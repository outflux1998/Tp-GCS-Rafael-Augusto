<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.cluster.hierarchy Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html">hierarchy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.cluster.hierarchy Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1_cluster_node.html">ClusterNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1_cluster_warning.html">ClusterWarning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a69eea798f07f7ac92c37f356d335d4cc" id="r_a69eea798f07f7ac92c37f356d335d4cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a69eea798f07f7ac92c37f356d335d4cc">_warning</a> (s)</td></tr>
<tr class="separator:a69eea798f07f7ac92c37f356d335d4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade238cc7c7575cf762edd4e36f531b78" id="r_ade238cc7c7575cf762edd4e36f531b78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ade238cc7c7575cf762edd4e36f531b78">_copy_array_if_base_present</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:ade238cc7c7575cf762edd4e36f531b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd63d3afe5ad26d1fc2fecb65916d283" id="r_afd63d3afe5ad26d1fc2fecb65916d283"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#afd63d3afe5ad26d1fc2fecb65916d283">_copy_arrays_if_base_present</a> (T)</td></tr>
<tr class="separator:afd63d3afe5ad26d1fc2fecb65916d283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715e2aa9866c1f8addc552106257dae4" id="r_a715e2aa9866c1f8addc552106257dae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a715e2aa9866c1f8addc552106257dae4">_randdm</a> (pnts)</td></tr>
<tr class="separator:a715e2aa9866c1f8addc552106257dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0362e93aa51d35d3895395af758fb5" id="r_a3d0362e93aa51d35d3895395af758fb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a3d0362e93aa51d35d3895395af758fb5">single</a> (y)</td></tr>
<tr class="separator:a3d0362e93aa51d35d3895395af758fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398b7760fa5a1f486daffed40154240e" id="r_a398b7760fa5a1f486daffed40154240e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a398b7760fa5a1f486daffed40154240e">complete</a> (y)</td></tr>
<tr class="separator:a398b7760fa5a1f486daffed40154240e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761f3af7ff4939e574d4dcd08a7bfcb0" id="r_a761f3af7ff4939e574d4dcd08a7bfcb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a761f3af7ff4939e574d4dcd08a7bfcb0">average</a> (y)</td></tr>
<tr class="separator:a761f3af7ff4939e574d4dcd08a7bfcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad844fae87f47ad5e14f827080c2c1aca" id="r_ad844fae87f47ad5e14f827080c2c1aca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ad844fae87f47ad5e14f827080c2c1aca">weighted</a> (y)</td></tr>
<tr class="separator:ad844fae87f47ad5e14f827080c2c1aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af078eaaf796754567d1ee58eac815eff" id="r_af078eaaf796754567d1ee58eac815eff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#af078eaaf796754567d1ee58eac815eff">centroid</a> (y)</td></tr>
<tr class="separator:af078eaaf796754567d1ee58eac815eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b4c53f5b1aa19afe45b628dcaf6840" id="r_a60b4c53f5b1aa19afe45b628dcaf6840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a60b4c53f5b1aa19afe45b628dcaf6840">median</a> (y)</td></tr>
<tr class="separator:a60b4c53f5b1aa19afe45b628dcaf6840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7226191ad03884e74134c8b8bde469ac" id="r_a7226191ad03884e74134c8b8bde469ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a7226191ad03884e74134c8b8bde469ac">ward</a> (y)</td></tr>
<tr class="separator:a7226191ad03884e74134c8b8bde469ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8b15e70c3130ac1b485b0dac18f23" id="r_ae9b8b15e70c3130ac1b485b0dac18f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ae9b8b15e70c3130ac1b485b0dac18f23">linkage</a> (y, method='<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a3d0362e93aa51d35d3895395af758fb5">single</a>', metric='euclidean', optimal_ordering=False)</td></tr>
<tr class="separator:ae9b8b15e70c3130ac1b485b0dac18f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b18fd6e3ee3157e0e803185d32b710" id="r_ae4b18fd6e3ee3157e0e803185d32b710"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ae4b18fd6e3ee3157e0e803185d32b710">_order_cluster_tree</a> (Z)</td></tr>
<tr class="separator:ae4b18fd6e3ee3157e0e803185d32b710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869cb447ba7c6b829c185a5c9aa50230" id="r_a869cb447ba7c6b829c185a5c9aa50230"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a869cb447ba7c6b829c185a5c9aa50230">cut_tree</a> (Z, n_clusters=None, height=None)</td></tr>
<tr class="separator:a869cb447ba7c6b829c185a5c9aa50230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e082a477afec3634282c40bd9b17eeb" id="r_a2e082a477afec3634282c40bd9b17eeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a2e082a477afec3634282c40bd9b17eeb">to_tree</a> (Z, rd=False)</td></tr>
<tr class="separator:a2e082a477afec3634282c40bd9b17eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e46d28bf6d0bd1f8c2e605bee4040a" id="r_ab5e46d28bf6d0bd1f8c2e605bee4040a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ab5e46d28bf6d0bd1f8c2e605bee4040a">optimal_leaf_ordering</a> (Z, y, metric='euclidean')</td></tr>
<tr class="separator:ab5e46d28bf6d0bd1f8c2e605bee4040a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f9b199e69c2153bc799145d5b4c2af" id="r_a29f9b199e69c2153bc799145d5b4c2af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a29f9b199e69c2153bc799145d5b4c2af">_convert_to_bool</a> (X)</td></tr>
<tr class="separator:a29f9b199e69c2153bc799145d5b4c2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a0af403878c70a65011e6f6b89f2a7" id="r_a20a0af403878c70a65011e6f6b89f2a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a20a0af403878c70a65011e6f6b89f2a7">_convert_to_double</a> (X)</td></tr>
<tr class="separator:a20a0af403878c70a65011e6f6b89f2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4084d497c98ada88f2085328520f2f60" id="r_a4084d497c98ada88f2085328520f2f60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a4084d497c98ada88f2085328520f2f60">cophenet</a> (Z, Y=None)</td></tr>
<tr class="separator:a4084d497c98ada88f2085328520f2f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae973440fe7f7bd476f26f178da6ad7f" id="r_aae973440fe7f7bd476f26f178da6ad7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aae973440fe7f7bd476f26f178da6ad7f">inconsistent</a> (Z, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>=2)</td></tr>
<tr class="separator:aae973440fe7f7bd476f26f178da6ad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb176e65cb46ba6d469032ba1eed50d" id="r_a3bb176e65cb46ba6d469032ba1eed50d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a3bb176e65cb46ba6d469032ba1eed50d">from_mlab_linkage</a> (Z)</td></tr>
<tr class="separator:a3bb176e65cb46ba6d469032ba1eed50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1942cfccf61cbbb35cc817abc093d8a3" id="r_a1942cfccf61cbbb35cc817abc093d8a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a1942cfccf61cbbb35cc817abc093d8a3">to_mlab_linkage</a> (Z)</td></tr>
<tr class="separator:a1942cfccf61cbbb35cc817abc093d8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba02ebb46b337c1f3abfcc826a97d9c" id="r_a6ba02ebb46b337c1f3abfcc826a97d9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a6ba02ebb46b337c1f3abfcc826a97d9c">is_monotonic</a> (Z)</td></tr>
<tr class="separator:a6ba02ebb46b337c1f3abfcc826a97d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0796ac2a7b5f353dd68958f983de3eeb" id="r_a0796ac2a7b5f353dd68958f983de3eeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a0796ac2a7b5f353dd68958f983de3eeb">is_valid_im</a> (R, warning=False, throw=False, name=None)</td></tr>
<tr class="separator:a0796ac2a7b5f353dd68958f983de3eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e368d4cd0ca27149553e321cdc1190c" id="r_a7e368d4cd0ca27149553e321cdc1190c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a7e368d4cd0ca27149553e321cdc1190c">is_valid_linkage</a> (Z, warning=False, throw=False, name=None)</td></tr>
<tr class="separator:a7e368d4cd0ca27149553e321cdc1190c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dd6bcec8ec5127f3520df488c78ae8" id="r_a39dd6bcec8ec5127f3520df488c78ae8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a39dd6bcec8ec5127f3520df488c78ae8">_check_hierarchy_uses_cluster_before_formed</a> (Z)</td></tr>
<tr class="separator:a39dd6bcec8ec5127f3520df488c78ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9219a94c8c3f707f90b00b4f0a962400" id="r_a9219a94c8c3f707f90b00b4f0a962400"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a9219a94c8c3f707f90b00b4f0a962400">_check_hierarchy_uses_cluster_more_than_once</a> (Z)</td></tr>
<tr class="separator:a9219a94c8c3f707f90b00b4f0a962400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee0f711da6fce752da806090d5d5f9f" id="r_a2ee0f711da6fce752da806090d5d5f9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a2ee0f711da6fce752da806090d5d5f9f">_check_hierarchy_not_all_clusters_used</a> (Z)</td></tr>
<tr class="separator:a2ee0f711da6fce752da806090d5d5f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725b5a843007245a8524e42c8293b913" id="r_a725b5a843007245a8524e42c8293b913"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a725b5a843007245a8524e42c8293b913">num_obs_linkage</a> (Z)</td></tr>
<tr class="separator:a725b5a843007245a8524e42c8293b913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a370417db125d267384d6e39cf75c4e" id="r_a8a370417db125d267384d6e39cf75c4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a8a370417db125d267384d6e39cf75c4e">correspond</a> (Z, Y)</td></tr>
<tr class="separator:a8a370417db125d267384d6e39cf75c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e31fbe2fa33eec7d23778b83b60a61" id="r_af6e31fbe2fa33eec7d23778b83b60a61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#af6e31fbe2fa33eec7d23778b83b60a61">fcluster</a> (Z, t, criterion='<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aae973440fe7f7bd476f26f178da6ad7f">inconsistent</a>', depth=2, R=None, monocrit=None)</td></tr>
<tr class="separator:af6e31fbe2fa33eec7d23778b83b60a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5987ff126b9d427ef17f702ffce6cc" id="r_a8e5987ff126b9d427ef17f702ffce6cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a8e5987ff126b9d427ef17f702ffce6cc">fclusterdata</a> (X, t, criterion='<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aae973440fe7f7bd476f26f178da6ad7f">inconsistent</a>', metric='euclidean', depth=2, method='<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a3d0362e93aa51d35d3895395af758fb5">single</a>', R=None)</td></tr>
<tr class="separator:a8e5987ff126b9d427ef17f702ffce6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54365dda4fda7dbb7e377a0ba626c8eb" id="r_a54365dda4fda7dbb7e377a0ba626c8eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a54365dda4fda7dbb7e377a0ba626c8eb">leaves_list</a> (Z)</td></tr>
<tr class="separator:a54365dda4fda7dbb7e377a0ba626c8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4de4074e40721ed1440ef2c067ae120" id="r_ad4de4074e40721ed1440ef2c067ae120"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ad4de4074e40721ed1440ef2c067ae120">_remove_dups</a> (L)</td></tr>
<tr class="separator:ad4de4074e40721ed1440ef2c067ae120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b97df9381d14a7e6762a2b8301895e" id="r_a67b97df9381d14a7e6762a2b8301895e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a67b97df9381d14a7e6762a2b8301895e">_get_tick_text_size</a> (p)</td></tr>
<tr class="separator:a67b97df9381d14a7e6762a2b8301895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71040b69c0049a9b6fe8e142fe3f0ab0" id="r_a71040b69c0049a9b6fe8e142fe3f0ab0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a71040b69c0049a9b6fe8e142fe3f0ab0">_get_tick_rotation</a> (p)</td></tr>
<tr class="separator:a71040b69c0049a9b6fe8e142fe3f0ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae105e6e65cddba4ee8c73aeaed36372b" id="r_ae105e6e65cddba4ee8c73aeaed36372b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ae105e6e65cddba4ee8c73aeaed36372b">_plot_dendrogram</a> (icoords, dcoords, ivl, p, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, mh, orientation, no_labels, color_list, leaf_font_size=None, leaf_rotation=None, contraction_marks=None, ax=None, above_threshold_color='C0')</td></tr>
<tr class="separator:ae105e6e65cddba4ee8c73aeaed36372b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10936aca9c1d0887f7a882f364fdf072" id="r_a10936aca9c1d0887f7a882f364fdf072"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a10936aca9c1d0887f7a882f364fdf072">set_link_color_palette</a> (palette)</td></tr>
<tr class="separator:a10936aca9c1d0887f7a882f364fdf072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5090a9f1ef7ef09ea50ae3685d671a08" id="r_a5090a9f1ef7ef09ea50ae3685d671a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a5090a9f1ef7ef09ea50ae3685d671a08">dendrogram</a> (Z, p=30, truncate_mode=None, color_threshold=None, get_leaves=True, orientation='top', labels=None, count_sort=False, distance_sort=False, show_leaf_counts=True, no_plot=False, no_labels=False, leaf_font_size=None, leaf_rotation=None, leaf_label_func=None, show_contracted=False, link_color_func=None, ax=None, above_threshold_color='C0')</td></tr>
<tr class="separator:a5090a9f1ef7ef09ea50ae3685d671a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295674906962ecfa4f1c33673897c3b7" id="r_a295674906962ecfa4f1c33673897c3b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a295674906962ecfa4f1c33673897c3b7">_get_leaves_color_list</a> (R)</td></tr>
<tr class="separator:a295674906962ecfa4f1c33673897c3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bcca8a18b9116ebd7a068180f6bd70" id="r_ab7bcca8a18b9116ebd7a068180f6bd70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ab7bcca8a18b9116ebd7a068180f6bd70">_append_singleton_leaf_node</a> (Z, p, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, level, lvs, ivl, leaf_label_func, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, labels)</td></tr>
<tr class="separator:ab7bcca8a18b9116ebd7a068180f6bd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67685daf201a7de78343a77f2828876" id="r_ae67685daf201a7de78343a77f2828876"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ae67685daf201a7de78343a77f2828876">_append_nonsingleton_leaf_node</a> (Z, p, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, level, lvs, ivl, leaf_label_func, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, labels, show_leaf_counts)</td></tr>
<tr class="separator:ae67685daf201a7de78343a77f2828876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfe2f2e6f0a328a9b2ea3da3f5d406c" id="r_afbfe2f2e6f0a328a9b2ea3da3f5d406c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#afbfe2f2e6f0a328a9b2ea3da3f5d406c">_append_contraction_marks</a> (Z, iv, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, contraction_marks)</td></tr>
<tr class="separator:afbfe2f2e6f0a328a9b2ea3da3f5d406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e9c7911fd649eaee77c58cb78db655" id="r_a07e9c7911fd649eaee77c58cb78db655"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a07e9c7911fd649eaee77c58cb78db655">_append_contraction_marks_sub</a> (Z, iv, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, contraction_marks)</td></tr>
<tr class="separator:a07e9c7911fd649eaee77c58cb78db655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ded49f2b974265b0b6d20494b05424" id="r_af8ded49f2b974265b0b6d20494b05424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#af8ded49f2b974265b0b6d20494b05424">_dendrogram_calculate_info</a> (Z, p, truncate_mode, color_threshold=np.inf, get_leaves=True, orientation='top', labels=None, count_sort=False, distance_sort=False, show_leaf_counts=False, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>=-1, iv=0.0, ivl=[], <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=0, icoord_list=[], dcoord_list=[], lvs=None, mhr=False, current_color=[], color_list=[], currently_below_threshold=[], leaf_label_func=None, level=0, contraction_marks=None, link_color_func=None, above_threshold_color='C0')</td></tr>
<tr class="separator:af8ded49f2b974265b0b6d20494b05424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d95f96e86090b51a7d13c81ae4a4fd" id="r_a82d95f96e86090b51a7d13c81ae4a4fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a82d95f96e86090b51a7d13c81ae4a4fd">is_isomorphic</a> (T1, T2)</td></tr>
<tr class="separator:a82d95f96e86090b51a7d13c81ae4a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bbec63e697c10ef5ad79ef91483621" id="r_a96bbec63e697c10ef5ad79ef91483621"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a96bbec63e697c10ef5ad79ef91483621">maxdists</a> (Z)</td></tr>
<tr class="separator:a96bbec63e697c10ef5ad79ef91483621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84328c677da43f757bd468f6060c926b" id="r_a84328c677da43f757bd468f6060c926b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a84328c677da43f757bd468f6060c926b">maxinconsts</a> (Z, R)</td></tr>
<tr class="separator:a84328c677da43f757bd468f6060c926b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9decd74c1e3c23a1d0ed9417e569b866" id="r_a9decd74c1e3c23a1d0ed9417e569b866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a9decd74c1e3c23a1d0ed9417e569b866">maxRstat</a> (Z, R, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>)</td></tr>
<tr class="separator:a9decd74c1e3c23a1d0ed9417e569b866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1847c24273484af16ed0642d57d5e3dc" id="r_a1847c24273484af16ed0642d57d5e3dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a1847c24273484af16ed0642d57d5e3dc">leaders</a> (Z, T)</td></tr>
<tr class="separator:a1847c24273484af16ed0642d57d5e3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a826723dda7579a0811e9dd6a6fac3259" id="r_a826723dda7579a0811e9dd6a6fac3259"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a826723dda7579a0811e9dd6a6fac3259">_LINKAGE_METHODS</a></td></tr>
<tr class="separator:a826723dda7579a0811e9dd6a6fac3259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ada639f32b594e8883367025e3f516c" id="r_a3ada639f32b594e8883367025e3f516c"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a3ada639f32b594e8883367025e3f516c">_EUCLIDEAN_METHODS</a> = ('<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#af078eaaf796754567d1ee58eac815eff">centroid</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a60b4c53f5b1aa19afe45b628dcaf6840">median</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a7226191ad03884e74134c8b8bde469ac">ward</a>')</td></tr>
<tr class="separator:a3ada639f32b594e8883367025e3f516c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476e625a81650e28e32bad1ad24efcf5" id="r_a476e625a81650e28e32bad1ad24efcf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a476e625a81650e28e32bad1ad24efcf5">_cnode_bare</a> = <a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1_cluster_node.html">ClusterNode</a>(0)</td></tr>
<tr class="separator:a476e625a81650e28e32bad1ad24efcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e6ed2ee8c7d83e9da01009dda7f74f" id="r_ac7e6ed2ee8c7d83e9da01009dda7f74f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ac7e6ed2ee8c7d83e9da01009dda7f74f">_cnode_type</a> = type(<a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1_cluster_node.html">ClusterNode</a>)</td></tr>
<tr class="separator:ac7e6ed2ee8c7d83e9da01009dda7f74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4486feb3a97520b8ac29af1c2690cd49" id="r_a4486feb3a97520b8ac29af1c2690cd49"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a4486feb3a97520b8ac29af1c2690cd49">_dtextsizes</a> = {20: 12, 30: 10, 50: 8, 85: 6, np.inf: 5}</td></tr>
<tr class="separator:a4486feb3a97520b8ac29af1c2690cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfa197c9179db51284830913704f0f0" id="r_aabfa197c9179db51284830913704f0f0"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aabfa197c9179db51284830913704f0f0">_drotation</a> = {20: 0, 40: 45, np.inf: 90}</td></tr>
<tr class="separator:aabfa197c9179db51284830913704f0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8615ce50b660d4fa36d168af87d88a" id="r_a2e8615ce50b660d4fa36d168af87d88a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a2e8615ce50b660d4fa36d168af87d88a">_dtextsortedkeys</a> = list(_dtextsizes.keys())</td></tr>
<tr class="separator:a2e8615ce50b660d4fa36d168af87d88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551341c8e94ec8af794985291c716354" id="r_a551341c8e94ec8af794985291c716354"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a551341c8e94ec8af794985291c716354">_drotationsortedkeys</a> = list(_drotation.keys())</td></tr>
<tr class="separator:a551341c8e94ec8af794985291c716354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfd11a02024f4440c25556201566cb0" id="r_aacfd11a02024f4440c25556201566cb0"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aacfd11a02024f4440c25556201566cb0">_link_line_colors_default</a> = ('C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9')</td></tr>
<tr class="separator:aacfd11a02024f4440c25556201566cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad943f16bba4262efdbd2ad1fe630c067" id="r_ad943f16bba4262efdbd2ad1fe630c067"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ad943f16bba4262efdbd2ad1fe630c067">_link_line_colors</a> = list(<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aacfd11a02024f4440c25556201566cb0">_link_line_colors_default</a>)</td></tr>
<tr class="separator:ad943f16bba4262efdbd2ad1fe630c067"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Hierarchical clustering (:mod:`scipy.cluster.hierarchy`)
========================================================

.. currentmodule:: scipy.cluster.hierarchy

These functions cut hierarchical clusterings into flat clusterings
or find the roots of the forest formed by a cut by providing the flat
cluster ids of each observation.

.. autosummary::
   :toctree: generated/

   fcluster
   fclusterdata
   leaders

These are routines for agglomerative clustering.

.. autosummary::
   :toctree: generated/

   linkage
   single
   complete
   average
   weighted
   centroid
   median
   ward

These routines compute statistics on hierarchies.

.. autosummary::
   :toctree: generated/

   cophenet
   from_mlab_linkage
   inconsistent
   maxinconsts
   maxdists
   maxRstat
   to_mlab_linkage

Routines for visualizing flat clusters.

.. autosummary::
   :toctree: generated/

   dendrogram

These are data structures and routines for representing hierarchies as
tree objects.

.. autosummary::
   :toctree: generated/

   ClusterNode
   leaves_list
   to_tree
   cut_tree
   optimal_leaf_ordering

These are predicates for checking the validity of linkage and
inconsistency matrices as well as for checking isomorphism of two
flat cluster assignments.

.. autosummary::
   :toctree: generated/

   is_valid_im
   is_valid_linkage
   is_isomorphic
   is_monotonic
   correspond
   num_obs_linkage

Utility routines for plotting:

.. autosummary::
   :toctree: generated/

   set_link_color_palette

Utility classes:

.. autosummary::
   :toctree: generated/

   DisjointSet -- data structure for incremental connectivity queries</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="afbfe2f2e6f0a328a9b2ea3da3f5d406c" name="afbfe2f2e6f0a328a9b2ea3da3f5d406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfe2f2e6f0a328a9b2ea3da3f5d406c">&#9670;&#160;</a></span>_append_contraction_marks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._append_contraction_marks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contraction_marks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3448</span><span class="keyword">def </span>_append_contraction_marks(Z, iv, i, n, contraction_marks):</div>
<div class="line"><span class="lineno"> 3449</span>    _append_contraction_marks_sub(Z, iv, int(Z[i - n, 0]), n, contraction_marks)</div>
<div class="line"><span class="lineno"> 3450</span>    _append_contraction_marks_sub(Z, iv, int(Z[i - n, 1]), n, contraction_marks)</div>
<div class="line"><span class="lineno"> 3451</span> </div>
<div class="line"><span class="lineno"> 3452</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a07e9c7911fd649eaee77c58cb78db655" name="a07e9c7911fd649eaee77c58cb78db655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e9c7911fd649eaee77c58cb78db655">&#9670;&#160;</a></span>_append_contraction_marks_sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._append_contraction_marks_sub </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contraction_marks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3453</span><span class="keyword">def </span>_append_contraction_marks_sub(Z, iv, i, n, contraction_marks):</div>
<div class="line"><span class="lineno"> 3454</span>    <span class="keywordflow">if</span> i &gt;= n:</div>
<div class="line"><span class="lineno"> 3455</span>        contraction_marks.append((iv, Z[i - n, 2]))</div>
<div class="line"><span class="lineno"> 3456</span>        _append_contraction_marks_sub(Z, iv, int(Z[i - n, 0]), n, contraction_marks)</div>
<div class="line"><span class="lineno"> 3457</span>        _append_contraction_marks_sub(Z, iv, int(Z[i - n, 1]), n, contraction_marks)</div>
<div class="line"><span class="lineno"> 3458</span> </div>
<div class="line"><span class="lineno"> 3459</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae67685daf201a7de78343a77f2828876" name="ae67685daf201a7de78343a77f2828876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67685daf201a7de78343a77f2828876">&#9670;&#160;</a></span>_append_nonsingleton_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._append_nonsingleton_leaf_node </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ivl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_label_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>show_leaf_counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3431</span>                                   i, labels, show_leaf_counts):</div>
<div class="line"><span class="lineno"> 3432</span>    <span class="comment"># If the leaf id structure is not None and is a list then the caller</span></div>
<div class="line"><span class="lineno"> 3433</span>    <span class="comment"># to dendrogram has indicated that cluster id&#39;s corresponding to the</span></div>
<div class="line"><span class="lineno"> 3434</span>    <span class="comment"># leaf nodes should be recorded.</span></div>
<div class="line"><span class="lineno"> 3435</span> </div>
<div class="line"><span class="lineno"> 3436</span>    <span class="keywordflow">if</span> lvs <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3437</span>        lvs.append(int(i))</div>
<div class="line"><span class="lineno"> 3438</span>    <span class="keywordflow">if</span> ivl <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3439</span>        <span class="keywordflow">if</span> leaf_label_func:</div>
<div class="line"><span class="lineno"> 3440</span>            ivl.append(leaf_label_func(int(i)))</div>
<div class="line"><span class="lineno"> 3441</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3442</span>            <span class="keywordflow">if</span> show_leaf_counts:</div>
<div class="line"><span class="lineno"> 3443</span>                ivl.append(<span class="stringliteral">&quot;(&quot;</span> + str(int(Z[i - n, 3])) + <span class="stringliteral">&quot;)&quot;</span>)</div>
<div class="line"><span class="lineno"> 3444</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3445</span>                ivl.append(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno"> 3446</span> </div>
<div class="line"><span class="lineno"> 3447</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7bcca8a18b9116ebd7a068180f6bd70" name="ab7bcca8a18b9116ebd7a068180f6bd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bcca8a18b9116ebd7a068180f6bd70">&#9670;&#160;</a></span>_append_singleton_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._append_singleton_leaf_node </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ivl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_label_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3405</span>                                i, labels):</div>
<div class="line"><span class="lineno"> 3406</span>    <span class="comment"># If the leaf id structure is not None and is a list then the caller</span></div>
<div class="line"><span class="lineno"> 3407</span>    <span class="comment"># to dendrogram has indicated that cluster id&#39;s corresponding to the</span></div>
<div class="line"><span class="lineno"> 3408</span>    <span class="comment"># leaf nodes should be recorded.</span></div>
<div class="line"><span class="lineno"> 3409</span> </div>
<div class="line"><span class="lineno"> 3410</span>    <span class="keywordflow">if</span> lvs <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3411</span>        lvs.append(int(i))</div>
<div class="line"><span class="lineno"> 3412</span> </div>
<div class="line"><span class="lineno"> 3413</span>    <span class="comment"># If leaf node labels are to be displayed...</span></div>
<div class="line"><span class="lineno"> 3414</span>    <span class="keywordflow">if</span> ivl <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3415</span>        <span class="comment"># If a leaf_label_func has been provided, the label comes from the</span></div>
<div class="line"><span class="lineno"> 3416</span>        <span class="comment"># string returned from the leaf_label_func, which is a function</span></div>
<div class="line"><span class="lineno"> 3417</span>        <span class="comment"># passed to dendrogram.</span></div>
<div class="line"><span class="lineno"> 3418</span>        <span class="keywordflow">if</span> leaf_label_func:</div>
<div class="line"><span class="lineno"> 3419</span>            ivl.append(leaf_label_func(int(i)))</div>
<div class="line"><span class="lineno"> 3420</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3421</span>            <span class="comment"># Otherwise, if the dendrogram caller has passed a labels list</span></div>
<div class="line"><span class="lineno"> 3422</span>            <span class="comment"># for the leaf nodes, use it.</span></div>
<div class="line"><span class="lineno"> 3423</span>            <span class="keywordflow">if</span> labels <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3424</span>                ivl.append(labels[int(i - n)])</div>
<div class="line"><span class="lineno"> 3425</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3426</span>                <span class="comment"># Otherwise, use the id as the label for the leaf.x</span></div>
<div class="line"><span class="lineno"> 3427</span>                ivl.append(str(int(i)))</div>
<div class="line"><span class="lineno"> 3428</span> </div>
<div class="line"><span class="lineno"> 3429</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ee0f711da6fce752da806090d5d5f9f" name="a2ee0f711da6fce752da806090d5d5f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee0f711da6fce752da806090d5d5f9f">&#9670;&#160;</a></span>_check_hierarchy_not_all_clusters_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._check_hierarchy_not_all_clusters_used </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2322</span><span class="keyword">def </span>_check_hierarchy_not_all_clusters_used(Z):</div>
<div class="line"><span class="lineno"> 2323</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 2324</span>    chosen = set([])</div>
<div class="line"><span class="lineno"> 2325</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, n - 1):</div>
<div class="line"><span class="lineno"> 2326</span>        chosen.add(int(Z[i, 0]))</div>
<div class="line"><span class="lineno"> 2327</span>        chosen.add(int(Z[i, 1]))</div>
<div class="line"><span class="lineno"> 2328</span>    must_chosen = set(range(0, 2 * n - 2))</div>
<div class="line"><span class="lineno"> 2329</span>    <span class="keywordflow">return</span> len(must_chosen.difference(chosen)) &gt; 0</div>
<div class="line"><span class="lineno"> 2330</span> </div>
<div class="line"><span class="lineno"> 2331</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a39dd6bcec8ec5127f3520df488c78ae8" name="a39dd6bcec8ec5127f3520df488c78ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dd6bcec8ec5127f3520df488c78ae8">&#9670;&#160;</a></span>_check_hierarchy_uses_cluster_before_formed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._check_hierarchy_uses_cluster_before_formed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2303</span><span class="keyword">def </span>_check_hierarchy_uses_cluster_before_formed(Z):</div>
<div class="line"><span class="lineno"> 2304</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 2305</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, n - 1):</div>
<div class="line"><span class="lineno"> 2306</span>        <span class="keywordflow">if</span> Z[i, 0] &gt;= n + i <span class="keywordflow">or</span> Z[i, 1] &gt;= n + i:</div>
<div class="line"><span class="lineno"> 2307</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2308</span>    <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2309</span> </div>
<div class="line"><span class="lineno"> 2310</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9219a94c8c3f707f90b00b4f0a962400" name="a9219a94c8c3f707f90b00b4f0a962400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9219a94c8c3f707f90b00b4f0a962400">&#9670;&#160;</a></span>_check_hierarchy_uses_cluster_more_than_once()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._check_hierarchy_uses_cluster_more_than_once </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2311</span><span class="keyword">def </span>_check_hierarchy_uses_cluster_more_than_once(Z):</div>
<div class="line"><span class="lineno"> 2312</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 2313</span>    chosen = set([])</div>
<div class="line"><span class="lineno"> 2314</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, n - 1):</div>
<div class="line"><span class="lineno"> 2315</span>        <span class="keywordflow">if</span> (Z[i, 0] <span class="keywordflow">in</span> chosen) <span class="keywordflow">or</span> (Z[i, 1] <span class="keywordflow">in</span> chosen) <span class="keywordflow">or</span> Z[i, 0] == Z[i, 1]:</div>
<div class="line"><span class="lineno"> 2316</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2317</span>        chosen.add(Z[i, 0])</div>
<div class="line"><span class="lineno"> 2318</span>        chosen.add(Z[i, 1])</div>
<div class="line"><span class="lineno"> 2319</span>    <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2320</span> </div>
<div class="line"><span class="lineno"> 2321</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a29f9b199e69c2153bc799145d5b4c2af" name="a29f9b199e69c2153bc799145d5b4c2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f9b199e69c2153bc799145d5b4c2af">&#9670;&#160;</a></span>_convert_to_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._convert_to_bool </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1562</span><span class="keyword">def </span>_convert_to_bool(X):</div>
<div class="line"><span class="lineno"> 1563</span>    <span class="keywordflow">if</span> X.dtype != bool:</div>
<div class="line"><span class="lineno"> 1564</span>        X = X.astype(bool)</div>
<div class="line"><span class="lineno"> 1565</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> X.flags.contiguous:</div>
<div class="line"><span class="lineno"> 1566</span>        X = X.copy()</div>
<div class="line"><span class="lineno"> 1567</span>    <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno"> 1568</span> </div>
<div class="line"><span class="lineno"> 1569</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a20a0af403878c70a65011e6f6b89f2a7" name="a20a0af403878c70a65011e6f6b89f2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a0af403878c70a65011e6f6b89f2a7">&#9670;&#160;</a></span>_convert_to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._convert_to_double </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1570</span><span class="keyword">def </span>_convert_to_double(X):</div>
<div class="line"><span class="lineno"> 1571</span>    <span class="keywordflow">if</span> X.dtype != np.double:</div>
<div class="line"><span class="lineno"> 1572</span>        X = X.astype(np.double)</div>
<div class="line"><span class="lineno"> 1573</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> X.flags.contiguous:</div>
<div class="line"><span class="lineno"> 1574</span>        X = X.copy()</div>
<div class="line"><span class="lineno"> 1575</span>    <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno"> 1576</span> </div>
<div class="line"><span class="lineno"> 1577</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ade238cc7c7575cf762edd4e36f531b78" name="ade238cc7c7575cf762edd4e36f531b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade238cc7c7575cf762edd4e36f531b78">&#9670;&#160;</a></span>_copy_array_if_base_present()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._copy_array_if_base_present </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Copy the array if its base points to a parent array.
</pre> <div class="fragment"><div class="line"><span class="lineno">  162</span><span class="keyword">def </span>_copy_array_if_base_present(a):</div>
<div class="line"><span class="lineno">  163</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    Copy the array if its base points to a parent array.</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  166</span>    <span class="keywordflow">if</span> a.base <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  167</span>        <span class="keywordflow">return</span> a.copy()</div>
<div class="line"><span class="lineno">  168</span>    <span class="keywordflow">elif</span> np.issubsctype(a, np.float32):</div>
<div class="line"><span class="lineno">  169</span>        <span class="keywordflow">return</span> np.array(a, dtype=np.double)</div>
<div class="line"><span class="lineno">  170</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afd63d3afe5ad26d1fc2fecb65916d283" name="afd63d3afe5ad26d1fc2fecb65916d283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd63d3afe5ad26d1fc2fecb65916d283">&#9670;&#160;</a></span>_copy_arrays_if_base_present()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._copy_arrays_if_base_present </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Accept a tuple of arrays T. Copies the array T[i] if its base array
points to an actual array. Otherwise, the reference is just copied.
This is useful if the arrays are being passed to a C function that
does not do proper striding.
</pre> <div class="fragment"><div class="line"><span class="lineno">  174</span><span class="keyword">def </span>_copy_arrays_if_base_present(T):</div>
<div class="line"><span class="lineno">  175</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    Accept a tuple of arrays T. Copies the array T[i] if its base array</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    points to an actual array. Otherwise, the reference is just copied.</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    This is useful if the arrays are being passed to a C function that</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    does not do proper striding.</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  181</span>    l = [_copy_array_if_base_present(a) <span class="keywordflow">for</span> a <span class="keywordflow">in</span> T]</div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordflow">return</span> l</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af8ded49f2b974265b0b6d20494b05424" name="af8ded49f2b974265b0b6d20494b05424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ded49f2b974265b0b6d20494b05424">&#9670;&#160;</a></span>_dendrogram_calculate_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._dendrogram_calculate_info </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>truncate_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>color_threshold</em> = <code>np.inf</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>get_leaves</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orientation</em> = <code>'top'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count_sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance_sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>show_leaf_counts</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iv</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ivl</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>icoord_list</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dcoord_list</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lvs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mhr</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>current_color</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>color_list</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>currently_below_threshold</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_label_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contraction_marks</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>link_color_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>above_threshold_color</em> = <code>'C0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate the endpoints of the links as well as the labels for the
the dendrogram rooted at the node with index i. iv is the independent
variable value to plot the left-most leaf node below the root node i
(if orientation='top', this would be the left-most x value where the
plotting of this root node i and its descendents should begin).

ivl is a list to store the labels of the leaf nodes. The leaf_label_func
is called whenever ivl != None, labels == None, and
leaf_label_func != None. When ivl != None and labels != None, the
labels list is used only for labeling the leaf nodes. When
ivl == None, no labels are generated for leaf nodes.

When get_leaves==True, a list of leaves is built as they are visited
in the dendrogram.

Returns a tuple with l being the independent variable coordinate that
corresponds to the midpoint of cluster to the left of cluster i if
i is non-singleton, otherwise the independent coordinate of the leaf
node if i is a leaf node.

Returns
-------
A tuple (left, w, h, md), where:
    * left is the independent variable coordinate of the center of the
      the U of the subtree

    * w is the amount of space used for the subtree (in independent
      variable units)

    * h is the height of the subtree in dependent variable units

    * md is the ``max(Z[*,2]``) for all nodes ``*`` below and including
      the target node.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3472</span>                               above_threshold_color=<span class="stringliteral">&#39;C0&#39;</span>):</div>
<div class="line"><span class="lineno"> 3473</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3474</span><span class="stringliteral">    Calculate the endpoints of the links as well as the labels for the</span></div>
<div class="line"><span class="lineno"> 3475</span><span class="stringliteral">    the dendrogram rooted at the node with index i. iv is the independent</span></div>
<div class="line"><span class="lineno"> 3476</span><span class="stringliteral">    variable value to plot the left-most leaf node below the root node i</span></div>
<div class="line"><span class="lineno"> 3477</span><span class="stringliteral">    (if orientation=&#39;top&#39;, this would be the left-most x value where the</span></div>
<div class="line"><span class="lineno"> 3478</span><span class="stringliteral">    plotting of this root node i and its descendents should begin).</span></div>
<div class="line"><span class="lineno"> 3479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3480</span><span class="stringliteral">    ivl is a list to store the labels of the leaf nodes. The leaf_label_func</span></div>
<div class="line"><span class="lineno"> 3481</span><span class="stringliteral">    is called whenever ivl != None, labels == None, and</span></div>
<div class="line"><span class="lineno"> 3482</span><span class="stringliteral">    leaf_label_func != None. When ivl != None and labels != None, the</span></div>
<div class="line"><span class="lineno"> 3483</span><span class="stringliteral">    labels list is used only for labeling the leaf nodes. When</span></div>
<div class="line"><span class="lineno"> 3484</span><span class="stringliteral">    ivl == None, no labels are generated for leaf nodes.</span></div>
<div class="line"><span class="lineno"> 3485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3486</span><span class="stringliteral">    When get_leaves==True, a list of leaves is built as they are visited</span></div>
<div class="line"><span class="lineno"> 3487</span><span class="stringliteral">    in the dendrogram.</span></div>
<div class="line"><span class="lineno"> 3488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3489</span><span class="stringliteral">    Returns a tuple with l being the independent variable coordinate that</span></div>
<div class="line"><span class="lineno"> 3490</span><span class="stringliteral">    corresponds to the midpoint of cluster to the left of cluster i if</span></div>
<div class="line"><span class="lineno"> 3491</span><span class="stringliteral">    i is non-singleton, otherwise the independent coordinate of the leaf</span></div>
<div class="line"><span class="lineno"> 3492</span><span class="stringliteral">    node if i is a leaf node.</span></div>
<div class="line"><span class="lineno"> 3493</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3494</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3495</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3496</span><span class="stringliteral">    A tuple (left, w, h, md), where:</span></div>
<div class="line"><span class="lineno"> 3497</span><span class="stringliteral">        * left is the independent variable coordinate of the center of the</span></div>
<div class="line"><span class="lineno"> 3498</span><span class="stringliteral">          the U of the subtree</span></div>
<div class="line"><span class="lineno"> 3499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3500</span><span class="stringliteral">        * w is the amount of space used for the subtree (in independent</span></div>
<div class="line"><span class="lineno"> 3501</span><span class="stringliteral">          variable units)</span></div>
<div class="line"><span class="lineno"> 3502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3503</span><span class="stringliteral">        * h is the height of the subtree in dependent variable units</span></div>
<div class="line"><span class="lineno"> 3504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3505</span><span class="stringliteral">        * md is the ``max(Z[*,2]``) for all nodes ``*`` below and including</span></div>
<div class="line"><span class="lineno"> 3506</span><span class="stringliteral">          the target node.</span></div>
<div class="line"><span class="lineno"> 3507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3508</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3509</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno"> 3510</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid singleton cluster count n.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3511</span> </div>
<div class="line"><span class="lineno"> 3512</span>    <span class="keywordflow">if</span> i == -1:</div>
<div class="line"><span class="lineno"> 3513</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid root cluster index i.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3514</span> </div>
<div class="line"><span class="lineno"> 3515</span>    <span class="keywordflow">if</span> truncate_mode == <span class="stringliteral">&#39;lastp&#39;</span>:</div>
<div class="line"><span class="lineno"> 3516</span>        <span class="comment"># If the node is a leaf node but corresponds to a non-singleton</span></div>
<div class="line"><span class="lineno"> 3517</span>        <span class="comment"># cluster, its label is either the empty string or the number of</span></div>
<div class="line"><span class="lineno"> 3518</span>        <span class="comment"># original observations belonging to cluster i.</span></div>
<div class="line"><span class="lineno"> 3519</span>        <span class="keywordflow">if</span> 2*n - p &gt; i &gt;= n:</div>
<div class="line"><span class="lineno"> 3520</span>            d = Z[i - n, 2]</div>
<div class="line"><span class="lineno"> 3521</span>            _append_nonsingleton_leaf_node(Z, p, n, level, lvs, ivl,</div>
<div class="line"><span class="lineno"> 3522</span>                                           leaf_label_func, i, labels,</div>
<div class="line"><span class="lineno"> 3523</span>                                           show_leaf_counts)</div>
<div class="line"><span class="lineno"> 3524</span>            <span class="keywordflow">if</span> contraction_marks <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3525</span>                _append_contraction_marks(Z, iv + 5.0, i, n, contraction_marks)</div>
<div class="line"><span class="lineno"> 3526</span>            <span class="keywordflow">return</span> (iv + 5.0, 10.0, 0.0, d)</div>
<div class="line"><span class="lineno"> 3527</span>        <span class="keywordflow">elif</span> i &lt; n:</div>
<div class="line"><span class="lineno"> 3528</span>            _append_singleton_leaf_node(Z, p, n, level, lvs, ivl,</div>
<div class="line"><span class="lineno"> 3529</span>                                        leaf_label_func, i, labels)</div>
<div class="line"><span class="lineno"> 3530</span>            <span class="keywordflow">return</span> (iv + 5.0, 10.0, 0.0, 0.0)</div>
<div class="line"><span class="lineno"> 3531</span>    <span class="keywordflow">elif</span> truncate_mode == <span class="stringliteral">&#39;level&#39;</span>:</div>
<div class="line"><span class="lineno"> 3532</span>        <span class="keywordflow">if</span> i &gt; n <span class="keywordflow">and</span> level &gt; p:</div>
<div class="line"><span class="lineno"> 3533</span>            d = Z[i - n, 2]</div>
<div class="line"><span class="lineno"> 3534</span>            _append_nonsingleton_leaf_node(Z, p, n, level, lvs, ivl,</div>
<div class="line"><span class="lineno"> 3535</span>                                           leaf_label_func, i, labels,</div>
<div class="line"><span class="lineno"> 3536</span>                                           show_leaf_counts)</div>
<div class="line"><span class="lineno"> 3537</span>            <span class="keywordflow">if</span> contraction_marks <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3538</span>                _append_contraction_marks(Z, iv + 5.0, i, n, contraction_marks)</div>
<div class="line"><span class="lineno"> 3539</span>            <span class="keywordflow">return</span> (iv + 5.0, 10.0, 0.0, d)</div>
<div class="line"><span class="lineno"> 3540</span>        <span class="keywordflow">elif</span> i &lt; n:</div>
<div class="line"><span class="lineno"> 3541</span>            _append_singleton_leaf_node(Z, p, n, level, lvs, ivl,</div>
<div class="line"><span class="lineno"> 3542</span>                                        leaf_label_func, i, labels)</div>
<div class="line"><span class="lineno"> 3543</span>            <span class="keywordflow">return</span> (iv + 5.0, 10.0, 0.0, 0.0)</div>
<div class="line"><span class="lineno"> 3544</span> </div>
<div class="line"><span class="lineno"> 3545</span>    <span class="comment"># Otherwise, only truncate if we have a leaf node.</span></div>
<div class="line"><span class="lineno"> 3546</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3547</span>    <span class="comment"># Only place leaves if they correspond to original observations.</span></div>
<div class="line"><span class="lineno"> 3548</span>    <span class="keywordflow">if</span> i &lt; n:</div>
<div class="line"><span class="lineno"> 3549</span>        _append_singleton_leaf_node(Z, p, n, level, lvs, ivl,</div>
<div class="line"><span class="lineno"> 3550</span>                                    leaf_label_func, i, labels)</div>
<div class="line"><span class="lineno"> 3551</span>        <span class="keywordflow">return</span> (iv + 5.0, 10.0, 0.0, 0.0)</div>
<div class="line"><span class="lineno"> 3552</span> </div>
<div class="line"><span class="lineno"> 3553</span>    <span class="comment"># !!! Otherwise, we don&#39;t have a leaf node, so work on plotting a</span></div>
<div class="line"><span class="lineno"> 3554</span>    <span class="comment"># non-leaf node.</span></div>
<div class="line"><span class="lineno"> 3555</span>    <span class="comment"># Actual indices of a and b</span></div>
<div class="line"><span class="lineno"> 3556</span>    aa = int(Z[i - n, 0])</div>
<div class="line"><span class="lineno"> 3557</span>    ab = int(Z[i - n, 1])</div>
<div class="line"><span class="lineno"> 3558</span>    <span class="keywordflow">if</span> aa &gt;= n:</div>
<div class="line"><span class="lineno"> 3559</span>        <span class="comment"># The number of singletons below cluster a</span></div>
<div class="line"><span class="lineno"> 3560</span>        na = Z[aa - n, 3]</div>
<div class="line"><span class="lineno"> 3561</span>        <span class="comment"># The distance between a&#39;s two direct children.</span></div>
<div class="line"><span class="lineno"> 3562</span>        da = Z[aa - n, 2]</div>
<div class="line"><span class="lineno"> 3563</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3564</span>        na = 1</div>
<div class="line"><span class="lineno"> 3565</span>        da = 0.0</div>
<div class="line"><span class="lineno"> 3566</span>    <span class="keywordflow">if</span> ab &gt;= n:</div>
<div class="line"><span class="lineno"> 3567</span>        nb = Z[ab - n, 3]</div>
<div class="line"><span class="lineno"> 3568</span>        db = Z[ab - n, 2]</div>
<div class="line"><span class="lineno"> 3569</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3570</span>        nb = 1</div>
<div class="line"><span class="lineno"> 3571</span>        db = 0.0</div>
<div class="line"><span class="lineno"> 3572</span> </div>
<div class="line"><span class="lineno"> 3573</span>    <span class="keywordflow">if</span> count_sort == <span class="stringliteral">&#39;ascending&#39;</span> <span class="keywordflow">or</span> count_sort == <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno"> 3574</span>        <span class="comment"># If a has a count greater than b, it and its descendents should</span></div>
<div class="line"><span class="lineno"> 3575</span>        <span class="comment"># be drawn to the right. Otherwise, to the left.</span></div>
<div class="line"><span class="lineno"> 3576</span>        <span class="keywordflow">if</span> na &gt; nb:</div>
<div class="line"><span class="lineno"> 3577</span>            <span class="comment"># The cluster index to draw to the left (ua) will be ab</span></div>
<div class="line"><span class="lineno"> 3578</span>            <span class="comment"># and the one to draw to the right (ub) will be aa</span></div>
<div class="line"><span class="lineno"> 3579</span>            ua = ab</div>
<div class="line"><span class="lineno"> 3580</span>            ub = aa</div>
<div class="line"><span class="lineno"> 3581</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3582</span>            ua = aa</div>
<div class="line"><span class="lineno"> 3583</span>            ub = ab</div>
<div class="line"><span class="lineno"> 3584</span>    <span class="keywordflow">elif</span> count_sort == <span class="stringliteral">&#39;descending&#39;</span>:</div>
<div class="line"><span class="lineno"> 3585</span>        <span class="comment"># If a has a count less than or equal to b, it and its</span></div>
<div class="line"><span class="lineno"> 3586</span>        <span class="comment"># descendents should be drawn to the left. Otherwise, to</span></div>
<div class="line"><span class="lineno"> 3587</span>        <span class="comment"># the right.</span></div>
<div class="line"><span class="lineno"> 3588</span>        <span class="keywordflow">if</span> na &gt; nb:</div>
<div class="line"><span class="lineno"> 3589</span>            ua = aa</div>
<div class="line"><span class="lineno"> 3590</span>            ub = ab</div>
<div class="line"><span class="lineno"> 3591</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3592</span>            ua = ab</div>
<div class="line"><span class="lineno"> 3593</span>            ub = aa</div>
<div class="line"><span class="lineno"> 3594</span>    <span class="keywordflow">elif</span> distance_sort == <span class="stringliteral">&#39;ascending&#39;</span> <span class="keywordflow">or</span> distance_sort == <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno"> 3595</span>        <span class="comment"># If a has a distance greater than b, it and its descendents should</span></div>
<div class="line"><span class="lineno"> 3596</span>        <span class="comment"># be drawn to the right. Otherwise, to the left.</span></div>
<div class="line"><span class="lineno"> 3597</span>        <span class="keywordflow">if</span> da &gt; db:</div>
<div class="line"><span class="lineno"> 3598</span>            ua = ab</div>
<div class="line"><span class="lineno"> 3599</span>            ub = aa</div>
<div class="line"><span class="lineno"> 3600</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3601</span>            ua = aa</div>
<div class="line"><span class="lineno"> 3602</span>            ub = ab</div>
<div class="line"><span class="lineno"> 3603</span>    <span class="keywordflow">elif</span> distance_sort == <span class="stringliteral">&#39;descending&#39;</span>:</div>
<div class="line"><span class="lineno"> 3604</span>        <span class="comment"># If a has a distance less than or equal to b, it and its</span></div>
<div class="line"><span class="lineno"> 3605</span>        <span class="comment"># descendents should be drawn to the left. Otherwise, to</span></div>
<div class="line"><span class="lineno"> 3606</span>        <span class="comment"># the right.</span></div>
<div class="line"><span class="lineno"> 3607</span>        <span class="keywordflow">if</span> da &gt; db:</div>
<div class="line"><span class="lineno"> 3608</span>            ua = aa</div>
<div class="line"><span class="lineno"> 3609</span>            ub = ab</div>
<div class="line"><span class="lineno"> 3610</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3611</span>            ua = ab</div>
<div class="line"><span class="lineno"> 3612</span>            ub = aa</div>
<div class="line"><span class="lineno"> 3613</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3614</span>        ua = aa</div>
<div class="line"><span class="lineno"> 3615</span>        ub = ab</div>
<div class="line"><span class="lineno"> 3616</span> </div>
<div class="line"><span class="lineno"> 3617</span>    <span class="comment"># Updated iv variable and the amount of space used.</span></div>
<div class="line"><span class="lineno"> 3618</span>    (uiva, uwa, uah, uamd) = \</div>
<div class="line"><span class="lineno"> 3619</span>        _dendrogram_calculate_info(</div>
<div class="line"><span class="lineno"> 3620</span>            Z=Z, p=p,</div>
<div class="line"><span class="lineno"> 3621</span>            truncate_mode=truncate_mode,</div>
<div class="line"><span class="lineno"> 3622</span>            color_threshold=color_threshold,</div>
<div class="line"><span class="lineno"> 3623</span>            get_leaves=get_leaves,</div>
<div class="line"><span class="lineno"> 3624</span>            orientation=orientation,</div>
<div class="line"><span class="lineno"> 3625</span>            labels=labels,</div>
<div class="line"><span class="lineno"> 3626</span>            count_sort=count_sort,</div>
<div class="line"><span class="lineno"> 3627</span>            distance_sort=distance_sort,</div>
<div class="line"><span class="lineno"> 3628</span>            show_leaf_counts=show_leaf_counts,</div>
<div class="line"><span class="lineno"> 3629</span>            i=ua, iv=iv, ivl=ivl, n=n,</div>
<div class="line"><span class="lineno"> 3630</span>            icoord_list=icoord_list,</div>
<div class="line"><span class="lineno"> 3631</span>            dcoord_list=dcoord_list, lvs=lvs,</div>
<div class="line"><span class="lineno"> 3632</span>            current_color=current_color,</div>
<div class="line"><span class="lineno"> 3633</span>            color_list=color_list,</div>
<div class="line"><span class="lineno"> 3634</span>            currently_below_threshold=currently_below_threshold,</div>
<div class="line"><span class="lineno"> 3635</span>            leaf_label_func=leaf_label_func,</div>
<div class="line"><span class="lineno"> 3636</span>            level=level + 1, contraction_marks=contraction_marks,</div>
<div class="line"><span class="lineno"> 3637</span>            link_color_func=link_color_func,</div>
<div class="line"><span class="lineno"> 3638</span>            above_threshold_color=above_threshold_color)</div>
<div class="line"><span class="lineno"> 3639</span> </div>
<div class="line"><span class="lineno"> 3640</span>    h = Z[i - n, 2]</div>
<div class="line"><span class="lineno"> 3641</span>    <span class="keywordflow">if</span> h &gt;= color_threshold <span class="keywordflow">or</span> color_threshold &lt;= 0:</div>
<div class="line"><span class="lineno"> 3642</span>        c = above_threshold_color</div>
<div class="line"><span class="lineno"> 3643</span> </div>
<div class="line"><span class="lineno"> 3644</span>        <span class="keywordflow">if</span> currently_below_threshold[0]:</div>
<div class="line"><span class="lineno"> 3645</span>            current_color[0] = (current_color[0] + 1) % len(_link_line_colors)</div>
<div class="line"><span class="lineno"> 3646</span>        currently_below_threshold[0] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3647</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3648</span>        currently_below_threshold[0] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3649</span>        c = _link_line_colors[current_color[0]]</div>
<div class="line"><span class="lineno"> 3650</span> </div>
<div class="line"><span class="lineno"> 3651</span>    (uivb, uwb, ubh, ubmd) = \</div>
<div class="line"><span class="lineno"> 3652</span>        _dendrogram_calculate_info(</div>
<div class="line"><span class="lineno"> 3653</span>            Z=Z, p=p,</div>
<div class="line"><span class="lineno"> 3654</span>            truncate_mode=truncate_mode,</div>
<div class="line"><span class="lineno"> 3655</span>            color_threshold=color_threshold,</div>
<div class="line"><span class="lineno"> 3656</span>            get_leaves=get_leaves,</div>
<div class="line"><span class="lineno"> 3657</span>            orientation=orientation,</div>
<div class="line"><span class="lineno"> 3658</span>            labels=labels,</div>
<div class="line"><span class="lineno"> 3659</span>            count_sort=count_sort,</div>
<div class="line"><span class="lineno"> 3660</span>            distance_sort=distance_sort,</div>
<div class="line"><span class="lineno"> 3661</span>            show_leaf_counts=show_leaf_counts,</div>
<div class="line"><span class="lineno"> 3662</span>            i=ub, iv=iv + uwa, ivl=ivl, n=n,</div>
<div class="line"><span class="lineno"> 3663</span>            icoord_list=icoord_list,</div>
<div class="line"><span class="lineno"> 3664</span>            dcoord_list=dcoord_list, lvs=lvs,</div>
<div class="line"><span class="lineno"> 3665</span>            current_color=current_color,</div>
<div class="line"><span class="lineno"> 3666</span>            color_list=color_list,</div>
<div class="line"><span class="lineno"> 3667</span>            currently_below_threshold=currently_below_threshold,</div>
<div class="line"><span class="lineno"> 3668</span>            leaf_label_func=leaf_label_func,</div>
<div class="line"><span class="lineno"> 3669</span>            level=level + 1, contraction_marks=contraction_marks,</div>
<div class="line"><span class="lineno"> 3670</span>            link_color_func=link_color_func,</div>
<div class="line"><span class="lineno"> 3671</span>            above_threshold_color=above_threshold_color)</div>
<div class="line"><span class="lineno"> 3672</span> </div>
<div class="line"><span class="lineno"> 3673</span>    max_dist = max(uamd, ubmd, h)</div>
<div class="line"><span class="lineno"> 3674</span> </div>
<div class="line"><span class="lineno"> 3675</span>    icoord_list.append([uiva, uiva, uivb, uivb])</div>
<div class="line"><span class="lineno"> 3676</span>    dcoord_list.append([uah, h, h, ubh])</div>
<div class="line"><span class="lineno"> 3677</span>    <span class="keywordflow">if</span> link_color_func <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3678</span>        v = link_color_func(int(i))</div>
<div class="line"><span class="lineno"> 3679</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(v, str):</div>
<div class="line"><span class="lineno"> 3680</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;link_color_func must return a matplotlib &quot;</span></div>
<div class="line"><span class="lineno"> 3681</span>                            <span class="stringliteral">&quot;color string!&quot;</span>)</div>
<div class="line"><span class="lineno"> 3682</span>        color_list.append(v)</div>
<div class="line"><span class="lineno"> 3683</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3684</span>        color_list.append(c)</div>
<div class="line"><span class="lineno"> 3685</span> </div>
<div class="line"><span class="lineno"> 3686</span>    <span class="keywordflow">return</span> (((uiva + uivb) / 2), uwa + uwb, h, max_dist)</div>
<div class="line"><span class="lineno"> 3687</span> </div>
<div class="line"><span class="lineno"> 3688</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a295674906962ecfa4f1c33673897c3b7" name="a295674906962ecfa4f1c33673897c3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295674906962ecfa4f1c33673897c3b7">&#9670;&#160;</a></span>_get_leaves_color_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._get_leaves_color_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3389</span><span class="keyword">def </span>_get_leaves_color_list(R):</div>
<div class="line"><span class="lineno"> 3390</span>    leaves_color_list = [<span class="keywordtype">None</span>] * len(R[<span class="stringliteral">&#39;leaves&#39;</span>])</div>
<div class="line"><span class="lineno"> 3391</span>    <span class="keywordflow">for</span> link_x, link_y, link_color <span class="keywordflow">in</span> zip(R[<span class="stringliteral">&#39;icoord&#39;</span>],</div>
<div class="line"><span class="lineno"> 3392</span>                                          R[<span class="stringliteral">&#39;dcoord&#39;</span>],</div>
<div class="line"><span class="lineno"> 3393</span>                                          R[<span class="stringliteral">&#39;color_list&#39;</span>]):</div>
<div class="line"><span class="lineno"> 3394</span>        <span class="keywordflow">for</span> (xi, yi) <span class="keywordflow">in</span> zip(link_x, link_y):</div>
<div class="line"><span class="lineno"> 3395</span>            <span class="keywordflow">if</span> yi == 0.0:  <span class="comment"># if yi is 0.0, the point is a leaf</span></div>
<div class="line"><span class="lineno"> 3396</span>                <span class="comment"># xi of leaves are      5, 15, 25, 35, ... (see `iv_ticks`)</span></div>
<div class="line"><span class="lineno"> 3397</span>                <span class="comment"># index of leaves are   0,  1,  2,  3, ... as below</span></div>
<div class="line"><span class="lineno"> 3398</span>                leaf_index = (int(xi) - 5) // 10</div>
<div class="line"><span class="lineno"> 3399</span>                <span class="comment"># each leaf has a same color of its link.</span></div>
<div class="line"><span class="lineno"> 3400</span>                leaves_color_list[leaf_index] = link_color</div>
<div class="line"><span class="lineno"> 3401</span>    <span class="keywordflow">return</span> leaves_color_list</div>
<div class="line"><span class="lineno"> 3402</span> </div>
<div class="line"><span class="lineno"> 3403</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a71040b69c0049a9b6fe8e142fe3f0ab0" name="a71040b69c0049a9b6fe8e142fe3f0ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71040b69c0049a9b6fe8e142fe3f0ab0">&#9670;&#160;</a></span>_get_tick_rotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._get_tick_rotation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2805</span><span class="keyword">def </span>_get_tick_rotation(p):</div>
<div class="line"><span class="lineno"> 2806</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> _drotationsortedkeys:</div>
<div class="line"><span class="lineno"> 2807</span>        <span class="keywordflow">if</span> p &lt;= k:</div>
<div class="line"><span class="lineno"> 2808</span>            <span class="keywordflow">return</span> _drotation[k]</div>
<div class="line"><span class="lineno"> 2809</span> </div>
<div class="line"><span class="lineno"> 2810</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a67b97df9381d14a7e6762a2b8301895e" name="a67b97df9381d14a7e6762a2b8301895e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b97df9381d14a7e6762a2b8301895e">&#9670;&#160;</a></span>_get_tick_text_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._get_tick_text_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2799</span><span class="keyword">def </span>_get_tick_text_size(p):</div>
<div class="line"><span class="lineno"> 2800</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> _dtextsortedkeys:</div>
<div class="line"><span class="lineno"> 2801</span>        <span class="keywordflow">if</span> p &lt;= k:</div>
<div class="line"><span class="lineno"> 2802</span>            <span class="keywordflow">return</span> _dtextsizes[k]</div>
<div class="line"><span class="lineno"> 2803</span> </div>
<div class="line"><span class="lineno"> 2804</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4b18fd6e3ee3157e0e803185d32b710" name="ae4b18fd6e3ee3157e0e803185d32b710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b18fd6e3ee3157e0e803185d32b710">&#9670;&#160;</a></span>_order_cluster_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._order_cluster_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return clustering nodes in bottom-up order by distance.

Parameters
----------
Z : scipy.cluster.linkage array
    The linkage matrix.

Returns
-------
nodes : list
    A list of ClusterNode objects.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1289</span><span class="keyword">def </span>_order_cluster_tree(Z):</div>
<div class="line"><span class="lineno"> 1290</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    Return clustering nodes in bottom-up order by distance.</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    Z : scipy.cluster.linkage array</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">        The linkage matrix.</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    nodes : list</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">        A list of ClusterNode objects.</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1303</span>    q = deque()</div>
<div class="line"><span class="lineno"> 1304</span>    tree = to_tree(Z)</div>
<div class="line"><span class="lineno"> 1305</span>    q.append(tree)</div>
<div class="line"><span class="lineno"> 1306</span>    nodes = []</div>
<div class="line"><span class="lineno"> 1307</span> </div>
<div class="line"><span class="lineno"> 1308</span>    <span class="keywordflow">while</span> q:</div>
<div class="line"><span class="lineno"> 1309</span>        node = q.popleft()</div>
<div class="line"><span class="lineno"> 1310</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> node.is_leaf():</div>
<div class="line"><span class="lineno"> 1311</span>            bisect.insort_left(nodes, node)</div>
<div class="line"><span class="lineno"> 1312</span>            q.append(node.get_right())</div>
<div class="line"><span class="lineno"> 1313</span>            q.append(node.get_left())</div>
<div class="line"><span class="lineno"> 1314</span>    <span class="keywordflow">return</span> nodes</div>
<div class="line"><span class="lineno"> 1315</span> </div>
<div class="line"><span class="lineno"> 1316</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae105e6e65cddba4ee8c73aeaed36372b" name="ae105e6e65cddba4ee8c73aeaed36372b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae105e6e65cddba4ee8c73aeaed36372b">&#9670;&#160;</a></span>_plot_dendrogram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._plot_dendrogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>icoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dcoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ivl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>color_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_font_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_rotation</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contraction_marks</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ax</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>above_threshold_color</em> = <code>'C0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2814</span>                     ax=<span class="keywordtype">None</span>, above_threshold_color=<span class="stringliteral">&#39;C0&#39;</span>):</div>
<div class="line"><span class="lineno"> 2815</span>    <span class="comment"># Import matplotlib here so that it&#39;s not imported unless dendrograms</span></div>
<div class="line"><span class="lineno"> 2816</span>    <span class="comment"># are plotted. Raise an informative error if importing fails.</span></div>
<div class="line"><span class="lineno"> 2817</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2818</span>        <span class="comment"># if an axis is provided, don&#39;t use pylab at all</span></div>
<div class="line"><span class="lineno"> 2819</span>        <span class="keywordflow">if</span> ax <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2820</span>            <span class="keyword">import</span> <a class="code hl_namespace" href="namespacematplotlib_1_1pylab.html">matplotlib.pylab</a></div>
<div class="line"><span class="lineno"> 2821</span>        <span class="keyword">import</span> <a class="code hl_namespace" href="namespacematplotlib_1_1patches.html">matplotlib.patches</a></div>
<div class="line"><span class="lineno"> 2822</span>        <span class="keyword">import</span> <a class="code hl_namespace" href="namespacematplotlib_1_1collections.html">matplotlib.collections</a></div>
<div class="line"><span class="lineno"> 2823</span>    <span class="keywordflow">except</span> ImportError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 2824</span>        <span class="keywordflow">raise</span> ImportError(<span class="stringliteral">&quot;You must install the matplotlib library to plot &quot;</span></div>
<div class="line"><span class="lineno"> 2825</span>                          <span class="stringliteral">&quot;the dendrogram. Use no_plot=True to calculate the &quot;</span></div>
<div class="line"><span class="lineno"> 2826</span>                          <span class="stringliteral">&quot;dendrogram without plotting.&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 2827</span> </div>
<div class="line"><span class="lineno"> 2828</span>    <span class="keywordflow">if</span> ax <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2829</span>        ax = matplotlib.pylab.gca()</div>
<div class="line"><span class="lineno"> 2830</span>        <span class="comment"># if we&#39;re using pylab, we want to trigger a draw at the end</span></div>
<div class="line"><span class="lineno"> 2831</span>        trigger_redraw = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2832</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2833</span>        trigger_redraw = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2834</span> </div>
<div class="line"><span class="lineno"> 2835</span>    <span class="comment"># Independent variable plot width</span></div>
<div class="line"><span class="lineno"> 2836</span>    ivw = len(ivl) * 10</div>
<div class="line"><span class="lineno"> 2837</span>    <span class="comment"># Dependent variable plot height</span></div>
<div class="line"><span class="lineno"> 2838</span>    dvw = mh + mh * 0.05</div>
<div class="line"><span class="lineno"> 2839</span> </div>
<div class="line"><span class="lineno"> 2840</span>    iv_ticks = np.arange(5, len(ivl) * 10 + 5, 10)</div>
<div class="line"><span class="lineno"> 2841</span>    <span class="keywordflow">if</span> orientation <span class="keywordflow">in</span> (<span class="stringliteral">&#39;top&#39;</span>, <span class="stringliteral">&#39;bottom&#39;</span>):</div>
<div class="line"><span class="lineno"> 2842</span>        <span class="keywordflow">if</span> orientation == <span class="stringliteral">&#39;top&#39;</span>:</div>
<div class="line"><span class="lineno"> 2843</span>            ax.set_ylim([0, dvw])</div>
<div class="line"><span class="lineno"> 2844</span>            ax.set_xlim([0, ivw])</div>
<div class="line"><span class="lineno"> 2845</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2846</span>            ax.set_ylim([dvw, 0])</div>
<div class="line"><span class="lineno"> 2847</span>            ax.set_xlim([0, ivw])</div>
<div class="line"><span class="lineno"> 2848</span> </div>
<div class="line"><span class="lineno"> 2849</span>        xlines = icoords</div>
<div class="line"><span class="lineno"> 2850</span>        ylines = dcoords</div>
<div class="line"><span class="lineno"> 2851</span>        <span class="keywordflow">if</span> no_labels:</div>
<div class="line"><span class="lineno"> 2852</span>            ax.set_xticks([])</div>
<div class="line"><span class="lineno"> 2853</span>            ax.set_xticklabels([])</div>
<div class="line"><span class="lineno"> 2854</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2855</span>            ax.set_xticks(iv_ticks)</div>
<div class="line"><span class="lineno"> 2856</span> </div>
<div class="line"><span class="lineno"> 2857</span>            <span class="keywordflow">if</span> orientation == <span class="stringliteral">&#39;top&#39;</span>:</div>
<div class="line"><span class="lineno"> 2858</span>                ax.xaxis.set_ticks_position(<span class="stringliteral">&#39;bottom&#39;</span>)</div>
<div class="line"><span class="lineno"> 2859</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2860</span>                ax.xaxis.set_ticks_position(<span class="stringliteral">&#39;top&#39;</span>)</div>
<div class="line"><span class="lineno"> 2861</span> </div>
<div class="line"><span class="lineno"> 2862</span>            <span class="comment"># Make the tick marks invisible because they cover up the links</span></div>
<div class="line"><span class="lineno"> 2863</span>            <span class="keywordflow">for</span> line <span class="keywordflow">in</span> ax.get_xticklines():</div>
<div class="line"><span class="lineno"> 2864</span>                line.set_visible(<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2865</span> </div>
<div class="line"><span class="lineno"> 2866</span>            leaf_rot = (float(_get_tick_rotation(len(ivl)))</div>
<div class="line"><span class="lineno"> 2867</span>                        <span class="keywordflow">if</span> (leaf_rotation <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> leaf_rotation)</div>
<div class="line"><span class="lineno"> 2868</span>            leaf_font = (float(_get_tick_text_size(len(ivl)))</div>
<div class="line"><span class="lineno"> 2869</span>                         <span class="keywordflow">if</span> (leaf_font_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> leaf_font_size)</div>
<div class="line"><span class="lineno"> 2870</span>            ax.set_xticklabels(ivl, rotation=leaf_rot, size=leaf_font)</div>
<div class="line"><span class="lineno"> 2871</span> </div>
<div class="line"><span class="lineno"> 2872</span>    <span class="keywordflow">elif</span> orientation <span class="keywordflow">in</span> (<span class="stringliteral">&#39;left&#39;</span>, <span class="stringliteral">&#39;right&#39;</span>):</div>
<div class="line"><span class="lineno"> 2873</span>        <span class="keywordflow">if</span> orientation == <span class="stringliteral">&#39;left&#39;</span>:</div>
<div class="line"><span class="lineno"> 2874</span>            ax.set_xlim([dvw, 0])</div>
<div class="line"><span class="lineno"> 2875</span>            ax.set_ylim([0, ivw])</div>
<div class="line"><span class="lineno"> 2876</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2877</span>            ax.set_xlim([0, dvw])</div>
<div class="line"><span class="lineno"> 2878</span>            ax.set_ylim([0, ivw])</div>
<div class="line"><span class="lineno"> 2879</span> </div>
<div class="line"><span class="lineno"> 2880</span>        xlines = dcoords</div>
<div class="line"><span class="lineno"> 2881</span>        ylines = icoords</div>
<div class="line"><span class="lineno"> 2882</span>        <span class="keywordflow">if</span> no_labels:</div>
<div class="line"><span class="lineno"> 2883</span>            ax.set_yticks([])</div>
<div class="line"><span class="lineno"> 2884</span>            ax.set_yticklabels([])</div>
<div class="line"><span class="lineno"> 2885</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2886</span>            ax.set_yticks(iv_ticks)</div>
<div class="line"><span class="lineno"> 2887</span> </div>
<div class="line"><span class="lineno"> 2888</span>            <span class="keywordflow">if</span> orientation == <span class="stringliteral">&#39;left&#39;</span>:</div>
<div class="line"><span class="lineno"> 2889</span>                ax.yaxis.set_ticks_position(<span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno"> 2890</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2891</span>                ax.yaxis.set_ticks_position(<span class="stringliteral">&#39;left&#39;</span>)</div>
<div class="line"><span class="lineno"> 2892</span> </div>
<div class="line"><span class="lineno"> 2893</span>            <span class="comment"># Make the tick marks invisible because they cover up the links</span></div>
<div class="line"><span class="lineno"> 2894</span>            <span class="keywordflow">for</span> line <span class="keywordflow">in</span> ax.get_yticklines():</div>
<div class="line"><span class="lineno"> 2895</span>                line.set_visible(<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2896</span> </div>
<div class="line"><span class="lineno"> 2897</span>            leaf_font = (float(_get_tick_text_size(len(ivl)))</div>
<div class="line"><span class="lineno"> 2898</span>                         <span class="keywordflow">if</span> (leaf_font_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">else</span> leaf_font_size)</div>
<div class="line"><span class="lineno"> 2899</span> </div>
<div class="line"><span class="lineno"> 2900</span>            <span class="keywordflow">if</span> leaf_rotation <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2901</span>                ax.set_yticklabels(ivl, rotation=leaf_rotation, size=leaf_font)</div>
<div class="line"><span class="lineno"> 2902</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2903</span>                ax.set_yticklabels(ivl, size=leaf_font)</div>
<div class="line"><span class="lineno"> 2904</span> </div>
<div class="line"><span class="lineno"> 2905</span>    <span class="comment"># Let&#39;s use collections instead. This way there is a separate legend item</span></div>
<div class="line"><span class="lineno"> 2906</span>    <span class="comment"># for each tree grouping, rather than stupidly one for each line segment.</span></div>
<div class="line"><span class="lineno"> 2907</span>    colors_used = _remove_dups(color_list)</div>
<div class="line"><span class="lineno"> 2908</span>    color_to_lines = {}</div>
<div class="line"><span class="lineno"> 2909</span>    <span class="keywordflow">for</span> color <span class="keywordflow">in</span> colors_used:</div>
<div class="line"><span class="lineno"> 2910</span>        color_to_lines[color] = []</div>
<div class="line"><span class="lineno"> 2911</span>    <span class="keywordflow">for</span> (xline, yline, color) <span class="keywordflow">in</span> zip(xlines, ylines, color_list):</div>
<div class="line"><span class="lineno"> 2912</span>        color_to_lines[color].append(list(zip(xline, yline)))</div>
<div class="line"><span class="lineno"> 2913</span> </div>
<div class="line"><span class="lineno"> 2914</span>    colors_to_collections = {}</div>
<div class="line"><span class="lineno"> 2915</span>    <span class="comment"># Construct the collections.</span></div>
<div class="line"><span class="lineno"> 2916</span>    <span class="keywordflow">for</span> color <span class="keywordflow">in</span> colors_used:</div>
<div class="line"><span class="lineno"> 2917</span>        coll = <a class="code hl_class" href="classmatplotlib_1_1collections_1_1_line_collection.html">matplotlib.collections.LineCollection</a>(color_to_lines[color],</div>
<div class="line"><span class="lineno"> 2918</span>                                                     colors=(color,))</div>
<div class="line"><span class="lineno"> 2919</span>        colors_to_collections[color] = coll</div>
<div class="line"><span class="lineno"> 2920</span> </div>
<div class="line"><span class="lineno"> 2921</span>    <span class="comment"># Add all the groupings below the color threshold.</span></div>
<div class="line"><span class="lineno"> 2922</span>    <span class="keywordflow">for</span> color <span class="keywordflow">in</span> colors_used:</div>
<div class="line"><span class="lineno"> 2923</span>        <span class="keywordflow">if</span> color != above_threshold_color:</div>
<div class="line"><span class="lineno"> 2924</span>            ax.add_collection(colors_to_collections[color])</div>
<div class="line"><span class="lineno"> 2925</span>    <span class="comment"># If there&#39;s a grouping of links above the color threshold, it goes last.</span></div>
<div class="line"><span class="lineno"> 2926</span>    <span class="keywordflow">if</span> above_threshold_color <span class="keywordflow">in</span> colors_to_collections:</div>
<div class="line"><span class="lineno"> 2927</span>        ax.add_collection(colors_to_collections[above_threshold_color])</div>
<div class="line"><span class="lineno"> 2928</span> </div>
<div class="line"><span class="lineno"> 2929</span>    <span class="keywordflow">if</span> contraction_marks <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2930</span>        Ellipse = <a class="code hl_class" href="classmatplotlib_1_1patches_1_1_ellipse.html">matplotlib.patches.Ellipse</a></div>
<div class="line"><span class="lineno"> 2931</span>        <span class="keywordflow">for</span> (x, y) <span class="keywordflow">in</span> contraction_marks:</div>
<div class="line"><span class="lineno"> 2932</span>            <span class="keywordflow">if</span> orientation <span class="keywordflow">in</span> (<span class="stringliteral">&#39;left&#39;</span>, <span class="stringliteral">&#39;right&#39;</span>):</div>
<div class="line"><span class="lineno"> 2933</span>                e = Ellipse((y, x), width=dvw / 100, height=1.0)</div>
<div class="line"><span class="lineno"> 2934</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2935</span>                e = Ellipse((x, y), width=1.0, height=dvw / 100)</div>
<div class="line"><span class="lineno"> 2936</span>            ax.add_artist(e)</div>
<div class="line"><span class="lineno"> 2937</span>            e.set_clip_box(ax.bbox)</div>
<div class="line"><span class="lineno"> 2938</span>            e.set_alpha(0.5)</div>
<div class="line"><span class="lineno"> 2939</span>            e.set_facecolor(<span class="stringliteral">&#39;k&#39;</span>)</div>
<div class="line"><span class="lineno"> 2940</span> </div>
<div class="line"><span class="lineno"> 2941</span>    <span class="keywordflow">if</span> trigger_redraw:</div>
<div class="line"><span class="lineno"> 2942</span>        matplotlib.pylab.draw_if_interactive()</div>
<div class="line"><span class="lineno"> 2943</span> </div>
<div class="line"><span class="lineno"> 2944</span> </div>
<div class="line"><span class="lineno"> 2945</span><span class="comment"># C0  is used for above threshhold color</span></div>
<div class="ttc" id="aclassmatplotlib_1_1collections_1_1_line_collection_html"><div class="ttname"><a href="classmatplotlib_1_1collections_1_1_line_collection.html">matplotlib.collections.LineCollection</a></div><div class="ttdef"><b>Definition</b> collections.py:1352</div></div>
<div class="ttc" id="aclassmatplotlib_1_1patches_1_1_ellipse_html"><div class="ttname"><a href="classmatplotlib_1_1patches_1_1_ellipse.html">matplotlib.patches.Ellipse</a></div><div class="ttdef"><b>Definition</b> patches.py:1516</div></div>
<div class="ttc" id="anamespacematplotlib_1_1collections_html"><div class="ttname"><a href="namespacematplotlib_1_1collections.html">matplotlib.collections</a></div><div class="ttdef"><b>Definition</b> collections.py:1</div></div>
<div class="ttc" id="anamespacematplotlib_1_1patches_html"><div class="ttname"><a href="namespacematplotlib_1_1patches.html">matplotlib.patches</a></div><div class="ttdef"><b>Definition</b> patches.py:1</div></div>
<div class="ttc" id="anamespacematplotlib_1_1pylab_html"><div class="ttname"><a href="namespacematplotlib_1_1pylab.html">matplotlib.pylab</a></div><div class="ttdef"><b>Definition</b> pylab.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a715e2aa9866c1f8addc552106257dae4" name="a715e2aa9866c1f8addc552106257dae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715e2aa9866c1f8addc552106257dae4">&#9670;&#160;</a></span>_randdm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._randdm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pnts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generate a random distance matrix stored in condensed form.

Parameters
----------
pnts : int
    The number of points in the distance matrix. Has to be at least 2.

Returns
-------
D : ndarray
    A ``pnts * (pnts - 1) / 2`` sized vector is returned.
</pre> <div class="fragment"><div class="line"><span class="lineno">  185</span><span class="keyword">def </span>_randdm(pnts):</div>
<div class="line"><span class="lineno">  186</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    Generate a random distance matrix stored in condensed form.</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    pnts : int</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        The number of points in the distance matrix. Has to be at least 2.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    D : ndarray</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        A ``pnts * (pnts - 1) / 2`` sized vector is returned.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  199</span>    <span class="keywordflow">if</span> pnts &gt;= 2:</div>
<div class="line"><span class="lineno">  200</span>        D = np.random.rand(pnts * (pnts - 1) / 2)</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The number of points in the distance matrix &quot;</span></div>
<div class="line"><span class="lineno">  203</span>                         <span class="stringliteral">&quot;must be at least 2.&quot;</span>)</div>
<div class="line"><span class="lineno">  204</span>    <span class="keywordflow">return</span> D</div>
<div class="line"><span class="lineno">  205</span> </div>
<div class="line"><span class="lineno">  206</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4de4074e40721ed1440ef2c067ae120" name="ad4de4074e40721ed1440ef2c067ae120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4de4074e40721ed1440ef2c067ae120">&#9670;&#160;</a></span>_remove_dups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._remove_dups </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Remove duplicates AND preserve the original order of the elements.

The set class is not guaranteed to do this.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2784</span><span class="keyword">def </span>_remove_dups(L):</div>
<div class="line"><span class="lineno"> 2785</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2786</span><span class="stringliteral">    Remove duplicates AND preserve the original order of the elements.</span></div>
<div class="line"><span class="lineno"> 2787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">    The set class is not guaranteed to do this.</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2790</span>    seen_before = set([])</div>
<div class="line"><span class="lineno"> 2791</span>    L2 = []</div>
<div class="line"><span class="lineno"> 2792</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> L:</div>
<div class="line"><span class="lineno"> 2793</span>        <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> seen_before:</div>
<div class="line"><span class="lineno"> 2794</span>            seen_before.add(i)</div>
<div class="line"><span class="lineno"> 2795</span>            L2.append(i)</div>
<div class="line"><span class="lineno"> 2796</span>    <span class="keywordflow">return</span> L2</div>
<div class="line"><span class="lineno"> 2797</span> </div>
<div class="line"><span class="lineno"> 2798</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a69eea798f07f7ac92c37f356d335d4cc" name="a69eea798f07f7ac92c37f356d335d4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69eea798f07f7ac92c37f356d335d4cc">&#9670;&#160;</a></span>_warning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._warning </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  158</span><span class="keyword">def </span>_warning(s):</div>
<div class="line"><span class="lineno">  159</span>    warnings.warn(<span class="stringliteral">&#39;scipy.cluster: %s&#39;</span> % s, ClusterWarning, stacklevel=3)</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a761f3af7ff4939e574d4dcd08a7bfcb0" name="a761f3af7ff4939e574d4dcd08a7bfcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761f3af7ff4939e574d4dcd08a7bfcb0">&#9670;&#160;</a></span>average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.average </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform average/UPGMA linkage on a condensed distance matrix.

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    `linkage` for more information on its structure.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import average, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

First, we need a toy dataset to play with::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

Then, we get a condensed distance matrix from this dataset:

&gt;&gt;&gt; y = pdist(X)

Finally, we can perform the clustering:

&gt;&gt;&gt; Z = average(y)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.20710678,  3.        ],
       [ 5.        , 13.        ,  1.20710678,  3.        ],
       [ 8.        , 14.        ,  1.20710678,  3.        ],
       [11.        , 15.        ,  1.20710678,  3.        ],
       [16.        , 17.        ,  3.39675184,  6.        ],
       [18.        , 19.        ,  3.39675184,  6.        ],
       [20.        , 21.        ,  4.09206523, 12.        ]])

The linkage matrix ``Z`` represents a dendrogram - see
`scipy.cluster.hierarchy.linkage` for a detailed explanation of its
contents.

We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster
each initial point would belong given a distance threshold:

&gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 1.5, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 4, criterion='distance')
array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 6, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a
plot of the dendrogram.</pre> <div class="fragment"><div class="line"><span class="lineno">  367</span><span class="keyword">def </span>average(y):</div>
<div class="line"><span class="lineno">  368</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    Perform average/UPGMA linkage on a condensed distance matrix.</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        The upper triangular of the distance matrix. The result of</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        ``pdist`` is returned in this form.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        A linkage matrix containing the hierarchical clustering. See</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        `linkage` for more information on its structure.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    linkage : for advanced creation of hierarchical clusterings.</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import average, fcluster</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    First, we need a toy dataset to play with::</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    Then, we get a condensed distance matrix from this dataset:</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    &gt;&gt;&gt; y = pdist(X)</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    Finally, we can perform the clustering:</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    &gt;&gt;&gt; Z = average(y)</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">           [ 2.        , 12.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">           [ 5.        , 13.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">           [ 8.        , 14.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">           [11.        , 15.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">           [16.        , 17.        ,  3.39675184,  6.        ],</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">           [18.        , 19.        ,  3.39675184,  6.        ],</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">           [20.        , 21.        ,  4.09206523, 12.        ]])</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram - see</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    contents.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    each initial point would belong given a distance threshold:</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 1.5, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 4, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32)</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 6, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    plot of the dendrogram.</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordflow">return</span> linkage(y, method=<span class="stringliteral">&#39;average&#39;</span>, metric=<span class="stringliteral">&#39;euclidean&#39;</span>)</div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af078eaaf796754567d1ee58eac815eff" name="af078eaaf796754567d1ee58eac815eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af078eaaf796754567d1ee58eac815eff">&#9670;&#160;</a></span>centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.centroid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform centroid/UPGMC linkage.

See `linkage` for more information on the input matrix,
return structure, and algorithm.

The following are common calling conventions:

1. ``Z = centroid(y)``

   Performs centroid/UPGMC linkage on the condensed distance
   matrix ``y``.

2. ``Z = centroid(X)``

   Performs centroid/UPGMC linkage on the observation matrix ``X``
   using Euclidean distance as the distance metric.

Parameters
----------
y : ndarray
    A condensed distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns. Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    an m by n array.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the `linkage` function documentation for more information
    on its structure.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import centroid, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

First, we need a toy dataset to play with::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

Then, we get a condensed distance matrix from this dataset:

&gt;&gt;&gt; y = pdist(X)

Finally, we can perform the clustering:

&gt;&gt;&gt; Z = centroid(y)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.11803399,  3.        ],
       [ 5.        , 13.        ,  1.11803399,  3.        ],
       [ 8.        , 15.        ,  1.11803399,  3.        ],
       [11.        , 14.        ,  1.11803399,  3.        ],
       [18.        , 19.        ,  3.33333333,  6.        ],
       [16.        , 17.        ,  3.33333333,  6.        ],
       [20.        , 21.        ,  3.33333333, 12.        ]])

The linkage matrix ``Z`` represents a dendrogram - see
`scipy.cluster.hierarchy.linkage` for a detailed explanation of its
contents.

We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster
each initial point would belong given a distance threshold:

&gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 1.1, criterion='distance')
array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 2, criterion='distance')
array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 4, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a
plot of the dendrogram.</pre> <div class="fragment"><div class="line"><span class="lineno">  534</span><span class="keyword">def </span>centroid(y):</div>
<div class="line"><span class="lineno">  535</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    Perform centroid/UPGMC linkage.</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    See `linkage` for more information on the input matrix,</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    return structure, and algorithm.</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    The following are common calling conventions:</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    1. ``Z = centroid(y)``</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">       Performs centroid/UPGMC linkage on the condensed distance</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">       matrix ``y``.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    2. ``Z = centroid(X)``</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">       Performs centroid/UPGMC linkage on the observation matrix ``X``</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">       using Euclidean distance as the distance metric.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">        A condensed distance matrix. A condensed</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">        distance matrix is a flat array containing the upper</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">        triangular of the distance matrix. This is the form that</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        ``pdist`` returns. Alternatively, a collection of</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">        m observation vectors in n dimensions may be passed as</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">        an m by n array.</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">        A linkage matrix containing the hierarchical clustering. See</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        the `linkage` function documentation for more information</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">        on its structure.</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    linkage : for advanced creation of hierarchical clusterings.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import centroid, fcluster</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    First, we need a toy dataset to play with::</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    Then, we get a condensed distance matrix from this dataset:</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    &gt;&gt;&gt; y = pdist(X)</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    Finally, we can perform the clustering:</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    &gt;&gt;&gt; Z = centroid(y)</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">           [ 2.        , 12.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">           [ 5.        , 13.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">           [ 8.        , 15.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">           [11.        , 14.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">           [18.        , 19.        ,  3.33333333,  6.        ],</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">           [16.        , 17.        ,  3.33333333,  6.        ],</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">           [20.        , 21.        ,  3.33333333, 12.        ]])</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram - see</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    contents.</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    each initial point would belong given a distance threshold:</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32)</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 1.1, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 2, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32)</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 4, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    plot of the dendrogram.</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  633</span>    <span class="keywordflow">return</span> linkage(y, method=<span class="stringliteral">&#39;centroid&#39;</span>, metric=<span class="stringliteral">&#39;euclidean&#39;</span>)</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a398b7760fa5a1f486daffed40154240e" name="a398b7760fa5a1f486daffed40154240e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398b7760fa5a1f486daffed40154240e">&#9670;&#160;</a></span>complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform complete/max/farthest point linkage on a condensed distance matrix.

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the `linkage` function documentation for more information
    on its structure.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import complete, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

First, we need a toy dataset to play with::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

Then, we get a condensed distance matrix from this dataset:

&gt;&gt;&gt; y = pdist(X)

Finally, we can perform the clustering:

&gt;&gt;&gt; Z = complete(y)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.41421356,  3.        ],
       [ 5.        , 13.        ,  1.41421356,  3.        ],
       [ 8.        , 14.        ,  1.41421356,  3.        ],
       [11.        , 15.        ,  1.41421356,  3.        ],
       [16.        , 17.        ,  4.12310563,  6.        ],
       [18.        , 19.        ,  4.12310563,  6.        ],
       [20.        , 21.        ,  5.65685425, 12.        ]])

The linkage matrix ``Z`` represents a dendrogram - see
`scipy.cluster.hierarchy.linkage` for a detailed explanation of its
contents.

We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster
each initial point would belong given a distance threshold:

&gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 1.5, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 4.5, criterion='distance')
array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 6, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a
plot of the dendrogram.
</pre> <div class="fragment"><div class="line"><span class="lineno">  285</span><span class="keyword">def </span>complete(y):</div>
<div class="line"><span class="lineno">  286</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    Perform complete/max/farthest point linkage on a condensed distance matrix.</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        The upper triangular of the distance matrix. The result of</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        ``pdist`` is returned in this form.</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        A linkage matrix containing the hierarchical clustering. See</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        the `linkage` function documentation for more information</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        on its structure.</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    linkage : for advanced creation of hierarchical clusterings.</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import complete, fcluster</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    First, we need a toy dataset to play with::</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    Then, we get a condensed distance matrix from this dataset:</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    &gt;&gt;&gt; y = pdist(X)</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    Finally, we can perform the clustering:</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    &gt;&gt;&gt; Z = complete(y)</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">           [ 2.        , 12.        ,  1.41421356,  3.        ],</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">           [ 5.        , 13.        ,  1.41421356,  3.        ],</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">           [ 8.        , 14.        ,  1.41421356,  3.        ],</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">           [11.        , 15.        ,  1.41421356,  3.        ],</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">           [16.        , 17.        ,  4.12310563,  6.        ],</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">           [18.        , 19.        ,  4.12310563,  6.        ],</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">           [20.        , 21.        ,  5.65685425, 12.        ]])</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram - see</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    contents.</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    each initial point would belong given a distance threshold:</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 1.5, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 4.5, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32)</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 6, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    plot of the dendrogram.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  364</span>    <span class="keywordflow">return</span> linkage(y, method=<span class="stringliteral">&#39;complete&#39;</span>, metric=<span class="stringliteral">&#39;euclidean&#39;</span>)</div>
<div class="line"><span class="lineno">  365</span> </div>
<div class="line"><span class="lineno">  366</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4084d497c98ada88f2085328520f2f60" name="a4084d497c98ada88f2085328520f2f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4084d497c98ada88f2085328520f2f60">&#9670;&#160;</a></span>cophenet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.cophenet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the cophenetic distances between each observation in
the hierarchical clustering defined by the linkage ``Z``.

Suppose ``p`` and ``q`` are original observations in
disjoint clusters ``s`` and ``t``, respectively and
``s`` and ``t`` are joined by a direct parent cluster
``u``. The cophenetic distance between observations
``i`` and ``j`` is simply the distance between
clusters ``s`` and ``t``.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as an array
    (see `linkage` function).
Y : ndarray (optional)
    Calculates the cophenetic correlation coefficient ``c`` of a
    hierarchical clustering defined by the linkage matrix `Z`
    of a set of :math:`n` observations in :math:`m`
    dimensions. `Y` is the condensed distance matrix from which
    `Z` was generated.

Returns
-------
c : ndarray
    The cophentic correlation distance (if ``Y`` is passed).
d : ndarray
    The cophenetic distance matrix in condensed form. The
    :math:`ij` th entry is the cophenetic distance between
    original observations :math:`i` and :math:`j`.

See Also
--------
linkage :
    for a description of what a linkage matrix is.
scipy.spatial.distance.squareform :
    transforming condensed matrices into square ones.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import single, cophenet
&gt;&gt;&gt; from scipy.spatial.distance import pdist, squareform

Given a dataset ``X`` and a linkage matrix ``Z``, the cophenetic distance
between two points of ``X`` is the distance between the largest two
distinct clusters that each of the points:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

``X`` corresponds to this dataset ::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; Z = single(pdist(X))
&gt;&gt;&gt; Z
array([[ 0.,  1.,  1.,  2.],
       [ 2., 12.,  1.,  3.],
       [ 3.,  4.,  1.,  2.],
       [ 5., 14.,  1.,  3.],
       [ 6.,  7.,  1.,  2.],
       [ 8., 16.,  1.,  3.],
       [ 9., 10.,  1.,  2.],
       [11., 18.,  1.,  3.],
       [13., 15.,  2.,  6.],
       [17., 20.,  2.,  9.],
       [19., 21.,  2., 12.]])
&gt;&gt;&gt; cophenet(Z)
array([1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 2., 2., 2., 2., 2.,
       2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 2., 2.,
       2., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.,
       1., 1., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 1., 1., 1.])

The output of the `scipy.cluster.hierarchy.cophenet` method is
represented in condensed form. We can use
`scipy.spatial.distance.squareform` to see the output as a
regular matrix (where each element ``ij`` denotes the cophenetic distance
between each ``i``, ``j`` pair of points in ``X``):

&gt;&gt;&gt; squareform(cophenet(Z))
array([[0., 1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.],
       [1., 0., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.],
       [1., 1., 0., 2., 2., 2., 2., 2., 2., 2., 2., 2.],
       [2., 2., 2., 0., 1., 1., 2., 2., 2., 2., 2., 2.],
       [2., 2., 2., 1., 0., 1., 2., 2., 2., 2., 2., 2.],
       [2., 2., 2., 1., 1., 0., 2., 2., 2., 2., 2., 2.],
       [2., 2., 2., 2., 2., 2., 0., 1., 1., 2., 2., 2.],
       [2., 2., 2., 2., 2., 2., 1., 0., 1., 2., 2., 2.],
       [2., 2., 2., 2., 2., 2., 1., 1., 0., 2., 2., 2.],
       [2., 2., 2., 2., 2., 2., 2., 2., 2., 0., 1., 1.],
       [2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 0., 1.],
       [2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 0.]])

In this example, the cophenetic distance between points on ``X`` that are
very close (i.e., in the same corner) is 1. For other pairs of points is 2,
because the points will be located in clusters at different
corners - thus, the distance between these clusters will be larger.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1578</span><span class="keyword">def </span>cophenet(Z, Y=None):</div>
<div class="line"><span class="lineno"> 1579</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">    Calculate the cophenetic distances between each observation in</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">    the hierarchical clustering defined by the linkage ``Z``.</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">    Suppose ``p`` and ``q`` are original observations in</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    disjoint clusters ``s`` and ``t``, respectively and</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    ``s`` and ``t`` are joined by a direct parent cluster</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">    ``u``. The cophenetic distance between observations</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    ``i`` and ``j`` is simply the distance between</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    clusters ``s`` and ``t``.</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">        The hierarchical clustering encoded as an array</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">        (see `linkage` function).</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    Y : ndarray (optional)</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">        Calculates the cophenetic correlation coefficient ``c`` of a</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">        hierarchical clustering defined by the linkage matrix `Z`</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">        of a set of :math:`n` observations in :math:`m`</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">        dimensions. `Y` is the condensed distance matrix from which</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        `Z` was generated.</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">    c : ndarray</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        The cophentic correlation distance (if ``Y`` is passed).</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">    d : ndarray</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">        The cophenetic distance matrix in condensed form. The</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">        :math:`ij` th entry is the cophenetic distance between</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">        original observations :math:`i` and :math:`j`.</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">    linkage :</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">        for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral">    scipy.spatial.distance.squareform :</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        transforming condensed matrices into square ones.</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import single, cophenet</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist, squareform</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    Given a dataset ``X`` and a linkage matrix ``Z``, the cophenetic distance</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    between two points of ``X`` is the distance between the largest two</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    distinct clusters that each of the points:</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">    ``X`` corresponds to this dataset ::</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">    &gt;&gt;&gt; Z = single(pdist(X))</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">    array([[ 0.,  1.,  1.,  2.],</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">           [ 2., 12.,  1.,  3.],</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">           [ 3.,  4.,  1.,  2.],</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">           [ 5., 14.,  1.,  3.],</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">           [ 6.,  7.,  1.,  2.],</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">           [ 8., 16.,  1.,  3.],</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">           [ 9., 10.,  1.,  2.],</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">           [11., 18.,  1.,  3.],</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">           [13., 15.,  2.,  6.],</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral">           [17., 20.,  2.,  9.],</span></div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral">           [19., 21.,  2., 12.]])</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">    &gt;&gt;&gt; cophenet(Z)</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral">    array([1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 2., 2., 2., 2., 2.,</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">           2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 2., 2.,</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">           2., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.,</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">           1., 1., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 1., 1., 1.])</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">    The output of the `scipy.cluster.hierarchy.cophenet` method is</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">    represented in condensed form. We can use</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">    `scipy.spatial.distance.squareform` to see the output as a</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">    regular matrix (where each element ``ij`` denotes the cophenetic distance</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">    between each ``i``, ``j`` pair of points in ``X``):</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">    &gt;&gt;&gt; squareform(cophenet(Z))</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">    array([[0., 1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">           [1., 0., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">           [1., 1., 0., 2., 2., 2., 2., 2., 2., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">           [2., 2., 2., 0., 1., 1., 2., 2., 2., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">           [2., 2., 2., 1., 0., 1., 2., 2., 2., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">           [2., 2., 2., 1., 1., 0., 2., 2., 2., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">           [2., 2., 2., 2., 2., 2., 0., 1., 1., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">           [2., 2., 2., 2., 2., 2., 1., 0., 1., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">           [2., 2., 2., 2., 2., 2., 1., 1., 0., 2., 2., 2.],</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">           [2., 2., 2., 2., 2., 2., 2., 2., 2., 0., 1., 1.],</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">           [2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 0., 1.],</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">           [2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 0.]])</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">    In this example, the cophenetic distance between points on ``X`` that are</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    very close (i.e., in the same corner) is 1. For other pairs of points is 2,</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    because the points will be located in clusters at different</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">    corners - thus, the distance between these clusters will be larger.</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1685</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 1686</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 1687</span>    Zs = Z.shape</div>
<div class="line"><span class="lineno"> 1688</span>    n = Zs[0] + 1</div>
<div class="line"><span class="lineno"> 1689</span> </div>
<div class="line"><span class="lineno"> 1690</span>    zz = np.zeros((n * (n-1)) // 2, dtype=np.double)</div>
<div class="line"><span class="lineno"> 1691</span>    <span class="comment"># Since the C code does not support striding using strides.</span></div>
<div class="line"><span class="lineno"> 1692</span>    <span class="comment"># The dimensions are used instead.</span></div>
<div class="line"><span class="lineno"> 1693</span>    Z = _convert_to_double(Z)</div>
<div class="line"><span class="lineno"> 1694</span> </div>
<div class="line"><span class="lineno"> 1695</span>    _hierarchy.cophenetic_distances(Z, zz, int(n))</div>
<div class="line"><span class="lineno"> 1696</span>    <span class="keywordflow">if</span> Y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1697</span>        <span class="keywordflow">return</span> zz</div>
<div class="line"><span class="lineno"> 1698</span> </div>
<div class="line"><span class="lineno"> 1699</span>    Y = np.asarray(Y, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 1700</span>    distance.is_valid_y(Y, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Y&#39;</span>)</div>
<div class="line"><span class="lineno"> 1701</span> </div>
<div class="line"><span class="lineno"> 1702</span>    z = zz.mean()</div>
<div class="line"><span class="lineno"> 1703</span>    y = Y.mean()</div>
<div class="line"><span class="lineno"> 1704</span>    Yy = Y - y</div>
<div class="line"><span class="lineno"> 1705</span>    Zz = zz - z</div>
<div class="line"><span class="lineno"> 1706</span>    numerator = (Yy * Zz)</div>
<div class="line"><span class="lineno"> 1707</span>    denomA = Yy**2</div>
<div class="line"><span class="lineno"> 1708</span>    denomB = Zz**2</div>
<div class="line"><span class="lineno"> 1709</span>    c = numerator.sum() / np.sqrt((denomA.sum() * denomB.sum()))</div>
<div class="line"><span class="lineno"> 1710</span>    <span class="keywordflow">return</span> (c, zz)</div>
<div class="line"><span class="lineno"> 1711</span> </div>
<div class="line"><span class="lineno"> 1712</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a370417db125d267384d6e39cf75c4e" name="a8a370417db125d267384d6e39cf75c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a370417db125d267384d6e39cf75c4e">&#9670;&#160;</a></span>correspond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.correspond </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check for correspondence between linkage and condensed distance matrices.

They must have the same number of original observations for
the check to succeed.

This function is useful as a sanity check in algorithms that make
extensive use of linkage and distance matrices that must
correspond to the same set of original observations.

Parameters
----------
Z : array_like
    The linkage matrix to check for correspondence.
Y : array_like
    The condensed distance matrix to check for correspondence.

Returns
-------
b : bool
    A boolean indicating whether the linkage matrix and distance
    matrix could possibly correspond to one another.

See Also
--------
linkage : for a description of what a linkage matrix is.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, correspond
&gt;&gt;&gt; from scipy.spatial.distance import pdist

This method can be used to check if a given linkage matrix ``Z`` has been
obtained from the application of a cluster method over a dataset ``X``:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]
&gt;&gt;&gt; X_condensed = pdist(X)
&gt;&gt;&gt; Z = ward(X_condensed)

Here, we can compare ``Z`` and ``X`` (in condensed form):

&gt;&gt;&gt; correspond(Z, X_condensed)
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 2370</span><span class="keyword">def </span>correspond(Z, Y):</div>
<div class="line"><span class="lineno"> 2371</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2372</span><span class="stringliteral">    Check for correspondence between linkage and condensed distance matrices.</span></div>
<div class="line"><span class="lineno"> 2373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2374</span><span class="stringliteral">    They must have the same number of original observations for</span></div>
<div class="line"><span class="lineno"> 2375</span><span class="stringliteral">    the check to succeed.</span></div>
<div class="line"><span class="lineno"> 2376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2377</span><span class="stringliteral">    This function is useful as a sanity check in algorithms that make</span></div>
<div class="line"><span class="lineno"> 2378</span><span class="stringliteral">    extensive use of linkage and distance matrices that must</span></div>
<div class="line"><span class="lineno"> 2379</span><span class="stringliteral">    correspond to the same set of original observations.</span></div>
<div class="line"><span class="lineno"> 2380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2381</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2382</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2383</span><span class="stringliteral">    Z : array_like</span></div>
<div class="line"><span class="lineno"> 2384</span><span class="stringliteral">        The linkage matrix to check for correspondence.</span></div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral">    Y : array_like</span></div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">        The condensed distance matrix to check for correspondence.</span></div>
<div class="line"><span class="lineno"> 2387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2388</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2389</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2390</span><span class="stringliteral">    b : bool</span></div>
<div class="line"><span class="lineno"> 2391</span><span class="stringliteral">        A boolean indicating whether the linkage matrix and distance</span></div>
<div class="line"><span class="lineno"> 2392</span><span class="stringliteral">        matrix could possibly correspond to one another.</span></div>
<div class="line"><span class="lineno"> 2393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2394</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2395</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, correspond</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">    This method can be used to check if a given linkage matrix ``Z`` has been</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">    obtained from the application of a cluster method over a dataset ``X``:</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2407</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2408</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2409</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2410</span><span class="stringliteral">    &gt;&gt;&gt; X_condensed = pdist(X)</span></div>
<div class="line"><span class="lineno"> 2411</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(X_condensed)</span></div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral">    Here, we can compare ``Z`` and ``X`` (in condensed form):</span></div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral">    &gt;&gt;&gt; correspond(Z, X_condensed)</span></div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2419</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2420</span>    distance.is_valid_y(Y, throw=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2421</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2422</span>    Y = np.asarray(Y, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2423</span>    <span class="keywordflow">return</span> distance.num_obs_y(Y) == num_obs_linkage(Z)</div>
<div class="line"><span class="lineno"> 2424</span> </div>
<div class="line"><span class="lineno"> 2425</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a869cb447ba7c6b829c185a5c9aa50230" name="a869cb447ba7c6b829c185a5c9aa50230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869cb447ba7c6b829c185a5c9aa50230">&#9670;&#160;</a></span>cut_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.cut_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_clusters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>height</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a linkage matrix Z, return the cut tree.

Parameters
----------
Z : scipy.cluster.linkage array
    The linkage matrix.
n_clusters : array_like, optional
    Number of clusters in the tree at the cut point.
height : array_like, optional
    The height at which to cut the tree. Only possible for ultrametric
    trees.

Returns
-------
cutree : array
    An array indicating group membership at each agglomeration step. I.e.,
    for a full cut tree, in the first column each data point is in its own
    cluster. At the next step, two nodes are merged. Finally, all
    singleton and non-singleton clusters are in one group. If `n_clusters`
    or `height` are given, the columns correspond to the columns of
    `n_clusters` or `height`.

Examples
--------
&gt;&gt;&gt; from scipy import cluster
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; X = rng.random((50, 4))
&gt;&gt;&gt; Z = cluster.hierarchy.ward(X)
&gt;&gt;&gt; cutree = cluster.hierarchy.cut_tree(Z, n_clusters=[5, 10])
&gt;&gt;&gt; cutree[:10]
array([[0, 0],
       [1, 1],
       [2, 2],
       [3, 3],
       [3, 4],
       [2, 2],
       [0, 0],
       [1, 5],
       [3, 6],
       [4, 7]])  # random</pre> <div class="fragment"><div class="line"><span class="lineno"> 1317</span><span class="keyword">def </span>cut_tree(Z, n_clusters=None, height=None):</div>
<div class="line"><span class="lineno"> 1318</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    Given a linkage matrix Z, return the cut tree.</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    Z : scipy.cluster.linkage array</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">        The linkage matrix.</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    n_clusters : array_like, optional</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">        Number of clusters in the tree at the cut point.</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    height : array_like, optional</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">        The height at which to cut the tree. Only possible for ultrametric</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">        trees.</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    cutree : array</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">        An array indicating group membership at each agglomeration step. I.e.,</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">        for a full cut tree, in the first column each data point is in its own</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">        cluster. At the next step, two nodes are merged. Finally, all</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">        singleton and non-singleton clusters are in one group. If `n_clusters`</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">        or `height` are given, the columns correspond to the columns of</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">        `n_clusters` or `height`.</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import cluster</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &gt;&gt;&gt; X = rng.random((50, 4))</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    &gt;&gt;&gt; Z = cluster.hierarchy.ward(X)</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    &gt;&gt;&gt; cutree = cluster.hierarchy.cut_tree(Z, n_clusters=[5, 10])</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    &gt;&gt;&gt; cutree[:10]</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    array([[0, 0],</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">           [1, 1],</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">           [2, 2],</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">           [3, 3],</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">           [3, 4],</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">           [2, 2],</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">           [0, 0],</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">           [1, 5],</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">           [3, 6],</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">           [4, 7]])  # random</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1363</span>    nobs = num_obs_linkage(Z)</div>
<div class="line"><span class="lineno"> 1364</span>    nodes = _order_cluster_tree(Z)</div>
<div class="line"><span class="lineno"> 1365</span> </div>
<div class="line"><span class="lineno"> 1366</span>    <span class="keywordflow">if</span> height <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> n_clusters <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1367</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;At least one of either height or n_clusters &quot;</span></div>
<div class="line"><span class="lineno"> 1368</span>                         <span class="stringliteral">&quot;must be None&quot;</span>)</div>
<div class="line"><span class="lineno"> 1369</span>    <span class="keywordflow">elif</span> height <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> n_clusters <span class="keywordflow">is</span> <span class="keywordtype">None</span>:  <span class="comment"># return the full cut tree</span></div>
<div class="line"><span class="lineno"> 1370</span>        cols_idx = np.arange(nobs)</div>
<div class="line"><span class="lineno"> 1371</span>    <span class="keywordflow">elif</span> height <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1372</span>        heights = np.array([x.dist <span class="keywordflow">for</span> x <span class="keywordflow">in</span> nodes])</div>
<div class="line"><span class="lineno"> 1373</span>        cols_idx = np.searchsorted(heights, height)</div>
<div class="line"><span class="lineno"> 1374</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1375</span>        cols_idx = nobs - np.searchsorted(np.arange(nobs), n_clusters)</div>
<div class="line"><span class="lineno"> 1376</span> </div>
<div class="line"><span class="lineno"> 1377</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1378</span>        n_cols = len(cols_idx)</div>
<div class="line"><span class="lineno"> 1379</span>    <span class="keywordflow">except</span> TypeError:  <span class="comment"># scalar</span></div>
<div class="line"><span class="lineno"> 1380</span>        n_cols = 1</div>
<div class="line"><span class="lineno"> 1381</span>        cols_idx = np.array([cols_idx])</div>
<div class="line"><span class="lineno"> 1382</span> </div>
<div class="line"><span class="lineno"> 1383</span>    groups = np.zeros((n_cols, nobs), dtype=int)</div>
<div class="line"><span class="lineno"> 1384</span>    last_group = np.arange(nobs)</div>
<div class="line"><span class="lineno"> 1385</span>    <span class="keywordflow">if</span> 0 <span class="keywordflow">in</span> cols_idx:</div>
<div class="line"><span class="lineno"> 1386</span>        groups[0] = last_group</div>
<div class="line"><span class="lineno"> 1387</span> </div>
<div class="line"><span class="lineno"> 1388</span>    <span class="keywordflow">for</span> i, node <span class="keywordflow">in</span> enumerate(nodes):</div>
<div class="line"><span class="lineno"> 1389</span>        idx = node.pre_order()</div>
<div class="line"><span class="lineno"> 1390</span>        this_group = last_group.copy()</div>
<div class="line"><span class="lineno"> 1391</span>        this_group[idx] = last_group[idx].min()</div>
<div class="line"><span class="lineno"> 1392</span>        this_group[this_group &gt; last_group[idx].max()] -= 1</div>
<div class="line"><span class="lineno"> 1393</span>        <span class="keywordflow">if</span> i + 1 <span class="keywordflow">in</span> cols_idx:</div>
<div class="line"><span class="lineno"> 1394</span>            groups[np.nonzero(i + 1 == cols_idx)[0]] = this_group</div>
<div class="line"><span class="lineno"> 1395</span>        last_group = this_group</div>
<div class="line"><span class="lineno"> 1396</span> </div>
<div class="line"><span class="lineno"> 1397</span>    <span class="keywordflow">return</span> groups.T</div>
<div class="line"><span class="lineno"> 1398</span> </div>
<div class="line"><span class="lineno"> 1399</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5090a9f1ef7ef09ea50ae3685d671a08" name="a5090a9f1ef7ef09ea50ae3685d671a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5090a9f1ef7ef09ea50ae3685d671a08">&#9670;&#160;</a></span>dendrogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.dendrogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>truncate_mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>color_threshold</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>get_leaves</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orientation</em> = <code>'top'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count_sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance_sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>show_leaf_counts</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_plot</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_labels</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_font_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_rotation</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_label_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>show_contracted</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>link_color_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ax</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>above_threshold_color</em> = <code>'C0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Plot the hierarchical clustering as a dendrogram.

The dendrogram illustrates how each cluster is
composed by drawing a U-shaped link between a non-singleton
cluster and its children. The top of the U-link indicates a
cluster merge. The two legs of the U-link indicate which clusters
were merged. The length of the two legs of the U-link represents
the distance between the child clusters. It is also the
cophenetic distance between original observations in the two
children clusters.

Parameters
----------
Z : ndarray
    The linkage matrix encoding the hierarchical clustering to
    render as a dendrogram. See the ``linkage`` function for more
    information on the format of ``Z``.
p : int, optional
    The ``p`` parameter for ``truncate_mode``.
truncate_mode : str, optional
    The dendrogram can be hard to read when the original
    observation matrix from which the linkage is derived is
    large. Truncation is used to condense the dendrogram. There
    are several modes:

    ``None``
      No truncation is performed (default).
      Note: ``'none'`` is an alias for ``None`` that's kept for
      backward compatibility.

    ``'lastp'``
      The last ``p`` non-singleton clusters formed in the linkage are the
      only non-leaf nodes in the linkage; they correspond to rows
      ``Z[n-p-2:end]`` in ``Z``. All other non-singleton clusters are
      contracted into leaf nodes.

    ``'level'``
      No more than ``p`` levels of the dendrogram tree are displayed.
      A "level" includes all nodes with ``p`` merges from the final merge.

      Note: ``'mtica'`` is an alias for ``'level'`` that's kept for
      backward compatibility.

color_threshold : double, optional
    For brevity, let :math:`t` be the ``color_threshold``.
    Colors all the descendent links below a cluster node
    :math:`k` the same color if :math:`k` is the first node below
    the cut threshold :math:`t`. All links connecting nodes with
    distances greater than or equal to the threshold are colored
    with de default matplotlib color ``'C0'``. If :math:`t` is less
    than or equal to zero, all nodes are colored ``'C0'``.
    If ``color_threshold`` is None or 'default',
    corresponding with MATLAB(TM) behavior, the threshold is set to
    ``0.7*max(Z[:,2])``.

get_leaves : bool, optional
    Includes a list ``R['leaves']=H`` in the result
    dictionary. For each :math:`i`, ``H[i] == j``, cluster node
    ``j`` appears in position ``i`` in the left-to-right traversal
    of the leaves, where :math:`j &lt; 2n-1` and :math:`i &lt; n`.
orientation : str, optional
    The direction to plot the dendrogram, which can be any
    of the following strings:

    ``'top'``
      Plots the root at the top, and plot descendent links going downwards.
      (default).

    ``'bottom'``
      Plots the root at the bottom, and plot descendent links going
      upwards.

    ``'left'``
      Plots the root at the left, and plot descendent links going right.

    ``'right'``
      Plots the root at the right, and plot descendent links going left.

labels : ndarray, optional
    By default, ``labels`` is None so the index of the original observation
    is used to label the leaf nodes.  Otherwise, this is an :math:`n`-sized
    sequence, with ``n == Z.shape[0] + 1``. The ``labels[i]`` value is the
    text to put under the :math:`i` th leaf node only if it corresponds to
    an original observation and not a non-singleton cluster.
count_sort : str or bool, optional
    For each node n, the order (visually, from left-to-right) n's
    two descendent links are plotted is determined by this
    parameter, which can be any of the following values:

    ``False``
      Nothing is done.

    ``'ascending'`` or ``True``
      The child with the minimum number of original objects in its cluster
      is plotted first.

    ``'descending'``
      The child with the maximum number of original objects in its cluster
      is plotted first.

    Note, ``distance_sort`` and ``count_sort`` cannot both be True.
distance_sort : str or bool, optional
    For each node n, the order (visually, from left-to-right) n's
    two descendent links are plotted is determined by this
    parameter, which can be any of the following values:

    ``False``
      Nothing is done.

    ``'ascending'`` or ``True``
      The child with the minimum distance between its direct descendents is
      plotted first.

    ``'descending'``
      The child with the maximum distance between its direct descendents is
      plotted first.

    Note ``distance_sort`` and ``count_sort`` cannot both be True.
show_leaf_counts : bool, optional
     When True, leaf nodes representing :math:`k&gt;1` original
     observation are labeled with the number of observations they
     contain in parentheses.
no_plot : bool, optional
    When True, the final rendering is not performed. This is
    useful if only the data structures computed for the rendering
    are needed or if matplotlib is not available.
no_labels : bool, optional
    When True, no labels appear next to the leaf nodes in the
    rendering of the dendrogram.
leaf_rotation : double, optional
    Specifies the angle (in degrees) to rotate the leaf
    labels. When unspecified, the rotation is based on the number of
    nodes in the dendrogram (default is 0).
leaf_font_size : int, optional
    Specifies the font size (in points) of the leaf labels. When
    unspecified, the size based on the number of nodes in the
    dendrogram.
leaf_label_func : lambda or function, optional
    When ``leaf_label_func`` is a callable function, for each
    leaf with cluster index :math:`k &lt; 2n-1`. The function
    is expected to return a string with the label for the
    leaf.

    Indices :math:`k &lt; n` correspond to original observations
    while indices :math:`k \\geq n` correspond to non-singleton
    clusters.

    For example, to label singletons with their node id and
    non-singletons with their id, count, and inconsistency
    coefficient, simply do::

        # First define the leaf label function.
        def llf(id):
            if id &lt; n:
                return str(id)
            else:
                return '[%d %d %1.2f]' % (id, count, R[n-id,3])

        # The text for the leaf nodes is going to be big so force
        # a rotation of 90 degrees.
        dendrogram(Z, leaf_label_func=llf, leaf_rotation=90)

        # leaf_label_func can also be used together with ``truncate_mode`` parameter,
        # in which case you will get your leaves labeled after truncation:
        dendrogram(Z, leaf_label_func=llf, leaf_rotation=90,
                   truncate_mode='level', p=2)

show_contracted : bool, optional
    When True the heights of non-singleton nodes contracted
    into a leaf node are plotted as crosses along the link
    connecting that leaf node.  This really is only useful when
    truncation is used (see ``truncate_mode`` parameter).
link_color_func : callable, optional
    If given, `link_color_function` is called with each non-singleton id
    corresponding to each U-shaped link it will paint. The function is
    expected to return the color to paint the link, encoded as a matplotlib
    color string code. For example::

        dendrogram(Z, link_color_func=lambda k: colors[k])

    colors the direct links below each untruncated non-singleton node
    ``k`` using ``colors[k]``.
ax : matplotlib Axes instance, optional
    If None and `no_plot` is not True, the dendrogram will be plotted
    on the current axes.  Otherwise if `no_plot` is not True the
    dendrogram will be plotted on the given ``Axes`` instance. This can be
    useful if the dendrogram is part of a more complex figure.
above_threshold_color : str, optional
    This matplotlib color string sets the color of the links above the
    color_threshold. The default is ``'C0'``.

Returns
-------
R : dict
    A dictionary of data structures computed to render the
    dendrogram. Its has the following keys:

    ``'color_list'``
      A list of color names. The k'th element represents the color of the
      k'th link.

    ``'icoord'`` and ``'dcoord'``
      Each of them is a list of lists. Let ``icoord = [I1, I2, ..., Ip]``
      where ``Ik = [xk1, xk2, xk3, xk4]`` and ``dcoord = [D1, D2, ..., Dp]``
      where ``Dk = [yk1, yk2, yk3, yk4]``, then the k'th link painted is
      ``(xk1, yk1)`` - ``(xk2, yk2)`` - ``(xk3, yk3)`` - ``(xk4, yk4)``.

    ``'ivl'``
      A list of labels corresponding to the leaf nodes.

    ``'leaves'``
      For each i, ``H[i] == j``, cluster node ``j`` appears in position
      ``i`` in the left-to-right traversal of the leaves, where
      :math:`j &lt; 2n-1` and :math:`i &lt; n`. If ``j`` is less than ``n``, the
      ``i``-th leaf node corresponds to an original observation.
      Otherwise, it corresponds to a non-singleton cluster.

    ``'leaves_color_list'``
      A list of color names. The k'th element represents the color of the
      k'th leaf.

See Also
--------
linkage, set_link_color_palette

Notes
-----
It is expected that the distances in ``Z[:,2]`` be monotonic, otherwise
crossings appear in the dendrogram.

Examples
--------
&gt;&gt;&gt; from scipy.cluster import hierarchy
&gt;&gt;&gt; import matplotlib.pyplot as plt

A very basic example:

&gt;&gt;&gt; ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268.,
...                    400., 754., 564., 138., 219., 869., 669.])
&gt;&gt;&gt; Z = hierarchy.linkage(ytdist, 'single')
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; dn = hierarchy.dendrogram(Z)

Now, plot in given axes, improve the color scheme and use both vertical and
horizontal orientations:

&gt;&gt;&gt; hierarchy.set_link_color_palette(['m', 'c', 'y', 'k'])
&gt;&gt;&gt; fig, axes = plt.subplots(1, 2, figsize=(8, 3))
&gt;&gt;&gt; dn1 = hierarchy.dendrogram(Z, ax=axes[0], above_threshold_color='y',
...                            orientation='top')
&gt;&gt;&gt; dn2 = hierarchy.dendrogram(Z, ax=axes[1],
...                            above_threshold_color='#bcbddc',
...                            orientation='right')
&gt;&gt;&gt; hierarchy.set_link_color_palette(None)  # reset to default after use
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3026</span>               above_threshold_color=<span class="stringliteral">&#39;C0&#39;</span>):</div>
<div class="line"><span class="lineno"> 3027</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3028</span><span class="stringliteral">    Plot the hierarchical clustering as a dendrogram.</span></div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral">    The dendrogram illustrates how each cluster is</span></div>
<div class="line"><span class="lineno"> 3031</span><span class="stringliteral">    composed by drawing a U-shaped link between a non-singleton</span></div>
<div class="line"><span class="lineno"> 3032</span><span class="stringliteral">    cluster and its children. The top of the U-link indicates a</span></div>
<div class="line"><span class="lineno"> 3033</span><span class="stringliteral">    cluster merge. The two legs of the U-link indicate which clusters</span></div>
<div class="line"><span class="lineno"> 3034</span><span class="stringliteral">    were merged. The length of the two legs of the U-link represents</span></div>
<div class="line"><span class="lineno"> 3035</span><span class="stringliteral">    the distance between the child clusters. It is also the</span></div>
<div class="line"><span class="lineno"> 3036</span><span class="stringliteral">    cophenetic distance between original observations in the two</span></div>
<div class="line"><span class="lineno"> 3037</span><span class="stringliteral">    children clusters.</span></div>
<div class="line"><span class="lineno"> 3038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3039</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3040</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3041</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 3042</span><span class="stringliteral">        The linkage matrix encoding the hierarchical clustering to</span></div>
<div class="line"><span class="lineno"> 3043</span><span class="stringliteral">        render as a dendrogram. See the ``linkage`` function for more</span></div>
<div class="line"><span class="lineno"> 3044</span><span class="stringliteral">        information on the format of ``Z``.</span></div>
<div class="line"><span class="lineno"> 3045</span><span class="stringliteral">    p : int, optional</span></div>
<div class="line"><span class="lineno"> 3046</span><span class="stringliteral">        The ``p`` parameter for ``truncate_mode``.</span></div>
<div class="line"><span class="lineno"> 3047</span><span class="stringliteral">    truncate_mode : str, optional</span></div>
<div class="line"><span class="lineno"> 3048</span><span class="stringliteral">        The dendrogram can be hard to read when the original</span></div>
<div class="line"><span class="lineno"> 3049</span><span class="stringliteral">        observation matrix from which the linkage is derived is</span></div>
<div class="line"><span class="lineno"> 3050</span><span class="stringliteral">        large. Truncation is used to condense the dendrogram. There</span></div>
<div class="line"><span class="lineno"> 3051</span><span class="stringliteral">        are several modes:</span></div>
<div class="line"><span class="lineno"> 3052</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3053</span><span class="stringliteral">        ``None``</span></div>
<div class="line"><span class="lineno"> 3054</span><span class="stringliteral">          No truncation is performed (default).</span></div>
<div class="line"><span class="lineno"> 3055</span><span class="stringliteral">          Note: ``&#39;none&#39;`` is an alias for ``None`` that&#39;s kept for</span></div>
<div class="line"><span class="lineno"> 3056</span><span class="stringliteral">          backward compatibility.</span></div>
<div class="line"><span class="lineno"> 3057</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3058</span><span class="stringliteral">        ``&#39;lastp&#39;``</span></div>
<div class="line"><span class="lineno"> 3059</span><span class="stringliteral">          The last ``p`` non-singleton clusters formed in the linkage are the</span></div>
<div class="line"><span class="lineno"> 3060</span><span class="stringliteral">          only non-leaf nodes in the linkage; they correspond to rows</span></div>
<div class="line"><span class="lineno"> 3061</span><span class="stringliteral">          ``Z[n-p-2:end]`` in ``Z``. All other non-singleton clusters are</span></div>
<div class="line"><span class="lineno"> 3062</span><span class="stringliteral">          contracted into leaf nodes.</span></div>
<div class="line"><span class="lineno"> 3063</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3064</span><span class="stringliteral">        ``&#39;level&#39;``</span></div>
<div class="line"><span class="lineno"> 3065</span><span class="stringliteral">          No more than ``p`` levels of the dendrogram tree are displayed.</span></div>
<div class="line"><span class="lineno"> 3066</span><span class="stringliteral">          A &quot;level&quot; includes all nodes with ``p`` merges from the final merge.</span></div>
<div class="line"><span class="lineno"> 3067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3068</span><span class="stringliteral">          Note: ``&#39;mtica&#39;`` is an alias for ``&#39;level&#39;`` that&#39;s kept for</span></div>
<div class="line"><span class="lineno"> 3069</span><span class="stringliteral">          backward compatibility.</span></div>
<div class="line"><span class="lineno"> 3070</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3071</span><span class="stringliteral">    color_threshold : double, optional</span></div>
<div class="line"><span class="lineno"> 3072</span><span class="stringliteral">        For brevity, let :math:`t` be the ``color_threshold``.</span></div>
<div class="line"><span class="lineno"> 3073</span><span class="stringliteral">        Colors all the descendent links below a cluster node</span></div>
<div class="line"><span class="lineno"> 3074</span><span class="stringliteral">        :math:`k` the same color if :math:`k` is the first node below</span></div>
<div class="line"><span class="lineno"> 3075</span><span class="stringliteral">        the cut threshold :math:`t`. All links connecting nodes with</span></div>
<div class="line"><span class="lineno"> 3076</span><span class="stringliteral">        distances greater than or equal to the threshold are colored</span></div>
<div class="line"><span class="lineno"> 3077</span><span class="stringliteral">        with de default matplotlib color ``&#39;C0&#39;``. If :math:`t` is less</span></div>
<div class="line"><span class="lineno"> 3078</span><span class="stringliteral">        than or equal to zero, all nodes are colored ``&#39;C0&#39;``.</span></div>
<div class="line"><span class="lineno"> 3079</span><span class="stringliteral">        If ``color_threshold`` is None or &#39;default&#39;,</span></div>
<div class="line"><span class="lineno"> 3080</span><span class="stringliteral">        corresponding with MATLAB(TM) behavior, the threshold is set to</span></div>
<div class="line"><span class="lineno"> 3081</span><span class="stringliteral">        ``0.7*max(Z[:,2])``.</span></div>
<div class="line"><span class="lineno"> 3082</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3083</span><span class="stringliteral">    get_leaves : bool, optional</span></div>
<div class="line"><span class="lineno"> 3084</span><span class="stringliteral">        Includes a list ``R[&#39;leaves&#39;]=H`` in the result</span></div>
<div class="line"><span class="lineno"> 3085</span><span class="stringliteral">        dictionary. For each :math:`i`, ``H[i] == j``, cluster node</span></div>
<div class="line"><span class="lineno"> 3086</span><span class="stringliteral">        ``j`` appears in position ``i`` in the left-to-right traversal</span></div>
<div class="line"><span class="lineno"> 3087</span><span class="stringliteral">        of the leaves, where :math:`j &lt; 2n-1` and :math:`i &lt; n`.</span></div>
<div class="line"><span class="lineno"> 3088</span><span class="stringliteral">    orientation : str, optional</span></div>
<div class="line"><span class="lineno"> 3089</span><span class="stringliteral">        The direction to plot the dendrogram, which can be any</span></div>
<div class="line"><span class="lineno"> 3090</span><span class="stringliteral">        of the following strings:</span></div>
<div class="line"><span class="lineno"> 3091</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3092</span><span class="stringliteral">        ``&#39;top&#39;``</span></div>
<div class="line"><span class="lineno"> 3093</span><span class="stringliteral">          Plots the root at the top, and plot descendent links going downwards.</span></div>
<div class="line"><span class="lineno"> 3094</span><span class="stringliteral">          (default).</span></div>
<div class="line"><span class="lineno"> 3095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3096</span><span class="stringliteral">        ``&#39;bottom&#39;``</span></div>
<div class="line"><span class="lineno"> 3097</span><span class="stringliteral">          Plots the root at the bottom, and plot descendent links going</span></div>
<div class="line"><span class="lineno"> 3098</span><span class="stringliteral">          upwards.</span></div>
<div class="line"><span class="lineno"> 3099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3100</span><span class="stringliteral">        ``&#39;left&#39;``</span></div>
<div class="line"><span class="lineno"> 3101</span><span class="stringliteral">          Plots the root at the left, and plot descendent links going right.</span></div>
<div class="line"><span class="lineno"> 3102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3103</span><span class="stringliteral">        ``&#39;right&#39;``</span></div>
<div class="line"><span class="lineno"> 3104</span><span class="stringliteral">          Plots the root at the right, and plot descendent links going left.</span></div>
<div class="line"><span class="lineno"> 3105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3106</span><span class="stringliteral">    labels : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3107</span><span class="stringliteral">        By default, ``labels`` is None so the index of the original observation</span></div>
<div class="line"><span class="lineno"> 3108</span><span class="stringliteral">        is used to label the leaf nodes.  Otherwise, this is an :math:`n`-sized</span></div>
<div class="line"><span class="lineno"> 3109</span><span class="stringliteral">        sequence, with ``n == Z.shape[0] + 1``. The ``labels[i]`` value is the</span></div>
<div class="line"><span class="lineno"> 3110</span><span class="stringliteral">        text to put under the :math:`i` th leaf node only if it corresponds to</span></div>
<div class="line"><span class="lineno"> 3111</span><span class="stringliteral">        an original observation and not a non-singleton cluster.</span></div>
<div class="line"><span class="lineno"> 3112</span><span class="stringliteral">    count_sort : str or bool, optional</span></div>
<div class="line"><span class="lineno"> 3113</span><span class="stringliteral">        For each node n, the order (visually, from left-to-right) n&#39;s</span></div>
<div class="line"><span class="lineno"> 3114</span><span class="stringliteral">        two descendent links are plotted is determined by this</span></div>
<div class="line"><span class="lineno"> 3115</span><span class="stringliteral">        parameter, which can be any of the following values:</span></div>
<div class="line"><span class="lineno"> 3116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3117</span><span class="stringliteral">        ``False``</span></div>
<div class="line"><span class="lineno"> 3118</span><span class="stringliteral">          Nothing is done.</span></div>
<div class="line"><span class="lineno"> 3119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3120</span><span class="stringliteral">        ``&#39;ascending&#39;`` or ``True``</span></div>
<div class="line"><span class="lineno"> 3121</span><span class="stringliteral">          The child with the minimum number of original objects in its cluster</span></div>
<div class="line"><span class="lineno"> 3122</span><span class="stringliteral">          is plotted first.</span></div>
<div class="line"><span class="lineno"> 3123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3124</span><span class="stringliteral">        ``&#39;descending&#39;``</span></div>
<div class="line"><span class="lineno"> 3125</span><span class="stringliteral">          The child with the maximum number of original objects in its cluster</span></div>
<div class="line"><span class="lineno"> 3126</span><span class="stringliteral">          is plotted first.</span></div>
<div class="line"><span class="lineno"> 3127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3128</span><span class="stringliteral">        Note, ``distance_sort`` and ``count_sort`` cannot both be True.</span></div>
<div class="line"><span class="lineno"> 3129</span><span class="stringliteral">    distance_sort : str or bool, optional</span></div>
<div class="line"><span class="lineno"> 3130</span><span class="stringliteral">        For each node n, the order (visually, from left-to-right) n&#39;s</span></div>
<div class="line"><span class="lineno"> 3131</span><span class="stringliteral">        two descendent links are plotted is determined by this</span></div>
<div class="line"><span class="lineno"> 3132</span><span class="stringliteral">        parameter, which can be any of the following values:</span></div>
<div class="line"><span class="lineno"> 3133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3134</span><span class="stringliteral">        ``False``</span></div>
<div class="line"><span class="lineno"> 3135</span><span class="stringliteral">          Nothing is done.</span></div>
<div class="line"><span class="lineno"> 3136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3137</span><span class="stringliteral">        ``&#39;ascending&#39;`` or ``True``</span></div>
<div class="line"><span class="lineno"> 3138</span><span class="stringliteral">          The child with the minimum distance between its direct descendents is</span></div>
<div class="line"><span class="lineno"> 3139</span><span class="stringliteral">          plotted first.</span></div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral">        ``&#39;descending&#39;``</span></div>
<div class="line"><span class="lineno"> 3142</span><span class="stringliteral">          The child with the maximum distance between its direct descendents is</span></div>
<div class="line"><span class="lineno"> 3143</span><span class="stringliteral">          plotted first.</span></div>
<div class="line"><span class="lineno"> 3144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3145</span><span class="stringliteral">        Note ``distance_sort`` and ``count_sort`` cannot both be True.</span></div>
<div class="line"><span class="lineno"> 3146</span><span class="stringliteral">    show_leaf_counts : bool, optional</span></div>
<div class="line"><span class="lineno"> 3147</span><span class="stringliteral">         When True, leaf nodes representing :math:`k&gt;1` original</span></div>
<div class="line"><span class="lineno"> 3148</span><span class="stringliteral">         observation are labeled with the number of observations they</span></div>
<div class="line"><span class="lineno"> 3149</span><span class="stringliteral">         contain in parentheses.</span></div>
<div class="line"><span class="lineno"> 3150</span><span class="stringliteral">    no_plot : bool, optional</span></div>
<div class="line"><span class="lineno"> 3151</span><span class="stringliteral">        When True, the final rendering is not performed. This is</span></div>
<div class="line"><span class="lineno"> 3152</span><span class="stringliteral">        useful if only the data structures computed for the rendering</span></div>
<div class="line"><span class="lineno"> 3153</span><span class="stringliteral">        are needed or if matplotlib is not available.</span></div>
<div class="line"><span class="lineno"> 3154</span><span class="stringliteral">    no_labels : bool, optional</span></div>
<div class="line"><span class="lineno"> 3155</span><span class="stringliteral">        When True, no labels appear next to the leaf nodes in the</span></div>
<div class="line"><span class="lineno"> 3156</span><span class="stringliteral">        rendering of the dendrogram.</span></div>
<div class="line"><span class="lineno"> 3157</span><span class="stringliteral">    leaf_rotation : double, optional</span></div>
<div class="line"><span class="lineno"> 3158</span><span class="stringliteral">        Specifies the angle (in degrees) to rotate the leaf</span></div>
<div class="line"><span class="lineno"> 3159</span><span class="stringliteral">        labels. When unspecified, the rotation is based on the number of</span></div>
<div class="line"><span class="lineno"> 3160</span><span class="stringliteral">        nodes in the dendrogram (default is 0).</span></div>
<div class="line"><span class="lineno"> 3161</span><span class="stringliteral">    leaf_font_size : int, optional</span></div>
<div class="line"><span class="lineno"> 3162</span><span class="stringliteral">        Specifies the font size (in points) of the leaf labels. When</span></div>
<div class="line"><span class="lineno"> 3163</span><span class="stringliteral">        unspecified, the size based on the number of nodes in the</span></div>
<div class="line"><span class="lineno"> 3164</span><span class="stringliteral">        dendrogram.</span></div>
<div class="line"><span class="lineno"> 3165</span><span class="stringliteral">    leaf_label_func : lambda or function, optional</span></div>
<div class="line"><span class="lineno"> 3166</span><span class="stringliteral">        When ``leaf_label_func`` is a callable function, for each</span></div>
<div class="line"><span class="lineno"> 3167</span><span class="stringliteral">        leaf with cluster index :math:`k &lt; 2n-1`. The function</span></div>
<div class="line"><span class="lineno"> 3168</span><span class="stringliteral">        is expected to return a string with the label for the</span></div>
<div class="line"><span class="lineno"> 3169</span><span class="stringliteral">        leaf.</span></div>
<div class="line"><span class="lineno"> 3170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3171</span><span class="stringliteral">        Indices :math:`k &lt; n` correspond to original observations</span></div>
<div class="line"><span class="lineno"> 3172</span><span class="stringliteral">        while indices :math:`k \\geq n` correspond to non-singleton</span></div>
<div class="line"><span class="lineno"> 3173</span><span class="stringliteral">        clusters.</span></div>
<div class="line"><span class="lineno"> 3174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3175</span><span class="stringliteral">        For example, to label singletons with their node id and</span></div>
<div class="line"><span class="lineno"> 3176</span><span class="stringliteral">        non-singletons with their id, count, and inconsistency</span></div>
<div class="line"><span class="lineno"> 3177</span><span class="stringliteral">        coefficient, simply do::</span></div>
<div class="line"><span class="lineno"> 3178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3179</span><span class="stringliteral">            # First define the leaf label function.</span></div>
<div class="line"><span class="lineno"> 3180</span><span class="stringliteral">            def llf(id):</span></div>
<div class="line"><span class="lineno"> 3181</span><span class="stringliteral">                if id &lt; n:</span></div>
<div class="line"><span class="lineno"> 3182</span><span class="stringliteral">                    return str(id)</span></div>
<div class="line"><span class="lineno"> 3183</span><span class="stringliteral">                else:</span></div>
<div class="line"><span class="lineno"> 3184</span><span class="stringliteral">                    return &#39;[%d %d %1.2f]&#39; % (id, count, R[n-id,3])</span></div>
<div class="line"><span class="lineno"> 3185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3186</span><span class="stringliteral">            # The text for the leaf nodes is going to be big so force</span></div>
<div class="line"><span class="lineno"> 3187</span><span class="stringliteral">            # a rotation of 90 degrees.</span></div>
<div class="line"><span class="lineno"> 3188</span><span class="stringliteral">            dendrogram(Z, leaf_label_func=llf, leaf_rotation=90)</span></div>
<div class="line"><span class="lineno"> 3189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3190</span><span class="stringliteral">            # leaf_label_func can also be used together with ``truncate_mode`` parameter,</span></div>
<div class="line"><span class="lineno"> 3191</span><span class="stringliteral">            # in which case you will get your leaves labeled after truncation:</span></div>
<div class="line"><span class="lineno"> 3192</span><span class="stringliteral">            dendrogram(Z, leaf_label_func=llf, leaf_rotation=90,</span></div>
<div class="line"><span class="lineno"> 3193</span><span class="stringliteral">                       truncate_mode=&#39;level&#39;, p=2)</span></div>
<div class="line"><span class="lineno"> 3194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3195</span><span class="stringliteral">    show_contracted : bool, optional</span></div>
<div class="line"><span class="lineno"> 3196</span><span class="stringliteral">        When True the heights of non-singleton nodes contracted</span></div>
<div class="line"><span class="lineno"> 3197</span><span class="stringliteral">        into a leaf node are plotted as crosses along the link</span></div>
<div class="line"><span class="lineno"> 3198</span><span class="stringliteral">        connecting that leaf node.  This really is only useful when</span></div>
<div class="line"><span class="lineno"> 3199</span><span class="stringliteral">        truncation is used (see ``truncate_mode`` parameter).</span></div>
<div class="line"><span class="lineno"> 3200</span><span class="stringliteral">    link_color_func : callable, optional</span></div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral">        If given, `link_color_function` is called with each non-singleton id</span></div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral">        corresponding to each U-shaped link it will paint. The function is</span></div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">        expected to return the color to paint the link, encoded as a matplotlib</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral">        color string code. For example::</span></div>
<div class="line"><span class="lineno"> 3205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3206</span><span class="stringliteral">            dendrogram(Z, link_color_func=lambda k: colors[k])</span></div>
<div class="line"><span class="lineno"> 3207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3208</span><span class="stringliteral">        colors the direct links below each untruncated non-singleton node</span></div>
<div class="line"><span class="lineno"> 3209</span><span class="stringliteral">        ``k`` using ``colors[k]``.</span></div>
<div class="line"><span class="lineno"> 3210</span><span class="stringliteral">    ax : matplotlib Axes instance, optional</span></div>
<div class="line"><span class="lineno"> 3211</span><span class="stringliteral">        If None and `no_plot` is not True, the dendrogram will be plotted</span></div>
<div class="line"><span class="lineno"> 3212</span><span class="stringliteral">        on the current axes.  Otherwise if `no_plot` is not True the</span></div>
<div class="line"><span class="lineno"> 3213</span><span class="stringliteral">        dendrogram will be plotted on the given ``Axes`` instance. This can be</span></div>
<div class="line"><span class="lineno"> 3214</span><span class="stringliteral">        useful if the dendrogram is part of a more complex figure.</span></div>
<div class="line"><span class="lineno"> 3215</span><span class="stringliteral">    above_threshold_color : str, optional</span></div>
<div class="line"><span class="lineno"> 3216</span><span class="stringliteral">        This matplotlib color string sets the color of the links above the</span></div>
<div class="line"><span class="lineno"> 3217</span><span class="stringliteral">        color_threshold. The default is ``&#39;C0&#39;``.</span></div>
<div class="line"><span class="lineno"> 3218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3219</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3220</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral">    R : dict</span></div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral">        A dictionary of data structures computed to render the</span></div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral">        dendrogram. Its has the following keys:</span></div>
<div class="line"><span class="lineno"> 3224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3225</span><span class="stringliteral">        ``&#39;color_list&#39;``</span></div>
<div class="line"><span class="lineno"> 3226</span><span class="stringliteral">          A list of color names. The k&#39;th element represents the color of the</span></div>
<div class="line"><span class="lineno"> 3227</span><span class="stringliteral">          k&#39;th link.</span></div>
<div class="line"><span class="lineno"> 3228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3229</span><span class="stringliteral">        ``&#39;icoord&#39;`` and ``&#39;dcoord&#39;``</span></div>
<div class="line"><span class="lineno"> 3230</span><span class="stringliteral">          Each of them is a list of lists. Let ``icoord = [I1, I2, ..., Ip]``</span></div>
<div class="line"><span class="lineno"> 3231</span><span class="stringliteral">          where ``Ik = [xk1, xk2, xk3, xk4]`` and ``dcoord = [D1, D2, ..., Dp]``</span></div>
<div class="line"><span class="lineno"> 3232</span><span class="stringliteral">          where ``Dk = [yk1, yk2, yk3, yk4]``, then the k&#39;th link painted is</span></div>
<div class="line"><span class="lineno"> 3233</span><span class="stringliteral">          ``(xk1, yk1)`` - ``(xk2, yk2)`` - ``(xk3, yk3)`` - ``(xk4, yk4)``.</span></div>
<div class="line"><span class="lineno"> 3234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3235</span><span class="stringliteral">        ``&#39;ivl&#39;``</span></div>
<div class="line"><span class="lineno"> 3236</span><span class="stringliteral">          A list of labels corresponding to the leaf nodes.</span></div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral">        ``&#39;leaves&#39;``</span></div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral">          For each i, ``H[i] == j``, cluster node ``j`` appears in position</span></div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">          ``i`` in the left-to-right traversal of the leaves, where</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral">          :math:`j &lt; 2n-1` and :math:`i &lt; n`. If ``j`` is less than ``n``, the</span></div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral">          ``i``-th leaf node corresponds to an original observation.</span></div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral">          Otherwise, it corresponds to a non-singleton cluster.</span></div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">        ``&#39;leaves_color_list&#39;``</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral">          A list of color names. The k&#39;th element represents the color of the</span></div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">          k&#39;th leaf.</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral">    linkage, set_link_color_palette</span></div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">    It is expected that the distances in ``Z[:,2]`` be monotonic, otherwise</span></div>
<div class="line"><span class="lineno"> 3256</span><span class="stringliteral">    crossings appear in the dendrogram.</span></div>
<div class="line"><span class="lineno"> 3257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3258</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3259</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3260</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster import hierarchy</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral">    A very basic example:</span></div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3265</span><span class="stringliteral">    &gt;&gt;&gt; ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268.,</span></div>
<div class="line"><span class="lineno"> 3266</span><span class="stringliteral">    ...                    400., 754., 564., 138., 219., 869., 669.])</span></div>
<div class="line"><span class="lineno"> 3267</span><span class="stringliteral">    &gt;&gt;&gt; Z = hierarchy.linkage(ytdist, &#39;single&#39;)</span></div>
<div class="line"><span class="lineno"> 3268</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral">    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z)</span></div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3271</span><span class="stringliteral">    Now, plot in given axes, improve the color scheme and use both vertical and</span></div>
<div class="line"><span class="lineno"> 3272</span><span class="stringliteral">    horizontal orientations:</span></div>
<div class="line"><span class="lineno"> 3273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3274</span><span class="stringliteral">    &gt;&gt;&gt; hierarchy.set_link_color_palette([&#39;m&#39;, &#39;c&#39;, &#39;y&#39;, &#39;k&#39;])</span></div>
<div class="line"><span class="lineno"> 3275</span><span class="stringliteral">    &gt;&gt;&gt; fig, axes = plt.subplots(1, 2, figsize=(8, 3))</span></div>
<div class="line"><span class="lineno"> 3276</span><span class="stringliteral">    &gt;&gt;&gt; dn1 = hierarchy.dendrogram(Z, ax=axes[0], above_threshold_color=&#39;y&#39;,</span></div>
<div class="line"><span class="lineno"> 3277</span><span class="stringliteral">    ...                            orientation=&#39;top&#39;)</span></div>
<div class="line"><span class="lineno"> 3278</span><span class="stringliteral">    &gt;&gt;&gt; dn2 = hierarchy.dendrogram(Z, ax=axes[1],</span></div>
<div class="line"><span class="lineno"> 3279</span><span class="stringliteral">    ...                            above_threshold_color=&#39;#bcbddc&#39;,</span></div>
<div class="line"><span class="lineno"> 3280</span><span class="stringliteral">    ...                            orientation=&#39;right&#39;)</span></div>
<div class="line"><span class="lineno"> 3281</span><span class="stringliteral">    &gt;&gt;&gt; hierarchy.set_link_color_palette(None)  # reset to default after use</span></div>
<div class="line"><span class="lineno"> 3282</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3284</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3285</span>    <span class="comment"># This feature was thought about but never implemented (still useful?):</span></div>
<div class="line"><span class="lineno"> 3286</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3287</span>    <span class="comment">#         ... = dendrogram(..., leaves_order=None)</span></div>
<div class="line"><span class="lineno"> 3288</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3289</span>    <span class="comment">#         Plots the leaves in the order specified by a vector of</span></div>
<div class="line"><span class="lineno"> 3290</span>    <span class="comment">#         original observation indices. If the vector contains duplicates</span></div>
<div class="line"><span class="lineno"> 3291</span>    <span class="comment">#         or results in a crossing, an exception will be thrown. Passing</span></div>
<div class="line"><span class="lineno"> 3292</span>    <span class="comment">#         None orders leaf nodes based on the order they appear in the</span></div>
<div class="line"><span class="lineno"> 3293</span>    <span class="comment">#         pre-order traversal.</span></div>
<div class="line"><span class="lineno"> 3294</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 3295</span> </div>
<div class="line"><span class="lineno"> 3296</span>    <span class="keywordflow">if</span> orientation <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;top&quot;</span>, <span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;bottom&quot;</span>, <span class="stringliteral">&quot;right&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3297</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;orientation must be one of &#39;top&#39;, &#39;left&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 3298</span>                         <span class="stringliteral">&quot;&#39;bottom&#39;, or &#39;right&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 3299</span> </div>
<div class="line"><span class="lineno"> 3300</span>    <span class="keywordflow">if</span> labels <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> Z.shape[0] + 1 != len(labels):</div>
<div class="line"><span class="lineno"> 3301</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Dimensions of Z and labels must be consistent.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3302</span> </div>
<div class="line"><span class="lineno"> 3303</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 3304</span>    Zs = Z.shape</div>
<div class="line"><span class="lineno"> 3305</span>    n = Zs[0] + 1</div>
<div class="line"><span class="lineno"> 3306</span>    <span class="keywordflow">if</span> type(p) <span class="keywordflow">in</span> (int, float):</div>
<div class="line"><span class="lineno"> 3307</span>        p = int(p)</div>
<div class="line"><span class="lineno"> 3308</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3309</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;The second argument must be a number&#39;</span>)</div>
<div class="line"><span class="lineno"> 3310</span> </div>
<div class="line"><span class="lineno"> 3311</span>    <span class="keywordflow">if</span> truncate_mode <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;lastp&#39;</span>, <span class="stringliteral">&#39;mtica&#39;</span>, <span class="stringliteral">&#39;level&#39;</span>, <span class="stringliteral">&#39;none&#39;</span>, <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3312</span>        <span class="comment"># &#39;mtica&#39; is kept working for backwards compat.</span></div>
<div class="line"><span class="lineno"> 3313</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Invalid truncation mode.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3314</span> </div>
<div class="line"><span class="lineno"> 3315</span>    <span class="keywordflow">if</span> truncate_mode == <span class="stringliteral">&#39;lastp&#39;</span>:</div>
<div class="line"><span class="lineno"> 3316</span>        <span class="keywordflow">if</span> p &gt; n <span class="keywordflow">or</span> p == 0:</div>
<div class="line"><span class="lineno"> 3317</span>            p = n</div>
<div class="line"><span class="lineno"> 3318</span> </div>
<div class="line"><span class="lineno"> 3319</span>    <span class="keywordflow">if</span> truncate_mode == <span class="stringliteral">&#39;mtica&#39;</span>:</div>
<div class="line"><span class="lineno"> 3320</span>        <span class="comment"># &#39;mtica&#39; is an alias</span></div>
<div class="line"><span class="lineno"> 3321</span>        truncate_mode = <span class="stringliteral">&#39;level&#39;</span></div>
<div class="line"><span class="lineno"> 3322</span> </div>
<div class="line"><span class="lineno"> 3323</span>    <span class="keywordflow">if</span> truncate_mode == <span class="stringliteral">&#39;level&#39;</span>:</div>
<div class="line"><span class="lineno"> 3324</span>        <span class="keywordflow">if</span> p &lt;= 0:</div>
<div class="line"><span class="lineno"> 3325</span>            p = np.inf</div>
<div class="line"><span class="lineno"> 3326</span> </div>
<div class="line"><span class="lineno"> 3327</span>    <span class="keywordflow">if</span> get_leaves:</div>
<div class="line"><span class="lineno"> 3328</span>        lvs = []</div>
<div class="line"><span class="lineno"> 3329</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3330</span>        lvs = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3331</span> </div>
<div class="line"><span class="lineno"> 3332</span>    icoord_list = []</div>
<div class="line"><span class="lineno"> 3333</span>    dcoord_list = []</div>
<div class="line"><span class="lineno"> 3334</span>    color_list = []</div>
<div class="line"><span class="lineno"> 3335</span>    current_color = [0]</div>
<div class="line"><span class="lineno"> 3336</span>    currently_below_threshold = [<span class="keyword">False</span>]</div>
<div class="line"><span class="lineno"> 3337</span>    ivl = []  <span class="comment"># list of leaves</span></div>
<div class="line"><span class="lineno"> 3338</span> </div>
<div class="line"><span class="lineno"> 3339</span>    <span class="keywordflow">if</span> color_threshold <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> (isinstance(color_threshold, str) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno"> 3340</span>                                   color_threshold == <span class="stringliteral">&#39;default&#39;</span>):</div>
<div class="line"><span class="lineno"> 3341</span>        color_threshold = max(Z[:, 2]) * 0.7</div>
<div class="line"><span class="lineno"> 3342</span> </div>
<div class="line"><span class="lineno"> 3343</span>    R = {<span class="stringliteral">&#39;icoord&#39;</span>: icoord_list, <span class="stringliteral">&#39;dcoord&#39;</span>: dcoord_list, <span class="stringliteral">&#39;ivl&#39;</span>: ivl,</div>
<div class="line"><span class="lineno"> 3344</span>         <span class="stringliteral">&#39;leaves&#39;</span>: lvs, <span class="stringliteral">&#39;color_list&#39;</span>: color_list}</div>
<div class="line"><span class="lineno"> 3345</span> </div>
<div class="line"><span class="lineno"> 3346</span>    <span class="comment"># Empty list will be filled in _dendrogram_calculate_info</span></div>
<div class="line"><span class="lineno"> 3347</span>    contraction_marks = [] <span class="keywordflow">if</span> show_contracted <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3348</span> </div>
<div class="line"><span class="lineno"> 3349</span>    _dendrogram_calculate_info(</div>
<div class="line"><span class="lineno"> 3350</span>        Z=Z, p=p,</div>
<div class="line"><span class="lineno"> 3351</span>        truncate_mode=truncate_mode,</div>
<div class="line"><span class="lineno"> 3352</span>        color_threshold=color_threshold,</div>
<div class="line"><span class="lineno"> 3353</span>        get_leaves=get_leaves,</div>
<div class="line"><span class="lineno"> 3354</span>        orientation=orientation,</div>
<div class="line"><span class="lineno"> 3355</span>        labels=labels,</div>
<div class="line"><span class="lineno"> 3356</span>        count_sort=count_sort,</div>
<div class="line"><span class="lineno"> 3357</span>        distance_sort=distance_sort,</div>
<div class="line"><span class="lineno"> 3358</span>        show_leaf_counts=show_leaf_counts,</div>
<div class="line"><span class="lineno"> 3359</span>        i=2*n - 2,</div>
<div class="line"><span class="lineno"> 3360</span>        iv=0.0,</div>
<div class="line"><span class="lineno"> 3361</span>        ivl=ivl,</div>
<div class="line"><span class="lineno"> 3362</span>        n=n,</div>
<div class="line"><span class="lineno"> 3363</span>        icoord_list=icoord_list,</div>
<div class="line"><span class="lineno"> 3364</span>        dcoord_list=dcoord_list,</div>
<div class="line"><span class="lineno"> 3365</span>        lvs=lvs,</div>
<div class="line"><span class="lineno"> 3366</span>        current_color=current_color,</div>
<div class="line"><span class="lineno"> 3367</span>        color_list=color_list,</div>
<div class="line"><span class="lineno"> 3368</span>        currently_below_threshold=currently_below_threshold,</div>
<div class="line"><span class="lineno"> 3369</span>        leaf_label_func=leaf_label_func,</div>
<div class="line"><span class="lineno"> 3370</span>        contraction_marks=contraction_marks,</div>
<div class="line"><span class="lineno"> 3371</span>        link_color_func=link_color_func,</div>
<div class="line"><span class="lineno"> 3372</span>        above_threshold_color=above_threshold_color)</div>
<div class="line"><span class="lineno"> 3373</span> </div>
<div class="line"><span class="lineno"> 3374</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> no_plot:</div>
<div class="line"><span class="lineno"> 3375</span>        mh = max(Z[:, 2])</div>
<div class="line"><span class="lineno"> 3376</span>        _plot_dendrogram(icoord_list, dcoord_list, ivl, p, n, mh, orientation,</div>
<div class="line"><span class="lineno"> 3377</span>                         no_labels, color_list,</div>
<div class="line"><span class="lineno"> 3378</span>                         leaf_font_size=leaf_font_size,</div>
<div class="line"><span class="lineno"> 3379</span>                         leaf_rotation=leaf_rotation,</div>
<div class="line"><span class="lineno"> 3380</span>                         contraction_marks=contraction_marks,</div>
<div class="line"><span class="lineno"> 3381</span>                         ax=ax,</div>
<div class="line"><span class="lineno"> 3382</span>                         above_threshold_color=above_threshold_color)</div>
<div class="line"><span class="lineno"> 3383</span> </div>
<div class="line"><span class="lineno"> 3384</span>    R[<span class="stringliteral">&quot;leaves_color_list&quot;</span>] = _get_leaves_color_list(R)</div>
<div class="line"><span class="lineno"> 3385</span> </div>
<div class="line"><span class="lineno"> 3386</span>    <span class="keywordflow">return</span> R</div>
<div class="line"><span class="lineno"> 3387</span> </div>
<div class="line"><span class="lineno"> 3388</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af6e31fbe2fa33eec7d23778b83b60a61" name="af6e31fbe2fa33eec7d23778b83b60a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e31fbe2fa33eec7d23778b83b60a61">&#9670;&#160;</a></span>fcluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.fcluster </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>criterion</em> = <code>'<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aae973440fe7f7bd476f26f178da6ad7f">inconsistent</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>monocrit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Form flat clusters from the hierarchical clustering defined by
the given linkage matrix.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded with the matrix returned
    by the `linkage` function.
t : scalar
    For criteria 'inconsistent', 'distance' or 'monocrit',
     this is the threshold to apply when forming flat clusters.
    For 'maxclust' or 'maxclust_monocrit' criteria,
     this would be max number of clusters requested.
criterion : str, optional
    The criterion to use in forming flat clusters. This can
    be any of the following values:

      ``inconsistent`` :
          If a cluster node and all its
          descendants have an inconsistent value less than or equal
          to `t`, then all its leaf descendants belong to the
          same flat cluster. When no non-singleton cluster meets
          this criterion, every node is assigned to its own
          cluster. (Default)

      ``distance`` :
          Forms flat clusters so that the original
          observations in each flat cluster have no greater a
          cophenetic distance than `t`.

      ``maxclust`` :
          Finds a minimum threshold ``r`` so that
          the cophenetic distance between any two original
          observations in the same flat cluster is no more than
          ``r`` and no more than `t` flat clusters are formed.

      ``monocrit`` :
          Forms a flat cluster from a cluster node c
          with index i when ``monocrit[j] &lt;= t``.

          For example, to threshold on the maximum mean distance
          as computed in the inconsistency matrix R with a
          threshold of 0.8 do::

              MR = maxRstat(Z, R, 3)
              fcluster(Z, t=0.8, criterion='monocrit', monocrit=MR)

      ``maxclust_monocrit`` :
          Forms a flat cluster from a
          non-singleton cluster node ``c`` when ``monocrit[i] &lt;=
          r`` for all cluster indices ``i`` below and including
          ``c``. ``r`` is minimized such that no more than ``t``
          flat clusters are formed. monocrit must be
          monotonic. For example, to minimize the threshold t on
          maximum inconsistency values so that no more than 3 flat
          clusters are formed, do::

              MI = maxinconsts(Z, R)
              fcluster(Z, t=3, criterion='maxclust_monocrit', monocrit=MI)
depth : int, optional
    The maximum depth to perform the inconsistency calculation.
    It has no meaning for the other criteria. Default is 2.
R : ndarray, optional
    The inconsistency matrix to use for the 'inconsistent'
    criterion. This matrix is computed if not provided.
monocrit : ndarray, optional
    An array of length n-1. `monocrit[i]` is the
    statistics upon which non-singleton i is thresholded. The
    monocrit vector must be monotonic, i.e., given a node c with
    index i, for all node indices j corresponding to nodes
    below c, ``monocrit[i] &gt;= monocrit[j]``.

Returns
-------
fcluster : ndarray
    An array of length ``n``. ``T[i]`` is the flat cluster number to
    which original observation ``i`` belongs.

See Also
--------
linkage : for information about hierarchical clustering methods work.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

All cluster linkage methods - e.g., `scipy.cluster.hierarchy.ward`
generate a linkage matrix ``Z`` as their output:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))

&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.29099445,  3.        ],
       [ 5.        , 13.        ,  1.29099445,  3.        ],
       [ 8.        , 14.        ,  1.29099445,  3.        ],
       [11.        , 15.        ,  1.29099445,  3.        ],
       [16.        , 17.        ,  5.77350269,  6.        ],
       [18.        , 19.        ,  5.77350269,  6.        ],
       [20.        , 21.        ,  8.16496581, 12.        ]])

This matrix represents a dendrogram, where the first and second elements
are the two clusters merged at each step, the third element is the
distance between these clusters, and the fourth element is the size of
the new cluster - the number of original data points included.

`scipy.cluster.hierarchy.fcluster` can be used to flatten the
dendrogram, obtaining as a result an assignation of the original data
points to single clusters.

This assignation mostly depends on a distance threshold ``t`` - the maximum
inter-cluster distance allowed:

&gt;&gt;&gt; fcluster(Z, t=0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)

&gt;&gt;&gt; fcluster(Z, t=1.1, criterion='distance')
array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32)

&gt;&gt;&gt; fcluster(Z, t=3, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)

&gt;&gt;&gt; fcluster(Z, t=9, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

In the first case, the threshold ``t`` is too small to allow any two
samples in the data to form a cluster, so 12 different clusters are
returned.

In the second case, the threshold is large enough to allow the first
4 points to be merged with their nearest neighbors. So, here, only 8
clusters are returned.

The third case, with a much higher threshold, allows for up to 8 data
points to be connected - so 4 clusters are returned here.

Lastly, the threshold of the fourth case is large enough to allow for
all data points to be merged together - so a single cluster is returned.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2426</span><span class="keyword">def </span>fcluster(Z, t, criterion=&#39;inconsistent&#39;, depth=2, R=None, monocrit=None):</div>
<div class="line"><span class="lineno"> 2427</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2428</span><span class="stringliteral">    Form flat clusters from the hierarchical clustering defined by</span></div>
<div class="line"><span class="lineno"> 2429</span><span class="stringliteral">    the given linkage matrix.</span></div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">        The hierarchical clustering encoded with the matrix returned</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">        by the `linkage` function.</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">    t : scalar</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">        For criteria &#39;inconsistent&#39;, &#39;distance&#39; or &#39;monocrit&#39;,</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">         this is the threshold to apply when forming flat clusters.</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">        For &#39;maxclust&#39; or &#39;maxclust_monocrit&#39; criteria,</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral">         this would be max number of clusters requested.</span></div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    criterion : str, optional</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">        The criterion to use in forming flat clusters. This can</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">        be any of the following values:</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">          ``inconsistent`` :</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral">              If a cluster node and all its</span></div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">              descendants have an inconsistent value less than or equal</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral">              to `t`, then all its leaf descendants belong to the</span></div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">              same flat cluster. When no non-singleton cluster meets</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">              this criterion, every node is assigned to its own</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral">              cluster. (Default)</span></div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">          ``distance`` :</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">              Forms flat clusters so that the original</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">              observations in each flat cluster have no greater a</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">              cophenetic distance than `t`.</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">          ``maxclust`` :</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">              Finds a minimum threshold ``r`` so that</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral">              the cophenetic distance between any two original</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">              observations in the same flat cluster is no more than</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral">              ``r`` and no more than `t` flat clusters are formed.</span></div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">          ``monocrit`` :</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">              Forms a flat cluster from a cluster node c</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral">              with index i when ``monocrit[j] &lt;= t``.</span></div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral">              For example, to threshold on the maximum mean distance</span></div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">              as computed in the inconsistency matrix R with a</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral">              threshold of 0.8 do::</span></div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral">                  MR = maxRstat(Z, R, 3)</span></div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">                  fcluster(Z, t=0.8, criterion=&#39;monocrit&#39;, monocrit=MR)</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">          ``maxclust_monocrit`` :</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">              Forms a flat cluster from a</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral">              non-singleton cluster node ``c`` when ``monocrit[i] &lt;=</span></div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">              r`` for all cluster indices ``i`` below and including</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">              ``c``. ``r`` is minimized such that no more than ``t``</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral">              flat clusters are formed. monocrit must be</span></div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">              monotonic. For example, to minimize the threshold t on</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">              maximum inconsistency values so that no more than 3 flat</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">              clusters are formed, do::</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral">                  MI = maxinconsts(Z, R)</span></div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">                  fcluster(Z, t=3, criterion=&#39;maxclust_monocrit&#39;, monocrit=MI)</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    depth : int, optional</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">        The maximum depth to perform the inconsistency calculation.</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">        It has no meaning for the other criteria. Default is 2.</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral">    R : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">        The inconsistency matrix to use for the &#39;inconsistent&#39;</span></div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral">        criterion. This matrix is computed if not provided.</span></div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">    monocrit : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral">        An array of length n-1. `monocrit[i]` is the</span></div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral">        statistics upon which non-singleton i is thresholded. The</span></div>
<div class="line"><span class="lineno"> 2496</span><span class="stringliteral">        monocrit vector must be monotonic, i.e., given a node c with</span></div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral">        index i, for all node indices j corresponding to nodes</span></div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral">        below c, ``monocrit[i] &gt;= monocrit[j]``.</span></div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">    fcluster : ndarray</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">        An array of length ``n``. ``T[i]`` is the flat cluster number to</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral">        which original observation ``i`` belongs.</span></div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral">    linkage : for information about hierarchical clustering methods work.</span></div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2515</span><span class="stringliteral">    All cluster linkage methods - e.g., `scipy.cluster.hierarchy.ward`</span></div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">    generate a linkage matrix ``Z`` as their output:</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">           [ 2.        , 12.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral">           [ 5.        , 13.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">           [ 8.        , 14.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">           [11.        , 15.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">           [16.        , 17.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">           [18.        , 19.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2536</span><span class="stringliteral">           [20.        , 21.        ,  8.16496581, 12.        ]])</span></div>
<div class="line"><span class="lineno"> 2537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2538</span><span class="stringliteral">    This matrix represents a dendrogram, where the first and second elements</span></div>
<div class="line"><span class="lineno"> 2539</span><span class="stringliteral">    are the two clusters merged at each step, the third element is the</span></div>
<div class="line"><span class="lineno"> 2540</span><span class="stringliteral">    distance between these clusters, and the fourth element is the size of</span></div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">    the new cluster - the number of original data points included.</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral">    `scipy.cluster.hierarchy.fcluster` can be used to flatten the</span></div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">    dendrogram, obtaining as a result an assignation of the original data</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral">    points to single clusters.</span></div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral">    This assignation mostly depends on a distance threshold ``t`` - the maximum</span></div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">    inter-cluster distance allowed:</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, t=0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral">    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, t=1.1, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral">    array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 2555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2556</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, t=3, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno"> 2557</span><span class="stringliteral">    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 2558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, t=9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral">    In the first case, the threshold ``t`` is too small to allow any two</span></div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">    samples in the data to form a cluster, so 12 different clusters are</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">    returned.</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">    In the second case, the threshold is large enough to allow the first</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">    4 points to be merged with their nearest neighbors. So, here, only 8</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral">    clusters are returned.</span></div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral">    The third case, with a much higher threshold, allows for up to 8 data</span></div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral">    points to be connected - so 4 clusters are returned here.</span></div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">    Lastly, the threshold of the fourth case is large enough to allow for</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral">    all data points to be merged together - so a single cluster is returned.</span></div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2577</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2578</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 2579</span> </div>
<div class="line"><span class="lineno"> 2580</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 2581</span>    T = np.zeros((n,), dtype=<span class="stringliteral">&#39;i&#39;</span>)</div>
<div class="line"><span class="lineno"> 2582</span> </div>
<div class="line"><span class="lineno"> 2583</span>    <span class="comment"># Since the C code does not support striding using strides.</span></div>
<div class="line"><span class="lineno"> 2584</span>    <span class="comment"># The dimensions are used instead.</span></div>
<div class="line"><span class="lineno"> 2585</span>    [Z] = _copy_arrays_if_base_present([Z])</div>
<div class="line"><span class="lineno"> 2586</span> </div>
<div class="line"><span class="lineno"> 2587</span>    <span class="keywordflow">if</span> criterion == <span class="stringliteral">&#39;inconsistent&#39;</span>:</div>
<div class="line"><span class="lineno"> 2588</span>        <span class="keywordflow">if</span> R <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2589</span>            R = inconsistent(Z, depth)</div>
<div class="line"><span class="lineno"> 2590</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2591</span>            R = np.asarray(R, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2592</span>            is_valid_im(R, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;R&#39;</span>)</div>
<div class="line"><span class="lineno"> 2593</span>            <span class="comment"># Since the C code does not support striding using strides.</span></div>
<div class="line"><span class="lineno"> 2594</span>            <span class="comment"># The dimensions are used instead.</span></div>
<div class="line"><span class="lineno"> 2595</span>            [R] = _copy_arrays_if_base_present([R])</div>
<div class="line"><span class="lineno"> 2596</span>        _hierarchy.cluster_in(Z, R, T, float(t), int(n))</div>
<div class="line"><span class="lineno"> 2597</span>    <span class="keywordflow">elif</span> criterion == <span class="stringliteral">&#39;distance&#39;</span>:</div>
<div class="line"><span class="lineno"> 2598</span>        _hierarchy.cluster_dist(Z, T, float(t), int(n))</div>
<div class="line"><span class="lineno"> 2599</span>    <span class="keywordflow">elif</span> criterion == <span class="stringliteral">&#39;maxclust&#39;</span>:</div>
<div class="line"><span class="lineno"> 2600</span>        _hierarchy.cluster_maxclust_dist(Z, T, int(n), int(t))</div>
<div class="line"><span class="lineno"> 2601</span>    <span class="keywordflow">elif</span> criterion == <span class="stringliteral">&#39;monocrit&#39;</span>:</div>
<div class="line"><span class="lineno"> 2602</span>        [monocrit] = _copy_arrays_if_base_present([monocrit])</div>
<div class="line"><span class="lineno"> 2603</span>        _hierarchy.cluster_monocrit(Z, monocrit, T, float(t), int(n))</div>
<div class="line"><span class="lineno"> 2604</span>    <span class="keywordflow">elif</span> criterion == <span class="stringliteral">&#39;maxclust_monocrit&#39;</span>:</div>
<div class="line"><span class="lineno"> 2605</span>        [monocrit] = _copy_arrays_if_base_present([monocrit])</div>
<div class="line"><span class="lineno"> 2606</span>        _hierarchy.cluster_maxclust_monocrit(Z, monocrit, T, int(n), int(t))</div>
<div class="line"><span class="lineno"> 2607</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2608</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Invalid cluster formation criterion: %s&#39;</span></div>
<div class="line"><span class="lineno"> 2609</span>                         % str(criterion))</div>
<div class="line"><span class="lineno"> 2610</span>    <span class="keywordflow">return</span> T</div>
<div class="line"><span class="lineno"> 2611</span> </div>
<div class="line"><span class="lineno"> 2612</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e5987ff126b9d427ef17f702ffce6cc" name="a8e5987ff126b9d427ef17f702ffce6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5987ff126b9d427ef17f702ffce6cc">&#9670;&#160;</a></span>fclusterdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.fclusterdata </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>criterion</em> = <code>'<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aae973440fe7f7bd476f26f178da6ad7f">inconsistent</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>'euclidean'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a3d0362e93aa51d35d3895395af758fb5">single</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cluster observation data using a given metric.

Clusters the original observations in the n-by-m data
matrix X (n observations in m dimensions), using the euclidean
distance metric to calculate distances between original observations,
performs hierarchical clustering using the single linkage algorithm,
and forms flat clusters using the inconsistency method with `t` as the
cut-off threshold.

A 1-D array ``T`` of length ``n`` is returned. ``T[i]`` is
the index of the flat cluster to which the original observation ``i``
belongs.

Parameters
----------
X : (N, M) ndarray
    N by M data matrix with N observations in M dimensions.
t : scalar
    For criteria 'inconsistent', 'distance' or 'monocrit',
     this is the threshold to apply when forming flat clusters.
    For 'maxclust' or 'maxclust_monocrit' criteria,
     this would be max number of clusters requested.
criterion : str, optional
    Specifies the criterion for forming flat clusters. Valid
    values are 'inconsistent' (default), 'distance', or 'maxclust'
    cluster formation algorithms. See `fcluster` for descriptions.
metric : str or function, optional
    The distance metric for calculating pairwise distances. See
    ``distance.pdist`` for descriptions and linkage to verify
    compatibility with the linkage method.
depth : int, optional
    The maximum depth for the inconsistency calculation. See
    `inconsistent` for more information.
method : str, optional
    The linkage method to use (single, complete, average,
    weighted, median centroid, ward). See `linkage` for more
    information. Default is "single".
R : ndarray, optional
    The inconsistency matrix. It will be computed if necessary
    if it is not passed.

Returns
-------
fclusterdata : ndarray
    A vector of length n. T[i] is the flat cluster number to
    which original observation i belongs.

See Also
--------
scipy.spatial.distance.pdist : pairwise distance metrics

Notes
-----
This function is similar to the MATLAB function ``clusterdata``.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import fclusterdata

This is a convenience method that abstracts all the steps to perform in a
typical SciPy's hierarchical clustering workflow.

* Transform the input data into a condensed matrix with `scipy.spatial.distance.pdist`.

* Apply a clustering method.

* Obtain flat clusters at a user defined distance threshold ``t`` using `scipy.cluster.hierarchy.fcluster`.

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; fclusterdata(X, t=1)
array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)

The output here (for the dataset ``X``, distance threshold ``t``, and the
default settings) is four clusters with three data points each.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2614</span>                 metric=<span class="stringliteral">&#39;euclidean&#39;</span>, depth=2, method=<span class="stringliteral">&#39;single&#39;</span>, R=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2615</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2616</span><span class="stringliteral">    Cluster observation data using a given metric.</span></div>
<div class="line"><span class="lineno"> 2617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2618</span><span class="stringliteral">    Clusters the original observations in the n-by-m data</span></div>
<div class="line"><span class="lineno"> 2619</span><span class="stringliteral">    matrix X (n observations in m dimensions), using the euclidean</span></div>
<div class="line"><span class="lineno"> 2620</span><span class="stringliteral">    distance metric to calculate distances between original observations,</span></div>
<div class="line"><span class="lineno"> 2621</span><span class="stringliteral">    performs hierarchical clustering using the single linkage algorithm,</span></div>
<div class="line"><span class="lineno"> 2622</span><span class="stringliteral">    and forms flat clusters using the inconsistency method with `t` as the</span></div>
<div class="line"><span class="lineno"> 2623</span><span class="stringliteral">    cut-off threshold.</span></div>
<div class="line"><span class="lineno"> 2624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2625</span><span class="stringliteral">    A 1-D array ``T`` of length ``n`` is returned. ``T[i]`` is</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral">    the index of the flat cluster to which the original observation ``i``</span></div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral">    belongs.</span></div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2630</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2631</span><span class="stringliteral">    X : (N, M) ndarray</span></div>
<div class="line"><span class="lineno"> 2632</span><span class="stringliteral">        N by M data matrix with N observations in M dimensions.</span></div>
<div class="line"><span class="lineno"> 2633</span><span class="stringliteral">    t : scalar</span></div>
<div class="line"><span class="lineno"> 2634</span><span class="stringliteral">        For criteria &#39;inconsistent&#39;, &#39;distance&#39; or &#39;monocrit&#39;,</span></div>
<div class="line"><span class="lineno"> 2635</span><span class="stringliteral">         this is the threshold to apply when forming flat clusters.</span></div>
<div class="line"><span class="lineno"> 2636</span><span class="stringliteral">        For &#39;maxclust&#39; or &#39;maxclust_monocrit&#39; criteria,</span></div>
<div class="line"><span class="lineno"> 2637</span><span class="stringliteral">         this would be max number of clusters requested.</span></div>
<div class="line"><span class="lineno"> 2638</span><span class="stringliteral">    criterion : str, optional</span></div>
<div class="line"><span class="lineno"> 2639</span><span class="stringliteral">        Specifies the criterion for forming flat clusters. Valid</span></div>
<div class="line"><span class="lineno"> 2640</span><span class="stringliteral">        values are &#39;inconsistent&#39; (default), &#39;distance&#39;, or &#39;maxclust&#39;</span></div>
<div class="line"><span class="lineno"> 2641</span><span class="stringliteral">        cluster formation algorithms. See `fcluster` for descriptions.</span></div>
<div class="line"><span class="lineno"> 2642</span><span class="stringliteral">    metric : str or function, optional</span></div>
<div class="line"><span class="lineno"> 2643</span><span class="stringliteral">        The distance metric for calculating pairwise distances. See</span></div>
<div class="line"><span class="lineno"> 2644</span><span class="stringliteral">        ``distance.pdist`` for descriptions and linkage to verify</span></div>
<div class="line"><span class="lineno"> 2645</span><span class="stringliteral">        compatibility with the linkage method.</span></div>
<div class="line"><span class="lineno"> 2646</span><span class="stringliteral">    depth : int, optional</span></div>
<div class="line"><span class="lineno"> 2647</span><span class="stringliteral">        The maximum depth for the inconsistency calculation. See</span></div>
<div class="line"><span class="lineno"> 2648</span><span class="stringliteral">        `inconsistent` for more information.</span></div>
<div class="line"><span class="lineno"> 2649</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno"> 2650</span><span class="stringliteral">        The linkage method to use (single, complete, average,</span></div>
<div class="line"><span class="lineno"> 2651</span><span class="stringliteral">        weighted, median centroid, ward). See `linkage` for more</span></div>
<div class="line"><span class="lineno"> 2652</span><span class="stringliteral">        information. Default is &quot;single&quot;.</span></div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral">    R : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral">        The inconsistency matrix. It will be computed if necessary</span></div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral">        if it is not passed.</span></div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2658</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2659</span><span class="stringliteral">    fclusterdata : ndarray</span></div>
<div class="line"><span class="lineno"> 2660</span><span class="stringliteral">        A vector of length n. T[i] is the flat cluster number to</span></div>
<div class="line"><span class="lineno"> 2661</span><span class="stringliteral">        which original observation i belongs.</span></div>
<div class="line"><span class="lineno"> 2662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2663</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2665</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno"> 2666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2667</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2668</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2669</span><span class="stringliteral">    This function is similar to the MATLAB function ``clusterdata``.</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import fclusterdata</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">    This is a convenience method that abstracts all the steps to perform in a</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral">    typical SciPy&#39;s hierarchical clustering workflow.</span></div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral">    * Transform the input data into a condensed matrix with `scipy.spatial.distance.pdist`.</span></div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">    * Apply a clustering method.</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral">    * Obtain flat clusters at a user defined distance threshold ``t`` using `scipy.cluster.hierarchy.fcluster`.</span></div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2688</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2689</span><span class="stringliteral">    &gt;&gt;&gt; fclusterdata(X, t=1)</span></div>
<div class="line"><span class="lineno"> 2690</span><span class="stringliteral">    array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 2691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2692</span><span class="stringliteral">    The output here (for the dataset ``X``, distance threshold ``t``, and the</span></div>
<div class="line"><span class="lineno"> 2693</span><span class="stringliteral">    default settings) is four clusters with three data points each.</span></div>
<div class="line"><span class="lineno"> 2694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2695</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2696</span>    X = np.asarray(X, order=<span class="stringliteral">&#39;c&#39;</span>, dtype=np.double)</div>
<div class="line"><span class="lineno"> 2697</span> </div>
<div class="line"><span class="lineno"> 2698</span>    <span class="keywordflow">if</span> type(X) != np.ndarray <span class="keywordflow">or</span> len(X.shape) != 2:</div>
<div class="line"><span class="lineno"> 2699</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;The observation matrix X must be an n by m numpy &#39;</span></div>
<div class="line"><span class="lineno"> 2700</span>                        <span class="stringliteral">&#39;array.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2701</span> </div>
<div class="line"><span class="lineno"> 2702</span>    Y = distance.pdist(X, metric=metric)</div>
<div class="line"><span class="lineno"> 2703</span>    Z = linkage(Y, method=method)</div>
<div class="line"><span class="lineno"> 2704</span>    <span class="keywordflow">if</span> R <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2705</span>        R = inconsistent(Z, d=depth)</div>
<div class="line"><span class="lineno"> 2706</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2707</span>        R = np.asarray(R, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2708</span>    T = fcluster(Z, criterion=criterion, depth=depth, R=R, t=t)</div>
<div class="line"><span class="lineno"> 2709</span>    <span class="keywordflow">return</span> T</div>
<div class="line"><span class="lineno"> 2710</span> </div>
<div class="line"><span class="lineno"> 2711</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bb176e65cb46ba6d469032ba1eed50d" name="a3bb176e65cb46ba6d469032ba1eed50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb176e65cb46ba6d469032ba1eed50d">&#9670;&#160;</a></span>from_mlab_linkage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.from_mlab_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a linkage matrix generated by MATLAB(TM) to a new
linkage matrix compatible with this module.

The conversion does two things:

 * the indices are converted from ``1..N`` to ``0..(N-1)`` form,
   and

 * a fourth column ``Z[:,3]`` is added where ``Z[i,3]`` represents the
   number of original observations (leaves) in the non-singleton
   cluster ``i``.

This function is useful when loading in linkages from legacy data
files generated by MATLAB.

Parameters
----------
Z : ndarray
    A linkage matrix generated by MATLAB(TM).

Returns
-------
ZS : ndarray
    A linkage matrix compatible with ``scipy.cluster.hierarchy``.

See Also
--------
linkage : for a description of what a linkage matrix is.
to_mlab_linkage : transform from SciPy to MATLAB format.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, from_mlab_linkage

Given a linkage matrix in MATLAB format ``mZ``, we can use
`scipy.cluster.hierarchy.from_mlab_linkage` to import
it into SciPy format:

&gt;&gt;&gt; mZ = np.array([[1, 2, 1], [4, 5, 1], [7, 8, 1],
...                [10, 11, 1], [3, 13, 1.29099445],
...                [6, 14, 1.29099445],
...                [9, 15, 1.29099445],
...                [12, 16, 1.29099445],
...                [17, 18, 5.77350269],
...                [19, 20, 5.77350269],
...                [21, 22,  8.16496581]])

&gt;&gt;&gt; Z = from_mlab_linkage(mZ)
&gt;&gt;&gt; Z
array([[  0.        ,   1.        ,   1.        ,   2.        ],
       [  3.        ,   4.        ,   1.        ,   2.        ],
       [  6.        ,   7.        ,   1.        ,   2.        ],
       [  9.        ,  10.        ,   1.        ,   2.        ],
       [  2.        ,  12.        ,   1.29099445,   3.        ],
       [  5.        ,  13.        ,   1.29099445,   3.        ],
       [  8.        ,  14.        ,   1.29099445,   3.        ],
       [ 11.        ,  15.        ,   1.29099445,   3.        ],
       [ 16.        ,  17.        ,   5.77350269,   6.        ],
       [ 18.        ,  19.        ,   5.77350269,   6.        ],
       [ 20.        ,  21.        ,   8.16496581,  12.        ]])

As expected, the linkage matrix ``Z`` returned includes an
additional column counting the number of original samples in
each cluster. Also, all cluster indices are reduced by 1
(MATLAB format uses 1-indexing, whereas SciPy uses 0-indexing).</pre> <div class="fragment"><div class="line"><span class="lineno"> 1787</span><span class="keyword">def </span>from_mlab_linkage(Z):</div>
<div class="line"><span class="lineno"> 1788</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">    Convert a linkage matrix generated by MATLAB(TM) to a new</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">    linkage matrix compatible with this module.</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    The conversion does two things:</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">     * the indices are converted from ``1..N`` to ``0..(N-1)`` form,</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">       and</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">     * a fourth column ``Z[:,3]`` is added where ``Z[i,3]`` represents the</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">       number of original observations (leaves) in the non-singleton</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">       cluster ``i``.</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">    This function is useful when loading in linkages from legacy data</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">    files generated by MATLAB.</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">        A linkage matrix generated by MATLAB(TM).</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">    ZS : ndarray</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">        A linkage matrix compatible with ``scipy.cluster.hierarchy``.</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">    to_mlab_linkage : transform from SciPy to MATLAB format.</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, from_mlab_linkage</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    Given a linkage matrix in MATLAB format ``mZ``, we can use</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    `scipy.cluster.hierarchy.from_mlab_linkage` to import</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    it into SciPy format:</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    &gt;&gt;&gt; mZ = np.array([[1, 2, 1], [4, 5, 1], [7, 8, 1],</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    ...                [10, 11, 1], [3, 13, 1.29099445],</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    ...                [6, 14, 1.29099445],</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    ...                [9, 15, 1.29099445],</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    ...                [12, 16, 1.29099445],</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    ...                [17, 18, 5.77350269],</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    ...                [19, 20, 5.77350269],</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    ...                [21, 22,  8.16496581]])</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">    &gt;&gt;&gt; Z = from_mlab_linkage(mZ)</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">    array([[  0.        ,   1.        ,   1.        ,   2.        ],</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">           [  3.        ,   4.        ,   1.        ,   2.        ],</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">           [  6.        ,   7.        ,   1.        ,   2.        ],</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">           [  9.        ,  10.        ,   1.        ,   2.        ],</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">           [  2.        ,  12.        ,   1.29099445,   3.        ],</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">           [  5.        ,  13.        ,   1.29099445,   3.        ],</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">           [  8.        ,  14.        ,   1.29099445,   3.        ],</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">           [ 11.        ,  15.        ,   1.29099445,   3.        ],</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">           [ 16.        ,  17.        ,   5.77350269,   6.        ],</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">           [ 18.        ,  19.        ,   5.77350269,   6.        ],</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">           [ 20.        ,  21.        ,   8.16496581,  12.        ]])</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    As expected, the linkage matrix ``Z`` returned includes an</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">    additional column counting the number of original samples in</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    each cluster. Also, all cluster indices are reduced by 1</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    (MATLAB format uses 1-indexing, whereas SciPy uses 0-indexing).</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1857</span>    Z = np.asarray(Z, dtype=np.double, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 1858</span>    Zs = Z.shape</div>
<div class="line"><span class="lineno"> 1859</span> </div>
<div class="line"><span class="lineno"> 1860</span>    <span class="comment"># If it&#39;s empty, return it.</span></div>
<div class="line"><span class="lineno"> 1861</span>    <span class="keywordflow">if</span> len(Zs) == 0 <span class="keywordflow">or</span> (len(Zs) == 1 <span class="keywordflow">and</span> Zs[0] == 0):</div>
<div class="line"><span class="lineno"> 1862</span>        <span class="keywordflow">return</span> Z.copy()</div>
<div class="line"><span class="lineno"> 1863</span> </div>
<div class="line"><span class="lineno"> 1864</span>    <span class="keywordflow">if</span> len(Zs) != 2:</div>
<div class="line"><span class="lineno"> 1865</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The linkage array must be rectangular.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1866</span> </div>
<div class="line"><span class="lineno"> 1867</span>    <span class="comment"># If it contains no rows, return it.</span></div>
<div class="line"><span class="lineno"> 1868</span>    <span class="keywordflow">if</span> Zs[0] == 0:</div>
<div class="line"><span class="lineno"> 1869</span>        <span class="keywordflow">return</span> Z.copy()</div>
<div class="line"><span class="lineno"> 1870</span> </div>
<div class="line"><span class="lineno"> 1871</span>    Zpart = Z.copy()</div>
<div class="line"><span class="lineno"> 1872</span>    <span class="keywordflow">if</span> Zpart[:, 0:2].min() != 1.0 <span class="keywordflow">and</span> Zpart[:, 0:2].max() != 2 * Zs[0]:</div>
<div class="line"><span class="lineno"> 1873</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The format of the indices is not 1..N&#39;</span>)</div>
<div class="line"><span class="lineno"> 1874</span> </div>
<div class="line"><span class="lineno"> 1875</span>    Zpart[:, 0:2] -= 1.0</div>
<div class="line"><span class="lineno"> 1876</span>    CS = np.zeros((Zs[0],), dtype=np.double)</div>
<div class="line"><span class="lineno"> 1877</span>    _hierarchy.calculate_cluster_sizes(Zpart, CS, int(Zs[0]) + 1)</div>
<div class="line"><span class="lineno"> 1878</span>    <span class="keywordflow">return</span> np.hstack([Zpart, CS.reshape(Zs[0], 1)])</div>
<div class="line"><span class="lineno"> 1879</span> </div>
<div class="line"><span class="lineno"> 1880</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae973440fe7f7bd476f26f178da6ad7f" name="aae973440fe7f7bd476f26f178da6ad7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae973440fe7f7bd476f26f178da6ad7f">&#9670;&#160;</a></span>inconsistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.inconsistent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate inconsistency statistics on a linkage matrix.

Parameters
----------
Z : ndarray
    The :math:`(n-1)` by 4 matrix encoding the linkage (hierarchical
    clustering).  See `linkage` documentation for more information on its
    form.
d : int, optional
    The number of links up to `d` levels below each non-singleton cluster.

Returns
-------
R : ndarray
    A :math:`(n-1)` by 4 matrix where the ``i``'th row contains the link
    statistics for the non-singleton cluster ``i``. The link statistics are
    computed over the link heights for links :math:`d` levels below the
    cluster ``i``. ``R[i,0]`` and ``R[i,1]`` are the mean and standard
    deviation of the link heights, respectively; ``R[i,2]`` is the number
    of links included in the calculation; and ``R[i,3]`` is the
    inconsistency coefficient,

    .. math:: \frac{\mathtt{Z[i,2]} - \mathtt{R[i,0]}} {R[i,1]}

Notes
-----
This function behaves similarly to the MATLAB(TM) ``inconsistent``
function.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import inconsistent, linkage
&gt;&gt;&gt; from matplotlib import pyplot as plt
&gt;&gt;&gt; X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]]
&gt;&gt;&gt; Z = linkage(X, 'ward')
&gt;&gt;&gt; print(Z)
[[ 5.          6.          0.          2.        ]
 [ 2.          7.          0.          2.        ]
 [ 0.          4.          1.          2.        ]
 [ 1.          8.          1.15470054  3.        ]
 [ 9.         10.          2.12132034  4.        ]
 [ 3.         12.          4.11096096  5.        ]
 [11.         13.         14.07183949  8.        ]]
&gt;&gt;&gt; inconsistent(Z)
array([[ 0.        ,  0.        ,  1.        ,  0.        ],
       [ 0.        ,  0.        ,  1.        ,  0.        ],
       [ 1.        ,  0.        ,  1.        ,  0.        ],
       [ 0.57735027,  0.81649658,  2.        ,  0.70710678],
       [ 1.04044011,  1.06123822,  3.        ,  1.01850858],
       [ 3.11614065,  1.40688837,  2.        ,  0.70710678],
       [ 6.44583366,  6.76770586,  3.        ,  1.12682288]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1713</span><span class="keyword">def </span>inconsistent(Z, d=2):</div>
<div class="line"><span class="lineno"> 1714</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral">    Calculate inconsistency statistics on a linkage matrix.</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral">        The :math:`(n-1)` by 4 matrix encoding the linkage (hierarchical</span></div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">        clustering).  See `linkage` documentation for more information on its</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">        form.</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">    d : int, optional</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">        The number of links up to `d` levels below each non-singleton cluster.</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">    R : ndarray</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">        A :math:`(n-1)` by 4 matrix where the ``i``&#39;th row contains the link</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">        statistics for the non-singleton cluster ``i``. The link statistics are</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">        computed over the link heights for links :math:`d` levels below the</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral">        cluster ``i``. ``R[i,0]`` and ``R[i,1]`` are the mean and standard</span></div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">        deviation of the link heights, respectively; ``R[i,2]`` is the number</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">        of links included in the calculation; and ``R[i,3]`` is the</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">        inconsistency coefficient,</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral">        .. math:: \frac{\mathtt{Z[i,2]} - \mathtt{R[i,0]}} {R[i,1]}</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">    This function behaves similarly to the MATLAB(TM) ``inconsistent``</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">    function.</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import inconsistent, linkage</span></div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral">    &gt;&gt;&gt; from matplotlib import pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">    &gt;&gt;&gt; X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]]</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral">    &gt;&gt;&gt; Z = linkage(X, &#39;ward&#39;)</span></div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">    &gt;&gt;&gt; print(Z)</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral">    [[ 5.          6.          0.          2.        ]</span></div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">     [ 2.          7.          0.          2.        ]</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">     [ 0.          4.          1.          2.        ]</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">     [ 1.          8.          1.15470054  3.        ]</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">     [ 9.         10.          2.12132034  4.        ]</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral">     [ 3.         12.          4.11096096  5.        ]</span></div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">     [11.         13.         14.07183949  8.        ]]</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">    &gt;&gt;&gt; inconsistent(Z)</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">    array([[ 0.        ,  0.        ,  1.        ,  0.        ],</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">           [ 0.        ,  0.        ,  1.        ,  0.        ],</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">           [ 1.        ,  0.        ,  1.        ,  0.        ],</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">           [ 0.57735027,  0.81649658,  2.        ,  0.70710678],</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">           [ 1.04044011,  1.06123822,  3.        ,  1.01850858],</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">           [ 3.11614065,  1.40688837,  2.        ,  0.70710678],</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">           [ 6.44583366,  6.76770586,  3.        ,  1.12682288]])</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1768</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 1769</span> </div>
<div class="line"><span class="lineno"> 1770</span>    Zs = Z.shape</div>
<div class="line"><span class="lineno"> 1771</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 1772</span>    <span class="keywordflow">if</span> (<span class="keywordflow">not</span> d == np.floor(d)) <span class="keywordflow">or</span> d &lt; 0:</div>
<div class="line"><span class="lineno"> 1773</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The second argument d must be a nonnegative &#39;</span></div>
<div class="line"><span class="lineno"> 1774</span>                         <span class="stringliteral">&#39;integer value.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1775</span> </div>
<div class="line"><span class="lineno"> 1776</span>    <span class="comment"># Since the C code does not support striding using strides.</span></div>
<div class="line"><span class="lineno"> 1777</span>    <span class="comment"># The dimensions are used instead.</span></div>
<div class="line"><span class="lineno"> 1778</span>    [Z] = _copy_arrays_if_base_present([Z])</div>
<div class="line"><span class="lineno"> 1779</span> </div>
<div class="line"><span class="lineno"> 1780</span>    n = Zs[0] + 1</div>
<div class="line"><span class="lineno"> 1781</span>    R = np.zeros((n - 1, 4), dtype=np.double)</div>
<div class="line"><span class="lineno"> 1782</span> </div>
<div class="line"><span class="lineno"> 1783</span>    _hierarchy.inconsistent(Z, R, int(n), int(d))</div>
<div class="line"><span class="lineno"> 1784</span>    <span class="keywordflow">return</span> R</div>
<div class="line"><span class="lineno"> 1785</span> </div>
<div class="line"><span class="lineno"> 1786</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a82d95f96e86090b51a7d13c81ae4a4fd" name="a82d95f96e86090b51a7d13c81ae4a4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d95f96e86090b51a7d13c81ae4a4fd">&#9670;&#160;</a></span>is_isomorphic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.is_isomorphic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine if two different cluster assignments are equivalent.

Parameters
----------
T1 : array_like
    An assignment of singleton cluster ids to flat cluster ids.
T2 : array_like
    An assignment of singleton cluster ids to flat cluster ids.

Returns
-------
b : bool
    Whether the flat cluster assignments `T1` and `T2` are
    equivalent.

See Also
--------
linkage : for a description of what a linkage matrix is.
fcluster : for the creation of flat cluster assignments.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import fcluster, is_isomorphic
&gt;&gt;&gt; from scipy.cluster.hierarchy import single, complete
&gt;&gt;&gt; from scipy.spatial.distance import pdist

Two flat cluster assignments can be isomorphic if they represent the same
cluster assignment, with different labels.

For example, we can use the `scipy.cluster.hierarchy.single`: method
and flatten the output to four clusters:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = single(pdist(X))
&gt;&gt;&gt; T = fcluster(Z, 1, criterion='distance')
&gt;&gt;&gt; T
array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)

We can then do the same using the
`scipy.cluster.hierarchy.complete`: method:

&gt;&gt;&gt; Z = complete(pdist(X))
&gt;&gt;&gt; T_ = fcluster(Z, 1.5, criterion='distance')
&gt;&gt;&gt; T_
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)

As we can see, in both cases we obtain four clusters and all the data
points are distributed in the same way - the only thing that changes
are the flat cluster labels (3 =&gt; 1, 4 =&gt;2, 2 =&gt;3 and 4 =&gt;1), so both
cluster assignments are isomorphic:

&gt;&gt;&gt; is_isomorphic(T, T_)
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 3689</span><span class="keyword">def </span>is_isomorphic(T1, T2):</div>
<div class="line"><span class="lineno"> 3690</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3691</span><span class="stringliteral">    Determine if two different cluster assignments are equivalent.</span></div>
<div class="line"><span class="lineno"> 3692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3693</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3694</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3695</span><span class="stringliteral">    T1 : array_like</span></div>
<div class="line"><span class="lineno"> 3696</span><span class="stringliteral">        An assignment of singleton cluster ids to flat cluster ids.</span></div>
<div class="line"><span class="lineno"> 3697</span><span class="stringliteral">    T2 : array_like</span></div>
<div class="line"><span class="lineno"> 3698</span><span class="stringliteral">        An assignment of singleton cluster ids to flat cluster ids.</span></div>
<div class="line"><span class="lineno"> 3699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3700</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3701</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3702</span><span class="stringliteral">    b : bool</span></div>
<div class="line"><span class="lineno"> 3703</span><span class="stringliteral">        Whether the flat cluster assignments `T1` and `T2` are</span></div>
<div class="line"><span class="lineno"> 3704</span><span class="stringliteral">        equivalent.</span></div>
<div class="line"><span class="lineno"> 3705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3706</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3707</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3708</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 3709</span><span class="stringliteral">    fcluster : for the creation of flat cluster assignments.</span></div>
<div class="line"><span class="lineno"> 3710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3711</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3712</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3713</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import fcluster, is_isomorphic</span></div>
<div class="line"><span class="lineno"> 3714</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import single, complete</span></div>
<div class="line"><span class="lineno"> 3715</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 3716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3717</span><span class="stringliteral">    Two flat cluster assignments can be isomorphic if they represent the same</span></div>
<div class="line"><span class="lineno"> 3718</span><span class="stringliteral">    cluster assignment, with different labels.</span></div>
<div class="line"><span class="lineno"> 3719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3720</span><span class="stringliteral">    For example, we can use the `scipy.cluster.hierarchy.single`: method</span></div>
<div class="line"><span class="lineno"> 3721</span><span class="stringliteral">    and flatten the output to four clusters:</span></div>
<div class="line"><span class="lineno"> 3722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3723</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 3724</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 3725</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 3726</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 3727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3728</span><span class="stringliteral">    &gt;&gt;&gt; Z = single(pdist(X))</span></div>
<div class="line"><span class="lineno"> 3729</span><span class="stringliteral">    &gt;&gt;&gt; T = fcluster(Z, 1, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno"> 3730</span><span class="stringliteral">    &gt;&gt;&gt; T</span></div>
<div class="line"><span class="lineno"> 3731</span><span class="stringliteral">    array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 3732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3733</span><span class="stringliteral">    We can then do the same using the</span></div>
<div class="line"><span class="lineno"> 3734</span><span class="stringliteral">    `scipy.cluster.hierarchy.complete`: method:</span></div>
<div class="line"><span class="lineno"> 3735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3736</span><span class="stringliteral">    &gt;&gt;&gt; Z = complete(pdist(X))</span></div>
<div class="line"><span class="lineno"> 3737</span><span class="stringliteral">    &gt;&gt;&gt; T_ = fcluster(Z, 1.5, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno"> 3738</span><span class="stringliteral">    &gt;&gt;&gt; T_</span></div>
<div class="line"><span class="lineno"> 3739</span><span class="stringliteral">    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 3740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3741</span><span class="stringliteral">    As we can see, in both cases we obtain four clusters and all the data</span></div>
<div class="line"><span class="lineno"> 3742</span><span class="stringliteral">    points are distributed in the same way - the only thing that changes</span></div>
<div class="line"><span class="lineno"> 3743</span><span class="stringliteral">    are the flat cluster labels (3 =&gt; 1, 4 =&gt;2, 2 =&gt;3 and 4 =&gt;1), so both</span></div>
<div class="line"><span class="lineno"> 3744</span><span class="stringliteral">    cluster assignments are isomorphic:</span></div>
<div class="line"><span class="lineno"> 3745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3746</span><span class="stringliteral">    &gt;&gt;&gt; is_isomorphic(T, T_)</span></div>
<div class="line"><span class="lineno"> 3747</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 3748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3749</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3750</span>    T1 = np.asarray(T1, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 3751</span>    T2 = np.asarray(T2, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 3752</span> </div>
<div class="line"><span class="lineno"> 3753</span>    <span class="keywordflow">if</span> type(T1) != np.ndarray:</div>
<div class="line"><span class="lineno"> 3754</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;T1 must be a numpy array.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3755</span>    <span class="keywordflow">if</span> type(T2) != np.ndarray:</div>
<div class="line"><span class="lineno"> 3756</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;T2 must be a numpy array.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3757</span> </div>
<div class="line"><span class="lineno"> 3758</span>    T1S = T1.shape</div>
<div class="line"><span class="lineno"> 3759</span>    T2S = T2.shape</div>
<div class="line"><span class="lineno"> 3760</span> </div>
<div class="line"><span class="lineno"> 3761</span>    <span class="keywordflow">if</span> len(T1S) != 1:</div>
<div class="line"><span class="lineno"> 3762</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;T1 must be one-dimensional.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3763</span>    <span class="keywordflow">if</span> len(T2S) != 1:</div>
<div class="line"><span class="lineno"> 3764</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;T2 must be one-dimensional.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3765</span>    <span class="keywordflow">if</span> T1S[0] != T2S[0]:</div>
<div class="line"><span class="lineno"> 3766</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;T1 and T2 must have the same number of elements.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3767</span>    n = T1S[0]</div>
<div class="line"><span class="lineno"> 3768</span>    d1 = {}</div>
<div class="line"><span class="lineno"> 3769</span>    d2 = {}</div>
<div class="line"><span class="lineno"> 3770</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, n):</div>
<div class="line"><span class="lineno"> 3771</span>        <span class="keywordflow">if</span> T1[i] <span class="keywordflow">in</span> d1:</div>
<div class="line"><span class="lineno"> 3772</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> T2[i] <span class="keywordflow">in</span> d2:</div>
<div class="line"><span class="lineno"> 3773</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3774</span>            <span class="keywordflow">if</span> d1[T1[i]] != T2[i] <span class="keywordflow">or</span> d2[T2[i]] != T1[i]:</div>
<div class="line"><span class="lineno"> 3775</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3776</span>        <span class="keywordflow">elif</span> T2[i] <span class="keywordflow">in</span> d2:</div>
<div class="line"><span class="lineno"> 3777</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3778</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3779</span>            d1[T1[i]] = T2[i]</div>
<div class="line"><span class="lineno"> 3780</span>            d2[T2[i]] = T1[i]</div>
<div class="line"><span class="lineno"> 3781</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3782</span> </div>
<div class="line"><span class="lineno"> 3783</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ba02ebb46b337c1f3abfcc826a97d9c" name="a6ba02ebb46b337c1f3abfcc826a97d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba02ebb46b337c1f3abfcc826a97d9c">&#9670;&#160;</a></span>is_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.is_monotonic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if the linkage passed is monotonic.

The linkage is monotonic if for every cluster :math:`s` and :math:`t`
joined, the distance between them is no less than the distance
between any previously joined clusters.

Parameters
----------
Z : ndarray
    The linkage matrix to check for monotonicity.

Returns
-------
b : bool
    A boolean indicating whether the linkage is monotonic.

See Also
--------
linkage : for a description of what a linkage matrix is.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import median, ward, is_monotonic
&gt;&gt;&gt; from scipy.spatial.distance import pdist

By definition, some hierarchical clustering algorithms - such as
`scipy.cluster.hierarchy.ward` - produce monotonic assignments of
samples to clusters; however, this is not always true for other
hierarchical methods - e.g. `scipy.cluster.hierarchy.median`.

Given a linkage matrix ``Z`` (as the result of a hierarchical clustering
method) we can test programmatically whether it has the monotonicity
property or not, using `scipy.cluster.hierarchy.is_monotonic`:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.29099445,  3.        ],
       [ 5.        , 13.        ,  1.29099445,  3.        ],
       [ 8.        , 14.        ,  1.29099445,  3.        ],
       [11.        , 15.        ,  1.29099445,  3.        ],
       [16.        , 17.        ,  5.77350269,  6.        ],
       [18.        , 19.        ,  5.77350269,  6.        ],
       [20.        , 21.        ,  8.16496581, 12.        ]])
&gt;&gt;&gt; is_monotonic(Z)
True

&gt;&gt;&gt; Z = median(pdist(X))
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.11803399,  3.        ],
       [ 5.        , 13.        ,  1.11803399,  3.        ],
       [ 8.        , 15.        ,  1.11803399,  3.        ],
       [11.        , 14.        ,  1.11803399,  3.        ],
       [18.        , 19.        ,  3.        ,  6.        ],
       [16.        , 17.        ,  3.5       ,  6.        ],
       [20.        , 21.        ,  3.25      , 12.        ]])
&gt;&gt;&gt; is_monotonic(Z)
False

Note that this method is equivalent to just verifying that the distances
in the third column of the linkage matrix appear in a monotonically
increasing order.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1968</span><span class="keyword">def </span>is_monotonic(Z):</div>
<div class="line"><span class="lineno"> 1969</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    Return True if the linkage passed is monotonic.</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">    The linkage is monotonic if for every cluster :math:`s` and :math:`t`</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    joined, the distance between them is no less than the distance</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    between any previously joined clusters.</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral">        The linkage matrix to check for monotonicity.</span></div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    b : bool</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">        A boolean indicating whether the linkage is monotonic.</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1990</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, ward, is_monotonic</span></div>
<div class="line"><span class="lineno"> 1993</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral">    By definition, some hierarchical clustering algorithms - such as</span></div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">    `scipy.cluster.hierarchy.ward` - produce monotonic assignments of</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral">    samples to clusters; however, this is not always true for other</span></div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">    hierarchical methods - e.g. `scipy.cluster.hierarchy.median`.</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral">    Given a linkage matrix ``Z`` (as the result of a hierarchical clustering</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">    method) we can test programmatically whether it has the monotonicity</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral">    property or not, using `scipy.cluster.hierarchy.is_monotonic`:</span></div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2004</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2005</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2006</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2007</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">           [ 2.        , 12.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral">           [ 5.        , 13.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral">           [ 8.        , 14.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2018</span><span class="stringliteral">           [11.        , 15.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2019</span><span class="stringliteral">           [16.        , 17.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2020</span><span class="stringliteral">           [18.        , 19.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral">           [20.        , 21.        ,  8.16496581, 12.        ]])</span></div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">    &gt;&gt;&gt; is_monotonic(Z)</span></div>
<div class="line"><span class="lineno"> 2023</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2024</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2025</span><span class="stringliteral">    &gt;&gt;&gt; Z = median(pdist(X))</span></div>
<div class="line"><span class="lineno"> 2026</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 2027</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2028</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2029</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2030</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2031</span><span class="stringliteral">           [ 2.        , 12.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2032</span><span class="stringliteral">           [ 5.        , 13.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2033</span><span class="stringliteral">           [ 8.        , 15.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2034</span><span class="stringliteral">           [11.        , 14.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2035</span><span class="stringliteral">           [18.        , 19.        ,  3.        ,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2036</span><span class="stringliteral">           [16.        , 17.        ,  3.5       ,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral">           [20.        , 21.        ,  3.25      , 12.        ]])</span></div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral">    &gt;&gt;&gt; is_monotonic(Z)</span></div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 2040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2041</span><span class="stringliteral">    Note that this method is equivalent to just verifying that the distances</span></div>
<div class="line"><span class="lineno"> 2042</span><span class="stringliteral">    in the third column of the linkage matrix appear in a monotonically</span></div>
<div class="line"><span class="lineno"> 2043</span><span class="stringliteral">    increasing order.</span></div>
<div class="line"><span class="lineno"> 2044</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2045</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2046</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2047</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 2048</span> </div>
<div class="line"><span class="lineno"> 2049</span>    <span class="comment"># We expect the i&#39;th value to be greater than its successor.</span></div>
<div class="line"><span class="lineno"> 2050</span>    <span class="keywordflow">return</span> (Z[1:, 2] &gt;= Z[:-1, 2]).all()</div>
<div class="line"><span class="lineno"> 2051</span> </div>
<div class="line"><span class="lineno"> 2052</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0796ac2a7b5f353dd68958f983de3eeb" name="a0796ac2a7b5f353dd68958f983de3eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0796ac2a7b5f353dd68958f983de3eeb">&#9670;&#160;</a></span>is_valid_im()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.is_valid_im </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>warning</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>throw</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if the inconsistency matrix passed is valid.

It must be a :math:`n` by 4 array of doubles. The standard
deviations ``R[:,1]`` must be nonnegative. The link counts
``R[:,2]`` must be positive and no greater than :math:`n-1`.

Parameters
----------
R : ndarray
    The inconsistency matrix to check for validity.
warning : bool, optional
    When True, issues a Python warning if the linkage
    matrix passed is invalid.
throw : bool, optional
    When True, throws a Python exception if the linkage
    matrix passed is invalid.
name : str, optional
    This string refers to the variable name of the invalid
    linkage matrix.

Returns
-------
b : bool
    True if the inconsistency matrix is valid.

See Also
--------
linkage : for a description of what a linkage matrix is.
inconsistent : for the creation of a inconsistency matrix.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, inconsistent, is_valid_im
&gt;&gt;&gt; from scipy.spatial.distance import pdist

Given a data set ``X``, we can apply a clustering method to obtain a
linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can
be also used to obtain the inconsistency matrix ``R`` associated to
this clustering process:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))
&gt;&gt;&gt; R = inconsistent(Z)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.29099445,  3.        ],
       [ 5.        , 13.        ,  1.29099445,  3.        ],
       [ 8.        , 14.        ,  1.29099445,  3.        ],
       [11.        , 15.        ,  1.29099445,  3.        ],
       [16.        , 17.        ,  5.77350269,  6.        ],
       [18.        , 19.        ,  5.77350269,  6.        ],
       [20.        , 21.        ,  8.16496581, 12.        ]])
&gt;&gt;&gt; R
array([[1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.14549722, 0.20576415, 2.        , 0.70710678],
       [1.14549722, 0.20576415, 2.        , 0.70710678],
       [1.14549722, 0.20576415, 2.        , 0.70710678],
       [1.14549722, 0.20576415, 2.        , 0.70710678],
       [2.78516386, 2.58797734, 3.        , 1.15470054],
       [2.78516386, 2.58797734, 3.        , 1.15470054],
       [6.57065706, 1.38071187, 3.        , 1.15470054]])

Now we can use `scipy.cluster.hierarchy.is_valid_im` to verify that
``R`` is correct:

&gt;&gt;&gt; is_valid_im(R)
True

However, if ``R`` is wrongly constructed (e.g., one of the standard
deviations is set to a negative value), then the check will fail:

&gt;&gt;&gt; R[-1,1] = R[-1,1] * -1
&gt;&gt;&gt; is_valid_im(R)
False</pre> <div class="fragment"><div class="line"><span class="lineno"> 2053</span><span class="keyword">def </span>is_valid_im(R, warning=False, throw=False, name=None):</div>
<div class="line"><span class="lineno"> 2054</span>    <span class="stringliteral">&quot;&quot;&quot;Return True if the inconsistency matrix passed is valid.</span></div>
<div class="line"><span class="lineno"> 2055</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2056</span><span class="stringliteral">    It must be a :math:`n` by 4 array of doubles. The standard</span></div>
<div class="line"><span class="lineno"> 2057</span><span class="stringliteral">    deviations ``R[:,1]`` must be nonnegative. The link counts</span></div>
<div class="line"><span class="lineno"> 2058</span><span class="stringliteral">    ``R[:,2]`` must be positive and no greater than :math:`n-1`.</span></div>
<div class="line"><span class="lineno"> 2059</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2060</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2061</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2062</span><span class="stringliteral">    R : ndarray</span></div>
<div class="line"><span class="lineno"> 2063</span><span class="stringliteral">        The inconsistency matrix to check for validity.</span></div>
<div class="line"><span class="lineno"> 2064</span><span class="stringliteral">    warning : bool, optional</span></div>
<div class="line"><span class="lineno"> 2065</span><span class="stringliteral">        When True, issues a Python warning if the linkage</span></div>
<div class="line"><span class="lineno"> 2066</span><span class="stringliteral">        matrix passed is invalid.</span></div>
<div class="line"><span class="lineno"> 2067</span><span class="stringliteral">    throw : bool, optional</span></div>
<div class="line"><span class="lineno"> 2068</span><span class="stringliteral">        When True, throws a Python exception if the linkage</span></div>
<div class="line"><span class="lineno"> 2069</span><span class="stringliteral">        matrix passed is invalid.</span></div>
<div class="line"><span class="lineno"> 2070</span><span class="stringliteral">    name : str, optional</span></div>
<div class="line"><span class="lineno"> 2071</span><span class="stringliteral">        This string refers to the variable name of the invalid</span></div>
<div class="line"><span class="lineno"> 2072</span><span class="stringliteral">        linkage matrix.</span></div>
<div class="line"><span class="lineno"> 2073</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2074</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2075</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2076</span><span class="stringliteral">    b : bool</span></div>
<div class="line"><span class="lineno"> 2077</span><span class="stringliteral">        True if the inconsistency matrix is valid.</span></div>
<div class="line"><span class="lineno"> 2078</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2079</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2080</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2081</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">    inconsistent : for the creation of a inconsistency matrix.</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2085</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2086</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, inconsistent, is_valid_im</span></div>
<div class="line"><span class="lineno"> 2087</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral">    Given a data set ``X``, we can apply a clustering method to obtain a</span></div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral">    linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">    be also used to obtain the inconsistency matrix ``R`` associated to</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral">    this clustering process:</span></div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">    &gt;&gt;&gt; R = inconsistent(Z)</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral">           [ 2.        , 12.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">           [ 5.        , 13.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral">           [ 8.        , 14.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">           [11.        , 15.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral">           [16.        , 17.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">           [18.        , 19.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">           [20.        , 21.        ,  8.16496581, 12.        ]])</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">    &gt;&gt;&gt; R</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">    array([[1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">           [1.14549722, 0.20576415, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral">           [1.14549722, 0.20576415, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral">           [1.14549722, 0.20576415, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">           [1.14549722, 0.20576415, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral">           [2.78516386, 2.58797734, 3.        , 1.15470054],</span></div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">           [2.78516386, 2.58797734, 3.        , 1.15470054],</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral">           [6.57065706, 1.38071187, 3.        , 1.15470054]])</span></div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">    Now we can use `scipy.cluster.hierarchy.is_valid_im` to verify that</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral">    ``R`` is correct:</span></div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">    &gt;&gt;&gt; is_valid_im(R)</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral">    However, if ``R`` is wrongly constructed (e.g., one of the standard</span></div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">    deviations is set to a negative value), then the check will fail:</span></div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2135</span><span class="stringliteral">    &gt;&gt;&gt; R[-1,1] = R[-1,1] * -1</span></div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral">    &gt;&gt;&gt; is_valid_im(R)</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2140</span>    R = np.asarray(R, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2141</span>    valid = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2142</span>    name_str = <span class="stringliteral">&quot;%r &quot;</span> % name <span class="keywordflow">if</span> name <span class="keywordflow">else</span> <span class="stringliteral">&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 2143</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2144</span>        <span class="keywordflow">if</span> type(R) != np.ndarray:</div>
<div class="line"><span class="lineno"> 2145</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;Variable %spassed as inconsistency matrix is not &#39;</span></div>
<div class="line"><span class="lineno"> 2146</span>                            <span class="stringliteral">&#39;a numpy array.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2147</span>        <span class="keywordflow">if</span> R.dtype != np.double:</div>
<div class="line"><span class="lineno"> 2148</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;Inconsistency matrix %smust contain doubles &#39;</span></div>
<div class="line"><span class="lineno"> 2149</span>                            <span class="stringliteral">&#39;(double).&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2150</span>        <span class="keywordflow">if</span> len(R.shape) != 2:</div>
<div class="line"><span class="lineno"> 2151</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Inconsistency matrix %smust have shape=2 (i.e. &#39;</span></div>
<div class="line"><span class="lineno"> 2152</span>                             <span class="stringliteral">&#39;be two-dimensional).&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2153</span>        <span class="keywordflow">if</span> R.shape[1] != 4:</div>
<div class="line"><span class="lineno"> 2154</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Inconsistency matrix %smust have 4 columns.&#39;</span> %</div>
<div class="line"><span class="lineno"> 2155</span>                             name_str)</div>
<div class="line"><span class="lineno"> 2156</span>        <span class="keywordflow">if</span> R.shape[0] &lt; 1:</div>
<div class="line"><span class="lineno"> 2157</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Inconsistency matrix %smust have at least one &#39;</span></div>
<div class="line"><span class="lineno"> 2158</span>                             <span class="stringliteral">&#39;row.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2159</span>        <span class="keywordflow">if</span> (R[:, 0] &lt; 0).any():</div>
<div class="line"><span class="lineno"> 2160</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Inconsistency matrix %scontains negative link &#39;</span></div>
<div class="line"><span class="lineno"> 2161</span>                             <span class="stringliteral">&#39;height means.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2162</span>        <span class="keywordflow">if</span> (R[:, 1] &lt; 0).any():</div>
<div class="line"><span class="lineno"> 2163</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Inconsistency matrix %scontains negative link &#39;</span></div>
<div class="line"><span class="lineno"> 2164</span>                             <span class="stringliteral">&#39;height standard deviations.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2165</span>        <span class="keywordflow">if</span> (R[:, 2] &lt; 0).any():</div>
<div class="line"><span class="lineno"> 2166</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Inconsistency matrix %scontains negative link &#39;</span></div>
<div class="line"><span class="lineno"> 2167</span>                             <span class="stringliteral">&#39;counts.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2168</span>    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 2169</span>        <span class="keywordflow">if</span> throw:</div>
<div class="line"><span class="lineno"> 2170</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 2171</span>        <span class="keywordflow">if</span> warning:</div>
<div class="line"><span class="lineno"> 2172</span>            _warning(str(e))</div>
<div class="line"><span class="lineno"> 2173</span>        valid = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2174</span> </div>
<div class="line"><span class="lineno"> 2175</span>    <span class="keywordflow">return</span> valid</div>
<div class="line"><span class="lineno"> 2176</span> </div>
<div class="line"><span class="lineno"> 2177</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e368d4cd0ca27149553e321cdc1190c" name="a7e368d4cd0ca27149553e321cdc1190c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e368d4cd0ca27149553e321cdc1190c">&#9670;&#160;</a></span>is_valid_linkage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.is_valid_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>warning</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>throw</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check the validity of a linkage matrix.

A linkage matrix is valid if it is a 2-D array (type double)
with :math:`n` rows and 4 columns. The first two columns must contain
indices between 0 and :math:`2n-1`. For a given row ``i``, the following
two expressions have to hold:

.. math::

    0 \\leq \\mathtt{Z[i,0]} \\leq i+n-1
    0 \\leq Z[i,1] \\leq i+n-1

I.e., a cluster cannot join another cluster unless the cluster being joined
has been generated.

Parameters
----------
Z : array_like
    Linkage matrix.
warning : bool, optional
    When True, issues a Python warning if the linkage
    matrix passed is invalid.
throw : bool, optional
    When True, throws a Python exception if the linkage
    matrix passed is invalid.
name : str, optional
    This string refers to the variable name of the invalid
    linkage matrix.

Returns
-------
b : bool
    True if the inconsistency matrix is valid.

See Also
--------
linkage: for a description of what a linkage matrix is.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, is_valid_linkage
&gt;&gt;&gt; from scipy.spatial.distance import pdist

All linkage matrices generated by the clustering methods in this module
will be valid (i.e., they will have the appropriate dimensions and the two
required expressions will hold for all the rows).

We can check this using `scipy.cluster.hierarchy.is_valid_linkage`:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.29099445,  3.        ],
       [ 5.        , 13.        ,  1.29099445,  3.        ],
       [ 8.        , 14.        ,  1.29099445,  3.        ],
       [11.        , 15.        ,  1.29099445,  3.        ],
       [16.        , 17.        ,  5.77350269,  6.        ],
       [18.        , 19.        ,  5.77350269,  6.        ],
       [20.        , 21.        ,  8.16496581, 12.        ]])
&gt;&gt;&gt; is_valid_linkage(Z)
True

However, if we create a linkage matrix in a wrong way - or if we modify
a valid one in a way that any of the required expressions don't hold
anymore, then the check will fail:

&gt;&gt;&gt; Z[3][1] = 20    # the cluster number 20 is not defined at this point
&gt;&gt;&gt; is_valid_linkage(Z)
False</pre> <div class="fragment"><div class="line"><span class="lineno"> 2178</span><span class="keyword">def </span>is_valid_linkage(Z, warning=False, throw=False, name=None):</div>
<div class="line"><span class="lineno"> 2179</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">    Check the validity of a linkage matrix.</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2182</span><span class="stringliteral">    A linkage matrix is valid if it is a 2-D array (type double)</span></div>
<div class="line"><span class="lineno"> 2183</span><span class="stringliteral">    with :math:`n` rows and 4 columns. The first two columns must contain</span></div>
<div class="line"><span class="lineno"> 2184</span><span class="stringliteral">    indices between 0 and :math:`2n-1`. For a given row ``i``, the following</span></div>
<div class="line"><span class="lineno"> 2185</span><span class="stringliteral">    two expressions have to hold:</span></div>
<div class="line"><span class="lineno"> 2186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2187</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 2188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2189</span><span class="stringliteral">        0 \\leq \\mathtt{Z[i,0]} \\leq i+n-1</span></div>
<div class="line"><span class="lineno"> 2190</span><span class="stringliteral">        0 \\leq Z[i,1] \\leq i+n-1</span></div>
<div class="line"><span class="lineno"> 2191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2192</span><span class="stringliteral">    I.e., a cluster cannot join another cluster unless the cluster being joined</span></div>
<div class="line"><span class="lineno"> 2193</span><span class="stringliteral">    has been generated.</span></div>
<div class="line"><span class="lineno"> 2194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2195</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2196</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2197</span><span class="stringliteral">    Z : array_like</span></div>
<div class="line"><span class="lineno"> 2198</span><span class="stringliteral">        Linkage matrix.</span></div>
<div class="line"><span class="lineno"> 2199</span><span class="stringliteral">    warning : bool, optional</span></div>
<div class="line"><span class="lineno"> 2200</span><span class="stringliteral">        When True, issues a Python warning if the linkage</span></div>
<div class="line"><span class="lineno"> 2201</span><span class="stringliteral">        matrix passed is invalid.</span></div>
<div class="line"><span class="lineno"> 2202</span><span class="stringliteral">    throw : bool, optional</span></div>
<div class="line"><span class="lineno"> 2203</span><span class="stringliteral">        When True, throws a Python exception if the linkage</span></div>
<div class="line"><span class="lineno"> 2204</span><span class="stringliteral">        matrix passed is invalid.</span></div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral">    name : str, optional</span></div>
<div class="line"><span class="lineno"> 2206</span><span class="stringliteral">        This string refers to the variable name of the invalid</span></div>
<div class="line"><span class="lineno"> 2207</span><span class="stringliteral">        linkage matrix.</span></div>
<div class="line"><span class="lineno"> 2208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">    b : bool</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral">        True if the inconsistency matrix is valid.</span></div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">    linkage: for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, is_valid_linkage</span></div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 2222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral">    All linkage matrices generated by the clustering methods in this module</span></div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral">    will be valid (i.e., they will have the appropriate dimensions and the two</span></div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral">    required expressions will hold for all the rows).</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">    We can check this using `scipy.cluster.hierarchy.is_valid_linkage`:</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral">           [ 2.        , 12.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">           [ 5.        , 13.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">           [ 8.        , 14.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">           [11.        , 15.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">           [16.        , 17.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral">           [18.        , 19.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">           [20.        , 21.        ,  8.16496581, 12.        ]])</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">    &gt;&gt;&gt; is_valid_linkage(Z)</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral">    However, if we create a linkage matrix in a wrong way - or if we modify</span></div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral">    a valid one in a way that any of the required expressions don&#39;t hold</span></div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral">    anymore, then the check will fail:</span></div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral">    &gt;&gt;&gt; Z[3][1] = 20    # the cluster number 20 is not defined at this point</span></div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">    &gt;&gt;&gt; is_valid_linkage(Z)</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2259</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2260</span>    valid = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2261</span>    name_str = <span class="stringliteral">&quot;%r &quot;</span> % name <span class="keywordflow">if</span> name <span class="keywordflow">else</span> <span class="stringliteral">&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 2262</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2263</span>        <span class="keywordflow">if</span> type(Z) != np.ndarray:</div>
<div class="line"><span class="lineno"> 2264</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;Passed linkage argument %sis not a valid array.&#39;</span> %</div>
<div class="line"><span class="lineno"> 2265</span>                            name_str)</div>
<div class="line"><span class="lineno"> 2266</span>        <span class="keywordflow">if</span> Z.dtype != np.double:</div>
<div class="line"><span class="lineno"> 2267</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;Linkage matrix %smust contain doubles.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2268</span>        <span class="keywordflow">if</span> len(Z.shape) != 2:</div>
<div class="line"><span class="lineno"> 2269</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage matrix %smust have shape=2 (i.e. be &#39;</span></div>
<div class="line"><span class="lineno"> 2270</span>                             <span class="stringliteral">&#39;two-dimensional).&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2271</span>        <span class="keywordflow">if</span> Z.shape[1] != 4:</div>
<div class="line"><span class="lineno"> 2272</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage matrix %smust have 4 columns.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2273</span>        <span class="keywordflow">if</span> Z.shape[0] == 0:</div>
<div class="line"><span class="lineno"> 2274</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage must be computed on at least two &#39;</span></div>
<div class="line"><span class="lineno"> 2275</span>                             <span class="stringliteral">&#39;observations.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2276</span>        n = Z.shape[0]</div>
<div class="line"><span class="lineno"> 2277</span>        <span class="keywordflow">if</span> n &gt; 1:</div>
<div class="line"><span class="lineno"> 2278</span>            <span class="keywordflow">if</span> ((Z[:, 0] &lt; 0).any() <span class="keywordflow">or</span> (Z[:, 1] &lt; 0).any()):</div>
<div class="line"><span class="lineno"> 2279</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage %scontains negative indices.&#39;</span> %</div>
<div class="line"><span class="lineno"> 2280</span>                                 name_str)</div>
<div class="line"><span class="lineno"> 2281</span>            <span class="keywordflow">if</span> (Z[:, 2] &lt; 0).any():</div>
<div class="line"><span class="lineno"> 2282</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage %scontains negative distances.&#39;</span> %</div>
<div class="line"><span class="lineno"> 2283</span>                                 name_str)</div>
<div class="line"><span class="lineno"> 2284</span>            <span class="keywordflow">if</span> (Z[:, 3] &lt; 0).any():</div>
<div class="line"><span class="lineno"> 2285</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage %scontains negative counts.&#39;</span> %</div>
<div class="line"><span class="lineno"> 2286</span>                                 name_str)</div>
<div class="line"><span class="lineno"> 2287</span>        <span class="keywordflow">if</span> _check_hierarchy_uses_cluster_before_formed(Z):</div>
<div class="line"><span class="lineno"> 2288</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage %suses non-singleton cluster before &#39;</span></div>
<div class="line"><span class="lineno"> 2289</span>                             <span class="stringliteral">&#39;it is formed.&#39;</span> % name_str)</div>
<div class="line"><span class="lineno"> 2290</span>        <span class="keywordflow">if</span> _check_hierarchy_uses_cluster_more_than_once(Z):</div>
<div class="line"><span class="lineno"> 2291</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Linkage %suses the same cluster more than once.&#39;</span></div>
<div class="line"><span class="lineno"> 2292</span>                             % name_str)</div>
<div class="line"><span class="lineno"> 2293</span>    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 2294</span>        <span class="keywordflow">if</span> throw:</div>
<div class="line"><span class="lineno"> 2295</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 2296</span>        <span class="keywordflow">if</span> warning:</div>
<div class="line"><span class="lineno"> 2297</span>            _warning(str(e))</div>
<div class="line"><span class="lineno"> 2298</span>        valid = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2299</span> </div>
<div class="line"><span class="lineno"> 2300</span>    <span class="keywordflow">return</span> valid</div>
<div class="line"><span class="lineno"> 2301</span> </div>
<div class="line"><span class="lineno"> 2302</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1847c24273484af16ed0642d57d5e3dc" name="a1847c24273484af16ed0642d57d5e3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1847c24273484af16ed0642d57d5e3dc">&#9670;&#160;</a></span>leaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.leaders </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the root nodes in a hierarchical clustering.

Returns the root nodes in a hierarchical clustering corresponding
to a cut defined by a flat cluster assignment vector ``T``. See
the ``fcluster`` function for more information on the format of ``T``.

For each flat cluster :math:`j` of the :math:`k` flat clusters
represented in the n-sized flat cluster assignment vector ``T``,
this function finds the lowest cluster node :math:`i` in the linkage
tree Z, such that:

  * leaf descendants belong only to flat cluster j
    (i.e., ``T[p]==j`` for all :math:`p` in :math:`S(i)`, where
    :math:`S(i)` is the set of leaf ids of descendant leaf nodes
    with cluster node :math:`i`)

  * there does not exist a leaf that is not a descendant with
    :math:`i` that also belongs to cluster :math:`j`
    (i.e., ``T[q]!=j`` for all :math:`q` not in :math:`S(i)`). If
    this condition is violated, ``T`` is not a valid cluster
    assignment vector, and an exception will be thrown.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    `linkage` for more information.
T : ndarray
    The flat cluster assignment vector.

Returns
-------
L : ndarray
    The leader linkage node id's stored as a k-element 1-D array,
    where ``k`` is the number of flat clusters found in ``T``.

    ``L[j]=i`` is the linkage cluster node id that is the
    leader of flat cluster with id M[j]. If ``i &lt; n``, ``i``
    corresponds to an original observation, otherwise it
    corresponds to a non-singleton cluster.
M : ndarray
    The leader linkage node id's stored as a k-element 1-D array, where
    ``k`` is the number of flat clusters found in ``T``. This allows the
    set of flat cluster ids to be any arbitrary set of ``k`` integers.

    For example: if ``L[3]=2`` and ``M[3]=8``, the flat cluster with
    id 8's leader is linkage node 2.

See Also
--------
fcluster : for the creation of flat cluster assignments.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster, leaders
&gt;&gt;&gt; from scipy.spatial.distance import pdist

Given a linkage matrix ``Z`` - obtained after apply a clustering method
to a dataset ``X`` - and a flat cluster assignment array ``T``:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.29099445,  3.        ],
       [ 5.        , 13.        ,  1.29099445,  3.        ],
       [ 8.        , 14.        ,  1.29099445,  3.        ],
       [11.        , 15.        ,  1.29099445,  3.        ],
       [16.        , 17.        ,  5.77350269,  6.        ],
       [18.        , 19.        ,  5.77350269,  6.        ],
       [20.        , 21.        ,  8.16496581, 12.        ]])

&gt;&gt;&gt; T = fcluster(Z, 3, criterion='distance')
&gt;&gt;&gt; T
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)

`scipy.cluster.hierarchy.leaders` returns the indices of the nodes
in the dendrogram that are the leaders of each flat cluster:

&gt;&gt;&gt; L, M = leaders(Z, T)
&gt;&gt;&gt; L
array([16, 17, 18, 19], dtype=int32)

(remember that indices 0-11 point to the 12 data points in ``X``,
whereas indices 12-22 point to the 11 rows of ``Z``)

`scipy.cluster.hierarchy.leaders` also returns the indices of
the flat clusters in ``T``:

&gt;&gt;&gt; M
array([1, 2, 3, 4], dtype=int32)</pre> <div class="fragment"><div class="line"><span class="lineno"> 4054</span><span class="keyword">def </span>leaders(Z, T):</div>
<div class="line"><span class="lineno"> 4055</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4056</span><span class="stringliteral">    Return the root nodes in a hierarchical clustering.</span></div>
<div class="line"><span class="lineno"> 4057</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4058</span><span class="stringliteral">    Returns the root nodes in a hierarchical clustering corresponding</span></div>
<div class="line"><span class="lineno"> 4059</span><span class="stringliteral">    to a cut defined by a flat cluster assignment vector ``T``. See</span></div>
<div class="line"><span class="lineno"> 4060</span><span class="stringliteral">    the ``fcluster`` function for more information on the format of ``T``.</span></div>
<div class="line"><span class="lineno"> 4061</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4062</span><span class="stringliteral">    For each flat cluster :math:`j` of the :math:`k` flat clusters</span></div>
<div class="line"><span class="lineno"> 4063</span><span class="stringliteral">    represented in the n-sized flat cluster assignment vector ``T``,</span></div>
<div class="line"><span class="lineno"> 4064</span><span class="stringliteral">    this function finds the lowest cluster node :math:`i` in the linkage</span></div>
<div class="line"><span class="lineno"> 4065</span><span class="stringliteral">    tree Z, such that:</span></div>
<div class="line"><span class="lineno"> 4066</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4067</span><span class="stringliteral">      * leaf descendants belong only to flat cluster j</span></div>
<div class="line"><span class="lineno"> 4068</span><span class="stringliteral">        (i.e., ``T[p]==j`` for all :math:`p` in :math:`S(i)`, where</span></div>
<div class="line"><span class="lineno"> 4069</span><span class="stringliteral">        :math:`S(i)` is the set of leaf ids of descendant leaf nodes</span></div>
<div class="line"><span class="lineno"> 4070</span><span class="stringliteral">        with cluster node :math:`i`)</span></div>
<div class="line"><span class="lineno"> 4071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4072</span><span class="stringliteral">      * there does not exist a leaf that is not a descendant with</span></div>
<div class="line"><span class="lineno"> 4073</span><span class="stringliteral">        :math:`i` that also belongs to cluster :math:`j`</span></div>
<div class="line"><span class="lineno"> 4074</span><span class="stringliteral">        (i.e., ``T[q]!=j`` for all :math:`q` not in :math:`S(i)`). If</span></div>
<div class="line"><span class="lineno"> 4075</span><span class="stringliteral">        this condition is violated, ``T`` is not a valid cluster</span></div>
<div class="line"><span class="lineno"> 4076</span><span class="stringliteral">        assignment vector, and an exception will be thrown.</span></div>
<div class="line"><span class="lineno"> 4077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4078</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4079</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4080</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 4081</span><span class="stringliteral">        The hierarchical clustering encoded as a matrix. See</span></div>
<div class="line"><span class="lineno"> 4082</span><span class="stringliteral">        `linkage` for more information.</span></div>
<div class="line"><span class="lineno"> 4083</span><span class="stringliteral">    T : ndarray</span></div>
<div class="line"><span class="lineno"> 4084</span><span class="stringliteral">        The flat cluster assignment vector.</span></div>
<div class="line"><span class="lineno"> 4085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4086</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4087</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4088</span><span class="stringliteral">    L : ndarray</span></div>
<div class="line"><span class="lineno"> 4089</span><span class="stringliteral">        The leader linkage node id&#39;s stored as a k-element 1-D array,</span></div>
<div class="line"><span class="lineno"> 4090</span><span class="stringliteral">        where ``k`` is the number of flat clusters found in ``T``.</span></div>
<div class="line"><span class="lineno"> 4091</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4092</span><span class="stringliteral">        ``L[j]=i`` is the linkage cluster node id that is the</span></div>
<div class="line"><span class="lineno"> 4093</span><span class="stringliteral">        leader of flat cluster with id M[j]. If ``i &lt; n``, ``i``</span></div>
<div class="line"><span class="lineno"> 4094</span><span class="stringliteral">        corresponds to an original observation, otherwise it</span></div>
<div class="line"><span class="lineno"> 4095</span><span class="stringliteral">        corresponds to a non-singleton cluster.</span></div>
<div class="line"><span class="lineno"> 4096</span><span class="stringliteral">    M : ndarray</span></div>
<div class="line"><span class="lineno"> 4097</span><span class="stringliteral">        The leader linkage node id&#39;s stored as a k-element 1-D array, where</span></div>
<div class="line"><span class="lineno"> 4098</span><span class="stringliteral">        ``k`` is the number of flat clusters found in ``T``. This allows the</span></div>
<div class="line"><span class="lineno"> 4099</span><span class="stringliteral">        set of flat cluster ids to be any arbitrary set of ``k`` integers.</span></div>
<div class="line"><span class="lineno"> 4100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4101</span><span class="stringliteral">        For example: if ``L[3]=2`` and ``M[3]=8``, the flat cluster with</span></div>
<div class="line"><span class="lineno"> 4102</span><span class="stringliteral">        id 8&#39;s leader is linkage node 2.</span></div>
<div class="line"><span class="lineno"> 4103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4104</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4105</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4106</span><span class="stringliteral">    fcluster : for the creation of flat cluster assignments.</span></div>
<div class="line"><span class="lineno"> 4107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4108</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4109</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4110</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster, leaders</span></div>
<div class="line"><span class="lineno"> 4111</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 4112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4113</span><span class="stringliteral">    Given a linkage matrix ``Z`` - obtained after apply a clustering method</span></div>
<div class="line"><span class="lineno"> 4114</span><span class="stringliteral">    to a dataset ``X`` - and a flat cluster assignment array ``T``:</span></div>
<div class="line"><span class="lineno"> 4115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4116</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 4117</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 4118</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 4119</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 4120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4121</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 4122</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 4123</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 4124</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 4125</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 4126</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 4127</span><span class="stringliteral">           [ 2.        , 12.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 4128</span><span class="stringliteral">           [ 5.        , 13.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 4129</span><span class="stringliteral">           [ 8.        , 14.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 4130</span><span class="stringliteral">           [11.        , 15.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 4131</span><span class="stringliteral">           [16.        , 17.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 4132</span><span class="stringliteral">           [18.        , 19.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 4133</span><span class="stringliteral">           [20.        , 21.        ,  8.16496581, 12.        ]])</span></div>
<div class="line"><span class="lineno"> 4134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4135</span><span class="stringliteral">    &gt;&gt;&gt; T = fcluster(Z, 3, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno"> 4136</span><span class="stringliteral">    &gt;&gt;&gt; T</span></div>
<div class="line"><span class="lineno"> 4137</span><span class="stringliteral">    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 4138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4139</span><span class="stringliteral">    `scipy.cluster.hierarchy.leaders` returns the indices of the nodes</span></div>
<div class="line"><span class="lineno"> 4140</span><span class="stringliteral">    in the dendrogram that are the leaders of each flat cluster:</span></div>
<div class="line"><span class="lineno"> 4141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4142</span><span class="stringliteral">    &gt;&gt;&gt; L, M = leaders(Z, T)</span></div>
<div class="line"><span class="lineno"> 4143</span><span class="stringliteral">    &gt;&gt;&gt; L</span></div>
<div class="line"><span class="lineno"> 4144</span><span class="stringliteral">    array([16, 17, 18, 19], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 4145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4146</span><span class="stringliteral">    (remember that indices 0-11 point to the 12 data points in ``X``,</span></div>
<div class="line"><span class="lineno"> 4147</span><span class="stringliteral">    whereas indices 12-22 point to the 11 rows of ``Z``)</span></div>
<div class="line"><span class="lineno"> 4148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4149</span><span class="stringliteral">    `scipy.cluster.hierarchy.leaders` also returns the indices of</span></div>
<div class="line"><span class="lineno"> 4150</span><span class="stringliteral">    the flat clusters in ``T``:</span></div>
<div class="line"><span class="lineno"> 4151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4152</span><span class="stringliteral">    &gt;&gt;&gt; M</span></div>
<div class="line"><span class="lineno"> 4153</span><span class="stringliteral">    array([1, 2, 3, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 4154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4155</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4156</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 4157</span>    T = np.asarray(T, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 4158</span>    <span class="keywordflow">if</span> type(T) != np.ndarray <span class="keywordflow">or</span> T.dtype != <span class="stringliteral">&#39;i&#39;</span>:</div>
<div class="line"><span class="lineno"> 4159</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;T must be a one-dimensional numpy array of integers.&#39;</span>)</div>
<div class="line"><span class="lineno"> 4160</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 4161</span>    <span class="keywordflow">if</span> len(T) != Z.shape[0] + 1:</div>
<div class="line"><span class="lineno"> 4162</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Mismatch: len(T)!=Z.shape[0] + 1.&#39;</span>)</div>
<div class="line"><span class="lineno"> 4163</span> </div>
<div class="line"><span class="lineno"> 4164</span>    Cl = np.unique(T)</div>
<div class="line"><span class="lineno"> 4165</span>    kk = len(Cl)</div>
<div class="line"><span class="lineno"> 4166</span>    L = np.zeros((kk,), dtype=<span class="stringliteral">&#39;i&#39;</span>)</div>
<div class="line"><span class="lineno"> 4167</span>    M = np.zeros((kk,), dtype=<span class="stringliteral">&#39;i&#39;</span>)</div>
<div class="line"><span class="lineno"> 4168</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 4169</span>    [Z, T] = _copy_arrays_if_base_present([Z, T])</div>
<div class="line"><span class="lineno"> 4170</span>    s = _hierarchy.leaders(Z, T, L, M, int(kk), int(n))</div>
<div class="line"><span class="lineno"> 4171</span>    <span class="keywordflow">if</span> s &gt;= 0:</div>
<div class="line"><span class="lineno"> 4172</span>        <span class="keywordflow">raise</span> ValueError((<span class="stringliteral">&#39;T is not a valid assignment vector. Error found &#39;</span></div>
<div class="line"><span class="lineno"> 4173</span>                          <span class="stringliteral">&#39;when examining linkage node %d (&lt; 2n-1).&#39;</span>) % s)</div>
<div class="line"><span class="lineno"> 4174</span>    <span class="keywordflow">return</span> (L, M)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a54365dda4fda7dbb7e377a0ba626c8eb" name="a54365dda4fda7dbb7e377a0ba626c8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54365dda4fda7dbb7e377a0ba626c8eb">&#9670;&#160;</a></span>leaves_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.leaves_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of leaf node ids.

The return corresponds to the observation vector index as it appears
in the tree from left to right. Z is a linkage matrix.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix.  `Z` is
    a linkage matrix.  See `linkage` for more information.

Returns
-------
leaves_list : ndarray
    The list of leaf node ids.

See Also
--------
dendrogram : for information about dendrogram structure.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, dendrogram, leaves_list
&gt;&gt;&gt; from scipy.spatial.distance import pdist
&gt;&gt;&gt; from matplotlib import pyplot as plt

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))

The linkage matrix ``Z`` represents a dendrogram, that is, a tree that
encodes the structure of the clustering performed.
`scipy.cluster.hierarchy.leaves_list` shows the mapping between
indices in the ``X`` dataset and leaves in the dendrogram:

&gt;&gt;&gt; leaves_list(Z)
array([ 2,  0,  1,  5,  3,  4,  8,  6,  7, 11,  9, 10], dtype=int32)

&gt;&gt;&gt; fig = plt.figure(figsize=(25, 10))
&gt;&gt;&gt; dn = dendrogram(Z)
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2712</span><span class="keyword">def </span>leaves_list(Z):</div>
<div class="line"><span class="lineno"> 2713</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2714</span><span class="stringliteral">    Return a list of leaf node ids.</span></div>
<div class="line"><span class="lineno"> 2715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2716</span><span class="stringliteral">    The return corresponds to the observation vector index as it appears</span></div>
<div class="line"><span class="lineno"> 2717</span><span class="stringliteral">    in the tree from left to right. Z is a linkage matrix.</span></div>
<div class="line"><span class="lineno"> 2718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2719</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2720</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2721</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 2722</span><span class="stringliteral">        The hierarchical clustering encoded as a matrix.  `Z` is</span></div>
<div class="line"><span class="lineno"> 2723</span><span class="stringliteral">        a linkage matrix.  See `linkage` for more information.</span></div>
<div class="line"><span class="lineno"> 2724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral">    leaves_list : ndarray</span></div>
<div class="line"><span class="lineno"> 2728</span><span class="stringliteral">        The list of leaf node ids.</span></div>
<div class="line"><span class="lineno"> 2729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2730</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2731</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2732</span><span class="stringliteral">    dendrogram : for information about dendrogram structure.</span></div>
<div class="line"><span class="lineno"> 2733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2734</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2735</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2736</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, dendrogram, leaves_list</span></div>
<div class="line"><span class="lineno"> 2737</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 2738</span><span class="stringliteral">    &gt;&gt;&gt; from matplotlib import pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2739</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2740</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2741</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2742</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram, that is, a tree that</span></div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral">    encodes the structure of the clustering performed.</span></div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">    `scipy.cluster.hierarchy.leaves_list` shows the mapping between</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral">    indices in the ``X`` dataset and leaves in the dendrogram:</span></div>
<div class="line"><span class="lineno"> 2751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral">    &gt;&gt;&gt; leaves_list(Z)</span></div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral">    array([ 2,  0,  1,  5,  3,  4,  8,  6,  7, 11,  9, 10], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure(figsize=(25, 10))</span></div>
<div class="line"><span class="lineno"> 2756</span><span class="stringliteral">    &gt;&gt;&gt; dn = dendrogram(Z)</span></div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2760</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2761</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 2762</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 2763</span>    ML = np.zeros((n,), dtype=<span class="stringliteral">&#39;i&#39;</span>)</div>
<div class="line"><span class="lineno"> 2764</span>    [Z] = _copy_arrays_if_base_present([Z])</div>
<div class="line"><span class="lineno"> 2765</span>    _hierarchy.prelist(Z, ML, int(n))</div>
<div class="line"><span class="lineno"> 2766</span>    <span class="keywordflow">return</span> ML</div>
<div class="line"><span class="lineno"> 2767</span> </div>
<div class="line"><span class="lineno"> 2768</span> </div>
<div class="line"><span class="lineno"> 2769</span><span class="comment"># Maps number of leaves to text size.</span></div>
<div class="line"><span class="lineno"> 2770</span><span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2771</span><span class="comment"># p &lt;= 20, size=&quot;12&quot;</span></div>
<div class="line"><span class="lineno"> 2772</span><span class="comment"># 20 &lt; p &lt;= 30, size=&quot;10&quot;</span></div>
<div class="line"><span class="lineno"> 2773</span><span class="comment"># 30 &lt; p &lt;= 50, size=&quot;8&quot;</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="comment"># 50 &lt; p &lt;= np.inf, size=&quot;6&quot;</span></div>
<div class="line"><span class="lineno"> 2775</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9b8b15e70c3130ac1b485b0dac18f23" name="ae9b8b15e70c3130ac1b485b0dac18f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8b15e70c3130ac1b485b0dac18f23">&#9670;&#160;</a></span>linkage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a3d0362e93aa51d35d3895395af758fb5">single</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>'euclidean'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optimal_ordering</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform hierarchical/agglomerative clustering.

The input y may be either a 1-D condensed distance matrix
or a 2-D array of observation vectors.

If y is a 1-D condensed distance matrix,
then y must be a :math:`\\binom{n}{2}` sized
vector, where n is the number of original observations paired
in the distance matrix. The behavior of this function is very
similar to the MATLAB linkage function.

A :math:`(n-1)` by 4 matrix ``Z`` is returned. At the
:math:`i`-th iteration, clusters with indices ``Z[i, 0]`` and
``Z[i, 1]`` are combined to form cluster :math:`n + i`. A
cluster with an index less than :math:`n` corresponds to one of
the :math:`n` original observations. The distance between
clusters ``Z[i, 0]`` and ``Z[i, 1]`` is given by ``Z[i, 2]``. The
fourth value ``Z[i, 3]`` represents the number of original
observations in the newly formed cluster.

The following linkage methods are used to compute the distance
:math:`d(s, t)` between two clusters :math:`s` and
:math:`t`. The algorithm begins with a forest of clusters that
have yet to be used in the hierarchy being formed. When two
clusters :math:`s` and :math:`t` from this forest are combined
into a single cluster :math:`u`, :math:`s` and :math:`t` are
removed from the forest, and :math:`u` is added to the
forest. When only one cluster remains in the forest, the algorithm
stops, and this cluster becomes the root.

A distance matrix is maintained at each iteration. The ``d[i,j]``
entry corresponds to the distance between cluster :math:`i` and
:math:`j` in the original forest.

At each iteration, the algorithm must update the distance matrix
to reflect the distance of the newly formed cluster u with the
remaining clusters in the forest.

Suppose there are :math:`|u|` original observations
:math:`u[0], \\ldots, u[|u|-1]` in cluster :math:`u` and
:math:`|v|` original objects :math:`v[0], \\ldots, v[|v|-1]` in
cluster :math:`v`. Recall, :math:`s` and :math:`t` are
combined to form cluster :math:`u`. Let :math:`v` be any
remaining cluster in the forest that is not :math:`u`.

The following are methods for calculating the distance between the
newly formed cluster :math:`u` and each :math:`v`.

  * method='single' assigns

    .. math::
       d(u,v) = \\min(dist(u[i],v[j]))

    for all points :math:`i` in cluster :math:`u` and
    :math:`j` in cluster :math:`v`. This is also known as the
    Nearest Point Algorithm.

  * method='complete' assigns

    .. math::
       d(u, v) = \\max(dist(u[i],v[j]))

    for all points :math:`i` in cluster u and :math:`j` in
    cluster :math:`v`. This is also known by the Farthest Point
    Algorithm or Voor Hees Algorithm.

  * method='average' assigns

    .. math::
       d(u,v) = \\sum_{ij} \\frac{d(u[i], v[j])}
                               {(|u|*|v|)}

    for all points :math:`i` and :math:`j` where :math:`|u|`
    and :math:`|v|` are the cardinalities of clusters :math:`u`
    and :math:`v`, respectively. This is also called the UPGMA
    algorithm.

  * method='weighted' assigns

    .. math::
       d(u,v) = (dist(s,v) + dist(t,v))/2

    where cluster u was formed with cluster s and t and v
    is a remaining cluster in the forest (also called WPGMA).

  * method='centroid' assigns

    .. math::
       dist(s,t) = ||c_s-c_t||_2

    where :math:`c_s` and :math:`c_t` are the centroids of
    clusters :math:`s` and :math:`t`, respectively. When two
    clusters :math:`s` and :math:`t` are combined into a new
    cluster :math:`u`, the new centroid is computed over all the
    original objects in clusters :math:`s` and :math:`t`. The
    distance then becomes the Euclidean distance between the
    centroid of :math:`u` and the centroid of a remaining cluster
    :math:`v` in the forest. This is also known as the UPGMC
    algorithm.

  * method='median' assigns :math:`d(s,t)` like the ``centroid``
    method. When two clusters :math:`s` and :math:`t` are combined
    into a new cluster :math:`u`, the average of centroids s and t
    give the new centroid :math:`u`. This is also known as the
    WPGMC algorithm.

  * method='ward' uses the Ward variance minimization algorithm.
    The new entry :math:`d(u,v)` is computed as follows,

    .. math::

       d(u,v) = \\sqrt{\\frac{|v|+|s|}
                           {T}d(v,s)^2
                    + \\frac{|v|+|t|}
                           {T}d(v,t)^2
                    - \\frac{|v|}
                           {T}d(s,t)^2}

    where :math:`u` is the newly joined cluster consisting of
    clusters :math:`s` and :math:`t`, :math:`v` is an unused
    cluster in the forest, :math:`T=|v|+|s|+|t|`, and
    :math:`|*|` is the cardinality of its argument. This is also
    known as the incremental algorithm.

Warning: When the minimum distance pair in the forest is chosen, there
may be two or more pairs with the same minimum distance. This
implementation may choose a different minimum than the MATLAB
version.

Parameters
----------
y : ndarray
    A condensed distance matrix. A condensed distance matrix
    is a flat array containing the upper triangular of the distance matrix.
    This is the form that ``pdist`` returns. Alternatively, a collection of
    :math:`m` observation vectors in :math:`n` dimensions may be passed as
    an :math:`m` by :math:`n` array. All elements of the condensed distance
    matrix must be finite, i.e., no NaNs or infs.
method : str, optional
    The linkage algorithm to use. See the ``Linkage Methods`` section below
    for full descriptions.
metric : str or function, optional
    The distance metric to use in the case that y is a collection of
    observation vectors; ignored otherwise. See the ``pdist``
    function for a list of valid distance metrics. A custom distance
    function can also be used.
optimal_ordering : bool, optional
    If True, the linkage matrix will be reordered so that the distance
    between successive leaves is minimal. This results in a more intuitive
    tree structure when the data are visualized. defaults to False, because
    this algorithm can be slow, particularly on large datasets [2]_. See
    also the `optimal_leaf_ordering` function.

    .. versionadded:: 1.0.0

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.

Notes
-----
1. For method 'single', an optimized algorithm based on minimum spanning
   tree is implemented. It has time complexity :math:`O(n^2)`.
   For methods 'complete', 'average', 'weighted' and 'ward', an algorithm
   called nearest-neighbors chain is implemented. It also has time
   complexity :math:`O(n^2)`.
   For other methods, a naive algorithm is implemented with :math:`O(n^3)`
   time complexity.
   All algorithms use :math:`O(n^2)` memory.
   Refer to [1]_ for details about the algorithms.
2. Methods 'centroid', 'median', and 'ward' are correctly defined only if
   Euclidean pairwise metric is used. If `y` is passed as precomputed
   pairwise distances, then it is the user's responsibility to assure that
   these distances are in fact Euclidean, otherwise the produced result
   will be incorrect.

See Also
--------
scipy.spatial.distance.pdist : pairwise distance metrics

References
----------
.. [1] Daniel Mullner, "Modern hierarchical, agglomerative clustering
       algorithms", :arXiv:`1109.2378v1`.
.. [2] Ziv Bar-Joseph, David K. Gifford, Tommi S. Jaakkola, "Fast optimal
       leaf ordering for hierarchical clustering", 2001. Bioinformatics
       :doi:`10.1093/bioinformatics/17.suppl_1.S22`

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import dendrogram, linkage
&gt;&gt;&gt; from matplotlib import pyplot as plt
&gt;&gt;&gt; X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]]

&gt;&gt;&gt; Z = linkage(X, 'ward')
&gt;&gt;&gt; fig = plt.figure(figsize=(25, 10))
&gt;&gt;&gt; dn = dendrogram(Z)

&gt;&gt;&gt; Z = linkage(X, 'single')
&gt;&gt;&gt; fig = plt.figure(figsize=(25, 10))
&gt;&gt;&gt; dn = dendrogram(Z)
&gt;&gt;&gt; plt.show()
</pre> <div class="fragment"><div class="line"><span class="lineno">  837</span><span class="keyword">def </span>linkage(y, method=&#39;single&#39;, metric=&#39;euclidean&#39;, optimal_ordering=False):</div>
<div class="line"><span class="lineno">  838</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    Perform hierarchical/agglomerative clustering.</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    The input y may be either a 1-D condensed distance matrix</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    or a 2-D array of observation vectors.</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    If y is a 1-D condensed distance matrix,</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    then y must be a :math:`\\binom{n}{2}` sized</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    vector, where n is the number of original observations paired</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    in the distance matrix. The behavior of this function is very</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    similar to the MATLAB linkage function.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    A :math:`(n-1)` by 4 matrix ``Z`` is returned. At the</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    :math:`i`-th iteration, clusters with indices ``Z[i, 0]`` and</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    ``Z[i, 1]`` are combined to form cluster :math:`n + i`. A</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    cluster with an index less than :math:`n` corresponds to one of</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    the :math:`n` original observations. The distance between</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    clusters ``Z[i, 0]`` and ``Z[i, 1]`` is given by ``Z[i, 2]``. The</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    fourth value ``Z[i, 3]`` represents the number of original</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    observations in the newly formed cluster.</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    The following linkage methods are used to compute the distance</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    :math:`d(s, t)` between two clusters :math:`s` and</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    :math:`t`. The algorithm begins with a forest of clusters that</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    have yet to be used in the hierarchy being formed. When two</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    clusters :math:`s` and :math:`t` from this forest are combined</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    into a single cluster :math:`u`, :math:`s` and :math:`t` are</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    removed from the forest, and :math:`u` is added to the</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    forest. When only one cluster remains in the forest, the algorithm</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    stops, and this cluster becomes the root.</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    A distance matrix is maintained at each iteration. The ``d[i,j]``</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    entry corresponds to the distance between cluster :math:`i` and</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    :math:`j` in the original forest.</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    At each iteration, the algorithm must update the distance matrix</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    to reflect the distance of the newly formed cluster u with the</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    remaining clusters in the forest.</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    Suppose there are :math:`|u|` original observations</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    :math:`u[0], \\ldots, u[|u|-1]` in cluster :math:`u` and</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    :math:`|v|` original objects :math:`v[0], \\ldots, v[|v|-1]` in</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    cluster :math:`v`. Recall, :math:`s` and :math:`t` are</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    combined to form cluster :math:`u`. Let :math:`v` be any</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    remaining cluster in the forest that is not :math:`u`.</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    The following are methods for calculating the distance between the</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    newly formed cluster :math:`u` and each :math:`v`.</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">      * method=&#39;single&#39; assigns</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">           d(u,v) = \\min(dist(u[i],v[j]))</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">        for all points :math:`i` in cluster :math:`u` and</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">        :math:`j` in cluster :math:`v`. This is also known as the</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">        Nearest Point Algorithm.</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">      * method=&#39;complete&#39; assigns</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">           d(u, v) = \\max(dist(u[i],v[j]))</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">        for all points :math:`i` in cluster u and :math:`j` in</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">        cluster :math:`v`. This is also known by the Farthest Point</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">        Algorithm or Voor Hees Algorithm.</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">      * method=&#39;average&#39; assigns</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">           d(u,v) = \\sum_{ij} \\frac{d(u[i], v[j])}</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">                                   {(|u|*|v|)}</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        for all points :math:`i` and :math:`j` where :math:`|u|`</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        and :math:`|v|` are the cardinalities of clusters :math:`u`</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        and :math:`v`, respectively. This is also called the UPGMA</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        algorithm.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">      * method=&#39;weighted&#39; assigns</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">           d(u,v) = (dist(s,v) + dist(t,v))/2</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">        where cluster u was formed with cluster s and t and v</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">        is a remaining cluster in the forest (also called WPGMA).</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">      * method=&#39;centroid&#39; assigns</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">           dist(s,t) = ||c_s-c_t||_2</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">        where :math:`c_s` and :math:`c_t` are the centroids of</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">        clusters :math:`s` and :math:`t`, respectively. When two</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">        clusters :math:`s` and :math:`t` are combined into a new</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">        cluster :math:`u`, the new centroid is computed over all the</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">        original objects in clusters :math:`s` and :math:`t`. The</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">        distance then becomes the Euclidean distance between the</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">        centroid of :math:`u` and the centroid of a remaining cluster</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">        :math:`v` in the forest. This is also known as the UPGMC</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">        algorithm.</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">      * method=&#39;median&#39; assigns :math:`d(s,t)` like the ``centroid``</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">        method. When two clusters :math:`s` and :math:`t` are combined</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">        into a new cluster :math:`u`, the average of centroids s and t</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">        give the new centroid :math:`u`. This is also known as the</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">        WPGMC algorithm.</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">      * method=&#39;ward&#39; uses the Ward variance minimization algorithm.</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">        The new entry :math:`d(u,v)` is computed as follows,</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">        .. math::</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">           d(u,v) = \\sqrt{\\frac{|v|+|s|}</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">                               {T}d(v,s)^2</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">                        + \\frac{|v|+|t|}</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">                               {T}d(v,t)^2</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">                        - \\frac{|v|}</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">                               {T}d(s,t)^2}</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">        where :math:`u` is the newly joined cluster consisting of</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">        clusters :math:`s` and :math:`t`, :math:`v` is an unused</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">        cluster in the forest, :math:`T=|v|+|s|+|t|`, and</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">        :math:`|*|` is the cardinality of its argument. This is also</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">        known as the incremental algorithm.</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    Warning: When the minimum distance pair in the forest is chosen, there</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    may be two or more pairs with the same minimum distance. This</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    implementation may choose a different minimum than the MATLAB</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    version.</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">        A condensed distance matrix. A condensed distance matrix</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">        is a flat array containing the upper triangular of the distance matrix.</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">        This is the form that ``pdist`` returns. Alternatively, a collection of</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        :math:`m` observation vectors in :math:`n` dimensions may be passed as</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">        an :math:`m` by :math:`n` array. All elements of the condensed distance</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">        matrix must be finite, i.e., no NaNs or infs.</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">        The linkage algorithm to use. See the ``Linkage Methods`` section below</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">        for full descriptions.</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    metric : str or function, optional</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">        The distance metric to use in the case that y is a collection of</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">        observation vectors; ignored otherwise. See the ``pdist``</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">        function for a list of valid distance metrics. A custom distance</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">        function can also be used.</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    optimal_ordering : bool, optional</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">        If True, the linkage matrix will be reordered so that the distance</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">        between successive leaves is minimal. This results in a more intuitive</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">        tree structure when the data are visualized. defaults to False, because</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">        this algorithm can be slow, particularly on large datasets [2]_. See</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">        also the `optimal_leaf_ordering` function.</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">        .. versionadded:: 1.0.0</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">        The hierarchical clustering encoded as a linkage matrix.</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    1. For method &#39;single&#39;, an optimized algorithm based on minimum spanning</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">       tree is implemented. It has time complexity :math:`O(n^2)`.</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">       For methods &#39;complete&#39;, &#39;average&#39;, &#39;weighted&#39; and &#39;ward&#39;, an algorithm</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">       called nearest-neighbors chain is implemented. It also has time</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">       complexity :math:`O(n^2)`.</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">       For other methods, a naive algorithm is implemented with :math:`O(n^3)`</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">       time complexity.</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">       All algorithms use :math:`O(n^2)` memory.</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">       Refer to [1]_ for details about the algorithms.</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    2. Methods &#39;centroid&#39;, &#39;median&#39;, and &#39;ward&#39; are correctly defined only if</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">       Euclidean pairwise metric is used. If `y` is passed as precomputed</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">       pairwise distances, then it is the user&#39;s responsibility to assure that</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">       these distances are in fact Euclidean, otherwise the produced result</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">       will be incorrect.</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    .. [1] Daniel Mullner, &quot;Modern hierarchical, agglomerative clustering</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">           algorithms&quot;, :arXiv:`1109.2378v1`.</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    .. [2] Ziv Bar-Joseph, David K. Gifford, Tommi S. Jaakkola, &quot;Fast optimal</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">           leaf ordering for hierarchical clustering&quot;, 2001. Bioinformatics</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">           :doi:`10.1093/bioinformatics/17.suppl_1.S22`</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import dendrogram, linkage</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    &gt;&gt;&gt; from matplotlib import pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    &gt;&gt;&gt; X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]]</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    &gt;&gt;&gt; Z = linkage(X, &#39;ward&#39;)</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure(figsize=(25, 10))</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    &gt;&gt;&gt; dn = dendrogram(Z)</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    &gt;&gt;&gt; Z = linkage(X, &#39;single&#39;)</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure(figsize=(25, 10))</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    &gt;&gt;&gt; dn = dendrogram(Z)</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1043</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> _LINKAGE_METHODS:</div>
<div class="line"><span class="lineno"> 1044</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid method: {0}&quot;</span>.format(method))</div>
<div class="line"><span class="lineno"> 1045</span> </div>
<div class="line"><span class="lineno"> 1046</span>    y = _convert_to_double(np.asarray(y, order=<span class="stringliteral">&#39;c&#39;</span>))</div>
<div class="line"><span class="lineno"> 1047</span> </div>
<div class="line"><span class="lineno"> 1048</span>    <span class="keywordflow">if</span> y.ndim == 1:</div>
<div class="line"><span class="lineno"> 1049</span>        distance.is_valid_y(y, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;y&#39;</span>)</div>
<div class="line"><span class="lineno"> 1050</span>        [y] = _copy_arrays_if_base_present([y])</div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">elif</span> y.ndim == 2:</div>
<div class="line"><span class="lineno"> 1052</span>        <span class="keywordflow">if</span> method <span class="keywordflow">in</span> _EUCLIDEAN_METHODS <span class="keywordflow">and</span> metric != <span class="stringliteral">&#39;euclidean&#39;</span>:</div>
<div class="line"><span class="lineno"> 1053</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Method &#39;{0}&#39; requires the distance metric &quot;</span></div>
<div class="line"><span class="lineno"> 1054</span>                             <span class="stringliteral">&quot;to be Euclidean&quot;</span>.format(method))</div>
<div class="line"><span class="lineno"> 1055</span>        <span class="keywordflow">if</span> y.shape[0] == y.shape[1] <span class="keywordflow">and</span> np.allclose(np.diag(y), 0):</div>
<div class="line"><span class="lineno"> 1056</span>            <span class="keywordflow">if</span> np.all(y &gt;= 0) <span class="keywordflow">and</span> np.allclose(y, y.T):</div>
<div class="line"><span class="lineno"> 1057</span>                _warning(<span class="stringliteral">&#39;The symmetric non-negative hollow observation &#39;</span></div>
<div class="line"><span class="lineno"> 1058</span>                         <span class="stringliteral">&#39;matrix looks suspiciously like an uncondensed &#39;</span></div>
<div class="line"><span class="lineno"> 1059</span>                         <span class="stringliteral">&#39;distance matrix&#39;</span>)</div>
<div class="line"><span class="lineno"> 1060</span>        y = distance.pdist(y, metric)</div>
<div class="line"><span class="lineno"> 1061</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1062</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`y` must be 1 or 2 dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1063</span> </div>
<div class="line"><span class="lineno"> 1064</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.all(np.isfinite(y)):</div>
<div class="line"><span class="lineno"> 1065</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The condensed distance matrix must contain only &quot;</span></div>
<div class="line"><span class="lineno"> 1066</span>                         <span class="stringliteral">&quot;finite values.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1067</span> </div>
<div class="line"><span class="lineno"> 1068</span>    n = int(distance.num_obs_y(y))</div>
<div class="line"><span class="lineno"> 1069</span>    method_code = _LINKAGE_METHODS[method]</div>
<div class="line"><span class="lineno"> 1070</span> </div>
<div class="line"><span class="lineno"> 1071</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;single&#39;</span>:</div>
<div class="line"><span class="lineno"> 1072</span>        result = _hierarchy.mst_single_linkage(y, n)</div>
<div class="line"><span class="lineno"> 1073</span>    <span class="keywordflow">elif</span> method <span class="keywordflow">in</span> [<span class="stringliteral">&#39;complete&#39;</span>, <span class="stringliteral">&#39;average&#39;</span>, <span class="stringliteral">&#39;weighted&#39;</span>, <span class="stringliteral">&#39;ward&#39;</span>]:</div>
<div class="line"><span class="lineno"> 1074</span>        result = _hierarchy.nn_chain(y, n, method_code)</div>
<div class="line"><span class="lineno"> 1075</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1076</span>        result = _hierarchy.fast_linkage(y, n, method_code)</div>
<div class="line"><span class="lineno"> 1077</span> </div>
<div class="line"><span class="lineno"> 1078</span>    <span class="keywordflow">if</span> optimal_ordering:</div>
<div class="line"><span class="lineno"> 1079</span>        <span class="keywordflow">return</span> optimal_leaf_ordering(result, y)</div>
<div class="line"><span class="lineno"> 1080</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1081</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1082</span> </div>
<div class="line"><span class="lineno"> 1083</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a96bbec63e697c10ef5ad79ef91483621" name="a96bbec63e697c10ef5ad79ef91483621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bbec63e697c10ef5ad79ef91483621">&#9670;&#160;</a></span>maxdists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.maxdists </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the maximum distance between any non-singleton cluster.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.

Returns
-------
maxdists : ndarray
    A ``(n-1)`` sized numpy array of doubles; ``MD[i]`` represents
    the maximum distance between any cluster (including
    singletons) below and including the node with index i. More
    specifically, ``MD[i] = Z[Q(i)-n, 2].max()`` where ``Q(i)`` is the
    set of all node indices below and including node i.

See Also
--------
linkage : for a description of what a linkage matrix is.
is_monotonic : for testing for monotonicity of a linkage matrix.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import median, maxdists
&gt;&gt;&gt; from scipy.spatial.distance import pdist

Given a linkage matrix ``Z``, `scipy.cluster.hierarchy.maxdists`
computes for each new cluster generated (i.e., for each row of the linkage
matrix) what is the maximum distance between any two child clusters.

Due to the nature of hierarchical clustering, in many cases this is going
to be just the distance between the two child clusters that were merged
to form the current one - that is, Z[:,2].

However, for non-monotonic cluster assignments such as
`scipy.cluster.hierarchy.median` clustering this is not always the
case: There may be cluster formations were the distance between the two
clusters merged is smaller than the distance between their children.

We can see this in an example:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = median(pdist(X))
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.11803399,  3.        ],
       [ 5.        , 13.        ,  1.11803399,  3.        ],
       [ 8.        , 15.        ,  1.11803399,  3.        ],
       [11.        , 14.        ,  1.11803399,  3.        ],
       [18.        , 19.        ,  3.        ,  6.        ],
       [16.        , 17.        ,  3.5       ,  6.        ],
       [20.        , 21.        ,  3.25      , 12.        ]])
&gt;&gt;&gt; maxdists(Z)
array([1.        , 1.        , 1.        , 1.        , 1.11803399,
       1.11803399, 1.11803399, 1.11803399, 3.        , 3.5       ,
       3.5       ])

Note that while the distance between the two clusters merged when creating the
last cluster is 3.25, there are two children (clusters 16 and 17) whose distance
is larger (3.5). Thus, `scipy.cluster.hierarchy.maxdists` returns 3.5 in
this case.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3784</span><span class="keyword">def </span>maxdists(Z):</div>
<div class="line"><span class="lineno"> 3785</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3786</span><span class="stringliteral">    Return the maximum distance between any non-singleton cluster.</span></div>
<div class="line"><span class="lineno"> 3787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3788</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3789</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3790</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 3791</span><span class="stringliteral">        The hierarchical clustering encoded as a matrix. See</span></div>
<div class="line"><span class="lineno"> 3792</span><span class="stringliteral">        ``linkage`` for more information.</span></div>
<div class="line"><span class="lineno"> 3793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3794</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3795</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3796</span><span class="stringliteral">    maxdists : ndarray</span></div>
<div class="line"><span class="lineno"> 3797</span><span class="stringliteral">        A ``(n-1)`` sized numpy array of doubles; ``MD[i]`` represents</span></div>
<div class="line"><span class="lineno"> 3798</span><span class="stringliteral">        the maximum distance between any cluster (including</span></div>
<div class="line"><span class="lineno"> 3799</span><span class="stringliteral">        singletons) below and including the node with index i. More</span></div>
<div class="line"><span class="lineno"> 3800</span><span class="stringliteral">        specifically, ``MD[i] = Z[Q(i)-n, 2].max()`` where ``Q(i)`` is the</span></div>
<div class="line"><span class="lineno"> 3801</span><span class="stringliteral">        set of all node indices below and including node i.</span></div>
<div class="line"><span class="lineno"> 3802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3803</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3804</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3805</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 3806</span><span class="stringliteral">    is_monotonic : for testing for monotonicity of a linkage matrix.</span></div>
<div class="line"><span class="lineno"> 3807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3808</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3809</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3810</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, maxdists</span></div>
<div class="line"><span class="lineno"> 3811</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 3812</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3813</span><span class="stringliteral">    Given a linkage matrix ``Z``, `scipy.cluster.hierarchy.maxdists`</span></div>
<div class="line"><span class="lineno"> 3814</span><span class="stringliteral">    computes for each new cluster generated (i.e., for each row of the linkage</span></div>
<div class="line"><span class="lineno"> 3815</span><span class="stringliteral">    matrix) what is the maximum distance between any two child clusters.</span></div>
<div class="line"><span class="lineno"> 3816</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3817</span><span class="stringliteral">    Due to the nature of hierarchical clustering, in many cases this is going</span></div>
<div class="line"><span class="lineno"> 3818</span><span class="stringliteral">    to be just the distance between the two child clusters that were merged</span></div>
<div class="line"><span class="lineno"> 3819</span><span class="stringliteral">    to form the current one - that is, Z[:,2].</span></div>
<div class="line"><span class="lineno"> 3820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3821</span><span class="stringliteral">    However, for non-monotonic cluster assignments such as</span></div>
<div class="line"><span class="lineno"> 3822</span><span class="stringliteral">    `scipy.cluster.hierarchy.median` clustering this is not always the</span></div>
<div class="line"><span class="lineno"> 3823</span><span class="stringliteral">    case: There may be cluster formations were the distance between the two</span></div>
<div class="line"><span class="lineno"> 3824</span><span class="stringliteral">    clusters merged is smaller than the distance between their children.</span></div>
<div class="line"><span class="lineno"> 3825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3826</span><span class="stringliteral">    We can see this in an example:</span></div>
<div class="line"><span class="lineno"> 3827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3828</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 3829</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 3830</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 3831</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 3832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3833</span><span class="stringliteral">    &gt;&gt;&gt; Z = median(pdist(X))</span></div>
<div class="line"><span class="lineno"> 3834</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 3835</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3836</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3837</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3838</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3839</span><span class="stringliteral">           [ 2.        , 12.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3840</span><span class="stringliteral">           [ 5.        , 13.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3841</span><span class="stringliteral">           [ 8.        , 15.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3842</span><span class="stringliteral">           [11.        , 14.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3843</span><span class="stringliteral">           [18.        , 19.        ,  3.        ,  6.        ],</span></div>
<div class="line"><span class="lineno"> 3844</span><span class="stringliteral">           [16.        , 17.        ,  3.5       ,  6.        ],</span></div>
<div class="line"><span class="lineno"> 3845</span><span class="stringliteral">           [20.        , 21.        ,  3.25      , 12.        ]])</span></div>
<div class="line"><span class="lineno"> 3846</span><span class="stringliteral">    &gt;&gt;&gt; maxdists(Z)</span></div>
<div class="line"><span class="lineno"> 3847</span><span class="stringliteral">    array([1.        , 1.        , 1.        , 1.        , 1.11803399,</span></div>
<div class="line"><span class="lineno"> 3848</span><span class="stringliteral">           1.11803399, 1.11803399, 1.11803399, 3.        , 3.5       ,</span></div>
<div class="line"><span class="lineno"> 3849</span><span class="stringliteral">           3.5       ])</span></div>
<div class="line"><span class="lineno"> 3850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3851</span><span class="stringliteral">    Note that while the distance between the two clusters merged when creating the</span></div>
<div class="line"><span class="lineno"> 3852</span><span class="stringliteral">    last cluster is 3.25, there are two children (clusters 16 and 17) whose distance</span></div>
<div class="line"><span class="lineno"> 3853</span><span class="stringliteral">    is larger (3.5). Thus, `scipy.cluster.hierarchy.maxdists` returns 3.5 in</span></div>
<div class="line"><span class="lineno"> 3854</span><span class="stringliteral">    this case.</span></div>
<div class="line"><span class="lineno"> 3855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3856</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3857</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>, dtype=np.double)</div>
<div class="line"><span class="lineno"> 3858</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 3859</span> </div>
<div class="line"><span class="lineno"> 3860</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 3861</span>    MD = np.zeros((n - 1,))</div>
<div class="line"><span class="lineno"> 3862</span>    [Z] = _copy_arrays_if_base_present([Z])</div>
<div class="line"><span class="lineno"> 3863</span>    _hierarchy.get_max_dist_for_each_cluster(Z, MD, int(n))</div>
<div class="line"><span class="lineno"> 3864</span>    <span class="keywordflow">return</span> MD</div>
<div class="line"><span class="lineno"> 3865</span> </div>
<div class="line"><span class="lineno"> 3866</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a84328c677da43f757bd468f6060c926b" name="a84328c677da43f757bd468f6060c926b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84328c677da43f757bd468f6060c926b">&#9670;&#160;</a></span>maxinconsts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.maxinconsts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the maximum inconsistency coefficient for each
non-singleton cluster and its children.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    `linkage` for more information.
R : ndarray
    The inconsistency matrix.

Returns
-------
MI : ndarray
    A monotonic ``(n-1)``-sized numpy array of doubles.

See Also
--------
linkage : for a description of what a linkage matrix is.
inconsistent : for the creation of a inconsistency matrix.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import median, inconsistent, maxinconsts
&gt;&gt;&gt; from scipy.spatial.distance import pdist

Given a data set ``X``, we can apply a clustering method to obtain a
linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can
be also used to obtain the inconsistency matrix ``R`` associated to
this clustering process:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = median(pdist(X))
&gt;&gt;&gt; R = inconsistent(Z)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.11803399,  3.        ],
       [ 5.        , 13.        ,  1.11803399,  3.        ],
       [ 8.        , 15.        ,  1.11803399,  3.        ],
       [11.        , 14.        ,  1.11803399,  3.        ],
       [18.        , 19.        ,  3.        ,  6.        ],
       [16.        , 17.        ,  3.5       ,  6.        ],
       [20.        , 21.        ,  3.25      , 12.        ]])
&gt;&gt;&gt; R
array([[1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.74535599, 1.08655358, 3.        , 1.15470054],
       [1.91202266, 1.37522872, 3.        , 1.15470054],
       [3.25      , 0.25      , 3.        , 0.        ]])

Here, `scipy.cluster.hierarchy.maxinconsts` can be used to compute
the maximum value of the inconsistency statistic (the last column of
``R``) for each non-singleton cluster and its children:

&gt;&gt;&gt; maxinconsts(Z, R)
array([0.        , 0.        , 0.        , 0.        , 0.70710678,
       0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054,
       1.15470054])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3867</span><span class="keyword">def </span>maxinconsts(Z, R):</div>
<div class="line"><span class="lineno"> 3868</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3869</span><span class="stringliteral">    Return the maximum inconsistency coefficient for each</span></div>
<div class="line"><span class="lineno"> 3870</span><span class="stringliteral">    non-singleton cluster and its children.</span></div>
<div class="line"><span class="lineno"> 3871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3872</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3873</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3874</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 3875</span><span class="stringliteral">        The hierarchical clustering encoded as a matrix. See</span></div>
<div class="line"><span class="lineno"> 3876</span><span class="stringliteral">        `linkage` for more information.</span></div>
<div class="line"><span class="lineno"> 3877</span><span class="stringliteral">    R : ndarray</span></div>
<div class="line"><span class="lineno"> 3878</span><span class="stringliteral">        The inconsistency matrix.</span></div>
<div class="line"><span class="lineno"> 3879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3880</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3881</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3882</span><span class="stringliteral">    MI : ndarray</span></div>
<div class="line"><span class="lineno"> 3883</span><span class="stringliteral">        A monotonic ``(n-1)``-sized numpy array of doubles.</span></div>
<div class="line"><span class="lineno"> 3884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3885</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3886</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3887</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 3888</span><span class="stringliteral">    inconsistent : for the creation of a inconsistency matrix.</span></div>
<div class="line"><span class="lineno"> 3889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3890</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3891</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3892</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, inconsistent, maxinconsts</span></div>
<div class="line"><span class="lineno"> 3893</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 3894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3895</span><span class="stringliteral">    Given a data set ``X``, we can apply a clustering method to obtain a</span></div>
<div class="line"><span class="lineno"> 3896</span><span class="stringliteral">    linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can</span></div>
<div class="line"><span class="lineno"> 3897</span><span class="stringliteral">    be also used to obtain the inconsistency matrix ``R`` associated to</span></div>
<div class="line"><span class="lineno"> 3898</span><span class="stringliteral">    this clustering process:</span></div>
<div class="line"><span class="lineno"> 3899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3900</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 3901</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 3902</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 3903</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 3904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3905</span><span class="stringliteral">    &gt;&gt;&gt; Z = median(pdist(X))</span></div>
<div class="line"><span class="lineno"> 3906</span><span class="stringliteral">    &gt;&gt;&gt; R = inconsistent(Z)</span></div>
<div class="line"><span class="lineno"> 3907</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 3908</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3909</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3910</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3911</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 3912</span><span class="stringliteral">           [ 2.        , 12.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3913</span><span class="stringliteral">           [ 5.        , 13.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3914</span><span class="stringliteral">           [ 8.        , 15.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3915</span><span class="stringliteral">           [11.        , 14.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno"> 3916</span><span class="stringliteral">           [18.        , 19.        ,  3.        ,  6.        ],</span></div>
<div class="line"><span class="lineno"> 3917</span><span class="stringliteral">           [16.        , 17.        ,  3.5       ,  6.        ],</span></div>
<div class="line"><span class="lineno"> 3918</span><span class="stringliteral">           [20.        , 21.        ,  3.25      , 12.        ]])</span></div>
<div class="line"><span class="lineno"> 3919</span><span class="stringliteral">    &gt;&gt;&gt; R</span></div>
<div class="line"><span class="lineno"> 3920</span><span class="stringliteral">    array([[1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 3921</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 3922</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 3923</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 3924</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 3925</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 3926</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 3927</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 3928</span><span class="stringliteral">           [1.74535599, 1.08655358, 3.        , 1.15470054],</span></div>
<div class="line"><span class="lineno"> 3929</span><span class="stringliteral">           [1.91202266, 1.37522872, 3.        , 1.15470054],</span></div>
<div class="line"><span class="lineno"> 3930</span><span class="stringliteral">           [3.25      , 0.25      , 3.        , 0.        ]])</span></div>
<div class="line"><span class="lineno"> 3931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3932</span><span class="stringliteral">    Here, `scipy.cluster.hierarchy.maxinconsts` can be used to compute</span></div>
<div class="line"><span class="lineno"> 3933</span><span class="stringliteral">    the maximum value of the inconsistency statistic (the last column of</span></div>
<div class="line"><span class="lineno"> 3934</span><span class="stringliteral">    ``R``) for each non-singleton cluster and its children:</span></div>
<div class="line"><span class="lineno"> 3935</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3936</span><span class="stringliteral">    &gt;&gt;&gt; maxinconsts(Z, R)</span></div>
<div class="line"><span class="lineno"> 3937</span><span class="stringliteral">    array([0.        , 0.        , 0.        , 0.        , 0.70710678,</span></div>
<div class="line"><span class="lineno"> 3938</span><span class="stringliteral">           0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054,</span></div>
<div class="line"><span class="lineno"> 3939</span><span class="stringliteral">           1.15470054])</span></div>
<div class="line"><span class="lineno"> 3940</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3941</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3942</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 3943</span>    R = np.asarray(R, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 3944</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 3945</span>    is_valid_im(R, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;R&#39;</span>)</div>
<div class="line"><span class="lineno"> 3946</span> </div>
<div class="line"><span class="lineno"> 3947</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 3948</span>    <span class="keywordflow">if</span> Z.shape[0] != R.shape[0]:</div>
<div class="line"><span class="lineno"> 3949</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The inconsistency matrix and linkage matrix each &quot;</span></div>
<div class="line"><span class="lineno"> 3950</span>                         <span class="stringliteral">&quot;have a different number of rows.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3951</span>    MI = np.zeros((n - 1,))</div>
<div class="line"><span class="lineno"> 3952</span>    [Z, R] = _copy_arrays_if_base_present([Z, R])</div>
<div class="line"><span class="lineno"> 3953</span>    _hierarchy.get_max_Rfield_for_each_cluster(Z, R, MI, int(n), 3)</div>
<div class="line"><span class="lineno"> 3954</span>    <span class="keywordflow">return</span> MI</div>
<div class="line"><span class="lineno"> 3955</span> </div>
<div class="line"><span class="lineno"> 3956</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9decd74c1e3c23a1d0ed9417e569b866" name="a9decd74c1e3c23a1d0ed9417e569b866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9decd74c1e3c23a1d0ed9417e569b866">&#9670;&#160;</a></span>maxRstat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.maxRstat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the maximum statistic for each non-singleton cluster and its
children.

Parameters
----------
Z : array_like
    The hierarchical clustering encoded as a matrix. See `linkage` for more
    information.
R : array_like
    The inconsistency matrix.
i : int
    The column of `R` to use as the statistic.

Returns
-------
MR : ndarray
    Calculates the maximum statistic for the i'th column of the
    inconsistency matrix `R` for each non-singleton cluster
    node. ``MR[j]`` is the maximum over ``R[Q(j)-n, i]``, where
    ``Q(j)`` the set of all node ids corresponding to nodes below
    and including ``j``.

See Also
--------
linkage : for a description of what a linkage matrix is.
inconsistent : for the creation of a inconsistency matrix.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import median, inconsistent, maxRstat
&gt;&gt;&gt; from scipy.spatial.distance import pdist

Given a data set ``X``, we can apply a clustering method to obtain a
linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can
be also used to obtain the inconsistency matrix ``R`` associated to
this clustering process:

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = median(pdist(X))
&gt;&gt;&gt; R = inconsistent(Z)
&gt;&gt;&gt; R
array([[1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.        , 0.        , 1.        , 0.        ],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.05901699, 0.08346263, 2.        , 0.70710678],
       [1.74535599, 1.08655358, 3.        , 1.15470054],
       [1.91202266, 1.37522872, 3.        , 1.15470054],
       [3.25      , 0.25      , 3.        , 0.        ]])

`scipy.cluster.hierarchy.maxRstat` can be used to compute
the maximum value of each column of ``R``, for each non-singleton
cluster and its children:

&gt;&gt;&gt; maxRstat(Z, R, 0)
array([1.        , 1.        , 1.        , 1.        , 1.05901699,
       1.05901699, 1.05901699, 1.05901699, 1.74535599, 1.91202266,
       3.25      ])
&gt;&gt;&gt; maxRstat(Z, R, 1)
array([0.        , 0.        , 0.        , 0.        , 0.08346263,
       0.08346263, 0.08346263, 0.08346263, 1.08655358, 1.37522872,
       1.37522872])
&gt;&gt;&gt; maxRstat(Z, R, 3)
array([0.        , 0.        , 0.        , 0.        , 0.70710678,
       0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054,
       1.15470054])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3957</span><span class="keyword">def </span>maxRstat(Z, R, i):</div>
<div class="line"><span class="lineno"> 3958</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3959</span><span class="stringliteral">    Return the maximum statistic for each non-singleton cluster and its</span></div>
<div class="line"><span class="lineno"> 3960</span><span class="stringliteral">    children.</span></div>
<div class="line"><span class="lineno"> 3961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3962</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3963</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3964</span><span class="stringliteral">    Z : array_like</span></div>
<div class="line"><span class="lineno"> 3965</span><span class="stringliteral">        The hierarchical clustering encoded as a matrix. See `linkage` for more</span></div>
<div class="line"><span class="lineno"> 3966</span><span class="stringliteral">        information.</span></div>
<div class="line"><span class="lineno"> 3967</span><span class="stringliteral">    R : array_like</span></div>
<div class="line"><span class="lineno"> 3968</span><span class="stringliteral">        The inconsistency matrix.</span></div>
<div class="line"><span class="lineno"> 3969</span><span class="stringliteral">    i : int</span></div>
<div class="line"><span class="lineno"> 3970</span><span class="stringliteral">        The column of `R` to use as the statistic.</span></div>
<div class="line"><span class="lineno"> 3971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3972</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3973</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3974</span><span class="stringliteral">    MR : ndarray</span></div>
<div class="line"><span class="lineno"> 3975</span><span class="stringliteral">        Calculates the maximum statistic for the i&#39;th column of the</span></div>
<div class="line"><span class="lineno"> 3976</span><span class="stringliteral">        inconsistency matrix `R` for each non-singleton cluster</span></div>
<div class="line"><span class="lineno"> 3977</span><span class="stringliteral">        node. ``MR[j]`` is the maximum over ``R[Q(j)-n, i]``, where</span></div>
<div class="line"><span class="lineno"> 3978</span><span class="stringliteral">        ``Q(j)`` the set of all node ids corresponding to nodes below</span></div>
<div class="line"><span class="lineno"> 3979</span><span class="stringliteral">        and including ``j``.</span></div>
<div class="line"><span class="lineno"> 3980</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3981</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3982</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3983</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 3984</span><span class="stringliteral">    inconsistent : for the creation of a inconsistency matrix.</span></div>
<div class="line"><span class="lineno"> 3985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3986</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3987</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3988</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, inconsistent, maxRstat</span></div>
<div class="line"><span class="lineno"> 3989</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 3990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3991</span><span class="stringliteral">    Given a data set ``X``, we can apply a clustering method to obtain a</span></div>
<div class="line"><span class="lineno"> 3992</span><span class="stringliteral">    linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can</span></div>
<div class="line"><span class="lineno"> 3993</span><span class="stringliteral">    be also used to obtain the inconsistency matrix ``R`` associated to</span></div>
<div class="line"><span class="lineno"> 3994</span><span class="stringliteral">    this clustering process:</span></div>
<div class="line"><span class="lineno"> 3995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3996</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 3997</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 3998</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 3999</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 4000</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4001</span><span class="stringliteral">    &gt;&gt;&gt; Z = median(pdist(X))</span></div>
<div class="line"><span class="lineno"> 4002</span><span class="stringliteral">    &gt;&gt;&gt; R = inconsistent(Z)</span></div>
<div class="line"><span class="lineno"> 4003</span><span class="stringliteral">    &gt;&gt;&gt; R</span></div>
<div class="line"><span class="lineno"> 4004</span><span class="stringliteral">    array([[1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 4005</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 4006</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 4007</span><span class="stringliteral">           [1.        , 0.        , 1.        , 0.        ],</span></div>
<div class="line"><span class="lineno"> 4008</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 4009</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 4010</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 4011</span><span class="stringliteral">           [1.05901699, 0.08346263, 2.        , 0.70710678],</span></div>
<div class="line"><span class="lineno"> 4012</span><span class="stringliteral">           [1.74535599, 1.08655358, 3.        , 1.15470054],</span></div>
<div class="line"><span class="lineno"> 4013</span><span class="stringliteral">           [1.91202266, 1.37522872, 3.        , 1.15470054],</span></div>
<div class="line"><span class="lineno"> 4014</span><span class="stringliteral">           [3.25      , 0.25      , 3.        , 0.        ]])</span></div>
<div class="line"><span class="lineno"> 4015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4016</span><span class="stringliteral">    `scipy.cluster.hierarchy.maxRstat` can be used to compute</span></div>
<div class="line"><span class="lineno"> 4017</span><span class="stringliteral">    the maximum value of each column of ``R``, for each non-singleton</span></div>
<div class="line"><span class="lineno"> 4018</span><span class="stringliteral">    cluster and its children:</span></div>
<div class="line"><span class="lineno"> 4019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4020</span><span class="stringliteral">    &gt;&gt;&gt; maxRstat(Z, R, 0)</span></div>
<div class="line"><span class="lineno"> 4021</span><span class="stringliteral">    array([1.        , 1.        , 1.        , 1.        , 1.05901699,</span></div>
<div class="line"><span class="lineno"> 4022</span><span class="stringliteral">           1.05901699, 1.05901699, 1.05901699, 1.74535599, 1.91202266,</span></div>
<div class="line"><span class="lineno"> 4023</span><span class="stringliteral">           3.25      ])</span></div>
<div class="line"><span class="lineno"> 4024</span><span class="stringliteral">    &gt;&gt;&gt; maxRstat(Z, R, 1)</span></div>
<div class="line"><span class="lineno"> 4025</span><span class="stringliteral">    array([0.        , 0.        , 0.        , 0.        , 0.08346263,</span></div>
<div class="line"><span class="lineno"> 4026</span><span class="stringliteral">           0.08346263, 0.08346263, 0.08346263, 1.08655358, 1.37522872,</span></div>
<div class="line"><span class="lineno"> 4027</span><span class="stringliteral">           1.37522872])</span></div>
<div class="line"><span class="lineno"> 4028</span><span class="stringliteral">    &gt;&gt;&gt; maxRstat(Z, R, 3)</span></div>
<div class="line"><span class="lineno"> 4029</span><span class="stringliteral">    array([0.        , 0.        , 0.        , 0.        , 0.70710678,</span></div>
<div class="line"><span class="lineno"> 4030</span><span class="stringliteral">           0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054,</span></div>
<div class="line"><span class="lineno"> 4031</span><span class="stringliteral">           1.15470054])</span></div>
<div class="line"><span class="lineno"> 4032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4033</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4034</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 4035</span>    R = np.asarray(R, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 4036</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 4037</span>    is_valid_im(R, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;R&#39;</span>)</div>
<div class="line"><span class="lineno"> 4038</span>    <span class="keywordflow">if</span> type(i) <span class="keywordflow">is</span> <span class="keywordflow">not</span> int:</div>
<div class="line"><span class="lineno"> 4039</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;The third argument must be an integer.&#39;</span>)</div>
<div class="line"><span class="lineno"> 4040</span>    <span class="keywordflow">if</span> i &lt; 0 <span class="keywordflow">or</span> i &gt; 3:</div>
<div class="line"><span class="lineno"> 4041</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;i must be an integer between 0 and 3 inclusive.&#39;</span>)</div>
<div class="line"><span class="lineno"> 4042</span> </div>
<div class="line"><span class="lineno"> 4043</span>    <span class="keywordflow">if</span> Z.shape[0] != R.shape[0]:</div>
<div class="line"><span class="lineno"> 4044</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The inconsistency matrix and linkage matrix each &quot;</span></div>
<div class="line"><span class="lineno"> 4045</span>                         <span class="stringliteral">&quot;have a different number of rows.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4046</span> </div>
<div class="line"><span class="lineno"> 4047</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 4048</span>    MR = np.zeros((n - 1,))</div>
<div class="line"><span class="lineno"> 4049</span>    [Z, R] = _copy_arrays_if_base_present([Z, R])</div>
<div class="line"><span class="lineno"> 4050</span>    _hierarchy.get_max_Rfield_for_each_cluster(Z, R, MR, int(n), i)</div>
<div class="line"><span class="lineno"> 4051</span>    <span class="keywordflow">return</span> MR</div>
<div class="line"><span class="lineno"> 4052</span> </div>
<div class="line"><span class="lineno"> 4053</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a60b4c53f5b1aa19afe45b628dcaf6840" name="a60b4c53f5b1aa19afe45b628dcaf6840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b4c53f5b1aa19afe45b628dcaf6840">&#9670;&#160;</a></span>median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.median </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform median/WPGMC linkage.

See `linkage` for more information on the return structure
and algorithm.

 The following are common calling conventions:

 1. ``Z = median(y)``

    Performs median/WPGMC linkage on the condensed distance matrix
    ``y``.  See ``linkage`` for more information on the return
    structure and algorithm.

 2. ``Z = median(X)``

    Performs median/WPGMC linkage on the observation matrix ``X``
    using Euclidean distance as the distance metric. See `linkage`
    for more information on the return structure and algorithm.

Parameters
----------
y : ndarray
    A condensed distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns.  Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    an m by n array.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import median, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

First, we need a toy dataset to play with::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

Then, we get a condensed distance matrix from this dataset:

&gt;&gt;&gt; y = pdist(X)

Finally, we can perform the clustering:

&gt;&gt;&gt; Z = median(y)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.11803399,  3.        ],
       [ 5.        , 13.        ,  1.11803399,  3.        ],
       [ 8.        , 15.        ,  1.11803399,  3.        ],
       [11.        , 14.        ,  1.11803399,  3.        ],
       [18.        , 19.        ,  3.        ,  6.        ],
       [16.        , 17.        ,  3.5       ,  6.        ],
       [20.        , 21.        ,  3.25      , 12.        ]])

The linkage matrix ``Z`` represents a dendrogram - see
`scipy.cluster.hierarchy.linkage` for a detailed explanation of its
contents.

We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster
each initial point would belong given a distance threshold:

&gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 1.1, criterion='distance')
array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 2, criterion='distance')
array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 4, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a
plot of the dendrogram.</pre> <div class="fragment"><div class="line"><span class="lineno">  636</span><span class="keyword">def </span>median(y):</div>
<div class="line"><span class="lineno">  637</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    Perform median/WPGMC linkage.</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    See `linkage` for more information on the return structure</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    and algorithm.</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">     The following are common calling conventions:</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">     1. ``Z = median(y)``</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        Performs median/WPGMC linkage on the condensed distance matrix</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">        ``y``.  See ``linkage`` for more information on the return</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        structure and algorithm.</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">     2. ``Z = median(X)``</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        Performs median/WPGMC linkage on the observation matrix ``X``</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">        using Euclidean distance as the distance metric. See `linkage`</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        for more information on the return structure and algorithm.</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        A condensed distance matrix. A condensed</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">        distance matrix is a flat array containing the upper</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        triangular of the distance matrix. This is the form that</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">        ``pdist`` returns.  Alternatively, a collection of</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">        m observation vectors in n dimensions may be passed as</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        an m by n array.</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        The hierarchical clustering encoded as a linkage matrix.</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    linkage : for advanced creation of hierarchical clusterings.</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, fcluster</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    First, we need a toy dataset to play with::</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    Then, we get a condensed distance matrix from this dataset:</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    &gt;&gt;&gt; y = pdist(X)</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    Finally, we can perform the clustering:</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    &gt;&gt;&gt; Z = median(y)</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">           [ 2.        , 12.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">           [ 5.        , 13.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">           [ 8.        , 15.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">           [11.        , 14.        ,  1.11803399,  3.        ],</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">           [18.        , 19.        ,  3.        ,  6.        ],</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">           [16.        , 17.        ,  3.5       ,  6.        ],</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">           [20.        , 21.        ,  3.25      , 12.        ]])</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram - see</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    contents.</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    each initial point would belong given a distance threshold:</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32)</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 1.1, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 2, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32)</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 4, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    plot of the dendrogram.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  735</span>    <span class="keywordflow">return</span> linkage(y, method=<span class="stringliteral">&#39;median&#39;</span>, metric=<span class="stringliteral">&#39;euclidean&#39;</span>)</div>
<div class="line"><span class="lineno">  736</span> </div>
<div class="line"><span class="lineno">  737</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a725b5a843007245a8524e42c8293b913" name="a725b5a843007245a8524e42c8293b913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725b5a843007245a8524e42c8293b913">&#9670;&#160;</a></span>num_obs_linkage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.num_obs_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of original observations of the linkage matrix passed.

Parameters
----------
Z : ndarray
    The linkage matrix on which to perform the operation.

Returns
-------
n : int
    The number of original observations in the linkage.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, num_obs_linkage
&gt;&gt;&gt; from scipy.spatial.distance import pdist

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))

``Z`` is a linkage matrix obtained after using the Ward clustering method
with ``X``, a dataset with 12 data points.

&gt;&gt;&gt; num_obs_linkage(Z)
12</pre> <div class="fragment"><div class="line"><span class="lineno"> 2332</span><span class="keyword">def </span>num_obs_linkage(Z):</div>
<div class="line"><span class="lineno"> 2333</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral">    Return the number of original observations of the linkage matrix passed.</span></div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral">        The linkage matrix on which to perform the operation.</span></div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno"> 2344</span><span class="stringliteral">        The number of original observations in the linkage.</span></div>
<div class="line"><span class="lineno"> 2345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2346</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2347</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2348</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, num_obs_linkage</span></div>
<div class="line"><span class="lineno"> 2349</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 2350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2351</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 2352</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 2353</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 2354</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 2355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2356</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 2357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2358</span><span class="stringliteral">    ``Z`` is a linkage matrix obtained after using the Ward clustering method</span></div>
<div class="line"><span class="lineno"> 2359</span><span class="stringliteral">    with ``X``, a dataset with 12 data points.</span></div>
<div class="line"><span class="lineno"> 2360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2361</span><span class="stringliteral">    &gt;&gt;&gt; num_obs_linkage(Z)</span></div>
<div class="line"><span class="lineno"> 2362</span><span class="stringliteral">    12</span></div>
<div class="line"><span class="lineno"> 2363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2364</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2365</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 2366</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 2367</span>    <span class="keywordflow">return</span> (Z.shape[0] + 1)</div>
<div class="line"><span class="lineno"> 2368</span> </div>
<div class="line"><span class="lineno"> 2369</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5e46d28bf6d0bd1f8c2e605bee4040a" name="ab5e46d28bf6d0bd1f8c2e605bee4040a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e46d28bf6d0bd1f8c2e605bee4040a">&#9670;&#160;</a></span>optimal_leaf_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.optimal_leaf_ordering </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>'euclidean'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given a linkage matrix Z and distance, reorder the cut tree.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix. See
    `linkage` for more information on the return structure and
    algorithm.
y : ndarray
    The condensed distance matrix from which Z was generated.
    Alternatively, a collection of m observation vectors in n
    dimensions may be passed as an m by n array.
metric : str or function, optional
    The distance metric to use in the case that y is a collection of
    observation vectors; ignored otherwise. See the ``pdist``
    function for a list of valid distance metrics. A custom distance
    function can also be used.

Returns
-------
Z_ordered : ndarray
    A copy of the linkage matrix Z, reordered to minimize the distance
    between adjacent leaves.

Examples
--------
&gt;&gt;&gt; from scipy.cluster import hierarchy
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; X = rng.standard_normal((10, 10))
&gt;&gt;&gt; Z = hierarchy.ward(X)
&gt;&gt;&gt; hierarchy.leaves_list(Z)
array([0, 3, 1, 9, 2, 5, 7, 4, 6, 8], dtype=int32)
&gt;&gt;&gt; hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, X))
array([3, 0, 2, 5, 7, 4, 8, 6, 9, 1], dtype=int32)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1499</span><span class="keyword">def </span>optimal_leaf_ordering(Z, y, metric=&#39;euclidean&#39;):</div>
<div class="line"><span class="lineno"> 1500</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    Given a linkage matrix Z and distance, reorder the cut tree.</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">        The hierarchical clustering encoded as a linkage matrix. See</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">        `linkage` for more information on the return structure and</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">        algorithm.</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        The condensed distance matrix from which Z was generated.</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">        Alternatively, a collection of m observation vectors in n</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        dimensions may be passed as an m by n array.</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    metric : str or function, optional</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">        The distance metric to use in the case that y is a collection of</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">        observation vectors; ignored otherwise. See the ``pdist``</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        function for a list of valid distance metrics. A custom distance</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">        function can also be used.</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    Z_ordered : ndarray</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">        A copy of the linkage matrix Z, reordered to minimize the distance</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        between adjacent leaves.</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster import hierarchy</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">    &gt;&gt;&gt; X = rng.standard_normal((10, 10))</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    &gt;&gt;&gt; Z = hierarchy.ward(X)</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    &gt;&gt;&gt; hierarchy.leaves_list(Z)</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    array([0, 3, 1, 9, 2, 5, 7, 4, 6, 8], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    &gt;&gt;&gt; hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, X))</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">    array([3, 0, 2, 5, 7, 4, 8, 6, 9, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1537</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 1538</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 1539</span> </div>
<div class="line"><span class="lineno"> 1540</span>    y = _convert_to_double(np.asarray(y, order=<span class="stringliteral">&#39;c&#39;</span>))</div>
<div class="line"><span class="lineno"> 1541</span> </div>
<div class="line"><span class="lineno"> 1542</span>    <span class="keywordflow">if</span> y.ndim == 1:</div>
<div class="line"><span class="lineno"> 1543</span>        distance.is_valid_y(y, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;y&#39;</span>)</div>
<div class="line"><span class="lineno"> 1544</span>        [y] = _copy_arrays_if_base_present([y])</div>
<div class="line"><span class="lineno"> 1545</span>    <span class="keywordflow">elif</span> y.ndim == 2:</div>
<div class="line"><span class="lineno"> 1546</span>        <span class="keywordflow">if</span> y.shape[0] == y.shape[1] <span class="keywordflow">and</span> np.allclose(np.diag(y), 0):</div>
<div class="line"><span class="lineno"> 1547</span>            <span class="keywordflow">if</span> np.all(y &gt;= 0) <span class="keywordflow">and</span> np.allclose(y, y.T):</div>
<div class="line"><span class="lineno"> 1548</span>                _warning(<span class="stringliteral">&#39;The symmetric non-negative hollow observation &#39;</span></div>
<div class="line"><span class="lineno"> 1549</span>                         <span class="stringliteral">&#39;matrix looks suspiciously like an uncondensed &#39;</span></div>
<div class="line"><span class="lineno"> 1550</span>                         <span class="stringliteral">&#39;distance matrix&#39;</span>)</div>
<div class="line"><span class="lineno"> 1551</span>        y = distance.pdist(y, metric)</div>
<div class="line"><span class="lineno"> 1552</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1553</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`y` must be 1 or 2 dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1554</span> </div>
<div class="line"><span class="lineno"> 1555</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.all(np.isfinite(y)):</div>
<div class="line"><span class="lineno"> 1556</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The condensed distance matrix must contain only &quot;</span></div>
<div class="line"><span class="lineno"> 1557</span>                         <span class="stringliteral">&quot;finite values.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1558</span> </div>
<div class="line"><span class="lineno"> 1559</span>    <span class="keywordflow">return</span> _optimal_leaf_ordering.optimal_leaf_ordering(Z, y)</div>
<div class="line"><span class="lineno"> 1560</span> </div>
<div class="line"><span class="lineno"> 1561</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a10936aca9c1d0887f7a882f364fdf072" name="a10936aca9c1d0887f7a882f364fdf072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10936aca9c1d0887f7a882f364fdf072">&#9670;&#160;</a></span>set_link_color_palette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.set_link_color_palette </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>palette</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set list of matplotlib color codes for use by dendrogram.

Note that this palette is global (i.e., setting it once changes the colors
for all subsequent calls to `dendrogram`) and that it affects only the
the colors below ``color_threshold``.

Note that `dendrogram` also accepts a custom coloring function through its
``link_color_func`` keyword, which is more flexible and non-global.

Parameters
----------
palette : list of str or None
    A list of matplotlib color codes.  The order of the color codes is the
    order in which the colors are cycled through when color thresholding in
    the dendrogram.

    If ``None``, resets the palette to its default (which are matplotlib
    default colors C1 to C9).

Returns
-------
None

See Also
--------
dendrogram

Notes
-----
Ability to reset the palette with ``None`` added in SciPy 0.17.0.

Examples
--------
&gt;&gt;&gt; from scipy.cluster import hierarchy
&gt;&gt;&gt; ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268.,
...                    400., 754., 564., 138., 219., 869., 669.])
&gt;&gt;&gt; Z = hierarchy.linkage(ytdist, 'single')
&gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True)
&gt;&gt;&gt; dn['color_list']
['C1', 'C0', 'C0', 'C0', 'C0']
&gt;&gt;&gt; hierarchy.set_link_color_palette(['c', 'm', 'y', 'k'])
&gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True, above_threshold_color='b')
&gt;&gt;&gt; dn['color_list']
['c', 'b', 'b', 'b', 'b']
&gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True, color_threshold=267,
...                           above_threshold_color='k')
&gt;&gt;&gt; dn['color_list']
['c', 'm', 'm', 'k', 'k']

Now, reset the color palette to its default:

&gt;&gt;&gt; hierarchy.set_link_color_palette(None)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2950</span><span class="keyword">def </span>set_link_color_palette(palette):</div>
<div class="line"><span class="lineno"> 2951</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2952</span><span class="stringliteral">    Set list of matplotlib color codes for use by dendrogram.</span></div>
<div class="line"><span class="lineno"> 2953</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2954</span><span class="stringliteral">    Note that this palette is global (i.e., setting it once changes the colors</span></div>
<div class="line"><span class="lineno"> 2955</span><span class="stringliteral">    for all subsequent calls to `dendrogram`) and that it affects only the</span></div>
<div class="line"><span class="lineno"> 2956</span><span class="stringliteral">    the colors below ``color_threshold``.</span></div>
<div class="line"><span class="lineno"> 2957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2958</span><span class="stringliteral">    Note that `dendrogram` also accepts a custom coloring function through its</span></div>
<div class="line"><span class="lineno"> 2959</span><span class="stringliteral">    ``link_color_func`` keyword, which is more flexible and non-global.</span></div>
<div class="line"><span class="lineno"> 2960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2961</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2962</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2963</span><span class="stringliteral">    palette : list of str or None</span></div>
<div class="line"><span class="lineno"> 2964</span><span class="stringliteral">        A list of matplotlib color codes.  The order of the color codes is the</span></div>
<div class="line"><span class="lineno"> 2965</span><span class="stringliteral">        order in which the colors are cycled through when color thresholding in</span></div>
<div class="line"><span class="lineno"> 2966</span><span class="stringliteral">        the dendrogram.</span></div>
<div class="line"><span class="lineno"> 2967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2968</span><span class="stringliteral">        If ``None``, resets the palette to its default (which are matplotlib</span></div>
<div class="line"><span class="lineno"> 2969</span><span class="stringliteral">        default colors C1 to C9).</span></div>
<div class="line"><span class="lineno"> 2970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2971</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2972</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2973</span><span class="stringliteral">    None</span></div>
<div class="line"><span class="lineno"> 2974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2975</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2976</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2977</span><span class="stringliteral">    dendrogram</span></div>
<div class="line"><span class="lineno"> 2978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2979</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2980</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral">    Ability to reset the palette with ``None`` added in SciPy 0.17.0.</span></div>
<div class="line"><span class="lineno"> 2982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2983</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2984</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2985</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster import hierarchy</span></div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">    &gt;&gt;&gt; ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268.,</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral">    ...                    400., 754., 564., 138., 219., 869., 669.])</span></div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral">    &gt;&gt;&gt; Z = hierarchy.linkage(ytdist, &#39;single&#39;)</span></div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral">    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True)</span></div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral">    &gt;&gt;&gt; dn[&#39;color_list&#39;]</span></div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral">    [&#39;C1&#39;, &#39;C0&#39;, &#39;C0&#39;, &#39;C0&#39;, &#39;C0&#39;]</span></div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">    &gt;&gt;&gt; hierarchy.set_link_color_palette([&#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;k&#39;])</span></div>
<div class="line"><span class="lineno"> 2993</span><span class="stringliteral">    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True, above_threshold_color=&#39;b&#39;)</span></div>
<div class="line"><span class="lineno"> 2994</span><span class="stringliteral">    &gt;&gt;&gt; dn[&#39;color_list&#39;]</span></div>
<div class="line"><span class="lineno"> 2995</span><span class="stringliteral">    [&#39;c&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;]</span></div>
<div class="line"><span class="lineno"> 2996</span><span class="stringliteral">    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True, color_threshold=267,</span></div>
<div class="line"><span class="lineno"> 2997</span><span class="stringliteral">    ...                           above_threshold_color=&#39;k&#39;)</span></div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral">    &gt;&gt;&gt; dn[&#39;color_list&#39;]</span></div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral">    [&#39;c&#39;, &#39;m&#39;, &#39;m&#39;, &#39;k&#39;, &#39;k&#39;]</span></div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3001</span><span class="stringliteral">    Now, reset the color palette to its default:</span></div>
<div class="line"><span class="lineno"> 3002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3003</span><span class="stringliteral">    &gt;&gt;&gt; hierarchy.set_link_color_palette(None)</span></div>
<div class="line"><span class="lineno"> 3004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3005</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3006</span>    <span class="keywordflow">if</span> palette <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3007</span>        <span class="comment"># reset to its default</span></div>
<div class="line"><span class="lineno"> 3008</span>        palette = _link_line_colors_default</div>
<div class="line"><span class="lineno"> 3009</span>    <span class="keywordflow">elif</span> type(palette) <span class="keywordflow">not</span> <span class="keywordflow">in</span> (list, tuple):</div>
<div class="line"><span class="lineno"> 3010</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;palette must be a list or tuple&quot;</span>)</div>
<div class="line"><span class="lineno"> 3011</span>    _ptypes = [isinstance(p, str) <span class="keywordflow">for</span> p <span class="keywordflow">in</span> palette]</div>
<div class="line"><span class="lineno"> 3012</span> </div>
<div class="line"><span class="lineno"> 3013</span>    <span class="keywordflow">if</span> <span class="keyword">False</span> <span class="keywordflow">in</span> _ptypes:</div>
<div class="line"><span class="lineno"> 3014</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;all palette list elements must be color strings&quot;</span>)</div>
<div class="line"><span class="lineno"> 3015</span> </div>
<div class="line"><span class="lineno"> 3016</span>    <span class="keyword">global</span> _link_line_colors</div>
<div class="line"><span class="lineno"> 3017</span>    _link_line_colors = palette</div>
<div class="line"><span class="lineno"> 3018</span> </div>
<div class="line"><span class="lineno"> 3019</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d0362e93aa51d35d3895395af758fb5" name="a3d0362e93aa51d35d3895395af758fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0362e93aa51d35d3895395af758fb5">&#9670;&#160;</a></span>single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.single </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform single/min/nearest linkage on the condensed distance matrix ``y``.

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    The linkage matrix.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import single, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

First, we need a toy dataset to play with::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

Then, we get a condensed distance matrix from this dataset:

&gt;&gt;&gt; y = pdist(X)

Finally, we can perform the clustering:

&gt;&gt;&gt; Z = single(y)
&gt;&gt;&gt; Z
array([[ 0.,  1.,  1.,  2.],
       [ 2., 12.,  1.,  3.],
       [ 3.,  4.,  1.,  2.],
       [ 5., 14.,  1.,  3.],
       [ 6.,  7.,  1.,  2.],
       [ 8., 16.,  1.,  3.],
       [ 9., 10.,  1.,  2.],
       [11., 18.,  1.,  3.],
       [13., 15.,  2.,  6.],
       [17., 20.,  2.,  9.],
       [19., 21.,  2., 12.]])

The linkage matrix ``Z`` represents a dendrogram - see
`scipy.cluster.hierarchy.linkage` for a detailed explanation of its
contents.

We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster
each initial point would belong given a distance threshold:

&gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9, 10, 11, 12,  4,  5,  6,  1,  2,  3], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 1, criterion='distance')
array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 2, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a
plot of the dendrogram.
</pre> <div class="fragment"><div class="line"><span class="lineno">  207</span><span class="keyword">def </span>single(y):</div>
<div class="line"><span class="lineno">  208</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    Perform single/min/nearest linkage on the condensed distance matrix ``y``.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        The upper triangular of the distance matrix. The result of</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        ``pdist`` is returned in this form.</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        The linkage matrix.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    linkage : for advanced creation of hierarchical clusterings.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import single, fcluster</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    First, we need a toy dataset to play with::</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    Then, we get a condensed distance matrix from this dataset:</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    &gt;&gt;&gt; y = pdist(X)</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    Finally, we can perform the clustering:</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    &gt;&gt;&gt; Z = single(y)</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    array([[ 0.,  1.,  1.,  2.],</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">           [ 2., 12.,  1.,  3.],</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">           [ 3.,  4.,  1.,  2.],</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">           [ 5., 14.,  1.,  3.],</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">           [ 6.,  7.,  1.,  2.],</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">           [ 8., 16.,  1.,  3.],</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">           [ 9., 10.,  1.,  2.],</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">           [11., 18.,  1.,  3.],</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">           [13., 15.,  2.,  6.],</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">           [17., 20.,  2.,  9.],</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">           [19., 21.,  2., 12.]])</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram - see</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    contents.</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    each initial point would belong given a distance threshold:</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    array([ 7,  8,  9, 10, 11, 12,  4,  5,  6,  1,  2,  3], dtype=int32)</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 1, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 2, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    plot of the dendrogram.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  282</span>    <span class="keywordflow">return</span> linkage(y, method=<span class="stringliteral">&#39;single&#39;</span>, metric=<span class="stringliteral">&#39;euclidean&#39;</span>)</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1942cfccf61cbbb35cc817abc093d8a3" name="a1942cfccf61cbbb35cc817abc093d8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1942cfccf61cbbb35cc817abc093d8a3">&#9670;&#160;</a></span>to_mlab_linkage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.to_mlab_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a linkage matrix to a MATLAB(TM) compatible one.

Converts a linkage matrix ``Z`` generated by the linkage function
of this module to a MATLAB(TM) compatible one. The return linkage
matrix has the last column removed and the cluster indices are
converted to ``1..N`` indexing.

Parameters
----------
Z : ndarray
    A linkage matrix generated by ``scipy.cluster.hierarchy``.

Returns
-------
to_mlab_linkage : ndarray
    A linkage matrix compatible with MATLAB(TM)'s hierarchical
    clustering functions.

    The return linkage matrix has the last column removed
    and the cluster indices are converted to ``1..N`` indexing.

See Also
--------
linkage : for a description of what a linkage matrix is.
from_mlab_linkage : transform from Matlab to SciPy format.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, to_mlab_linkage
&gt;&gt;&gt; from scipy.spatial.distance import pdist

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

&gt;&gt;&gt; Z = ward(pdist(X))
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.29099445,  3.        ],
       [ 5.        , 13.        ,  1.29099445,  3.        ],
       [ 8.        , 14.        ,  1.29099445,  3.        ],
       [11.        , 15.        ,  1.29099445,  3.        ],
       [16.        , 17.        ,  5.77350269,  6.        ],
       [18.        , 19.        ,  5.77350269,  6.        ],
       [20.        , 21.        ,  8.16496581, 12.        ]])

After a linkage matrix ``Z`` has been created, we can use
`scipy.cluster.hierarchy.to_mlab_linkage` to convert it
into MATLAB format:

&gt;&gt;&gt; mZ = to_mlab_linkage(Z)
&gt;&gt;&gt; mZ
array([[  1.        ,   2.        ,   1.        ],
       [  4.        ,   5.        ,   1.        ],
       [  7.        ,   8.        ,   1.        ],
       [ 10.        ,  11.        ,   1.        ],
       [  3.        ,  13.        ,   1.29099445],
       [  6.        ,  14.        ,   1.29099445],
       [  9.        ,  15.        ,   1.29099445],
       [ 12.        ,  16.        ,   1.29099445],
       [ 17.        ,  18.        ,   5.77350269],
       [ 19.        ,  20.        ,   5.77350269],
       [ 21.        ,  22.        ,   8.16496581]])

The new linkage matrix ``mZ`` uses 1-indexing for all the
clusters (instead of 0-indexing). Also, the last column of
the original linkage matrix has been dropped.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1881</span><span class="keyword">def </span>to_mlab_linkage(Z):</div>
<div class="line"><span class="lineno"> 1882</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral">    Convert a linkage matrix to a MATLAB(TM) compatible one.</span></div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">    Converts a linkage matrix ``Z`` generated by the linkage function</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    of this module to a MATLAB(TM) compatible one. The return linkage</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral">    matrix has the last column removed and the cluster indices are</span></div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">    converted to ``1..N`` indexing.</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">        A linkage matrix generated by ``scipy.cluster.hierarchy``.</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    to_mlab_linkage : ndarray</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">        A linkage matrix compatible with MATLAB(TM)&#39;s hierarchical</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">        clustering functions.</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">        The return linkage matrix has the last column removed</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">        and the cluster indices are converted to ``1..N`` indexing.</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">    linkage : for a description of what a linkage matrix is.</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">    from_mlab_linkage : transform from Matlab to SciPy format.</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, to_mlab_linkage</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(pdist(X))</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">           [ 2.        , 12.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">           [ 5.        , 13.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral">           [ 8.        , 14.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">           [11.        , 15.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral">           [16.        , 17.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral">           [18.        , 19.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">           [20.        , 21.        ,  8.16496581, 12.        ]])</span></div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">    After a linkage matrix ``Z`` has been created, we can use</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral">    `scipy.cluster.hierarchy.to_mlab_linkage` to convert it</span></div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral">    into MATLAB format:</span></div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral">    &gt;&gt;&gt; mZ = to_mlab_linkage(Z)</span></div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral">    &gt;&gt;&gt; mZ</span></div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral">    array([[  1.        ,   2.        ,   1.        ],</span></div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral">           [  4.        ,   5.        ,   1.        ],</span></div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral">           [  7.        ,   8.        ,   1.        ],</span></div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">           [ 10.        ,  11.        ,   1.        ],</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">           [  3.        ,  13.        ,   1.29099445],</span></div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">           [  6.        ,  14.        ,   1.29099445],</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">           [  9.        ,  15.        ,   1.29099445],</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">           [ 12.        ,  16.        ,   1.29099445],</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">           [ 17.        ,  18.        ,   5.77350269],</span></div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral">           [ 19.        ,  20.        ,   5.77350269],</span></div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral">           [ 21.        ,  22.        ,   8.16496581]])</span></div>
<div class="line"><span class="lineno"> 1950</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1951</span><span class="stringliteral">    The new linkage matrix ``mZ`` uses 1-indexing for all the</span></div>
<div class="line"><span class="lineno"> 1952</span><span class="stringliteral">    clusters (instead of 0-indexing). Also, the last column of</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral">    the original linkage matrix has been dropped.</span></div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1956</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>, dtype=np.double)</div>
<div class="line"><span class="lineno"> 1957</span>    Zs = Z.shape</div>
<div class="line"><span class="lineno"> 1958</span>    <span class="keywordflow">if</span> len(Zs) == 0 <span class="keywordflow">or</span> (len(Zs) == 1 <span class="keywordflow">and</span> Zs[0] == 0):</div>
<div class="line"><span class="lineno"> 1959</span>        <span class="keywordflow">return</span> Z.copy()</div>
<div class="line"><span class="lineno"> 1960</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 1961</span> </div>
<div class="line"><span class="lineno"> 1962</span>    ZP = Z[:, 0:3].copy()</div>
<div class="line"><span class="lineno"> 1963</span>    ZP[:, 0:2] += 1.0</div>
<div class="line"><span class="lineno"> 1964</span> </div>
<div class="line"><span class="lineno"> 1965</span>    <span class="keywordflow">return</span> ZP</div>
<div class="line"><span class="lineno"> 1966</span> </div>
<div class="line"><span class="lineno"> 1967</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e082a477afec3634282c40bd9b17eeb" name="a2e082a477afec3634282c40bd9b17eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e082a477afec3634282c40bd9b17eeb">&#9670;&#160;</a></span>to_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.to_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rd</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a linkage matrix into an easy-to-use tree object.

The reference to the root `ClusterNode` object is returned (by default).

Each `ClusterNode` object has a ``left``, ``right``, ``dist``, ``id``,
and ``count`` attribute. The left and right attributes point to
ClusterNode objects that were combined to generate the cluster.
If both are None then the `ClusterNode` object is a leaf node, its count
must be 1, and its distance is meaningless but set to 0.

*Note: This function is provided for the convenience of the library
user. ClusterNodes are not used as input to any of the functions in this
library.*

Parameters
----------
Z : ndarray
    The linkage matrix in proper form (see the `linkage`
    function documentation).
rd : bool, optional
    When False (default), a reference to the root `ClusterNode` object is
    returned.  Otherwise, a tuple ``(r, d)`` is returned. ``r`` is a
    reference to the root node while ``d`` is a list of `ClusterNode`
    objects - one per original entry in the linkage matrix plus entries
    for all clustering steps. If a cluster id is
    less than the number of samples ``n`` in the data that the linkage
    matrix describes, then it corresponds to a singleton cluster (leaf
    node).
    See `linkage` for more information on the assignment of cluster ids
    to clusters.

Returns
-------
tree : ClusterNode or tuple (ClusterNode, list of ClusterNode)
    If ``rd`` is False, a `ClusterNode`.
    If ``rd`` is True, a list of length ``2*n - 1``, with ``n`` the number
    of samples.  See the description of `rd` above for more details.

See Also
--------
linkage, is_valid_linkage, ClusterNode

Examples
--------
&gt;&gt;&gt; from scipy.cluster import hierarchy
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = rng.random((5, 2))
&gt;&gt;&gt; Z = hierarchy.linkage(x)
&gt;&gt;&gt; hierarchy.to_tree(Z)
&lt;scipy.cluster.hierarchy.ClusterNode object at ...
&gt;&gt;&gt; rootnode, nodelist = hierarchy.to_tree(Z, rd=True)
&gt;&gt;&gt; rootnode
&lt;scipy.cluster.hierarchy.ClusterNode object at ...
&gt;&gt;&gt; len(nodelist)
9</pre> <div class="fragment"><div class="line"><span class="lineno"> 1400</span><span class="keyword">def </span>to_tree(Z, rd=False):</div>
<div class="line"><span class="lineno"> 1401</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    Convert a linkage matrix into an easy-to-use tree object.</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    The reference to the root `ClusterNode` object is returned (by default).</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">    Each `ClusterNode` object has a ``left``, ``right``, ``dist``, ``id``,</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    and ``count`` attribute. The left and right attributes point to</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    ClusterNode objects that were combined to generate the cluster.</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    If both are None then the `ClusterNode` object is a leaf node, its count</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    must be 1, and its distance is meaningless but set to 0.</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">    *Note: This function is provided for the convenience of the library</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    user. ClusterNodes are not used as input to any of the functions in this</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    library.*</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">        The linkage matrix in proper form (see the `linkage`</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">        function documentation).</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">    rd : bool, optional</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">        When False (default), a reference to the root `ClusterNode` object is</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">        returned.  Otherwise, a tuple ``(r, d)`` is returned. ``r`` is a</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">        reference to the root node while ``d`` is a list of `ClusterNode`</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">        objects - one per original entry in the linkage matrix plus entries</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">        for all clustering steps. If a cluster id is</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">        less than the number of samples ``n`` in the data that the linkage</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">        matrix describes, then it corresponds to a singleton cluster (leaf</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">        node).</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">        See `linkage` for more information on the assignment of cluster ids</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">        to clusters.</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    tree : ClusterNode or tuple (ClusterNode, list of ClusterNode)</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">        If ``rd`` is False, a `ClusterNode`.</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">        If ``rd`` is True, a list of length ``2*n - 1``, with ``n`` the number</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">        of samples.  See the description of `rd` above for more details.</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    linkage, is_valid_linkage, ClusterNode</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster import hierarchy</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.random((5, 2))</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">    &gt;&gt;&gt; Z = hierarchy.linkage(x)</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">    &gt;&gt;&gt; hierarchy.to_tree(Z)</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">    &lt;scipy.cluster.hierarchy.ClusterNode object at ...</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">    &gt;&gt;&gt; rootnode, nodelist = hierarchy.to_tree(Z, rd=True)</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    &gt;&gt;&gt; rootnode</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">    &lt;scipy.cluster.hierarchy.ClusterNode object at ...</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">    &gt;&gt;&gt; len(nodelist)</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">    9</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1459</span>    Z = np.asarray(Z, order=<span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno"> 1460</span>    is_valid_linkage(Z, throw=<span class="keyword">True</span>, name=<span class="stringliteral">&#39;Z&#39;</span>)</div>
<div class="line"><span class="lineno"> 1461</span> </div>
<div class="line"><span class="lineno"> 1462</span>    <span class="comment"># Number of original objects is equal to the number of rows plus 1.</span></div>
<div class="line"><span class="lineno"> 1463</span>    n = Z.shape[0] + 1</div>
<div class="line"><span class="lineno"> 1464</span> </div>
<div class="line"><span class="lineno"> 1465</span>    <span class="comment"># Create a list full of None&#39;s to store the node objects</span></div>
<div class="line"><span class="lineno"> 1466</span>    d = [<span class="keywordtype">None</span>] * (n * 2 - 1)</div>
<div class="line"><span class="lineno"> 1467</span> </div>
<div class="line"><span class="lineno"> 1468</span>    <span class="comment"># Create the nodes corresponding to the n original objects.</span></div>
<div class="line"><span class="lineno"> 1469</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, n):</div>
<div class="line"><span class="lineno"> 1470</span>        d[i] = ClusterNode(i)</div>
<div class="line"><span class="lineno"> 1471</span> </div>
<div class="line"><span class="lineno"> 1472</span>    nd = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1473</span> </div>
<div class="line"><span class="lineno"> 1474</span>    <span class="keywordflow">for</span> i, row <span class="keywordflow">in</span> enumerate(Z):</div>
<div class="line"><span class="lineno"> 1475</span>        fi = int(row[0])</div>
<div class="line"><span class="lineno"> 1476</span>        fj = int(row[1])</div>
<div class="line"><span class="lineno"> 1477</span>        <span class="keywordflow">if</span> fi &gt; i + n:</div>
<div class="line"><span class="lineno"> 1478</span>            <span class="keywordflow">raise</span> ValueError((<span class="stringliteral">&#39;Corrupt matrix Z. Index to derivative cluster &#39;</span></div>
<div class="line"><span class="lineno"> 1479</span>                              <span class="stringliteral">&#39;is used before it is formed. See row %d, &#39;</span></div>
<div class="line"><span class="lineno"> 1480</span>                              <span class="stringliteral">&#39;column 0&#39;</span>) % fi)</div>
<div class="line"><span class="lineno"> 1481</span>        <span class="keywordflow">if</span> fj &gt; i + n:</div>
<div class="line"><span class="lineno"> 1482</span>            <span class="keywordflow">raise</span> ValueError((<span class="stringliteral">&#39;Corrupt matrix Z. Index to derivative cluster &#39;</span></div>
<div class="line"><span class="lineno"> 1483</span>                              <span class="stringliteral">&#39;is used before it is formed. See row %d, &#39;</span></div>
<div class="line"><span class="lineno"> 1484</span>                              <span class="stringliteral">&#39;column 1&#39;</span>) % fj)</div>
<div class="line"><span class="lineno"> 1485</span> </div>
<div class="line"><span class="lineno"> 1486</span>        nd = ClusterNode(i + n, d[fi], d[fj], row[2])</div>
<div class="line"><span class="lineno"> 1487</span>        <span class="comment">#                ^ id   ^ left ^ right ^ dist</span></div>
<div class="line"><span class="lineno"> 1488</span>        <span class="keywordflow">if</span> row[3] != nd.count:</div>
<div class="line"><span class="lineno"> 1489</span>            <span class="keywordflow">raise</span> ValueError((<span class="stringliteral">&#39;Corrupt matrix Z. The count Z[%d,3] is &#39;</span></div>
<div class="line"><span class="lineno"> 1490</span>                              <span class="stringliteral">&#39;incorrect.&#39;</span>) % i)</div>
<div class="line"><span class="lineno"> 1491</span>        d[n + i] = nd</div>
<div class="line"><span class="lineno"> 1492</span> </div>
<div class="line"><span class="lineno"> 1493</span>    <span class="keywordflow">if</span> rd:</div>
<div class="line"><span class="lineno"> 1494</span>        <span class="keywordflow">return</span> (nd, d)</div>
<div class="line"><span class="lineno"> 1495</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1496</span>        <span class="keywordflow">return</span> nd</div>
<div class="line"><span class="lineno"> 1497</span> </div>
<div class="line"><span class="lineno"> 1498</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7226191ad03884e74134c8b8bde469ac" name="a7226191ad03884e74134c8b8bde469ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7226191ad03884e74134c8b8bde469ac">&#9670;&#160;</a></span>ward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.ward </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Ward's linkage on a condensed distance matrix.

See `linkage` for more information on the return structure
and algorithm.

The following are common calling conventions:

1. ``Z = ward(y)``
   Performs Ward's linkage on the condensed distance matrix ``y``.

2. ``Z = ward(X)``
   Performs Ward's linkage on the observation matrix ``X`` using
   Euclidean distance as the distance metric.

Parameters
----------
y : ndarray
    A condensed distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns.  Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    an m by n array.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix. See
    `linkage` for more information on the return structure and
    algorithm.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

First, we need a toy dataset to play with::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

Then, we get a condensed distance matrix from this dataset:

&gt;&gt;&gt; y = pdist(X)

Finally, we can perform the clustering:

&gt;&gt;&gt; Z = ward(y)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 9.        , 10.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.29099445,  3.        ],
       [ 5.        , 13.        ,  1.29099445,  3.        ],
       [ 8.        , 14.        ,  1.29099445,  3.        ],
       [11.        , 15.        ,  1.29099445,  3.        ],
       [16.        , 17.        ,  5.77350269,  6.        ],
       [18.        , 19.        ,  5.77350269,  6.        ],
       [20.        , 21.        ,  8.16496581, 12.        ]])

The linkage matrix ``Z`` represents a dendrogram - see
`scipy.cluster.hierarchy.linkage` for a detailed explanation of its
contents.

We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster
each initial point would belong given a distance threshold:

&gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 1.1, criterion='distance')
array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 3, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 9, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a
plot of the dendrogram.</pre> <div class="fragment"><div class="line"><span class="lineno">  738</span><span class="keyword">def </span>ward(y):</div>
<div class="line"><span class="lineno">  739</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    Perform Ward&#39;s linkage on a condensed distance matrix.</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    See `linkage` for more information on the return structure</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    and algorithm.</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    The following are common calling conventions:</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    1. ``Z = ward(y)``</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">       Performs Ward&#39;s linkage on the condensed distance matrix ``y``.</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    2. ``Z = ward(X)``</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">       Performs Ward&#39;s linkage on the observation matrix ``X`` using</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">       Euclidean distance as the distance metric.</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">        A condensed distance matrix. A condensed</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">        distance matrix is a flat array containing the upper</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        triangular of the distance matrix. This is the form that</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        ``pdist`` returns.  Alternatively, a collection of</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        m observation vectors in n dimensions may be passed as</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        an m by n array.</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        The hierarchical clustering encoded as a linkage matrix. See</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">        `linkage` for more information on the return structure and</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">        algorithm.</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    linkage : for advanced creation of hierarchical clusterings.</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    First, we need a toy dataset to play with::</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    Then, we get a condensed distance matrix from this dataset:</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    &gt;&gt;&gt; y = pdist(X)</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    Finally, we can perform the clustering:</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    &gt;&gt;&gt; Z = ward(y)</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">           [ 9.        , 10.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">           [ 2.        , 12.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">           [ 5.        , 13.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">           [ 8.        , 14.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">           [11.        , 15.        ,  1.29099445,  3.        ],</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">           [16.        , 17.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">           [18.        , 19.        ,  5.77350269,  6.        ],</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">           [20.        , 21.        ,  8.16496581, 12.        ]])</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram - see</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    contents.</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    each initial point would belong given a distance threshold:</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 1.1, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32)</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 3, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    plot of the dendrogram.</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  834</span>    <span class="keywordflow">return</span> linkage(y, method=<span class="stringliteral">&#39;ward&#39;</span>, metric=<span class="stringliteral">&#39;euclidean&#39;</span>)</div>
<div class="line"><span class="lineno">  835</span> </div>
<div class="line"><span class="lineno">  836</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad844fae87f47ad5e14f827080c2c1aca" name="ad844fae87f47ad5e14f827080c2c1aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad844fae87f47ad5e14f827080c2c1aca">&#9670;&#160;</a></span>weighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy.weighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform weighted/WPGMA linkage on the condensed distance matrix.

See `linkage` for more information on the return
structure and algorithm.

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    `linkage` for more information on its structure.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics

Examples
--------
&gt;&gt;&gt; from scipy.cluster.hierarchy import weighted, fcluster
&gt;&gt;&gt; from scipy.spatial.distance import pdist

First, we need a toy dataset to play with::

    x x    x x
    x        x

    x        x
    x x    x x

&gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]

Then, we get a condensed distance matrix from this dataset:

&gt;&gt;&gt; y = pdist(X)

Finally, we can perform the clustering:

&gt;&gt;&gt; Z = weighted(y)
&gt;&gt;&gt; Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
       [ 6.        ,  7.        ,  1.        ,  2.        ],
       [ 3.        ,  4.        ,  1.        ,  2.        ],
       [ 9.        , 11.        ,  1.        ,  2.        ],
       [ 2.        , 12.        ,  1.20710678,  3.        ],
       [ 8.        , 13.        ,  1.20710678,  3.        ],
       [ 5.        , 14.        ,  1.20710678,  3.        ],
       [10.        , 15.        ,  1.20710678,  3.        ],
       [18.        , 19.        ,  3.05595762,  6.        ],
       [16.        , 17.        ,  3.32379407,  6.        ],
       [20.        , 21.        ,  4.06357713, 12.        ]])

The linkage matrix ``Z`` represents a dendrogram - see
`scipy.cluster.hierarchy.linkage` for a detailed explanation of its
contents.

We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster
each initial point would belong given a distance threshold:

&gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9,  1,  2,  3, 10, 11, 12,  4,  6,  5], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 1.5, criterion='distance')
array([3, 3, 3, 1, 1, 1, 4, 4, 4, 2, 2, 2], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 4, criterion='distance')
array([2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1], dtype=int32)
&gt;&gt;&gt; fcluster(Z, 6, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)

Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a
plot of the dendrogram.</pre> <div class="fragment"><div class="line"><span class="lineno">  449</span><span class="keyword">def </span>weighted(y):</div>
<div class="line"><span class="lineno">  450</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    Perform weighted/WPGMA linkage on the condensed distance matrix.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    See `linkage` for more information on the return</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    structure and algorithm.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        The upper triangular of the distance matrix. The result of</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        ``pdist`` is returned in this form.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    Z : ndarray</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">        A linkage matrix containing the hierarchical clustering. See</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">        `linkage` for more information on its structure.</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    linkage : for advanced creation of hierarchical clusterings.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    scipy.spatial.distance.pdist : pairwise distance metrics</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.cluster.hierarchy import weighted, fcluster</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    First, we need a toy dataset to play with::</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        x        x</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        x x    x x</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0],</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    ...      [0, 4], [0, 3], [1, 4],</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    ...      [4, 0], [3, 0], [4, 1],</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    ...      [4, 4], [3, 4], [4, 3]]</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    Then, we get a condensed distance matrix from this dataset:</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    &gt;&gt;&gt; y = pdist(X)</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    Finally, we can perform the clustering:</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    &gt;&gt;&gt; Z = weighted(y)</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    &gt;&gt;&gt; Z</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    array([[ 0.        ,  1.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">           [ 6.        ,  7.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">           [ 3.        ,  4.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">           [ 9.        , 11.        ,  1.        ,  2.        ],</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">           [ 2.        , 12.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">           [ 8.        , 13.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">           [ 5.        , 14.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">           [10.        , 15.        ,  1.20710678,  3.        ],</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">           [18.        , 19.        ,  3.05595762,  6.        ],</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">           [16.        , 17.        ,  3.32379407,  6.        ],</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">           [20.        , 21.        ,  4.06357713, 12.        ]])</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    The linkage matrix ``Z`` represents a dendrogram - see</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    contents.</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    each initial point would belong given a distance threshold:</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 0.9, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    array([ 7,  8,  9,  1,  2,  3, 10, 11, 12,  4,  6,  5], dtype=int32)</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 1.5, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    array([3, 3, 3, 1, 1, 1, 4, 4, 4, 2, 2, 2], dtype=int32)</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 4, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    array([2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    &gt;&gt;&gt; fcluster(Z, 6, criterion=&#39;distance&#39;)</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    plot of the dendrogram.</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordflow">return</span> linkage(y, method=<span class="stringliteral">&#39;weighted&#39;</span>, metric=<span class="stringliteral">&#39;euclidean&#39;</span>)</div>
<div class="line"><span class="lineno">  532</span> </div>
<div class="line"><span class="lineno">  533</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a476e625a81650e28e32bad1ad24efcf5" name="a476e625a81650e28e32bad1ad24efcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476e625a81650e28e32bad1ad24efcf5">&#9670;&#160;</a></span>_cnode_bare</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._cnode_bare = <a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1_cluster_node.html">ClusterNode</a>(0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7e6ed2ee8c7d83e9da01009dda7f74f" name="ac7e6ed2ee8c7d83e9da01009dda7f74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e6ed2ee8c7d83e9da01009dda7f74f">&#9670;&#160;</a></span>_cnode_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._cnode_type = type(<a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1_cluster_node.html">ClusterNode</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabfa197c9179db51284830913704f0f0" name="aabfa197c9179db51284830913704f0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfa197c9179db51284830913704f0f0">&#9670;&#160;</a></span>_drotation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.cluster.hierarchy._drotation = {20: 0, 40: 45, np.inf: 90}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a551341c8e94ec8af794985291c716354" name="a551341c8e94ec8af794985291c716354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551341c8e94ec8af794985291c716354">&#9670;&#160;</a></span>_drotationsortedkeys</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._drotationsortedkeys = list(_drotation.keys())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4486feb3a97520b8ac29af1c2690cd49" name="a4486feb3a97520b8ac29af1c2690cd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4486feb3a97520b8ac29af1c2690cd49">&#9670;&#160;</a></span>_dtextsizes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.cluster.hierarchy._dtextsizes = {20: 12, 30: 10, 50: 8, 85: 6, np.inf: 5}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e8615ce50b660d4fa36d168af87d88a" name="a2e8615ce50b660d4fa36d168af87d88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8615ce50b660d4fa36d168af87d88a">&#9670;&#160;</a></span>_dtextsortedkeys</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._dtextsortedkeys = list(_dtextsizes.keys())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ada639f32b594e8883367025e3f516c" name="a3ada639f32b594e8883367025e3f516c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ada639f32b594e8883367025e3f516c">&#9670;&#160;</a></span>_EUCLIDEAN_METHODS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.cluster.hierarchy._EUCLIDEAN_METHODS = ('<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#af078eaaf796754567d1ee58eac815eff">centroid</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a60b4c53f5b1aa19afe45b628dcaf6840">median</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a7226191ad03884e74134c8b8bde469ac">ward</a>')</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad943f16bba4262efdbd2ad1fe630c067" name="ad943f16bba4262efdbd2ad1fe630c067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad943f16bba4262efdbd2ad1fe630c067">&#9670;&#160;</a></span>_link_line_colors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.cluster.hierarchy._link_line_colors = list(<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aacfd11a02024f4440c25556201566cb0">_link_line_colors_default</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aacfd11a02024f4440c25556201566cb0" name="aacfd11a02024f4440c25556201566cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfd11a02024f4440c25556201566cb0">&#9670;&#160;</a></span>_link_line_colors_default</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.cluster.hierarchy._link_line_colors_default = ('C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9')</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a826723dda7579a0811e9dd6a6fac3259" name="a826723dda7579a0811e9dd6a6fac3259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826723dda7579a0811e9dd6a6fac3259">&#9670;&#160;</a></span>_LINKAGE_METHODS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.cluster.hierarchy._LINKAGE_METHODS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {<span class="stringliteral">&#39;single&#39;</span>: 0, <span class="stringliteral">&#39;complete&#39;</span>: 1, <span class="stringliteral">&#39;average&#39;</span>: 2, <span class="stringliteral">&#39;centroid&#39;</span>: 3,</div>
<div class="line"><span class="lineno">    2</span>                    <span class="stringliteral">&#39;median&#39;</span>: 4, <span class="stringliteral">&#39;ward&#39;</span>: 5, <span class="stringliteral">&#39;weighted&#39;</span>: 6}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
