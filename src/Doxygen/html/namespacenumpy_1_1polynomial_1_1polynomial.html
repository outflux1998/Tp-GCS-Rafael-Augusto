<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.polynomial.polynomial Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1polynomial.html">polynomial</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html">polynomial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.polynomial.polynomial Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1polynomial_1_1polynomial_1_1_polynomial.html">Polynomial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae918ad4af8515648d5d4aab5dddf0d55" id="r_ae918ad4af8515648d5d4aab5dddf0d55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#ae918ad4af8515648d5d4aab5dddf0d55">polyline</a> (off, scl)</td></tr>
<tr class="separator:ae918ad4af8515648d5d4aab5dddf0d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a0bddca583334f657830d8dd513f36" id="r_a29a0bddca583334f657830d8dd513f36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a29a0bddca583334f657830d8dd513f36">polyfromroots</a> (<a class="el" href="namespacenumpy_1_1lib_1_1polynomial.html#a2b778895ac343811f977274be7932815">roots</a>)</td></tr>
<tr class="separator:a29a0bddca583334f657830d8dd513f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24499152556afdb9bb8ecabafa47748" id="r_ac24499152556afdb9bb8ecabafa47748"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#ac24499152556afdb9bb8ecabafa47748">polyadd</a> (c1, c2)</td></tr>
<tr class="separator:ac24499152556afdb9bb8ecabafa47748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a52aa247003715189181dbc5cca1ba" id="r_a27a52aa247003715189181dbc5cca1ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a27a52aa247003715189181dbc5cca1ba">polysub</a> (c1, c2)</td></tr>
<tr class="separator:a27a52aa247003715189181dbc5cca1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5245c48d904bbbe3fdf11f0da9ea7c" id="r_a1c5245c48d904bbbe3fdf11f0da9ea7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a1c5245c48d904bbbe3fdf11f0da9ea7c">polymulx</a> (c)</td></tr>
<tr class="separator:a1c5245c48d904bbbe3fdf11f0da9ea7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eae7956d8adccdea88a022b1377a788" id="r_a9eae7956d8adccdea88a022b1377a788"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a9eae7956d8adccdea88a022b1377a788">polymul</a> (c1, c2)</td></tr>
<tr class="separator:a9eae7956d8adccdea88a022b1377a788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d699e58f111c1cf8f131b145c92101" id="r_aa3d699e58f111c1cf8f131b145c92101"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#aa3d699e58f111c1cf8f131b145c92101">polydiv</a> (c1, c2)</td></tr>
<tr class="separator:aa3d699e58f111c1cf8f131b145c92101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7346f5d7618fd9d086d66c1cb74b6386" id="r_a7346f5d7618fd9d086d66c1cb74b6386"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a7346f5d7618fd9d086d66c1cb74b6386">polypow</a> (c, pow, maxpower=None)</td></tr>
<tr class="separator:a7346f5d7618fd9d086d66c1cb74b6386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e713b1481c20598277695ce6116c8f5" id="r_a2e713b1481c20598277695ce6116c8f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a2e713b1481c20598277695ce6116c8f5">polyder</a> (c, m=1, scl=1, axis=0)</td></tr>
<tr class="separator:a2e713b1481c20598277695ce6116c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae925c9505594a28d957813e32a3f8d94" id="r_ae925c9505594a28d957813e32a3f8d94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#ae925c9505594a28d957813e32a3f8d94">polyint</a> (c, m=1, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a487d35c8a6e2a81ebb15722142c54b9c">k</a>=[], lbnd=0, scl=1, axis=0)</td></tr>
<tr class="separator:ae925c9505594a28d957813e32a3f8d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af96090a5a020c74c2cf0ce6b5fd364" id="r_a5af96090a5a020c74c2cf0ce6b5fd364"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a5af96090a5a020c74c2cf0ce6b5fd364">polyval</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, c, tensor=True)</td></tr>
<tr class="separator:a5af96090a5a020c74c2cf0ce6b5fd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015e926b0b4a06a4eee5cc075107bbff" id="r_a015e926b0b4a06a4eee5cc075107bbff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a015e926b0b4a06a4eee5cc075107bbff">polyvalfromroots</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, tensor=True)</td></tr>
<tr class="separator:a015e926b0b4a06a4eee5cc075107bbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28517914a28dc42082e2d31a658cbbca" id="r_a28517914a28dc42082e2d31a658cbbca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a28517914a28dc42082e2d31a658cbbca">polyval2d</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y, c)</td></tr>
<tr class="separator:a28517914a28dc42082e2d31a658cbbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75ffd3c6cf7232b651d2ec60a12496c" id="r_ab75ffd3c6cf7232b651d2ec60a12496c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#ab75ffd3c6cf7232b651d2ec60a12496c">polygrid2d</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y, c)</td></tr>
<tr class="separator:ab75ffd3c6cf7232b651d2ec60a12496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f13e2c875f4bedb6af03d3bdd4c6a2c" id="r_a3f13e2c875f4bedb6af03d3bdd4c6a2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a3f13e2c875f4bedb6af03d3bdd4c6a2c">polyval3d</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y, <a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>, c)</td></tr>
<tr class="separator:a3f13e2c875f4bedb6af03d3bdd4c6a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b582c07963d40c5241ef870cf5a6f7b" id="r_a5b582c07963d40c5241ef870cf5a6f7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a5b582c07963d40c5241ef870cf5a6f7b">polygrid3d</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y, <a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>, c)</td></tr>
<tr class="separator:a5b582c07963d40c5241ef870cf5a6f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdff790ca3c6465134664fb38c32388d" id="r_acdff790ca3c6465134664fb38c32388d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#acdff790ca3c6465134664fb38c32388d">polyvander</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, deg)</td></tr>
<tr class="separator:acdff790ca3c6465134664fb38c32388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb2c7c2d8c80c9c49960d0844c02992" id="r_afbb2c7c2d8c80c9c49960d0844c02992"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#afbb2c7c2d8c80c9c49960d0844c02992">polyvander2d</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y, deg)</td></tr>
<tr class="separator:afbb2c7c2d8c80c9c49960d0844c02992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a9cf88eb62e6b71d0b57595c287585" id="r_a75a9cf88eb62e6b71d0b57595c287585"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a75a9cf88eb62e6b71d0b57595c287585">polyvander3d</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y, <a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>, deg)</td></tr>
<tr class="separator:a75a9cf88eb62e6b71d0b57595c287585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b36c13a422b50bf194c46022946fff1" id="r_a0b36c13a422b50bf194c46022946fff1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a0b36c13a422b50bf194c46022946fff1">polyfit</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y, deg, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=None, <a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a3656c4a5c2415c4f34d68f47b532c5fa">full</a>=False, <a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>=None)</td></tr>
<tr class="separator:a0b36c13a422b50bf194c46022946fff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f09db33678e71abd57965cb6a24898" id="r_a16f09db33678e71abd57965cb6a24898"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a16f09db33678e71abd57965cb6a24898">polycompanion</a> (c)</td></tr>
<tr class="separator:a16f09db33678e71abd57965cb6a24898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3c07debc947d63e4e61e87e4dd82e" id="r_a00c3c07debc947d63e4e61e87e4dd82e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a00c3c07debc947d63e4e61e87e4dd82e">polyroots</a> (c)</td></tr>
<tr class="separator:a00c3c07debc947d63e4e61e87e4dd82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2de664e1f9c270594965d9743950e741" id="r_a2de664e1f9c270594965d9743950e741"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a2de664e1f9c270594965d9743950e741">polytrim</a> = pu.trimcoef</td></tr>
<tr class="separator:a2de664e1f9c270594965d9743950e741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a119d1b65932bf329ae2b46feb15f91" id="r_a7a119d1b65932bf329ae2b46feb15f91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a7a119d1b65932bf329ae2b46feb15f91">polydomain</a> = np.array([-1, 1])</td></tr>
<tr class="separator:a7a119d1b65932bf329ae2b46feb15f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bf919463839420cc8515680877978f" id="r_aa3bf919463839420cc8515680877978f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#aa3bf919463839420cc8515680877978f">polyzero</a> = np.array([0])</td></tr>
<tr class="separator:aa3bf919463839420cc8515680877978f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38838de0ae95dbf53f57e27bab6785a6" id="r_a38838de0ae95dbf53f57e27bab6785a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a38838de0ae95dbf53f57e27bab6785a6">polyone</a> = np.array([1])</td></tr>
<tr class="separator:a38838de0ae95dbf53f57e27bab6785a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2471daff3218186409ae1bffea4d922d" id="r_a2471daff3218186409ae1bffea4d922d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1polynomial_1_1polynomial.html#a2471daff3218186409ae1bffea4d922d">polyx</a> = np.array([0, 1])</td></tr>
<tr class="separator:a2471daff3218186409ae1bffea4d922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">=================================================
Power Series (:mod:`numpy.polynomial.polynomial`)
=================================================

This module provides a number of objects (mostly functions) useful for
dealing with polynomials, including a `Polynomial` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with polynomial objects is in
the docstring for its "parent" sub-package, `numpy.polynomial`).

Classes
-------
.. autosummary::
   :toctree: generated/

   Polynomial

Constants
---------
.. autosummary::
   :toctree: generated/

   polydomain
   polyzero
   polyone
   polyx

Arithmetic
----------
.. autosummary::
   :toctree: generated/

   polyadd
   polysub
   polymulx
   polymul
   polydiv
   polypow
   polyval
   polyval2d
   polyval3d
   polygrid2d
   polygrid3d

Calculus
--------
.. autosummary::
   :toctree: generated/

   polyder
   polyint

Misc Functions
--------------
.. autosummary::
   :toctree: generated/

   polyfromroots
   polyroots
   polyvalfromroots
   polyvander
   polyvander2d
   polyvander3d
   polycompanion
   polyfit
   polytrim
   polyline

See Also
--------
`numpy.polynomial`</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ac24499152556afdb9bb8ecabafa47748" name="ac24499152556afdb9bb8ecabafa47748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24499152556afdb9bb8ecabafa47748">&#9670;&#160;</a></span>polyadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyadd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add one polynomial to another.

Returns the sum of two polynomials `c1` + `c2`.  The arguments are
sequences of coefficients from lowest order term to highest, i.e.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to high.

Returns
-------
out : ndarray
    The coefficient array representing their sum.

See Also
--------
polysub, polymulx, polymul, polydiv, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; sum = P.polyadd(c1,c2); sum
array([4.,  4.,  4.])
&gt;&gt;&gt; P.polyval(2, sum) # 4 + 4(2) + 4(2**2)
28.0</pre> <div class="fragment"><div class="line"><span class="lineno">  215</span><span class="keyword">def </span>polyadd(c1, c2):</div>
<div class="line"><span class="lineno">  216</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    Add one polynomial to another.</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    Returns the sum of two polynomials `c1` + `c2`.  The arguments are</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    sequences of coefficients from lowest order term to highest, i.e.,</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    c1, c2 : array_like</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        1-D arrays of polynomial coefficients ordered from low to high.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        The coefficient array representing their sum.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    polysub, polymulx, polymul, polydiv, polypow</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    &gt;&gt;&gt; c1 = (1,2,3)</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    &gt;&gt;&gt; c2 = (3,2,1)</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    &gt;&gt;&gt; sum = P.polyadd(c1,c2); sum</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    array([4.,  4.,  4.])</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    &gt;&gt;&gt; P.polyval(2, sum) # 4 + 4(2) + 4(2**2)</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    28.0</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">return</span> pu._add(c1, c2)</div>
<div class="line"><span class="lineno">  249</span> </div>
<div class="line"><span class="lineno">  250</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a16f09db33678e71abd57965cb6a24898" name="a16f09db33678e71abd57965cb6a24898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f09db33678e71abd57965cb6a24898">&#9670;&#160;</a></span>polycompanion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polycompanion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the companion matrix of c.

The companion matrix for power series cannot be made symmetric by
scaling the basis, so this function differs from those for the
orthogonal polynomials.

Parameters
----------
c : array_like
    1-D array of polynomial coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 1365</span><span class="keyword">def </span>polycompanion(c):</div>
<div class="line"><span class="lineno"> 1366</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    Return the companion matrix of c.</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    The companion matrix for power series cannot be made symmetric by</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    scaling the basis, so this function differs from those for the</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    orthogonal polynomials.</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">        1-D array of polynomial coefficients ordered from low to high</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">        degree.</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    mat : ndarray</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">        Companion matrix of dimensions (deg, deg).</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1390</span>    <span class="comment"># c is a trimmed copy</span></div>
<div class="line"><span class="lineno"> 1391</span>    [c] = pu.as_series([c])</div>
<div class="line"><span class="lineno"> 1392</span>    <span class="keywordflow">if</span> len(c) &lt; 2:</div>
<div class="line"><span class="lineno"> 1393</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Series must have maximum degree of at least 1.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1394</span>    <span class="keywordflow">if</span> len(c) == 2:</div>
<div class="line"><span class="lineno"> 1395</span>        <span class="keywordflow">return</span> np.array([[-c[0]/c[1]]])</div>
<div class="line"><span class="lineno"> 1396</span> </div>
<div class="line"><span class="lineno"> 1397</span>    n = len(c) - 1</div>
<div class="line"><span class="lineno"> 1398</span>    mat = np.zeros((n, n), dtype=c.dtype)</div>
<div class="line"><span class="lineno"> 1399</span>    bot = mat.reshape(-1)[n::n+1]</div>
<div class="line"><span class="lineno"> 1400</span>    bot[...] = 1</div>
<div class="line"><span class="lineno"> 1401</span>    mat[:, -1] -= c[:-1]/c[-1]</div>
<div class="line"><span class="lineno"> 1402</span>    <span class="keywordflow">return</span> mat</div>
<div class="line"><span class="lineno"> 1403</span> </div>
<div class="line"><span class="lineno"> 1404</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e713b1481c20598277695ce6116c8f5" name="a2e713b1481c20598277695ce6116c8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e713b1481c20598277695ce6116c8f5">&#9670;&#160;</a></span>polyder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scl</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Differentiate a polynomial.

Returns the polynomial coefficients `c` differentiated `m` times along
`axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable).  The
argument `c` is an array of coefficients from low to high degree along
each axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``
while [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is
``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of polynomial coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree
    in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change
    of variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Polynomial coefficients of the derivative.

See Also
--------
polyint

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3
&gt;&gt;&gt; P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2
array([  2.,   6.,  12.])
&gt;&gt;&gt; P.polyder(c,3) # (d**3/dx**3)(c) = 24
array([24.])
&gt;&gt;&gt; P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2
array([ -2.,  -6., -12.])
&gt;&gt;&gt; P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x
array([  6.,  24.])</pre> <div class="fragment"><div class="line"><span class="lineno">  463</span><span class="keyword">def </span>polyder(c, m=1, scl=1, axis=0):</div>
<div class="line"><span class="lineno">  464</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    Differentiate a polynomial.</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    Returns the polynomial coefficients `c` differentiated `m` times along</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    `axis`.  At each iteration the result is multiplied by `scl` (the</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    scaling factor is for use in a linear change of variable).  The</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    argument `c` is an array of coefficients from low to high degree along</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    each axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    while [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    ``x`` and axis=1 is ``y``.</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        Array of polynomial coefficients. If c is multidimensional the</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        different axis correspond to different variables with the degree</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        in each axis given by the corresponding index.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    m : int, optional</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        Number of derivatives taken, must be non-negative. (Default: 1)</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    scl : scalar, optional</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        Each differentiation is multiplied by `scl`.  The end result is</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        multiplication by ``scl**m``.  This is for use in a linear change</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        of variable. (Default: 1)</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        Axis over which the derivative is taken. (Default: 0).</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    der : ndarray</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">        Polynomial coefficients of the derivative.</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    polyint</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    &gt;&gt;&gt; c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    &gt;&gt;&gt; P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    array([  2.,   6.,  12.])</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    &gt;&gt;&gt; P.polyder(c,3) # (d**3/dx**3)(c) = 24</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    array([24.])</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &gt;&gt;&gt; P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    array([ -2.,  -6., -12.])</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    &gt;&gt;&gt; P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    array([  6.,  24.])</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  515</span>    c = np.array(c, ndmin=1, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">if</span> c.dtype.char <span class="keywordflow">in</span> <span class="stringliteral">&#39;?bBhHiIlLqQpP&#39;</span>:</div>
<div class="line"><span class="lineno">  517</span>        <span class="comment"># astype fails with NA</span></div>
<div class="line"><span class="lineno">  518</span>        c = c + 0.0</div>
<div class="line"><span class="lineno">  519</span>    cdt = c.dtype</div>
<div class="line"><span class="lineno">  520</span>    cnt = pu._deprecate_as_int(m, <span class="stringliteral">&quot;the order of derivation&quot;</span>)</div>
<div class="line"><span class="lineno">  521</span>    iaxis = pu._deprecate_as_int(axis, <span class="stringliteral">&quot;the axis&quot;</span>)</div>
<div class="line"><span class="lineno">  522</span>    <span class="keywordflow">if</span> cnt &lt; 0:</div>
<div class="line"><span class="lineno">  523</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The order of derivation must be non-negative&quot;</span>)</div>
<div class="line"><span class="lineno">  524</span>    iaxis = normalize_axis_index(iaxis, c.ndim)</div>
<div class="line"><span class="lineno">  525</span> </div>
<div class="line"><span class="lineno">  526</span>    <span class="keywordflow">if</span> cnt == 0:</div>
<div class="line"><span class="lineno">  527</span>        <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>    c = np.moveaxis(c, iaxis, 0)</div>
<div class="line"><span class="lineno">  530</span>    n = len(c)</div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordflow">if</span> cnt &gt;= n:</div>
<div class="line"><span class="lineno">  532</span>        c = c[:1]*0</div>
<div class="line"><span class="lineno">  533</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  534</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(cnt):</div>
<div class="line"><span class="lineno">  535</span>            n = n - 1</div>
<div class="line"><span class="lineno">  536</span>            c *= scl</div>
<div class="line"><span class="lineno">  537</span>            der = np.empty((n,) + c.shape[1:], dtype=cdt)</div>
<div class="line"><span class="lineno">  538</span>            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(n, 0, -1):</div>
<div class="line"><span class="lineno">  539</span>                der[j - 1] = j*c[j]</div>
<div class="line"><span class="lineno">  540</span>            c = der</div>
<div class="line"><span class="lineno">  541</span>    c = np.moveaxis(c, 0, iaxis)</div>
<div class="line"><span class="lineno">  542</span>    <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  544</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3d699e58f111c1cf8f131b145c92101" name="aa3d699e58f111c1cf8f131b145c92101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d699e58f111c1cf8f131b145c92101">&#9670;&#160;</a></span>polydiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polydiv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Divide one polynomial by another.

Returns the quotient-with-remainder of two polynomials `c1` / `c2`.
The arguments are sequences of coefficients, from lowest order term
to highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to high.

Returns
-------
[quo, rem] : ndarrays
    Of coefficient series representing the quotient and remainder.

See Also
--------
polyadd, polysub, polymulx, polymul, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; P.polydiv(c1,c2)
(array([3.]), array([-8., -4.]))
&gt;&gt;&gt; P.polydiv(c2,c1)
(array([ 0.33333333]), array([ 2.66666667,  1.33333333])) # may vary</pre> <div class="fragment"><div class="line"><span class="lineno">  366</span><span class="keyword">def </span>polydiv(c1, c2):</div>
<div class="line"><span class="lineno">  367</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    Divide one polynomial by another.</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    Returns the quotient-with-remainder of two polynomials `c1` / `c2`.</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    The arguments are sequences of coefficients, from lowest order term</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    to highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``.</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    c1, c2 : array_like</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        1-D arrays of polynomial coefficients ordered from low to high.</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    [quo, rem] : ndarrays</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">        Of coefficient series representing the quotient and remainder.</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    polyadd, polysub, polymulx, polymul, polypow</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    &gt;&gt;&gt; c1 = (1,2,3)</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    &gt;&gt;&gt; c2 = (3,2,1)</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    &gt;&gt;&gt; P.polydiv(c1,c2)</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    (array([3.]), array([-8., -4.]))</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    &gt;&gt;&gt; P.polydiv(c2,c1)</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    (array([ 0.33333333]), array([ 2.66666667,  1.33333333])) # may vary</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  399</span>    <span class="comment"># c1, c2 are trimmed copies</span></div>
<div class="line"><span class="lineno">  400</span>    [c1, c2] = pu.as_series([c1, c2])</div>
<div class="line"><span class="lineno">  401</span>    <span class="keywordflow">if</span> c2[-1] == 0:</div>
<div class="line"><span class="lineno">  402</span>        <span class="keywordflow">raise</span> ZeroDivisionError()</div>
<div class="line"><span class="lineno">  403</span> </div>
<div class="line"><span class="lineno">  404</span>    <span class="comment"># note: this is more efficient than `pu._div(polymul, c1, c2)`</span></div>
<div class="line"><span class="lineno">  405</span>    lc1 = len(c1)</div>
<div class="line"><span class="lineno">  406</span>    lc2 = len(c2)</div>
<div class="line"><span class="lineno">  407</span>    <span class="keywordflow">if</span> lc1 &lt; lc2:</div>
<div class="line"><span class="lineno">  408</span>        <span class="keywordflow">return</span> c1[:1]*0, c1</div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">elif</span> lc2 == 1:</div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">return</span> c1/c2[-1], c1[:1]*0</div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  412</span>        dlen = lc1 - lc2</div>
<div class="line"><span class="lineno">  413</span>        scl = c2[-1]</div>
<div class="line"><span class="lineno">  414</span>        c2 = c2[:-1]/scl</div>
<div class="line"><span class="lineno">  415</span>        i = dlen</div>
<div class="line"><span class="lineno">  416</span>        j = lc1 - 1</div>
<div class="line"><span class="lineno">  417</span>        <span class="keywordflow">while</span> i &gt;= 0:</div>
<div class="line"><span class="lineno">  418</span>            c1[i:j] -= c2*c1[j]</div>
<div class="line"><span class="lineno">  419</span>            i -= 1</div>
<div class="line"><span class="lineno">  420</span>            j -= 1</div>
<div class="line"><span class="lineno">  421</span>        <span class="keywordflow">return</span> c1[j+1:]/scl, pu.trimseq(c1[:j+1])</div>
<div class="line"><span class="lineno">  422</span> </div>
<div class="line"><span class="lineno">  423</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b36c13a422b50bf194c46022946fff1" name="a0b36c13a422b50bf194c46022946fff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b36c13a422b50bf194c46022946fff1">&#9670;&#160;</a></span>polyfit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyfit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Least-squares fit of a polynomial to data.

Return the coefficients of a polynomial of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n,

where `n` is `deg`.

Parameters
----------
x : array_like, shape (`M`,)
    x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.
y : array_like, shape (`M`,) or (`M`, `K`)
    y-coordinates of the sample points.  Several sets of sample points
    sharing the same x-coordinates can be (independently) fit with one
    call to `polyfit` by passing in for `y` a 2-D array that contains
    one data set per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit.  Singular values smaller
    than `rcond`, relative to the largest singular value, will be
    ignored.  The default value is ``len(x)*eps``, where `eps` is the
    relative precision of the platform's float type, about 2e-16 in
    most cases.
full : bool, optional
    Switch determining the nature of the return value.  When ``False``
    (the default) just the coefficients are returned; when ``True``,
    diagnostic information from the singular value decomposition (used
    to solve the fit's matrix equation) is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the weight ``w[i]`` applies to the unsquared
    residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are
    chosen so that the errors of the products ``w[i]*y[i]`` all have the
    same variance.  When using inverse-variance weighting, use
    ``w[i] = 1/sigma(y[i])``.  The default value is None.

    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`)
    Polynomial coefficients ordered from low to high.  If `y` was 2-D,
    the coefficients in column `k` of `coef` represent the polynomial
    fit to the data in `y`'s `k`-th column.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if ``full == True``

    - residuals -- sum of squared residuals of the least squares fit
    - rank -- the numerical rank of the scaled Vandermonde matrix
    - singular_values -- singular values of the scaled Vandermonde matrix
    - rcond -- value of `rcond`.

    For more details, see `numpy.linalg.lstsq`.

Raises
------
RankWarning
    Raised if the matrix in the least-squares fit is rank deficient.
    The warning is only raised if ``full == False``.  The warnings can
    be turned off by:

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
numpy.polynomial.chebyshev.chebfit
numpy.polynomial.legendre.legfit
numpy.polynomial.laguerre.lagfit
numpy.polynomial.hermite.hermfit
numpy.polynomial.hermite_e.hermefit
polyval : Evaluates a polynomial.
polyvander : Vandermonde matrix for powers.
numpy.linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the polynomial `p` that minimizes
the sum of the weighted squared errors

.. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) over-determined matrix equation:

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected (and `full` == ``False``), a `RankWarning` will be raised.
This means that the coefficient values may be poorly determined.
Fitting to a lower order polynomial will usually get rid of the warning
(but may not be what you want, of course; if you have independent
reason(s) for choosing the degree which isn't working, you may have to:
a) reconsider those reasons, and/or b) reconsider the quality of your
data).  The `rcond` parameter can also be set to a value smaller than
its default, but the resulting fit may be spurious and have large
contributions from roundoff error.

Polynomial fits using double precision tend to "fail" at about
(polynomial) degree 20. Fits using Chebyshev or Legendre series are
generally better conditioned, but much can still depend on the
distribution of the sample points and the smoothness of the data.  If
the quality of the fit is inadequate, splines may be a good
alternative.

Examples
--------
&gt;&gt;&gt; np.random.seed(123)
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; x = np.linspace(-1,1,51) # x "data": [-1, -0.96, ..., 0.96, 1]
&gt;&gt;&gt; y = x**3 - x + np.random.randn(len(x))  # x^3 - x + Gaussian noise
&gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)
&gt;&gt;&gt; np.random.seed(123)
&gt;&gt;&gt; c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1
array([ 0.01909725, -1.30598256, -0.00577963,  1.02644286]) # may vary
&gt;&gt;&gt; stats # note the large SSR, explaining the rather poor results
 [array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316, # may vary
          0.28853036]), 1.1324274851176597e-014]

Same thing without the added noise

&gt;&gt;&gt; y = x**3 - x
&gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)
&gt;&gt;&gt; c # c[0], c[2] should be "very close to 0", c[1] ~= -1, c[3] ~= 1
array([-6.36925336e-18, -1.00000000e+00, -4.08053781e-16,  1.00000000e+00])
&gt;&gt;&gt; stats # note the minuscule SSR
[array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158, # may vary
           0.50443316,  0.28853036]), 1.1324274851176597e-014]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1214</span><span class="keyword">def </span>polyfit(x, y, deg, rcond=None, full=False, w=None):</div>
<div class="line"><span class="lineno"> 1215</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    Least-squares fit of a polynomial to data.</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    Return the coefficients of a polynomial of degree `deg` that is the</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    least squares fit to the data values `y` given at points `x`. If `y` is</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">    fits are done, one for each column of `y`, and the resulting</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">    coefficients are stored in the corresponding columns of a 2-D return.</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">    The fitted polynomial(s) are in the form</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">    .. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n,</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    where `n` is `deg`.</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">    x : array_like, shape (`M`,)</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">        x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">    y : array_like, shape (`M`,) or (`M`, `K`)</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">        y-coordinates of the sample points.  Several sets of sample points</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">        sharing the same x-coordinates can be (independently) fit with one</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">        call to `polyfit` by passing in for `y` a 2-D array that contains</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">        one data set per column.</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    deg : int or 1-D array_like</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">        Degree(s) of the fitting polynomials. If `deg` is a single integer</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">        all terms up to and including the `deg`&#39;th term are included in the</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">        fit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">        degrees of the terms to include may be used instead.</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">    rcond : float, optional</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">        Relative condition number of the fit.  Singular values smaller</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">        than `rcond`, relative to the largest singular value, will be</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">        ignored.  The default value is ``len(x)*eps``, where `eps` is the</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">        relative precision of the platform&#39;s float type, about 2e-16 in</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">        most cases.</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    full : bool, optional</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">        Switch determining the nature of the return value.  When ``False``</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">        (the default) just the coefficients are returned; when ``True``,</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">        diagnostic information from the singular value decomposition (used</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">        to solve the fit&#39;s matrix equation) is also returned.</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    w : array_like, shape (`M`,), optional</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">        Weights. If not None, the weight ``w[i]`` applies to the unsquared</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">        residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">        chosen so that the errors of the products ``w[i]*y[i]`` all have the</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">        same variance.  When using inverse-variance weighting, use</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">        ``w[i] = 1/sigma(y[i])``.  The default value is None.</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">        .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">    coef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`)</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">        Polynomial coefficients ordered from low to high.  If `y` was 2-D,</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        the coefficients in column `k` of `coef` represent the polynomial</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">        fit to the data in `y`&#39;s `k`-th column.</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    [residuals, rank, singular_values, rcond] : list</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">        These values are only returned if ``full == True``</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">        - residuals -- sum of squared residuals of the least squares fit</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">        - rank -- the numerical rank of the scaled Vandermonde matrix</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">        - singular_values -- singular values of the scaled Vandermonde matrix</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">        - rcond -- value of `rcond`.</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">        For more details, see `numpy.linalg.lstsq`.</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">    RankWarning</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">        Raised if the matrix in the least-squares fit is rank deficient.</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">        The warning is only raised if ``full == False``.  The warnings can</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        be turned off by:</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">        &gt;&gt;&gt; import warnings</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">        &gt;&gt;&gt; warnings.simplefilter(&#39;ignore&#39;, np.RankWarning)</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    numpy.polynomial.chebyshev.chebfit</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    numpy.polynomial.legendre.legfit</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    numpy.polynomial.laguerre.lagfit</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    numpy.polynomial.hermite.hermfit</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    numpy.polynomial.hermite_e.hermefit</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    polyval : Evaluates a polynomial.</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    polyvander : Vandermonde matrix for powers.</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    numpy.linalg.lstsq : Computes a least-squares fit from the matrix.</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    scipy.interpolate.UnivariateSpline : Computes spline fits.</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">    The solution is the coefficients of the polynomial `p` that minimizes</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    the sum of the weighted squared errors</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">    where the :math:`w_j` are the weights. This problem is solved by</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    setting up the (typically) over-determined matrix equation:</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral">    .. math:: V(x) * c = w * y,</span></div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">    where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    coefficients to be solved for, `w` are the weights, and `y` are the</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    observed values.  This equation is then solved using the singular value</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    decomposition of `V`.</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    If some of the singular values of `V` are so small that they are</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    neglected (and `full` == ``False``), a `RankWarning` will be raised.</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    This means that the coefficient values may be poorly determined.</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    Fitting to a lower order polynomial will usually get rid of the warning</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    (but may not be what you want, of course; if you have independent</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    reason(s) for choosing the degree which isn&#39;t working, you may have to:</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    a) reconsider those reasons, and/or b) reconsider the quality of your</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    data).  The `rcond` parameter can also be set to a value smaller than</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    its default, but the resulting fit may be spurious and have large</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    contributions from roundoff error.</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    Polynomial fits using double precision tend to &quot;fail&quot; at about</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    (polynomial) degree 20. Fits using Chebyshev or Legendre series are</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    generally better conditioned, but much can still depend on the</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    distribution of the sample points and the smoothness of the data.  If</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    the quality of the fit is inadequate, splines may be a good</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">    alternative.</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">    &gt;&gt;&gt; np.random.seed(123)</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(-1,1,51) # x &quot;data&quot;: [-1, -0.96, ..., 0.96, 1]</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    &gt;&gt;&gt; y = x**3 - x + np.random.randn(len(x))  # x^3 - x + Gaussian noise</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    &gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    &gt;&gt;&gt; np.random.seed(123)</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    &gt;&gt;&gt; c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    array([ 0.01909725, -1.30598256, -0.00577963,  1.02644286]) # may vary</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &gt;&gt;&gt; stats # note the large SSR, explaining the rather poor results</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">     [array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316, # may vary</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">              0.28853036]), 1.1324274851176597e-014]</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    Same thing without the added noise</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    &gt;&gt;&gt; y = x**3 - x</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    &gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    &gt;&gt;&gt; c # c[0], c[2] should be &quot;very close to 0&quot;, c[1] ~= -1, c[3] ~= 1</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    array([-6.36925336e-18, -1.00000000e+00, -4.08053781e-16,  1.00000000e+00])</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    &gt;&gt;&gt; stats # note the minuscule SSR</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">    [array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158, # may vary</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">               0.50443316,  0.28853036]), 1.1324274851176597e-014]</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1362</span>    <span class="keywordflow">return</span> pu._fit(polyvander, x, y, deg, rcond, full, w)</div>
<div class="line"><span class="lineno"> 1363</span> </div>
<div class="line"><span class="lineno"> 1364</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a29a0bddca583334f657830d8dd513f36" name="a29a0bddca583334f657830d8dd513f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a0bddca583334f657830d8dd513f36">&#9670;&#160;</a></span>polyfromroots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyfromroots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a monic polynomial with given roots.

Return the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

where the ``r_n`` are the roots specified in `roots`.  If a zero has
multiplicity n, then it must appear in `roots` n times. For instance,
if 2 is a root of multiplicity three and 3 is a root of multiplicity 2,
then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear
in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * x + ... +  x^n

The coefficient of the last term is 1 for monic polynomials in this
form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of the polynomial's coefficients If all the roots are
    real, then `out` is also real, otherwise it is complex.  (see
    Examples below).

See Also
--------
numpy.polynomial.chebyshev.chebfromroots
numpy.polynomial.legendre.legfromroots
numpy.polynomial.laguerre.lagfromroots
numpy.polynomial.hermite.hermfromroots
numpy.polynomial.hermite_e.hermefromroots

Notes
-----
The coefficients are determined by multiplying together linear factors
of the form ``(x - r_i)``, i.e.

.. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n)

where ``n == len(roots) - 1``; note that this implies that ``1`` is always
returned for :math:`a_n`.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x
array([ 0., -1.,  0.,  1.])
&gt;&gt;&gt; j = complex(0,1)
&gt;&gt;&gt; P.polyfromroots((-j,j)) # complex returned, though values are real
array([1.+0.j,  0.+0.j,  1.+0.j])</pre> <div class="fragment"><div class="line"><span class="lineno">  151</span><span class="keyword">def </span>polyfromroots(roots):</div>
<div class="line"><span class="lineno">  152</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    Generate a monic polynomial with given roots.</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    Return the coefficients of the polynomial</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    where the ``r_n`` are the roots specified in `roots`.  If a zero has</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    multiplicity n, then it must appear in `roots` n times. For instance,</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    if 2 is a root of multiplicity three and 3 is a root of multiplicity 2,</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    in any order.</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    If the returned coefficients are `c`, then</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    .. math:: p(x) = c_0 + c_1 * x + ... +  x^n</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    The coefficient of the last term is 1 for monic polynomials in this</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    form.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    roots : array_like</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        Sequence containing the roots.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        1-D array of the polynomial&#39;s coefficients If all the roots are</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        real, then `out` is also real, otherwise it is complex.  (see</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        Examples below).</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    numpy.polynomial.chebyshev.chebfromroots</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    numpy.polynomial.legendre.legfromroots</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    numpy.polynomial.laguerre.lagfromroots</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    numpy.polynomial.hermite.hermfromroots</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    numpy.polynomial.hermite_e.hermefromroots</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    The coefficients are determined by multiplying together linear factors</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    of the form ``(x - r_i)``, i.e.</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    .. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n)</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    where ``n == len(roots) - 1``; note that this implies that ``1`` is always</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    returned for :math:`a_n`.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    &gt;&gt;&gt; P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    array([ 0., -1.,  0.,  1.])</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    &gt;&gt;&gt; j = complex(0,1)</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    &gt;&gt;&gt; P.polyfromroots((-j,j)) # complex returned, though values are real</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    array([1.+0.j,  0.+0.j,  1.+0.j])</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  212</span>    <span class="keywordflow">return</span> pu._fromroots(polyline, polymul, roots)</div>
<div class="line"><span class="lineno">  213</span> </div>
<div class="line"><span class="lineno">  214</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab75ffd3c6cf7232b651d2ec60a12496c" name="ab75ffd3c6cf7232b651d2ec60a12496c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75ffd3c6cf7232b651d2ec60a12496c">&#9670;&#160;</a></span>polygrid2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polygrid2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a 2-D polynomial on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \\sum_{i,j} c_{i,j} * a^i * b^j

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
polyval, polyval2d, polyval3d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0</pre> <div class="fragment"><div class="line"><span class="lineno">  898</span><span class="keyword">def </span>polygrid2d(x, y, c):</div>
<div class="line"><span class="lineno">  899</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    Evaluate a 2-D polynomial on the Cartesian product of x and y.</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    This function returns the values:</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * a^i * b^j</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    where the points `(a, b)` consist of all pairs formed by taking</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    `a` from `x` and `b` from `y`. The resulting points form a grid with</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    `x` in the first dimension and `y` in the second.</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    The parameters `x` and `y` are converted to arrays only if they are</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    tuples or a lists, otherwise they are treated as a scalars. In either</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    case, either `x` and `y` or their elements must support multiplication</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    and addition both with themselves and with the elements of `c`.</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    If `c` has fewer than two dimensions, ones are implicitly appended to</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    its shape to make it 2-D. The shape of the result will be c.shape[2:] +</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    x.shape + y.shape.</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    x, y : array_like, compatible objects</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">        The two dimensional series is evaluated at the points in the</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">        Cartesian product of `x` and `y`.  If `x` or `y` is a list or</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">        tuple, it is first converted to an ndarray, otherwise it is left</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">        unchanged and, if it isn&#39;t an ndarray, it is treated as a scalar.</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">        Array of coefficients ordered so that the coefficients for terms of</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">        degree i,j are contained in ``c[i,j]``. If `c` has dimension</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">        greater than two the remaining indices enumerate multiple sets of</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">        coefficients.</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    values : ndarray, compatible object</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">        The values of the two dimensional polynomial at points in the Cartesian</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">        product of `x` and `y`.</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    polyval, polyval2d, polyval3d, polygrid3d</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  948</span>    <span class="keywordflow">return</span> pu._gridnd(polyval, c, x, y)</div>
<div class="line"><span class="lineno">  949</span> </div>
<div class="line"><span class="lineno">  950</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b582c07963d40c5241ef870cf5a6f7b" name="a5b582c07963d40c5241ef870cf5a6f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b582c07963d40c5241ef870cf5a6f7b">&#9670;&#160;</a></span>polygrid3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polygrid3d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a 3-D polynomial on the Cartesian product of x, y and z.

This function returns the values:

.. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
polyval, polyval2d, polygrid2d, polyval3d

Notes
-----

.. versionadded:: 1.7.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 1002</span><span class="keyword">def </span>polygrid3d(x, y, z, c):</div>
<div class="line"><span class="lineno"> 1003</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    This function returns the values:</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    where the points `(a, b, c)` consist of all triples formed by taking</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    a grid with `x` in the first dimension, `y` in the second, and `z` in</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    the third.</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    The parameters `x`, `y`, and `z` are converted to arrays only if they</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    are tuples or a lists, otherwise they are treated as a scalars. In</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    either case, either `x`, `y`, and `z` or their elements must support</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    multiplication and addition both with themselves and with the elements</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    of `c`.</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    If `c` has fewer than three dimensions, ones are implicitly appended to</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    its shape to make it 3-D. The shape of the result will be c.shape[3:] +</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    x.shape + y.shape + z.shape.</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    x, y, z : array_like, compatible objects</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">        The three dimensional series is evaluated at the points in the</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">        list or tuple, it is first converted to an ndarray, otherwise it is</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">        left unchanged and, if it isn&#39;t an ndarray, it is treated as a</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">        scalar.</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">        Array of coefficients ordered so that the coefficients for terms of</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">        degree i,j are contained in ``c[i,j]``. If `c` has dimension</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">        greater than two the remaining indices enumerate multiple sets of</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">        coefficients.</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    values : ndarray, compatible object</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        The values of the two dimensional polynomial at points in the Cartesian</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">        product of `x` and `y`.</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    polyval, polyval2d, polygrid2d, polyval3d</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1055</span>    <span class="keywordflow">return</span> pu._gridnd(polyval, c, x, y, z)</div>
<div class="line"><span class="lineno"> 1056</span> </div>
<div class="line"><span class="lineno"> 1057</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae925c9505594a28d957813e32a3f8d94" name="ae925c9505594a28d957813e32a3f8d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae925c9505594a28d957813e32a3f8d94">&#9670;&#160;</a></span>polyint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lbnd</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scl</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integrate a polynomial.

Returns the polynomial coefficients `c` integrated `m` times from
`lbnd` along `axis`.  At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.) The argument `c` is an array of
coefficients, from low to high degree along each axis, e.g., [1,2,3]
represents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]]
represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    1-D array of polynomial coefficients, ordered from low to high.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at zero
    is the first value in the list, the value of the second integral
    at zero is the second value, etc.  If ``k == []`` (the default),
    all constants are set to zero.  If ``m == 1``, a single scalar can
    be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Coefficient array of the integral.

Raises
------
ValueError
    If ``m &lt; 1``, ``len(k) &gt; m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
polyder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.  Why
is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`. Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c = (1,2,3)
&gt;&gt;&gt; P.polyint(c) # should return array([0, 1, 1, 1])
array([0.,  1.,  1.,  1.])
&gt;&gt;&gt; P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])
 array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary
         0.05      ])
&gt;&gt;&gt; P.polyint(c,k=3) # should return array([3, 1, 1, 1])
array([3.,  1.,  1.,  1.])
&gt;&gt;&gt; P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])
array([6.,  1.,  1.,  1.])
&gt;&gt;&gt; P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])
array([ 0., -2., -2., -2.])</pre> <div class="fragment"><div class="line"><span class="lineno">  545</span><span class="keyword">def </span>polyint(c, m=1, k=[], lbnd=0, scl=1, axis=0):</div>
<div class="line"><span class="lineno">  546</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    Integrate a polynomial.</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    Returns the polynomial coefficients `c` integrated `m` times from</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    `lbnd` along `axis`.  At each iteration the resulting series is</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    **multiplied** by `scl` and an integration constant, `k`, is added.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    The scaling factor is for use in a linear change of variable.  (&quot;Buyer</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    beware&quot;: note that, depending on what one is doing, one may want `scl`</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    to be the reciprocal of what one might expect; for more information,</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    see the Notes section below.) The argument `c` is an array of</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    coefficients, from low to high degree along each axis, e.g., [1,2,3]</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    represents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]]</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    ``y``.</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">        1-D array of polynomial coefficients, ordered from low to high.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    m : int, optional</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">        Order of integration, must be positive. (Default: 1)</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    k : {[], list, scalar}, optional</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">        Integration constant(s).  The value of the first integral at zero</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        is the first value in the list, the value of the second integral</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        at zero is the second value, etc.  If ``k == []`` (the default),</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        all constants are set to zero.  If ``m == 1``, a single scalar can</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        be given instead of a list.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    lbnd : scalar, optional</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        The lower bound of the integral. (Default: 0)</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    scl : scalar, optional</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        Following each integration the result is *multiplied* by `scl`</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        before the integration constant is added. (Default: 1)</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        Axis over which the integral is taken. (Default: 0).</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    S : ndarray</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        Coefficient array of the integral.</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        If ``m &lt; 1``, ``len(k) &gt; m``, ``np.ndim(lbnd) != 0``, or</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        ``np.ndim(scl) != 0``.</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    polyder</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    Note that the result of each integration is *multiplied* by `scl`.  Why</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    is this important to note?  Say one is making a linear change of</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    variable :math:`u = ax + b` in an integral relative to `x`. Then</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    :math:`dx = du/a`, so one will need to set `scl` equal to</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    :math:`1/a` - perhaps not what one would have first thought.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    &gt;&gt;&gt; c = (1,2,3)</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    &gt;&gt;&gt; P.polyint(c) # should return array([0, 1, 1, 1])</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    array([0.,  1.,  1.,  1.])</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    &gt;&gt;&gt; P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">     array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">             0.05      ])</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    &gt;&gt;&gt; P.polyint(c,k=3) # should return array([3, 1, 1, 1])</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    array([3.,  1.,  1.,  1.])</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    &gt;&gt;&gt; P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    array([6.,  1.,  1.,  1.])</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    &gt;&gt;&gt; P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    array([ 0., -2., -2., -2.])</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  623</span>    c = np.array(c, ndmin=1, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  624</span>    <span class="keywordflow">if</span> c.dtype.char <span class="keywordflow">in</span> <span class="stringliteral">&#39;?bBhHiIlLqQpP&#39;</span>:</div>
<div class="line"><span class="lineno">  625</span>        <span class="comment"># astype doesn&#39;t preserve mask attribute.</span></div>
<div class="line"><span class="lineno">  626</span>        c = c + 0.0</div>
<div class="line"><span class="lineno">  627</span>    cdt = c.dtype</div>
<div class="line"><span class="lineno">  628</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.iterable(k):</div>
<div class="line"><span class="lineno">  629</span>        k = [k]</div>
<div class="line"><span class="lineno">  630</span>    cnt = pu._deprecate_as_int(m, <span class="stringliteral">&quot;the order of integration&quot;</span>)</div>
<div class="line"><span class="lineno">  631</span>    iaxis = pu._deprecate_as_int(axis, <span class="stringliteral">&quot;the axis&quot;</span>)</div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">if</span> cnt &lt; 0:</div>
<div class="line"><span class="lineno">  633</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The order of integration must be non-negative&quot;</span>)</div>
<div class="line"><span class="lineno">  634</span>    <span class="keywordflow">if</span> len(k) &gt; cnt:</div>
<div class="line"><span class="lineno">  635</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Too many integration constants&quot;</span>)</div>
<div class="line"><span class="lineno">  636</span>    <span class="keywordflow">if</span> np.ndim(lbnd) != 0:</div>
<div class="line"><span class="lineno">  637</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;lbnd must be a scalar.&quot;</span>)</div>
<div class="line"><span class="lineno">  638</span>    <span class="keywordflow">if</span> np.ndim(scl) != 0:</div>
<div class="line"><span class="lineno">  639</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;scl must be a scalar.&quot;</span>)</div>
<div class="line"><span class="lineno">  640</span>    iaxis = normalize_axis_index(iaxis, c.ndim)</div>
<div class="line"><span class="lineno">  641</span> </div>
<div class="line"><span class="lineno">  642</span>    <span class="keywordflow">if</span> cnt == 0:</div>
<div class="line"><span class="lineno">  643</span>        <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno">  644</span> </div>
<div class="line"><span class="lineno">  645</span>    k = list(k) + [0]*(cnt - len(k))</div>
<div class="line"><span class="lineno">  646</span>    c = np.moveaxis(c, iaxis, 0)</div>
<div class="line"><span class="lineno">  647</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(cnt):</div>
<div class="line"><span class="lineno">  648</span>        n = len(c)</div>
<div class="line"><span class="lineno">  649</span>        c *= scl</div>
<div class="line"><span class="lineno">  650</span>        <span class="keywordflow">if</span> n == 1 <span class="keywordflow">and</span> np.all(c[0] == 0):</div>
<div class="line"><span class="lineno">  651</span>            c[0] += k[i]</div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  653</span>            tmp = np.empty((n + 1,) + c.shape[1:], dtype=cdt)</div>
<div class="line"><span class="lineno">  654</span>            tmp[0] = c[0]*0</div>
<div class="line"><span class="lineno">  655</span>            tmp[1] = c[0]</div>
<div class="line"><span class="lineno">  656</span>            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(1, n):</div>
<div class="line"><span class="lineno">  657</span>                tmp[j + 1] = c[j]/(j + 1)</div>
<div class="line"><span class="lineno">  658</span>            tmp[0] += k[i] - polyval(lbnd, tmp)</div>
<div class="line"><span class="lineno">  659</span>            c = tmp</div>
<div class="line"><span class="lineno">  660</span>    c = np.moveaxis(c, 0, iaxis)</div>
<div class="line"><span class="lineno">  661</span>    <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno">  662</span> </div>
<div class="line"><span class="lineno">  663</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae918ad4af8515648d5d4aab5dddf0d55" name="ae918ad4af8515648d5d4aab5dddf0d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae918ad4af8515648d5d4aab5dddf0d55">&#9670;&#160;</a></span>polyline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an array representing a linear polynomial.

Parameters
----------
off, scl : scalars
    The "y-intercept" and "slope" of the line, respectively.

Returns
-------
y : ndarray
    This module's representation of the linear polynomial ``off +
    scl*x``.

See Also
--------
numpy.polynomial.chebyshev.chebline
numpy.polynomial.legendre.legline
numpy.polynomial.laguerre.lagline
numpy.polynomial.hermite.hermline
numpy.polynomial.hermite_e.hermeline

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; P.polyline(1,-1)
array([ 1, -1])
&gt;&gt;&gt; P.polyval(1, P.polyline(1,-1)) # should be 0
0.0</pre> <div class="fragment"><div class="line"><span class="lineno">  113</span><span class="keyword">def </span>polyline(off, scl):</div>
<div class="line"><span class="lineno">  114</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    Returns an array representing a linear polynomial.</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    off, scl : scalars</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        The &quot;y-intercept&quot; and &quot;slope&quot; of the line, respectively.</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        This module&#39;s representation of the linear polynomial ``off +</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        scl*x``.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    numpy.polynomial.chebyshev.chebline</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    numpy.polynomial.legendre.legline</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    numpy.polynomial.laguerre.lagline</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    numpy.polynomial.hermite.hermline</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    numpy.polynomial.hermite_e.hermeline</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    &gt;&gt;&gt; P.polyline(1,-1)</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    array([ 1, -1])</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    &gt;&gt;&gt; P.polyval(1, P.polyline(1,-1)) # should be 0</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">if</span> scl != 0:</div>
<div class="line"><span class="lineno">  146</span>        <span class="keywordflow">return</span> np.array([off, scl])</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  148</span>        <span class="keywordflow">return</span> np.array([off])</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9eae7956d8adccdea88a022b1377a788" name="a9eae7956d8adccdea88a022b1377a788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eae7956d8adccdea88a022b1377a788">&#9670;&#160;</a></span>polymul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polymul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply one polynomial by another.

Returns the product of two polynomials `c1` * `c2`.  The arguments are
sequences of coefficients, from lowest order term to highest, e.g.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``

Parameters
----------
c1, c2 : array_like
    1-D arrays of coefficients representing a polynomial, relative to the
    "standard" basis, and ordered from lowest order term to highest.

Returns
-------
out : ndarray
    Of the coefficients of their product.

See Also
--------
polyadd, polysub, polymulx, polydiv, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; P.polymul(c1,c2)
array([  3.,   8.,  14.,   8.,   3.])</pre> <div class="fragment"><div class="line"><span class="lineno">  328</span><span class="keyword">def </span>polymul(c1, c2):</div>
<div class="line"><span class="lineno">  329</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    Multiply one polynomial by another.</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    Returns the product of two polynomials `c1` * `c2`.  The arguments are</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    sequences of coefficients, from lowest order term to highest, e.g.,</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    c1, c2 : array_like</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">        1-D arrays of coefficients representing a polynomial, relative to the</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">        &quot;standard&quot; basis, and ordered from lowest order term to highest.</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">        Of the coefficients of their product.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    polyadd, polysub, polymulx, polydiv, polypow</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    &gt;&gt;&gt; c1 = (1,2,3)</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    &gt;&gt;&gt; c2 = (3,2,1)</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    &gt;&gt;&gt; P.polymul(c1,c2)</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    array([  3.,   8.,  14.,   8.,   3.])</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  360</span>    <span class="comment"># c1, c2 are trimmed copies</span></div>
<div class="line"><span class="lineno">  361</span>    [c1, c2] = pu.as_series([c1, c2])</div>
<div class="line"><span class="lineno">  362</span>    ret = np.convolve(c1, c2)</div>
<div class="line"><span class="lineno">  363</span>    <span class="keywordflow">return</span> pu.trimseq(ret)</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c5245c48d904bbbe3fdf11f0da9ea7c" name="a1c5245c48d904bbbe3fdf11f0da9ea7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5245c48d904bbbe3fdf11f0da9ea7c">&#9670;&#160;</a></span>polymulx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polymulx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multiply a polynomial by x.

Multiply the polynomial `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of polynomial coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

See Also
--------
polyadd, polysub, polymul, polydiv, polypow

Notes
-----

.. versionadded:: 1.5.0</pre> <div class="fragment"><div class="line"><span class="lineno">  288</span><span class="keyword">def </span>polymulx(c):</div>
<div class="line"><span class="lineno">  289</span>    <span class="stringliteral">&quot;&quot;&quot;Multiply a polynomial by x.</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    Multiply the polynomial `c` by x, where x is the independent</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    variable.</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        1-D array of polynomial coefficients ordered from low to</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        high.</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        Array representing the result of the multiplication.</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    polyadd, polysub, polymul, polydiv, polypow</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  316</span>    <span class="comment"># c is a trimmed copy</span></div>
<div class="line"><span class="lineno">  317</span>    [c] = pu.as_series([c])</div>
<div class="line"><span class="lineno">  318</span>    <span class="comment"># The zero series needs special treatment</span></div>
<div class="line"><span class="lineno">  319</span>    <span class="keywordflow">if</span> len(c) == 1 <span class="keywordflow">and</span> c[0] == 0:</div>
<div class="line"><span class="lineno">  320</span>        <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno">  321</span> </div>
<div class="line"><span class="lineno">  322</span>    prd = np.empty(len(c) + 1, dtype=c.dtype)</div>
<div class="line"><span class="lineno">  323</span>    prd[0] = c[0]*0</div>
<div class="line"><span class="lineno">  324</span>    prd[1:] = c</div>
<div class="line"><span class="lineno">  325</span>    <span class="keywordflow">return</span> prd</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7346f5d7618fd9d086d66c1cb74b6386" name="a7346f5d7618fd9d086d66c1cb74b6386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7346f5d7618fd9d086d66c1cb74b6386">&#9670;&#160;</a></span>polypow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polypow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxpower</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Raise a polynomial to a power.

Returns the polynomial `c` raised to the power `pow`. The argument
`c` is a sequence of coefficients ordered from low to high. i.e.,
[1,2,3] is the series  ``1 + 2*x + 3*x**2.``

Parameters
----------
c : array_like
    1-D array of array of series coefficients ordered from low to
    high degree.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Power series of power.

See Also
--------
polyadd, polysub, polymulx, polymul, polydiv

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; P.polypow([1,2,3], 2)
array([ 1., 4., 10., 12., 9.])</pre> <div class="fragment"><div class="line"><span class="lineno">  424</span><span class="keyword">def </span>polypow(c, pow, maxpower=None):</div>
<div class="line"><span class="lineno">  425</span>    <span class="stringliteral">&quot;&quot;&quot;Raise a polynomial to a power.</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    Returns the polynomial `c` raised to the power `pow`. The argument</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    `c` is a sequence of coefficients ordered from low to high. i.e.,</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    [1,2,3] is the series  ``1 + 2*x + 3*x**2.``</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        1-D array of array of series coefficients ordered from low to</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        high degree.</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    pow : integer</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">        Power to which the series will be raised</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    maxpower : integer, optional</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        Maximum power allowed. This is mainly to limit growth of the series</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        to unmanageable size. Default is 16</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    coef : ndarray</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        Power series of power.</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    polyadd, polysub, polymulx, polymul, polydiv</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    &gt;&gt;&gt; P.polypow([1,2,3], 2)</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    array([ 1., 4., 10., 12., 9.])</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  458</span>    <span class="comment"># note: this is more efficient than `pu._pow(polymul, c1, c2)`, as it</span></div>
<div class="line"><span class="lineno">  459</span>    <span class="comment"># avoids calling `as_series` repeatedly</span></div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">return</span> pu._pow(np.convolve, c, pow, maxpower)</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a00c3c07debc947d63e4e61e87e4dd82e" name="a00c3c07debc947d63e4e61e87e4dd82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c3c07debc947d63e4e61e87e4dd82e">&#9670;&#160;</a></span>polyroots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyroots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the roots of a polynomial.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \\sum_i c[i] * x^i.

Parameters
----------
c : 1-D array_like
    1-D array of polynomial coefficients.

Returns
-------
out : ndarray
    Array of the roots of the polynomial. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
numpy.polynomial.chebyshev.chebroots
numpy.polynomial.legendre.legroots
numpy.polynomial.laguerre.lagroots
numpy.polynomial.hermite.hermroots
numpy.polynomial.hermite_e.hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the power series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.polynomial as poly
&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1)))
array([-1.,  0.,  1.])
&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1))).dtype
dtype('float64')
&gt;&gt;&gt; j = complex(0,1)
&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-j,0,j)))
array([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j]) # may vary</pre> <div class="fragment"><div class="line"><span class="lineno"> 1405</span><span class="keyword">def </span>polyroots(c):</div>
<div class="line"><span class="lineno"> 1406</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    Compute the roots of a polynomial.</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    Return the roots (a.k.a. &quot;zeros&quot;) of the polynomial</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    .. math:: p(x) = \\sum_i c[i] * x^i.</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">    c : 1-D array_like</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">        1-D array of polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">        Array of the roots of the polynomial. If all the roots are real,</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">        then `out` is also real, otherwise it is complex.</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    numpy.polynomial.chebyshev.chebroots</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    numpy.polynomial.legendre.legroots</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    numpy.polynomial.laguerre.lagroots</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    numpy.polynomial.hermite.hermroots</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    numpy.polynomial.hermite_e.hermeroots</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    The root estimates are obtained as the eigenvalues of the companion</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    matrix, Roots far from the origin of the complex plane may have large</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">    errors due to the numerical instability of the power series for such</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">    values. Roots with multiplicity greater than 1 will also show larger</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    errors as the value of the series near such points is relatively</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">    insensitive to errors in the roots. Isolated roots near the origin can</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">    be improved by a few iterations of Newton&#39;s method.</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    &gt;&gt;&gt; import numpy.polynomial.polynomial as poly</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    &gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1)))</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    array([-1.,  0.,  1.])</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">    &gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1))).dtype</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">    dtype(&#39;float64&#39;)</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">    &gt;&gt;&gt; j = complex(0,1)</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">    &gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-j,0,j)))</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">    array([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j]) # may vary</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1454</span>    <span class="comment"># c is a trimmed copy</span></div>
<div class="line"><span class="lineno"> 1455</span>    [c] = pu.as_series([c])</div>
<div class="line"><span class="lineno"> 1456</span>    <span class="keywordflow">if</span> len(c) &lt; 2:</div>
<div class="line"><span class="lineno"> 1457</span>        <span class="keywordflow">return</span> np.array([], dtype=c.dtype)</div>
<div class="line"><span class="lineno"> 1458</span>    <span class="keywordflow">if</span> len(c) == 2:</div>
<div class="line"><span class="lineno"> 1459</span>        <span class="keywordflow">return</span> np.array([-c[0]/c[1]])</div>
<div class="line"><span class="lineno"> 1460</span> </div>
<div class="line"><span class="lineno"> 1461</span>    <span class="comment"># rotated companion matrix reduces error</span></div>
<div class="line"><span class="lineno"> 1462</span>    m = polycompanion(c)[::-1,::-1]</div>
<div class="line"><span class="lineno"> 1463</span>    r = la.eigvals(m)</div>
<div class="line"><span class="lineno"> 1464</span>    r.sort()</div>
<div class="line"><span class="lineno"> 1465</span>    <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno"> 1466</span> </div>
<div class="line"><span class="lineno"> 1467</span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="comment"># polynomial class</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="comment">#</span></div>
<div class="line"><span class="lineno"> 1471</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a27a52aa247003715189181dbc5cca1ba" name="a27a52aa247003715189181dbc5cca1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a52aa247003715189181dbc5cca1ba">&#9670;&#160;</a></span>polysub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polysub </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Subtract one polynomial from another.

Returns the difference of two polynomials `c1` - `c2`.  The arguments
are sequences of coefficients from lowest order term to highest, i.e.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of coefficients representing their difference.

See Also
--------
polyadd, polymulx, polymul, polydiv, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; P.polysub(c1,c2)
array([-2.,  0.,  2.])
&gt;&gt;&gt; P.polysub(c2,c1) # -P.polysub(c1,c2)
array([ 2.,  0., -2.])</pre> <div class="fragment"><div class="line"><span class="lineno">  251</span><span class="keyword">def </span>polysub(c1, c2):</div>
<div class="line"><span class="lineno">  252</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    Subtract one polynomial from another.</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    Returns the difference of two polynomials `c1` - `c2`.  The arguments</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    are sequences of coefficients from lowest order term to highest, i.e.,</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    c1, c2 : array_like</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">        1-D arrays of polynomial coefficients ordered from low to</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">        high.</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        Of coefficients representing their difference.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    polyadd, polymulx, polymul, polydiv, polypow</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial import polynomial as P</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    &gt;&gt;&gt; c1 = (1,2,3)</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    &gt;&gt;&gt; c2 = (3,2,1)</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    &gt;&gt;&gt; P.polysub(c1,c2)</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    array([-2.,  0.,  2.])</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    &gt;&gt;&gt; P.polysub(c2,c1) # -P.polysub(c1,c2)</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    array([ 2.,  0., -2.])</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">return</span> pu._sub(c1, c2)</div>
<div class="line"><span class="lineno">  286</span> </div>
<div class="line"><span class="lineno">  287</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5af96090a5a020c74c2cf0ce6b5fd364" name="a5af96090a5a020c74c2cf0ce6b5fd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af96090a5a020c74c2cf0ce6b5fd364">&#9670;&#160;</a></span>polyval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyval </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tensor</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a polynomial at points x.

If `c` is of length `n + 1`, this function returns the value

.. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, compatible object
    The shape of the returned array is described above.

See Also
--------
polyval2d, polygrid2d, polyval3d, polygrid3d

Notes
-----
The evaluation uses Horner's method.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.polynomial import polyval
&gt;&gt;&gt; polyval(1, [1,2,3])
6.0
&gt;&gt;&gt; a = np.arange(4).reshape(2,2)
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; polyval(a, [1,2,3])
array([[ 1.,   6.],
       [17.,  34.]])
&gt;&gt;&gt; coef = np.arange(4).reshape(2,2) # multidimensional coefficients
&gt;&gt;&gt; coef
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; polyval([1,2], coef, tensor=True)
array([[2.,  4.],
       [4.,  7.]])
&gt;&gt;&gt; polyval([1,2], coef, tensor=False)
array([2.,  7.])</pre> <div class="fragment"><div class="line"><span class="lineno">  664</span><span class="keyword">def </span>polyval(x, c, tensor=True):</div>
<div class="line"><span class="lineno">  665</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    Evaluate a polynomial at points x.</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    If `c` is of length `n + 1`, this function returns the value</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    .. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    The parameter `x` is converted to an array only if it is a tuple or a</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    list, otherwise it is treated as a scalar. In either case, either `x`</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    or its elements must support multiplication and addition both with</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    themselves and with the elements of `c`.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    `c` is multidimensional, then the shape of the result depends on the</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    scalars have shape (,).</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    Trailing zeros in the coefficients will be used in the evaluation, so</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    they should be avoided if efficiency is a concern.</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    x : array_like, compatible object</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        If `x` is a list or tuple, it is converted to an ndarray, otherwise</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        it is left unchanged and treated as a scalar. In either case, `x`</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        or its elements must support addition and multiplication with</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">        with themselves and with the elements of `c`.</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        Array of coefficients ordered so that the coefficients for terms of</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        degree n are contained in c[n]. If `c` is multidimensional the</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">        remaining indices enumerate multiple polynomials. In the two</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        dimensional case the coefficients may be thought of as stored in</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        the columns of `c`.</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    tensor : boolean, optional</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        If True, the shape of the coefficient array is extended with ones</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        on the right, one for each dimension of `x`. Scalars have dimension 0</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        for this action. The result is that every column of coefficients in</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        `c` is evaluated for every element of `x`. If False, `x` is broadcast</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        over the columns of `c` for the evaluation.  This keyword is useful</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">        when `c` is multidimensional. The default value is True.</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    values : ndarray, compatible object</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">        The shape of the returned array is described above.</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    polyval2d, polygrid2d, polyval3d, polygrid3d</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    The evaluation uses Horner&#39;s method.</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial.polynomial import polyval</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    &gt;&gt;&gt; polyval(1, [1,2,3])</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    6.0</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(4).reshape(2,2)</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">           [2, 3]])</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    &gt;&gt;&gt; polyval(a, [1,2,3])</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    array([[ 1.,   6.],</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">           [17.,  34.]])</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    &gt;&gt;&gt; coef = np.arange(4).reshape(2,2) # multidimensional coefficients</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    &gt;&gt;&gt; coef</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">           [2, 3]])</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    &gt;&gt;&gt; polyval([1,2], coef, tensor=True)</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    array([[2.,  4.],</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">           [4.,  7.]])</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    &gt;&gt;&gt; polyval([1,2], coef, tensor=False)</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    array([2.,  7.])</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  745</span>    c = np.array(c, ndmin=1, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  746</span>    <span class="keywordflow">if</span> c.dtype.char <span class="keywordflow">in</span> <span class="stringliteral">&#39;?bBhHiIlLqQpP&#39;</span>:</div>
<div class="line"><span class="lineno">  747</span>        <span class="comment"># astype fails with NA</span></div>
<div class="line"><span class="lineno">  748</span>        c = c + 0.0</div>
<div class="line"><span class="lineno">  749</span>    <span class="keywordflow">if</span> isinstance(x, (tuple, list)):</div>
<div class="line"><span class="lineno">  750</span>        x = np.asarray(x)</div>
<div class="line"><span class="lineno">  751</span>    <span class="keywordflow">if</span> isinstance(x, np.ndarray) <span class="keywordflow">and</span> tensor:</div>
<div class="line"><span class="lineno">  752</span>        c = c.reshape(c.shape + (1,)*x.ndim)</div>
<div class="line"><span class="lineno">  753</span> </div>
<div class="line"><span class="lineno">  754</span>    c0 = c[-1] + x*0</div>
<div class="line"><span class="lineno">  755</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(2, len(c) + 1):</div>
<div class="line"><span class="lineno">  756</span>        c0 = c[-i] + c0*x</div>
<div class="line"><span class="lineno">  757</span>    <span class="keywordflow">return</span> c0</div>
<div class="line"><span class="lineno">  758</span> </div>
<div class="line"><span class="lineno">  759</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a28517914a28dc42082e2d31a658cbbca" name="a28517914a28dc42082e2d31a658cbbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28517914a28dc42082e2d31a658cbbca">&#9670;&#160;</a></span>polyval2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyval2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a 2-D polynomial at points (x, y).

This function returns the value

.. math:: p(x,y) = \\sum_{i,j} c_{i,j} * x^i * y^j

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in `c[i,j]`. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
polyval, polygrid2d, polyval3d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0</pre> <div class="fragment"><div class="line"><span class="lineno">  848</span><span class="keyword">def </span>polyval2d(x, y, c):</div>
<div class="line"><span class="lineno">  849</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    Evaluate a 2-D polynomial at points (x, y).</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    This function returns the value</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * x^i * y^j</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    The parameters `x` and `y` are converted to arrays only if they are</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    tuples or a lists, otherwise they are treated as a scalars and they</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    must have the same shape after conversion. In either case, either `x`</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    and `y` or their elements must support multiplication and addition both</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    with themselves and with the elements of `c`.</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    If `c` has fewer than two dimensions, ones are implicitly appended to</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    its shape to make it 2-D. The shape of the result will be c.shape[2:] +</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    x.shape.</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    x, y : array_like, compatible objects</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">        The two dimensional series is evaluated at the points `(x, y)`,</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">        where `x` and `y` must have the same shape. If `x` or `y` is a list</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">        or tuple, it is first converted to an ndarray, otherwise it is left</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">        unchanged and, if it isn&#39;t an ndarray, it is treated as a scalar.</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">        Array of coefficients ordered so that the coefficient of the term</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        of multi-degree i,j is contained in `c[i,j]`. If `c` has</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">        dimension greater than two the remaining indices enumerate multiple</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">        sets of coefficients.</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    values : ndarray, compatible object</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        The values of the two dimensional polynomial at points formed with</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">        pairs of corresponding values from `x` and `y`.</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    polyval, polygrid2d, polyval3d, polygrid3d</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  895</span>    <span class="keywordflow">return</span> pu._valnd(polyval, c, x, y)</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f13e2c875f4bedb6af03d3bdd4c6a2c" name="a3f13e2c875f4bedb6af03d3bdd4c6a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f13e2c875f4bedb6af03d3bdd4c6a2c">&#9670;&#160;</a></span>polyval3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyval3d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a 3-D polynomial at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
polyval, polyval2d, polygrid2d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0</pre> <div class="fragment"><div class="line"><span class="lineno">  951</span><span class="keyword">def </span>polyval3d(x, y, z, c):</div>
<div class="line"><span class="lineno">  952</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    Evaluate a 3-D polynomial at points (x, y, z).</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">    This function returns the values:</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    The parameters `x`, `y`, and `z` are converted to arrays only if</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    they are tuples or a lists, otherwise they are treated as a scalars and</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    they must have the same shape after conversion. In either case, either</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    `x`, `y`, and `z` or their elements must support multiplication and</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    addition both with themselves and with the elements of `c`.</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    If `c` has fewer than 3 dimensions, ones are implicitly appended to its</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    shape to make it 3-D. The shape of the result will be c.shape[3:] +</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    x.shape.</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    x, y, z : array_like, compatible object</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">        The three dimensional series is evaluated at the points</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        any of `x`, `y`, or `z` is a list or tuple, it is first converted</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">        to an ndarray, otherwise it is left unchanged and if it isn&#39;t an</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">        ndarray it is  treated as a scalar.</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    c : array_like</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">        Array of coefficients ordered so that the coefficient of the term of</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">        greater than 3 the remaining indices enumerate multiple sets of</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">        coefficients.</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    values : ndarray, compatible object</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">        The values of the multidimensional polynomial on points formed with</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">        triples of corresponding values from `x`, `y`, and `z`.</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    polyval, polyval2d, polygrid2d, polygrid3d</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  999</span>    <span class="keywordflow">return</span> pu._valnd(polyval, c, x, y, z)</div>
<div class="line"><span class="lineno"> 1000</span> </div>
<div class="line"><span class="lineno"> 1001</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a015e926b0b4a06a4eee5cc075107bbff" name="a015e926b0b4a06a4eee5cc075107bbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015e926b0b4a06a4eee5cc075107bbff">&#9670;&#160;</a></span>polyvalfromroots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyvalfromroots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tensor</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a polynomial specified by its roots at points x.

If `r` is of length `N`, this function returns the value

.. math:: p(x) = \\prod_{n=1}^{N} (x - r_n)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `r`.

If `r` is a 1-D array, then `p(x)` will have the same shape as `x`.  If `r`
is multidimensional, then the shape of the result depends on the value of
`tensor`. If `tensor` is ``True`` the shape will be r.shape[1:] + x.shape;
that is, each polynomial is evaluated at every value of `x`. If `tensor` is
``False``, the shape will be r.shape[1:]; that is, each polynomial is
evaluated only for the corresponding broadcast value of `x`. Note that
scalars have shape (,).

.. versionadded:: 1.12

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `r`.
r : array_like
    Array of roots. If `r` is multidimensional the first index is the
    root index, while the remaining indices enumerate multiple
    polynomials. For instance, in the two dimensional case the roots
    of each polynomial may be thought of as stored in the columns of `r`.
tensor : boolean, optional
    If True, the shape of the roots array is extended with ones on the
    right, one for each dimension of `x`. Scalars have dimension 0 for this
    action. The result is that every column of coefficients in `r` is
    evaluated for every element of `x`. If False, `x` is broadcast over the
    columns of `r` for the evaluation.  This keyword is useful when `r` is
    multidimensional. The default value is True.

Returns
-------
values : ndarray, compatible object
    The shape of the returned array is described above.

See Also
--------
polyroots, polyfromroots, polyval

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.polynomial import polyvalfromroots
&gt;&gt;&gt; polyvalfromroots(1, [1,2,3])
0.0
&gt;&gt;&gt; a = np.arange(4).reshape(2,2)
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; polyvalfromroots(a, [-1, 0, 1])
array([[-0.,   0.],
       [ 6.,  24.]])
&gt;&gt;&gt; r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients
&gt;&gt;&gt; r # each column of r defines one polynomial
array([[-2, -1],
       [ 0,  1]])
&gt;&gt;&gt; b = [-2, 1]
&gt;&gt;&gt; polyvalfromroots(b, r, tensor=True)
array([[-0.,  3.],
       [ 3., 0.]])
&gt;&gt;&gt; polyvalfromroots(b, r, tensor=False)
array([-0.,  0.])
</pre> <div class="fragment"><div class="line"><span class="lineno">  760</span><span class="keyword">def </span>polyvalfromroots(x, r, tensor=True):</div>
<div class="line"><span class="lineno">  761</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    Evaluate a polynomial specified by its roots at points x.</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    If `r` is of length `N`, this function returns the value</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    .. math:: p(x) = \\prod_{n=1}^{N} (x - r_n)</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    The parameter `x` is converted to an array only if it is a tuple or a</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    list, otherwise it is treated as a scalar. In either case, either `x`</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    or its elements must support multiplication and addition both with</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    themselves and with the elements of `r`.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    If `r` is a 1-D array, then `p(x)` will have the same shape as `x`.  If `r`</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    is multidimensional, then the shape of the result depends on the value of</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    `tensor`. If `tensor` is ``True`` the shape will be r.shape[1:] + x.shape;</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    that is, each polynomial is evaluated at every value of `x`. If `tensor` is</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    ``False``, the shape will be r.shape[1:]; that is, each polynomial is</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    evaluated only for the corresponding broadcast value of `x`. Note that</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    scalars have shape (,).</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    .. versionadded:: 1.12</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    x : array_like, compatible object</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        If `x` is a list or tuple, it is converted to an ndarray, otherwise</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        it is left unchanged and treated as a scalar. In either case, `x`</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        or its elements must support addition and multiplication with</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">        with themselves and with the elements of `r`.</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    r : array_like</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">        Array of roots. If `r` is multidimensional the first index is the</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        root index, while the remaining indices enumerate multiple</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">        polynomials. For instance, in the two dimensional case the roots</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        of each polynomial may be thought of as stored in the columns of `r`.</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    tensor : boolean, optional</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">        If True, the shape of the roots array is extended with ones on the</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">        right, one for each dimension of `x`. Scalars have dimension 0 for this</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        action. The result is that every column of coefficients in `r` is</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        evaluated for every element of `x`. If False, `x` is broadcast over the</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">        columns of `r` for the evaluation.  This keyword is useful when `r` is</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">        multidimensional. The default value is True.</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    values : ndarray, compatible object</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        The shape of the returned array is described above.</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    polyroots, polyfromroots, polyval</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.polynomial.polynomial import polyvalfromroots</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    &gt;&gt;&gt; polyvalfromroots(1, [1,2,3])</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(4).reshape(2,2)</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">           [2, 3]])</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    &gt;&gt;&gt; polyvalfromroots(a, [-1, 0, 1])</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    array([[-0.,   0.],</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">           [ 6.,  24.]])</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    &gt;&gt;&gt; r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    &gt;&gt;&gt; r # each column of r defines one polynomial</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    array([[-2, -1],</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">           [ 0,  1]])</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    &gt;&gt;&gt; b = [-2, 1]</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    &gt;&gt;&gt; polyvalfromroots(b, r, tensor=True)</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    array([[-0.,  3.],</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">           [ 3., 0.]])</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    &gt;&gt;&gt; polyvalfromroots(b, r, tensor=False)</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    array([-0.,  0.])</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  835</span>    r = np.array(r, ndmin=1, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  836</span>    <span class="keywordflow">if</span> r.dtype.char <span class="keywordflow">in</span> <span class="stringliteral">&#39;?bBhHiIlLqQpP&#39;</span>:</div>
<div class="line"><span class="lineno">  837</span>        r = r.astype(np.double)</div>
<div class="line"><span class="lineno">  838</span>    <span class="keywordflow">if</span> isinstance(x, (tuple, list)):</div>
<div class="line"><span class="lineno">  839</span>        x = np.asarray(x)</div>
<div class="line"><span class="lineno">  840</span>    <span class="keywordflow">if</span> isinstance(x, np.ndarray):</div>
<div class="line"><span class="lineno">  841</span>        <span class="keywordflow">if</span> tensor:</div>
<div class="line"><span class="lineno">  842</span>            r = r.reshape(r.shape + (1,)*x.ndim)</div>
<div class="line"><span class="lineno">  843</span>        <span class="keywordflow">elif</span> x.ndim &gt;= r.ndim:</div>
<div class="line"><span class="lineno">  844</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;x.ndim must be &lt; r.ndim when tensor == False&quot;</span>)</div>
<div class="line"><span class="lineno">  845</span>    <span class="keywordflow">return</span> np.prod(x - r, axis=0)</div>
<div class="line"><span class="lineno">  846</span> </div>
<div class="line"><span class="lineno">  847</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acdff790ca3c6465134664fb38c32388d" name="acdff790ca3c6465134664fb38c32388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdff790ca3c6465134664fb38c32388d">&#9670;&#160;</a></span>polyvander()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyvander </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Vandermonde matrix of given degree.

Returns the Vandermonde matrix of degree `deg` and sample points
`x`. The Vandermonde matrix is defined by

.. math:: V[..., i] = x^i,

where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of
`x` and the last index is the power of `x`.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
matrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and
``polyval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of polynomials of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray.
    The Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where the last index is the power of `x`.
    The dtype will be the same as the converted `x`.

See Also
--------
polyvander2d, polyvander3d</pre> <div class="fragment"><div class="line"><span class="lineno"> 1058</span><span class="keyword">def </span>polyvander(x, deg):</div>
<div class="line"><span class="lineno"> 1059</span>    <span class="stringliteral">&quot;&quot;&quot;Vandermonde matrix of given degree.</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    Returns the Vandermonde matrix of degree `deg` and sample points</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    `x`. The Vandermonde matrix is defined by</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">    .. math:: V[..., i] = x^i,</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">    `x` and the last index is the power of `x`.</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    matrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    ``polyval(x, c)`` are the same up to roundoff. This equivalence is</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    useful both for least squares fitting and for the evaluation of a large</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    number of polynomials of the same degree and sample points.</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">        Array of points. The dtype is converted to float64 or complex128</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">        depending on whether any of the elements are complex. If `x` is</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">        scalar it is converted to a 1-D array.</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    deg : int</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">        Degree of the resulting matrix.</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    vander : ndarray.</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">        The Vandermonde matrix. The shape of the returned matrix is</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">        ``x.shape + (deg + 1,)``, where the last index is the power of `x`.</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">        The dtype will be the same as the converted `x`.</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    polyvander2d, polyvander3d</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1096</span>    ideg = pu._deprecate_as_int(deg, <span class="stringliteral">&quot;deg&quot;</span>)</div>
<div class="line"><span class="lineno"> 1097</span>    <span class="keywordflow">if</span> ideg &lt; 0:</div>
<div class="line"><span class="lineno"> 1098</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;deg must be non-negative&quot;</span>)</div>
<div class="line"><span class="lineno"> 1099</span> </div>
<div class="line"><span class="lineno"> 1100</span>    x = np.array(x, copy=<span class="keyword">False</span>, ndmin=1) + 0.0</div>
<div class="line"><span class="lineno"> 1101</span>    dims = (ideg + 1,) + x.shape</div>
<div class="line"><span class="lineno"> 1102</span>    dtyp = x.dtype</div>
<div class="line"><span class="lineno"> 1103</span>    v = np.empty(dims, dtype=dtyp)</div>
<div class="line"><span class="lineno"> 1104</span>    v[0] = x*0 + 1</div>
<div class="line"><span class="lineno"> 1105</span>    <span class="keywordflow">if</span> ideg &gt; 0:</div>
<div class="line"><span class="lineno"> 1106</span>        v[1] = x</div>
<div class="line"><span class="lineno"> 1107</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(2, ideg + 1):</div>
<div class="line"><span class="lineno"> 1108</span>            v[i] = v[i-1]*x</div>
<div class="line"><span class="lineno"> 1109</span>    <span class="keywordflow">return</span> np.moveaxis(v, 0, -1)</div>
<div class="line"><span class="lineno"> 1110</span> </div>
<div class="line"><span class="lineno"> 1111</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afbb2c7c2d8c80c9c49960d0844c02992" name="afbb2c7c2d8c80c9c49960d0844c02992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb2c7c2d8c80c9c49960d0844c02992">&#9670;&#160;</a></span>polyvander2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyvander2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j,

where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the powers of
`x` and `y`.

If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D polynomials
of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
polyvander, polyvander3d, polyval2d, polyval3d</pre> <div class="fragment"><div class="line"><span class="lineno"> 1112</span><span class="keyword">def </span>polyvander2d(x, y, deg):</div>
<div class="line"><span class="lineno"> 1113</span>    <span class="stringliteral">&quot;&quot;&quot;Pseudo-Vandermonde matrix of given degrees.</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    points `(x, y)`. The pseudo-Vandermonde matrix is defined by</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    .. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j,</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    `V` index the points `(x, y)` and the last index encodes the powers of</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    `x` and `y`.</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    correspond to the elements of a 2-D coefficient array `c` of shape</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    (xdeg + 1, ydeg + 1) in the order</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    up to roundoff. This equivalence is useful both for least squares</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    fitting and for the evaluation of a large number of 2-D polynomials</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    of the same degrees and sample points.</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">    x, y : array_like</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">        Arrays of point coordinates, all of the same shape. The dtypes</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">        will be converted to either float64 or complex128 depending on</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">        whether any of the elements are complex. Scalars are converted to</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">        1-D arrays.</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    deg : list of ints</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">        List of maximum degrees of the form [x_deg, y_deg].</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">    vander2d : ndarray</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">        The shape of the returned matrix is ``x.shape + (order,)``, where</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">        as the converted `x` and `y`.</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    polyvander, polyvander3d, polyval2d, polyval3d</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1157</span>    <span class="keywordflow">return</span> pu._vander_nd_flat((polyvander, polyvander), (x, y), deg)</div>
<div class="line"><span class="lineno"> 1158</span> </div>
<div class="line"><span class="lineno"> 1159</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a75a9cf88eb62e6b71d0b57595c287585" name="a75a9cf88eb62e6b71d0b57595c287585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a9cf88eb62e6b71d0b57595c287585">&#9670;&#160;</a></span>polyvander3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyvander3d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,

where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the powers of `x`, `y`, and `z`.

If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D polynomials
of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
polyvander, polyvander3d, polyval2d, polyval3d

Notes
-----

.. versionadded:: 1.7.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 1160</span><span class="keyword">def </span>polyvander3d(x, y, z, deg):</div>
<div class="line"><span class="lineno"> 1161</span>    <span class="stringliteral">&quot;&quot;&quot;Pseudo-Vandermonde matrix of given degrees.</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    then The pseudo-Vandermonde matrix is defined by</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">    indices of `V` index the points `(x, y, z)` and the last index encodes</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    the powers of `x`, `y`, and `z`.</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    of `V` correspond to the elements of a 3-D coefficient array `c` of</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    same up to roundoff. This equivalence is useful both for least squares</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">    fitting and for the evaluation of a large number of 3-D polynomials</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    of the same degrees and sample points.</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    x, y, z : array_like</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">        Arrays of point coordinates, all of the same shape. The dtypes will</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">        be converted to either float64 or complex128 depending on whether</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">        any of the elements are complex. Scalars are converted to 1-D</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">        arrays.</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    deg : list of ints</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">        List of maximum degrees of the form [x_deg, y_deg, z_deg].</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    vander3d : ndarray</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">        The shape of the returned matrix is ``x.shape + (order,)``, where</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">        be the same as the converted `x`, `y`, and `z`.</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    polyvander, polyvander3d, polyval2d, polyval3d</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1211</span>    <span class="keywordflow">return</span> pu._vander_nd_flat((polyvander, polyvander, polyvander), (x, y, z), deg)</div>
<div class="line"><span class="lineno"> 1212</span> </div>
<div class="line"><span class="lineno"> 1213</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7a119d1b65932bf329ae2b46feb15f91" name="a7a119d1b65932bf329ae2b46feb15f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a119d1b65932bf329ae2b46feb15f91">&#9670;&#160;</a></span>polydomain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polydomain = np.array([-1, 1])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38838de0ae95dbf53f57e27bab6785a6" name="a38838de0ae95dbf53f57e27bab6785a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38838de0ae95dbf53f57e27bab6785a6">&#9670;&#160;</a></span>polyone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyone = np.array([1])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2de664e1f9c270594965d9743950e741" name="a2de664e1f9c270594965d9743950e741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de664e1f9c270594965d9743950e741">&#9670;&#160;</a></span>polytrim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polytrim = pu.trimcoef</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2471daff3218186409ae1bffea4d922d" name="a2471daff3218186409ae1bffea4d922d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2471daff3218186409ae1bffea4d922d">&#9670;&#160;</a></span>polyx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyx = np.array([0, 1])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3bf919463839420cc8515680877978f" name="aa3bf919463839420cc8515680877978f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bf919463839420cc8515680877978f">&#9670;&#160;</a></span>polyzero</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.polynomial.polynomial.polyzero = np.array([0])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
