<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.sparse.linalg._matfuncs Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse.html">sparse</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html">_matfuncs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.sparse.linalg._matfuncs Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1sparse_1_1linalg_1_1__matfuncs_1_1___expm_pade_helper.html">_ExpmPadeHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1sparse_1_1linalg_1_1__matfuncs_1_1_matrix_power_operator.html">MatrixPowerOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1sparse_1_1linalg_1_1__matfuncs_1_1_product_operator.html">ProductOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a23bb163e51712cdad294aa83487c58dc" id="r_a23bb163e51712cdad294aa83487c58dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#a23bb163e51712cdad294aa83487c58dc">inv</a> (A)</td></tr>
<tr class="separator:a23bb163e51712cdad294aa83487c58dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3c0f99fb71a9d6dfac47dc38b1d916" id="r_aae3c0f99fb71a9d6dfac47dc38b1d916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#aae3c0f99fb71a9d6dfac47dc38b1d916">_onenorm_matrix_power_nnm</a> (A, p)</td></tr>
<tr class="separator:aae3c0f99fb71a9d6dfac47dc38b1d916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29bacfc8dad7a2d4b386b2b64aca8b0" id="r_ac29bacfc8dad7a2d4b386b2b64aca8b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#ac29bacfc8dad7a2d4b386b2b64aca8b0">_is_upper_triangular</a> (A)</td></tr>
<tr class="separator:ac29bacfc8dad7a2d4b386b2b64aca8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcb23d4b6a778bb9d3f4d3d659126b3" id="r_a7fcb23d4b6a778bb9d3f4d3d659126b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#a7fcb23d4b6a778bb9d3f4d3d659126b3">_smart_matrix_product</a> (A, B, <a class="el" href="__blas__subroutines_8h.html#a29dda7d0819a860e921db821deb590c9">alpha</a>=None, structure=None)</td></tr>
<tr class="separator:a7fcb23d4b6a778bb9d3f4d3d659126b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49862cbca6ff0d831695ebda5d04b6e" id="r_ab49862cbca6ff0d831695ebda5d04b6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#ab49862cbca6ff0d831695ebda5d04b6e">_onenormest_matrix_power</a> (A, p, t=2, itmax=5, compute_v=False, compute_w=False, structure=None)</td></tr>
<tr class="separator:ab49862cbca6ff0d831695ebda5d04b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9960b5506eb0d0b0e2feeab0e4a412" id="r_aea9960b5506eb0d0b0e2feeab0e4a412"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#aea9960b5506eb0d0b0e2feeab0e4a412">_onenormest_product</a> (operator_seq, t=2, itmax=5, compute_v=False, compute_w=False, structure=None)</td></tr>
<tr class="separator:aea9960b5506eb0d0b0e2feeab0e4a412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f859882b1048cf958d74ac540b3b24" id="r_a93f859882b1048cf958d74ac540b3b24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#a93f859882b1048cf958d74ac540b3b24">expm</a> (A)</td></tr>
<tr class="separator:a93f859882b1048cf958d74ac540b3b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356bb825e38f1bb2ce63d821dc00dd3c" id="r_a356bb825e38f1bb2ce63d821dc00dd3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#a356bb825e38f1bb2ce63d821dc00dd3c">_expm</a> (A, use_exact_onenorm)</td></tr>
<tr class="separator:a356bb825e38f1bb2ce63d821dc00dd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0896688d08ec5aada93457b4d8863cf2" id="r_a0896688d08ec5aada93457b4d8863cf2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#a0896688d08ec5aada93457b4d8863cf2">_solve_P_Q</a> (U, V, structure=None)</td></tr>
<tr class="separator:a0896688d08ec5aada93457b4d8863cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ebd9f286cbe578566e0fcac398c938" id="r_a73ebd9f286cbe578566e0fcac398c938"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#a73ebd9f286cbe578566e0fcac398c938">_exp_sinch</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, x)</td></tr>
<tr class="separator:a73ebd9f286cbe578566e0fcac398c938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f374a24946f81eead278c8573bc10c" id="r_a18f374a24946f81eead278c8573bc10c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#a18f374a24946f81eead278c8573bc10c">_eq_10_42</a> (lam_1, lam_2, t_12)</td></tr>
<tr class="separator:a18f374a24946f81eead278c8573bc10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe645ac2f986a554855b8b0923bbc8d" id="r_abbe645ac2f986a554855b8b0923bbc8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#abbe645ac2f986a554855b8b0923bbc8d">_fragment_2_1</a> (X, T, s)</td></tr>
<tr class="separator:abbe645ac2f986a554855b8b0923bbc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3494a8eb00309c9bb5f7587b5539de" id="r_afe3494a8eb00309c9bb5f7587b5539de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#afe3494a8eb00309c9bb5f7587b5539de">_ell</a> (A, m)</td></tr>
<tr class="separator:afe3494a8eb00309c9bb5f7587b5539de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae90b773bf9cba0d0fa8c6e785fb0e93e" id="r_ae90b773bf9cba0d0fa8c6e785fb0e93e"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1linalg_1_1__matfuncs.html#ae90b773bf9cba0d0fa8c6e785fb0e93e">UPPER_TRIANGULAR</a> = 'upper_triangular'</td></tr>
<tr class="separator:ae90b773bf9cba0d0fa8c6e785fb0e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Sparse matrix functions
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="afe3494a8eb00309c9bb5f7587b5539de" name="afe3494a8eb00309c9bb5f7587b5539de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3494a8eb00309c9bb5f7587b5539de">&#9670;&#160;</a></span>_ell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._ell </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A helper function for expm_2009.

Parameters
----------
A : linear operator
    A linear operator whose norm of power we care about.
m : int
    The power of the linear operator

Returns
-------
value : int
    A value related to a bound.</pre> <div class="fragment"><div class="line"><span class="lineno">  819</span><span class="keyword">def </span>_ell(A, m):</div>
<div class="line"><span class="lineno">  820</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    A helper function for expm_2009.</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    A : linear operator</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        A linear operator whose norm of power we care about.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    m : int</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        The power of the linear operator</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    value : int</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">        A value related to a bound.</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  836</span>    <span class="keywordflow">if</span> len(A.shape) != 2 <span class="keywordflow">or</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  837</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected A to be like a square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  838</span> </div>
<div class="line"><span class="lineno">  839</span>    <span class="comment"># The c_i are explained in (2.2) and (2.6) of the 2005 expm paper.</span></div>
<div class="line"><span class="lineno">  840</span>    <span class="comment"># They are coefficients of terms of a generating function series expansion.</span></div>
<div class="line"><span class="lineno">  841</span>    c_i = {3: 100800.,</div>
<div class="line"><span class="lineno">  842</span>           5: 10059033600.,</div>
<div class="line"><span class="lineno">  843</span>           7: 4487938430976000.,</div>
<div class="line"><span class="lineno">  844</span>           9: 5914384781877411840000.,</div>
<div class="line"><span class="lineno">  845</span>           13: 113250775606021113483283660800000000.</div>
<div class="line"><span class="lineno">  846</span>           }</div>
<div class="line"><span class="lineno">  847</span>    abs_c_recip = c_i[m]</div>
<div class="line"><span class="lineno">  848</span> </div>
<div class="line"><span class="lineno">  849</span>    <span class="comment"># This is explained after Eq. (1.2) of the 2009 expm paper.</span></div>
<div class="line"><span class="lineno">  850</span>    <span class="comment"># It is the &quot;unit roundoff&quot; of IEEE double precision arithmetic.</span></div>
<div class="line"><span class="lineno">  851</span>    u = 2**-53</div>
<div class="line"><span class="lineno">  852</span> </div>
<div class="line"><span class="lineno">  853</span>    <span class="comment"># Compute the one-norm of matrix power p of abs(A).</span></div>
<div class="line"><span class="lineno">  854</span>    A_abs_onenorm = _onenorm_matrix_power_nnm(abs(A), 2*m + 1)</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span>    <span class="comment"># Treat zero norm as a special case.</span></div>
<div class="line"><span class="lineno">  857</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> A_abs_onenorm:</div>
<div class="line"><span class="lineno">  858</span>        <span class="keywordflow">return</span> 0</div>
<div class="line"><span class="lineno">  859</span> </div>
<div class="line"><span class="lineno">  860</span>    alpha = A_abs_onenorm / (_onenorm(A) * abs_c_recip)</div>
<div class="line"><span class="lineno">  861</span>    log2_alpha_div_u = np.log2(alpha/u)</div>
<div class="line"><span class="lineno">  862</span>    value = int(np.ceil(log2_alpha_div_u / (2 * m)))</div>
<div class="line"><span class="lineno">  863</span>    <span class="keywordflow">return</span> max(value, 0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a18f374a24946f81eead278c8573bc10c" name="a18f374a24946f81eead278c8573bc10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f374a24946f81eead278c8573bc10c">&#9670;&#160;</a></span>_eq_10_42()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._eq_10_42 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lam_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lam_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t_12</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Equation (10.42) of Functions of Matrices: Theory and Computation.

Notes
-----
This is a helper function for _fragment_2_1 of expm_2009.
Equation (10.42) is on page 251 in the section on Schur algorithms.
In particular, section 10.4.3 explains the Schur-Parlett algorithm.
expm([[lam_1, t_12], [0, lam_1])
=
[[exp(lam_1), t_12*exp((lam_1 + lam_2)/2)*sinch((lam_1 - lam_2)/2)],
[0, exp(lam_2)]
</pre> <div class="fragment"><div class="line"><span class="lineno">  746</span><span class="keyword">def </span>_eq_10_42(lam_1, lam_2, t_12):</div>
<div class="line"><span class="lineno">  747</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    Equation (10.42) of Functions of Matrices: Theory and Computation.</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    This is a helper function for _fragment_2_1 of expm_2009.</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    Equation (10.42) is on page 251 in the section on Schur algorithms.</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    In particular, section 10.4.3 explains the Schur-Parlett algorithm.</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    expm([[lam_1, t_12], [0, lam_1])</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    =</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    [[exp(lam_1), t_12*exp((lam_1 + lam_2)/2)*sinch((lam_1 - lam_2)/2)],</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    [0, exp(lam_2)]</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  760</span> </div>
<div class="line"><span class="lineno">  761</span>    <span class="comment"># The plain formula t_12 * (exp(lam_2) - exp(lam_2)) / (lam_2 - lam_1)</span></div>
<div class="line"><span class="lineno">  762</span>    <span class="comment"># apparently suffers from cancellation, according to Higham&#39;s textbook.</span></div>
<div class="line"><span class="lineno">  763</span>    <span class="comment"># A nice implementation of sinch, defined as sinh(x)/x,</span></div>
<div class="line"><span class="lineno">  764</span>    <span class="comment"># will apparently work around the cancellation.</span></div>
<div class="line"><span class="lineno">  765</span>    a = 0.5 * (lam_1 + lam_2)</div>
<div class="line"><span class="lineno">  766</span>    b = 0.5 * (lam_1 - lam_2)</div>
<div class="line"><span class="lineno">  767</span>    <span class="keywordflow">return</span> t_12 * _exp_sinch(a, b)</div>
<div class="line"><span class="lineno">  768</span> </div>
<div class="line"><span class="lineno">  769</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a73ebd9f286cbe578566e0fcac398c938" name="a73ebd9f286cbe578566e0fcac398c938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ebd9f286cbe578566e0fcac398c938">&#9670;&#160;</a></span>_exp_sinch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._exp_sinch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Stably evaluate exp(a)*sinh(x)/x

Notes
-----
The strategy of falling back to a sixth order Taylor expansion
was suggested by the Spallation Neutron Source docs
which was found on the internet by google search.
http://www.ornl.gov/~t6p/resources/xal/javadoc/gov/sns/tools/math/ElementaryFunction.html
The details of the cutoff point and the Horner-like evaluation
was picked without reference to anything in particular.

Note that sinch is not currently implemented in scipy.special,
whereas the "engineer's" definition of sinc is implemented.
The implementation of sinc involves a scaling factor of pi
that distinguishes it from the "mathematician's" version of sinc.</pre> <div class="fragment"><div class="line"><span class="lineno">  715</span><span class="keyword">def </span>_exp_sinch(a, x):</div>
<div class="line"><span class="lineno">  716</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    Stably evaluate exp(a)*sinh(x)/x</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    The strategy of falling back to a sixth order Taylor expansion</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    was suggested by the Spallation Neutron Source docs</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    which was found on the internet by google search.</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    http://www.ornl.gov/~t6p/resources/xal/javadoc/gov/sns/tools/math/ElementaryFunction.html</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    The details of the cutoff point and the Horner-like evaluation</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    was picked without reference to anything in particular.</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    Note that sinch is not currently implemented in scipy.special,</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    whereas the &quot;engineer&#39;s&quot; definition of sinc is implemented.</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    The implementation of sinc involves a scaling factor of pi</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    that distinguishes it from the &quot;mathematician&#39;s&quot; version of sinc.</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  734</span> </div>
<div class="line"><span class="lineno">  735</span>    <span class="comment"># If x is small then use sixth order Taylor expansion.</span></div>
<div class="line"><span class="lineno">  736</span>    <span class="comment"># How small is small? I am using the point where the relative error</span></div>
<div class="line"><span class="lineno">  737</span>    <span class="comment"># of the approximation is less than 1e-14.</span></div>
<div class="line"><span class="lineno">  738</span>    <span class="comment"># If x is large then directly evaluate sinh(x) / x.</span></div>
<div class="line"><span class="lineno">  739</span>    <span class="keywordflow">if</span> abs(x) &lt; 0.0135:</div>
<div class="line"><span class="lineno">  740</span>        x2 = x*x</div>
<div class="line"><span class="lineno">  741</span>        <span class="keywordflow">return</span> np.exp(a) * (1 + (x2/6.)*(1 + (x2/20.)*(1 + (x2/42.))))</div>
<div class="line"><span class="lineno">  742</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  743</span>        <span class="keywordflow">return</span> (np.exp(a + x) - np.exp(a - x)) / (2*x)</div>
<div class="line"><span class="lineno">  744</span> </div>
<div class="line"><span class="lineno">  745</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a356bb825e38f1bb2ce63d821dc00dd3c" name="a356bb825e38f1bb2ce63d821dc00dd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356bb825e38f1bb2ce63d821dc00dd3c">&#9670;&#160;</a></span>_expm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._expm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_exact_onenorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  593</span><span class="keyword">def </span>_expm(A, use_exact_onenorm):</div>
<div class="line"><span class="lineno">  594</span>    <span class="comment"># Core of expm, separated to allow testing exact and approximate</span></div>
<div class="line"><span class="lineno">  595</span>    <span class="comment"># algorithms.</span></div>
<div class="line"><span class="lineno">  596</span> </div>
<div class="line"><span class="lineno">  597</span>    <span class="comment"># Avoid indiscriminate asarray() to allow sparse or other strange arrays.</span></div>
<div class="line"><span class="lineno">  598</span>    <span class="keywordflow">if</span> isinstance(A, (list, tuple, np.matrix)):</div>
<div class="line"><span class="lineno">  599</span>        A = np.asarray(A)</div>
<div class="line"><span class="lineno">  600</span>    <span class="keywordflow">if</span> len(A.shape) != 2 <span class="keywordflow">or</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  601</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected a square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>    <span class="comment"># gracefully handle size-0 input,</span></div>
<div class="line"><span class="lineno">  604</span>    <span class="comment"># carefully handling sparse scenario</span></div>
<div class="line"><span class="lineno">  605</span>    <span class="keywordflow">if</span> A.shape == (0, 0):</div>
<div class="line"><span class="lineno">  606</span>        out = np.zeros([0, 0], dtype=A.dtype)</div>
<div class="line"><span class="lineno">  607</span>        <span class="keywordflow">if</span> isspmatrix(A) <span class="keywordflow">or</span> is_pydata_spmatrix(A):</div>
<div class="line"><span class="lineno">  608</span>            <span class="keywordflow">return</span> A.__class__(out)</div>
<div class="line"><span class="lineno">  609</span>        <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  610</span> </div>
<div class="line"><span class="lineno">  611</span>    <span class="comment"># Trivial case</span></div>
<div class="line"><span class="lineno">  612</span>    <span class="keywordflow">if</span> A.shape == (1, 1):</div>
<div class="line"><span class="lineno">  613</span>        out = [[np.exp(A[0, 0])]]</div>
<div class="line"><span class="lineno">  614</span> </div>
<div class="line"><span class="lineno">  615</span>        <span class="comment"># Avoid indiscriminate casting to ndarray to</span></div>
<div class="line"><span class="lineno">  616</span>        <span class="comment"># allow for sparse or other strange arrays</span></div>
<div class="line"><span class="lineno">  617</span>        <span class="keywordflow">if</span> isspmatrix(A) <span class="keywordflow">or</span> is_pydata_spmatrix(A):</div>
<div class="line"><span class="lineno">  618</span>            <span class="keywordflow">return</span> A.__class__(out)</div>
<div class="line"><span class="lineno">  619</span> </div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">return</span> np.array(out)</div>
<div class="line"><span class="lineno">  621</span> </div>
<div class="line"><span class="lineno">  622</span>    <span class="comment"># Ensure input is of float type, to avoid integer overflows etc.</span></div>
<div class="line"><span class="lineno">  623</span>    <span class="keywordflow">if</span> ((isinstance(A, np.ndarray) <span class="keywordflow">or</span> isspmatrix(A) <span class="keywordflow">or</span> is_pydata_spmatrix(A))</div>
<div class="line"><span class="lineno">  624</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.issubdtype(A.dtype, np.inexact)):</div>
<div class="line"><span class="lineno">  625</span>        A = A.astype(float)</div>
<div class="line"><span class="lineno">  626</span> </div>
<div class="line"><span class="lineno">  627</span>    <span class="comment"># Detect upper triangularity.</span></div>
<div class="line"><span class="lineno">  628</span>    structure = UPPER_TRIANGULAR <span class="keywordflow">if</span> _is_upper_triangular(A) <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  629</span> </div>
<div class="line"><span class="lineno">  630</span>    <span class="keywordflow">if</span> use_exact_onenorm == <span class="stringliteral">&quot;auto&quot;</span>:</div>
<div class="line"><span class="lineno">  631</span>        <span class="comment"># Hardcode a matrix order threshold for exact vs. estimated one-norms.</span></div>
<div class="line"><span class="lineno">  632</span>        use_exact_onenorm = A.shape[0] &lt; 200</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span>    <span class="comment"># Track functions of A to help compute the matrix exponential.</span></div>
<div class="line"><span class="lineno">  635</span>    h = _ExpmPadeHelper(</div>
<div class="line"><span class="lineno">  636</span>            A, structure=structure, use_exact_onenorm=use_exact_onenorm)</div>
<div class="line"><span class="lineno">  637</span> </div>
<div class="line"><span class="lineno">  638</span>    <span class="comment"># Try Pade order 3.</span></div>
<div class="line"><span class="lineno">  639</span>    eta_1 = max(h.d4_loose, h.d6_loose)</div>
<div class="line"><span class="lineno">  640</span>    <span class="keywordflow">if</span> eta_1 &lt; 1.495585217958292e-002 <span class="keywordflow">and</span> _ell(h.A, 3) == 0:</div>
<div class="line"><span class="lineno">  641</span>        U, V = h.pade3()</div>
<div class="line"><span class="lineno">  642</span>        <span class="keywordflow">return</span> _solve_P_Q(U, V, structure=structure)</div>
<div class="line"><span class="lineno">  643</span> </div>
<div class="line"><span class="lineno">  644</span>    <span class="comment"># Try Pade order 5.</span></div>
<div class="line"><span class="lineno">  645</span>    eta_2 = max(h.d4_tight, h.d6_loose)</div>
<div class="line"><span class="lineno">  646</span>    <span class="keywordflow">if</span> eta_2 &lt; 2.539398330063230e-001 <span class="keywordflow">and</span> _ell(h.A, 5) == 0:</div>
<div class="line"><span class="lineno">  647</span>        U, V = h.pade5()</div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">return</span> _solve_P_Q(U, V, structure=structure)</div>
<div class="line"><span class="lineno">  649</span> </div>
<div class="line"><span class="lineno">  650</span>    <span class="comment"># Try Pade orders 7 and 9.</span></div>
<div class="line"><span class="lineno">  651</span>    eta_3 = max(h.d6_tight, h.d8_loose)</div>
<div class="line"><span class="lineno">  652</span>    <span class="keywordflow">if</span> eta_3 &lt; 9.504178996162932e-001 <span class="keywordflow">and</span> _ell(h.A, 7) == 0:</div>
<div class="line"><span class="lineno">  653</span>        U, V = h.pade7()</div>
<div class="line"><span class="lineno">  654</span>        <span class="keywordflow">return</span> _solve_P_Q(U, V, structure=structure)</div>
<div class="line"><span class="lineno">  655</span>    <span class="keywordflow">if</span> eta_3 &lt; 2.097847961257068e+000 <span class="keywordflow">and</span> _ell(h.A, 9) == 0:</div>
<div class="line"><span class="lineno">  656</span>        U, V = h.pade9()</div>
<div class="line"><span class="lineno">  657</span>        <span class="keywordflow">return</span> _solve_P_Q(U, V, structure=structure)</div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span>    <span class="comment"># Use Pade order 13.</span></div>
<div class="line"><span class="lineno">  660</span>    eta_4 = max(h.d8_loose, h.d10_loose)</div>
<div class="line"><span class="lineno">  661</span>    eta_5 = min(eta_3, eta_4)</div>
<div class="line"><span class="lineno">  662</span>    theta_13 = 4.25</div>
<div class="line"><span class="lineno">  663</span> </div>
<div class="line"><span class="lineno">  664</span>    <span class="comment"># Choose smallest s&gt;=0 such that 2**(-s) eta_5 &lt;= theta_13</span></div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">if</span> eta_5 == 0:</div>
<div class="line"><span class="lineno">  666</span>        <span class="comment"># Nilpotent special case</span></div>
<div class="line"><span class="lineno">  667</span>        s = 0</div>
<div class="line"><span class="lineno">  668</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  669</span>        s = max(int(np.ceil(np.log2(eta_5 / theta_13))), 0)</div>
<div class="line"><span class="lineno">  670</span>    s = s + _ell(2**-s * h.A, 13)</div>
<div class="line"><span class="lineno">  671</span>    U, V = h.pade13_scaled(s)</div>
<div class="line"><span class="lineno">  672</span>    X = _solve_P_Q(U, V, structure=structure)</div>
<div class="line"><span class="lineno">  673</span>    <span class="keywordflow">if</span> structure == UPPER_TRIANGULAR:</div>
<div class="line"><span class="lineno">  674</span>        <span class="comment"># Invoke Code Fragment 2.1.</span></div>
<div class="line"><span class="lineno">  675</span>        X = _fragment_2_1(X, h.A, s)</div>
<div class="line"><span class="lineno">  676</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  677</span>        <span class="comment"># X = r_13(A)^(2^s) by repeated squaring.</span></div>
<div class="line"><span class="lineno">  678</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(s):</div>
<div class="line"><span class="lineno">  679</span>            X = X.dot(X)</div>
<div class="line"><span class="lineno">  680</span>    <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno">  681</span> </div>
<div class="line"><span class="lineno">  682</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abbe645ac2f986a554855b8b0923bbc8d" name="abbe645ac2f986a554855b8b0923bbc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe645ac2f986a554855b8b0923bbc8d">&#9670;&#160;</a></span>_fragment_2_1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._fragment_2_1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A helper function for expm_2009.

Notes
-----
The argument X is modified in-place, but this modification is not the same
as the returned value of the function.
This function also takes pains to do things in ways that are compatible
with sparse matrices, for example by avoiding fancy indexing
and by using methods of the matrices whenever possible instead of
using functions of the numpy or scipy libraries themselves.</pre> <div class="fragment"><div class="line"><span class="lineno">  770</span><span class="keyword">def </span>_fragment_2_1(X, T, s):</div>
<div class="line"><span class="lineno">  771</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    A helper function for expm_2009.</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    The argument X is modified in-place, but this modification is not the same</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    as the returned value of the function.</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    This function also takes pains to do things in ways that are compatible</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    with sparse matrices, for example by avoiding fancy indexing</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    and by using methods of the matrices whenever possible instead of</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    using functions of the numpy or scipy libraries themselves.</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  784</span>    <span class="comment"># Form X = r_m(2^-s T)</span></div>
<div class="line"><span class="lineno">  785</span>    <span class="comment"># Replace diag(X) by exp(2^-s diag(T)).</span></div>
<div class="line"><span class="lineno">  786</span>    n = X.shape[0]</div>
<div class="line"><span class="lineno">  787</span>    diag_T = np.ravel(T.diagonal().copy())</div>
<div class="line"><span class="lineno">  788</span> </div>
<div class="line"><span class="lineno">  789</span>    <span class="comment"># Replace diag(X) by exp(2^-s diag(T)).</span></div>
<div class="line"><span class="lineno">  790</span>    scale = 2 ** -s</div>
<div class="line"><span class="lineno">  791</span>    exp_diag = np.exp(scale * diag_T)</div>
<div class="line"><span class="lineno">  792</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">  793</span>        X[k, k] = exp_diag[k]</div>
<div class="line"><span class="lineno">  794</span> </div>
<div class="line"><span class="lineno">  795</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(s-1, -1, -1):</div>
<div class="line"><span class="lineno">  796</span>        X = X.dot(X)</div>
<div class="line"><span class="lineno">  797</span> </div>
<div class="line"><span class="lineno">  798</span>        <span class="comment"># Replace diag(X) by exp(2^-i diag(T)).</span></div>
<div class="line"><span class="lineno">  799</span>        scale = 2 ** -i</div>
<div class="line"><span class="lineno">  800</span>        exp_diag = np.exp(scale * diag_T)</div>
<div class="line"><span class="lineno">  801</span>        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">  802</span>            X[k, k] = exp_diag[k]</div>
<div class="line"><span class="lineno">  803</span> </div>
<div class="line"><span class="lineno">  804</span>        <span class="comment"># Replace (first) superdiagonal of X by explicit formula</span></div>
<div class="line"><span class="lineno">  805</span>        <span class="comment"># for superdiagonal of exp(2^-i T) from Eq (10.42) of</span></div>
<div class="line"><span class="lineno">  806</span>        <span class="comment"># the author&#39;s 2008 textbook</span></div>
<div class="line"><span class="lineno">  807</span>        <span class="comment"># Functions of Matrices: Theory and Computation.</span></div>
<div class="line"><span class="lineno">  808</span>        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(n-1):</div>
<div class="line"><span class="lineno">  809</span>            lam_1 = scale * diag_T[k]</div>
<div class="line"><span class="lineno">  810</span>            lam_2 = scale * diag_T[k+1]</div>
<div class="line"><span class="lineno">  811</span>            t_12 = scale * T[k, k+1]</div>
<div class="line"><span class="lineno">  812</span>            value = _eq_10_42(lam_1, lam_2, t_12)</div>
<div class="line"><span class="lineno">  813</span>            X[k, k+1] = value</div>
<div class="line"><span class="lineno">  814</span> </div>
<div class="line"><span class="lineno">  815</span>    <span class="comment"># Return the updated X matrix.</span></div>
<div class="line"><span class="lineno">  816</span>    <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac29bacfc8dad7a2d4b386b2b64aca8b0" name="ac29bacfc8dad7a2d4b386b2b64aca8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29bacfc8dad7a2d4b386b2b64aca8b0">&#9670;&#160;</a></span>_is_upper_triangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._is_upper_triangular </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  112</span><span class="keyword">def </span>_is_upper_triangular(A):</div>
<div class="line"><span class="lineno">  113</span>    <span class="comment"># This function could possibly be of wider interest.</span></div>
<div class="line"><span class="lineno">  114</span>    <span class="keywordflow">if</span> isspmatrix(A):</div>
<div class="line"><span class="lineno">  115</span>        lower_part = scipy.sparse.tril(A, -1)</div>
<div class="line"><span class="lineno">  116</span>        <span class="comment"># Check structural upper triangularity,</span></div>
<div class="line"><span class="lineno">  117</span>        <span class="comment"># then coincidental upper triangularity if needed.</span></div>
<div class="line"><span class="lineno">  118</span>        <span class="keywordflow">return</span> lower_part.nnz == 0 <span class="keywordflow">or</span> lower_part.count_nonzero() == 0</div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">elif</span> is_pydata_spmatrix(A):</div>
<div class="line"><span class="lineno">  120</span>        <span class="keyword">import</span> sparse</div>
<div class="line"><span class="lineno">  121</span>        lower_part = sparse.tril(A, -1)</div>
<div class="line"><span class="lineno">  122</span>        <span class="keywordflow">return</span> lower_part.nnz == 0</div>
<div class="line"><span class="lineno">  123</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  124</span>        <span class="keywordflow">return</span> <span class="keywordflow">not</span> np.tril(A, -1).any()</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae3c0f99fb71a9d6dfac47dc38b1d916" name="aae3c0f99fb71a9d6dfac47dc38b1d916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3c0f99fb71a9d6dfac47dc38b1d916">&#9670;&#160;</a></span>_onenorm_matrix_power_nnm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._onenorm_matrix_power_nnm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the 1-norm of a non-negative integer power of a non-negative matrix.

Parameters
----------
A : a square ndarray or matrix or sparse matrix
    Input matrix with non-negative entries.
p : non-negative integer
    The power to which the matrix is to be raised.

Returns
-------
out : float
    The 1-norm of the matrix power p of A.</pre> <div class="fragment"><div class="line"><span class="lineno">   79</span><span class="keyword">def </span>_onenorm_matrix_power_nnm(A, p):</div>
<div class="line"><span class="lineno">   80</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    Compute the 1-norm of a non-negative integer power of a non-negative matrix.</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    A : a square ndarray or matrix or sparse matrix</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        Input matrix with non-negative entries.</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    p : non-negative integer</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        The power to which the matrix is to be raised.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    out : float</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        The 1-norm of the matrix power p of A.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   96</span>    <span class="comment"># Check input</span></div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">if</span> int(p) != p <span class="keywordflow">or</span> p &lt; 0:</div>
<div class="line"><span class="lineno">   98</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected non-negative integer p&#39;</span>)</div>
<div class="line"><span class="lineno">   99</span>    p = int(p)</div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">if</span> len(A.shape) != 2 <span class="keywordflow">or</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  101</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected A to be like a square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  102</span> </div>
<div class="line"><span class="lineno">  103</span>    <span class="comment"># Explicitly make a column vector so that this works when A is a</span></div>
<div class="line"><span class="lineno">  104</span>    <span class="comment"># numpy matrix (in addition to ndarray and sparse matrix).</span></div>
<div class="line"><span class="lineno">  105</span>    v = np.ones((A.shape[0], 1), dtype=float)</div>
<div class="line"><span class="lineno">  106</span>    M = A.T</div>
<div class="line"><span class="lineno">  107</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(p):</div>
<div class="line"><span class="lineno">  108</span>        v = M.dot(v)</div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordflow">return</span> np.max(v)</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab49862cbca6ff0d831695ebda5d04b6e" name="ab49862cbca6ff0d831695ebda5d04b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49862cbca6ff0d831695ebda5d04b6e">&#9670;&#160;</a></span>_onenormest_matrix_power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._onenormest_matrix_power </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>itmax</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_v</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_w</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Efficiently estimate the 1-norm of A^p.

Parameters
----------
A : ndarray
    Matrix whose 1-norm of a power is to be computed.
p : int
    Non-negative integer power.
t : int, optional
    A positive parameter controlling the tradeoff between
    accuracy versus time and memory usage.
    Larger values take longer and use more memory
    but give more accurate output.
itmax : int, optional
    Use at most this many iterations.
compute_v : bool, optional
    Request a norm-maximizing linear operator input vector if True.
compute_w : bool, optional
    Request a norm-maximizing linear operator output vector if True.

Returns
-------
est : float
    An underestimate of the 1-norm of the sparse matrix.
v : ndarray, optional
    The vector such that ||Av||_1 == est*||v||_1.
    It can be thought of as an input to the linear operator
    that gives an output with particularly large norm.
w : ndarray, optional
    The vector Av which has relatively large 1-norm.
    It can be thought of as an output of the linear operator
    that is relatively large in norm compared to the input.</pre> <div class="fragment"><div class="line"><span class="lineno">  254</span>        t=2, itmax=5, compute_v=<span class="keyword">False</span>, compute_w=<span class="keyword">False</span>, structure=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  255</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    Efficiently estimate the 1-norm of A^p.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    A : ndarray</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        Matrix whose 1-norm of a power is to be computed.</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    p : int</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">        Non-negative integer power.</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    t : int, optional</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">        A positive parameter controlling the tradeoff between</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">        accuracy versus time and memory usage.</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">        Larger values take longer and use more memory</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        but give more accurate output.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    itmax : int, optional</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">        Use at most this many iterations.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    compute_v : bool, optional</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        Request a norm-maximizing linear operator input vector if True.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    compute_w : bool, optional</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        Request a norm-maximizing linear operator output vector if True.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    est : float</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        An underestimate of the 1-norm of the sparse matrix.</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    v : ndarray, optional</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        The vector such that ||Av||_1 == est*||v||_1.</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        It can be thought of as an input to the linear operator</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        that gives an output with particularly large norm.</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    w : ndarray, optional</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        The vector Av which has relatively large 1-norm.</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        It can be thought of as an output of the linear operator</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">        that is relatively large in norm compared to the input.</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  290</span>    <span class="keywordflow">return</span> scipy.sparse.linalg.onenormest(</div>
<div class="line"><span class="lineno">  291</span>            MatrixPowerOperator(A, p, structure=structure))</div>
<div class="line"><span class="lineno">  292</span> </div>
<div class="line"><span class="lineno">  293</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aea9960b5506eb0d0b0e2feeab0e4a412" name="aea9960b5506eb0d0b0e2feeab0e4a412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9960b5506eb0d0b0e2feeab0e4a412">&#9670;&#160;</a></span>_onenormest_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._onenormest_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>operator_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>itmax</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_v</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_w</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Efficiently estimate the 1-norm of the matrix product of the args.

Parameters
----------
operator_seq : linear operator sequence
    Matrices whose 1-norm of product is to be computed.
t : int, optional
    A positive parameter controlling the tradeoff between
    accuracy versus time and memory usage.
    Larger values take longer and use more memory
    but give more accurate output.
itmax : int, optional
    Use at most this many iterations.
compute_v : bool, optional
    Request a norm-maximizing linear operator input vector if True.
compute_w : bool, optional
    Request a norm-maximizing linear operator output vector if True.
structure : str, optional
    A string describing the structure of all operators.
    Only `upper_triangular` is currently supported.

Returns
-------
est : float
    An underestimate of the 1-norm of the sparse matrix.
v : ndarray, optional
    The vector such that ||Av||_1 == est*||v||_1.
    It can be thought of as an input to the linear operator
    that gives an output with particularly large norm.
w : ndarray, optional
    The vector Av which has relatively large 1-norm.
    It can be thought of as an output of the linear operator
    that is relatively large in norm compared to the input.</pre> <div class="fragment"><div class="line"><span class="lineno">  295</span>        t=2, itmax=5, compute_v=<span class="keyword">False</span>, compute_w=<span class="keyword">False</span>, structure=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  296</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    Efficiently estimate the 1-norm of the matrix product of the args.</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    operator_seq : linear operator sequence</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">        Matrices whose 1-norm of product is to be computed.</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    t : int, optional</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        A positive parameter controlling the tradeoff between</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        accuracy versus time and memory usage.</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">        Larger values take longer and use more memory</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        but give more accurate output.</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    itmax : int, optional</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">        Use at most this many iterations.</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    compute_v : bool, optional</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        Request a norm-maximizing linear operator input vector if True.</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    compute_w : bool, optional</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        Request a norm-maximizing linear operator output vector if True.</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    structure : str, optional</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        A string describing the structure of all operators.</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">        Only `upper_triangular` is currently supported.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    est : float</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        An underestimate of the 1-norm of the sparse matrix.</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    v : ndarray, optional</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">        The vector such that ||Av||_1 == est*||v||_1.</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        It can be thought of as an input to the linear operator</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        that gives an output with particularly large norm.</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    w : ndarray, optional</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        The vector Av which has relatively large 1-norm.</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">        It can be thought of as an output of the linear operator</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        that is relatively large in norm compared to the input.</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  332</span>    <span class="keywordflow">return</span> scipy.sparse.linalg.onenormest(</div>
<div class="line"><span class="lineno">  333</span>            ProductOperator(*operator_seq, structure=structure))</div>
<div class="line"><span class="lineno">  334</span> </div>
<div class="line"><span class="lineno">  335</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7fcb23d4b6a778bb9d3f4d3d659126b3" name="a7fcb23d4b6a778bb9d3f4d3d659126b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcb23d4b6a778bb9d3f4d3d659126b3">&#9670;&#160;</a></span>_smart_matrix_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._smart_matrix_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A matrix product that knows about sparse and structured matrices.

Parameters
----------
A : 2d ndarray
    First matrix.
B : 2d ndarray
    Second matrix.
alpha : float
    The matrix product will be scaled by this constant.
structure : str, optional
    A string describing the structure of both matrices `A` and `B`.
    Only `upper_triangular` is currently supported.

Returns
-------
M : 2d ndarray
    Matrix product of A and B.</pre> <div class="fragment"><div class="line"><span class="lineno">  127</span><span class="keyword">def </span>_smart_matrix_product(A, B, alpha=None, structure=None):</div>
<div class="line"><span class="lineno">  128</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    A matrix product that knows about sparse and structured matrices.</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    A : 2d ndarray</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">        First matrix.</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    B : 2d ndarray</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        Second matrix.</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    alpha : float</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        The matrix product will be scaled by this constant.</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    structure : str, optional</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        A string describing the structure of both matrices `A` and `B`.</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        Only `upper_triangular` is currently supported.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    M : 2d ndarray</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">        Matrix product of A and B.</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">if</span> len(A.shape) != 2:</div>
<div class="line"><span class="lineno">  150</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected A to be a rectangular matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordflow">if</span> len(B.shape) != 2:</div>
<div class="line"><span class="lineno">  152</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected B to be a rectangular matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  153</span>    f = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">if</span> structure == UPPER_TRIANGULAR:</div>
<div class="line"><span class="lineno">  155</span>        <span class="keywordflow">if</span> (<span class="keywordflow">not</span> isspmatrix(A) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isspmatrix(B)</div>
<div class="line"><span class="lineno">  156</span>                <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_pydata_spmatrix(A) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_pydata_spmatrix(B)):</div>
<div class="line"><span class="lineno">  157</span>            f, = scipy.linalg.get_blas_funcs((<span class="stringliteral">&#39;trmm&#39;</span>,), (A, B))</div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">if</span> f <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  160</span>            alpha = 1.</div>
<div class="line"><span class="lineno">  161</span>        out = <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(alpha, A, B)</div>
<div class="line"><span class="lineno">  162</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  163</span>        <span class="keywordflow">if</span> alpha <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  164</span>            out = A.dot(B)</div>
<div class="line"><span class="lineno">  165</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  166</span>            out = alpha * A.dot(B)</div>
<div class="line"><span class="lineno">  167</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_af01a903df7bdb7a494f5827e45bf3a2a"><div class="ttname"><a href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a></div><div class="ttdeci">void int int int int npy_complex64 int int npy_complex64 float float npy_complex64 npy_complex64 * f</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:262</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0896688d08ec5aada93457b4d8863cf2" name="a0896688d08ec5aada93457b4d8863cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0896688d08ec5aada93457b4d8863cf2">&#9670;&#160;</a></span>_solve_P_Q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs._solve_P_Q </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A helper function for expm_2009.

Parameters
----------
U : ndarray
    Pade numerator.
V : ndarray
    Pade denominator.
structure : str, optional
    A string describing the structure of both matrices `U` and `V`.
    Only `upper_triangular` is currently supported.

Notes
-----
The `structure` argument is inspired by similar args
for theano and cvxopt functions.</pre> <div class="fragment"><div class="line"><span class="lineno">  683</span><span class="keyword">def </span>_solve_P_Q(U, V, structure=None):</div>
<div class="line"><span class="lineno">  684</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    A helper function for expm_2009.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    U : ndarray</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">        Pade numerator.</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    V : ndarray</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">        Pade denominator.</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    structure : str, optional</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        A string describing the structure of both matrices `U` and `V`.</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        Only `upper_triangular` is currently supported.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    The `structure` argument is inspired by similar args</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    for theano and cvxopt functions.</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  703</span>    P = U + V</div>
<div class="line"><span class="lineno">  704</span>    Q = -U + V</div>
<div class="line"><span class="lineno">  705</span>    <span class="keywordflow">if</span> isspmatrix(U) <span class="keywordflow">or</span> is_pydata_spmatrix(U):</div>
<div class="line"><span class="lineno">  706</span>        <span class="keywordflow">return</span> spsolve(Q, P)</div>
<div class="line"><span class="lineno">  707</span>    <span class="keywordflow">elif</span> structure <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  708</span>        <span class="keywordflow">return</span> solve(Q, P)</div>
<div class="line"><span class="lineno">  709</span>    <span class="keywordflow">elif</span> structure == UPPER_TRIANGULAR:</div>
<div class="line"><span class="lineno">  710</span>        <span class="keywordflow">return</span> solve_triangular(Q, P)</div>
<div class="line"><span class="lineno">  711</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  712</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;unsupported matrix structure: &#39;</span> + str(structure))</div>
<div class="line"><span class="lineno">  713</span> </div>
<div class="line"><span class="lineno">  714</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a93f859882b1048cf958d74ac540b3b24" name="a93f859882b1048cf958d74ac540b3b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f859882b1048cf958d74ac540b3b24">&#9670;&#160;</a></span>expm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs.expm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the matrix exponential using Pade approximation.

Parameters
----------
A : (M,M) array_like or sparse matrix
    2D Array or Matrix (sparse or dense) to be exponentiated

Returns
-------
expA : (M,M) ndarray
    Matrix exponential of `A`

Notes
-----
This is algorithm (6.1) which is a simplification of algorithm (5.1).

.. versionadded:: 0.12.0

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       "A New Scaling and Squaring Algorithm for the Matrix Exponential."
       SIAM Journal on Matrix Analysis and Applications.
       31 (3). pp. 970-989. ISSN 1095-7162

Examples
--------
&gt;&gt;&gt; from scipy.sparse import csc_matrix
&gt;&gt;&gt; from scipy.sparse.linalg import expm
&gt;&gt;&gt; A = csc_matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])
&gt;&gt;&gt; A.toarray()
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]], dtype=int64)
&gt;&gt;&gt; Aexp = expm(A)
&gt;&gt;&gt; Aexp
&lt;3x3 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
    with 3 stored elements in Compressed Sparse Column format&gt;
&gt;&gt;&gt; Aexp.toarray()
array([[  2.71828183,   0.        ,   0.        ],
       [  0.        ,   7.3890561 ,   0.        ],
       [  0.        ,   0.        ,  20.08553692]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  545</span><span class="keyword">def </span>expm(A):</div>
<div class="line"><span class="lineno">  546</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    Compute the matrix exponential using Pade approximation.</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    A : (M,M) array_like or sparse matrix</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">        2D Array or Matrix (sparse or dense) to be exponentiated</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    expA : (M,M) ndarray</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">        Matrix exponential of `A`</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    This is algorithm (6.1) which is a simplification of algorithm (5.1).</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    .. versionadded:: 0.12.0</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">           &quot;A New Scaling and Squaring Algorithm for the Matrix Exponential.&quot;</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications.</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">           31 (3). pp. 970-989. ISSN 1095-7162</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import csc_matrix</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse.linalg import expm</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    &gt;&gt;&gt; A = csc_matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    &gt;&gt;&gt; A.toarray()</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    array([[1, 0, 0],</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">           [0, 2, 0],</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">           [0, 0, 3]], dtype=int64)</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    &gt;&gt;&gt; Aexp = expm(A)</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    &gt;&gt;&gt; Aexp</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    &lt;3x3 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        with 3 stored elements in Compressed Sparse Column format&gt;</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    &gt;&gt;&gt; Aexp.toarray()</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    array([[  2.71828183,   0.        ,   0.        ],</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">           [  0.        ,   7.3890561 ,   0.        ],</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">           [  0.        ,   0.        ,  20.08553692]])</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  590</span>    <span class="keywordflow">return</span> _expm(A, use_exact_onenorm=<span class="stringliteral">&#39;auto&#39;</span>)</div>
<div class="line"><span class="lineno">  591</span> </div>
<div class="line"><span class="lineno">  592</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a23bb163e51712cdad294aa83487c58dc" name="a23bb163e51712cdad294aa83487c58dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bb163e51712cdad294aa83487c58dc">&#9670;&#160;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._matfuncs.inv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the inverse of a sparse matrix

Parameters
----------
A : (M, M) sparse matrix
    square matrix to be inverted

Returns
-------
Ainv : (M, M) sparse matrix
    inverse of `A`

Notes
-----
This computes the sparse inverse of `A`. If the inverse of `A` is expected
to be non-sparse, it will likely be faster to convert `A` to dense and use
`scipy.linalg.inv`.

Examples
--------
&gt;&gt;&gt; from scipy.sparse import csc_matrix
&gt;&gt;&gt; from scipy.sparse.linalg import inv
&gt;&gt;&gt; A = csc_matrix([[1., 0.], [1., 2.]])
&gt;&gt;&gt; Ainv = inv(A)
&gt;&gt;&gt; Ainv
&lt;2x2 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
    with 3 stored elements in Compressed Sparse Column format&gt;
&gt;&gt;&gt; A.dot(Ainv)
&lt;2x2 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
    with 2 stored elements in Compressed Sparse Column format&gt;
&gt;&gt;&gt; A.dot(Ainv).toarray()
array([[ 1.,  0.],
       [ 0.,  1.]])

.. versionadded:: 0.12.0</pre> <div class="fragment"><div class="line"><span class="lineno">   30</span><span class="keyword">def </span>inv(A):</div>
<div class="line"><span class="lineno">   31</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    Compute the inverse of a sparse matrix</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    A : (M, M) sparse matrix</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        square matrix to be inverted</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    Ainv : (M, M) sparse matrix</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        inverse of `A`</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    This computes the sparse inverse of `A`. If the inverse of `A` is expected</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    to be non-sparse, it will likely be faster to convert `A` to dense and use</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    `scipy.linalg.inv`.</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import csc_matrix</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse.linalg import inv</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    &gt;&gt;&gt; A = csc_matrix([[1., 0.], [1., 2.]])</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    &gt;&gt;&gt; Ainv = inv(A)</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    &gt;&gt;&gt; Ainv</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    &lt;2x2 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        with 3 stored elements in Compressed Sparse Column format&gt;</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    &gt;&gt;&gt; A.dot(Ainv)</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    &lt;2x2 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        with 2 stored elements in Compressed Sparse Column format&gt;</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    &gt;&gt;&gt; A.dot(Ainv).toarray()</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    array([[ 1.,  0.],</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">           [ 0.,  1.]])</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    .. versionadded:: 0.12.0</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   69</span>    <span class="comment"># Check input</span></div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (scipy.sparse.isspmatrix(A) <span class="keywordflow">or</span> is_pydata_spmatrix(A)):</div>
<div class="line"><span class="lineno">   71</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;Input must be a sparse matrix&#39;</span>)</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    <span class="comment"># Use sparse direct solver to solve &quot;AX = I&quot; accurately</span></div>
<div class="line"><span class="lineno">   74</span>    I = _ident_like(A)</div>
<div class="line"><span class="lineno">   75</span>    Ainv = spsolve(A, I)</div>
<div class="line"><span class="lineno">   76</span>    <span class="keywordflow">return</span> Ainv</div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae90b773bf9cba0d0fa8c6e785fb0e93e" name="ae90b773bf9cba0d0fa8c6e785fb0e93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90b773bf9cba0d0fa8c6e785fb0e93e">&#9670;&#160;</a></span>UPPER_TRIANGULAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str scipy.sparse.linalg._matfuncs.UPPER_TRIANGULAR = 'upper_triangular'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
