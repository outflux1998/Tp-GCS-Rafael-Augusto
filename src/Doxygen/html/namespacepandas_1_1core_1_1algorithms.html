<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.algorithms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html">algorithms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.algorithms Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1algorithms_1_1_select_n.html">SelectN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1algorithms_1_1_select_n_frame.html">SelectNFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1algorithms_1_1_select_n_series.html">SelectNSeries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a874d39e4200cf44ffe3d92f229ffb058" id="r_a874d39e4200cf44ffe3d92f229ffb058"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a874d39e4200cf44ffe3d92f229ffb058">_ensure_data</a> (ArrayLike values)</td></tr>
<tr class="separator:a874d39e4200cf44ffe3d92f229ffb058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc56a5f7c5c53e4c93b3f64a2be1966" id="r_a7cc56a5f7c5c53e4c93b3f64a2be1966"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a7cc56a5f7c5c53e4c93b3f64a2be1966">_reconstruct_data</a> (ArrayLike values, DtypeObj dtype, AnyArrayLike original)</td></tr>
<tr class="separator:a7cc56a5f7c5c53e4c93b3f64a2be1966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8625e137d8c86211e15af330b0eb62d7" id="r_a8625e137d8c86211e15af330b0eb62d7"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a8625e137d8c86211e15af330b0eb62d7">_ensure_arraylike</a> (values)</td></tr>
<tr class="separator:a8625e137d8c86211e15af330b0eb62d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c1f2997367be47d8e23ab79fb93c98" id="r_a42c1f2997367be47d8e23ab79fb93c98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a42c1f2997367be47d8e23ab79fb93c98">_get_hashtable_algo</a> (np.ndarray values)</td></tr>
<tr class="separator:a42c1f2997367be47d8e23ab79fb93c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8703d635d626d874a194d111f277e8fe" id="r_a8703d635d626d874a194d111f277e8fe"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a8703d635d626d874a194d111f277e8fe">_check_object_for_strings</a> (np.ndarray values)</td></tr>
<tr class="separator:a8703d635d626d874a194d111f277e8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a16f208025c0e7ed8cba4fdf45489" id="r_aaf2a16f208025c0e7ed8cba4fdf45489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#aaf2a16f208025c0e7ed8cba4fdf45489">unique</a> (values)</td></tr>
<tr class="separator:aaf2a16f208025c0e7ed8cba4fdf45489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b109d6754b5a73d5d0f048daa50c652" id="r_a9b109d6754b5a73d5d0f048daa50c652"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a9b109d6754b5a73d5d0f048daa50c652">unique_with_mask</a> (values, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a9b109d6754b5a73d5d0f048daa50c652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dc394a0f66946b43dbf0479a5e3fbe" id="r_ad0dc394a0f66946b43dbf0479a5e3fbe"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ad0dc394a0f66946b43dbf0479a5e3fbe">isin</a> (AnyArrayLike comps, AnyArrayLike values)</td></tr>
<tr class="separator:ad0dc394a0f66946b43dbf0479a5e3fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f8aa3851b6c7db2db499afbfc15ba2" id="r_a74f8aa3851b6c7db2db499afbfc15ba2"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], np.ndarray]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a74f8aa3851b6c7db2db499afbfc15ba2">factorize_array</a> (np.ndarray values, int|None na_sentinel=-1, int|None size_hint=None, object na_value=None, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a74f8aa3851b6c7db2db499afbfc15ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf3b6725a87c4e85ebc82f91f7b7517" id="r_abdf3b6725a87c4e85ebc82f91f7b7517"><td class="memItemLeft" align="right" valign="top">tuple[np.ndarray, np.ndarray|Index]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#abdf3b6725a87c4e85ebc82f91f7b7517">factorize</a> (values, bool sort=False, int|None|lib.NoDefault na_sentinel=lib.no_default, bool|lib.NoDefault use_na_sentinel=lib.no_default, int|None size_hint=None)</td></tr>
<tr class="separator:abdf3b6725a87c4e85ebc82f91f7b7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c3c3639ea05762f11fd5e0c587aa0" id="r_a908c3c3639ea05762f11fd5e0c587aa0"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a908c3c3639ea05762f11fd5e0c587aa0">resolve_na_sentinel</a> (int|None|lib.NoDefault na_sentinel, bool|lib.NoDefault use_na_sentinel)</td></tr>
<tr class="separator:a908c3c3639ea05762f11fd5e0c587aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94e3ad2581655ddc87364fba047c8e4" id="r_ae94e3ad2581655ddc87364fba047c8e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ae94e3ad2581655ddc87364fba047c8e4">_re_wrap_factorize</a> (original, uniques, np.ndarray codes)</td></tr>
<tr class="separator:ae94e3ad2581655ddc87364fba047c8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e9a411ce11004fdee2f052eb473b21" id="r_ac4e9a411ce11004fdee2f052eb473b21"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ac4e9a411ce11004fdee2f052eb473b21">value_counts</a> (values, bool sort=True, bool ascending=False, bool normalize=False, bins=None, bool dropna=True)</td></tr>
<tr class="separator:ac4e9a411ce11004fdee2f052eb473b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6280dfd2f7602419089531b89725716" id="r_ae6280dfd2f7602419089531b89725716"><td class="memItemLeft" align="right" valign="top">tuple[ArrayLike, npt.NDArray[np.int64]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ae6280dfd2f7602419089531b89725716">value_counts_arraylike</a> (np.ndarray values, bool dropna, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:ae6280dfd2f7602419089531b89725716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d93a79ab7b264a134ff2ca59e57a930" id="r_a7d93a79ab7b264a134ff2ca59e57a930"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a7d93a79ab7b264a134ff2ca59e57a930">duplicated</a> (ArrayLike values, Literal[&quot;first&quot;, &quot;last&quot;, False] keep=&quot;first&quot;)</td></tr>
<tr class="separator:a7d93a79ab7b264a134ff2ca59e57a930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce89cf7249e152882399c613f25ff4c" id="r_abce89cf7249e152882399c613f25ff4c"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#abce89cf7249e152882399c613f25ff4c">mode</a> (ArrayLike values, bool dropna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:abce89cf7249e152882399c613f25ff4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d326870eb5bfc64588bc44c36052ed" id="r_a33d326870eb5bfc64588bc44c36052ed"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.float64]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a33d326870eb5bfc64588bc44c36052ed">rank</a> (ArrayLike values, int axis=0, str method=&quot;average&quot;, str na_option=&quot;keep&quot;, bool ascending=True, bool pct=False)</td></tr>
<tr class="separator:a33d326870eb5bfc64588bc44c36052ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab862dfcf42b4d3baa7e1d6bb0a6ff87f" id="r_ab862dfcf42b4d3baa7e1d6bb0a6ff87f"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.int64]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ab862dfcf42b4d3baa7e1d6bb0a6ff87f">checked_add_with_arr</a> (npt.NDArray[np.int64] arr, int|npt.NDArray[np.int64] b, npt.NDArray[np.bool_]|None arr_mask=None, npt.NDArray[np.bool_]|None b_mask=None)</td></tr>
<tr class="separator:ab862dfcf42b4d3baa7e1d6bb0a6ff87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbad8a0202f851027f2c12932e2128c4" id="r_adbad8a0202f851027f2c12932e2128c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#adbad8a0202f851027f2c12932e2128c4">take</a> (arr, TakeIndexer indices, int axis=0, bool allow_fill=False, fill_value=None)</td></tr>
<tr class="separator:adbad8a0202f851027f2c12932e2128c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae045f9a70b46994e5b96321911d27b71" id="r_ae045f9a70b46994e5b96321911d27b71"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]|np.intp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ae045f9a70b46994e5b96321911d27b71">searchsorted</a> (ArrayLike arr, NumpyValueArrayLike|<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> value, Literal[&quot;left&quot;, &quot;right&quot;] <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>=&quot;left&quot;, NumpySorter sorter=None)</td></tr>
<tr class="separator:ae045f9a70b46994e5b96321911d27b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24b94f7b06860b8ef8d61a9aecf24c7" id="r_ac24b94f7b06860b8ef8d61a9aecf24c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ac24b94f7b06860b8ef8d61a9aecf24c7">diff</a> (arr, int <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, int axis=0)</td></tr>
<tr class="separator:ac24b94f7b06860b8ef8d61a9aecf24c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5430fe14107fd86b141565c8e8a2c52f" id="r_a5430fe14107fd86b141565c8e8a2c52f"><td class="memItemLeft" align="right" valign="top">np.ndarray|MultiIndex|tuple[np.ndarray|MultiIndex, np.ndarray]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a5430fe14107fd86b141565c8e8a2c52f">safe_sort</a> (values, codes=None, int na_sentinel=-1, bool assume_unique=False, bool verify=True)</td></tr>
<tr class="separator:a5430fe14107fd86b141565c8e8a2c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41e24b6319bacff26ff7c3e229b0dc4" id="r_aa41e24b6319bacff26ff7c3e229b0dc4"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#aa41e24b6319bacff26ff7c3e229b0dc4">_sort_mixed</a> (values)</td></tr>
<tr class="separator:aa41e24b6319bacff26ff7c3e229b0dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b747ec5b0c3b7c1b76f35dd21caf02" id="r_a97b747ec5b0c3b7c1b76f35dd21caf02"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a97b747ec5b0c3b7c1b76f35dd21caf02">_sort_tuples</a> (np.ndarray values, np.ndarray original_values)</td></tr>
<tr class="separator:a97b747ec5b0c3b7c1b76f35dd21caf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2241344c44aa02bba41229b15e92a9b" id="r_ad2241344c44aa02bba41229b15e92a9b"><td class="memItemLeft" align="right" valign="top">MultiIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ad2241344c44aa02bba41229b15e92a9b">_sort_tuples</a> (np.ndarray values, MultiIndex original_values)</td></tr>
<tr class="separator:ad2241344c44aa02bba41229b15e92a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9848a579fd5b4f3975ae88734301e2af" id="r_a9848a579fd5b4f3975ae88734301e2af"><td class="memItemLeft" align="right" valign="top">np.ndarray|MultiIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a9848a579fd5b4f3975ae88734301e2af">_sort_tuples</a> (np.ndarray values, np.ndarray|MultiIndex original_values)</td></tr>
<tr class="separator:a9848a579fd5b4f3975ae88734301e2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f173fc73e7b7030dec21d132c5803" id="r_a8e2f173fc73e7b7030dec21d132c5803"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a8e2f173fc73e7b7030dec21d132c5803">union_with_duplicates</a> (ArrayLike lvals, ArrayLike rvals)</td></tr>
<tr class="separator:a8e2f173fc73e7b7030dec21d132c5803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae3dfca7af569cdf3704041ed4741359b" id="r_ae3dfca7af569cdf3704041ed4741359b"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#ae3dfca7af569cdf3704041ed4741359b">_hashtables</a></td></tr>
<tr class="separator:ae3dfca7af569cdf3704041ed4741359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2391ef584cb31e63dcc63f95b35de489" id="r_a2391ef584cb31e63dcc63f95b35de489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#a2391ef584cb31e63dcc63f95b35de489">unique1d</a> = <a class="el" href="namespacepandas_1_1core_1_1algorithms.html#aaf2a16f208025c0e7ed8cba4fdf45489">unique</a></td></tr>
<tr class="separator:a2391ef584cb31e63dcc63f95b35de489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb5f0661eb264df858024a3e0de961" id="r_abdeb5f0661eb264df858024a3e0de961"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1algorithms.html#abdeb5f0661eb264df858024a3e0de961">_diff_special</a> = {&quot;float64&quot;, &quot;float32&quot;, &quot;int64&quot;, &quot;int32&quot;, &quot;int16&quot;, &quot;int8&quot;}</td></tr>
<tr class="separator:abdeb5f0661eb264df858024a3e0de961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Generic data algorithms. This module is experimental at the moment and not
intended for public consumption
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a8703d635d626d874a194d111f277e8fe" name="a8703d635d626d874a194d111f277e8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8703d635d626d874a194d111f277e8fe">&#9670;&#160;</a></span>_check_object_for_strings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> str pandas.core.algorithms._check_object_for_strings </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check if we can use string hashtable instead of object hashtable.

Parameters
----------
values : ndarray

Returns
-------
str
</pre> <div class="fragment"><div class="line"><span class="lineno">  287</span><span class="keyword">def </span>_check_object_for_strings(values: np.ndarray) -&gt; str:</div>
<div class="line"><span class="lineno">  288</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    Check if we can use string hashtable instead of object hashtable.</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    values : ndarray</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    str</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  299</span>    ndtype = values.dtype.name</div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">if</span> ndtype == <span class="stringliteral">&quot;object&quot;</span>:</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>        <span class="comment"># it&#39;s cheaper to use a String Hash Table than Object; we infer</span></div>
<div class="line"><span class="lineno">  303</span>        <span class="comment"># including nulls because that is the only difference between</span></div>
<div class="line"><span class="lineno">  304</span>        <span class="comment"># StringHashTable and ObjectHashtable</span></div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordflow">if</span> lib.infer_dtype(values, skipna=<span class="keyword">False</span>) <span class="keywordflow">in</span> [<span class="stringliteral">&quot;string&quot;</span>]:</div>
<div class="line"><span class="lineno">  306</span>            ndtype = <span class="stringliteral">&quot;string&quot;</span></div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">return</span> ndtype</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span><span class="comment"># --------------- #</span></div>
<div class="line"><span class="lineno">  311</span><span class="comment"># top-level algos #</span></div>
<div class="line"><span class="lineno">  312</span><span class="comment"># --------------- #</span></div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8625e137d8c86211e15af330b0eb62d7" name="a8625e137d8c86211e15af330b0eb62d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8625e137d8c86211e15af330b0eb62d7">&#9670;&#160;</a></span>_ensure_arraylike()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.algorithms._ensure_arraylike </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">ensure that we are arraylike if not already
</pre> <div class="fragment"><div class="line"><span class="lineno">  235</span><span class="keyword">def </span>_ensure_arraylike(values) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  236</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    ensure that we are arraylike if not already</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  239</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_array_like(values):</div>
<div class="line"><span class="lineno">  240</span>        inferred = lib.infer_dtype(values, skipna=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  241</span>        <span class="keywordflow">if</span> inferred <span class="keywordflow">in</span> [<span class="stringliteral">&quot;mixed&quot;</span>, <span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;mixed-integer&quot;</span>]:</div>
<div class="line"><span class="lineno">  242</span>            <span class="comment"># &quot;mixed-integer&quot; to ensure we do not cast [&quot;ss&quot;, 42] to str GH#22160</span></div>
<div class="line"><span class="lineno">  243</span>            <span class="keywordflow">if</span> isinstance(values, tuple):</div>
<div class="line"><span class="lineno">  244</span>                values = list(values)</div>
<div class="line"><span class="lineno">  245</span>            values = construct_1d_object_array_from_listlike(values)</div>
<div class="line"><span class="lineno">  246</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  247</span>            values = np.asarray(values)</div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno">  249</span> </div>
<div class="line"><span class="lineno">  250</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a874d39e4200cf44ffe3d92f229ffb058" name="a874d39e4200cf44ffe3d92f229ffb058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874d39e4200cf44ffe3d92f229ffb058">&#9670;&#160;</a></span>_ensure_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.algorithms._ensure_data </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">routine to ensure that our data is of the correct
input dtype for lower-level routines

This will coerce:
- ints -&gt; int64
- uint -&gt; uint64
- bool -&gt; uint8
- datetimelike -&gt; i8
- datetime64tz -&gt; i8 (in local tz)
- categorical -&gt; codes

Parameters
----------
values : np.ndarray or ExtensionArray

Returns
-------
np.ndarray
</pre> <div class="fragment"><div class="line"><span class="lineno">  117</span><span class="keyword">def </span>_ensure_data(values: ArrayLike) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  118</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    routine to ensure that our data is of the correct</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    input dtype for lower-level routines</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    This will coerce:</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    - ints -&gt; int64</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    - uint -&gt; uint64</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    - bool -&gt; uint8</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    - datetimelike -&gt; i8</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    - datetime64tz -&gt; i8 (in local tz)</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    - categorical -&gt; codes</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    values : np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    np.ndarray</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  138</span> </div>
<div class="line"><span class="lineno">  139</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(values, ABCMultiIndex):</div>
<div class="line"><span class="lineno">  140</span>        <span class="comment"># extract_array would raise</span></div>
<div class="line"><span class="lineno">  141</span>        values = extract_array(values, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    <span class="keywordflow">if</span> is_object_dtype(values.dtype):</div>
<div class="line"><span class="lineno">  144</span>        <span class="keywordflow">return</span> ensure_object(np.asarray(values))</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>    <span class="keywordflow">elif</span> isinstance(values.dtype, BaseMaskedDtype):</div>
<div class="line"><span class="lineno">  147</span>        <span class="comment"># i.e. BooleanArray, FloatingArray, IntegerArray</span></div>
<div class="line"><span class="lineno">  148</span>        values = cast(<span class="stringliteral">&quot;BaseMaskedArray&quot;</span>, values)</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> values._hasna:</div>
<div class="line"><span class="lineno">  150</span>            <span class="comment"># No pd.NAs -&gt; We can avoid an object-dtype cast (and copy) GH#41816</span></div>
<div class="line"><span class="lineno">  151</span>            <span class="comment">#  recurse to avoid re-implementing logic for eg bool-&gt;uint8</span></div>
<div class="line"><span class="lineno">  152</span>            <span class="keywordflow">return</span> _ensure_data(values._data)</div>
<div class="line"><span class="lineno">  153</span>        <span class="keywordflow">return</span> np.asarray(values)</div>
<div class="line"><span class="lineno">  154</span> </div>
<div class="line"><span class="lineno">  155</span>    <span class="keywordflow">elif</span> is_categorical_dtype(values.dtype):</div>
<div class="line"><span class="lineno">  156</span>        <span class="comment"># NB: cases that go through here should NOT be using _reconstruct_data</span></div>
<div class="line"><span class="lineno">  157</span>        <span class="comment">#  on the back-end.</span></div>
<div class="line"><span class="lineno">  158</span>        values = cast(<span class="stringliteral">&quot;Categorical&quot;</span>, values)</div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">return</span> values.codes</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">elif</span> is_bool_dtype(values.dtype):</div>
<div class="line"><span class="lineno">  162</span>        <span class="keywordflow">if</span> isinstance(values, np.ndarray):</div>
<div class="line"><span class="lineno">  163</span>            <span class="comment"># i.e. actually dtype == np.dtype(&quot;bool&quot;)</span></div>
<div class="line"><span class="lineno">  164</span>            <span class="keywordflow">return</span> np.asarray(values).view(<span class="stringliteral">&quot;uint8&quot;</span>)</div>
<div class="line"><span class="lineno">  165</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  166</span>            <span class="comment"># e.g. Sparse[bool, False]  # TODO: no test cases get here</span></div>
<div class="line"><span class="lineno">  167</span>            <span class="keywordflow">return</span> np.asarray(values).astype(<span class="stringliteral">&quot;uint8&quot;</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">elif</span> is_integer_dtype(values.dtype):</div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordflow">return</span> np.asarray(values)</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordflow">elif</span> is_float_dtype(values.dtype):</div>
<div class="line"><span class="lineno">  173</span>        <span class="comment"># Note: checking `values.dtype == &quot;float128&quot;` raises on Windows and 32bit</span></div>
<div class="line"><span class="lineno">  174</span>        <span class="comment"># error: Item &quot;ExtensionDtype&quot; of &quot;Union[Any, ExtensionDtype, dtype[Any]]&quot;</span></div>
<div class="line"><span class="lineno">  175</span>        <span class="comment"># has no attribute &quot;itemsize&quot;</span></div>
<div class="line"><span class="lineno">  176</span>        <span class="keywordflow">if</span> values.dtype.itemsize <span class="keywordflow">in</span> [2, 12, 16]:  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno">  177</span>            <span class="comment"># we dont (yet) have float128 hashtable support</span></div>
<div class="line"><span class="lineno">  178</span>            <span class="keywordflow">return</span> ensure_float64(values)</div>
<div class="line"><span class="lineno">  179</span>        <span class="keywordflow">return</span> np.asarray(values)</div>
<div class="line"><span class="lineno">  180</span> </div>
<div class="line"><span class="lineno">  181</span>    <span class="keywordflow">elif</span> is_complex_dtype(values.dtype):</div>
<div class="line"><span class="lineno">  182</span>        <span class="keywordflow">return</span> cast(np.ndarray, values)</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>    <span class="comment"># datetimelike</span></div>
<div class="line"><span class="lineno">  185</span>    <span class="keywordflow">elif</span> needs_i8_conversion(values.dtype):</div>
<div class="line"><span class="lineno">  186</span>        <span class="keywordflow">if</span> isinstance(values, np.ndarray):</div>
<div class="line"><span class="lineno">  187</span>            values = sanitize_to_nanoseconds(values)</div>
<div class="line"><span class="lineno">  188</span>        npvalues = values.view(<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno">  189</span>        npvalues = cast(np.ndarray, npvalues)</div>
<div class="line"><span class="lineno">  190</span>        <span class="keywordflow">return</span> npvalues</div>
<div class="line"><span class="lineno">  191</span> </div>
<div class="line"><span class="lineno">  192</span>    <span class="comment"># we have failed, return object</span></div>
<div class="line"><span class="lineno">  193</span>    values = np.asarray(values, dtype=object)</div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">return</span> ensure_object(values)</div>
<div class="line"><span class="lineno">  195</span> </div>
<div class="line"><span class="lineno">  196</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a42c1f2997367be47d8e23ab79fb93c98" name="a42c1f2997367be47d8e23ab79fb93c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c1f2997367be47d8e23ab79fb93c98">&#9670;&#160;</a></span>_get_hashtable_algo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.algorithms._get_hashtable_algo </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
values : np.ndarray

Returns
-------
htable : HashTable subclass
values : ndarray
</pre> <div class="fragment"><div class="line"><span class="lineno">  269</span><span class="keyword">def </span>_get_hashtable_algo(values: np.ndarray):</div>
<div class="line"><span class="lineno">  270</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    values : np.ndarray</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    htable : HashTable subclass</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    values : ndarray</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  280</span>    values = _ensure_data(values)</div>
<div class="line"><span class="lineno">  281</span> </div>
<div class="line"><span class="lineno">  282</span>    ndtype = _check_object_for_strings(values)</div>
<div class="line"><span class="lineno">  283</span>    htable = _hashtables[ndtype]</div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">return</span> htable, values</div>
<div class="line"><span class="lineno">  285</span> </div>
<div class="line"><span class="lineno">  286</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae94e3ad2581655ddc87364fba047c8e4" name="ae94e3ad2581655ddc87364fba047c8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94e3ad2581655ddc87364fba047c8e4">&#9670;&#160;</a></span>_re_wrap_factorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.algorithms._re_wrap_factorize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>uniques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>codes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wrap factorize results in Series or Index depending on original type.
</pre> <div class="fragment"><div class="line"><span class="lineno">  901</span><span class="keyword">def </span>_re_wrap_factorize(original, uniques, codes: np.ndarray):</div>
<div class="line"><span class="lineno">  902</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Wrap factorize results in Series or Index depending on original type.</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  905</span>    <span class="keywordflow">if</span> isinstance(original, ABCIndex):</div>
<div class="line"><span class="lineno">  906</span>        uniques = ensure_wrapped_if_datetimelike(uniques)</div>
<div class="line"><span class="lineno">  907</span>        uniques = original._shallow_copy(uniques, name=<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  908</span>    <span class="keywordflow">elif</span> isinstance(original, ABCSeries):</div>
<div class="line"><span class="lineno">  909</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> Index</div>
<div class="line"><span class="lineno">  910</span> </div>
<div class="line"><span class="lineno">  911</span>        uniques = Index(uniques)</div>
<div class="line"><span class="lineno">  912</span> </div>
<div class="line"><span class="lineno">  913</span>    <span class="keywordflow">return</span> codes, uniques</div>
<div class="line"><span class="lineno">  914</span> </div>
<div class="line"><span class="lineno">  915</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cc56a5f7c5c53e4c93b3f64a2be1966" name="a7cc56a5f7c5c53e4c93b3f64a2be1966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc56a5f7c5c53e4c93b3f64a2be1966">&#9670;&#160;</a></span>_reconstruct_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.algorithms._reconstruct_data </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyArrayLike
&#160;</td>
          <td class="paramname"><em>original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">reverse of _ensure_data

Parameters
----------
values : np.ndarray or ExtensionArray
dtype : np.dtype or ExtensionDtype
original : AnyArrayLike

Returns
-------
ExtensionArray or np.ndarray
</pre> <div class="fragment"><div class="line"><span class="lineno">  199</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  200</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    reverse of _ensure_data</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    values : np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    dtype : np.dtype or ExtensionDtype</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    original : AnyArrayLike</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    ExtensionArray or np.ndarray</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">if</span> isinstance(values, ABCExtensionArray) <span class="keywordflow">and</span> values.dtype == dtype:</div>
<div class="line"><span class="lineno">  214</span>        <span class="comment"># Catch DatetimeArray/TimedeltaArray</span></div>
<div class="line"><span class="lineno">  215</span>        <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, np.dtype):</div>
<div class="line"><span class="lineno">  218</span>        <span class="comment"># i.e. ExtensionDtype; note we have ruled out above the possibility</span></div>
<div class="line"><span class="lineno">  219</span>        <span class="comment">#  that values.dtype == dtype</span></div>
<div class="line"><span class="lineno">  220</span>        cls = dtype.construct_array_type()</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span>        values = cls._from_sequence(values, dtype=dtype)</div>
<div class="line"><span class="lineno">  223</span> </div>
<div class="line"><span class="lineno">  224</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  225</span>        <span class="keywordflow">if</span> is_datetime64_dtype(dtype):</div>
<div class="line"><span class="lineno">  226</span>            dtype = np.dtype(<span class="stringliteral">&quot;datetime64[ns]&quot;</span>)</div>
<div class="line"><span class="lineno">  227</span>        <span class="keywordflow">elif</span> is_timedelta64_dtype(dtype):</div>
<div class="line"><span class="lineno">  228</span>            dtype = np.dtype(<span class="stringliteral">&quot;timedelta64[ns]&quot;</span>)</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>        values = values.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno">  233</span> </div>
<div class="line"><span class="lineno">  234</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa41e24b6319bacff26ff7c3e229b0dc4" name="aa41e24b6319bacff26ff7c3e229b0dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41e24b6319bacff26ff7c3e229b0dc4">&#9670;&#160;</a></span>_sort_mixed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.algorithms._sort_mixed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">order ints before strings in 1d arrays, safe in py3</pre> <div class="fragment"><div class="line"><span class="lineno"> 1928</span><span class="keyword">def </span>_sort_mixed(values) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1929</span>    <span class="stringliteral">&quot;&quot;&quot;order ints before strings in 1d arrays, safe in py3&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1930</span>    str_pos = np.array([isinstance(x, str) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> values], dtype=bool)</div>
<div class="line"><span class="lineno"> 1931</span>    none_pos = np.array([x <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">for</span> x <span class="keywordflow">in</span> values], dtype=bool)</div>
<div class="line"><span class="lineno"> 1932</span>    nums = np.sort(values[~str_pos &amp; ~none_pos])</div>
<div class="line"><span class="lineno"> 1933</span>    strs = np.sort(values[str_pos])</div>
<div class="line"><span class="lineno"> 1934</span>    <span class="keywordflow">return</span> np.concatenate(</div>
<div class="line"><span class="lineno"> 1935</span>        [nums, np.asarray(strs, dtype=object), np.array(values[none_pos])]</div>
<div class="line"><span class="lineno"> 1936</span>    )</div>
<div class="line"><span class="lineno"> 1937</span> </div>
<div class="line"><span class="lineno"> 1938</span> </div>
<div class="line"><span class="lineno"> 1939</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2241344c44aa02bba41229b15e92a9b" name="ad2241344c44aa02bba41229b15e92a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2241344c44aa02bba41229b15e92a9b">&#9670;&#160;</a></span>_sort_tuples() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> MultiIndex pandas.core.algorithms._sort_tuples </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiIndex&#160;</td>
          <td class="paramname"><em>original_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1945</span><span class="keyword">def </span>_sort_tuples(values: np.ndarray, original_values: MultiIndex) -&gt; MultiIndex:</div>
<div class="line"><span class="lineno"> 1946</span>    ...</div>
<div class="line"><span class="lineno"> 1947</span> </div>
<div class="line"><span class="lineno"> 1948</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a97b747ec5b0c3b7c1b76f35dd21caf02" name="a97b747ec5b0c3b7c1b76f35dd21caf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b747ec5b0c3b7c1b76f35dd21caf02">&#9670;&#160;</a></span>_sort_tuples() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.algorithms._sort_tuples </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>original_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1940</span><span class="keyword">def </span>_sort_tuples(values: np.ndarray, original_values: np.ndarray) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1941</span>    ...</div>
<div class="line"><span class="lineno"> 1942</span> </div>
<div class="line"><span class="lineno"> 1943</span> </div>
<div class="line"><span class="lineno"> 1944</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9848a579fd5b4f3975ae88734301e2af" name="a9848a579fd5b4f3975ae88734301e2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9848a579fd5b4f3975ae88734301e2af">&#9670;&#160;</a></span>_sort_tuples() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray | MultiIndex pandas.core.algorithms._sort_tuples </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray | MultiIndex
&#160;</td>
          <td class="paramname"><em>original_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert array of tuples (1d) to array or array (2d).
We need to keep the columns separately as they contain different types and
nans (can't use `np.sort` as it may fail when str and nan are mixed in a
column as types cannot be compared).
We have to apply the indexer to the original values to keep the dtypes in
case of MultiIndexes
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1951</span>) -&gt; np.ndarray | MultiIndex:</div>
<div class="line"><span class="lineno"> 1952</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral">    Convert array of tuples (1d) to array or array (2d).</span></div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">    We need to keep the columns separately as they contain different types and</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">    nans (can&#39;t use `np.sort` as it may fail when str and nan are mixed in a</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral">    column as types cannot be compared).</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral">    We have to apply the indexer to the original values to keep the dtypes in</span></div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">    case of MultiIndexes</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1960</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1internals_1_1construction.html">pandas.core.internals.construction</a> <span class="keyword">import</span> to_arrays</div>
<div class="line"><span class="lineno"> 1961</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1sorting.html">pandas.core.sorting</a> <span class="keyword">import</span> lexsort_indexer</div>
<div class="line"><span class="lineno"> 1962</span> </div>
<div class="line"><span class="lineno"> 1963</span>    arrays, _ = to_arrays(values, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1964</span>    indexer = lexsort_indexer(arrays, orders=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1965</span>    <span class="keywordflow">return</span> original_values[indexer]</div>
<div class="line"><span class="lineno"> 1966</span> </div>
<div class="line"><span class="lineno"> 1967</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1internals_1_1construction_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1internals_1_1construction.html">pandas.core.internals.construction</a></div><div class="ttdef"><b>Definition</b> construction.py:1</div></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1sorting_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1sorting.html">pandas.core.sorting</a></div><div class="ttdef"><b>Definition</b> sorting.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab862dfcf42b4d3baa7e1d6bb0a6ff87f" name="ab862dfcf42b4d3baa7e1d6bb0a6ff87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab862dfcf42b4d3baa7e1d6bb0a6ff87f">&#9670;&#160;</a></span>checked_add_with_arr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.int64] pandas.core.algorithms.checked_add_with_arr </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.int64]&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | npt.NDArray[np.int64]&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>arr_mask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>b_mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform array addition that checks for underflow and overflow.

Performs the addition of an int64 array and an int64 integer (or array)
but checks that they do not result in overflow first. For elements that
are indicated to be NaN, whether or not there is overflow for that element
is automatically ignored.

Parameters
----------
arr : np.ndarray[int64] addend.
b : array or scalar addend.
arr_mask : np.ndarray[bool] or None, default None
    array indicating which elements to exclude from checking
b_mask : np.ndarray[bool] or None, default None
    array or scalar indicating which element(s) to exclude from checking

Returns
-------
sum : An array for elements x + b for each element x in arr if b is
      a scalar or an array for elements x + y for each element pair
      (x, y) in (arr, b).

Raises
------
OverflowError if any x + y exceeds the maximum or minimum int64 value.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1167</span>) -&gt; npt.NDArray[np.int64]:</div>
<div class="line"><span class="lineno"> 1168</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    Perform array addition that checks for underflow and overflow.</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    Performs the addition of an int64 array and an int64 integer (or array)</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    but checks that they do not result in overflow first. For elements that</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    are indicated to be NaN, whether or not there is overflow for that element</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    is automatically ignored.</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">    arr : np.ndarray[int64] addend.</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    b : array or scalar addend.</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    arr_mask : np.ndarray[bool] or None, default None</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">        array indicating which elements to exclude from checking</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    b_mask : np.ndarray[bool] or None, default None</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">        array or scalar indicating which element(s) to exclude from checking</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    sum : An array for elements x + b for each element x in arr if b is</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">          a scalar or an array for elements x + y for each element pair</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">          (x, y) in (arr, b).</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    OverflowError if any x + y exceeds the maximum or minimum int64 value.</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1195</span>    <span class="comment"># For performance reasons, we broadcast &#39;b&#39; to the new array &#39;b2&#39;</span></div>
<div class="line"><span class="lineno"> 1196</span>    <span class="comment"># so that it has the same size as &#39;arr&#39;.</span></div>
<div class="line"><span class="lineno"> 1197</span>    b2 = np.broadcast_to(b, arr.shape)</div>
<div class="line"><span class="lineno"> 1198</span>    <span class="keywordflow">if</span> b_mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1199</span>        <span class="comment"># We do the same broadcasting for b_mask as well.</span></div>
<div class="line"><span class="lineno"> 1200</span>        b2_mask = np.broadcast_to(b_mask, arr.shape)</div>
<div class="line"><span class="lineno"> 1201</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1202</span>        b2_mask = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1203</span> </div>
<div class="line"><span class="lineno"> 1204</span>    <span class="comment"># For elements that are NaN, regardless of their value, we should</span></div>
<div class="line"><span class="lineno"> 1205</span>    <span class="comment"># ignore whether they overflow or not when doing the checked add.</span></div>
<div class="line"><span class="lineno"> 1206</span>    <span class="keywordflow">if</span> arr_mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> b2_mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1207</span>        not_nan = np.logical_not(arr_mask | b2_mask)</div>
<div class="line"><span class="lineno"> 1208</span>    <span class="keywordflow">elif</span> arr_mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1209</span>        not_nan = np.logical_not(arr_mask)</div>
<div class="line"><span class="lineno"> 1210</span>    <span class="keywordflow">elif</span> b_mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1211</span>        <span class="comment"># error: Argument 1 to &quot;__call__&quot; of &quot;_UFunc_Nin1_Nout1&quot; has</span></div>
<div class="line"><span class="lineno"> 1212</span>        <span class="comment"># incompatible type &quot;Optional[ndarray[Any, dtype[bool_]]]&quot;;</span></div>
<div class="line"><span class="lineno"> 1213</span>        <span class="comment"># expected &quot;Union[_SupportsArray[dtype[Any]], _NestedSequence</span></div>
<div class="line"><span class="lineno"> 1214</span>        <span class="comment"># [_SupportsArray[dtype[Any]]], bool, int, float, complex, str</span></div>
<div class="line"><span class="lineno"> 1215</span>        <span class="comment"># , bytes, _NestedSequence[Union[bool, int, float, complex, str</span></div>
<div class="line"><span class="lineno"> 1216</span>        <span class="comment"># , bytes]]]&quot;</span></div>
<div class="line"><span class="lineno"> 1217</span>        not_nan = np.logical_not(b2_mask)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 1218</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1219</span>        not_nan = np.empty(arr.shape, dtype=bool)</div>
<div class="line"><span class="lineno"> 1220</span>        not_nan.fill(<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1221</span> </div>
<div class="line"><span class="lineno"> 1222</span>    <span class="comment"># gh-14324: For each element in &#39;arr&#39; and its corresponding element</span></div>
<div class="line"><span class="lineno"> 1223</span>    <span class="comment"># in &#39;b2&#39;, we check the sign of the element in &#39;b2&#39;. If it is positive,</span></div>
<div class="line"><span class="lineno"> 1224</span>    <span class="comment"># we then check whether its sum with the element in &#39;arr&#39; exceeds</span></div>
<div class="line"><span class="lineno"> 1225</span>    <span class="comment"># np.iinfo(np.int64).max. If so, we have an overflow error. If it</span></div>
<div class="line"><span class="lineno"> 1226</span>    <span class="comment"># it is negative, we then check whether its sum with the element in</span></div>
<div class="line"><span class="lineno"> 1227</span>    <span class="comment"># &#39;arr&#39; exceeds np.iinfo(np.int64).min. If so, we have an overflow</span></div>
<div class="line"><span class="lineno"> 1228</span>    <span class="comment"># error as well.</span></div>
<div class="line"><span class="lineno"> 1229</span>    i8max = lib.i8max</div>
<div class="line"><span class="lineno"> 1230</span>    i8min = iNaT</div>
<div class="line"><span class="lineno"> 1231</span> </div>
<div class="line"><span class="lineno"> 1232</span>    mask1 = b2 &gt; 0</div>
<div class="line"><span class="lineno"> 1233</span>    mask2 = b2 &lt; 0</div>
<div class="line"><span class="lineno"> 1234</span> </div>
<div class="line"><span class="lineno"> 1235</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> mask1.any():</div>
<div class="line"><span class="lineno"> 1236</span>        to_raise = ((i8min - b2 &gt; arr) &amp; not_nan).any()</div>
<div class="line"><span class="lineno"> 1237</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> mask2.any():</div>
<div class="line"><span class="lineno"> 1238</span>        to_raise = ((i8max - b2 &lt; arr) &amp; not_nan).any()</div>
<div class="line"><span class="lineno"> 1239</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1240</span>        to_raise = ((i8max - b2[mask1] &lt; arr[mask1]) &amp; not_nan[mask1]).any() <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno"> 1241</span>            (i8min - b2[mask2] &gt; arr[mask2]) &amp; not_nan[mask2]</div>
<div class="line"><span class="lineno"> 1242</span>        ).any()</div>
<div class="line"><span class="lineno"> 1243</span> </div>
<div class="line"><span class="lineno"> 1244</span>    <span class="keywordflow">if</span> to_raise:</div>
<div class="line"><span class="lineno"> 1245</span>        <span class="keywordflow">raise</span> OverflowError(<span class="stringliteral">&quot;Overflow in int64 addition&quot;</span>)</div>
<div class="line"><span class="lineno"> 1246</span> </div>
<div class="line"><span class="lineno"> 1247</span>    result = arr + b</div>
<div class="line"><span class="lineno"> 1248</span>    <span class="keywordflow">if</span> arr_mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> b2_mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1249</span>        np.putmask(result, ~not_nan, iNaT)</div>
<div class="line"><span class="lineno"> 1250</span> </div>
<div class="line"><span class="lineno"> 1251</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1252</span> </div>
<div class="line"><span class="lineno"> 1253</span> </div>
<div class="line"><span class="lineno"> 1254</span><span class="comment"># --------------- #</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="comment"># select n        #</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="comment"># --------------- #</span></div>
<div class="line"><span class="lineno"> 1257</span> </div>
<div class="line"><span class="lineno"> 1258</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac24b94f7b06860b8ef8d61a9aecf24c7" name="ac24b94f7b06860b8ef8d61a9aecf24c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24b94f7b06860b8ef8d61a9aecf24c7">&#9670;&#160;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.algorithms.diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">difference of n between self,
analogous to s-s.shift(n)

Parameters
----------
arr : ndarray or ExtensionArray
n : int
    number of periods
axis : {0, 1}
    axis to shift on
stacklevel : int, default 3
    The stacklevel for the lost dtype warning.

Returns
-------
shifted
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1675</span><span class="keyword">def </span>diff(arr, n: int, axis: int = 0):</div>
<div class="line"><span class="lineno"> 1676</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    difference of n between self,</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    analogous to s-s.shift(n)</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">    arr : ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">        number of periods</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">    axis : {0, 1}</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        axis to shift on</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">    stacklevel : int, default 3</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">        The stacklevel for the lost dtype warning.</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">    shifted</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1694</span> </div>
<div class="line"><span class="lineno"> 1695</span>    n = int(n)</div>
<div class="line"><span class="lineno"> 1696</span>    na = np.nan</div>
<div class="line"><span class="lineno"> 1697</span>    dtype = arr.dtype</div>
<div class="line"><span class="lineno"> 1698</span> </div>
<div class="line"><span class="lineno"> 1699</span>    is_bool = is_bool_dtype(dtype)</div>
<div class="line"><span class="lineno"> 1700</span>    <span class="keywordflow">if</span> is_bool:</div>
<div class="line"><span class="lineno"> 1701</span>        op = operator.xor</div>
<div class="line"><span class="lineno"> 1702</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1703</span>        op = operator.sub</div>
<div class="line"><span class="lineno"> 1704</span> </div>
<div class="line"><span class="lineno"> 1705</span>    <span class="keywordflow">if</span> isinstance(dtype, PandasDtype):</div>
<div class="line"><span class="lineno"> 1706</span>        <span class="comment"># PandasArray cannot necessarily hold shifted versions of itself.</span></div>
<div class="line"><span class="lineno"> 1707</span>        arr = arr.to_numpy()</div>
<div class="line"><span class="lineno"> 1708</span>        dtype = arr.dtype</div>
<div class="line"><span class="lineno"> 1709</span> </div>
<div class="line"><span class="lineno"> 1710</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, np.dtype):</div>
<div class="line"><span class="lineno"> 1711</span>        <span class="comment"># i.e ExtensionDtype</span></div>
<div class="line"><span class="lineno"> 1712</span>        <span class="keywordflow">if</span> hasattr(arr, f<span class="stringliteral">&quot;__{op.__name__}__&quot;</span>):</div>
<div class="line"><span class="lineno"> 1713</span>            <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 1714</span>                <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;cannot diff {type(arr).__name__} on axis={axis}&quot;</span>)</div>
<div class="line"><span class="lineno"> 1715</span>            <span class="keywordflow">return</span> op(arr, arr.shift(n))</div>
<div class="line"><span class="lineno"> 1716</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1717</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1718</span>                <span class="stringliteral">&quot;dtype lost in &#39;diff()&#39;. In the future this will raise a &quot;</span></div>
<div class="line"><span class="lineno"> 1719</span>                <span class="stringliteral">&quot;TypeError. Convert to a suitable dtype prior to calling &#39;diff&#39;.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1720</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 1721</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1722</span>            )</div>
<div class="line"><span class="lineno"> 1723</span>            arr = np.asarray(arr)</div>
<div class="line"><span class="lineno"> 1724</span>            dtype = arr.dtype</div>
<div class="line"><span class="lineno"> 1725</span> </div>
<div class="line"><span class="lineno"> 1726</span>    is_timedelta = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1727</span>    <span class="keywordflow">if</span> needs_i8_conversion(arr.dtype):</div>
<div class="line"><span class="lineno"> 1728</span>        dtype = np.int64</div>
<div class="line"><span class="lineno"> 1729</span>        arr = arr.view(<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno"> 1730</span>        na = iNaT</div>
<div class="line"><span class="lineno"> 1731</span>        is_timedelta = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1732</span> </div>
<div class="line"><span class="lineno"> 1733</span>    <span class="keywordflow">elif</span> is_bool:</div>
<div class="line"><span class="lineno"> 1734</span>        <span class="comment"># We have to cast in order to be able to hold np.nan</span></div>
<div class="line"><span class="lineno"> 1735</span>        dtype = np.object_</div>
<div class="line"><span class="lineno"> 1736</span> </div>
<div class="line"><span class="lineno"> 1737</span>    <span class="keywordflow">elif</span> is_integer_dtype(dtype):</div>
<div class="line"><span class="lineno"> 1738</span>        <span class="comment"># We have to cast in order to be able to hold np.nan</span></div>
<div class="line"><span class="lineno"> 1739</span> </div>
<div class="line"><span class="lineno"> 1740</span>        <span class="comment"># int8, int16 are incompatible with float64,</span></div>
<div class="line"><span class="lineno"> 1741</span>        <span class="comment"># see https://github.com/cython/cython/issues/2646</span></div>
<div class="line"><span class="lineno"> 1742</span>        <span class="keywordflow">if</span> arr.dtype.name <span class="keywordflow">in</span> [<span class="stringliteral">&quot;int8&quot;</span>, <span class="stringliteral">&quot;int16&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1743</span>            dtype = np.float32</div>
<div class="line"><span class="lineno"> 1744</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1745</span>            dtype = np.float64</div>
<div class="line"><span class="lineno"> 1746</span> </div>
<div class="line"><span class="lineno"> 1747</span>    orig_ndim = arr.ndim</div>
<div class="line"><span class="lineno"> 1748</span>    <span class="keywordflow">if</span> orig_ndim == 1:</div>
<div class="line"><span class="lineno"> 1749</span>        <span class="comment"># reshape so we can always use algos.diff_2d</span></div>
<div class="line"><span class="lineno"> 1750</span>        arr = arr.reshape(-1, 1)</div>
<div class="line"><span class="lineno"> 1751</span>        <span class="comment"># TODO: require axis == 0</span></div>
<div class="line"><span class="lineno"> 1752</span> </div>
<div class="line"><span class="lineno"> 1753</span>    dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno"> 1754</span>    out_arr = np.empty(arr.shape, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1755</span> </div>
<div class="line"><span class="lineno"> 1756</span>    na_indexer = [slice(<span class="keywordtype">None</span>)] * 2</div>
<div class="line"><span class="lineno"> 1757</span>    na_indexer[axis] = slice(<span class="keywordtype">None</span>, n) <span class="keywordflow">if</span> n &gt;= 0 <span class="keywordflow">else</span> slice(n, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1758</span>    out_arr[tuple(na_indexer)] = na</div>
<div class="line"><span class="lineno"> 1759</span> </div>
<div class="line"><span class="lineno"> 1760</span>    <span class="keywordflow">if</span> arr.dtype.name <span class="keywordflow">in</span> _diff_special:</div>
<div class="line"><span class="lineno"> 1761</span>        <span class="comment"># TODO: can diff_2d dtype specialization troubles be fixed by defining</span></div>
<div class="line"><span class="lineno"> 1762</span>        <span class="comment">#  out_arr inside diff_2d?</span></div>
<div class="line"><span class="lineno"> 1763</span>        algos.diff_2d(arr, out_arr, n, axis, datetimelike=is_timedelta)</div>
<div class="line"><span class="lineno"> 1764</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1765</span>        <span class="comment"># To keep mypy happy, _res_indexer is a list while res_indexer is</span></div>
<div class="line"><span class="lineno"> 1766</span>        <span class="comment">#  a tuple, ditto for lag_indexer.</span></div>
<div class="line"><span class="lineno"> 1767</span>        _res_indexer = [slice(<span class="keywordtype">None</span>)] * 2</div>
<div class="line"><span class="lineno"> 1768</span>        _res_indexer[axis] = slice(n, <span class="keywordtype">None</span>) <span class="keywordflow">if</span> n &gt;= 0 <span class="keywordflow">else</span> slice(<span class="keywordtype">None</span>, n)</div>
<div class="line"><span class="lineno"> 1769</span>        res_indexer = tuple(_res_indexer)</div>
<div class="line"><span class="lineno"> 1770</span> </div>
<div class="line"><span class="lineno"> 1771</span>        _lag_indexer = [slice(<span class="keywordtype">None</span>)] * 2</div>
<div class="line"><span class="lineno"> 1772</span>        _lag_indexer[axis] = slice(<span class="keywordtype">None</span>, -n) <span class="keywordflow">if</span> n &gt; 0 <span class="keywordflow">else</span> slice(-n, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1773</span>        lag_indexer = tuple(_lag_indexer)</div>
<div class="line"><span class="lineno"> 1774</span> </div>
<div class="line"><span class="lineno"> 1775</span>        out_arr[res_indexer] = op(arr[res_indexer], arr[lag_indexer])</div>
<div class="line"><span class="lineno"> 1776</span> </div>
<div class="line"><span class="lineno"> 1777</span>    <span class="keywordflow">if</span> is_timedelta:</div>
<div class="line"><span class="lineno"> 1778</span>        out_arr = out_arr.view(<span class="stringliteral">&quot;timedelta64[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1779</span> </div>
<div class="line"><span class="lineno"> 1780</span>    <span class="keywordflow">if</span> orig_ndim == 1:</div>
<div class="line"><span class="lineno"> 1781</span>        out_arr = out_arr[:, 0]</div>
<div class="line"><span class="lineno"> 1782</span>    <span class="keywordflow">return</span> out_arr</div>
<div class="line"><span class="lineno"> 1783</span> </div>
<div class="line"><span class="lineno"> 1784</span> </div>
<div class="line"><span class="lineno"> 1785</span><span class="comment"># --------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="comment"># Helper functions</span></div>
<div class="line"><span class="lineno"> 1787</span> </div>
<div class="line"><span class="lineno"> 1788</span><span class="comment"># Note: safe_sort is in algorithms.py instead of sorting.py because it is</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="comment">#  low-dependency, is used in this module, and used private methods from</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="comment">#  this module.</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d93a79ab7b264a134ff2ca59e57a930" name="a7d93a79ab7b264a134ff2ca59e57a930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d93a79ab7b264a134ff2ca59e57a930">&#9670;&#160;</a></span>duplicated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] pandas.core.algorithms.duplicated </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;first&quot;, &quot;last&quot;, False] &#160;</td>
          <td class="paramname"><em>keep</em> = <code>&quot;first&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return boolean ndarray denoting duplicate values.

Parameters
----------
values : nd.array, ExtensionArray or Series
    Array over which to check for duplicate values.
keep : {'first', 'last', False}, default 'first'
    - ``first`` : Mark duplicates as ``True`` except for the first
      occurrence.
    - ``last`` : Mark duplicates as ``True`` except for the last
      occurrence.
    - False : Mark all duplicates as ``True``.

Returns
-------
duplicated : ndarray[bool]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1039</span>) -&gt; npt.NDArray[np.bool_]:</div>
<div class="line"><span class="lineno"> 1040</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    Return boolean ndarray denoting duplicate values.</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    values : nd.array, ExtensionArray or Series</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        Array over which to check for duplicate values.</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">        - ``first`` : Mark duplicates as ``True`` except for the first</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">          occurrence.</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">        - ``last`` : Mark duplicates as ``True`` except for the last</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">          occurrence.</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">        - False : Mark all duplicates as ``True``.</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">    duplicated : ndarray[bool]</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1058</span>    values = _ensure_data(values)</div>
<div class="line"><span class="lineno"> 1059</span>    <span class="keywordflow">return</span> htable.duplicated(values, keep=keep)</div>
<div class="line"><span class="lineno"> 1060</span> </div>
<div class="line"><span class="lineno"> 1061</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abdf3b6725a87c4e85ebc82f91f7b7517" name="abdf3b6725a87c4e85ebc82f91f7b7517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf3b6725a87c4e85ebc82f91f7b7517">&#9670;&#160;</a></span>factorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[np.ndarray, np.ndarray | Index] pandas.core.algorithms.factorize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None | lib.NoDefault &#160;</td>
          <td class="paramname"><em>na_sentinel</em> = <code>lib.no_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>use_na_sentinel</em> = <code>lib.no_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>size_hint</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encode the object as an enumerated type or categorical variable.

This method is useful for obtaining a numeric representation of an
array when all that matters is identifying distinct values. `factorize`
is available as both a top-level function :func:`pandas.factorize`,
and as a method :meth:`Series.factorize` and :meth:`Index.factorize`.

Parameters
----------
{values}{sort}
na_sentinel : int or None, default -1
    Value to mark "not found". If None, will not drop the NaN
    from the uniques of the values.

    .. deprecated:: 1.5.0
        The na_sentinel argument is deprecated and
        will be removed in a future version of pandas. Specify use_na_sentinel as
        either True or False.

    .. versionchanged:: 1.1.2

use_na_sentinel : bool, default True
    If True, the sentinel -1 will be used for NaN values. If False,
    NaN values will be encoded as non-negative integers and will not drop the
    NaN from the uniques of the values.

    .. versionadded:: 1.5.0
{size_hint}\

Returns
-------
codes : ndarray
    An integer ndarray that's an indexer into `uniques`.
    ``uniques.take(codes)`` will have the same values as `values`.
uniques : ndarray, Index, or Categorical
    The unique valid values. When `values` is Categorical, `uniques`
    is a Categorical. When `values` is some other pandas object, an
    `Index` is returned. Otherwise, a 1-D ndarray is returned.

    .. note::

       Even if there's a missing value in `values`, `uniques` will
       *not* contain an entry for it.

See Also
--------
cut : Discretize continuous-valued array.
unique : Find the unique value in an array.

Notes
-----
Reference :ref:`the user guide &lt;reshaping.factorize&gt;` for more examples.

Examples
--------
These examples all show factorize as a top-level method like
``pd.factorize(values)``. The results are identical for methods like
:meth:`Series.factorize`.

&gt;&gt;&gt; codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'])
&gt;&gt;&gt; codes
array([0, 0, 1, 2, 0]...)
&gt;&gt;&gt; uniques
array(['b', 'a', 'c'], dtype=object)

With ``sort=True``, the `uniques` will be sorted, and `codes` will be
shuffled so that the relationship is the maintained.

&gt;&gt;&gt; codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'], sort=True)
&gt;&gt;&gt; codes
array([1, 1, 0, 2, 1]...)
&gt;&gt;&gt; uniques
array(['a', 'b', 'c'], dtype=object)

When ``use_na_sentinel=True`` (the default), missing values are indicated in
the `codes` with the sentinel value ``-1`` and missing values are not
included in `uniques`.

&gt;&gt;&gt; codes, uniques = pd.factorize(['b', None, 'a', 'c', 'b'])
&gt;&gt;&gt; codes
array([ 0, -1,  1,  2,  0]...)
&gt;&gt;&gt; uniques
array(['b', 'a', 'c'], dtype=object)

Thus far, we've only factorized lists (which are internally coerced to
NumPy arrays). When factorizing pandas objects, the type of `uniques`
will differ. For Categoricals, a `Categorical` is returned.

&gt;&gt;&gt; cat = pd.Categorical(['a', 'a', 'c'], categories=['a', 'b', 'c'])
&gt;&gt;&gt; codes, uniques = pd.factorize(cat)
&gt;&gt;&gt; codes
array([0, 0, 1]...)
&gt;&gt;&gt; uniques
['a', 'c']
Categories (3, object): ['a', 'b', 'c']

Notice that ``'b'`` is in ``uniques.categories``, despite not being
present in ``cat.values``.

For all other pandas objects, an Index of the appropriate type is
returned.

&gt;&gt;&gt; cat = pd.Series(['a', 'a', 'c'])
&gt;&gt;&gt; codes, uniques = pd.factorize(cat)
&gt;&gt;&gt; codes
array([0, 0, 1]...)
&gt;&gt;&gt; uniques
Index(['a', 'c'], dtype='object')

If NaN is in the values, and we want to include NaN in the uniques of the
values, it can be achieved by setting ``use_na_sentinel=False``.

&gt;&gt;&gt; values = np.array([1, 2, 1, np.nan])
&gt;&gt;&gt; codes, uniques = pd.factorize(values)  # default: use_na_sentinel=True
&gt;&gt;&gt; codes
array([ 0,  1,  0, -1])
&gt;&gt;&gt; uniques
array([1., 2.])

&gt;&gt;&gt; codes, uniques = pd.factorize(values, use_na_sentinel=False)
&gt;&gt;&gt; codes
array([0, 1, 0, 2])
&gt;&gt;&gt; uniques
array([ 1.,  2., nan])
</pre> <div class="fragment"><div class="line"><span class="lineno">  617</span>) -&gt; tuple[np.ndarray, np.ndarray | Index]:</div>
<div class="line"><span class="lineno">  618</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    Encode the object as an enumerated type or categorical variable.</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    This method is useful for obtaining a numeric representation of an</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    array when all that matters is identifying distinct values. `factorize`</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    is available as both a top-level function :func:`pandas.factorize`,</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    and as a method :meth:`Series.factorize` and :meth:`Index.factorize`.</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    {values}{sort}</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    na_sentinel : int or None, default -1</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        Value to mark &quot;not found&quot;. If None, will not drop the NaN</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        from the uniques of the values.</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">        .. deprecated:: 1.5.0</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">            The na_sentinel argument is deprecated and</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">            will be removed in a future version of pandas. Specify use_na_sentinel as</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">            either True or False.</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">        .. versionchanged:: 1.1.2</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    use_na_sentinel : bool, default True</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">        If True, the sentinel -1 will be used for NaN values. If False,</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        NaN values will be encoded as non-negative integers and will not drop the</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">        NaN from the uniques of the values.</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    {size_hint}\</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    codes : ndarray</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">        An integer ndarray that&#39;s an indexer into `uniques`.</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        ``uniques.take(codes)`` will have the same values as `values`.</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    uniques : ndarray, Index, or Categorical</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">        The unique valid values. When `values` is Categorical, `uniques`</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        is a Categorical. When `values` is some other pandas object, an</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        `Index` is returned. Otherwise, a 1-D ndarray is returned.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        .. note::</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">           Even if there&#39;s a missing value in `values`, `uniques` will</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">           *not* contain an entry for it.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    cut : Discretize continuous-valued array.</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    unique : Find the unique value in an array.</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    Reference :ref:`the user guide &lt;reshaping.factorize&gt;` for more examples.</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    These examples all show factorize as a top-level method like</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    ``pd.factorize(values)``. The results are identical for methods like</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    :meth:`Series.factorize`.</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    &gt;&gt;&gt; codes, uniques = pd.factorize([&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;])</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    &gt;&gt;&gt; codes</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    array([0, 0, 1, 2, 0]...)</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    &gt;&gt;&gt; uniques</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    array([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], dtype=object)</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    With ``sort=True``, the `uniques` will be sorted, and `codes` will be</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    shuffled so that the relationship is the maintained.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    &gt;&gt;&gt; codes, uniques = pd.factorize([&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;], sort=True)</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    &gt;&gt;&gt; codes</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    array([1, 1, 0, 2, 1]...)</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    &gt;&gt;&gt; uniques</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=object)</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    When ``use_na_sentinel=True`` (the default), missing values are indicated in</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    the `codes` with the sentinel value ``-1`` and missing values are not</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    included in `uniques`.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    &gt;&gt;&gt; codes, uniques = pd.factorize([&#39;b&#39;, None, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;])</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    &gt;&gt;&gt; codes</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    array([ 0, -1,  1,  2,  0]...)</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    &gt;&gt;&gt; uniques</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    array([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], dtype=object)</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    Thus far, we&#39;ve only factorized lists (which are internally coerced to</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    NumPy arrays). When factorizing pandas objects, the type of `uniques`</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    will differ. For Categoricals, a `Categorical` is returned.</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    &gt;&gt;&gt; cat = pd.Categorical([&#39;a&#39;, &#39;a&#39;, &#39;c&#39;], categories=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    &gt;&gt;&gt; codes, uniques = pd.factorize(cat)</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    &gt;&gt;&gt; codes</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    array([0, 0, 1]...)</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    &gt;&gt;&gt; uniques</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    [&#39;a&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    Notice that ``&#39;b&#39;`` is in ``uniques.categories``, despite not being</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    present in ``cat.values``.</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    For all other pandas objects, an Index of the appropriate type is</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    returned.</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    &gt;&gt;&gt; cat = pd.Series([&#39;a&#39;, &#39;a&#39;, &#39;c&#39;])</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    &gt;&gt;&gt; codes, uniques = pd.factorize(cat)</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    &gt;&gt;&gt; codes</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    array([0, 0, 1]...)</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    &gt;&gt;&gt; uniques</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    Index([&#39;a&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    If NaN is in the values, and we want to include NaN in the uniques of the</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    values, it can be achieved by setting ``use_na_sentinel=False``.</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    &gt;&gt;&gt; values = np.array([1, 2, 1, np.nan])</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    &gt;&gt;&gt; codes, uniques = pd.factorize(values)  # default: use_na_sentinel=True</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    &gt;&gt;&gt; codes</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    array([ 0,  1,  0, -1])</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    &gt;&gt;&gt; uniques</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    array([1., 2.])</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    &gt;&gt;&gt; codes, uniques = pd.factorize(values, use_na_sentinel=False)</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    &gt;&gt;&gt; codes</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    array([0, 1, 0, 2])</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    &gt;&gt;&gt; uniques</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    array([ 1.,  2., nan])</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  744</span>    <span class="comment"># Implementation notes: This method is responsible for 3 things</span></div>
<div class="line"><span class="lineno">  745</span>    <span class="comment"># 1.) coercing data to array-like (ndarray, Index, extension array)</span></div>
<div class="line"><span class="lineno">  746</span>    <span class="comment"># 2.) factorizing codes and uniques</span></div>
<div class="line"><span class="lineno">  747</span>    <span class="comment"># 3.) Maybe boxing the uniques in an Index</span></div>
<div class="line"><span class="lineno">  748</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  749</span>    <span class="comment"># Step 2 is dispatched to extension types (like Categorical). They are</span></div>
<div class="line"><span class="lineno">  750</span>    <span class="comment"># responsible only for factorization. All data coercion, sorting and boxing</span></div>
<div class="line"><span class="lineno">  751</span>    <span class="comment"># should happen here.</span></div>
<div class="line"><span class="lineno">  752</span> </div>
<div class="line"><span class="lineno">  753</span>    <span class="comment"># GH#46910 deprecated na_sentinel in favor of use_na_sentinel:</span></div>
<div class="line"><span class="lineno">  754</span>    <span class="comment">#   na_sentinel=None corresponds to use_na_sentinel=False</span></div>
<div class="line"><span class="lineno">  755</span>    <span class="comment">#   na_sentinel=-1 correspond to use_na_sentinel=True</span></div>
<div class="line"><span class="lineno">  756</span>    <span class="comment"># Other na_sentinel values will not be supported when the deprecation is enforced.</span></div>
<div class="line"><span class="lineno">  757</span>    na_sentinel = resolve_na_sentinel(na_sentinel, use_na_sentinel)</div>
<div class="line"><span class="lineno">  758</span>    <span class="keywordflow">if</span> isinstance(values, ABCRangeIndex):</div>
<div class="line"><span class="lineno">  759</span>        <span class="keywordflow">return</span> values.factorize(sort=sort)</div>
<div class="line"><span class="lineno">  760</span> </div>
<div class="line"><span class="lineno">  761</span>    values = _ensure_arraylike(values)</div>
<div class="line"><span class="lineno">  762</span>    original = values</div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(values, ABCMultiIndex):</div>
<div class="line"><span class="lineno">  764</span>        values = extract_array(values, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  765</span> </div>
<div class="line"><span class="lineno">  766</span>    <span class="comment"># GH35667, if na_sentinel=None, we will not dropna NaNs from the uniques</span></div>
<div class="line"><span class="lineno">  767</span>    <span class="comment"># of values, assign na_sentinel=-1 to replace code value for NaN.</span></div>
<div class="line"><span class="lineno">  768</span>    dropna = na_sentinel <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  769</span> </div>
<div class="line"><span class="lineno">  770</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  771</span>        isinstance(values, (ABCDatetimeArray, ABCTimedeltaArray))</div>
<div class="line"><span class="lineno">  772</span>        <span class="keywordflow">and</span> values.freq <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  773</span>    ):</div>
<div class="line"><span class="lineno">  774</span>        <span class="comment"># The presence of &#39;freq&#39; means we can fast-path sorting and know there</span></div>
<div class="line"><span class="lineno">  775</span>        <span class="comment">#  aren&#39;t NAs</span></div>
<div class="line"><span class="lineno">  776</span>        codes, uniques = values.factorize(sort=sort)</div>
<div class="line"><span class="lineno">  777</span>        <span class="keywordflow">return</span> _re_wrap_factorize(original, uniques, codes)</div>
<div class="line"><span class="lineno">  778</span> </div>
<div class="line"><span class="lineno">  779</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(values.dtype, np.dtype):</div>
<div class="line"><span class="lineno">  780</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  781</span>            na_sentinel == -1 <span class="keywordflow">or</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  782</span>        ) <span class="keywordflow">and</span> <span class="stringliteral">&quot;use_na_sentinel&quot;</span> <span class="keywordflow">in</span> inspect.signature(values.factorize).parameters:</div>
<div class="line"><span class="lineno">  783</span>            <span class="comment"># Avoid using catch_warnings when possible</span></div>
<div class="line"><span class="lineno">  784</span>            <span class="comment"># GH#46910 - TimelikeOps has deprecated signature</span></div>
<div class="line"><span class="lineno">  785</span>            codes, uniques = values.factorize(  <span class="comment"># type: ignore[call-arg]</span></div>
<div class="line"><span class="lineno">  786</span>                use_na_sentinel=na_sentinel <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  787</span>            )</div>
<div class="line"><span class="lineno">  788</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  789</span>            na_sentinel_arg = -1 <span class="keywordflow">if</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> na_sentinel</div>
<div class="line"><span class="lineno">  790</span>            <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno">  791</span>                <span class="comment"># We&#39;ve already warned above</span></div>
<div class="line"><span class="lineno">  792</span>                warnings.filterwarnings(<span class="stringliteral">&quot;ignore&quot;</span>, <span class="stringliteral">&quot;.*use_na_sentinel.*&quot;</span>, FutureWarning)</div>
<div class="line"><span class="lineno">  793</span>                codes, uniques = values.factorize(na_sentinel=na_sentinel_arg)</div>
<div class="line"><span class="lineno">  794</span> </div>
<div class="line"><span class="lineno">  795</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  796</span>        values = np.asarray(values)  <span class="comment"># convert DTA/TDA/MultiIndex</span></div>
<div class="line"><span class="lineno">  797</span>        <span class="comment"># TODO: pass na_sentinel=na_sentinel to factorize_array. When sort is True and</span></div>
<div class="line"><span class="lineno">  798</span>        <span class="comment">#       na_sentinel is None we append NA on the end because safe_sort does not</span></div>
<div class="line"><span class="lineno">  799</span>        <span class="comment">#       handle null values in uniques.</span></div>
<div class="line"><span class="lineno">  800</span>        <span class="keywordflow">if</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> sort:</div>
<div class="line"><span class="lineno">  801</span>            na_sentinel_arg = -1</div>
<div class="line"><span class="lineno">  802</span>        <span class="keywordflow">elif</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  803</span>            na_sentinel_arg = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  804</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  805</span>            na_sentinel_arg = na_sentinel</div>
<div class="line"><span class="lineno">  806</span> </div>
<div class="line"><span class="lineno">  807</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> dropna <span class="keywordflow">and</span> <span class="keywordflow">not</span> sort <span class="keywordflow">and</span> is_object_dtype(values):</div>
<div class="line"><span class="lineno">  808</span>            <span class="comment"># factorize can now handle differentiating various types of null values.</span></div>
<div class="line"><span class="lineno">  809</span>            <span class="comment"># These can only occur when the array has object dtype.</span></div>
<div class="line"><span class="lineno">  810</span>            <span class="comment"># However, for backwards compatibility we only use the null for the</span></div>
<div class="line"><span class="lineno">  811</span>            <span class="comment"># provided dtype. This may be revisited in the future, see GH#48476.</span></div>
<div class="line"><span class="lineno">  812</span>            null_mask = isna(values)</div>
<div class="line"><span class="lineno">  813</span>            <span class="keywordflow">if</span> null_mask.any():</div>
<div class="line"><span class="lineno">  814</span>                na_value = na_value_for_dtype(values.dtype, compat=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  815</span>                <span class="comment"># Don&#39;t modify (potentially user-provided) array</span></div>
<div class="line"><span class="lineno">  816</span>                values = np.where(null_mask, na_value, values)</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span>        codes, uniques = factorize_array(</div>
<div class="line"><span class="lineno">  819</span>            values,</div>
<div class="line"><span class="lineno">  820</span>            na_sentinel=na_sentinel_arg,</div>
<div class="line"><span class="lineno">  821</span>            size_hint=size_hint,</div>
<div class="line"><span class="lineno">  822</span>        )</div>
<div class="line"><span class="lineno">  823</span> </div>
<div class="line"><span class="lineno">  824</span>    <span class="keywordflow">if</span> sort <span class="keywordflow">and</span> len(uniques) &gt; 0:</div>
<div class="line"><span class="lineno">  825</span>        <span class="keywordflow">if</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  826</span>            <span class="comment"># TODO: Can remove when na_sentinel=na_sentinel as in TODO above</span></div>
<div class="line"><span class="lineno">  827</span>            na_sentinel = -1</div>
<div class="line"><span class="lineno">  828</span>        uniques, codes = safe_sort(</div>
<div class="line"><span class="lineno">  829</span>            uniques, codes, na_sentinel=na_sentinel, assume_unique=<span class="keyword">True</span>, verify=<span class="keyword">False</span></div>
<div class="line"><span class="lineno">  830</span>        )</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> dropna <span class="keywordflow">and</span> sort:</div>
<div class="line"><span class="lineno">  833</span>        <span class="comment"># TODO: Can remove entire block when na_sentinel=na_sentinel as in TODO above</span></div>
<div class="line"><span class="lineno">  834</span>        <span class="keywordflow">if</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  835</span>            na_sentinel_arg = -1</div>
<div class="line"><span class="lineno">  836</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  837</span>            na_sentinel_arg = na_sentinel</div>
<div class="line"><span class="lineno">  838</span>        code_is_na = codes == na_sentinel_arg</div>
<div class="line"><span class="lineno">  839</span>        <span class="keywordflow">if</span> code_is_na.any():</div>
<div class="line"><span class="lineno">  840</span>            <span class="comment"># na_value is set based on the dtype of uniques, and compat set to False is</span></div>
<div class="line"><span class="lineno">  841</span>            <span class="comment"># because we do not want na_value to be 0 for integers</span></div>
<div class="line"><span class="lineno">  842</span>            na_value = na_value_for_dtype(uniques.dtype, compat=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  843</span>            uniques = np.append(uniques, [na_value])</div>
<div class="line"><span class="lineno">  844</span>            codes = np.where(code_is_na, len(uniques) - 1, codes)</div>
<div class="line"><span class="lineno">  845</span> </div>
<div class="line"><span class="lineno">  846</span>    uniques = _reconstruct_data(uniques, original.dtype, original)</div>
<div class="line"><span class="lineno">  847</span> </div>
<div class="line"><span class="lineno">  848</span>    <span class="keywordflow">return</span> _re_wrap_factorize(original, uniques, codes)</div>
<div class="line"><span class="lineno">  849</span> </div>
<div class="line"><span class="lineno">  850</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a74f8aa3851b6c7db2db499afbfc15ba2" name="a74f8aa3851b6c7db2db499afbfc15ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f8aa3851b6c7db2db499afbfc15ba2">&#9670;&#160;</a></span>factorize_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], np.ndarray] pandas.core.algorithms.factorize_array </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>na_sentinel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>size_hint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object &#160;</td>
          <td class="paramname"><em>na_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Factorize a numpy array to codes and uniques.

This doesn't do any coercion of types or unboxing before factorization.

Parameters
----------
values : ndarray
na_sentinel : int, default -1
size_hint : int, optional
    Passed through to the hashtable's 'get_labels' method
na_value : object, optional
    A value in `values` to consider missing. Note: only use this
    parameter when you know that you don't have any values pandas would
    consider missing in the array (NaN for float data, iNaT for
    datetimes, etc.).
mask : ndarray[bool], optional
    If not None, the mask is used as indicator for missing values
    (True = missing, False = valid) instead of `na_value` or
    condition "val != val".

Returns
-------
codes : ndarray[np.intp]
uniques : ndarray
</pre> <div class="fragment"><div class="line"><span class="lineno">  532</span>) -&gt; tuple[npt.NDArray[np.intp], np.ndarray]:</div>
<div class="line"><span class="lineno">  533</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    Factorize a numpy array to codes and uniques.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    This doesn&#39;t do any coercion of types or unboxing before factorization.</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    values : ndarray</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    na_sentinel : int, default -1</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    size_hint : int, optional</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        Passed through to the hashtable&#39;s &#39;get_labels&#39; method</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    na_value : object, optional</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        A value in `values` to consider missing. Note: only use this</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        parameter when you know that you don&#39;t have any values pandas would</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">        consider missing in the array (NaN for float data, iNaT for</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">        datetimes, etc.).</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    mask : ndarray[bool], optional</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        If not None, the mask is used as indicator for missing values</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        (True = missing, False = valid) instead of `na_value` or</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">        condition &quot;val != val&quot;.</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    codes : ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    uniques : ndarray</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  559</span>    ignore_na = na_sentinel <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  560</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> ignore_na:</div>
<div class="line"><span class="lineno">  561</span>        na_sentinel = -1</div>
<div class="line"><span class="lineno">  562</span> </div>
<div class="line"><span class="lineno">  563</span>    original = values</div>
<div class="line"><span class="lineno">  564</span>    <span class="keywordflow">if</span> values.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno">  565</span>        <span class="comment"># _get_hashtable_algo will cast dt64/td64 to i8 via _ensure_data, so we</span></div>
<div class="line"><span class="lineno">  566</span>        <span class="comment">#  need to do the same to na_value. We are assuming here that the passed</span></div>
<div class="line"><span class="lineno">  567</span>        <span class="comment">#  na_value is an appropriately-typed NaT.</span></div>
<div class="line"><span class="lineno">  568</span>        <span class="comment"># e.g. test_where_datetimelike_categorical</span></div>
<div class="line"><span class="lineno">  569</span>        na_value = iNaT</div>
<div class="line"><span class="lineno">  570</span> </div>
<div class="line"><span class="lineno">  571</span>    hash_klass, values = _get_hashtable_algo(values)</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span>    table = hash_klass(size_hint <span class="keywordflow">or</span> len(values))</div>
<div class="line"><span class="lineno">  574</span>    uniques, codes = table.factorize(</div>
<div class="line"><span class="lineno">  575</span>        values,</div>
<div class="line"><span class="lineno">  576</span>        na_sentinel=na_sentinel,</div>
<div class="line"><span class="lineno">  577</span>        na_value=na_value,</div>
<div class="line"><span class="lineno">  578</span>        mask=mask,</div>
<div class="line"><span class="lineno">  579</span>        ignore_na=ignore_na,</div>
<div class="line"><span class="lineno">  580</span>    )</div>
<div class="line"><span class="lineno">  581</span> </div>
<div class="line"><span class="lineno">  582</span>    <span class="comment"># re-cast e.g. i8-&gt;dt64/td64, uint8-&gt;bool</span></div>
<div class="line"><span class="lineno">  583</span>    uniques = _reconstruct_data(uniques, original.dtype, original)</div>
<div class="line"><span class="lineno">  584</span> </div>
<div class="line"><span class="lineno">  585</span>    codes = ensure_platform_int(codes)</div>
<div class="line"><span class="lineno">  586</span>    <span class="keywordflow">return</span> codes, uniques</div>
<div class="line"><span class="lineno">  587</span> </div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span><span class="preprocessor">@doc</span>(</div>
<div class="line"><span class="lineno">  590</span>    values=dedent(</div>
<div class="line"><span class="lineno">  591</span>        <span class="stringliteral">&quot;&quot;&quot;\</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    values : sequence</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        A 1-D sequence. Sequences that aren&#39;t pandas objects are</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        coerced to ndarrays before factorization.</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  596</span>    ),</div>
<div class="line"><span class="lineno">  597</span>    sort=dedent(</div>
<div class="line"><span class="lineno">  598</span>        <span class="stringliteral">&quot;&quot;&quot;\</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    sort : bool, default False</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">        Sort `uniques` and shuffle `codes` to maintain the</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        relationship.</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  603</span>    ),</div>
<div class="line"><span class="lineno">  604</span>    size_hint=dedent(</div>
<div class="line"><span class="lineno">  605</span>        <span class="stringliteral">&quot;&quot;&quot;\</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    size_hint : int, optional</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">        Hint to the hashtable sizer.</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  609</span>    ),</div>
<div class="line"><span class="lineno">  610</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0dc394a0f66946b43dbf0479a5e3fbe" name="ad0dc394a0f66946b43dbf0479a5e3fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dc394a0f66946b43dbf0479a5e3fbe">&#9670;&#160;</a></span>isin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] pandas.core.algorithms.isin </td>
          <td>(</td>
          <td class="paramtype">AnyArrayLike&#160;</td>
          <td class="paramname"><em>comps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyArrayLike&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the isin boolean array.

Parameters
----------
comps : array-like
values : array-like

Returns
-------
ndarray[bool]
    Same length as `comps`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  439</span><span class="keyword">def </span>isin(comps: AnyArrayLike, values: AnyArrayLike) -&gt; npt.NDArray[np.bool_]:</div>
<div class="line"><span class="lineno">  440</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    Compute the isin boolean array.</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    comps : array-like</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    values : array-like</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    ndarray[bool]</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        Same length as `comps`.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  453</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(comps):</div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  455</span>            <span class="stringliteral">&quot;only list-like objects are allowed to be passed &quot;</span></div>
<div class="line"><span class="lineno">  456</span>            f<span class="stringliteral">&quot;to isin(), you passed a [{type(comps).__name__}]&quot;</span></div>
<div class="line"><span class="lineno">  457</span>        )</div>
<div class="line"><span class="lineno">  458</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(values):</div>
<div class="line"><span class="lineno">  459</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  460</span>            <span class="stringliteral">&quot;only list-like objects are allowed to be passed &quot;</span></div>
<div class="line"><span class="lineno">  461</span>            f<span class="stringliteral">&quot;to isin(), you passed a [{type(values).__name__}]&quot;</span></div>
<div class="line"><span class="lineno">  462</span>        )</div>
<div class="line"><span class="lineno">  463</span> </div>
<div class="line"><span class="lineno">  464</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(values, (ABCIndex, ABCSeries, ABCExtensionArray, np.ndarray)):</div>
<div class="line"><span class="lineno">  465</span>        orig_values = values</div>
<div class="line"><span class="lineno">  466</span>        values = _ensure_arraylike(list(values))</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>        <span class="keywordflow">if</span> is_numeric_dtype(values) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_signed_integer_dtype(comps):</div>
<div class="line"><span class="lineno">  469</span>            <span class="comment"># GH#46485 Use object to avoid upcast to float64 later</span></div>
<div class="line"><span class="lineno">  470</span>            <span class="comment"># TODO: Share with _find_common_type_compat</span></div>
<div class="line"><span class="lineno">  471</span>            values = construct_1d_object_array_from_listlike(list(orig_values))</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordflow">elif</span> isinstance(values, ABCMultiIndex):</div>
<div class="line"><span class="lineno">  474</span>        <span class="comment"># Avoid raising in extract_array</span></div>
<div class="line"><span class="lineno">  475</span>        values = np.array(values)</div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  477</span>        values = extract_array(values, extract_numpy=<span class="keyword">True</span>, extract_range=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  478</span> </div>
<div class="line"><span class="lineno">  479</span>    comps_array = _ensure_arraylike(comps)</div>
<div class="line"><span class="lineno">  480</span>    comps_array = extract_array(comps_array, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  481</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(comps_array, np.ndarray):</div>
<div class="line"><span class="lineno">  482</span>        <span class="comment"># i.e. Extension Array</span></div>
<div class="line"><span class="lineno">  483</span>        <span class="keywordflow">return</span> comps_array.isin(values)</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span>    <span class="keywordflow">elif</span> needs_i8_conversion(comps_array.dtype):</div>
<div class="line"><span class="lineno">  486</span>        <span class="comment"># Dispatch to DatetimeLikeArrayMixin.isin</span></div>
<div class="line"><span class="lineno">  487</span>        <span class="keywordflow">return</span> pd_array(comps_array).isin(values)</div>
<div class="line"><span class="lineno">  488</span>    <span class="keywordflow">elif</span> needs_i8_conversion(values.dtype) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_object_dtype(comps_array.dtype):</div>
<div class="line"><span class="lineno">  489</span>        <span class="comment"># e.g. comps_array are integers and values are datetime64s</span></div>
<div class="line"><span class="lineno">  490</span>        <span class="keywordflow">return</span> np.zeros(comps_array.shape, dtype=bool)</div>
<div class="line"><span class="lineno">  491</span>        <span class="comment"># TODO: not quite right ... Sparse/Categorical</span></div>
<div class="line"><span class="lineno">  492</span>    <span class="keywordflow">elif</span> needs_i8_conversion(values.dtype):</div>
<div class="line"><span class="lineno">  493</span>        <span class="keywordflow">return</span> isin(comps_array, values.astype(object))</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>    <span class="keywordflow">elif</span> isinstance(values.dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno">  496</span>        <span class="keywordflow">return</span> isin(np.asarray(comps_array), np.asarray(values))</div>
<div class="line"><span class="lineno">  497</span> </div>
<div class="line"><span class="lineno">  498</span>    <span class="comment"># GH16012</span></div>
<div class="line"><span class="lineno">  499</span>    <span class="comment"># Ensure np.in1d doesn&#39;t get object types or it *may* throw an exception</span></div>
<div class="line"><span class="lineno">  500</span>    <span class="comment"># Albeit hashmap has O(1) look-up (vs. O(logn) in sorted array),</span></div>
<div class="line"><span class="lineno">  501</span>    <span class="comment"># in1d is faster for small sizes</span></div>
<div class="line"><span class="lineno">  502</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  503</span>        len(comps_array) &gt; 1_000_000</div>
<div class="line"><span class="lineno">  504</span>        <span class="keywordflow">and</span> len(values) &lt;= 26</div>
<div class="line"><span class="lineno">  505</span>        <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_object_dtype(comps_array)</div>
<div class="line"><span class="lineno">  506</span>    ):</div>
<div class="line"><span class="lineno">  507</span>        <span class="comment"># If the values include nan we need to check for nan explicitly</span></div>
<div class="line"><span class="lineno">  508</span>        <span class="comment"># since np.nan it not equal to np.nan</span></div>
<div class="line"><span class="lineno">  509</span>        <span class="keywordflow">if</span> isna(values).any():</div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span>            <span class="keyword">def </span><a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(c, v):</div>
<div class="line"><span class="lineno">  512</span>                <span class="keywordflow">return</span> np.logical_or(np.in1d(c, v), np.isnan(c))</div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  515</span>            f = np.in1d</div>
<div class="line"><span class="lineno">  516</span> </div>
<div class="line"><span class="lineno">  517</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  518</span>        common = np.find_common_type([values.dtype, comps_array.dtype], [])</div>
<div class="line"><span class="lineno">  519</span>        values = values.astype(common, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  520</span>        comps_array = comps_array.astype(common, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  521</span>        f = htable.ismember</div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(comps_array, values)</div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_af01a903df7bdb7a494f5827e45bf3a2a"><div class="ttname"><a href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a></div><div class="ttdeci">void int int int int npy_complex64 int int npy_complex64 float float npy_complex64 npy_complex64 * f</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:262</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abce89cf7249e152882399c613f25ff4c" name="abce89cf7249e152882399c613f25ff4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce89cf7249e152882399c613f25ff4c">&#9670;&#160;</a></span>mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.algorithms.mode </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dropna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the mode(s) of an array.

Parameters
----------
values : array-like
    Array over which to check for duplicate values.
dropna : bool, default True
    Don't consider counts of NaN/NaT.

Returns
-------
np.ndarray or ExtensionArray
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1064</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1065</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    Returns the mode(s) of an array.</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    values : array-like</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">        Array over which to check for duplicate values.</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    dropna : bool, default True</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">        Don&#39;t consider counts of NaN/NaT.</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1079</span>    values = _ensure_arraylike(values)</div>
<div class="line"><span class="lineno"> 1080</span>    original = values</div>
<div class="line"><span class="lineno"> 1081</span> </div>
<div class="line"><span class="lineno"> 1082</span>    <span class="keywordflow">if</span> needs_i8_conversion(values.dtype):</div>
<div class="line"><span class="lineno"> 1083</span>        <span class="comment"># Got here with ndarray; dispatch to DatetimeArray/TimedeltaArray.</span></div>
<div class="line"><span class="lineno"> 1084</span>        values = ensure_wrapped_if_datetimelike(values)</div>
<div class="line"><span class="lineno"> 1085</span>        values = cast(<span class="stringliteral">&quot;ExtensionArray&quot;</span>, values)</div>
<div class="line"><span class="lineno"> 1086</span>        <span class="keywordflow">return</span> values._mode(dropna=dropna)</div>
<div class="line"><span class="lineno"> 1087</span> </div>
<div class="line"><span class="lineno"> 1088</span>    values = _ensure_data(values)</div>
<div class="line"><span class="lineno"> 1089</span> </div>
<div class="line"><span class="lineno"> 1090</span>    npresult = htable.mode(values, dropna=dropna, mask=mask)</div>
<div class="line"><span class="lineno"> 1091</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1092</span>        npresult = np.sort(npresult)</div>
<div class="line"><span class="lineno"> 1093</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1094</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1095</span>            f<span class="stringliteral">&quot;Unable to sort modes: {err}&quot;</span>,</div>
<div class="line"><span class="lineno"> 1096</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1097</span>        )</div>
<div class="line"><span class="lineno"> 1098</span> </div>
<div class="line"><span class="lineno"> 1099</span>    result = _reconstruct_data(npresult, original.dtype, original)</div>
<div class="line"><span class="lineno"> 1100</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1101</span> </div>
<div class="line"><span class="lineno"> 1102</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a33d326870eb5bfc64588bc44c36052ed" name="a33d326870eb5bfc64588bc44c36052ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d326870eb5bfc64588bc44c36052ed">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.float64] pandas.core.algorithms.rank </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;average&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>na_option</em> = <code>&quot;keep&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pct</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rank the values along a given axis.

Parameters
----------
values : np.ndarray or ExtensionArray
    Array whose values will be ranked. The number of dimensions in this
    array must not exceed 2.
axis : int, default 0
    Axis over which to perform rankings.
method : {'average', 'min', 'max', 'first', 'dense'}, default 'average'
    The method by which tiebreaks are broken during the ranking.
na_option : {'keep', 'top'}, default 'keep'
    The method by which NaNs are placed in the ranking.
    - ``keep``: rank each NaN value with a NaN ranking
    - ``top``: replace each NaN with either +/- inf so that they
               there are ranked at the top
ascending : bool, default True
    Whether or not the elements should be ranked in ascending order.
pct : bool, default False
    Whether or not to the display the returned rankings in integer form
    (e.g. 1, 2, 3) or in percentile form (e.g. 0.333..., 0.666..., 1).
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1110</span>) -&gt; npt.NDArray[np.float64]:</div>
<div class="line"><span class="lineno"> 1111</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">    Rank the values along a given axis.</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    values : np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">        Array whose values will be ranked. The number of dimensions in this</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">        array must not exceed 2.</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    axis : int, default 0</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">        Axis over which to perform rankings.</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}, default &#39;average&#39;</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">        The method by which tiebreaks are broken during the ranking.</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    na_option : {&#39;keep&#39;, &#39;top&#39;}, default &#39;keep&#39;</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">        The method by which NaNs are placed in the ranking.</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">        - ``keep``: rank each NaN value with a NaN ranking</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">        - ``top``: replace each NaN with either +/- inf so that they</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">                   there are ranked at the top</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    ascending : bool, default True</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">        Whether or not the elements should be ranked in ascending order.</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    pct : bool, default False</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">        Whether or not to the display the returned rankings in integer form</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">        (e.g. 1, 2, 3) or in percentile form (e.g. 0.333..., 0.666..., 1).</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1134</span>    is_datetimelike = needs_i8_conversion(values.dtype)</div>
<div class="line"><span class="lineno"> 1135</span>    values = _ensure_data(values)</div>
<div class="line"><span class="lineno"> 1136</span> </div>
<div class="line"><span class="lineno"> 1137</span>    <span class="keywordflow">if</span> values.ndim == 1:</div>
<div class="line"><span class="lineno"> 1138</span>        ranks = algos.rank_1d(</div>
<div class="line"><span class="lineno"> 1139</span>            values,</div>
<div class="line"><span class="lineno"> 1140</span>            is_datetimelike=is_datetimelike,</div>
<div class="line"><span class="lineno"> 1141</span>            ties_method=method,</div>
<div class="line"><span class="lineno"> 1142</span>            ascending=ascending,</div>
<div class="line"><span class="lineno"> 1143</span>            na_option=na_option,</div>
<div class="line"><span class="lineno"> 1144</span>            pct=pct,</div>
<div class="line"><span class="lineno"> 1145</span>        )</div>
<div class="line"><span class="lineno"> 1146</span>    <span class="keywordflow">elif</span> values.ndim == 2:</div>
<div class="line"><span class="lineno"> 1147</span>        ranks = algos.rank_2d(</div>
<div class="line"><span class="lineno"> 1148</span>            values,</div>
<div class="line"><span class="lineno"> 1149</span>            axis=axis,</div>
<div class="line"><span class="lineno"> 1150</span>            is_datetimelike=is_datetimelike,</div>
<div class="line"><span class="lineno"> 1151</span>            ties_method=method,</div>
<div class="line"><span class="lineno"> 1152</span>            ascending=ascending,</div>
<div class="line"><span class="lineno"> 1153</span>            na_option=na_option,</div>
<div class="line"><span class="lineno"> 1154</span>            pct=pct,</div>
<div class="line"><span class="lineno"> 1155</span>        )</div>
<div class="line"><span class="lineno"> 1156</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1157</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Array with ndim &gt; 2 are not supported.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1158</span> </div>
<div class="line"><span class="lineno"> 1159</span>    <span class="keywordflow">return</span> ranks</div>
<div class="line"><span class="lineno"> 1160</span> </div>
<div class="line"><span class="lineno"> 1161</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a908c3c3639ea05762f11fd5e0c587aa0" name="a908c3c3639ea05762f11fd5e0c587aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908c3c3639ea05762f11fd5e0c587aa0">&#9670;&#160;</a></span>resolve_na_sentinel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None pandas.core.algorithms.resolve_na_sentinel </td>
          <td>(</td>
          <td class="paramtype">int | None | lib.NoDefault&#160;</td>
          <td class="paramname"><em>na_sentinel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault&#160;</td>
          <td class="paramname"><em>use_na_sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine value of na_sentinel for factorize methods.

See GH#46910 for details on the deprecation.

Parameters
----------
na_sentinel : int, None, or lib.no_default
    Value passed to the method.
use_na_sentinel : bool or lib.no_default
    Value passed to the method.

Returns
-------
Resolved value of na_sentinel.
</pre> <div class="fragment"><div class="line"><span class="lineno">  854</span>) -&gt; int | <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  855</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    Determine value of na_sentinel for factorize methods.</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    See GH#46910 for details on the deprecation.</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    na_sentinel : int, None, or lib.no_default</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">        Value passed to the method.</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    use_na_sentinel : bool or lib.no_default</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">        Value passed to the method.</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    Resolved value of na_sentinel.</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  871</span>    <span class="keywordflow">if</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordflow">not</span> lib.no_default <span class="keywordflow">and</span> use_na_sentinel <span class="keywordflow">is</span> <span class="keywordflow">not</span> lib.no_default:</div>
<div class="line"><span class="lineno">  872</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  873</span>            <span class="stringliteral">&quot;Cannot specify both `na_sentinel` and `use_na_sentile`; &quot;</span></div>
<div class="line"><span class="lineno">  874</span>            f<span class="stringliteral">&quot;got `na_sentinel={na_sentinel}` and `use_na_sentinel={use_na_sentinel}`&quot;</span></div>
<div class="line"><span class="lineno">  875</span>        )</div>
<div class="line"><span class="lineno">  876</span>    <span class="keywordflow">if</span> na_sentinel <span class="keywordflow">is</span> lib.no_default:</div>
<div class="line"><span class="lineno">  877</span>        result = -1 <span class="keywordflow">if</span> use_na_sentinel <span class="keywordflow">is</span> lib.no_default <span class="keywordflow">or</span> use_na_sentinel <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  878</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  879</span>        <span class="keywordflow">if</span> na_sentinel <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  880</span>            msg = (</div>
<div class="line"><span class="lineno">  881</span>                <span class="stringliteral">&quot;Specifying `na_sentinel=None` is deprecated, specify &quot;</span></div>
<div class="line"><span class="lineno">  882</span>                <span class="stringliteral">&quot;`use_na_sentinel=False` instead.&quot;</span></div>
<div class="line"><span class="lineno">  883</span>            )</div>
<div class="line"><span class="lineno">  884</span>        <span class="keywordflow">elif</span> na_sentinel == -1:</div>
<div class="line"><span class="lineno">  885</span>            msg = (</div>
<div class="line"><span class="lineno">  886</span>                <span class="stringliteral">&quot;Specifying `na_sentinel=-1` is deprecated, specify &quot;</span></div>
<div class="line"><span class="lineno">  887</span>                <span class="stringliteral">&quot;`use_na_sentinel=True` instead.&quot;</span></div>
<div class="line"><span class="lineno">  888</span>            )</div>
<div class="line"><span class="lineno">  889</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  890</span>            msg = (</div>
<div class="line"><span class="lineno">  891</span>                <span class="stringliteral">&quot;Specifying the specific value to use for `na_sentinel` is &quot;</span></div>
<div class="line"><span class="lineno">  892</span>                <span class="stringliteral">&quot;deprecated and will be removed in a future version of pandas. &quot;</span></div>
<div class="line"><span class="lineno">  893</span>                <span class="stringliteral">&quot;Specify `use_na_sentinel=True` to use the sentinel value -1, and &quot;</span></div>
<div class="line"><span class="lineno">  894</span>                <span class="stringliteral">&quot;`use_na_sentinel=False` to encode NaN values.&quot;</span></div>
<div class="line"><span class="lineno">  895</span>            )</div>
<div class="line"><span class="lineno">  896</span>        warnings.warn(msg, FutureWarning, stacklevel=find_stack_level())</div>
<div class="line"><span class="lineno">  897</span>        result = na_sentinel</div>
<div class="line"><span class="lineno">  898</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  899</span> </div>
<div class="line"><span class="lineno">  900</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5430fe14107fd86b141565c8e8a2c52f" name="a5430fe14107fd86b141565c8e8a2c52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5430fe14107fd86b141565c8e8a2c52f">&#9670;&#160;</a></span>safe_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray | MultiIndex | tuple[np.ndarray | MultiIndex, np.ndarray] pandas.core.algorithms.safe_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>codes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>na_sentinel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>assume_unique</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>verify</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sort ``values`` and reorder corresponding ``codes``.

``values`` should be unique if ``codes`` is not None.
Safe for use with mixed types (int, str), orders ints before strs.

Parameters
----------
values : list-like
    Sequence; must be unique if ``codes`` is not None.
codes : list_like, optional
    Indices to ``values``. All out of bound indices are treated as
    "not found" and will be masked with ``na_sentinel``.
na_sentinel : int, default -1
    Value in ``codes`` to mark "not found".
    Ignored when ``codes`` is None.
assume_unique : bool, default False
    When True, ``values`` are assumed to be unique, which can speed up
    the calculation. Ignored when ``codes`` is None.
verify : bool, default True
    Check if codes are out of bound for the values and put out of bound
    codes equal to na_sentinel. If ``verify=False``, it is assumed there
    are no out of bound codes. Ignored when ``codes`` is None.

    .. versionadded:: 0.25.0

Returns
-------
ordered : ndarray or MultiIndex
    Sorted ``values``
new_codes : ndarray
    Reordered ``codes``; returned when ``codes`` is not None.

Raises
------
TypeError
    * If ``values`` is not list-like or if ``codes`` is neither None
    nor list-like
    * If ``values`` cannot be sorted
ValueError
    * If ``codes`` is not None and ``values`` contain duplicates.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1797</span>) -&gt; np.ndarray | MultiIndex | tuple[np.ndarray | MultiIndex, np.ndarray]:</div>
<div class="line"><span class="lineno"> 1798</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">    Sort ``values`` and reorder corresponding ``codes``.</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">    ``values`` should be unique if ``codes`` is not None.</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">    Safe for use with mixed types (int, str), orders ints before strs.</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    values : list-like</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">        Sequence; must be unique if ``codes`` is not None.</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">    codes : list_like, optional</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">        Indices to ``values``. All out of bound indices are treated as</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">        &quot;not found&quot; and will be masked with ``na_sentinel``.</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">    na_sentinel : int, default -1</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">        Value in ``codes`` to mark &quot;not found&quot;.</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">        Ignored when ``codes`` is None.</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    assume_unique : bool, default False</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">        When True, ``values`` are assumed to be unique, which can speed up</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">        the calculation. Ignored when ``codes`` is None.</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">    verify : bool, default True</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">        Check if codes are out of bound for the values and put out of bound</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        codes equal to na_sentinel. If ``verify=False``, it is assumed there</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">        are no out of bound codes. Ignored when ``codes`` is None.</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">        .. versionadded:: 0.25.0</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    ordered : ndarray or MultiIndex</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">        Sorted ``values``</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    new_codes : ndarray</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        Reordered ``codes``; returned when ``codes`` is not None.</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">        * If ``values`` is not list-like or if ``codes`` is neither None</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">        nor list-like</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">        * If ``values`` cannot be sorted</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">        * If ``codes`` is not None and ``values`` contain duplicates.</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1840</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(values):</div>
<div class="line"><span class="lineno"> 1841</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1842</span>            <span class="stringliteral">&quot;Only list-like objects are allowed to be passed to safe_sort as values&quot;</span></div>
<div class="line"><span class="lineno"> 1843</span>        )</div>
<div class="line"><span class="lineno"> 1844</span>    original_values = values</div>
<div class="line"><span class="lineno"> 1845</span>    is_mi = isinstance(original_values, ABCMultiIndex)</div>
<div class="line"><span class="lineno"> 1846</span> </div>
<div class="line"><span class="lineno"> 1847</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(values, (np.ndarray, ABCExtensionArray)):</div>
<div class="line"><span class="lineno"> 1848</span>        <span class="comment"># don&#39;t convert to string types</span></div>
<div class="line"><span class="lineno"> 1849</span>        dtype, _ = infer_dtype_from_array(values)</div>
<div class="line"><span class="lineno"> 1850</span>        <span class="comment"># error: Argument &quot;dtype&quot; to &quot;asarray&quot; has incompatible type &quot;Union[dtype[Any],</span></div>
<div class="line"><span class="lineno"> 1851</span>        <span class="comment"># ExtensionDtype]&quot;; expected &quot;Union[dtype[Any], None, type, _SupportsDType, str,</span></div>
<div class="line"><span class="lineno"> 1852</span>        <span class="comment"># Union[Tuple[Any, int], Tuple[Any, Union[int, Sequence[int]]], List[Any],</span></div>
<div class="line"><span class="lineno"> 1853</span>        <span class="comment"># _DTypeDict, Tuple[Any, Any]]]&quot;</span></div>
<div class="line"><span class="lineno"> 1854</span>        values = np.asarray(values, dtype=dtype)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 1855</span> </div>
<div class="line"><span class="lineno"> 1856</span>    sorter = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1857</span>    ordered: np.ndarray | MultiIndex</div>
<div class="line"><span class="lineno"> 1858</span> </div>
<div class="line"><span class="lineno"> 1859</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1860</span>        <span class="keywordflow">not</span> is_extension_array_dtype(values)</div>
<div class="line"><span class="lineno"> 1861</span>        <span class="keywordflow">and</span> lib.infer_dtype(values, skipna=<span class="keyword">False</span>) == <span class="stringliteral">&quot;mixed-integer&quot;</span></div>
<div class="line"><span class="lineno"> 1862</span>    ):</div>
<div class="line"><span class="lineno"> 1863</span>        ordered = _sort_mixed(values)</div>
<div class="line"><span class="lineno"> 1864</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1865</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1866</span>            sorter = values.argsort()</div>
<div class="line"><span class="lineno"> 1867</span>            <span class="keywordflow">if</span> is_mi:</div>
<div class="line"><span class="lineno"> 1868</span>                <span class="comment"># Operate on original object instead of casted array (MultiIndex)</span></div>
<div class="line"><span class="lineno"> 1869</span>                ordered = original_values.take(sorter)</div>
<div class="line"><span class="lineno"> 1870</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1871</span>                ordered = values.take(sorter)</div>
<div class="line"><span class="lineno"> 1872</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1873</span>            <span class="comment"># Previous sorters failed or were not applicable, try `_sort_mixed`</span></div>
<div class="line"><span class="lineno"> 1874</span>            <span class="comment"># which would work, but which fails for special case of 1d arrays</span></div>
<div class="line"><span class="lineno"> 1875</span>            <span class="comment"># with tuples.</span></div>
<div class="line"><span class="lineno"> 1876</span>            <span class="keywordflow">if</span> values.size <span class="keywordflow">and</span> isinstance(values[0], tuple):</div>
<div class="line"><span class="lineno"> 1877</span>                ordered = _sort_tuples(values, original_values)</div>
<div class="line"><span class="lineno"> 1878</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1879</span>                ordered = _sort_mixed(values)</div>
<div class="line"><span class="lineno"> 1880</span> </div>
<div class="line"><span class="lineno"> 1881</span>    <span class="comment"># codes:</span></div>
<div class="line"><span class="lineno"> 1882</span> </div>
<div class="line"><span class="lineno"> 1883</span>    <span class="keywordflow">if</span> codes <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1884</span>        <span class="keywordflow">return</span> ordered</div>
<div class="line"><span class="lineno"> 1885</span> </div>
<div class="line"><span class="lineno"> 1886</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(codes):</div>
<div class="line"><span class="lineno"> 1887</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1888</span>            <span class="stringliteral">&quot;Only list-like objects or None are allowed to &quot;</span></div>
<div class="line"><span class="lineno"> 1889</span>            <span class="stringliteral">&quot;be passed to safe_sort as codes&quot;</span></div>
<div class="line"><span class="lineno"> 1890</span>        )</div>
<div class="line"><span class="lineno"> 1891</span>    codes = ensure_platform_int(np.asarray(codes))</div>
<div class="line"><span class="lineno"> 1892</span> </div>
<div class="line"><span class="lineno"> 1893</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> assume_unique <span class="keywordflow">and</span> <span class="keywordflow">not</span> len(unique(values)) == len(values):</div>
<div class="line"><span class="lineno"> 1894</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;values should be unique if codes is not None&quot;</span>)</div>
<div class="line"><span class="lineno"> 1895</span> </div>
<div class="line"><span class="lineno"> 1896</span>    <span class="keywordflow">if</span> sorter <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1897</span>        <span class="comment"># mixed types</span></div>
<div class="line"><span class="lineno"> 1898</span>        hash_klass, values = _get_hashtable_algo(values)</div>
<div class="line"><span class="lineno"> 1899</span>        t = hash_klass(len(values))</div>
<div class="line"><span class="lineno"> 1900</span>        t.map_locations(values)</div>
<div class="line"><span class="lineno"> 1901</span>        sorter = ensure_platform_int(t.lookup(ordered))</div>
<div class="line"><span class="lineno"> 1902</span> </div>
<div class="line"><span class="lineno"> 1903</span>    <span class="keywordflow">if</span> na_sentinel == -1:</div>
<div class="line"><span class="lineno"> 1904</span>        <span class="comment"># take_nd is faster, but only works for na_sentinels of -1</span></div>
<div class="line"><span class="lineno"> 1905</span>        order2 = sorter.argsort()</div>
<div class="line"><span class="lineno"> 1906</span>        new_codes = take_nd(order2, codes, fill_value=-1)</div>
<div class="line"><span class="lineno"> 1907</span>        <span class="keywordflow">if</span> verify:</div>
<div class="line"><span class="lineno"> 1908</span>            mask = (codes &lt; -len(values)) | (codes &gt;= len(values))</div>
<div class="line"><span class="lineno"> 1909</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1910</span>            mask = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1911</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1912</span>        reverse_indexer = np.empty(len(sorter), dtype=np.int_)</div>
<div class="line"><span class="lineno"> 1913</span>        reverse_indexer.put(sorter, np.arange(len(sorter)))</div>
<div class="line"><span class="lineno"> 1914</span>        <span class="comment"># Out of bound indices will be masked with `na_sentinel` next, so we</span></div>
<div class="line"><span class="lineno"> 1915</span>        <span class="comment"># may deal with them here without performance loss using `mode=&#39;wrap&#39;`</span></div>
<div class="line"><span class="lineno"> 1916</span>        new_codes = reverse_indexer.take(codes, mode=<span class="stringliteral">&quot;wrap&quot;</span>)</div>
<div class="line"><span class="lineno"> 1917</span> </div>
<div class="line"><span class="lineno"> 1918</span>        mask = codes == na_sentinel</div>
<div class="line"><span class="lineno"> 1919</span>        <span class="keywordflow">if</span> verify:</div>
<div class="line"><span class="lineno"> 1920</span>            mask = mask | (codes &lt; -len(values)) | (codes &gt;= len(values))</div>
<div class="line"><span class="lineno"> 1921</span> </div>
<div class="line"><span class="lineno"> 1922</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1923</span>        np.putmask(new_codes, mask, na_sentinel)</div>
<div class="line"><span class="lineno"> 1924</span> </div>
<div class="line"><span class="lineno"> 1925</span>    <span class="keywordflow">return</span> ordered, ensure_platform_int(new_codes)</div>
<div class="line"><span class="lineno"> 1926</span> </div>
<div class="line"><span class="lineno"> 1927</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae045f9a70b46994e5b96321911d27b71" name="ae045f9a70b46994e5b96321911d27b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae045f9a70b46994e5b96321911d27b71">&#9670;&#160;</a></span>searchsorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] | np.intp pandas.core.algorithms.searchsorted </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumpyValueArrayLike | <a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;left&quot;, &quot;right&quot;] &#160;</td>
          <td class="paramname"><em>side</em> = <code>&quot;left&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumpySorter &#160;</td>
          <td class="paramname"><em>sorter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find indices where elements should be inserted to maintain order.

.. versionadded:: 0.25.0

Find the indices into a sorted array `arr` (a) such that, if the
corresponding elements in `value` were inserted before the indices,
the order of `arr` would be preserved.

Assuming that `arr` is sorted:

======  ================================
`side`  returned index `i` satisfies
======  ================================
left    ``arr[i-1] &lt; value &lt;= self[i]``
right   ``arr[i-1] &lt;= value &lt; self[i]``
======  ================================

Parameters
----------
arr: np.ndarray, ExtensionArray, Series
    Input array. If `sorter` is None, then it must be sorted in
    ascending order, otherwise `sorter` must be an array of indices
    that sort it.
value : array-like or scalar
    Values to insert into `arr`.
side : {'left', 'right'}, optional
    If 'left', the index of the first suitable location found is given.
    If 'right', return the last such index.  If there is no suitable
    index, return either 0 or N (where N is the length of `self`).
sorter : 1-D array-like, optional
    Optional array of integer indices that sort array a into ascending
    order. They are typically the result of argsort.

Returns
-------
array of ints or int
    If value is array-like, array of insertion points.
    If value is scalar, a single integer.

See Also
--------
numpy.searchsorted : Similar method from NumPy.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1587</span>) -&gt; npt.NDArray[np.intp] | np.intp:</div>
<div class="line"><span class="lineno"> 1588</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    Find indices where elements should be inserted to maintain order.</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    .. versionadded:: 0.25.0</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    Find the indices into a sorted array `arr` (a) such that, if the</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    corresponding elements in `value` were inserted before the indices,</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    the order of `arr` would be preserved.</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    Assuming that `arr` is sorted:</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    ======  ================================</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">    `side`  returned index `i` satisfies</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    ======  ================================</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">    left    ``arr[i-1] &lt; value &lt;= self[i]``</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">    right   ``arr[i-1] &lt;= value &lt; self[i]``</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">    ======  ================================</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    arr: np.ndarray, ExtensionArray, Series</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">        Input array. If `sorter` is None, then it must be sorted in</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">        ascending order, otherwise `sorter` must be an array of indices</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">        that sort it.</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">    value : array-like or scalar</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">        Values to insert into `arr`.</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">    side : {&#39;left&#39;, &#39;right&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral">        If &#39;left&#39;, the index of the first suitable location found is given.</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        If &#39;right&#39;, return the last such index.  If there is no suitable</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">        index, return either 0 or N (where N is the length of `self`).</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">    sorter : 1-D array-like, optional</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">        Optional array of integer indices that sort array a into ascending</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">        order. They are typically the result of argsort.</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    array of ints or int</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">        If value is array-like, array of insertion points.</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">        If value is scalar, a single integer.</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">    numpy.searchsorted : Similar method from NumPy.</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1632</span>    <span class="keywordflow">if</span> sorter <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1633</span>        sorter = ensure_platform_int(sorter)</div>
<div class="line"><span class="lineno"> 1634</span> </div>
<div class="line"><span class="lineno"> 1635</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1636</span>        isinstance(arr, np.ndarray)</div>
<div class="line"><span class="lineno"> 1637</span>        <span class="keywordflow">and</span> is_integer_dtype(arr.dtype)</div>
<div class="line"><span class="lineno"> 1638</span>        <span class="keywordflow">and</span> (is_integer(value) <span class="keywordflow">or</span> is_integer_dtype(value))</div>
<div class="line"><span class="lineno"> 1639</span>    ):</div>
<div class="line"><span class="lineno"> 1640</span>        <span class="comment"># if `arr` and `value` have different dtypes, `arr` would be</span></div>
<div class="line"><span class="lineno"> 1641</span>        <span class="comment"># recast by numpy, causing a slow search.</span></div>
<div class="line"><span class="lineno"> 1642</span>        <span class="comment"># Before searching below, we therefore try to give `value` the</span></div>
<div class="line"><span class="lineno"> 1643</span>        <span class="comment"># same dtype as `arr`, while guarding against integer overflows.</span></div>
<div class="line"><span class="lineno"> 1644</span>        iinfo = np.iinfo(arr.dtype.type)</div>
<div class="line"><span class="lineno"> 1645</span>        value_arr = np.array([value]) <span class="keywordflow">if</span> is_scalar(value) <span class="keywordflow">else</span> np.array(value)</div>
<div class="line"><span class="lineno"> 1646</span>        <span class="keywordflow">if</span> (value_arr &gt;= iinfo.min).all() <span class="keywordflow">and</span> (value_arr &lt;= iinfo.max).all():</div>
<div class="line"><span class="lineno"> 1647</span>            <span class="comment"># value within bounds, so no overflow, so can convert value dtype</span></div>
<div class="line"><span class="lineno"> 1648</span>            <span class="comment"># to dtype of arr</span></div>
<div class="line"><span class="lineno"> 1649</span>            dtype = arr.dtype</div>
<div class="line"><span class="lineno"> 1650</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1651</span>            dtype = value_arr.dtype</div>
<div class="line"><span class="lineno"> 1652</span> </div>
<div class="line"><span class="lineno"> 1653</span>        <span class="keywordflow">if</span> is_scalar(value):</div>
<div class="line"><span class="lineno"> 1654</span>            <span class="comment"># We know that value is int</span></div>
<div class="line"><span class="lineno"> 1655</span>            value = cast(int, dtype.type(value))</div>
<div class="line"><span class="lineno"> 1656</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1657</span>            value = pd_array(cast(ArrayLike, value), dtype=dtype)</div>
<div class="line"><span class="lineno"> 1658</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1659</span>        <span class="comment"># E.g. if `arr` is an array with dtype=&#39;datetime64[ns]&#39;</span></div>
<div class="line"><span class="lineno"> 1660</span>        <span class="comment"># and `value` is a pd.Timestamp, we may need to convert value</span></div>
<div class="line"><span class="lineno"> 1661</span>        arr = ensure_wrapped_if_datetimelike(arr)</div>
<div class="line"><span class="lineno"> 1662</span> </div>
<div class="line"><span class="lineno"> 1663</span>    <span class="comment"># Argument 1 to &quot;searchsorted&quot; of &quot;ndarray&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 1664</span>    <span class="comment"># &quot;Union[NumpyValueArrayLike, ExtensionArray]&quot;; expected &quot;NumpyValueArrayLike&quot;</span></div>
<div class="line"><span class="lineno"> 1665</span>    <span class="keywordflow">return</span> arr.searchsorted(value, side=side, sorter=sorter)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 1666</span> </div>
<div class="line"><span class="lineno"> 1667</span> </div>
<div class="line"><span class="lineno"> 1668</span><span class="comment"># ---- #</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="comment"># diff #</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="comment"># ---- #</span></div>
<div class="line"><span class="lineno"> 1671</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adbad8a0202f851027f2c12932e2128c4" name="adbad8a0202f851027f2c12932e2128c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbad8a0202f851027f2c12932e2128c4">&#9670;&#160;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.algorithms.take </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TakeIndexer&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>allow_fill</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take elements from an array.

Parameters
----------
arr : array-like or scalar value
    Non array-likes (sequences/scalars without a dtype) are coerced
    to an ndarray.
indices : sequence of int or one-dimensional np.ndarray of int
    Indices to be taken.
axis : int, default 0
    The axis over which to select values.
allow_fill : bool, default False
    How to handle negative values in `indices`.

    * False: negative values in `indices` indicate positional indices
      from the right (the default). This is similar to :func:`numpy.take`.

    * True: negative values in `indices` indicate
      missing values. These values are set to `fill_value`. Any other
      negative values raise a ``ValueError``.

fill_value : any, optional
    Fill value to use for NA-indices when `allow_fill` is True.
    This may be ``None``, in which case the default NA value for
    the type (``self.dtype.na_value``) is used.

    For multi-dimensional `arr`, each *element* is filled with
    `fill_value`.

Returns
-------
ndarray or ExtensionArray
    Same type as the input.

Raises
------
IndexError
    When `indices` is out of bounds for the array.
ValueError
    When the indexer contains negative values other than ``-1``
    and `allow_fill` is True.

Notes
-----
When `allow_fill` is False, `indices` may be whatever dimensionality
is accepted by NumPy for `arr`.

When `allow_fill` is True, `indices` should be 1-D.

See Also
--------
numpy.take : Take elements from an array along an axis.

Examples
--------
&gt;&gt;&gt; import pandas as pd

With the default ``allow_fill=False``, negative numbers indicate
positional indices from the right.

&gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1])
array([10, 10, 30])

Setting ``allow_fill=True`` will place `fill_value` in those positions.

&gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True)
array([10., 10., nan])

&gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True,
...      fill_value=-10)
array([ 10,  10, -10])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1486</span>):</div>
<div class="line"><span class="lineno"> 1487</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">    Take elements from an array.</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">    arr : array-like or scalar value</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">        Non array-likes (sequences/scalars without a dtype) are coerced</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">        to an ndarray.</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">    indices : sequence of int or one-dimensional np.ndarray of int</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">        Indices to be taken.</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    axis : int, default 0</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">        The axis over which to select values.</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    allow_fill : bool, default False</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">        How to handle negative values in `indices`.</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">        * False: negative values in `indices` indicate positional indices</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">          from the right (the default). This is similar to :func:`numpy.take`.</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">        * True: negative values in `indices` indicate</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">          missing values. These values are set to `fill_value`. Any other</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">          negative values raise a ``ValueError``.</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    fill_value : any, optional</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        Fill value to use for NA-indices when `allow_fill` is True.</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">        This may be ``None``, in which case the default NA value for</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        the type (``self.dtype.na_value``) is used.</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">        For multi-dimensional `arr`, each *element* is filled with</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">        `fill_value`.</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">    ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">        Same type as the input.</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">    IndexError</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">        When `indices` is out of bounds for the array.</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">        When the indexer contains negative values other than ``-1``</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">        and `allow_fill` is True.</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    When `allow_fill` is False, `indices` may be whatever dimensionality</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    is accepted by NumPy for `arr`.</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">    When `allow_fill` is True, `indices` should be 1-D.</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">    numpy.take : Take elements from an array along an axis.</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    &gt;&gt;&gt; import pandas as pd</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    With the default ``allow_fill=False``, negative numbers indicate</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">    positional indices from the right.</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    &gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1])</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    array([10, 10, 30])</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    Setting ``allow_fill=True`` will place `fill_value` in those positions.</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    &gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True)</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    array([10., 10., nan])</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    &gt;&gt;&gt; pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True,</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    ...      fill_value=-10)</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    array([ 10,  10, -10])</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1560</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_array_like(arr):</div>
<div class="line"><span class="lineno"> 1561</span>        arr = np.asarray(arr)</div>
<div class="line"><span class="lineno"> 1562</span> </div>
<div class="line"><span class="lineno"> 1563</span>    indices = np.asarray(indices, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 1564</span> </div>
<div class="line"><span class="lineno"> 1565</span>    <span class="keywordflow">if</span> allow_fill:</div>
<div class="line"><span class="lineno"> 1566</span>        <span class="comment"># Pandas style, -1 means NA</span></div>
<div class="line"><span class="lineno"> 1567</span>        validate_indices(indices, arr.shape[axis])</div>
<div class="line"><span class="lineno"> 1568</span>        result = take_nd(</div>
<div class="line"><span class="lineno"> 1569</span>            arr, indices, axis=axis, allow_fill=<span class="keyword">True</span>, fill_value=fill_value</div>
<div class="line"><span class="lineno"> 1570</span>        )</div>
<div class="line"><span class="lineno"> 1571</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1572</span>        <span class="comment"># NumPy style</span></div>
<div class="line"><span class="lineno"> 1573</span>        result = arr.take(indices, axis=axis)</div>
<div class="line"><span class="lineno"> 1574</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1575</span> </div>
<div class="line"><span class="lineno"> 1576</span> </div>
<div class="line"><span class="lineno"> 1577</span><span class="comment"># ------------ #</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="comment"># searchsorted #</span></div>
<div class="line"><span class="lineno"> 1579</span><span class="comment"># ------------ #</span></div>
<div class="line"><span class="lineno"> 1580</span> </div>
<div class="line"><span class="lineno"> 1581</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e2f173fc73e7b7030dec21d132c5803" name="a8e2f173fc73e7b7030dec21d132c5803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2f173fc73e7b7030dec21d132c5803">&#9670;&#160;</a></span>union_with_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.algorithms.union_with_duplicates </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>lvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>rvals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extracts the union from lvals and rvals with respect to duplicates and nans in
both arrays.

Parameters
----------
lvals: np.ndarray or ExtensionArray
    left values which is ordered in front.
rvals: np.ndarray or ExtensionArray
    right values ordered after lvals.

Returns
-------
np.ndarray or ExtensionArray
    Containing the unsorted union of both arrays.

Notes
-----
Caller is responsible for ensuring lvals.dtype == rvals.dtype.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1968</span><span class="keyword">def </span>union_with_duplicates(lvals: ArrayLike, rvals: ArrayLike) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1969</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    Extracts the union from lvals and rvals with respect to duplicates and nans in</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">    both arrays.</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">    lvals: np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">        left values which is ordered in front.</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">    rvals: np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">        right values ordered after lvals.</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral">    np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">        Containing the unsorted union of both arrays.</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral">    Caller is responsible for ensuring lvals.dtype == rvals.dtype.</span></div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1989</span>    indexer = []</div>
<div class="line"><span class="lineno"> 1990</span>    l_count = value_counts(lvals, dropna=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1991</span>    r_count = value_counts(rvals, dropna=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1992</span>    l_count, r_count = l_count.align(r_count, fill_value=0)</div>
<div class="line"><span class="lineno"> 1993</span>    unique_array = unique(concat_compat([lvals, rvals]))</div>
<div class="line"><span class="lineno"> 1994</span>    unique_array = ensure_wrapped_if_datetimelike(unique_array)</div>
<div class="line"><span class="lineno"> 1995</span> </div>
<div class="line"><span class="lineno"> 1996</span>    <span class="keywordflow">for</span> i, value <span class="keywordflow">in</span> enumerate(unique_array):</div>
<div class="line"><span class="lineno"> 1997</span>        indexer += [i] * int(max(l_count.at[value], r_count.at[value]))</div>
<div class="line"><span class="lineno"> 1998</span>    <span class="keywordflow">return</span> unique_array.take(indexer)</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf2a16f208025c0e7ed8cba4fdf45489" name="aaf2a16f208025c0e7ed8cba4fdf45489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2a16f208025c0e7ed8cba4fdf45489">&#9670;&#160;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.algorithms.unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return unique values based on a hash table.

Uniques are returned in order of appearance. This does NOT sort.

Significantly faster than numpy.unique for long enough sequences.
Includes NA values.

Parameters
----------
values : 1d array-like

Returns
-------
numpy.ndarray or ExtensionArray

    The return can be:

    * Index : when the input is an Index
    * Categorical : when the input is a Categorical dtype
    * ndarray : when the input is a Series/ndarray

    Return numpy.ndarray or ExtensionArray.

See Also
--------
Index.unique : Return unique values from an Index.
Series.unique : Return unique values of Series object.

Examples
--------
&gt;&gt;&gt; pd.unique(pd.Series([2, 1, 3, 3]))
array([2, 1, 3])

&gt;&gt;&gt; pd.unique(pd.Series([2] + [1] * 5))
array([2, 1])

&gt;&gt;&gt; pd.unique(pd.Series([pd.Timestamp("20160101"), pd.Timestamp("20160101")]))
array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')

&gt;&gt;&gt; pd.unique(
...     pd.Series(
...         [
...             pd.Timestamp("20160101", tz="US/Eastern"),
...             pd.Timestamp("20160101", tz="US/Eastern"),
...         ]
...     )
... )
&lt;DatetimeArray&gt;
['2016-01-01 00:00:00-05:00']
Length: 1, dtype: datetime64[ns, US/Eastern]

&gt;&gt;&gt; pd.unique(
...     pd.Index(
...         [
...             pd.Timestamp("20160101", tz="US/Eastern"),
...             pd.Timestamp("20160101", tz="US/Eastern"),
...         ]
...     )
... )
DatetimeIndex(['2016-01-01 00:00:00-05:00'],
        dtype='datetime64[ns, US/Eastern]',
        freq=None)

&gt;&gt;&gt; pd.unique(list("baabc"))
array(['b', 'a', 'c'], dtype=object)

An unordered Categorical will return categories in the
order of appearance.

&gt;&gt;&gt; pd.unique(pd.Series(pd.Categorical(list("baabc"))))
['b', 'a', 'c']
Categories (3, object): ['a', 'b', 'c']

&gt;&gt;&gt; pd.unique(pd.Series(pd.Categorical(list("baabc"), categories=list("abc"))))
['b', 'a', 'c']
Categories (3, object): ['a', 'b', 'c']

An ordered Categorical preserves the category ordering.

&gt;&gt;&gt; pd.unique(
...     pd.Series(
...         pd.Categorical(list("baabc"), categories=list("abc"), ordered=True)
...     )
... )
['b', 'a', 'c']
Categories (3, object): ['a' &lt; 'b' &lt; 'c']

An array of tuples

&gt;&gt;&gt; pd.unique([("a", "b"), ("b", "a"), ("a", "c"), ("b", "a")])
array([('a', 'b'), ('b', 'a'), ('a', 'c')], dtype=object)
</pre> <div class="fragment"><div class="line"><span class="lineno">  315</span><span class="keyword">def </span>unique(values):</div>
<div class="line"><span class="lineno">  316</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    Return unique values based on a hash table.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    Uniques are returned in order of appearance. This does NOT sort.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    Significantly faster than numpy.unique for long enough sequences.</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    Includes NA values.</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    values : 1d array-like</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    numpy.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        The return can be:</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        * Index : when the input is an Index</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">        * Categorical : when the input is a Categorical dtype</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        * ndarray : when the input is a Series/ndarray</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        Return numpy.ndarray or ExtensionArray.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    Index.unique : Return unique values from an Index.</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    Series.unique : Return unique values of Series object.</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(pd.Series([2, 1, 3, 3]))</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    array([2, 1, 3])</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(pd.Series([2] + [1] * 5))</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    array([2, 1])</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(pd.Series([pd.Timestamp(&quot;20160101&quot;), pd.Timestamp(&quot;20160101&quot;)]))</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    array([&#39;2016-01-01T00:00:00.000000000&#39;], dtype=&#39;datetime64[ns]&#39;)</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    ...     pd.Series(</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    ...         [</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    ...         ]</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    ...     )</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    &lt;DatetimeArray&gt;</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    [&#39;2016-01-01 00:00:00-05:00&#39;]</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    Length: 1, dtype: datetime64[ns, US/Eastern]</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    ...     pd.Index(</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    ...         [</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    ...             pd.Timestamp(&quot;20160101&quot;, tz=&quot;US/Eastern&quot;),</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    ...         ]</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    ...     )</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    DatetimeIndex([&#39;2016-01-01 00:00:00-05:00&#39;],</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">            dtype=&#39;datetime64[ns, US/Eastern]&#39;,</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">            freq=None)</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(list(&quot;baabc&quot;))</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    array([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], dtype=object)</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    An unordered Categorical will return categories in the</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    order of appearance.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(pd.Series(pd.Categorical(list(&quot;baabc&quot;))))</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(pd.Series(pd.Categorical(list(&quot;baabc&quot;), categories=list(&quot;abc&quot;))))</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    An ordered Categorical preserves the category ordering.</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique(</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    ...     pd.Series(</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    ...         pd.Categorical(list(&quot;baabc&quot;), categories=list(&quot;abc&quot;), ordered=True)</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    ...     )</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    Categories (3, object): [&#39;a&#39; &lt; &#39;b&#39; &lt; &#39;c&#39;]</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    An array of tuples</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    &gt;&gt;&gt; pd.unique([(&quot;a&quot;, &quot;b&quot;), (&quot;b&quot;, &quot;a&quot;), (&quot;a&quot;, &quot;c&quot;), (&quot;b&quot;, &quot;a&quot;)])</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    array([(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;a&#39;), (&#39;a&#39;, &#39;c&#39;)], dtype=object)</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">return</span> unique_with_mask(values)</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b109d6754b5a73d5d0f048daa50c652" name="a9b109d6754b5a73d5d0f048daa50c652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b109d6754b5a73d5d0f048daa50c652">&#9670;&#160;</a></span>unique_with_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.algorithms.unique_with_mask </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">See algorithms.unique for docs. Takes a mask for masked arrays.</pre> <div class="fragment"><div class="line"><span class="lineno">  412</span><span class="keyword">def </span>unique_with_mask(values, mask: npt.NDArray[np.bool_] | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  413</span>    <span class="stringliteral">&quot;&quot;&quot;See algorithms.unique for docs. Takes a mask for masked arrays.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  414</span>    values = _ensure_arraylike(values)</div>
<div class="line"><span class="lineno">  415</span> </div>
<div class="line"><span class="lineno">  416</span>    <span class="keywordflow">if</span> is_extension_array_dtype(values.dtype):</div>
<div class="line"><span class="lineno">  417</span>        <span class="comment"># Dispatch to extension dtype&#39;s unique.</span></div>
<div class="line"><span class="lineno">  418</span>        <span class="keywordflow">return</span> values.unique()</div>
<div class="line"><span class="lineno">  419</span> </div>
<div class="line"><span class="lineno">  420</span>    original = values</div>
<div class="line"><span class="lineno">  421</span>    htable, values = _get_hashtable_algo(values)</div>
<div class="line"><span class="lineno">  422</span> </div>
<div class="line"><span class="lineno">  423</span>    table = htable(len(values))</div>
<div class="line"><span class="lineno">  424</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  425</span>        uniques = table.unique(values)</div>
<div class="line"><span class="lineno">  426</span>        uniques = _reconstruct_data(uniques, original.dtype, original)</div>
<div class="line"><span class="lineno">  427</span>        <span class="keywordflow">return</span> uniques</div>
<div class="line"><span class="lineno">  428</span> </div>
<div class="line"><span class="lineno">  429</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  430</span>        uniques, mask = table.unique(values, mask=mask)</div>
<div class="line"><span class="lineno">  431</span>        uniques = _reconstruct_data(uniques, original.dtype, original)</div>
<div class="line"><span class="lineno">  432</span>        <span class="keyword">assert</span> mask <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>  <span class="comment"># for mypy</span></div>
<div class="line"><span class="lineno">  433</span>        <span class="keywordflow">return</span> uniques, mask.astype(<span class="stringliteral">&quot;bool&quot;</span>)</div>
<div class="line"><span class="lineno">  434</span> </div>
<div class="line"><span class="lineno">  435</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4e9a411ce11004fdee2f052eb473b21" name="ac4e9a411ce11004fdee2f052eb473b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e9a411ce11004fdee2f052eb473b21">&#9670;&#160;</a></span>value_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Series pandas.core.algorithms.value_counts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>normalize</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dropna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a histogram of the counts of non-null values.

Parameters
----------
values : ndarray (1-d)
sort : bool, default True
    Sort by values
ascending : bool, default False
    Sort in ascending order
normalize: bool, default False
    If True then compute a relative histogram
bins : integer, optional
    Rather than count values, group them into half-open bins,
    convenience for pd.cut, only works with numeric data
dropna : bool, default True
    Don't include counts of NaN

Returns
-------
Series
</pre> <div class="fragment"><div class="line"><span class="lineno">  923</span>) -&gt; Series:</div>
<div class="line"><span class="lineno">  924</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    Compute a histogram of the counts of non-null values.</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    values : ndarray (1-d)</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    sort : bool, default True</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">        Sort by values</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    ascending : bool, default False</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">        Sort in ascending order</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    normalize: bool, default False</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">        If True then compute a relative histogram</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    bins : integer, optional</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">        Rather than count values, group them into half-open bins,</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">        convenience for pd.cut, only works with numeric data</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    dropna : bool, default True</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">        Don&#39;t include counts of NaN</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">    Series</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  946</span>    <span class="keyword">from</span> pandas <span class="keyword">import</span> (</div>
<div class="line"><span class="lineno">  947</span>        Index,</div>
<div class="line"><span class="lineno">  948</span>        Series,</div>
<div class="line"><span class="lineno">  949</span>    )</div>
<div class="line"><span class="lineno">  950</span> </div>
<div class="line"><span class="lineno">  951</span>    name = getattr(values, <span class="stringliteral">&quot;name&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  952</span> </div>
<div class="line"><span class="lineno">  953</span>    <span class="keywordflow">if</span> bins <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  954</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1reshape_1_1tile.html">pandas.core.reshape.tile</a> <span class="keyword">import</span> cut</div>
<div class="line"><span class="lineno">  955</span> </div>
<div class="line"><span class="lineno">  956</span>        values = Series(values)</div>
<div class="line"><span class="lineno">  957</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  958</span>            ii = cut(values, bins, include_lowest=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  959</span>        <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  960</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;bins argument only works with numeric data.&quot;</span>) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  961</span> </div>
<div class="line"><span class="lineno">  962</span>        <span class="comment"># count, remove nulls (from the index), and but the bins</span></div>
<div class="line"><span class="lineno">  963</span>        result = ii.value_counts(dropna=dropna)</div>
<div class="line"><span class="lineno">  964</span>        result = result[result.index.notna()]</div>
<div class="line"><span class="lineno">  965</span>        result.index = result.index.astype(<span class="stringliteral">&quot;interval&quot;</span>)</div>
<div class="line"><span class="lineno">  966</span>        result = result.sort_index()</div>
<div class="line"><span class="lineno">  967</span> </div>
<div class="line"><span class="lineno">  968</span>        <span class="comment"># if we are dropna and we have NO values</span></div>
<div class="line"><span class="lineno">  969</span>        <span class="keywordflow">if</span> dropna <span class="keywordflow">and</span> (result._values == 0).all():</div>
<div class="line"><span class="lineno">  970</span>            result = result.iloc[0:0]</div>
<div class="line"><span class="lineno">  971</span> </div>
<div class="line"><span class="lineno">  972</span>        <span class="comment"># normalizing is by len of all (regardless of dropna)</span></div>
<div class="line"><span class="lineno">  973</span>        counts = np.array([len(ii)])</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  976</span> </div>
<div class="line"><span class="lineno">  977</span>        <span class="keywordflow">if</span> is_extension_array_dtype(values):</div>
<div class="line"><span class="lineno">  978</span> </div>
<div class="line"><span class="lineno">  979</span>            <span class="comment"># handle Categorical and sparse,</span></div>
<div class="line"><span class="lineno">  980</span>            result = Series(values)._values.value_counts(dropna=dropna)</div>
<div class="line"><span class="lineno">  981</span>            result.name = name</div>
<div class="line"><span class="lineno">  982</span>            counts = result._values</div>
<div class="line"><span class="lineno">  983</span> </div>
<div class="line"><span class="lineno">  984</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  985</span>            values = _ensure_arraylike(values)</div>
<div class="line"><span class="lineno">  986</span>            keys, counts = value_counts_arraylike(values, dropna)</div>
<div class="line"><span class="lineno">  987</span> </div>
<div class="line"><span class="lineno">  988</span>            <span class="comment"># For backwards compatibility, we let Index do its normal type</span></div>
<div class="line"><span class="lineno">  989</span>            <span class="comment">#  inference, _except_ for if if infers from object to bool.</span></div>
<div class="line"><span class="lineno">  990</span>            idx = Index._with_infer(keys)</div>
<div class="line"><span class="lineno">  991</span>            <span class="keywordflow">if</span> idx.dtype == bool <span class="keywordflow">and</span> keys.dtype == object:</div>
<div class="line"><span class="lineno">  992</span>                idx = idx.astype(object)</div>
<div class="line"><span class="lineno">  993</span> </div>
<div class="line"><span class="lineno">  994</span>            result = Series(counts, index=idx, name=name)</div>
<div class="line"><span class="lineno">  995</span> </div>
<div class="line"><span class="lineno">  996</span>    <span class="keywordflow">if</span> sort:</div>
<div class="line"><span class="lineno">  997</span>        result = result.sort_values(ascending=ascending)</div>
<div class="line"><span class="lineno">  998</span> </div>
<div class="line"><span class="lineno">  999</span>    <span class="keywordflow">if</span> normalize:</div>
<div class="line"><span class="lineno"> 1000</span>        result = result / counts.sum()</div>
<div class="line"><span class="lineno"> 1001</span> </div>
<div class="line"><span class="lineno"> 1002</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1003</span> </div>
<div class="line"><span class="lineno"> 1004</span> </div>
<div class="line"><span class="lineno"> 1005</span><span class="comment"># Called once from SparseArray, otherwise could be private</span></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1reshape_1_1tile_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1reshape_1_1tile.html">pandas.core.reshape.tile</a></div><div class="ttdef"><b>Definition</b> tile.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6280dfd2f7602419089531b89725716" name="ae6280dfd2f7602419089531b89725716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6280dfd2f7602419089531b89725716">&#9670;&#160;</a></span>value_counts_arraylike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[ArrayLike, npt.NDArray[np.int64]] pandas.core.algorithms.value_counts_arraylike </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dropna</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
values : np.ndarray
dropna : bool
mask : np.ndarray[bool] or None, default None

Returns
-------
uniques : np.ndarray
counts : np.ndarray[np.int64]
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1008</span>) -&gt; tuple[ArrayLike, npt.NDArray[np.int64]]:</div>
<div class="line"><span class="lineno"> 1009</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    values : np.ndarray</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    dropna : bool</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    mask : np.ndarray[bool] or None, default None</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    uniques : np.ndarray</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    counts : np.ndarray[np.int64]</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1021</span>    original = values</div>
<div class="line"><span class="lineno"> 1022</span>    values = _ensure_data(values)</div>
<div class="line"><span class="lineno"> 1023</span> </div>
<div class="line"><span class="lineno"> 1024</span>    keys, counts = htable.value_count(values, dropna, mask=mask)</div>
<div class="line"><span class="lineno"> 1025</span> </div>
<div class="line"><span class="lineno"> 1026</span>    <span class="keywordflow">if</span> needs_i8_conversion(original.dtype):</div>
<div class="line"><span class="lineno"> 1027</span>        <span class="comment"># datetime, timedelta, or period</span></div>
<div class="line"><span class="lineno"> 1028</span> </div>
<div class="line"><span class="lineno"> 1029</span>        <span class="keywordflow">if</span> dropna:</div>
<div class="line"><span class="lineno"> 1030</span>            mask = keys != iNaT</div>
<div class="line"><span class="lineno"> 1031</span>            keys, counts = keys[mask], counts[mask]</div>
<div class="line"><span class="lineno"> 1032</span> </div>
<div class="line"><span class="lineno"> 1033</span>    res_keys = _reconstruct_data(keys, original.dtype, original)</div>
<div class="line"><span class="lineno"> 1034</span>    <span class="keywordflow">return</span> res_keys, counts</div>
<div class="line"><span class="lineno"> 1035</span> </div>
<div class="line"><span class="lineno"> 1036</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abdeb5f0661eb264df858024a3e0de961" name="abdeb5f0661eb264df858024a3e0de961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdeb5f0661eb264df858024a3e0de961">&#9670;&#160;</a></span>_diff_special</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.algorithms._diff_special = {&quot;float64&quot;, &quot;float32&quot;, &quot;int64&quot;, &quot;int32&quot;, &quot;int16&quot;, &quot;int8&quot;}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3dfca7af569cdf3704041ed4741359b" name="ae3dfca7af569cdf3704041ed4741359b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dfca7af569cdf3704041ed4741359b">&#9670;&#160;</a></span>_hashtables</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.algorithms._hashtables</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;complex128&quot;</span>: htable.Complex128HashTable,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;complex64&quot;</span>: htable.Complex64HashTable,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;float64&quot;</span>: htable.Float64HashTable,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;float32&quot;</span>: htable.Float32HashTable,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;uint64&quot;</span>: htable.UInt64HashTable,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;uint32&quot;</span>: htable.UInt32HashTable,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;uint16&quot;</span>: htable.UInt16HashTable,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;uint8&quot;</span>: htable.UInt8HashTable,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;int64&quot;</span>: htable.Int64HashTable,</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&quot;int32&quot;</span>: htable.Int32HashTable,</div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">&quot;int16&quot;</span>: htable.Int16HashTable,</div>
<div class="line"><span class="lineno">   13</span>    <span class="stringliteral">&quot;int8&quot;</span>: htable.Int8HashTable,</div>
<div class="line"><span class="lineno">   14</span>    <span class="stringliteral">&quot;string&quot;</span>: htable.StringHashTable,</div>
<div class="line"><span class="lineno">   15</span>    <span class="stringliteral">&quot;object&quot;</span>: htable.PyObjectHashTable,</div>
<div class="line"><span class="lineno">   16</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2391ef584cb31e63dcc63f95b35de489" name="a2391ef584cb31e63dcc63f95b35de489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2391ef584cb31e63dcc63f95b35de489">&#9670;&#160;</a></span>unique1d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.algorithms.unique1d = <a class="el" href="namespacepandas_1_1core_1_1algorithms.html#aaf2a16f208025c0e7ed8cba4fdf45489">unique</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
