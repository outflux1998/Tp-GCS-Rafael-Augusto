<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.arrays.sparse.scipy_sparse Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1arrays.html">arrays</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1arrays_1_1sparse.html">sparse</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1arrays_1_1sparse_1_1scipy__sparse.html">scipy_sparse</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.arrays.sparse.scipy_sparse Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad8296d354292f2c9d3d505c17774c4c9" id="r_ad8296d354292f2c9d3d505c17774c4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1arrays_1_1sparse_1_1scipy__sparse.html#ad8296d354292f2c9d3d505c17774c4c9">_check_is_partition</a> (Iterable parts, Iterable whole)</td></tr>
<tr class="separator:ad8296d354292f2c9d3d505c17774c4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91434410d77f56d19bb5b4d390251522" id="r_a91434410d77f56d19bb5b4d390251522"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], list[IndexLabel]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1arrays_1_1sparse_1_1scipy__sparse.html#a91434410d77f56d19bb5b4d390251522">_levels_to_axis</a> (<a class="el" href="return__character_2foo77_8f.html#a67572f61f6cfe1702b5aba8e77d63eb3">ss</a>, tuple[int]|list[int] levels, npt.NDArray[np.intp] valid_ilocs, bool sort_labels=False)</td></tr>
<tr class="separator:a91434410d77f56d19bb5b4d390251522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a5182fbcd52ad1a78efa2f47d81920" id="r_a18a5182fbcd52ad1a78efa2f47d81920"><td class="memItemLeft" align="right" valign="top">tuple[ np.ndarray, npt.NDArray[np.intp], npt.NDArray[np.intp], list[IndexLabel], list[IndexLabel],]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1arrays_1_1sparse_1_1scipy__sparse.html#a18a5182fbcd52ad1a78efa2f47d81920">_to_ijv</a> (<a class="el" href="return__character_2foo77_8f.html#a67572f61f6cfe1702b5aba8e77d63eb3">ss</a>, tuple[int]|list[int] row_levels=(0,), tuple[int]|list[int] column_levels=(1,), bool sort_labels=False)</td></tr>
<tr class="separator:a18a5182fbcd52ad1a78efa2f47d81920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9158723dc669b4918c1d65cd5170ab19" id="r_a9158723dc669b4918c1d65cd5170ab19"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classscipy_1_1sparse_1_1__coo_1_1coo__matrix.html">scipy.sparse.coo_matrix</a>, list[IndexLabel], list[IndexLabel]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1arrays_1_1sparse_1_1scipy__sparse.html#a9158723dc669b4918c1d65cd5170ab19">sparse_series_to_coo</a> (<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> <a class="el" href="return__character_2foo77_8f.html#a67572f61f6cfe1702b5aba8e77d63eb3">ss</a>, Iterable[int] row_levels=(0,), Iterable[int] column_levels=(1,), bool sort_labels=False)</td></tr>
<tr class="separator:a9158723dc669b4918c1d65cd5170ab19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d643b105ca287829ae75830cb01550" id="r_ac5d643b105ca287829ae75830cb01550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1arrays_1_1sparse_1_1scipy__sparse.html#ac5d643b105ca287829ae75830cb01550">coo_to_sparse_series</a> (<a class="el" href="classscipy_1_1sparse_1_1__coo_1_1coo__matrix.html">scipy.sparse.coo_matrix</a> A, bool dense_index=False)</td></tr>
<tr class="separator:ac5d643b105ca287829ae75830cb01550"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Interaction with scipy.sparse matrices.

Currently only includes to_coo helpers.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ad8296d354292f2c9d3d505c17774c4c9" name="ad8296d354292f2c9d3d505c17774c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8296d354292f2c9d3d505c17774c4c9">&#9670;&#160;</a></span>_check_is_partition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.arrays.sparse.scipy_sparse._check_is_partition </td>
          <td>(</td>
          <td class="paramtype">Iterable&#160;</td>
          <td class="paramname"><em>parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable&#160;</td>
          <td class="paramname"><em>whole</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   31</span><span class="keyword">def </span>_check_is_partition(parts: Iterable, whole: Iterable):</div>
<div class="line"><span class="lineno">   32</span>    whole = set(whole)</div>
<div class="line"><span class="lineno">   33</span>    parts = [set(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> parts]</div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">if</span> set.intersection(*parts) != set():</div>
<div class="line"><span class="lineno">   35</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Is not a partition because intersection is not null.&quot;</span>)</div>
<div class="line"><span class="lineno">   36</span>    <span class="keywordflow">if</span> set.union(*parts) != whole:</div>
<div class="line"><span class="lineno">   37</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Is not a partition because union is not the whole.&quot;</span>)</div>
<div class="line"><span class="lineno">   38</span> </div>
<div class="line"><span class="lineno">   39</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a91434410d77f56d19bb5b4d390251522" name="a91434410d77f56d19bb5b4d390251522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91434410d77f56d19bb5b4d390251522">&#9670;&#160;</a></span>_levels_to_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], list[IndexLabel]] pandas.core.arrays.sparse.scipy_sparse._levels_to_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[int] | list[int]&#160;</td>
          <td class="paramname"><em>levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>valid_ilocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort_labels</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">For a MultiIndexed sparse Series `ss`, return `ax_coords` and `ax_labels`,
where `ax_coords` are the coordinates along one of the two axes of the
destination sparse matrix, and `ax_labels` are the labels from `ss`' Index
which correspond to these coordinates.

Parameters
----------
ss : Series
levels : tuple/list
valid_ilocs : numpy.ndarray
    Array of integer positions of valid values for the sparse matrix in ss.
sort_labels : bool, default False
    Sort the axis labels before forming the sparse matrix. When `levels`
    refers to a single level, set to True for a faster execution.

Returns
-------
ax_coords : numpy.ndarray (axis coordinates)
ax_labels : list (axis labels)
</pre> <div class="fragment"><div class="line"><span class="lineno">   45</span>) -&gt; tuple[npt.NDArray[np.intp], list[IndexLabel]]:</div>
<div class="line"><span class="lineno">   46</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    For a MultiIndexed sparse Series `ss`, return `ax_coords` and `ax_labels`,</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    where `ax_coords` are the coordinates along one of the two axes of the</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    destination sparse matrix, and `ax_labels` are the labels from `ss`&#39; Index</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    which correspond to these coordinates.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    ss : Series</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    levels : tuple/list</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    valid_ilocs : numpy.ndarray</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">        Array of integer positions of valid values for the sparse matrix in ss.</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    sort_labels : bool, default False</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        Sort the axis labels before forming the sparse matrix. When `levels`</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        refers to a single level, set to True for a faster execution.</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    ax_coords : numpy.ndarray (axis coordinates)</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    ax_labels : list (axis labels)</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   67</span>    <span class="comment"># Since the labels are sorted in `Index.levels`, when we wish to sort and</span></div>
<div class="line"><span class="lineno">   68</span>    <span class="comment"># there is only one level of the MultiIndex for this axis, the desired</span></div>
<div class="line"><span class="lineno">   69</span>    <span class="comment"># output can be obtained in the following simpler, more efficient way.</span></div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">if</span> sort_labels <span class="keywordflow">and</span> len(levels) == 1:</div>
<div class="line"><span class="lineno">   71</span>        ax_coords = ss.index.codes[levels[0]][valid_ilocs]</div>
<div class="line"><span class="lineno">   72</span>        ax_labels = ss.index.levels[levels[0]]</div>
<div class="line"><span class="lineno">   73</span> </div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   75</span>        levels_values = lib.fast_zip(</div>
<div class="line"><span class="lineno">   76</span>            [ss.index.get_level_values(lvl).values <span class="keywordflow">for</span> lvl <span class="keywordflow">in</span> levels]</div>
<div class="line"><span class="lineno">   77</span>        )</div>
<div class="line"><span class="lineno">   78</span>        codes, ax_labels = factorize(levels_values, sort=sort_labels)</div>
<div class="line"><span class="lineno">   79</span>        ax_coords = codes[valid_ilocs]</div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>    ax_labels = ax_labels.tolist()</div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">return</span> ax_coords, ax_labels</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a18a5182fbcd52ad1a78efa2f47d81920" name="a18a5182fbcd52ad1a78efa2f47d81920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a5182fbcd52ad1a78efa2f47d81920">&#9670;&#160;</a></span>_to_ijv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[
    np.ndarray,
    npt.NDArray[np.intp],
    npt.NDArray[np.intp],
    list[IndexLabel],
    list[IndexLabel],
] pandas.core.arrays.sparse.scipy_sparse._to_ijv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[int] | list[int] &#160;</td>
          <td class="paramname"><em>row_levels</em> = <code>(0,)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[int] | list[int] &#160;</td>
          <td class="paramname"><em>column_levels</em> = <code>(1,)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort_labels</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">For an arbitrary MultiIndexed sparse Series return (v, i, j, ilabels,
jlabels) where (v, (i, j)) is suitable for passing to scipy.sparse.coo
constructor, and ilabels and jlabels are the row and column labels
respectively.

Parameters
----------
ss : Series
row_levels : tuple/list
column_levels : tuple/list
sort_labels : bool, default False
    Sort the row and column labels before forming the sparse matrix.
    When `row_levels` and/or `column_levels` refer to a single level,
    set to `True` for a faster execution.

Returns
-------
values : numpy.ndarray
    Valid values to populate a sparse matrix, extracted from
    ss.
i_coords : numpy.ndarray (row coordinates of the values)
j_coords : numpy.ndarray (column coordinates of the values)
i_labels : list (row labels)
j_labels : list (column labels)
</pre> <div class="fragment"><div class="line"><span class="lineno">   96</span>]:</div>
<div class="line"><span class="lineno">   97</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    For an arbitrary MultiIndexed sparse Series return (v, i, j, ilabels,</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    jlabels) where (v, (i, j)) is suitable for passing to scipy.sparse.coo</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    constructor, and ilabels and jlabels are the row and column labels</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    respectively.</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    ss : Series</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    row_levels : tuple/list</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    column_levels : tuple/list</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    sort_labels : bool, default False</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        Sort the row and column labels before forming the sparse matrix.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        When `row_levels` and/or `column_levels` refer to a single level,</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        set to `True` for a faster execution.</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    values : numpy.ndarray</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">        Valid values to populate a sparse matrix, extracted from</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">        ss.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    i_coords : numpy.ndarray (row coordinates of the values)</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    j_coords : numpy.ndarray (column coordinates of the values)</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    i_labels : list (row labels)</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    j_labels : list (column labels)</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  123</span>    <span class="comment"># index and column levels must be a partition of the index</span></div>
<div class="line"><span class="lineno">  124</span>    _check_is_partition([row_levels, column_levels], range(ss.index.nlevels))</div>
<div class="line"><span class="lineno">  125</span>    <span class="comment"># From the sparse Series, get the integer indices and data for valid sparse</span></div>
<div class="line"><span class="lineno">  126</span>    <span class="comment"># entries.</span></div>
<div class="line"><span class="lineno">  127</span>    sp_vals = ss.array.sp_values</div>
<div class="line"><span class="lineno">  128</span>    na_mask = notna(sp_vals)</div>
<div class="line"><span class="lineno">  129</span>    values = sp_vals[na_mask]</div>
<div class="line"><span class="lineno">  130</span>    valid_ilocs = ss.array.sp_index.indices[na_mask]</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>    i_coords, i_labels = _levels_to_axis(</div>
<div class="line"><span class="lineno">  133</span>        ss, row_levels, valid_ilocs, sort_labels=sort_labels</div>
<div class="line"><span class="lineno">  134</span>    )</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span>    j_coords, j_labels = _levels_to_axis(</div>
<div class="line"><span class="lineno">  137</span>        ss, column_levels, valid_ilocs, sort_labels=sort_labels</div>
<div class="line"><span class="lineno">  138</span>    )</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">return</span> values, i_coords, j_coords, i_labels, j_labels</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac5d643b105ca287829ae75830cb01550" name="ac5d643b105ca287829ae75830cb01550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d643b105ca287829ae75830cb01550">&#9670;&#160;</a></span>coo_to_sparse_series()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> pandas.core.arrays.sparse.scipy_sparse.coo_to_sparse_series </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscipy_1_1sparse_1_1__coo_1_1coo__matrix.html">scipy.sparse.coo_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dense_index</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a scipy.sparse.coo_matrix to a SparseSeries.

Parameters
----------
A : scipy.sparse.coo_matrix
dense_index : bool, default False

Returns
-------
Series

Raises
------
TypeError if A is not a coo_matrix
</pre> <div class="fragment"><div class="line"><span class="lineno">  178</span>) -&gt; Series:</div>
<div class="line"><span class="lineno">  179</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    Convert a scipy.sparse.coo_matrix to a SparseSeries.</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    A : scipy.sparse.coo_matrix</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    dense_index : bool, default False</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    Series</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    TypeError if A is not a coo_matrix</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  195</span>    <span class="keyword">from</span> pandas <span class="keyword">import</span> SparseDtype</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  198</span>        ser = Series(A.data, MultiIndex.from_arrays((A.row, A.col)))</div>
<div class="line"><span class="lineno">  199</span>    <span class="keywordflow">except</span> AttributeError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  200</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  201</span>            f<span class="stringliteral">&quot;Expected coo_matrix. Got {type(A).__name__} instead.&quot;</span></div>
<div class="line"><span class="lineno">  202</span>        ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  203</span>    ser = ser.sort_index()</div>
<div class="line"><span class="lineno">  204</span>    ser = ser.astype(SparseDtype(ser.dtype))</div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">if</span> dense_index:</div>
<div class="line"><span class="lineno">  206</span>        <span class="comment"># is there a better constructor method to use here?</span></div>
<div class="line"><span class="lineno">  207</span>        i = range(A.shape[0])</div>
<div class="line"><span class="lineno">  208</span>        j = range(A.shape[1])</div>
<div class="line"><span class="lineno">  209</span>        ind = MultiIndex.from_product([i, j])</div>
<div class="line"><span class="lineno">  210</span>        ser = ser.reindex(ind)</div>
<div class="line"><span class="lineno">  211</span>    <span class="keywordflow">return</span> ser</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9158723dc669b4918c1d65cd5170ab19" name="a9158723dc669b4918c1d65cd5170ab19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9158723dc669b4918c1d65cd5170ab19">&#9670;&#160;</a></span>sparse_series_to_coo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classscipy_1_1sparse_1_1__coo_1_1coo__matrix.html">scipy.sparse.coo_matrix</a>, list[IndexLabel], list[IndexLabel]] pandas.core.arrays.sparse.scipy_sparse.sparse_series_to_coo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[int] &#160;</td>
          <td class="paramname"><em>row_levels</em> = <code>(0,)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[int] &#160;</td>
          <td class="paramname"><em>column_levels</em> = <code>(1,)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort_labels</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a sparse Series to a scipy.sparse.coo_matrix using index
levels row_levels, column_levels as the row and column
labels respectively. Returns the sparse_matrix, row and column labels.
</pre> <div class="fragment"><div class="line"><span class="lineno">  148</span>) -&gt; tuple[<a class="code hl_class" href="classscipy_1_1sparse_1_1__coo_1_1coo__matrix.html">scipy.sparse.coo_matrix</a>, list[IndexLabel], list[IndexLabel]]:</div>
<div class="line"><span class="lineno">  149</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    Convert a sparse Series to a scipy.sparse.coo_matrix using index</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    levels row_levels, column_levels as the row and column</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    labels respectively. Returns the sparse_matrix, row and column labels.</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  154</span>    <span class="keyword">import</span> <a class="code hl_namespace" href="namespacescipy_1_1sparse.html">scipy.sparse</a></div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">if</span> ss.index.nlevels &lt; 2:</div>
<div class="line"><span class="lineno">  157</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;to_coo requires MultiIndex with nlevels &gt;= 2.&quot;</span>)</div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> ss.index.is_unique:</div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  160</span>            <span class="stringliteral">&quot;Duplicate index entries are not allowed in to_coo transformation.&quot;</span></div>
<div class="line"><span class="lineno">  161</span>        )</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>    <span class="comment"># to keep things simple, only rely on integer indexing (not labels)</span></div>
<div class="line"><span class="lineno">  164</span>    row_levels = [ss.index._get_level_number(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> row_levels]</div>
<div class="line"><span class="lineno">  165</span>    column_levels = [ss.index._get_level_number(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> column_levels]</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>    v, i, j, rows, columns = _to_ijv(</div>
<div class="line"><span class="lineno">  168</span>        ss, row_levels=row_levels, column_levels=column_levels, sort_labels=sort_labels</div>
<div class="line"><span class="lineno">  169</span>    )</div>
<div class="line"><span class="lineno">  170</span>    sparse_matrix = <a class="code hl_class" href="classscipy_1_1sparse_1_1__coo_1_1coo__matrix.html">scipy.sparse.coo_matrix</a>(</div>
<div class="line"><span class="lineno">  171</span>        (v, (i, j)), shape=(len(rows), len(columns))</div>
<div class="line"><span class="lineno">  172</span>    )</div>
<div class="line"><span class="lineno">  173</span>    <span class="keywordflow">return</span> sparse_matrix, rows, columns</div>
<div class="line"><span class="lineno">  174</span> </div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="ttc" id="aclassscipy_1_1sparse_1_1__coo_1_1coo__matrix_html"><div class="ttname"><a href="classscipy_1_1sparse_1_1__coo_1_1coo__matrix.html">scipy.sparse._coo.coo_matrix</a></div><div class="ttdef"><b>Definition</b> _coo.py:22</div></div>
<div class="ttc" id="anamespacescipy_1_1sparse_html"><div class="ttname"><a href="namespacescipy_1_1sparse.html">scipy.sparse</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
