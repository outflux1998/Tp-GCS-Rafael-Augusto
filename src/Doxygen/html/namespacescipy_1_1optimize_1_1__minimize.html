<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.optimize._minimize Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize.html">optimize</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html">_minimize</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.optimize._minimize Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a06b55f429535e64a7a09e3106bce5381" id="r_a06b55f429535e64a7a09e3106bce5381"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a06b55f429535e64a7a09e3106bce5381">minimize</a> (fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=None, callback=None, options=None)</td></tr>
<tr class="separator:a06b55f429535e64a7a09e3106bce5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cce925ddde23ddeb63140539dc3014" id="r_a99cce925ddde23ddeb63140539dc3014"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a99cce925ddde23ddeb63140539dc3014">minimize_scalar</a> (fun, <a class="el" href="namespacescipy_1_1optimize_1_1__optimize.html#aee61cc6cef1e91f845fff5cf0a8fc44f">bracket</a>=None, bounds=None, args=(), method='<a class="el" href="namespacescipy_1_1optimize_1_1__optimize.html#ab667dd7bd58227d18103e3e286969b71">brent</a>', <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=None, options=None)</td></tr>
<tr class="separator:a99cce925ddde23ddeb63140539dc3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f97aa043b2d33a6aa37b011d3e9b50" id="r_a74f97aa043b2d33a6aa37b011d3e9b50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a74f97aa043b2d33a6aa37b011d3e9b50">_remove_from_bounds</a> (bounds, i_fixed)</td></tr>
<tr class="separator:a74f97aa043b2d33a6aa37b011d3e9b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac132482535741d9d6a933f380eeb4865" id="r_ac132482535741d9d6a933f380eeb4865"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#ac132482535741d9d6a933f380eeb4865">_remove_from_func</a> (fun_in, i_fixed, x_fixed, min_dim=None, remove=0)</td></tr>
<tr class="separator:ac132482535741d9d6a933f380eeb4865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37baabb489f94924d3a1f53103ca87a" id="r_af37baabb489f94924d3a1f53103ca87a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#af37baabb489f94924d3a1f53103ca87a">_add_to_array</a> (x_in, i_fixed, x_fixed)</td></tr>
<tr class="separator:af37baabb489f94924d3a1f53103ca87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3aa15f3847875f0ef7241594a0ef94" id="r_a1a3aa15f3847875f0ef7241594a0ef94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a1a3aa15f3847875f0ef7241594a0ef94">standardize_bounds</a> (bounds, x0, meth)</td></tr>
<tr class="separator:a1a3aa15f3847875f0ef7241594a0ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b03ad6211c83f03d6fa01635f8d2eac" id="r_a7b03ad6211c83f03d6fa01635f8d2eac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a7b03ad6211c83f03d6fa01635f8d2eac">standardize_constraints</a> (constraints, x0, meth)</td></tr>
<tr class="separator:a7b03ad6211c83f03d6fa01635f8d2eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544f953a44fca4f4bc22f08b8730adce" id="r_a544f953a44fca4f4bc22f08b8730adce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a544f953a44fca4f4bc22f08b8730adce">_optimize_result_for_equal_bounds</a> (fun, bounds, method, args=(), constraints=())</td></tr>
<tr class="separator:a544f953a44fca4f4bc22f08b8730adce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5a2f9bbf136a9cf97fb9a1bdeabefe90" id="r_a5a2f9bbf136a9cf97fb9a1bdeabefe90"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a5a2f9bbf136a9cf97fb9a1bdeabefe90">MINIMIZE_METHODS</a></td></tr>
<tr class="separator:a5a2f9bbf136a9cf97fb9a1bdeabefe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941d7c5e6c201976a8d6eecf67084eaf" id="r_a941d7c5e6c201976a8d6eecf67084eaf"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__minimize.html#a941d7c5e6c201976a8d6eecf67084eaf">MINIMIZE_SCALAR_METHODS</a> = ['<a class="el" href="namespacescipy_1_1optimize_1_1__optimize.html#ab667dd7bd58227d18103e3e286969b71">brent</a>', 'bounded', '<a class="el" href="namespacescipy_1_1optimize_1_1__optimize.html#a4f74c3036679f7cddb38d24bb4ad22ee">golden</a>']</td></tr>
<tr class="separator:a941d7c5e6c201976a8d6eecf67084eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Unified interfaces to minimization algorithms.

Functions
---------
- minimize : minimization of a function of several variables.
- minimize_scalar : minimization of a function of one variable.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="af37baabb489f94924d3a1f53103ca87a" name="af37baabb489f94924d3a1f53103ca87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37baabb489f94924d3a1f53103ca87a">&#9670;&#160;</a></span>_add_to_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize._add_to_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_fixed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Adds fixed variables back to an array</pre> <div class="fragment"><div class="line"><span class="lineno">  928</span><span class="keyword">def </span>_add_to_array(x_in, i_fixed, x_fixed):</div>
<div class="line"><span class="lineno">  929</span>    <span class="stringliteral">&quot;&quot;&quot;Adds fixed variables back to an array&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  930</span>    i_free = ~i_fixed</div>
<div class="line"><span class="lineno">  931</span>    <span class="keywordflow">if</span> x_in.ndim == 2:</div>
<div class="line"><span class="lineno">  932</span>        i_free = i_free[:, <span class="keywordtype">None</span>] @ i_free[<span class="keywordtype">None</span>, :]</div>
<div class="line"><span class="lineno">  933</span>    x_out = np.zeros_like(i_free, dtype=x_in.dtype)</div>
<div class="line"><span class="lineno">  934</span>    x_out[~i_free] = x_fixed</div>
<div class="line"><span class="lineno">  935</span>    x_out[i_free] = x_in.ravel()</div>
<div class="line"><span class="lineno">  936</span>    <span class="keywordflow">return</span> x_out</div>
<div class="line"><span class="lineno">  937</span> </div>
<div class="line"><span class="lineno">  938</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a544f953a44fca4f4bc22f08b8730adce" name="a544f953a44fca4f4bc22f08b8730adce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544f953a44fca4f4bc22f08b8730adce">&#9670;&#160;</a></span>_optimize_result_for_equal_bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize._optimize_result_for_equal_bounds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>constraints</em> = <code>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Provides a default OptimizeResult for when a bounded minimization method
has (lb == ub).all().

Parameters
----------
fun: callable
bounds: Bounds
method: str
constraints: Constraint
</pre> <div class="fragment"><div class="line"><span class="lineno">  979</span>):</div>
<div class="line"><span class="lineno">  980</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    Provides a default OptimizeResult for when a bounded minimization method</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    has (lb == ub).all().</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    fun: callable</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">    bounds: Bounds</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">    method: str</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    constraints: Constraint</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  991</span>    success = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  992</span>    message = <span class="stringliteral">&#39;All independent variables were fixed by bounds.&#39;</span></div>
<div class="line"><span class="lineno">  993</span> </div>
<div class="line"><span class="lineno">  994</span>    <span class="comment"># bounds is new-style</span></div>
<div class="line"><span class="lineno">  995</span>    x0 = bounds.lb</div>
<div class="line"><span class="lineno">  996</span> </div>
<div class="line"><span class="lineno">  997</span>    <span class="keywordflow">if</span> constraints:</div>
<div class="line"><span class="lineno">  998</span>        message = (<span class="stringliteral">&quot;All independent variables were fixed by bounds at values&quot;</span></div>
<div class="line"><span class="lineno">  999</span>                   <span class="stringliteral">&quot; that satisfy the constraints.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1000</span>        constraints = standardize_constraints(constraints, x0, <span class="stringliteral">&#39;new&#39;</span>)</div>
<div class="line"><span class="lineno"> 1001</span> </div>
<div class="line"><span class="lineno"> 1002</span>    maxcv = 0</div>
<div class="line"><span class="lineno"> 1003</span>    <span class="keywordflow">for</span> c <span class="keywordflow">in</span> constraints:</div>
<div class="line"><span class="lineno"> 1004</span>        pc = PreparedConstraint(c, x0)</div>
<div class="line"><span class="lineno"> 1005</span>        violation = pc.violation(x0)</div>
<div class="line"><span class="lineno"> 1006</span>        <span class="keywordflow">if</span> np.sum(violation):</div>
<div class="line"><span class="lineno"> 1007</span>            maxcv = max(maxcv, np.max(violation))</div>
<div class="line"><span class="lineno"> 1008</span>            success = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1009</span>            message = (f<span class="stringliteral">&quot;All independent variables were fixed by bounds, but &quot;</span></div>
<div class="line"><span class="lineno"> 1010</span>                       f<span class="stringliteral">&quot;the independent variables do not satisfy the &quot;</span></div>
<div class="line"><span class="lineno"> 1011</span>                       f<span class="stringliteral">&quot;constraints exactly. (Maximum violation: {maxcv}).&quot;</span>)</div>
<div class="line"><span class="lineno"> 1012</span> </div>
<div class="line"><span class="lineno"> 1013</span>    <span class="keywordflow">return</span> OptimizeResult(</div>
<div class="line"><span class="lineno"> 1014</span>        x=x0, fun=fun(x0, *args), success=success, message=message, nfev=1,</div>
<div class="line"><span class="lineno"> 1015</span>        njev=0, nhev=0,</div>
<div class="line"><span class="lineno"> 1016</span>    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74f97aa043b2d33a6aa37b011d3e9b50" name="a74f97aa043b2d33a6aa37b011d3e9b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f97aa043b2d33a6aa37b011d3e9b50">&#9670;&#160;</a></span>_remove_from_bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize._remove_from_bounds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i_fixed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Removes fixed variables from a `Bounds` instance</pre> <div class="fragment"><div class="line"><span class="lineno">  898</span><span class="keyword">def </span>_remove_from_bounds(bounds, i_fixed):</div>
<div class="line"><span class="lineno">  899</span>    <span class="stringliteral">&quot;&quot;&quot;Removes fixed variables from a `Bounds` instance&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  900</span>    lb = bounds.lb[~i_fixed]</div>
<div class="line"><span class="lineno">  901</span>    ub = bounds.ub[~i_fixed]</div>
<div class="line"><span class="lineno">  902</span>    <span class="keywordflow">return</span> Bounds(lb, ub)  <span class="comment"># don&#39;t mutate original Bounds object</span></div>
<div class="line"><span class="lineno">  903</span> </div>
<div class="line"><span class="lineno">  904</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac132482535741d9d6a933f380eeb4865" name="ac132482535741d9d6a933f380eeb4865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac132482535741d9d6a933f380eeb4865">&#9670;&#160;</a></span>_remove_from_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize._remove_from_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_dim</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remove</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wraps a function such that fixed variables need not be passed in</pre> <div class="fragment"><div class="line"><span class="lineno">  905</span><span class="keyword">def </span>_remove_from_func(fun_in, i_fixed, x_fixed, min_dim=None, remove=0):</div>
<div class="line"><span class="lineno">  906</span>    <span class="stringliteral">&quot;&quot;&quot;Wraps a function such that fixed variables need not be passed in&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  907</span>    <span class="keyword">def </span>fun_out(x_in, *args, **kwargs):</div>
<div class="line"><span class="lineno">  908</span>        x_out = np.zeros_like(i_fixed, dtype=x_in.dtype)</div>
<div class="line"><span class="lineno">  909</span>        x_out[i_fixed] = x_fixed</div>
<div class="line"><span class="lineno">  910</span>        x_out[~i_fixed] = x_in</div>
<div class="line"><span class="lineno">  911</span>        y_out = fun_in(x_out, *args, **kwargs)</div>
<div class="line"><span class="lineno">  912</span>        y_out = np.array(y_out)</div>
<div class="line"><span class="lineno">  913</span> </div>
<div class="line"><span class="lineno">  914</span>        <span class="keywordflow">if</span> min_dim == 1:</div>
<div class="line"><span class="lineno">  915</span>            y_out = np.atleast_1d(y_out)</div>
<div class="line"><span class="lineno">  916</span>        <span class="keywordflow">elif</span> min_dim == 2:</div>
<div class="line"><span class="lineno">  917</span>            y_out = np.atleast_2d(y_out)</div>
<div class="line"><span class="lineno">  918</span> </div>
<div class="line"><span class="lineno">  919</span>        <span class="keywordflow">if</span> remove == 1:</div>
<div class="line"><span class="lineno">  920</span>            y_out = y_out[..., ~i_fixed]</div>
<div class="line"><span class="lineno">  921</span>        <span class="keywordflow">elif</span> remove == 2:</div>
<div class="line"><span class="lineno">  922</span>            y_out = y_out[~i_fixed, ~i_fixed]</div>
<div class="line"><span class="lineno">  923</span> </div>
<div class="line"><span class="lineno">  924</span>        <span class="keywordflow">return</span> y_out</div>
<div class="line"><span class="lineno">  925</span>    <span class="keywordflow">return</span> fun_out</div>
<div class="line"><span class="lineno">  926</span> </div>
<div class="line"><span class="lineno">  927</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a06b55f429535e64a7a09e3106bce5381" name="a06b55f429535e64a7a09e3106bce5381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b55f429535e64a7a09e3106bce5381">&#9670;&#160;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize.minimize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jac</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hess</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hessp</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>constraints</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Minimization of scalar function of one or more variables.

Parameters
----------
fun : callable
    The objective function to be minimized.

        ``fun(x, *args) -&gt; float``

    where ``x`` is a 1-D array with shape (n,) and ``args``
    is a tuple of the fixed parameters needed to completely
    specify the function.
x0 : ndarray, shape (n,)
    Initial guess. Array of real elements of size (n,),
    where ``n`` is the number of independent variables.
args : tuple, optional
    Extra arguments passed to the objective function and its
    derivatives (`fun`, `jac` and `hess` functions).
method : str or callable, optional
    Type of solver.  Should be one of

        - 'Nelder-Mead' :ref:`(see here) &lt;optimize.minimize-neldermead&gt;`
        - 'Powell'      :ref:`(see here) &lt;optimize.minimize-powell&gt;`
        - 'CG'          :ref:`(see here) &lt;optimize.minimize-cg&gt;`
        - 'BFGS'        :ref:`(see here) &lt;optimize.minimize-bfgs&gt;`
        - 'Newton-CG'   :ref:`(see here) &lt;optimize.minimize-newtoncg&gt;`
        - 'L-BFGS-B'    :ref:`(see here) &lt;optimize.minimize-lbfgsb&gt;`
        - 'TNC'         :ref:`(see here) &lt;optimize.minimize-tnc&gt;`
        - 'COBYLA'      :ref:`(see here) &lt;optimize.minimize-cobyla&gt;`
        - 'SLSQP'       :ref:`(see here) &lt;optimize.minimize-slsqp&gt;`
        - 'trust-constr':ref:`(see here) &lt;optimize.minimize-trustconstr&gt;`
        - 'dogleg'      :ref:`(see here) &lt;optimize.minimize-dogleg&gt;`
        - 'trust-ncg'   :ref:`(see here) &lt;optimize.minimize-trustncg&gt;`
        - 'trust-exact' :ref:`(see here) &lt;optimize.minimize-trustexact&gt;`
        - 'trust-krylov' :ref:`(see here) &lt;optimize.minimize-trustkrylov&gt;`
        - custom - a callable object (added in version 0.14.0),
          see below for description.

    If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``,
    depending on whether or not the problem has constraints or bounds.
jac : {callable,  '2-point', '3-point', 'cs', bool}, optional
    Method for computing the gradient vector. Only for CG, BFGS,
    Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov,
    trust-exact and trust-constr.
    If it is a callable, it should be a function that returns the gradient
    vector:

        ``jac(x, *args) -&gt; array_like, shape (n,)``

    where ``x`` is an array with shape (n,) and ``args`` is a tuple with
    the fixed parameters. If `jac` is a Boolean and is True, `fun` is
    assumed to return a tuple ``(f, g)`` containing the objective
    function and the gradient.
    Methods 'Newton-CG', 'trust-ncg', 'dogleg', 'trust-exact', and
    'trust-krylov' require that either a callable be supplied, or that
    `fun` return the objective and gradient.
    If None or False, the gradient will be estimated using 2-point finite
    difference estimation with an absolute step size.
    Alternatively, the keywords  {'2-point', '3-point', 'cs'} can be used
    to select a finite difference scheme for numerical estimation of the
    gradient with a relative step size. These finite difference schemes
    obey any specified `bounds`.
hess : {callable, '2-point', '3-point', 'cs', HessianUpdateStrategy}, optional
    Method for computing the Hessian matrix. Only for Newton-CG, dogleg,
    trust-ncg, trust-krylov, trust-exact and trust-constr.
    If it is callable, it should return the Hessian matrix:

        ``hess(x, *args) -&gt; {LinearOperator, spmatrix, array}, (n, n)``

    where ``x`` is a (n,) ndarray and ``args`` is a tuple with the fixed
    parameters.
    The keywords {'2-point', '3-point', 'cs'} can also be used to select
    a finite difference scheme for numerical estimation of the hessian.
    Alternatively, objects implementing the `HessianUpdateStrategy`
    interface can be used to approximate the Hessian. Available
    quasi-Newton methods implementing this interface are:

        - `BFGS`;
        - `SR1`.

    Not all of the options are available for each of the methods; for
    availability refer to the notes.
hessp : callable, optional
    Hessian of objective function times an arbitrary vector p. Only for
    Newton-CG, trust-ncg, trust-krylov, trust-constr.
    Only one of `hessp` or `hess` needs to be given. If `hess` is
    provided, then `hessp` will be ignored. `hessp` must compute the
    Hessian times an arbitrary vector:

        ``hessp(x, p, *args) -&gt;  ndarray shape (n,)``

    where ``x`` is a (n,) ndarray, ``p`` is an arbitrary vector with
    dimension (n,) and ``args`` is a tuple with the fixed
    parameters.
bounds : sequence or `Bounds`, optional
    Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell, and
    trust-constr methods. There are two ways to specify the bounds:

        1. Instance of `Bounds` class.
        2. Sequence of ``(min, max)`` pairs for each element in `x`. None
           is used to specify no bound.

constraints : {Constraint, dict} or List of {Constraint, dict}, optional
    Constraints definition. Only for COBYLA, SLSQP and trust-constr.

    Constraints for 'trust-constr' are defined as a single object or a
    list of objects specifying constraints to the optimization problem.
    Available constraints are:

        - `LinearConstraint`
        - `NonlinearConstraint`

    Constraints for COBYLA, SLSQP are defined as a list of dictionaries.
    Each dictionary with fields:

        type : str
            Constraint type: 'eq' for equality, 'ineq' for inequality.
        fun : callable
            The function defining the constraint.
        jac : callable, optional
            The Jacobian of `fun` (only for SLSQP).
        args : sequence, optional
            Extra arguments to be passed to the function and Jacobian.

    Equality constraint means that the constraint function result is to
    be zero whereas inequality means that it is to be non-negative.
    Note that COBYLA only supports inequality constraints.
tol : float, optional
    Tolerance for termination. When `tol` is specified, the selected
    minimization algorithm sets some relevant solver-specific tolerance(s)
    equal to `tol`. For detailed control, use solver-specific
    options.
options : dict, optional
    A dictionary of solver options. All methods accept the following
    generic options:

        maxiter : int
            Maximum number of iterations to perform. Depending on the
            method each iteration may use several function evaluations.
        disp : bool
            Set to True to print convergence messages.

    For method-specific options, see :func:`show_options()`.
callback : callable, optional
    Called after each iteration. For 'trust-constr' it is a callable with
    the signature:

        ``callback(xk, OptimizeResult state) -&gt; bool``

    where ``xk`` is the current parameter vector. and ``state``
    is an `OptimizeResult` object, with the same fields
    as the ones from the return. If callback returns True
    the algorithm execution is terminated.
    For all the other methods, the signature is:

        ``callback(xk)``

    where ``xk`` is the current parameter vector.

Returns
-------
res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the optimizer exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes.

See also
--------
minimize_scalar : Interface to minimization algorithms for scalar
    univariate functions
show_options : Additional options accepted by the solvers

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *BFGS*.

**Unconstrained minimization**

Method :ref:`CG &lt;optimize.minimize-cg&gt;` uses a nonlinear conjugate
gradient algorithm by Polak and Ribiere, a variant of the
Fletcher-Reeves method described in [5]_ pp.120-122. Only the
first derivatives are used.

Method :ref:`BFGS &lt;optimize.minimize-bfgs&gt;` uses the quasi-Newton
method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [5]_
pp. 136. It uses the first derivatives only. BFGS has proven good
performance even for non-smooth optimizations. This method also
returns an approximation of the Hessian inverse, stored as
`hess_inv` in the OptimizeResult object.

Method :ref:`Newton-CG &lt;optimize.minimize-newtoncg&gt;` uses a
Newton-CG algorithm [5]_ pp. 168 (also known as the truncated
Newton method). It uses a CG method to the compute the search
direction. See also *TNC* method for a box-constrained
minimization with a similar algorithm. Suitable for large-scale
problems.

Method :ref:`dogleg &lt;optimize.minimize-dogleg&gt;` uses the dog-leg
trust-region algorithm [5]_ for unconstrained minimization. This
algorithm requires the gradient and Hessian; furthermore the
Hessian is required to be positive definite.

Method :ref:`trust-ncg &lt;optimize.minimize-trustncg&gt;` uses the
Newton conjugate gradient trust-region algorithm [5]_ for
unconstrained minimization. This algorithm requires the gradient
and either the Hessian or a function that computes the product of
the Hessian with a given vector. Suitable for large-scale problems.

Method :ref:`trust-krylov &lt;optimize.minimize-trustkrylov&gt;` uses
the Newton GLTR trust-region algorithm [14]_, [15]_ for unconstrained
minimization. This algorithm requires the gradient
and either the Hessian or a function that computes the product of
the Hessian with a given vector. Suitable for large-scale problems.
On indefinite problems it requires usually less iterations than the
`trust-ncg` method and is recommended for medium and large-scale problems.

Method :ref:`trust-exact &lt;optimize.minimize-trustexact&gt;`
is a trust-region method for unconstrained minimization in which
quadratic subproblems are solved almost exactly [13]_. This
algorithm requires the gradient and the Hessian (which is
*not* required to be positive definite). It is, in many
situations, the Newton method to converge in fewer iterations
and the most recommended for small and medium-size problems.

**Bound-Constrained minimization**

Method :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;` uses the
Simplex algorithm [1]_, [2]_. This algorithm is robust in many
applications. However, if numerical computation of derivative can be
trusted, other algorithms using the first and/or second derivatives
information might be preferred for their better performance in
general.

Method :ref:`L-BFGS-B &lt;optimize.minimize-lbfgsb&gt;` uses the L-BFGS-B
algorithm [6]_, [7]_ for bound constrained minimization.

Method :ref:`Powell &lt;optimize.minimize-powell&gt;` is a modification
of Powell's method [3]_, [4]_ which is a conjugate direction
method. It performs sequential one-dimensional minimizations along
each vector of the directions set (`direc` field in `options` and
`info`), which is updated at each iteration of the main
minimization loop. The function need not be differentiable, and no
derivatives are taken. If bounds are not provided, then an
unbounded line search will be used. If bounds are provided and
the initial guess is within the bounds, then every function
evaluation throughout the minimization procedure will be within
the bounds. If bounds are provided, the initial guess is outside
the bounds, and `direc` is full rank (default has full rank), then
some function evaluations during the first iteration may be
outside the bounds, but every function evaluation after the first
iteration will be within the bounds. If `direc` is not full rank,
then some parameters may not be optimized and the solution is not
guaranteed to be within the bounds.

Method :ref:`TNC &lt;optimize.minimize-tnc&gt;` uses a truncated Newton
algorithm [5]_, [8]_ to minimize a function with variables subject
to bounds. This algorithm uses gradient information; it is also
called Newton Conjugate-Gradient. It differs from the *Newton-CG*
method described above as it wraps a C implementation and allows
each variable to be given upper and lower bounds.

**Constrained Minimization**

Method :ref:`COBYLA &lt;optimize.minimize-cobyla&gt;` uses the
Constrained Optimization BY Linear Approximation (COBYLA) method
[9]_, [10]_, [11]_. The algorithm is based on linear
approximations to the objective function and each constraint. The
method wraps a FORTRAN implementation of the algorithm. The
constraints functions 'fun' may return either a single number
or an array or list of numbers.

Method :ref:`SLSQP &lt;optimize.minimize-slsqp&gt;` uses Sequential
Least SQuares Programming to minimize a function of several
variables with any combination of bounds, equality and inequality
constraints. The method wraps the SLSQP Optimization subroutine
originally implemented by Dieter Kraft [12]_. Note that the
wrapper handles infinite values in bounds by converting them into
large floating values.

Method :ref:`trust-constr &lt;optimize.minimize-trustconstr&gt;` is a
trust-region algorithm for constrained optimization. It swiches
between two implementations depending on the problem definition.
It is the most versatile constrained minimization algorithm
implemented in SciPy and the most appropriate for large-scale problems.
For equality constrained problems it is an implementation of Byrd-Omojokun
Trust-Region SQP method described in [17]_ and in [5]_, p. 549. When
inequality constraints are imposed as well, it swiches to the trust-region
interior point method described in [16]_. This interior point algorithm,
in turn, solves inequality constraints by introducing slack variables
and solving a sequence of equality-constrained barrier problems
for progressively smaller values of the barrier parameter.
The previously described equality constrained SQP method is
used to solve the subproblems with increasing levels of accuracy
as the iterate gets closer to a solution.

**Finite-Difference Options**

For Method :ref:`trust-constr &lt;optimize.minimize-trustconstr&gt;`
the gradient and the Hessian may be approximated using
three finite-difference schemes: {'2-point', '3-point', 'cs'}.
The scheme 'cs' is, potentially, the most accurate but it
requires the function to correctly handle complex inputs and to
be differentiable in the complex plane. The scheme '3-point' is more
accurate than '2-point' but requires twice as many operations. If the
gradient is estimated via finite-differences the Hessian must be
estimated using one of the quasi-Newton strategies.

**Method specific options for the** `hess` **keyword**

+--------------+------+----------+-------------------------+-----+
| method/Hess  | None | callable | '2-point/'3-point'/'cs' | HUS |
+==============+======+==========+=========================+=====+
| Newton-CG    | x    | (n, n)   | x                       | x   |
|              |      | LO       |                         |     |
+--------------+------+----------+-------------------------+-----+
| dogleg       |      | (n, n)   |                         |     |
+--------------+------+----------+-------------------------+-----+
| trust-ncg    |      | (n, n)   | x                       | x   |
+--------------+------+----------+-------------------------+-----+
| trust-krylov |      | (n, n)   | x                       | x   |
+--------------+------+----------+-------------------------+-----+
| trust-exact  |      | (n, n)   |                         |     |
+--------------+------+----------+-------------------------+-----+
| trust-constr | x    | (n, n)   |  x                      | x   |
|              |      | LO       |                         |     |
|              |      | sp       |                         |     |
+--------------+------+----------+-------------------------+-----+

where LO=LinearOperator, sp=Sparse matrix, HUS=HessianUpdateStrategy

**Custom minimizers**

It may be useful to pass a custom minimization method, for example
when using a frontend to this method such as `scipy.optimize.basinhopping`
or a different library.  You can simply pass a callable as the ``method``
parameter.

The callable is called as ``method(fun, x0, args, **kwargs, **options)``
where ``kwargs`` corresponds to any other parameters passed to `minimize`
(such as `callback`, `hess`, etc.), except the `options` dict, which has
its contents also passed as `method` parameters pair by pair.  Also, if
`jac` has been passed as a bool type, `jac` and `fun` are mangled so that
`fun` returns just the function values and `jac` is converted to a function
returning the Jacobian.  The method shall return an `OptimizeResult`
object.

The provided `method` callable must be able to accept (and possibly ignore)
arbitrary parameters; the set of parameters accepted by `minimize` may
expand in future versions and then these parameters will be passed to
the method.  You can find an example in the scipy.optimize tutorial.

.. versionadded:: 0.11.0

References
----------
.. [1] Nelder, J A, and R Mead. 1965. A Simplex Method for Function
    Minimization. The Computer Journal 7: 308-13.
.. [2] Wright M H. 1996. Direct search methods: Once scorned, now
    respectable, in Numerical Analysis 1995: Proceedings of the 1995
    Dundee Biennial Conference in Numerical Analysis (Eds. D F
    Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.
    191-208.
.. [3] Powell, M J D. 1964. An efficient method for finding the minimum of
   a function of several variables without calculating derivatives. The
   Computer Journal 7: 155-162.
.. [4] Press W, S A Teukolsky, W T Vetterling and B P Flannery.
   Numerical Recipes (any edition), Cambridge University Press.
.. [5] Nocedal, J, and S J Wright. 2006. Numerical Optimization.
   Springer New York.
.. [6] Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory
   Algorithm for Bound Constrained Optimization. SIAM Journal on
   Scientific and Statistical Computing 16 (5): 1190-1208.
.. [7] Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm
   778: L-BFGS-B, FORTRAN routines for large scale bound constrained
   optimization. ACM Transactions on Mathematical Software 23 (4):
   550-560.
.. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Method.
   1984. SIAM Journal of Numerical Analysis 21: 770-778.
.. [9] Powell, M J D. A direct search optimization method that models
   the objective and constraint functions by linear interpolation.
   1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez
   and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.
.. [10] Powell M J D. Direct search algorithms for optimization
   calculations. 1998. Acta Numerica 7: 287-336.
.. [11] Powell M J D. A view of algorithms for optimization without
   derivatives. 2007.Cambridge University Technical Report DAMTP
   2007/NA03
.. [12] Kraft, D. A software package for sequential quadratic
   programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace
   Center -- Institute for Flight Mechanics, Koln, Germany.
.. [13] Conn, A. R., Gould, N. I., and Toint, P. L.
   Trust region methods. 2000. Siam. pp. 169-200.
.. [14] F. Lenders, C. Kirches, A. Potschka: "trlib: A vector-free
   implementation of the GLTR method for iterative solution of
   the trust region problem", :arxiv:`1611.04718`
.. [15] N. Gould, S. Lucidi, M. Roma, P. Toint: "Solving the
   Trust-Region Subproblem using the Lanczos Method",
   SIAM J. Optim., 9(2), 504--525, (1999).
.. [16] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999.
    An interior point algorithm for large-scale nonlinear  programming.
    SIAM Journal on Optimization 9.4: 877-900.
.. [17] Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998. On the
    implementation of an algorithm for large-scale equality constrained
    optimization. SIAM Journal on Optimization 8.3: 682-706.

Examples
--------
Let us consider the problem of minimizing the Rosenbrock function. This
function (and its respective derivatives) is implemented in `rosen`
(resp. `rosen_der`, `rosen_hess`) in the `scipy.optimize`.

&gt;&gt;&gt; from scipy.optimize import minimize, rosen, rosen_der

A simple application of the *Nelder-Mead* method is:

&gt;&gt;&gt; x0 = [1.3, 0.7, 0.8, 1.9, 1.2]
&gt;&gt;&gt; res = minimize(rosen, x0, method='Nelder-Mead', tol=1e-6)
&gt;&gt;&gt; res.x
array([ 1.,  1.,  1.,  1.,  1.])

Now using the *BFGS* algorithm, using the first derivative and a few
options:

&gt;&gt;&gt; res = minimize(rosen, x0, method='BFGS', jac=rosen_der,
...                options={'gtol': 1e-6, 'disp': True})
Optimization terminated successfully.
         Current function value: 0.000000
         Iterations: 26
         Function evaluations: 31
         Gradient evaluations: 31
&gt;&gt;&gt; res.x
array([ 1.,  1.,  1.,  1.,  1.])
&gt;&gt;&gt; print(res.message)
Optimization terminated successfully.
&gt;&gt;&gt; res.hess_inv
array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary
       [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],
       [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],
       [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],
       [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])


Next, consider a minimization problem with several constraints (namely
Example 16.4 from [5]_). The objective function is:

&gt;&gt;&gt; fun = lambda x: (x[0] - 1)**2 + (x[1] - 2.5)**2

There are three constraints defined as:

&gt;&gt;&gt; cons = ({'type': 'ineq', 'fun': lambda x:  x[0] - 2 * x[1] + 2},
...         {'type': 'ineq', 'fun': lambda x: -x[0] - 2 * x[1] + 6},
...         {'type': 'ineq', 'fun': lambda x: -x[0] + 2 * x[1] + 2})

And variables must be positive, hence the following bounds:

&gt;&gt;&gt; bnds = ((0, None), (0, None))

The optimization problem is solved using the SLSQP method as:

&gt;&gt;&gt; res = minimize(fun, (2, 0), method='SLSQP', bounds=bnds,
...                constraints=cons)

It should converge to the theoretical solution (1.4 ,1.7).</pre> <div class="fragment"><div class="line"><span class="lineno">   47</span>             callback=<span class="keywordtype">None</span>, options=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">   48</span>    <span class="stringliteral">&quot;&quot;&quot;Minimization of scalar function of one or more variables.</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    fun : callable</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        The objective function to be minimized.</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">            ``fun(x, *args) -&gt; float``</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">        where ``x`` is a 1-D array with shape (n,) and ``args``</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        is a tuple of the fixed parameters needed to completely</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        specify the function.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    x0 : ndarray, shape (n,)</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        Initial guess. Array of real elements of size (n,),</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        where ``n`` is the number of independent variables.</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">        Extra arguments passed to the objective function and its</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        derivatives (`fun`, `jac` and `hess` functions).</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    method : str or callable, optional</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">        Type of solver.  Should be one of</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">            - &#39;Nelder-Mead&#39; :ref:`(see here) &lt;optimize.minimize-neldermead&gt;`</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">            - &#39;Powell&#39;      :ref:`(see here) &lt;optimize.minimize-powell&gt;`</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">            - &#39;CG&#39;          :ref:`(see here) &lt;optimize.minimize-cg&gt;`</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">            - &#39;BFGS&#39;        :ref:`(see here) &lt;optimize.minimize-bfgs&gt;`</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">            - &#39;Newton-CG&#39;   :ref:`(see here) &lt;optimize.minimize-newtoncg&gt;`</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">            - &#39;L-BFGS-B&#39;    :ref:`(see here) &lt;optimize.minimize-lbfgsb&gt;`</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">            - &#39;TNC&#39;         :ref:`(see here) &lt;optimize.minimize-tnc&gt;`</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">            - &#39;COBYLA&#39;      :ref:`(see here) &lt;optimize.minimize-cobyla&gt;`</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">            - &#39;SLSQP&#39;       :ref:`(see here) &lt;optimize.minimize-slsqp&gt;`</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">            - &#39;trust-constr&#39;:ref:`(see here) &lt;optimize.minimize-trustconstr&gt;`</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">            - &#39;dogleg&#39;      :ref:`(see here) &lt;optimize.minimize-dogleg&gt;`</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">            - &#39;trust-ncg&#39;   :ref:`(see here) &lt;optimize.minimize-trustncg&gt;`</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">            - &#39;trust-exact&#39; :ref:`(see here) &lt;optimize.minimize-trustexact&gt;`</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">            - &#39;trust-krylov&#39; :ref:`(see here) &lt;optimize.minimize-trustkrylov&gt;`</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">            - custom - a callable object (added in version 0.14.0),</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">              see below for description.</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``,</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        depending on whether or not the problem has constraints or bounds.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    jac : {callable,  &#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;, bool}, optional</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        Method for computing the gradient vector. Only for CG, BFGS,</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov,</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        trust-exact and trust-constr.</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        If it is a callable, it should be a function that returns the gradient</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        vector:</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">            ``jac(x, *args) -&gt; array_like, shape (n,)``</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        where ``x`` is an array with shape (n,) and ``args`` is a tuple with</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        the fixed parameters. If `jac` is a Boolean and is True, `fun` is</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">        assumed to return a tuple ``(f, g)`` containing the objective</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        function and the gradient.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        Methods &#39;Newton-CG&#39;, &#39;trust-ncg&#39;, &#39;dogleg&#39;, &#39;trust-exact&#39;, and</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        &#39;trust-krylov&#39; require that either a callable be supplied, or that</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        `fun` return the objective and gradient.</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        If None or False, the gradient will be estimated using 2-point finite</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        difference estimation with an absolute step size.</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        Alternatively, the keywords  {&#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;} can be used</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        to select a finite difference scheme for numerical estimation of the</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        gradient with a relative step size. These finite difference schemes</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        obey any specified `bounds`.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    hess : {callable, &#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;, HessianUpdateStrategy}, optional</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        Method for computing the Hessian matrix. Only for Newton-CG, dogleg,</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        trust-ncg, trust-krylov, trust-exact and trust-constr.</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        If it is callable, it should return the Hessian matrix:</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">            ``hess(x, *args) -&gt; {LinearOperator, spmatrix, array}, (n, n)``</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">        where ``x`` is a (n,) ndarray and ``args`` is a tuple with the fixed</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        parameters.</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        The keywords {&#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;} can also be used to select</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        a finite difference scheme for numerical estimation of the hessian.</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        Alternatively, objects implementing the `HessianUpdateStrategy`</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        interface can be used to approximate the Hessian. Available</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">        quasi-Newton methods implementing this interface are:</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">            - `BFGS`;</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">            - `SR1`.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        Not all of the options are available for each of the methods; for</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">        availability refer to the notes.</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    hessp : callable, optional</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        Hessian of objective function times an arbitrary vector p. Only for</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">        Newton-CG, trust-ncg, trust-krylov, trust-constr.</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">        Only one of `hessp` or `hess` needs to be given. If `hess` is</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">        provided, then `hessp` will be ignored. `hessp` must compute the</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">        Hessian times an arbitrary vector:</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">            ``hessp(x, p, *args) -&gt;  ndarray shape (n,)``</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        where ``x`` is a (n,) ndarray, ``p`` is an arbitrary vector with</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        dimension (n,) and ``args`` is a tuple with the fixed</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        parameters.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    bounds : sequence or `Bounds`, optional</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell, and</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        trust-constr methods. There are two ways to specify the bounds:</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">            1. Instance of `Bounds` class.</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">            2. Sequence of ``(min, max)`` pairs for each element in `x`. None</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">               is used to specify no bound.</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    constraints : {Constraint, dict} or List of {Constraint, dict}, optional</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        Constraints definition. Only for COBYLA, SLSQP and trust-constr.</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        Constraints for &#39;trust-constr&#39; are defined as a single object or a</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        list of objects specifying constraints to the optimization problem.</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        Available constraints are:</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">            - `LinearConstraint`</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">            - `NonlinearConstraint`</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        Constraints for COBYLA, SLSQP are defined as a list of dictionaries.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        Each dictionary with fields:</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">            type : str</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">                Constraint type: &#39;eq&#39; for equality, &#39;ineq&#39; for inequality.</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">            fun : callable</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">                The function defining the constraint.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">            jac : callable, optional</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">                The Jacobian of `fun` (only for SLSQP).</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">            args : sequence, optional</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">                Extra arguments to be passed to the function and Jacobian.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        Equality constraint means that the constraint function result is to</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        be zero whereas inequality means that it is to be non-negative.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        Note that COBYLA only supports inequality constraints.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        Tolerance for termination. When `tol` is specified, the selected</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">        minimization algorithm sets some relevant solver-specific tolerance(s)</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">        equal to `tol`. For detailed control, use solver-specific</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">        options.</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    options : dict, optional</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        A dictionary of solver options. All methods accept the following</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        generic options:</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">            maxiter : int</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">                Maximum number of iterations to perform. Depending on the</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">                method each iteration may use several function evaluations.</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">            disp : bool</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">                Set to True to print convergence messages.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">        For method-specific options, see :func:`show_options()`.</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    callback : callable, optional</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        Called after each iteration. For &#39;trust-constr&#39; it is a callable with</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        the signature:</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">            ``callback(xk, OptimizeResult state) -&gt; bool``</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        where ``xk`` is the current parameter vector. and ``state``</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">        is an `OptimizeResult` object, with the same fields</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">        as the ones from the return. If callback returns True</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        the algorithm execution is terminated.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        For all the other methods, the signature is:</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">            ``callback(xk)``</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">        where ``xk`` is the current parameter vector.</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    res : OptimizeResult</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        The optimization result represented as a ``OptimizeResult`` object.</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        Important attributes are: ``x`` the solution array, ``success`` a</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        Boolean flag indicating if the optimizer exited successfully and</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        ``message`` which describes the cause of the termination. See</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        `OptimizeResult` for a description of other attributes.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    minimize_scalar : Interface to minimization algorithms for scalar</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        univariate functions</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    show_options : Additional options accepted by the solvers</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    This section describes the available solvers that can be selected by the</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    &#39;method&#39; parameter. The default method is *BFGS*.</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    **Unconstrained minimization**</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    Method :ref:`CG &lt;optimize.minimize-cg&gt;` uses a nonlinear conjugate</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    gradient algorithm by Polak and Ribiere, a variant of the</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Fletcher-Reeves method described in [5]_ pp.120-122. Only the</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    first derivatives are used.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Method :ref:`BFGS &lt;optimize.minimize-bfgs&gt;` uses the quasi-Newton</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [5]_</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    pp. 136. It uses the first derivatives only. BFGS has proven good</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    performance even for non-smooth optimizations. This method also</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    returns an approximation of the Hessian inverse, stored as</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    `hess_inv` in the OptimizeResult object.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    Method :ref:`Newton-CG &lt;optimize.minimize-newtoncg&gt;` uses a</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    Newton-CG algorithm [5]_ pp. 168 (also known as the truncated</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    Newton method). It uses a CG method to the compute the search</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    direction. See also *TNC* method for a box-constrained</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    minimization with a similar algorithm. Suitable for large-scale</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    problems.</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    Method :ref:`dogleg &lt;optimize.minimize-dogleg&gt;` uses the dog-leg</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    trust-region algorithm [5]_ for unconstrained minimization. This</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    algorithm requires the gradient and Hessian; furthermore the</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    Hessian is required to be positive definite.</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    Method :ref:`trust-ncg &lt;optimize.minimize-trustncg&gt;` uses the</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    Newton conjugate gradient trust-region algorithm [5]_ for</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    unconstrained minimization. This algorithm requires the gradient</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    and either the Hessian or a function that computes the product of</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    the Hessian with a given vector. Suitable for large-scale problems.</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    Method :ref:`trust-krylov &lt;optimize.minimize-trustkrylov&gt;` uses</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    the Newton GLTR trust-region algorithm [14]_, [15]_ for unconstrained</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    minimization. This algorithm requires the gradient</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    and either the Hessian or a function that computes the product of</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    the Hessian with a given vector. Suitable for large-scale problems.</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    On indefinite problems it requires usually less iterations than the</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    `trust-ncg` method and is recommended for medium and large-scale problems.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    Method :ref:`trust-exact &lt;optimize.minimize-trustexact&gt;`</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    is a trust-region method for unconstrained minimization in which</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    quadratic subproblems are solved almost exactly [13]_. This</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    algorithm requires the gradient and the Hessian (which is</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    *not* required to be positive definite). It is, in many</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    situations, the Newton method to converge in fewer iterations</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    and the most recommended for small and medium-size problems.</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    **Bound-Constrained minimization**</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    Method :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;` uses the</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    Simplex algorithm [1]_, [2]_. This algorithm is robust in many</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    applications. However, if numerical computation of derivative can be</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    trusted, other algorithms using the first and/or second derivatives</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    information might be preferred for their better performance in</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    general.</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    Method :ref:`L-BFGS-B &lt;optimize.minimize-lbfgsb&gt;` uses the L-BFGS-B</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    algorithm [6]_, [7]_ for bound constrained minimization.</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    Method :ref:`Powell &lt;optimize.minimize-powell&gt;` is a modification</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    of Powell&#39;s method [3]_, [4]_ which is a conjugate direction</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    method. It performs sequential one-dimensional minimizations along</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    each vector of the directions set (`direc` field in `options` and</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    `info`), which is updated at each iteration of the main</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    minimization loop. The function need not be differentiable, and no</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    derivatives are taken. If bounds are not provided, then an</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    unbounded line search will be used. If bounds are provided and</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    the initial guess is within the bounds, then every function</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    evaluation throughout the minimization procedure will be within</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    the bounds. If bounds are provided, the initial guess is outside</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    the bounds, and `direc` is full rank (default has full rank), then</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    some function evaluations during the first iteration may be</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    outside the bounds, but every function evaluation after the first</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    iteration will be within the bounds. If `direc` is not full rank,</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    then some parameters may not be optimized and the solution is not</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    guaranteed to be within the bounds.</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    Method :ref:`TNC &lt;optimize.minimize-tnc&gt;` uses a truncated Newton</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    algorithm [5]_, [8]_ to minimize a function with variables subject</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    to bounds. This algorithm uses gradient information; it is also</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    called Newton Conjugate-Gradient. It differs from the *Newton-CG*</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    method described above as it wraps a C implementation and allows</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    each variable to be given upper and lower bounds.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    **Constrained Minimization**</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    Method :ref:`COBYLA &lt;optimize.minimize-cobyla&gt;` uses the</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    Constrained Optimization BY Linear Approximation (COBYLA) method</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    [9]_, [10]_, [11]_. The algorithm is based on linear</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    approximations to the objective function and each constraint. The</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    method wraps a FORTRAN implementation of the algorithm. The</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    constraints functions &#39;fun&#39; may return either a single number</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    or an array or list of numbers.</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    Method :ref:`SLSQP &lt;optimize.minimize-slsqp&gt;` uses Sequential</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    Least SQuares Programming to minimize a function of several</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    variables with any combination of bounds, equality and inequality</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    constraints. The method wraps the SLSQP Optimization subroutine</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    originally implemented by Dieter Kraft [12]_. Note that the</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    wrapper handles infinite values in bounds by converting them into</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    large floating values.</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    Method :ref:`trust-constr &lt;optimize.minimize-trustconstr&gt;` is a</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    trust-region algorithm for constrained optimization. It swiches</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    between two implementations depending on the problem definition.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    It is the most versatile constrained minimization algorithm</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    implemented in SciPy and the most appropriate for large-scale problems.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    For equality constrained problems it is an implementation of Byrd-Omojokun</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    Trust-Region SQP method described in [17]_ and in [5]_, p. 549. When</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    inequality constraints are imposed as well, it swiches to the trust-region</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    interior point method described in [16]_. This interior point algorithm,</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    in turn, solves inequality constraints by introducing slack variables</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    and solving a sequence of equality-constrained barrier problems</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    for progressively smaller values of the barrier parameter.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    The previously described equality constrained SQP method is</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    used to solve the subproblems with increasing levels of accuracy</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    as the iterate gets closer to a solution.</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    **Finite-Difference Options**</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    For Method :ref:`trust-constr &lt;optimize.minimize-trustconstr&gt;`</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    the gradient and the Hessian may be approximated using</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    three finite-difference schemes: {&#39;2-point&#39;, &#39;3-point&#39;, &#39;cs&#39;}.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    The scheme &#39;cs&#39; is, potentially, the most accurate but it</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    requires the function to correctly handle complex inputs and to</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    be differentiable in the complex plane. The scheme &#39;3-point&#39; is more</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    accurate than &#39;2-point&#39; but requires twice as many operations. If the</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    gradient is estimated via finite-differences the Hessian must be</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    estimated using one of the quasi-Newton strategies.</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    **Method specific options for the** `hess` **keyword**</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    +--------------+------+----------+-------------------------+-----+</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    | method/Hess  | None | callable | &#39;2-point/&#39;3-point&#39;/&#39;cs&#39; | HUS |</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    +==============+======+==========+=========================+=====+</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    | Newton-CG    | x    | (n, n)   | x                       | x   |</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    |              |      | LO       |                         |     |</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    +--------------+------+----------+-------------------------+-----+</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    | dogleg       |      | (n, n)   |                         |     |</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    +--------------+------+----------+-------------------------+-----+</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    | trust-ncg    |      | (n, n)   | x                       | x   |</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    +--------------+------+----------+-------------------------+-----+</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    | trust-krylov |      | (n, n)   | x                       | x   |</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    +--------------+------+----------+-------------------------+-----+</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    | trust-exact  |      | (n, n)   |                         |     |</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    +--------------+------+----------+-------------------------+-----+</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    | trust-constr | x    | (n, n)   |  x                      | x   |</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    |              |      | LO       |                         |     |</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    |              |      | sp       |                         |     |</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    +--------------+------+----------+-------------------------+-----+</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    where LO=LinearOperator, sp=Sparse matrix, HUS=HessianUpdateStrategy</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    **Custom minimizers**</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    It may be useful to pass a custom minimization method, for example</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    when using a frontend to this method such as `scipy.optimize.basinhopping`</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    or a different library.  You can simply pass a callable as the ``method``</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    parameter.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    The callable is called as ``method(fun, x0, args, **kwargs, **options)``</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    where ``kwargs`` corresponds to any other parameters passed to `minimize`</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    (such as `callback`, `hess`, etc.), except the `options` dict, which has</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    its contents also passed as `method` parameters pair by pair.  Also, if</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    `jac` has been passed as a bool type, `jac` and `fun` are mangled so that</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    `fun` returns just the function values and `jac` is converted to a function</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    returning the Jacobian.  The method shall return an `OptimizeResult`</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    object.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    The provided `method` callable must be able to accept (and possibly ignore)</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    arbitrary parameters; the set of parameters accepted by `minimize` may</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    expand in future versions and then these parameters will be passed to</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    the method.  You can find an example in the scipy.optimize tutorial.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    .. [1] Nelder, J A, and R Mead. 1965. A Simplex Method for Function</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">        Minimization. The Computer Journal 7: 308-13.</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    .. [2] Wright M H. 1996. Direct search methods: Once scorned, now</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        respectable, in Numerical Analysis 1995: Proceedings of the 1995</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        Dundee Biennial Conference in Numerical Analysis (Eds. D F</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">        191-208.</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    .. [3] Powell, M J D. 1964. An efficient method for finding the minimum of</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">       a function of several variables without calculating derivatives. The</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">       Computer Journal 7: 155-162.</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    .. [4] Press W, S A Teukolsky, W T Vetterling and B P Flannery.</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">       Numerical Recipes (any edition), Cambridge University Press.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    .. [5] Nocedal, J, and S J Wright. 2006. Numerical Optimization.</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">       Springer New York.</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    .. [6] Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">       Algorithm for Bound Constrained Optimization. SIAM Journal on</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">       Scientific and Statistical Computing 16 (5): 1190-1208.</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    .. [7] Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">       778: L-BFGS-B, FORTRAN routines for large scale bound constrained</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">       optimization. ACM Transactions on Mathematical Software 23 (4):</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">       550-560.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    .. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Method.</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">       1984. SIAM Journal of Numerical Analysis 21: 770-778.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    .. [9] Powell, M J D. A direct search optimization method that models</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">       the objective and constraint functions by linear interpolation.</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">       1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">       and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    .. [10] Powell M J D. Direct search algorithms for optimization</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">       calculations. 1998. Acta Numerica 7: 287-336.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    .. [11] Powell M J D. A view of algorithms for optimization without</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">       derivatives. 2007.Cambridge University Technical Report DAMTP</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">       2007/NA03</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    .. [12] Kraft, D. A software package for sequential quadratic</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">       programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">       Center -- Institute for Flight Mechanics, Koln, Germany.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    .. [13] Conn, A. R., Gould, N. I., and Toint, P. L.</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">       Trust region methods. 2000. Siam. pp. 169-200.</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    .. [14] F. Lenders, C. Kirches, A. Potschka: &quot;trlib: A vector-free</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">       implementation of the GLTR method for iterative solution of</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">       the trust region problem&quot;, :arxiv:`1611.04718`</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    .. [15] N. Gould, S. Lucidi, M. Roma, P. Toint: &quot;Solving the</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">       Trust-Region Subproblem using the Lanczos Method&quot;,</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">       SIAM J. Optim., 9(2), 504--525, (1999).</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    .. [16] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999.</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        An interior point algorithm for large-scale nonlinear  programming.</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        SIAM Journal on Optimization 9.4: 877-900.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    .. [17] Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998. On the</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        implementation of an algorithm for large-scale equality constrained</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">        optimization. SIAM Journal on Optimization 8.3: 682-706.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    Let us consider the problem of minimizing the Rosenbrock function. This</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    function (and its respective derivatives) is implemented in `rosen`</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    (resp. `rosen_der`, `rosen_hess`) in the `scipy.optimize`.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.optimize import minimize, rosen, rosen_der</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    A simple application of the *Nelder-Mead* method is:</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    &gt;&gt;&gt; x0 = [1.3, 0.7, 0.8, 1.9, 1.2]</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    &gt;&gt;&gt; res = minimize(rosen, x0, method=&#39;Nelder-Mead&#39;, tol=1e-6)</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    &gt;&gt;&gt; res.x</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    array([ 1.,  1.,  1.,  1.,  1.])</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    Now using the *BFGS* algorithm, using the first derivative and a few</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    options:</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    &gt;&gt;&gt; res = minimize(rosen, x0, method=&#39;BFGS&#39;, jac=rosen_der,</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    ...                options={&#39;gtol&#39;: 1e-6, &#39;disp&#39;: True})</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    Optimization terminated successfully.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">             Current function value: 0.000000</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">             Iterations: 26</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">             Function evaluations: 31</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">             Gradient evaluations: 31</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    &gt;&gt;&gt; res.x</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    array([ 1.,  1.,  1.,  1.,  1.])</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    &gt;&gt;&gt; print(res.message)</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    Optimization terminated successfully.</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    &gt;&gt;&gt; res.hess_inv</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">           [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">           [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">           [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">           [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    Next, consider a minimization problem with several constraints (namely</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    Example 16.4 from [5]_). The objective function is:</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    &gt;&gt;&gt; fun = lambda x: (x[0] - 1)**2 + (x[1] - 2.5)**2</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    There are three constraints defined as:</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    &gt;&gt;&gt; cons = ({&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x:  x[0] - 2 * x[1] + 2},</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    ...         {&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x: -x[0] - 2 * x[1] + 6},</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    ...         {&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x: -x[0] + 2 * x[1] + 2})</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    And variables must be positive, hence the following bounds:</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    &gt;&gt;&gt; bnds = ((0, None), (0, None))</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    The optimization problem is solved using the SLSQP method as:</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    &gt;&gt;&gt; res = minimize(fun, (2, 0), method=&#39;SLSQP&#39;, bounds=bnds,</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    ...                constraints=cons)</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    It should converge to the theoretical solution (1.4 ,1.7).</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  516</span>    x0 = np.atleast_1d(np.asarray(x0))</div>
<div class="line"><span class="lineno">  517</span> </div>
<div class="line"><span class="lineno">  518</span>    <span class="keywordflow">if</span> x0.ndim != 1:</div>
<div class="line"><span class="lineno">  519</span>        message = (<span class="stringliteral">&#39;Use of `minimize` with `x0.ndim != 1` is deprecated. &#39;</span></div>
<div class="line"><span class="lineno">  520</span>                   <span class="stringliteral">&#39;Currently, singleton dimensions will be removed from &#39;</span></div>
<div class="line"><span class="lineno">  521</span>                   <span class="stringliteral">&#39;`x0`, but an error will be raised in SciPy 1.11.0.&#39;</span>)</div>
<div class="line"><span class="lineno">  522</span>        warn(message, DeprecationWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  523</span>        x0 = np.atleast_1d(np.squeeze(x0))</div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span>    <span class="keywordflow">if</span> x0.dtype.kind <span class="keywordflow">in</span> np.typecodes[<span class="stringliteral">&quot;AllInteger&quot;</span>]:</div>
<div class="line"><span class="lineno">  526</span>        x0 = np.asarray(x0, dtype=float)</div>
<div class="line"><span class="lineno">  527</span> </div>
<div class="line"><span class="lineno">  528</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(args, tuple):</div>
<div class="line"><span class="lineno">  529</span>        args = (args,)</div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordflow">if</span> method <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  532</span>        <span class="comment"># Select automatically</span></div>
<div class="line"><span class="lineno">  533</span>        <span class="keywordflow">if</span> constraints:</div>
<div class="line"><span class="lineno">  534</span>            method = <span class="stringliteral">&#39;SLSQP&#39;</span></div>
<div class="line"><span class="lineno">  535</span>        <span class="keywordflow">elif</span> bounds <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  536</span>            method = <span class="stringliteral">&#39;L-BFGS-B&#39;</span></div>
<div class="line"><span class="lineno">  537</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  538</span>            method = <span class="stringliteral">&#39;BFGS&#39;</span></div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>    <span class="keywordflow">if</span> callable(method):</div>
<div class="line"><span class="lineno">  541</span>        meth = <span class="stringliteral">&quot;_custom&quot;</span></div>
<div class="line"><span class="lineno">  542</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  543</span>        meth = method.lower()</div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span>    <span class="keywordflow">if</span> options <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  546</span>        options = {}</div>
<div class="line"><span class="lineno">  547</span>    <span class="comment"># check if optional parameters are supported by the selected method</span></div>
<div class="line"><span class="lineno">  548</span>    <span class="comment"># - jac</span></div>
<div class="line"><span class="lineno">  549</span>    <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;nelder-mead&#39;</span>, <span class="stringliteral">&#39;powell&#39;</span>, <span class="stringliteral">&#39;cobyla&#39;</span>) <span class="keywordflow">and</span> bool(jac):</div>
<div class="line"><span class="lineno">  550</span>        warn(<span class="stringliteral">&#39;Method %s does not use gradient information (jac).&#39;</span> % method,</div>
<div class="line"><span class="lineno">  551</span>             RuntimeWarning)</div>
<div class="line"><span class="lineno">  552</span>    <span class="comment"># - hess</span></div>
<div class="line"><span class="lineno">  553</span>    <span class="keywordflow">if</span> meth <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;newton-cg&#39;</span>, <span class="stringliteral">&#39;dogleg&#39;</span>, <span class="stringliteral">&#39;trust-ncg&#39;</span>, <span class="stringliteral">&#39;trust-constr&#39;</span>,</div>
<div class="line"><span class="lineno">  554</span>                    <span class="stringliteral">&#39;trust-krylov&#39;</span>, <span class="stringliteral">&#39;trust-exact&#39;</span>, <span class="stringliteral">&#39;_custom&#39;</span>) <span class="keywordflow">and</span> hess <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  555</span>        warn(<span class="stringliteral">&#39;Method %s does not use Hessian information (hess).&#39;</span> % method,</div>
<div class="line"><span class="lineno">  556</span>             RuntimeWarning)</div>
<div class="line"><span class="lineno">  557</span>    <span class="comment"># - hessp</span></div>
<div class="line"><span class="lineno">  558</span>    <span class="keywordflow">if</span> meth <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;newton-cg&#39;</span>, <span class="stringliteral">&#39;dogleg&#39;</span>, <span class="stringliteral">&#39;trust-ncg&#39;</span>, <span class="stringliteral">&#39;trust-constr&#39;</span>,</div>
<div class="line"><span class="lineno">  559</span>                    <span class="stringliteral">&#39;trust-krylov&#39;</span>, <span class="stringliteral">&#39;_custom&#39;</span>) \</div>
<div class="line"><span class="lineno">  560</span>       <span class="keywordflow">and</span> hessp <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  561</span>        warn(<span class="stringliteral">&#39;Method %s does not use Hessian-vector product &#39;</span></div>
<div class="line"><span class="lineno">  562</span>             <span class="stringliteral">&#39;information (hessp).&#39;</span> % method, RuntimeWarning)</div>
<div class="line"><span class="lineno">  563</span>    <span class="comment"># - constraints or bounds</span></div>
<div class="line"><span class="lineno">  564</span>    <span class="keywordflow">if</span> (meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;cg&#39;</span>, <span class="stringliteral">&#39;bfgs&#39;</span>, <span class="stringliteral">&#39;newton-cg&#39;</span>, <span class="stringliteral">&#39;dogleg&#39;</span>, <span class="stringliteral">&#39;trust-ncg&#39;</span>)</div>
<div class="line"><span class="lineno">  565</span>            <span class="keywordflow">and</span> (bounds <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> np.any(constraints))):</div>
<div class="line"><span class="lineno">  566</span>        warn(<span class="stringliteral">&#39;Method %s cannot handle constraints nor bounds.&#39;</span> % method,</div>
<div class="line"><span class="lineno">  567</span>             RuntimeWarning)</div>
<div class="line"><span class="lineno">  568</span>    <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;nelder-mead&#39;</span>, <span class="stringliteral">&#39;l-bfgs-b&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>, <span class="stringliteral">&#39;powell&#39;</span>) <span class="keywordflow">and</span> np.any(constraints):</div>
<div class="line"><span class="lineno">  569</span>        warn(<span class="stringliteral">&#39;Method %s cannot handle constraints.&#39;</span> % method,</div>
<div class="line"><span class="lineno">  570</span>             RuntimeWarning)</div>
<div class="line"><span class="lineno">  571</span>    <span class="keywordflow">if</span> meth == <span class="stringliteral">&#39;cobyla&#39;</span> <span class="keywordflow">and</span> bounds <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  572</span>        warn(<span class="stringliteral">&#39;Method %s cannot handle bounds.&#39;</span> % method,</div>
<div class="line"><span class="lineno">  573</span>             RuntimeWarning)</div>
<div class="line"><span class="lineno">  574</span>    <span class="comment"># - return_all</span></div>
<div class="line"><span class="lineno">  575</span>    <span class="keywordflow">if</span> (meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;l-bfgs-b&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>, <span class="stringliteral">&#39;cobyla&#39;</span>, <span class="stringliteral">&#39;slsqp&#39;</span>) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  576</span>            options.get(<span class="stringliteral">&#39;return_all&#39;</span>, <span class="keyword">False</span>)):</div>
<div class="line"><span class="lineno">  577</span>        warn(<span class="stringliteral">&#39;Method %s does not support the return_all option.&#39;</span> % method,</div>
<div class="line"><span class="lineno">  578</span>             RuntimeWarning)</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span>    <span class="comment"># check gradient vector</span></div>
<div class="line"><span class="lineno">  581</span>    <span class="keywordflow">if</span> callable(jac):</div>
<div class="line"><span class="lineno">  582</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  583</span>    <span class="keywordflow">elif</span> jac <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  584</span>        <span class="comment"># fun returns func and grad</span></div>
<div class="line"><span class="lineno">  585</span>        fun = MemoizeJac(fun)</div>
<div class="line"><span class="lineno">  586</span>        jac = fun.derivative</div>
<div class="line"><span class="lineno">  587</span>    <span class="keywordflow">elif</span> (jac <span class="keywordflow">in</span> FD_METHODS <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  588</span>          meth <span class="keywordflow">in</span> [<span class="stringliteral">&#39;trust-constr&#39;</span>, <span class="stringliteral">&#39;bfgs&#39;</span>, <span class="stringliteral">&#39;cg&#39;</span>, <span class="stringliteral">&#39;l-bfgs-b&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>, <span class="stringliteral">&#39;slsqp&#39;</span>]):</div>
<div class="line"><span class="lineno">  589</span>        <span class="comment"># finite differences with relative step</span></div>
<div class="line"><span class="lineno">  590</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  591</span>    <span class="keywordflow">elif</span> meth <span class="keywordflow">in</span> [<span class="stringliteral">&#39;trust-constr&#39;</span>]:</div>
<div class="line"><span class="lineno">  592</span>        <span class="comment"># default jac calculation for this method</span></div>
<div class="line"><span class="lineno">  593</span>        jac = <span class="stringliteral">&#39;2-point&#39;</span></div>
<div class="line"><span class="lineno">  594</span>    <span class="keywordflow">elif</span> jac <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> bool(jac) <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno">  595</span>        <span class="comment"># this will cause e.g. LBFGS to use forward difference, absolute step</span></div>
<div class="line"><span class="lineno">  596</span>        jac = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  597</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  598</span>        <span class="comment"># default if jac option is not understood</span></div>
<div class="line"><span class="lineno">  599</span>        jac = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>    <span class="comment"># set default tolerances</span></div>
<div class="line"><span class="lineno">  602</span>    <span class="keywordflow">if</span> tol <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  603</span>        options = dict(options)</div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">if</span> meth == <span class="stringliteral">&#39;nelder-mead&#39;</span>:</div>
<div class="line"><span class="lineno">  605</span>            options.setdefault(<span class="stringliteral">&#39;xatol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  606</span>            options.setdefault(<span class="stringliteral">&#39;fatol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  607</span>        <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;newton-cg&#39;</span>, <span class="stringliteral">&#39;powell&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>):</div>
<div class="line"><span class="lineno">  608</span>            options.setdefault(<span class="stringliteral">&#39;xtol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  609</span>        <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;powell&#39;</span>, <span class="stringliteral">&#39;l-bfgs-b&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>, <span class="stringliteral">&#39;slsqp&#39;</span>):</div>
<div class="line"><span class="lineno">  610</span>            options.setdefault(<span class="stringliteral">&#39;ftol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  611</span>        <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;bfgs&#39;</span>, <span class="stringliteral">&#39;cg&#39;</span>, <span class="stringliteral">&#39;l-bfgs-b&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>, <span class="stringliteral">&#39;dogleg&#39;</span>,</div>
<div class="line"><span class="lineno">  612</span>                    <span class="stringliteral">&#39;trust-ncg&#39;</span>, <span class="stringliteral">&#39;trust-exact&#39;</span>, <span class="stringliteral">&#39;trust-krylov&#39;</span>):</div>
<div class="line"><span class="lineno">  613</span>            options.setdefault(<span class="stringliteral">&#39;gtol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  614</span>        <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;cobyla&#39;</span>, <span class="stringliteral">&#39;_custom&#39;</span>):</div>
<div class="line"><span class="lineno">  615</span>            options.setdefault(<span class="stringliteral">&#39;tol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  616</span>        <span class="keywordflow">if</span> meth == <span class="stringliteral">&#39;trust-constr&#39;</span>:</div>
<div class="line"><span class="lineno">  617</span>            options.setdefault(<span class="stringliteral">&#39;xtol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  618</span>            options.setdefault(<span class="stringliteral">&#39;gtol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  619</span>            options.setdefault(<span class="stringliteral">&#39;barrier_tol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  620</span> </div>
<div class="line"><span class="lineno">  621</span>    <span class="keywordflow">if</span> meth == <span class="stringliteral">&#39;_custom&#39;</span>:</div>
<div class="line"><span class="lineno">  622</span>        <span class="comment"># custom method called before bounds and constraints are &#39;standardised&#39;</span></div>
<div class="line"><span class="lineno">  623</span>        <span class="comment"># custom method should be able to accept whatever bounds/constraints</span></div>
<div class="line"><span class="lineno">  624</span>        <span class="comment"># are provided to it.</span></div>
<div class="line"><span class="lineno">  625</span>        <span class="keywordflow">return</span> method(fun, x0, args=args, jac=jac, hess=hess, hessp=hessp,</div>
<div class="line"><span class="lineno">  626</span>                      bounds=bounds, constraints=constraints,</div>
<div class="line"><span class="lineno">  627</span>                      callback=callback, **options)</div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="line"><span class="lineno">  629</span>    constraints = standardize_constraints(constraints, x0, meth)</div>
<div class="line"><span class="lineno">  630</span> </div>
<div class="line"><span class="lineno">  631</span>    remove_vars = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">if</span> bounds <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  633</span>        <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> {<span class="stringliteral">&quot;tnc&quot;</span>, <span class="stringliteral">&quot;slsqp&quot;</span>, <span class="stringliteral">&quot;l-bfgs-b&quot;</span>}:</div>
<div class="line"><span class="lineno">  634</span>            <span class="comment"># These methods can&#39;t take the finite-difference derivatives they</span></div>
<div class="line"><span class="lineno">  635</span>            <span class="comment"># need when a variable is fixed by the bounds. To avoid this issue,</span></div>
<div class="line"><span class="lineno">  636</span>            <span class="comment"># remove fixed variables from the problem.</span></div>
<div class="line"><span class="lineno">  637</span>            <span class="comment"># NOTE: if this list is expanded, then be sure to update the</span></div>
<div class="line"><span class="lineno">  638</span>            <span class="comment"># accompanying tests and test_optimize.eb_data. Consider also if</span></div>
<div class="line"><span class="lineno">  639</span>            <span class="comment"># default OptimizeResult will need updating.</span></div>
<div class="line"><span class="lineno">  640</span> </div>
<div class="line"><span class="lineno">  641</span>            <span class="comment"># convert to new-style bounds so we only have to consider one case</span></div>
<div class="line"><span class="lineno">  642</span>            bounds = standardize_bounds(bounds, x0, <span class="stringliteral">&#39;new&#39;</span>)</div>
<div class="line"><span class="lineno">  643</span> </div>
<div class="line"><span class="lineno">  644</span>            <span class="comment"># determine whether any variables are fixed</span></div>
<div class="line"><span class="lineno">  645</span>            i_fixed = (bounds.lb == bounds.ub)</div>
<div class="line"><span class="lineno">  646</span> </div>
<div class="line"><span class="lineno">  647</span>            <span class="keywordflow">if</span> np.all(i_fixed):</div>
<div class="line"><span class="lineno">  648</span>                <span class="comment"># all the parameters are fixed, a minimizer is not able to do</span></div>
<div class="line"><span class="lineno">  649</span>                <span class="comment"># anything</span></div>
<div class="line"><span class="lineno">  650</span>                <span class="keywordflow">return</span> _optimize_result_for_equal_bounds(</div>
<div class="line"><span class="lineno">  651</span>                    fun, bounds, meth, args=args, constraints=constraints</div>
<div class="line"><span class="lineno">  652</span>                )</div>
<div class="line"><span class="lineno">  653</span> </div>
<div class="line"><span class="lineno">  654</span>            <span class="comment"># determine whether finite differences are needed for any grad/jac</span></div>
<div class="line"><span class="lineno">  655</span>            fd_needed = (<span class="keywordflow">not</span> callable(jac))</div>
<div class="line"><span class="lineno">  656</span>            <span class="keywordflow">for</span> con <span class="keywordflow">in</span> constraints:</div>
<div class="line"><span class="lineno">  657</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(con.get(<span class="stringliteral">&#39;jac&#39;</span>, <span class="keywordtype">None</span>)):</div>
<div class="line"><span class="lineno">  658</span>                    fd_needed = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  659</span> </div>
<div class="line"><span class="lineno">  660</span>            <span class="comment"># If finite differences are ever used, remove all fixed variables</span></div>
<div class="line"><span class="lineno">  661</span>            <span class="comment"># Always remove fixed variables for TNC; see gh-14565</span></div>
<div class="line"><span class="lineno">  662</span>            remove_vars = i_fixed.any() <span class="keywordflow">and</span> (fd_needed <span class="keywordflow">or</span> meth == <span class="stringliteral">&quot;tnc&quot;</span>)</div>
<div class="line"><span class="lineno">  663</span>            <span class="keywordflow">if</span> remove_vars:</div>
<div class="line"><span class="lineno">  664</span>                x_fixed = (bounds.lb)[i_fixed]</div>
<div class="line"><span class="lineno">  665</span>                x0 = x0[~i_fixed]</div>
<div class="line"><span class="lineno">  666</span>                bounds = _remove_from_bounds(bounds, i_fixed)</div>
<div class="line"><span class="lineno">  667</span>                fun = _remove_from_func(fun, i_fixed, x_fixed)</div>
<div class="line"><span class="lineno">  668</span>                <span class="keywordflow">if</span> callable(callback):</div>
<div class="line"><span class="lineno">  669</span>                    callback = _remove_from_func(callback, i_fixed, x_fixed)</div>
<div class="line"><span class="lineno">  670</span>                <span class="keywordflow">if</span> callable(jac):</div>
<div class="line"><span class="lineno">  671</span>                    jac = _remove_from_func(jac, i_fixed, x_fixed, remove=1)</div>
<div class="line"><span class="lineno">  672</span> </div>
<div class="line"><span class="lineno">  673</span>                <span class="comment"># make a copy of the constraints so the user&#39;s version doesn&#39;t</span></div>
<div class="line"><span class="lineno">  674</span>                <span class="comment"># get changed. (Shallow copy is ok)</span></div>
<div class="line"><span class="lineno">  675</span>                constraints = [con.copy() <span class="keywordflow">for</span> con <span class="keywordflow">in</span> constraints]</div>
<div class="line"><span class="lineno">  676</span>                <span class="keywordflow">for</span> con <span class="keywordflow">in</span> constraints:  <span class="comment"># yes, guaranteed to be a list</span></div>
<div class="line"><span class="lineno">  677</span>                    con[<span class="stringliteral">&#39;fun&#39;</span>] = _remove_from_func(con[<span class="stringliteral">&#39;fun&#39;</span>], i_fixed,</div>
<div class="line"><span class="lineno">  678</span>                                                   x_fixed, min_dim=1,</div>
<div class="line"><span class="lineno">  679</span>                                                   remove=0)</div>
<div class="line"><span class="lineno">  680</span>                    <span class="keywordflow">if</span> callable(con.get(<span class="stringliteral">&#39;jac&#39;</span>, <span class="keywordtype">None</span>)):</div>
<div class="line"><span class="lineno">  681</span>                        con[<span class="stringliteral">&#39;jac&#39;</span>] = _remove_from_func(con[<span class="stringliteral">&#39;jac&#39;</span>], i_fixed,</div>
<div class="line"><span class="lineno">  682</span>                                                       x_fixed, min_dim=2,</div>
<div class="line"><span class="lineno">  683</span>                                                       remove=1)</div>
<div class="line"><span class="lineno">  684</span>        bounds = standardize_bounds(bounds, x0, meth)</div>
<div class="line"><span class="lineno">  685</span> </div>
<div class="line"><span class="lineno">  686</span>    <span class="keywordflow">if</span> meth == <span class="stringliteral">&#39;nelder-mead&#39;</span>:</div>
<div class="line"><span class="lineno">  687</span>        res = _minimize_neldermead(fun, x0, args, callback, bounds=bounds,</div>
<div class="line"><span class="lineno">  688</span>                                   **options)</div>
<div class="line"><span class="lineno">  689</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;powell&#39;</span>:</div>
<div class="line"><span class="lineno">  690</span>        res = _minimize_powell(fun, x0, args, callback, bounds, **options)</div>
<div class="line"><span class="lineno">  691</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;cg&#39;</span>:</div>
<div class="line"><span class="lineno">  692</span>        res = _minimize_cg(fun, x0, args, jac, callback, **options)</div>
<div class="line"><span class="lineno">  693</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;bfgs&#39;</span>:</div>
<div class="line"><span class="lineno">  694</span>        res = _minimize_bfgs(fun, x0, args, jac, callback, **options)</div>
<div class="line"><span class="lineno">  695</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;newton-cg&#39;</span>:</div>
<div class="line"><span class="lineno">  696</span>        res = _minimize_newtoncg(fun, x0, args, jac, hess, hessp, callback,</div>
<div class="line"><span class="lineno">  697</span>                                 **options)</div>
<div class="line"><span class="lineno">  698</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;l-bfgs-b&#39;</span>:</div>
<div class="line"><span class="lineno">  699</span>        res = _minimize_lbfgsb(fun, x0, args, jac, bounds,</div>
<div class="line"><span class="lineno">  700</span>                               callback=callback, **options)</div>
<div class="line"><span class="lineno">  701</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;tnc&#39;</span>:</div>
<div class="line"><span class="lineno">  702</span>        res = _minimize_tnc(fun, x0, args, jac, bounds, callback=callback,</div>
<div class="line"><span class="lineno">  703</span>                            **options)</div>
<div class="line"><span class="lineno">  704</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;cobyla&#39;</span>:</div>
<div class="line"><span class="lineno">  705</span>        res = _minimize_cobyla(fun, x0, args, constraints, callback=callback,</div>
<div class="line"><span class="lineno">  706</span>                                **options)</div>
<div class="line"><span class="lineno">  707</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;slsqp&#39;</span>:</div>
<div class="line"><span class="lineno">  708</span>        res = _minimize_slsqp(fun, x0, args, jac, bounds,</div>
<div class="line"><span class="lineno">  709</span>                              constraints, callback=callback, **options)</div>
<div class="line"><span class="lineno">  710</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;trust-constr&#39;</span>:</div>
<div class="line"><span class="lineno">  711</span>        res = _minimize_trustregion_constr(fun, x0, args, jac, hess, hessp,</div>
<div class="line"><span class="lineno">  712</span>                                           bounds, constraints,</div>
<div class="line"><span class="lineno">  713</span>                                           callback=callback, **options)</div>
<div class="line"><span class="lineno">  714</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;dogleg&#39;</span>:</div>
<div class="line"><span class="lineno">  715</span>        res = _minimize_dogleg(fun, x0, args, jac, hess,</div>
<div class="line"><span class="lineno">  716</span>                               callback=callback, **options)</div>
<div class="line"><span class="lineno">  717</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;trust-ncg&#39;</span>:</div>
<div class="line"><span class="lineno">  718</span>        res = _minimize_trust_ncg(fun, x0, args, jac, hess, hessp,</div>
<div class="line"><span class="lineno">  719</span>                                  callback=callback, **options)</div>
<div class="line"><span class="lineno">  720</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;trust-krylov&#39;</span>:</div>
<div class="line"><span class="lineno">  721</span>        res = _minimize_trust_krylov(fun, x0, args, jac, hess, hessp,</div>
<div class="line"><span class="lineno">  722</span>                                     callback=callback, **options)</div>
<div class="line"><span class="lineno">  723</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;trust-exact&#39;</span>:</div>
<div class="line"><span class="lineno">  724</span>        res = _minimize_trustregion_exact(fun, x0, args, jac, hess,</div>
<div class="line"><span class="lineno">  725</span>                                          callback=callback, **options)</div>
<div class="line"><span class="lineno">  726</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  727</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Unknown solver %s&#39;</span> % method)</div>
<div class="line"><span class="lineno">  728</span> </div>
<div class="line"><span class="lineno">  729</span>    <span class="keywordflow">if</span> remove_vars:</div>
<div class="line"><span class="lineno">  730</span>        res.x = _add_to_array(res.x, i_fixed, x_fixed)</div>
<div class="line"><span class="lineno">  731</span>        res.jac = _add_to_array(res.jac, i_fixed, np.nan)</div>
<div class="line"><span class="lineno">  732</span>        <span class="keywordflow">if</span> <span class="stringliteral">&quot;hess_inv&quot;</span> <span class="keywordflow">in</span> res:</div>
<div class="line"><span class="lineno">  733</span>            res.hess_inv = <span class="keywordtype">None</span>  <span class="comment"># unknown</span></div>
<div class="line"><span class="lineno">  734</span> </div>
<div class="line"><span class="lineno">  735</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  736</span> </div>
<div class="line"><span class="lineno">  737</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a99cce925ddde23ddeb63140539dc3014" name="a99cce925ddde23ddeb63140539dc3014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cce925ddde23ddeb63140539dc3014">&#9670;&#160;</a></span>minimize_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize.minimize_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bracket</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'<a class="el" href="namespacescipy_1_1optimize_1_1__optimize.html#ab667dd7bd58227d18103e3e286969b71">brent</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Minimization of scalar function of one variable.

Parameters
----------
fun : callable
    Objective function.
    Scalar function, must return a scalar.
bracket : sequence, optional
    For methods 'brent' and 'golden', `bracket` defines the bracketing
    interval and can either have three items ``(a, b, c)`` so that
    ``a &lt; b &lt; c`` and ``fun(b) &lt; fun(a), fun(c)`` or two items ``a`` and
    ``c`` which are assumed to be a starting interval for a downhill
    bracket search (see `bracket`); it doesn't always mean that the
    obtained solution will satisfy ``a &lt;= x &lt;= c``.
bounds : sequence, optional
    For method 'bounded', `bounds` is mandatory and must have two items
    corresponding to the optimization bounds.
args : tuple, optional
    Extra arguments passed to the objective function.
method : str or callable, optional
    Type of solver.  Should be one of:

        - :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;`
        - :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;`
        - :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;`
        - custom - a callable object (added in version 0.14.0), see below

    See the 'Notes' section for details of each solver.

tol : float, optional
    Tolerance for termination. For detailed control, use solver-specific
    options.
options : dict, optional
    A dictionary of solver options.

        maxiter : int
            Maximum number of iterations to perform.
        disp : bool
            Set to True to print convergence messages.

    See :func:`show_options()` for solver-specific options.

Returns
-------
res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the optimizer exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes.

See also
--------
minimize : Interface to minimization algorithms for scalar multivariate
    functions
show_options : Additional options accepted by the solvers

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *Brent*.

Method :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;` uses Brent's
algorithm to find a local minimum.  The algorithm uses inverse
parabolic interpolation when possible to speed up convergence of
the golden section method.

Method :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;` uses the
golden section search technique. It uses analog of the bisection
method to decrease the bracketed interval. It is usually
preferable to use the *Brent* method.

Method :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;` can
perform bounded minimization. It uses the Brent method to find a
local minimum in the interval x1 &lt; xopt &lt; x2.

**Custom minimizers**

It may be useful to pass a custom minimization method, for example
when using some library frontend to minimize_scalar. You can simply
pass a callable as the ``method`` parameter.

The callable is called as ``method(fun, args, **kwargs, **options)``
where ``kwargs`` corresponds to any other parameters passed to `minimize`
(such as `bracket`, `tol`, etc.), except the `options` dict, which has
its contents also passed as `method` parameters pair by pair.  The method
shall return an `OptimizeResult` object.

The provided `method` callable must be able to accept (and possibly ignore)
arbitrary parameters; the set of parameters accepted by `minimize` may
expand in future versions and then these parameters will be passed to
the method. You can find an example in the scipy.optimize tutorial.

.. versionadded:: 0.11.0

Examples
--------
Consider the problem of minimizing the following function.

&gt;&gt;&gt; def f(x):
...     return (x - 2) * x * (x + 2)**2

Using the *Brent* method, we find the local minimum as:

&gt;&gt;&gt; from scipy.optimize import minimize_scalar
&gt;&gt;&gt; res = minimize_scalar(f)
&gt;&gt;&gt; res.x
1.28077640403

Using the *Bounded* method, we find a local minimum with specified
bounds as:

&gt;&gt;&gt; res = minimize_scalar(f, bounds=(-3, -1), method='bounded')
&gt;&gt;&gt; res.x
-2.0000002026</pre> <div class="fragment"><div class="line"><span class="lineno">  739</span>                    method=<span class="stringliteral">&#39;brent&#39;</span>, tol=<span class="keywordtype">None</span>, options=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  740</span>    <span class="stringliteral">&quot;&quot;&quot;Minimization of scalar function of one variable.</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    fun : callable</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        Objective function.</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        Scalar function, must return a scalar.</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    bracket : sequence, optional</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        For methods &#39;brent&#39; and &#39;golden&#39;, `bracket` defines the bracketing</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        interval and can either have three items ``(a, b, c)`` so that</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        ``a &lt; b &lt; c`` and ``fun(b) &lt; fun(a), fun(c)`` or two items ``a`` and</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        ``c`` which are assumed to be a starting interval for a downhill</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        bracket search (see `bracket`); it doesn&#39;t always mean that the</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        obtained solution will satisfy ``a &lt;= x &lt;= c``.</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    bounds : sequence, optional</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        For method &#39;bounded&#39;, `bounds` is mandatory and must have two items</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        corresponding to the optimization bounds.</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">        Extra arguments passed to the objective function.</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    method : str or callable, optional</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        Type of solver.  Should be one of:</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">            - :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;`</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">            - :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;`</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">            - :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;`</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">            - custom - a callable object (added in version 0.14.0), see below</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        See the &#39;Notes&#39; section for details of each solver.</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        Tolerance for termination. For detailed control, use solver-specific</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        options.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    options : dict, optional</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">        A dictionary of solver options.</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">            maxiter : int</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">                Maximum number of iterations to perform.</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">            disp : bool</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">                Set to True to print convergence messages.</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">        See :func:`show_options()` for solver-specific options.</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    res : OptimizeResult</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        The optimization result represented as a ``OptimizeResult`` object.</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        Important attributes are: ``x`` the solution array, ``success`` a</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        Boolean flag indicating if the optimizer exited successfully and</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        ``message`` which describes the cause of the termination. See</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">        `OptimizeResult` for a description of other attributes.</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    minimize : Interface to minimization algorithms for scalar multivariate</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        functions</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    show_options : Additional options accepted by the solvers</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    This section describes the available solvers that can be selected by the</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    &#39;method&#39; parameter. The default method is *Brent*.</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    Method :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;` uses Brent&#39;s</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    algorithm to find a local minimum.  The algorithm uses inverse</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    parabolic interpolation when possible to speed up convergence of</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    the golden section method.</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    Method :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;` uses the</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    golden section search technique. It uses analog of the bisection</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    method to decrease the bracketed interval. It is usually</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    preferable to use the *Brent* method.</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    Method :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;` can</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    perform bounded minimization. It uses the Brent method to find a</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    local minimum in the interval x1 &lt; xopt &lt; x2.</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    **Custom minimizers**</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    It may be useful to pass a custom minimization method, for example</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    when using some library frontend to minimize_scalar. You can simply</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    pass a callable as the ``method`` parameter.</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    The callable is called as ``method(fun, args, **kwargs, **options)``</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    where ``kwargs`` corresponds to any other parameters passed to `minimize`</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    (such as `bracket`, `tol`, etc.), except the `options` dict, which has</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    its contents also passed as `method` parameters pair by pair.  The method</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    shall return an `OptimizeResult` object.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    The provided `method` callable must be able to accept (and possibly ignore)</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    arbitrary parameters; the set of parameters accepted by `minimize` may</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    expand in future versions and then these parameters will be passed to</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    the method. You can find an example in the scipy.optimize tutorial.</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    Consider the problem of minimizing the following function.</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    ...     return (x - 2) * x * (x + 2)**2</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    Using the *Brent* method, we find the local minimum as:</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.optimize import minimize_scalar</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    &gt;&gt;&gt; res = minimize_scalar(f)</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    &gt;&gt;&gt; res.x</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    1.28077640403</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    Using the *Bounded* method, we find a local minimum with specified</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    bounds as:</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    &gt;&gt;&gt; res = minimize_scalar(f, bounds=(-3, -1), method=&#39;bounded&#39;)</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    &gt;&gt;&gt; res.x</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    -2.0000002026</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  857</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(args, tuple):</div>
<div class="line"><span class="lineno">  858</span>        args = (args,)</div>
<div class="line"><span class="lineno">  859</span> </div>
<div class="line"><span class="lineno">  860</span>    <span class="keywordflow">if</span> callable(method):</div>
<div class="line"><span class="lineno">  861</span>        meth = <span class="stringliteral">&quot;_custom&quot;</span></div>
<div class="line"><span class="lineno">  862</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  863</span>        meth = method.lower()</div>
<div class="line"><span class="lineno">  864</span>    <span class="keywordflow">if</span> options <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  865</span>        options = {}</div>
<div class="line"><span class="lineno">  866</span> </div>
<div class="line"><span class="lineno">  867</span>    <span class="keywordflow">if</span> tol <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  868</span>        options = dict(options)</div>
<div class="line"><span class="lineno">  869</span>        <span class="keywordflow">if</span> meth == <span class="stringliteral">&#39;bounded&#39;</span> <span class="keywordflow">and</span> <span class="stringliteral">&#39;xatol&#39;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> options:</div>
<div class="line"><span class="lineno">  870</span>            warn(<span class="stringliteral">&quot;Method &#39;bounded&#39; does not support relative tolerance in x; &quot;</span></div>
<div class="line"><span class="lineno">  871</span>                 <span class="stringliteral">&quot;defaulting to absolute tolerance.&quot;</span>, RuntimeWarning)</div>
<div class="line"><span class="lineno">  872</span>            options[<span class="stringliteral">&#39;xatol&#39;</span>] = tol</div>
<div class="line"><span class="lineno">  873</span>        <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;_custom&#39;</span>:</div>
<div class="line"><span class="lineno">  874</span>            options.setdefault(<span class="stringliteral">&#39;tol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  875</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  876</span>            options.setdefault(<span class="stringliteral">&#39;xtol&#39;</span>, tol)</div>
<div class="line"><span class="lineno">  877</span> </div>
<div class="line"><span class="lineno">  878</span>    <span class="comment"># replace boolean &quot;disp&quot; option, if specified, by an integer value.</span></div>
<div class="line"><span class="lineno">  879</span>    disp = options.get(<span class="stringliteral">&#39;disp&#39;</span>)</div>
<div class="line"><span class="lineno">  880</span>    <span class="keywordflow">if</span> isinstance(disp, bool):</div>
<div class="line"><span class="lineno">  881</span>        options[<span class="stringliteral">&#39;disp&#39;</span>] = 2 * int(disp)</div>
<div class="line"><span class="lineno">  882</span> </div>
<div class="line"><span class="lineno">  883</span>    <span class="keywordflow">if</span> meth == <span class="stringliteral">&#39;_custom&#39;</span>:</div>
<div class="line"><span class="lineno">  884</span>        <span class="keywordflow">return</span> method(fun, args=args, bracket=bracket, bounds=bounds, **options)</div>
<div class="line"><span class="lineno">  885</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;brent&#39;</span>:</div>
<div class="line"><span class="lineno">  886</span>        <span class="keywordflow">return</span> _minimize_scalar_brent(fun, bracket, args, **options)</div>
<div class="line"><span class="lineno">  887</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;bounded&#39;</span>:</div>
<div class="line"><span class="lineno">  888</span>        <span class="keywordflow">if</span> bounds <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  889</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The `bounds` parameter is mandatory for &#39;</span></div>
<div class="line"><span class="lineno">  890</span>                             <span class="stringliteral">&#39;method `bounded`.&#39;</span>)</div>
<div class="line"><span class="lineno">  891</span>        <span class="keywordflow">return</span> _minimize_scalar_bounded(fun, bounds, args, **options)</div>
<div class="line"><span class="lineno">  892</span>    <span class="keywordflow">elif</span> meth == <span class="stringliteral">&#39;golden&#39;</span>:</div>
<div class="line"><span class="lineno">  893</span>        <span class="keywordflow">return</span> _minimize_scalar_golden(fun, bracket, args, **options)</div>
<div class="line"><span class="lineno">  894</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  895</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Unknown solver %s&#39;</span> % method)</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a3aa15f3847875f0ef7241594a0ef94" name="a1a3aa15f3847875f0ef7241594a0ef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3aa15f3847875f0ef7241594a0ef94">&#9670;&#160;</a></span>standardize_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize.standardize_bounds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>meth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts bounds to the form required by the solver.</pre> <div class="fragment"><div class="line"><span class="lineno">  939</span><span class="keyword">def </span>standardize_bounds(bounds, x0, meth):</div>
<div class="line"><span class="lineno">  940</span>    <span class="stringliteral">&quot;&quot;&quot;Converts bounds to the form required by the solver.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  941</span>    <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> {<span class="stringliteral">&#39;trust-constr&#39;</span>, <span class="stringliteral">&#39;powell&#39;</span>, <span class="stringliteral">&#39;nelder-mead&#39;</span>, <span class="stringliteral">&#39;new&#39;</span>}:</div>
<div class="line"><span class="lineno">  942</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(bounds, Bounds):</div>
<div class="line"><span class="lineno">  943</span>            lb, ub = old_bound_to_new(bounds)</div>
<div class="line"><span class="lineno">  944</span>            bounds = Bounds(lb, ub)</div>
<div class="line"><span class="lineno">  945</span>    <span class="keywordflow">elif</span> meth <span class="keywordflow">in</span> (<span class="stringliteral">&#39;l-bfgs-b&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>, <span class="stringliteral">&#39;slsqp&#39;</span>, <span class="stringliteral">&#39;old&#39;</span>):</div>
<div class="line"><span class="lineno">  946</span>        <span class="keywordflow">if</span> isinstance(bounds, Bounds):</div>
<div class="line"><span class="lineno">  947</span>            bounds = new_bounds_to_old(bounds.lb, bounds.ub, x0.shape[0])</div>
<div class="line"><span class="lineno">  948</span>    <span class="keywordflow">return</span> bounds</div>
<div class="line"><span class="lineno">  949</span> </div>
<div class="line"><span class="lineno">  950</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b03ad6211c83f03d6fa01635f8d2eac" name="a7b03ad6211c83f03d6fa01635f8d2eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b03ad6211c83f03d6fa01635f8d2eac">&#9670;&#160;</a></span>standardize_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._minimize.standardize_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>meth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts constraints to the form required by the solver.</pre> <div class="fragment"><div class="line"><span class="lineno">  951</span><span class="keyword">def </span>standardize_constraints(constraints, x0, meth):</div>
<div class="line"><span class="lineno">  952</span>    <span class="stringliteral">&quot;&quot;&quot;Converts constraints to the form required by the solver.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  953</span>    all_constraint_types = (NonlinearConstraint, LinearConstraint, dict)</div>
<div class="line"><span class="lineno">  954</span>    new_constraint_types = all_constraint_types[:-1]</div>
<div class="line"><span class="lineno">  955</span>    <span class="keywordflow">if</span> constraints <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  956</span>        constraints = []</div>
<div class="line"><span class="lineno">  957</span>    <span class="keywordflow">elif</span> isinstance(constraints, all_constraint_types):</div>
<div class="line"><span class="lineno">  958</span>        constraints = [constraints]</div>
<div class="line"><span class="lineno">  959</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  960</span>        constraints = list(constraints)  <span class="comment"># ensure it&#39;s a mutable sequence</span></div>
<div class="line"><span class="lineno">  961</span> </div>
<div class="line"><span class="lineno">  962</span>    <span class="keywordflow">if</span> meth <span class="keywordflow">in</span> [<span class="stringliteral">&#39;trust-constr&#39;</span>, <span class="stringliteral">&#39;new&#39;</span>]:</div>
<div class="line"><span class="lineno">  963</span>        <span class="keywordflow">for</span> i, con <span class="keywordflow">in</span> enumerate(constraints):</div>
<div class="line"><span class="lineno">  964</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(con, new_constraint_types):</div>
<div class="line"><span class="lineno">  965</span>                constraints[i] = old_constraint_to_new(i, con)</div>
<div class="line"><span class="lineno">  966</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  967</span>        <span class="comment"># iterate over copy, changing original</span></div>
<div class="line"><span class="lineno">  968</span>        <span class="keywordflow">for</span> i, con <span class="keywordflow">in</span> enumerate(list(constraints)):</div>
<div class="line"><span class="lineno">  969</span>            <span class="keywordflow">if</span> isinstance(con, new_constraint_types):</div>
<div class="line"><span class="lineno">  970</span>                old_constraints = new_constraint_to_old(con, x0)</div>
<div class="line"><span class="lineno">  971</span>                constraints[i] = old_constraints[0]</div>
<div class="line"><span class="lineno">  972</span>                constraints.extend(old_constraints[1:])  <span class="comment"># appends 1 if present</span></div>
<div class="line"><span class="lineno">  973</span> </div>
<div class="line"><span class="lineno">  974</span>    <span class="keywordflow">return</span> constraints</div>
<div class="line"><span class="lineno">  975</span> </div>
<div class="line"><span class="lineno">  976</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5a2f9bbf136a9cf97fb9a1bdeabefe90" name="a5a2f9bbf136a9cf97fb9a1bdeabefe90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2f9bbf136a9cf97fb9a1bdeabefe90">&#9670;&#160;</a></span>MINIMIZE_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.optimize._minimize.MINIMIZE_METHODS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [<span class="stringliteral">&#39;nelder-mead&#39;</span>, <span class="stringliteral">&#39;powell&#39;</span>, <span class="stringliteral">&#39;cg&#39;</span>, <span class="stringliteral">&#39;bfgs&#39;</span>, <span class="stringliteral">&#39;newton-cg&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                    <span class="stringliteral">&#39;l-bfgs-b&#39;</span>, <span class="stringliteral">&#39;tnc&#39;</span>, <span class="stringliteral">&#39;cobyla&#39;</span>, <span class="stringliteral">&#39;slsqp&#39;</span>, <span class="stringliteral">&#39;trust-constr&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                    <span class="stringliteral">&#39;dogleg&#39;</span>, <span class="stringliteral">&#39;trust-ncg&#39;</span>, <span class="stringliteral">&#39;trust-exact&#39;</span>, <span class="stringliteral">&#39;trust-krylov&#39;</span>]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a941d7c5e6c201976a8d6eecf67084eaf" name="a941d7c5e6c201976a8d6eecf67084eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941d7c5e6c201976a8d6eecf67084eaf">&#9670;&#160;</a></span>MINIMIZE_SCALAR_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.optimize._minimize.MINIMIZE_SCALAR_METHODS = ['<a class="el" href="namespacescipy_1_1optimize_1_1__optimize.html#ab667dd7bd58227d18103e3e286969b71">brent</a>', 'bounded', '<a class="el" href="namespacescipy_1_1optimize_1_1__optimize.html#a4f74c3036679f7cddb38d24bb4ad22ee">golden</a>']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
