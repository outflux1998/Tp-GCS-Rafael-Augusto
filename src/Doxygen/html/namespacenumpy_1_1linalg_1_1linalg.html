<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.linalg.linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.linalg.linalg Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1linalg_1_1linalg_1_1_lin_alg_error.html">LinAlgError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a358192a7ade9dc95145c9ff0a23cf0fe" id="r_a358192a7ade9dc95145c9ff0a23cf0fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a358192a7ade9dc95145c9ff0a23cf0fe">_determine_error_states</a> ()</td></tr>
<tr class="separator:a358192a7ade9dc95145c9ff0a23cf0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b9be286d3992eafed65df1566ea86f" id="r_a21b9be286d3992eafed65df1566ea86f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a21b9be286d3992eafed65df1566ea86f">_raise_linalgerror_singular</a> (err, flag)</td></tr>
<tr class="separator:a21b9be286d3992eafed65df1566ea86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae09ef8c9cf44b33fc7e0fb30b1e18d5" id="r_aae09ef8c9cf44b33fc7e0fb30b1e18d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#aae09ef8c9cf44b33fc7e0fb30b1e18d5">_raise_linalgerror_nonposdef</a> (err, flag)</td></tr>
<tr class="separator:aae09ef8c9cf44b33fc7e0fb30b1e18d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04638047db002ef5529b4c4644688884" id="r_a04638047db002ef5529b4c4644688884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a04638047db002ef5529b4c4644688884">_raise_linalgerror_eigenvalues_nonconvergence</a> (err, flag)</td></tr>
<tr class="separator:a04638047db002ef5529b4c4644688884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab0cda2c2ce99553059eafe2ea83e8e" id="r_a2ab0cda2c2ce99553059eafe2ea83e8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a2ab0cda2c2ce99553059eafe2ea83e8e">_raise_linalgerror_svd_nonconvergence</a> (err, flag)</td></tr>
<tr class="separator:a2ab0cda2c2ce99553059eafe2ea83e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1874f54bee8a0f34813690f697b4758e" id="r_a1874f54bee8a0f34813690f697b4758e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a1874f54bee8a0f34813690f697b4758e">_raise_linalgerror_lstsq</a> (err, flag)</td></tr>
<tr class="separator:a1874f54bee8a0f34813690f697b4758e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236e72de3a5fc00ea907840aa243cacd" id="r_a236e72de3a5fc00ea907840aa243cacd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a236e72de3a5fc00ea907840aa243cacd">_raise_linalgerror_qr</a> (err, flag)</td></tr>
<tr class="separator:a236e72de3a5fc00ea907840aa243cacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745386a4df63f7c9f9eadc6cdbba61b3" id="r_a745386a4df63f7c9f9eadc6cdbba61b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a745386a4df63f7c9f9eadc6cdbba61b3">get_linalg_error_extobj</a> (callback)</td></tr>
<tr class="separator:a745386a4df63f7c9f9eadc6cdbba61b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247e069b47db364917838aa463f45682" id="r_a247e069b47db364917838aa463f45682"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a247e069b47db364917838aa463f45682">_makearray</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a247e069b47db364917838aa463f45682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c2894feb89ce0f8c4ffe78918bfd8d" id="r_aa7c2894feb89ce0f8c4ffe78918bfd8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#aa7c2894feb89ce0f8c4ffe78918bfd8d">isComplexType</a> (t)</td></tr>
<tr class="separator:aa7c2894feb89ce0f8c4ffe78918bfd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc34a3597be98978b9acf101d95e350a" id="r_adc34a3597be98978b9acf101d95e350a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#adc34a3597be98978b9acf101d95e350a">_realType</a> (t, default=double)</td></tr>
<tr class="separator:adc34a3597be98978b9acf101d95e350a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4351aa8ecb06a50fdea7c7d09e7e780" id="r_ab4351aa8ecb06a50fdea7c7d09e7e780"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#ab4351aa8ecb06a50fdea7c7d09e7e780">_complexType</a> (t, default=cdouble)</td></tr>
<tr class="separator:ab4351aa8ecb06a50fdea7c7d09e7e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b6396c9fa8f28c81ce6e4ad721b1c8" id="r_a90b6396c9fa8f28c81ce6e4ad721b1c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a90b6396c9fa8f28c81ce6e4ad721b1c8">_commonType</a> (*arrays)</td></tr>
<tr class="separator:a90b6396c9fa8f28c81ce6e4ad721b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc466eebf92cf7d53e8d506c942b286" id="r_a2fc466eebf92cf7d53e8d506c942b286"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a2fc466eebf92cf7d53e8d506c942b286">_to_native_byte_order</a> (*arrays)</td></tr>
<tr class="separator:a2fc466eebf92cf7d53e8d506c942b286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ec17df6593c49c1b5f39d93aad7c94" id="r_a85ec17df6593c49c1b5f39d93aad7c94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a85ec17df6593c49c1b5f39d93aad7c94">_assert_2d</a> (*arrays)</td></tr>
<tr class="separator:a85ec17df6593c49c1b5f39d93aad7c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3b0edc2306e6383fcca031968e4ee4" id="r_aeb3b0edc2306e6383fcca031968e4ee4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#aeb3b0edc2306e6383fcca031968e4ee4">_assert_stacked_2d</a> (*arrays)</td></tr>
<tr class="separator:aeb3b0edc2306e6383fcca031968e4ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3fe62c567d2ab2f95220dc74b37b49" id="r_a3b3fe62c567d2ab2f95220dc74b37b49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a3b3fe62c567d2ab2f95220dc74b37b49">_assert_stacked_square</a> (*arrays)</td></tr>
<tr class="separator:a3b3fe62c567d2ab2f95220dc74b37b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd72fcb95fd0ced580a787554edcb7" id="r_afbfd72fcb95fd0ced580a787554edcb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#afbfd72fcb95fd0ced580a787554edcb7">_assert_finite</a> (*arrays)</td></tr>
<tr class="separator:afbfd72fcb95fd0ced580a787554edcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df8b2a3e888ff6a136b0fd8d450af17" id="r_a6df8b2a3e888ff6a136b0fd8d450af17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a6df8b2a3e888ff6a136b0fd8d450af17">_is_empty_2d</a> (arr)</td></tr>
<tr class="separator:a6df8b2a3e888ff6a136b0fd8d450af17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bd7e50c24e75af531053ee81b9e755" id="r_af2bd7e50c24e75af531053ee81b9e755"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#af2bd7e50c24e75af531053ee81b9e755">transpose</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:af2bd7e50c24e75af531053ee81b9e755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d1ed67778fc2be54d435ea3520e6e2" id="r_a34d1ed67778fc2be54d435ea3520e6e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a34d1ed67778fc2be54d435ea3520e6e2">_tensorsolve_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, axes=None)</td></tr>
<tr class="separator:a34d1ed67778fc2be54d435ea3520e6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4904dfc53632855f934147ecef5e8a0" id="r_af4904dfc53632855f934147ecef5e8a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#af4904dfc53632855f934147ecef5e8a0">tensorsolve</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, axes=None)</td></tr>
<tr class="separator:af4904dfc53632855f934147ecef5e8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4398972dcef171795e676d6ab6504cbf" id="r_a4398972dcef171795e676d6ab6504cbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a4398972dcef171795e676d6ab6504cbf">_solve_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b)</td></tr>
<tr class="separator:a4398972dcef171795e676d6ab6504cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a21a52eeca46e495eb5c1d0549d35e4" id="r_a4a21a52eeca46e495eb5c1d0549d35e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a4a21a52eeca46e495eb5c1d0549d35e4">solve</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b)</td></tr>
<tr class="separator:a4a21a52eeca46e495eb5c1d0549d35e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa829102618449035b405b8e1d8eaab4f" id="r_aa829102618449035b405b8e1d8eaab4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#aa829102618449035b405b8e1d8eaab4f">_tensorinv_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, ind=None)</td></tr>
<tr class="separator:aa829102618449035b405b8e1d8eaab4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cdbc2a157ce505a12a4265ce69dda6" id="r_a05cdbc2a157ce505a12a4265ce69dda6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a05cdbc2a157ce505a12a4265ce69dda6">tensorinv</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, ind=2)</td></tr>
<tr class="separator:a05cdbc2a157ce505a12a4265ce69dda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fc8fb3809ce7a0a426237f9125d8fd" id="r_a87fc8fb3809ce7a0a426237f9125d8fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a87fc8fb3809ce7a0a426237f9125d8fd">_unary_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a87fc8fb3809ce7a0a426237f9125d8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17f2260411a13c61c0ab3f0f9396032" id="r_ab17f2260411a13c61c0ab3f0f9396032"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#ab17f2260411a13c61c0ab3f0f9396032">inv</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:ab17f2260411a13c61c0ab3f0f9396032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cab95dae929c01fe428c30312bd9108" id="r_a7cab95dae929c01fe428c30312bd9108"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a7cab95dae929c01fe428c30312bd9108">_matrix_power_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a7cab95dae929c01fe428c30312bd9108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d569ae90f74c4129df6e5980186a78" id="r_a86d569ae90f74c4129df6e5980186a78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a86d569ae90f74c4129df6e5980186a78">matrix_power</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a86d569ae90f74c4129df6e5980186a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8403bd8d4383a88fcd54bd60b6c48519" id="r_a8403bd8d4383a88fcd54bd60b6c48519"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a8403bd8d4383a88fcd54bd60b6c48519">cholesky</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a8403bd8d4383a88fcd54bd60b6c48519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c023b12d8beb6430cd553908c1ff0e1" id="r_a2c023b12d8beb6430cd553908c1ff0e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a2c023b12d8beb6430cd553908c1ff0e1">_qr_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, mode=None)</td></tr>
<tr class="separator:a2c023b12d8beb6430cd553908c1ff0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2be88b893be73b57a619b251238af5" id="r_aff2be88b893be73b57a619b251238af5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#aff2be88b893be73b57a619b251238af5">qr</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, mode='reduced')</td></tr>
<tr class="separator:aff2be88b893be73b57a619b251238af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7ac4d2bd2d2acaaaf7b0d401355e2b" id="r_aff7ac4d2bd2d2acaaaf7b0d401355e2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#aff7ac4d2bd2d2acaaaf7b0d401355e2b">eigvals</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:aff7ac4d2bd2d2acaaaf7b0d401355e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b9465ea982039a73fc3b6a64d46c6" id="r_a3b9b9465ea982039a73fc3b6a64d46c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a3b9b9465ea982039a73fc3b6a64d46c6">_eigvalsh_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, UPLO=None)</td></tr>
<tr class="separator:a3b9b9465ea982039a73fc3b6a64d46c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14126dbdd00c4414f1bfbb5b912ee503" id="r_a14126dbdd00c4414f1bfbb5b912ee503"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a14126dbdd00c4414f1bfbb5b912ee503">eigvalsh</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, UPLO='L')</td></tr>
<tr class="separator:a14126dbdd00c4414f1bfbb5b912ee503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8866544a9e20e99f2c079c95f4bb39" id="r_a8f8866544a9e20e99f2c079c95f4bb39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a8f8866544a9e20e99f2c079c95f4bb39">_convertarray</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a8f8866544a9e20e99f2c079c95f4bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3865b410b9a4d07ac35578669b34754a" id="r_a3865b410b9a4d07ac35578669b34754a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a3865b410b9a4d07ac35578669b34754a">eig</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a3865b410b9a4d07ac35578669b34754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c40172a6047b318226fe270b78a41b6" id="r_a3c40172a6047b318226fe270b78a41b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a3c40172a6047b318226fe270b78a41b6">eigh</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, UPLO='L')</td></tr>
<tr class="separator:a3c40172a6047b318226fe270b78a41b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152e68fc881be5b3c5ecd3a7fc75d611" id="r_a152e68fc881be5b3c5ecd3a7fc75d611"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a152e68fc881be5b3c5ecd3a7fc75d611">_svd_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, full_matrices=None, compute_uv=None, hermitian=None)</td></tr>
<tr class="separator:a152e68fc881be5b3c5ecd3a7fc75d611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87161c382942444130ad2df8e3c1c65" id="r_ac87161c382942444130ad2df8e3c1c65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#ac87161c382942444130ad2df8e3c1c65">svd</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, full_matrices=True, compute_uv=True, hermitian=False)</td></tr>
<tr class="separator:ac87161c382942444130ad2df8e3c1c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f0a185f531860510f6146e2ef57e7e" id="r_a63f0a185f531860510f6146e2ef57e7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a63f0a185f531860510f6146e2ef57e7e">_cond_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, p=None)</td></tr>
<tr class="separator:a63f0a185f531860510f6146e2ef57e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae06f65c5604f0296aef175cf0d9399b" id="r_aae06f65c5604f0296aef175cf0d9399b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#aae06f65c5604f0296aef175cf0d9399b">cond</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, p=None)</td></tr>
<tr class="separator:aae06f65c5604f0296aef175cf0d9399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256212e0bee45268628d8c06bfe9f574" id="r_a256212e0bee45268628d8c06bfe9f574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a256212e0bee45268628d8c06bfe9f574">_matrix_rank_dispatcher</a> (A, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=None, hermitian=None)</td></tr>
<tr class="separator:a256212e0bee45268628d8c06bfe9f574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a54f41be367169cf0a47c4057c5c27" id="r_a07a54f41be367169cf0a47c4057c5c27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a07a54f41be367169cf0a47c4057c5c27">matrix_rank</a> (A, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=None, hermitian=False)</td></tr>
<tr class="separator:a07a54f41be367169cf0a47c4057c5c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a842d8fd25a773d433abd3370e9c66" id="r_a48a842d8fd25a773d433abd3370e9c66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a48a842d8fd25a773d433abd3370e9c66">_pinv_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=None, hermitian=None)</td></tr>
<tr class="separator:a48a842d8fd25a773d433abd3370e9c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00f981974b0138052c72eefbe4eff6a" id="r_af00f981974b0138052c72eefbe4eff6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#af00f981974b0138052c72eefbe4eff6a">pinv</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=1e-15, hermitian=False)</td></tr>
<tr class="separator:af00f981974b0138052c72eefbe4eff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209de2fe316cc96d6ccd173f1bb86591" id="r_a209de2fe316cc96d6ccd173f1bb86591"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a209de2fe316cc96d6ccd173f1bb86591">slogdet</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a209de2fe316cc96d6ccd173f1bb86591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd159870d4ba793e2d0900aefbebad" id="r_abefd159870d4ba793e2d0900aefbebad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#abefd159870d4ba793e2d0900aefbebad">det</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:abefd159870d4ba793e2d0900aefbebad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98d5a3e6acab90bc77e029fe65e1fd2" id="r_ac98d5a3e6acab90bc77e029fe65e1fd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#ac98d5a3e6acab90bc77e029fe65e1fd2">_lstsq_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=None)</td></tr>
<tr class="separator:ac98d5a3e6acab90bc77e029fe65e1fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c871d4070603e5365a9ded025813da" id="r_a45c871d4070603e5365a9ded025813da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a45c871d4070603e5365a9ded025813da">lstsq</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, <a class="el" href="__lapack__subroutines_8h.html#a1d8c469c24eed45f78d0edc8ec73bc1b">rcond</a>=&quot;warn&quot;)</td></tr>
<tr class="separator:a45c871d4070603e5365a9ded025813da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c49b251309ead92384588742efd302" id="r_a78c49b251309ead92384588742efd302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a78c49b251309ead92384588742efd302">_multi_svd_norm</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, row_axis, col_axis, op)</td></tr>
<tr class="separator:a78c49b251309ead92384588742efd302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f43bd67c595551cf256686b20393651" id="r_a3f43bd67c595551cf256686b20393651"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a3f43bd67c595551cf256686b20393651">_norm_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, ord=None, axis=None, keepdims=None)</td></tr>
<tr class="separator:a3f43bd67c595551cf256686b20393651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ed0342a9f0d9562f149924eb17d591" id="r_a54ed0342a9f0d9562f149924eb17d591"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a54ed0342a9f0d9562f149924eb17d591">norm</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, ord=None, axis=None, keepdims=False)</td></tr>
<tr class="separator:a54ed0342a9f0d9562f149924eb17d591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbed473a248af4e4b4c8d3da1a89249" id="r_a4dbed473a248af4e4b4c8d3da1a89249"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a4dbed473a248af4e4b4c8d3da1a89249">_multidot_dispatcher</a> (arrays, *out=None)</td></tr>
<tr class="separator:a4dbed473a248af4e4b4c8d3da1a89249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c3416113850ed22c95bcb81b371689" id="r_a88c3416113850ed22c95bcb81b371689"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a88c3416113850ed22c95bcb81b371689">multi_dot</a> (arrays, *out=None)</td></tr>
<tr class="separator:a88c3416113850ed22c95bcb81b371689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e15d4a573f1e2f88660e1460bc2224d" id="r_a0e15d4a573f1e2f88660e1460bc2224d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a0e15d4a573f1e2f88660e1460bc2224d">_multi_dot_three</a> (A, B, C, out=None)</td></tr>
<tr class="separator:a0e15d4a573f1e2f88660e1460bc2224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc116ae6e0fb6ff3322ddee9c4628a6" id="r_acbc116ae6e0fb6ff3322ddee9c4628a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#acbc116ae6e0fb6ff3322ddee9c4628a6">_multi_dot_matrix_chain_order</a> (arrays, return_costs=False)</td></tr>
<tr class="separator:acbc116ae6e0fb6ff3322ddee9c4628a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc18df050d15bc7b75302247b6fbda20" id="r_abc18df050d15bc7b75302247b6fbda20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#abc18df050d15bc7b75302247b6fbda20">_multi_dot</a> (arrays, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, <a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>, out=None)</td></tr>
<tr class="separator:abc18df050d15bc7b75302247b6fbda20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acbaf0497d21f2a1a0cce4283e9b33791" id="r_acbaf0497d21f2a1a0cce4283e9b33791"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#acbaf0497d21f2a1a0cce4283e9b33791">array_function_dispatch</a></td></tr>
<tr class="separator:acbaf0497d21f2a1a0cce4283e9b33791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5b13c1ab5625fec5215d3a9b5e16ce" id="r_a3b5b13c1ab5625fec5215d3a9b5e16ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a3b5b13c1ab5625fec5215d3a9b5e16ce">fortran_int</a> = intc</td></tr>
<tr class="separator:a3b5b13c1ab5625fec5215d3a9b5e16ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eacc11c4a69383222b25cd70ffecd3" id="r_a68eacc11c4a69383222b25cd70ffecd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a68eacc11c4a69383222b25cd70ffecd3">_linalg_error_extobj</a> = <a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a358192a7ade9dc95145c9ff0a23cf0fe">_determine_error_states</a>()</td></tr>
<tr class="separator:a68eacc11c4a69383222b25cd70ffecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd9ba979a8aab5ef704105f77ac77c4" id="r_afcd9ba979a8aab5ef704105f77ac77c4"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#afcd9ba979a8aab5ef704105f77ac77c4">_real_types_map</a></td></tr>
<tr class="separator:afcd9ba979a8aab5ef704105f77ac77c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2229168993a702c198ddbb01a8030d9" id="r_af2229168993a702c198ddbb01a8030d9"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#af2229168993a702c198ddbb01a8030d9">_complex_types_map</a></td></tr>
<tr class="separator:af2229168993a702c198ddbb01a8030d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Lite version of scipy.linalg.

Notes
-----
This module is a lite version of the linalg.py module in SciPy which
contains high-level Python interface to the LAPACK library.  The lite
version only accesses the following LAPACK functions: dgesv, zgesv,
dgeev, zgeev, dgesdd, zgesdd, dgelsd, zgelsd, dsyevd, zheevd, dgetrf,
zgetrf, dpotrf, zpotrf, dgeqrf, zgeqrf, zungqr, dorgqr.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a85ec17df6593c49c1b5f39d93aad7c94" name="a85ec17df6593c49c1b5f39d93aad7c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ec17df6593c49c1b5f39d93aad7c94">&#9670;&#160;</a></span>_assert_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._assert_2d </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  174</span><span class="keyword">def </span>_assert_2d(*arrays):</div>
<div class="line"><span class="lineno">  175</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno">  176</span>        <span class="keywordflow">if</span> a.ndim != 2:</div>
<div class="line"><span class="lineno">  177</span>            <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&#39;%d-dimensional array given. Array must be &#39;</span></div>
<div class="line"><span class="lineno">  178</span>                    <span class="stringliteral">&#39;two-dimensional&#39;</span> % a.ndim)</div>
<div class="line"><span class="lineno">  179</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afbfd72fcb95fd0ced580a787554edcb7" name="afbfd72fcb95fd0ced580a787554edcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfd72fcb95fd0ced580a787554edcb7">&#9670;&#160;</a></span>_assert_finite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._assert_finite </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  192</span><span class="keyword">def </span>_assert_finite(*arrays):</div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno">  194</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isfinite(a).all():</div>
<div class="line"><span class="lineno">  195</span>            <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Array must not contain infs or NaNs&quot;</span>)</div>
<div class="line"><span class="lineno">  196</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb3b0edc2306e6383fcca031968e4ee4" name="aeb3b0edc2306e6383fcca031968e4ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3b0edc2306e6383fcca031968e4ee4">&#9670;&#160;</a></span>_assert_stacked_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._assert_stacked_2d </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  180</span><span class="keyword">def </span>_assert_stacked_2d(*arrays):</div>
<div class="line"><span class="lineno">  181</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno">  182</span>        <span class="keywordflow">if</span> a.ndim &lt; 2:</div>
<div class="line"><span class="lineno">  183</span>            <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&#39;%d-dimensional array given. Array must be &#39;</span></div>
<div class="line"><span class="lineno">  184</span>                    <span class="stringliteral">&#39;at least two-dimensional&#39;</span> % a.ndim)</div>
<div class="line"><span class="lineno">  185</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b3fe62c567d2ab2f95220dc74b37b49" name="a3b3fe62c567d2ab2f95220dc74b37b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3fe62c567d2ab2f95220dc74b37b49">&#9670;&#160;</a></span>_assert_stacked_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._assert_stacked_square </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  186</span><span class="keyword">def </span>_assert_stacked_square(*arrays):</div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno">  188</span>        m, n = a.shape[-2:]</div>
<div class="line"><span class="lineno">  189</span>        <span class="keywordflow">if</span> m != n:</div>
<div class="line"><span class="lineno">  190</span>            <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&#39;Last 2 dimensions of the array must be square&#39;</span>)</div>
<div class="line"><span class="lineno">  191</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a90b6396c9fa8f28c81ce6e4ad721b1c8" name="a90b6396c9fa8f28c81ce6e4ad721b1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b6396c9fa8f28c81ce6e4ad721b1c8">&#9670;&#160;</a></span>_commonType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._commonType </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  136</span><span class="keyword">def </span>_commonType(*arrays):</div>
<div class="line"><span class="lineno">  137</span>    <span class="comment"># in lite version, use higher precision (always double or cdouble)</span></div>
<div class="line"><span class="lineno">  138</span>    result_type = single</div>
<div class="line"><span class="lineno">  139</span>    is_complex = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordflow">if</span> issubclass(a.dtype.type, inexact):</div>
<div class="line"><span class="lineno">  142</span>            <span class="keywordflow">if</span> isComplexType(a.dtype.type):</div>
<div class="line"><span class="lineno">  143</span>                is_complex = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  144</span>            rt = _realType(a.dtype.type, default=<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  145</span>            <span class="keywordflow">if</span> rt <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  146</span>                <span class="comment"># unsupported inexact scalar</span></div>
<div class="line"><span class="lineno">  147</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;array type %s is unsupported in linalg&quot;</span> %</div>
<div class="line"><span class="lineno">  148</span>                        (a.dtype.name,))</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  150</span>            rt = double</div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">if</span> rt <span class="keywordflow">is</span> double:</div>
<div class="line"><span class="lineno">  152</span>            result_type = double</div>
<div class="line"><span class="lineno">  153</span>    <span class="keywordflow">if</span> is_complex:</div>
<div class="line"><span class="lineno">  154</span>        t = cdouble</div>
<div class="line"><span class="lineno">  155</span>        result_type = _complex_types_map[result_type]</div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  157</span>        t = double</div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">return</span> t, result_type</div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4351aa8ecb06a50fdea7c7d09e7e780" name="ab4351aa8ecb06a50fdea7c7d09e7e780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4351aa8ecb06a50fdea7c7d09e7e780">&#9670;&#160;</a></span>_complexType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._complexType </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>cdouble</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  133</span><span class="keyword">def </span>_complexType(t, default=cdouble):</div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordflow">return</span> _complex_types_map.get(t, default)</div>
<div class="line"><span class="lineno">  135</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a63f0a185f531860510f6146e2ef57e7e" name="a63f0a185f531860510f6146e2ef57e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f0a185f531860510f6146e2ef57e7e">&#9670;&#160;</a></span>_cond_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._cond_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1659</span><span class="keyword">def </span>_cond_dispatcher(x, p=None):</div>
<div class="line"><span class="lineno"> 1660</span>    <span class="keywordflow">return</span> (x,)</div>
<div class="line"><span class="lineno"> 1661</span> </div>
<div class="line"><span class="lineno"> 1662</span> </div>
<div class="line"><span class="lineno"> 1663</span><span class="preprocessor">@array_function_dispatch(_cond_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f8866544a9e20e99f2c079c95f4bb39" name="a8f8866544a9e20e99f2c079c95f4bb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8866544a9e20e99f2c079c95f4bb39">&#9670;&#160;</a></span>_convertarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._convertarray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1159</span><span class="keyword">def </span>_convertarray(a):</div>
<div class="line"><span class="lineno"> 1160</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 1161</span>    a = a.astype(t).T.copy()</div>
<div class="line"><span class="lineno"> 1162</span>    <span class="keywordflow">return</span> a, t, result_t</div>
<div class="line"><span class="lineno"> 1163</span> </div>
<div class="line"><span class="lineno"> 1164</span> </div>
<div class="line"><span class="lineno"> 1165</span><span class="comment"># Eigenvectors</span></div>
<div class="line"><span class="lineno"> 1166</span> </div>
<div class="line"><span class="lineno"> 1167</span> </div>
<div class="line"><span class="lineno"> 1168</span><span class="preprocessor">@array_function_dispatch(_unary_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a358192a7ade9dc95145c9ff0a23cf0fe" name="a358192a7ade9dc95145c9ff0a23cf0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358192a7ade9dc95145c9ff0a23cf0fe">&#9670;&#160;</a></span>_determine_error_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._determine_error_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   74</span><span class="keyword">def </span>_determine_error_states():</div>
<div class="line"><span class="lineno">   75</span>    errobj = geterrobj()</div>
<div class="line"><span class="lineno">   76</span>    bufsize = errobj[0]</div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span>    <span class="keyword">with</span> errstate(invalid=<span class="stringliteral">&#39;call&#39;</span>, over=<span class="stringliteral">&#39;ignore&#39;</span>,</div>
<div class="line"><span class="lineno">   79</span>                  divide=<span class="stringliteral">&#39;ignore&#39;</span>, under=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno">   80</span>        invalid_call_errmask = geterrobj()[1]</div>
<div class="line"><span class="lineno">   81</span> </div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">return</span> [bufsize, invalid_call_errmask, <span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span><span class="comment"># Dealing with errors in _umath_linalg</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b9b9465ea982039a73fc3b6a64d46c6" name="a3b9b9465ea982039a73fc3b6a64d46c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9b9465ea982039a73fc3b6a64d46c6">&#9670;&#160;</a></span>_eigvalsh_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._eigvalsh_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>UPLO</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1061</span><span class="keyword">def </span>_eigvalsh_dispatcher(a, UPLO=None):</div>
<div class="line"><span class="lineno"> 1062</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1063</span> </div>
<div class="line"><span class="lineno"> 1064</span> </div>
<div class="line"><span class="lineno"> 1065</span><span class="preprocessor">@array_function_dispatch(_eigvalsh_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6df8b2a3e888ff6a136b0fd8d450af17" name="a6df8b2a3e888ff6a136b0fd8d450af17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df8b2a3e888ff6a136b0fd8d450af17">&#9670;&#160;</a></span>_is_empty_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._is_empty_2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  197</span><span class="keyword">def </span>_is_empty_2d(arr):</div>
<div class="line"><span class="lineno">  198</span>    <span class="comment"># check size first for efficiency</span></div>
<div class="line"><span class="lineno">  199</span>    <span class="keywordflow">return</span> arr.size == 0 <span class="keywordflow">and</span> product(arr.shape[-2:]) == 0</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac98d5a3e6acab90bc77e029fe65e1fd2" name="ac98d5a3e6acab90bc77e029fe65e1fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98d5a3e6acab90bc77e029fe65e1fd2">&#9670;&#160;</a></span>_lstsq_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._lstsq_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2146</span><span class="keyword">def </span>_lstsq_dispatcher(a, b, rcond=None):</div>
<div class="line"><span class="lineno"> 2147</span>    <span class="keywordflow">return</span> (a, b)</div>
<div class="line"><span class="lineno"> 2148</span> </div>
<div class="line"><span class="lineno"> 2149</span> </div>
<div class="line"><span class="lineno"> 2150</span><span class="preprocessor">@array_function_dispatch(_lstsq_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a247e069b47db364917838aa463f45682" name="a247e069b47db364917838aa463f45682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247e069b47db364917838aa463f45682">&#9670;&#160;</a></span>_makearray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._makearray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  112</span><span class="keyword">def </span>_makearray(a):</div>
<div class="line"><span class="lineno">  113</span>    new = asarray(a)</div>
<div class="line"><span class="lineno">  114</span>    wrap = getattr(a, <span class="stringliteral">&quot;__array_prepare__&quot;</span>, new.__array_wrap__)</div>
<div class="line"><span class="lineno">  115</span>    <span class="keywordflow">return</span> new, wrap</div>
<div class="line"><span class="lineno">  116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cab95dae929c01fe428c30312bd9108" name="a7cab95dae929c01fe428c30312bd9108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cab95dae929c01fe428c30312bd9108">&#9670;&#160;</a></span>_matrix_power_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._matrix_power_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  542</span><span class="keyword">def </span>_matrix_power_dispatcher(a, n):</div>
<div class="line"><span class="lineno">  543</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span> </div>
<div class="line"><span class="lineno">  546</span><span class="preprocessor">@array_function_dispatch(_matrix_power_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a256212e0bee45268628d8c06bfe9f574" name="a256212e0bee45268628d8c06bfe9f574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256212e0bee45268628d8c06bfe9f574">&#9670;&#160;</a></span>_matrix_rank_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._matrix_rank_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hermitian</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1782</span><span class="keyword">def </span>_matrix_rank_dispatcher(A, tol=None, hermitian=None):</div>
<div class="line"><span class="lineno"> 1783</span>    <span class="keywordflow">return</span> (A,)</div>
<div class="line"><span class="lineno"> 1784</span> </div>
<div class="line"><span class="lineno"> 1785</span> </div>
<div class="line"><span class="lineno"> 1786</span><span class="preprocessor">@array_function_dispatch(_matrix_rank_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abc18df050d15bc7b75302247b6fbda20" name="abc18df050d15bc7b75302247b6fbda20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc18df050d15bc7b75302247b6fbda20">&#9670;&#160;</a></span>_multi_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._multi_dot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Actually do the multiplication with the given order.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2785</span><span class="keyword">def </span>_multi_dot(arrays, order, i, j, out=None):</div>
<div class="line"><span class="lineno"> 2786</span>    <span class="stringliteral">&quot;&quot;&quot;Actually do the multiplication with the given order.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2787</span>    <span class="keywordflow">if</span> i == j:</div>
<div class="line"><span class="lineno"> 2788</span>        <span class="comment"># the initial call with non-None out should never get here</span></div>
<div class="line"><span class="lineno"> 2789</span>        <span class="keyword">assert</span> out <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2790</span> </div>
<div class="line"><span class="lineno"> 2791</span>        <span class="keywordflow">return</span> arrays[i]</div>
<div class="line"><span class="lineno"> 2792</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2793</span>        <span class="keywordflow">return</span> dot(_multi_dot(arrays, order, i, order[i, j]),</div>
<div class="line"><span class="lineno"> 2794</span>                   _multi_dot(arrays, order, order[i, j] + 1, j),</div>
<div class="line"><span class="lineno"> 2795</span>                   out=out)</div>
</div><!-- fragment -->
</div>
</div>
<a id="acbc116ae6e0fb6ff3322ddee9c4628a6" name="acbc116ae6e0fb6ff3322ddee9c4628a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc116ae6e0fb6ff3322ddee9c4628a6">&#9670;&#160;</a></span>_multi_dot_matrix_chain_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._multi_dot_matrix_chain_order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_costs</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a np.array that encodes the optimal order of mutiplications.

The optimal order array is then used by `_multi_dot()` to do the
multiplication.

Also return the cost matrix if `return_costs` is `True`

The implementation CLOSELY follows Cormen, "Introduction to Algorithms",
Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.

    cost[i, j] = min([
        cost[prefix] + cost[suffix] + cost_mult(prefix, suffix)
        for k in range(i, j)])</pre> <div class="fragment"><div class="line"><span class="lineno"> 2744</span><span class="keyword">def </span>_multi_dot_matrix_chain_order(arrays, return_costs=False):</div>
<div class="line"><span class="lineno"> 2745</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral">    Return a np.array that encodes the optimal order of mutiplications.</span></div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral">    The optimal order array is then used by `_multi_dot()` to do the</span></div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">    multiplication.</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2751</span><span class="stringliteral">    Also return the cost matrix if `return_costs` is `True`</span></div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral">    The implementation CLOSELY follows Cormen, &quot;Introduction to Algorithms&quot;,</span></div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral">    Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.</span></div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2756</span><span class="stringliteral">        cost[i, j] = min([</span></div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">            cost[prefix] + cost[suffix] + cost_mult(prefix, suffix)</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral">            for k in range(i, j)])</span></div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2760</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2761</span>    n = len(arrays)</div>
<div class="line"><span class="lineno"> 2762</span>    <span class="comment"># p stores the dimensions of the matrices</span></div>
<div class="line"><span class="lineno"> 2763</span>    <span class="comment"># Example for p: A_{10x100}, B_{100x5}, C_{5x50} --&gt; p = [10, 100, 5, 50]</span></div>
<div class="line"><span class="lineno"> 2764</span>    p = [a.shape[0] <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays] + [arrays[-1].shape[1]]</div>
<div class="line"><span class="lineno"> 2765</span>    <span class="comment"># m is a matrix of costs of the subproblems</span></div>
<div class="line"><span class="lineno"> 2766</span>    <span class="comment"># m[i,j]: min number of scalar multiplications needed to compute A_{i..j}</span></div>
<div class="line"><span class="lineno"> 2767</span>    m = zeros((n, n), dtype=double)</div>
<div class="line"><span class="lineno"> 2768</span>    <span class="comment"># s is the actual ordering</span></div>
<div class="line"><span class="lineno"> 2769</span>    <span class="comment"># s[i, j] is the value of k at which we split the product A_i..A_j</span></div>
<div class="line"><span class="lineno"> 2770</span>    s = empty((n, n), dtype=intp)</div>
<div class="line"><span class="lineno"> 2771</span> </div>
<div class="line"><span class="lineno"> 2772</span>    <span class="keywordflow">for</span> l <span class="keywordflow">in</span> range(1, n):</div>
<div class="line"><span class="lineno"> 2773</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n - l):</div>
<div class="line"><span class="lineno"> 2774</span>            j = i + l</div>
<div class="line"><span class="lineno"> 2775</span>            m[i, j] = Inf</div>
<div class="line"><span class="lineno"> 2776</span>            <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(i, j):</div>
<div class="line"><span class="lineno"> 2777</span>                q = m[i, k] + m[k+1, j] + p[i]*p[k+1]*p[j+1]</div>
<div class="line"><span class="lineno"> 2778</span>                <span class="keywordflow">if</span> q &lt; m[i, j]:</div>
<div class="line"><span class="lineno"> 2779</span>                    m[i, j] = q</div>
<div class="line"><span class="lineno"> 2780</span>                    s[i, j] = k  <span class="comment"># Note that Cormen uses 1-based index</span></div>
<div class="line"><span class="lineno"> 2781</span> </div>
<div class="line"><span class="lineno"> 2782</span>    <span class="keywordflow">return</span> (s, m) <span class="keywordflow">if</span> return_costs <span class="keywordflow">else</span> s</div>
<div class="line"><span class="lineno"> 2783</span> </div>
<div class="line"><span class="lineno"> 2784</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e15d4a573f1e2f88660e1460bc2224d" name="a0e15d4a573f1e2f88660e1460bc2224d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e15d4a573f1e2f88660e1460bc2224d">&#9670;&#160;</a></span>_multi_dot_three()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._multi_dot_three </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Find the best order for three arrays and do the multiplication.

For three arguments `_multi_dot_three` is approximately 15 times faster
than `_multi_dot_matrix_chain_order`</pre> <div class="fragment"><div class="line"><span class="lineno"> 2723</span><span class="keyword">def </span>_multi_dot_three(A, B, C, out=None):</div>
<div class="line"><span class="lineno"> 2724</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral">    Find the best order for three arrays and do the multiplication.</span></div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral">    For three arguments `_multi_dot_three` is approximately 15 times faster</span></div>
<div class="line"><span class="lineno"> 2728</span><span class="stringliteral">    than `_multi_dot_matrix_chain_order`</span></div>
<div class="line"><span class="lineno"> 2729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2730</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2731</span>    a0, a1b0 = A.shape</div>
<div class="line"><span class="lineno"> 2732</span>    b1c0, c1 = C.shape</div>
<div class="line"><span class="lineno"> 2733</span>    <span class="comment"># cost1 = cost((AB)C) = a0*a1b0*b1c0 + a0*b1c0*c1</span></div>
<div class="line"><span class="lineno"> 2734</span>    cost1 = a0 * b1c0 * (a1b0 + c1)</div>
<div class="line"><span class="lineno"> 2735</span>    <span class="comment"># cost2 = cost(A(BC)) = a1b0*b1c0*c1 + a0*a1b0*c1</span></div>
<div class="line"><span class="lineno"> 2736</span>    cost2 = a1b0 * c1 * (a0 + b1c0)</div>
<div class="line"><span class="lineno"> 2737</span> </div>
<div class="line"><span class="lineno"> 2738</span>    <span class="keywordflow">if</span> cost1 &lt; cost2:</div>
<div class="line"><span class="lineno"> 2739</span>        <span class="keywordflow">return</span> dot(dot(A, B), C, out=out)</div>
<div class="line"><span class="lineno"> 2740</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2741</span>        <span class="keywordflow">return</span> dot(A, dot(B, C), out=out)</div>
<div class="line"><span class="lineno"> 2742</span> </div>
<div class="line"><span class="lineno"> 2743</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a78c49b251309ead92384588742efd302" name="a78c49b251309ead92384588742efd302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c49b251309ead92384588742efd302">&#9670;&#160;</a></span>_multi_svd_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._multi_svd_norm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>row_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>col_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a function of the singular values of the 2-D matrices in `x`.

This is a private utility function used by `numpy.linalg.norm()`.

Parameters
----------
x : ndarray
row_axis, col_axis : int
    The axes of `x` that hold the 2-D matrices.
op : callable
    This should be either numpy.amin or `numpy.amax` or `numpy.sum`.

Returns
-------
result : float or ndarray
    If `x` is 2-D, the return values is a float.
    Otherwise, it is an array with ``x.ndim - 2`` dimensions.
    The return values are either the minimum or maximum or sum of the
    singular values of the matrices, depending on whether `op`
    is `numpy.amin` or `numpy.amax` or `numpy.sum`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2310</span><span class="keyword">def </span>_multi_svd_norm(x, row_axis, col_axis, op):</div>
<div class="line"><span class="lineno"> 2311</span>    <span class="stringliteral">&quot;&quot;&quot;Compute a function of the singular values of the 2-D matrices in `x`.</span></div>
<div class="line"><span class="lineno"> 2312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2313</span><span class="stringliteral">    This is a private utility function used by `numpy.linalg.norm()`.</span></div>
<div class="line"><span class="lineno"> 2314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2315</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2316</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2317</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno"> 2318</span><span class="stringliteral">    row_axis, col_axis : int</span></div>
<div class="line"><span class="lineno"> 2319</span><span class="stringliteral">        The axes of `x` that hold the 2-D matrices.</span></div>
<div class="line"><span class="lineno"> 2320</span><span class="stringliteral">    op : callable</span></div>
<div class="line"><span class="lineno"> 2321</span><span class="stringliteral">        This should be either numpy.amin or `numpy.amax` or `numpy.sum`.</span></div>
<div class="line"><span class="lineno"> 2322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2323</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2324</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2325</span><span class="stringliteral">    result : float or ndarray</span></div>
<div class="line"><span class="lineno"> 2326</span><span class="stringliteral">        If `x` is 2-D, the return values is a float.</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral">        Otherwise, it is an array with ``x.ndim - 2`` dimensions.</span></div>
<div class="line"><span class="lineno"> 2328</span><span class="stringliteral">        The return values are either the minimum or maximum or sum of the</span></div>
<div class="line"><span class="lineno"> 2329</span><span class="stringliteral">        singular values of the matrices, depending on whether `op`</span></div>
<div class="line"><span class="lineno"> 2330</span><span class="stringliteral">        is `numpy.amin` or `numpy.amax` or `numpy.sum`.</span></div>
<div class="line"><span class="lineno"> 2331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2332</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2333</span>    y = moveaxis(x, (row_axis, col_axis), (-2, -1))</div>
<div class="line"><span class="lineno"> 2334</span>    result = op(svd(y, compute_uv=<span class="keyword">False</span>), axis=-1)</div>
<div class="line"><span class="lineno"> 2335</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 2336</span> </div>
<div class="line"><span class="lineno"> 2337</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4dbed473a248af4e4b4c8d3da1a89249" name="a4dbed473a248af4e4b4c8d3da1a89249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbed473a248af4e4b4c8d3da1a89249">&#9670;&#160;</a></span>_multidot_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._multidot_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2597</span><span class="keyword">def </span>_multidot_dispatcher(arrays, *, out=None):</div>
<div class="line"><span class="lineno"> 2598</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> arrays</div>
<div class="line"><span class="lineno"> 2599</span>    <span class="keywordflow">yield</span> out</div>
<div class="line"><span class="lineno"> 2600</span> </div>
<div class="line"><span class="lineno"> 2601</span> </div>
<div class="line"><span class="lineno"> 2602</span><span class="preprocessor">@array_function_dispatch(_multidot_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f43bd67c595551cf256686b20393651" name="a3f43bd67c595551cf256686b20393651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f43bd67c595551cf256686b20393651">&#9670;&#160;</a></span>_norm_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._norm_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ord</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2338</span><span class="keyword">def </span>_norm_dispatcher(x, ord=None, axis=None, keepdims=None):</div>
<div class="line"><span class="lineno"> 2339</span>    <span class="keywordflow">return</span> (x,)</div>
<div class="line"><span class="lineno"> 2340</span> </div>
<div class="line"><span class="lineno"> 2341</span> </div>
<div class="line"><span class="lineno"> 2342</span><span class="preprocessor">@array_function_dispatch(_norm_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a48a842d8fd25a773d433abd3370e9c66" name="a48a842d8fd25a773d433abd3370e9c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a842d8fd25a773d433abd3370e9c66">&#9670;&#160;</a></span>_pinv_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._pinv_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hermitian</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1893</span><span class="keyword">def </span>_pinv_dispatcher(a, rcond=None, hermitian=None):</div>
<div class="line"><span class="lineno"> 1894</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1895</span> </div>
<div class="line"><span class="lineno"> 1896</span> </div>
<div class="line"><span class="lineno"> 1897</span><span class="preprocessor">@array_function_dispatch(_pinv_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c023b12d8beb6430cd553908c1ff0e1" name="a2c023b12d8beb6430cd553908c1ff0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c023b12d8beb6430cd553908c1ff0e1">&#9670;&#160;</a></span>_qr_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._qr_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  762</span><span class="keyword">def </span>_qr_dispatcher(a, mode=None):</div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span> </div>
<div class="line"><span class="lineno">  766</span><span class="preprocessor">@array_function_dispatch(_qr_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a04638047db002ef5529b4c4644688884" name="a04638047db002ef5529b4c4644688884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04638047db002ef5529b4c4644688884">&#9670;&#160;</a></span>_raise_linalgerror_eigenvalues_nonconvergence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._raise_linalgerror_eigenvalues_nonconvergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   94</span><span class="keyword">def </span>_raise_linalgerror_eigenvalues_nonconvergence(err, flag):</div>
<div class="line"><span class="lineno">   95</span>    <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Eigenvalues did not converge&quot;</span>)</div>
<div class="line"><span class="lineno">   96</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1874f54bee8a0f34813690f697b4758e" name="a1874f54bee8a0f34813690f697b4758e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1874f54bee8a0f34813690f697b4758e">&#9670;&#160;</a></span>_raise_linalgerror_lstsq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._raise_linalgerror_lstsq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  100</span><span class="keyword">def </span>_raise_linalgerror_lstsq(err, flag):</div>
<div class="line"><span class="lineno">  101</span>    <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;SVD did not converge in Linear Least Squares&quot;</span>)</div>
<div class="line"><span class="lineno">  102</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae09ef8c9cf44b33fc7e0fb30b1e18d5" name="aae09ef8c9cf44b33fc7e0fb30b1e18d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae09ef8c9cf44b33fc7e0fb30b1e18d5">&#9670;&#160;</a></span>_raise_linalgerror_nonposdef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._raise_linalgerror_nonposdef </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   91</span><span class="keyword">def </span>_raise_linalgerror_nonposdef(err, flag):</div>
<div class="line"><span class="lineno">   92</span>    <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Matrix is not positive definite&quot;</span>)</div>
<div class="line"><span class="lineno">   93</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a236e72de3a5fc00ea907840aa243cacd" name="a236e72de3a5fc00ea907840aa243cacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236e72de3a5fc00ea907840aa243cacd">&#9670;&#160;</a></span>_raise_linalgerror_qr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._raise_linalgerror_qr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  103</span><span class="keyword">def </span>_raise_linalgerror_qr(err, flag):</div>
<div class="line"><span class="lineno">  104</span>    <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Incorrect argument found while performing &quot;</span></div>
<div class="line"><span class="lineno">  105</span>                      <span class="stringliteral">&quot;QR factorization&quot;</span>)</div>
<div class="line"><span class="lineno">  106</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a21b9be286d3992eafed65df1566ea86f" name="a21b9be286d3992eafed65df1566ea86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b9be286d3992eafed65df1566ea86f">&#9670;&#160;</a></span>_raise_linalgerror_singular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._raise_linalgerror_singular </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   88</span><span class="keyword">def </span>_raise_linalgerror_singular(err, flag):</div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Singular matrix&quot;</span>)</div>
<div class="line"><span class="lineno">   90</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ab0cda2c2ce99553059eafe2ea83e8e" name="a2ab0cda2c2ce99553059eafe2ea83e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab0cda2c2ce99553059eafe2ea83e8e">&#9670;&#160;</a></span>_raise_linalgerror_svd_nonconvergence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._raise_linalgerror_svd_nonconvergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   97</span><span class="keyword">def </span>_raise_linalgerror_svd_nonconvergence(err, flag):</div>
<div class="line"><span class="lineno">   98</span>    <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;SVD did not converge&quot;</span>)</div>
<div class="line"><span class="lineno">   99</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adc34a3597be98978b9acf101d95e350a" name="adc34a3597be98978b9acf101d95e350a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc34a3597be98978b9acf101d95e350a">&#9670;&#160;</a></span>_realType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._realType </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>double</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  130</span><span class="keyword">def </span>_realType(t, default=double):</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">return</span> _real_types_map.get(t, default)</div>
<div class="line"><span class="lineno">  132</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4398972dcef171795e676d6ab6504cbf" name="a4398972dcef171795e676d6ab6504cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4398972dcef171795e676d6ab6504cbf">&#9670;&#160;</a></span>_solve_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._solve_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  302</span><span class="keyword">def </span>_solve_dispatcher(a, b):</div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">return</span> (a, b)</div>
<div class="line"><span class="lineno">  304</span> </div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span><span class="preprocessor">@array_function_dispatch(_solve_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a152e68fc881be5b3c5ecd3a7fc75d611" name="a152e68fc881be5b3c5ecd3a7fc75d611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152e68fc881be5b3c5ecd3a7fc75d611">&#9670;&#160;</a></span>_svd_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._svd_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_matrices</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_uv</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hermitian</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1459</span><span class="keyword">def </span>_svd_dispatcher(a, full_matrices=None, compute_uv=None, hermitian=None):</div>
<div class="line"><span class="lineno"> 1460</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1461</span> </div>
<div class="line"><span class="lineno"> 1462</span> </div>
<div class="line"><span class="lineno"> 1463</span><span class="preprocessor">@array_function_dispatch(_svd_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa829102618449035b405b8e1d8eaab4f" name="aa829102618449035b405b8e1d8eaab4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa829102618449035b405b8e1d8eaab4f">&#9670;&#160;</a></span>_tensorinv_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._tensorinv_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  391</span><span class="keyword">def </span>_tensorinv_dispatcher(a, ind=None):</div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  393</span> </div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span><span class="preprocessor">@array_function_dispatch(_tensorinv_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a34d1ed67778fc2be54d435ea3520e6e2" name="a34d1ed67778fc2be54d435ea3520e6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d1ed67778fc2be54d435ea3520e6e2">&#9670;&#160;</a></span>_tensorsolve_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._tensorsolve_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  221</span><span class="keyword">def </span>_tensorsolve_dispatcher(a, b, axes=None):</div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">return</span> (a, b)</div>
<div class="line"><span class="lineno">  223</span> </div>
<div class="line"><span class="lineno">  224</span> </div>
<div class="line"><span class="lineno">  225</span><span class="preprocessor">@array_function_dispatch(_tensorsolve_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fc466eebf92cf7d53e8d506c942b286" name="a2fc466eebf92cf7d53e8d506c942b286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc466eebf92cf7d53e8d506c942b286">&#9670;&#160;</a></span>_to_native_byte_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._to_native_byte_order </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  161</span><span class="keyword">def </span>_to_native_byte_order(*arrays):</div>
<div class="line"><span class="lineno">  162</span>    ret = []</div>
<div class="line"><span class="lineno">  163</span>    <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno">  164</span>        <span class="keywordflow">if</span> arr.dtype.byteorder <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;=&#39;</span>, <span class="stringliteral">&#39;|&#39;</span>):</div>
<div class="line"><span class="lineno">  165</span>            ret.append(asarray(arr, dtype=arr.dtype.newbyteorder(<span class="stringliteral">&#39;=&#39;</span>)))</div>
<div class="line"><span class="lineno">  166</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  167</span>            ret.append(arr)</div>
<div class="line"><span class="lineno">  168</span>    <span class="keywordflow">if</span> len(ret) == 1:</div>
<div class="line"><span class="lineno">  169</span>        <span class="keywordflow">return</span> ret[0]</div>
<div class="line"><span class="lineno">  170</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a87fc8fb3809ce7a0a426237f9125d8fd" name="a87fc8fb3809ce7a0a426237f9125d8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fc8fb3809ce7a0a426237f9125d8fd">&#9670;&#160;</a></span>_unary_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._unary_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  465</span><span class="keyword">def </span>_unary_dispatcher(a):</div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span><span class="preprocessor">@array_function_dispatch(_unary_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8403bd8d4383a88fcd54bd60b6c48519" name="a8403bd8d4383a88fcd54bd60b6c48519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8403bd8d4383a88fcd54bd60b6c48519">&#9670;&#160;</a></span>cholesky()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.cholesky </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cholesky decomposition.

Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
where `L` is lower-triangular and .H is the conjugate transpose operator
(which is the ordinary transpose if `a` is real-valued).  `a` must be
Hermitian (symmetric if real-valued) and positive-definite. No
checking is performed to verify whether `a` is Hermitian or not.
In addition, only the lower-triangular and diagonal elements of `a`
are used. Only `L` is actually returned.

Parameters
----------
a : (..., M, M) array_like
    Hermitian (symmetric if all elements are real), positive-definite
    input matrix.

Returns
-------
L : (..., M, M) array_like
    Lower-triangular Cholesky factor of `a`.  Returns a matrix object if
    `a` is a matrix object.

Raises
------
LinAlgError
   If the decomposition fails, for example, if `a` is not
   positive-definite.

See Also
--------
scipy.linalg.cholesky : Similar function in SciPy.
scipy.linalg.cholesky_banded : Cholesky decompose a banded Hermitian
                               positive-definite matrix.
scipy.linalg.cho_factor : Cholesky decomposition of a matrix, to use in
                          `scipy.linalg.cho_solve`.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The Cholesky decomposition is often used as a fast way of solving

.. math:: A \\mathbf{x} = \\mathbf{b}

(when `A` is both Hermitian/symmetric and positive-definite).

First, we solve for :math:`\\mathbf{y}` in

.. math:: L \\mathbf{y} = \\mathbf{b},

and then for :math:`\\mathbf{x}` in

.. math:: L.H \\mathbf{x} = \\mathbf{y}.

Examples
--------
&gt;&gt;&gt; A = np.array([[1,-2j],[2j,5]])
&gt;&gt;&gt; A
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
&gt;&gt;&gt; L = np.linalg.cholesky(A)
&gt;&gt;&gt; L
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
&gt;&gt;&gt; np.dot(L, L.T.conj()) # verify that L * L.H = A
array([[1.+0.j, 0.-2.j],
       [0.+2.j, 5.+0.j]])
&gt;&gt;&gt; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
&gt;&gt;&gt; np.linalg.cholesky(A) # an ndarray object is returned
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
&gt;&gt;&gt; # But a matrix object is returned if A is a matrix object
&gt;&gt;&gt; np.linalg.cholesky(np.matrix(A))
matrix([[ 1.+0.j,  0.+0.j],
        [ 0.+2.j,  1.+0.j]])</pre> <div class="fragment"><div class="line"><span class="lineno">  666</span><span class="keyword">def </span>cholesky(a):</div>
<div class="line"><span class="lineno">  667</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    Cholesky decomposition.</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    where `L` is lower-triangular and .H is the conjugate transpose operator</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    (which is the ordinary transpose if `a` is real-valued).  `a` must be</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    Hermitian (symmetric if real-valued) and positive-definite. No</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    checking is performed to verify whether `a` is Hermitian or not.</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    In addition, only the lower-triangular and diagonal elements of `a`</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    are used. Only `L` is actually returned.</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">        Hermitian (symmetric if all elements are real), positive-definite</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">        input matrix.</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    L : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        Lower-triangular Cholesky factor of `a`.  Returns a matrix object if</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        `a` is a matrix object.</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">       If the decomposition fails, for example, if `a` is not</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">       positive-definite.</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    scipy.linalg.cholesky : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">    scipy.linalg.cholesky_banded : Cholesky decompose a banded Hermitian</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">                                   positive-definite matrix.</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    scipy.linalg.cho_factor : Cholesky decomposition of a matrix, to use in</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">                              `scipy.linalg.cho_solve`.</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    The Cholesky decomposition is often used as a fast way of solving</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    .. math:: A \\mathbf{x} = \\mathbf{b}</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    (when `A` is both Hermitian/symmetric and positive-definite).</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    First, we solve for :math:`\\mathbf{y}` in</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    .. math:: L \\mathbf{y} = \\mathbf{b},</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    and then for :math:`\\mathbf{x}` in</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    .. math:: L.H \\mathbf{x} = \\mathbf{y}.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[1,-2j],[2j,5]])</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    &gt;&gt;&gt; A</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    array([[ 1.+0.j, -0.-2.j],</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">           [ 0.+2.j,  5.+0.j]])</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    &gt;&gt;&gt; L = np.linalg.cholesky(A)</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    &gt;&gt;&gt; L</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    array([[1.+0.j, 0.+0.j],</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">           [0.+2.j, 1.+0.j]])</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(L, L.T.conj()) # verify that L * L.H = A</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    array([[1.+0.j, 0.-2.j],</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">           [0.+2.j, 5.+0.j]])</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    &gt;&gt;&gt; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    &gt;&gt;&gt; np.linalg.cholesky(A) # an ndarray object is returned</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    array([[1.+0.j, 0.+0.j],</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">           [0.+2.j, 1.+0.j]])</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    &gt;&gt;&gt; # But a matrix object is returned if A is a matrix object</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    &gt;&gt;&gt; np.linalg.cholesky(np.matrix(A))</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    matrix([[ 1.+0.j,  0.+0.j],</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">            [ 0.+2.j,  1.+0.j]])</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  749</span>    extobj = get_linalg_error_extobj(_raise_linalgerror_nonposdef)</div>
<div class="line"><span class="lineno">  750</span>    gufunc = _umath_linalg.cholesky_lo</div>
<div class="line"><span class="lineno">  751</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno">  752</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno">  753</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno">  754</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno">  755</span>    signature = <span class="stringliteral">&#39;D-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;d&#39;</span></div>
<div class="line"><span class="lineno">  756</span>    r = gufunc(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno">  757</span>    <span class="keywordflow">return</span> wrap(r.astype(result_t, copy=<span class="keyword">False</span>))</div>
<div class="line"><span class="lineno">  758</span> </div>
<div class="line"><span class="lineno">  759</span> </div>
<div class="line"><span class="lineno">  760</span><span class="comment"># QR decomposition</span></div>
<div class="line"><span class="lineno">  761</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae06f65c5604f0296aef175cf0d9399b" name="aae06f65c5604f0296aef175cf0d9399b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae06f65c5604f0296aef175cf0d9399b">&#9670;&#160;</a></span>cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.cond </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the condition number of a matrix.

This function is capable of returning the condition number using
one of seven different norms, depending on the value of `p` (see
Parameters below).

Parameters
----------
x : (..., M, N) array_like
    The matrix whose condition number is sought.
p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional
    Order of the norm used in the condition number computation:

    =====  ============================
    p      norm for matrices
    =====  ============================
    None   2-norm, computed directly using the ``SVD``
    'fro'  Frobenius norm
    inf    max(sum(abs(x), axis=1))
    -inf   min(sum(abs(x), axis=1))
    1      max(sum(abs(x), axis=0))
    -1     min(sum(abs(x), axis=0))
    2      2-norm (largest sing. value)
    -2     smallest singular value
    =====  ============================

    inf means the `numpy.inf` object, and the Frobenius norm is
    the root-of-sum-of-squares norm.

Returns
-------
c : {float, inf}
    The condition number of the matrix. May be infinite.

See Also
--------
numpy.linalg.norm

Notes
-----
The condition number of `x` is defined as the norm of `x` times the
norm of the inverse of `x` [1]_; the norm can be the usual L2-norm
(root-of-sum-of-squares) or one of a number of other matrix norms.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
       Academic Press, Inc., 1980, pg. 285.

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
&gt;&gt;&gt; a
array([[ 1,  0, -1],
       [ 0,  1,  0],
       [ 1,  0,  1]])
&gt;&gt;&gt; LA.cond(a)
1.4142135623730951
&gt;&gt;&gt; LA.cond(a, 'fro')
3.1622776601683795
&gt;&gt;&gt; LA.cond(a, np.inf)
2.0
&gt;&gt;&gt; LA.cond(a, -np.inf)
1.0
&gt;&gt;&gt; LA.cond(a, 1)
2.0
&gt;&gt;&gt; LA.cond(a, -1)
1.0
&gt;&gt;&gt; LA.cond(a, 2)
1.4142135623730951
&gt;&gt;&gt; LA.cond(a, -2)
0.70710678118654746 # may vary
&gt;&gt;&gt; min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))
0.70710678118654746 # may vary</pre> <div class="fragment"><div class="line"><span class="lineno"> 1664</span><span class="keyword">def </span>cond(x, p=None):</div>
<div class="line"><span class="lineno"> 1665</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">    Compute the condition number of a matrix.</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    This function is capable of returning the condition number using</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    one of seven different norms, depending on the value of `p` (see</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">    Parameters below).</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">    x : (..., M, N) array_like</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">        The matrix whose condition number is sought.</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    p : {None, 1, -1, 2, -2, inf, -inf, &#39;fro&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">        Order of the norm used in the condition number computation:</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">        =====  ============================</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">        p      norm for matrices</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">        =====  ============================</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">        None   2-norm, computed directly using the ``SVD``</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">        &#39;fro&#39;  Frobenius norm</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">        inf    max(sum(abs(x), axis=1))</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">        -inf   min(sum(abs(x), axis=1))</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        1      max(sum(abs(x), axis=0))</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">        -1     min(sum(abs(x), axis=0))</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">        2      2-norm (largest sing. value)</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">        -2     smallest singular value</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">        =====  ============================</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">        inf means the `numpy.inf` object, and the Frobenius norm is</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">        the root-of-sum-of-squares norm.</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">    c : {float, inf}</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">        The condition number of the matrix. May be infinite.</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    numpy.linalg.norm</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral">    The condition number of `x` is defined as the norm of `x` times the</span></div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">    norm of the inverse of `x` [1]_; the norm can be the usual L2-norm</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">    (root-of-sum-of-squares) or one of a number of other matrix norms.</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">    .. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,</span></div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">           Academic Press, Inc., 1980, pg. 285.</span></div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral">    &gt;&gt;&gt; from numpy import linalg as LA</span></div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral">    array([[ 1,  0, -1],</span></div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">           [ 0,  1,  0],</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">           [ 1,  0,  1]])</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a)</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">    1.4142135623730951</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a, &#39;fro&#39;)</span></div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">    3.1622776601683795</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a, np.inf)</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a, -np.inf)</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a, 1)</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a, -1)</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a, 2)</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral">    1.4142135623730951</span></div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral">    &gt;&gt;&gt; LA.cond(a, -2)</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">    0.70710678118654746 # may vary</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">    &gt;&gt;&gt; min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">    0.70710678118654746 # may vary</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1743</span>    x = asarray(x)  <span class="comment"># in case we have a matrix</span></div>
<div class="line"><span class="lineno"> 1744</span>    <span class="keywordflow">if</span> _is_empty_2d(x):</div>
<div class="line"><span class="lineno"> 1745</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;cond is not defined on empty arrays&quot;</span>)</div>
<div class="line"><span class="lineno"> 1746</span>    <span class="keywordflow">if</span> p <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> p == 2 <span class="keywordflow">or</span> p == -2:</div>
<div class="line"><span class="lineno"> 1747</span>        s = svd(x, compute_uv=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1748</span>        <span class="keyword">with</span> errstate(all=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 1749</span>            <span class="keywordflow">if</span> p == -2:</div>
<div class="line"><span class="lineno"> 1750</span>                r = s[..., -1] / s[..., 0]</div>
<div class="line"><span class="lineno"> 1751</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1752</span>                r = s[..., 0] / s[..., -1]</div>
<div class="line"><span class="lineno"> 1753</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1754</span>        <span class="comment"># Call inv(x) ignoring errors. The result array will</span></div>
<div class="line"><span class="lineno"> 1755</span>        <span class="comment"># contain nans in the entries where inversion failed.</span></div>
<div class="line"><span class="lineno"> 1756</span>        _assert_stacked_2d(x)</div>
<div class="line"><span class="lineno"> 1757</span>        _assert_stacked_square(x)</div>
<div class="line"><span class="lineno"> 1758</span>        t, result_t = _commonType(x)</div>
<div class="line"><span class="lineno"> 1759</span>        signature = <span class="stringliteral">&#39;D-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;d&#39;</span></div>
<div class="line"><span class="lineno"> 1760</span>        <span class="keyword">with</span> errstate(all=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 1761</span>            invx = _umath_linalg.inv(x, signature=signature)</div>
<div class="line"><span class="lineno"> 1762</span>            r = norm(x, p, axis=(-2, -1)) * norm(invx, p, axis=(-2, -1))</div>
<div class="line"><span class="lineno"> 1763</span>        r = r.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1764</span> </div>
<div class="line"><span class="lineno"> 1765</span>    <span class="comment"># Convert nans to infs unless the original array had nan entries</span></div>
<div class="line"><span class="lineno"> 1766</span>    r = asarray(r)</div>
<div class="line"><span class="lineno"> 1767</span>    nan_mask = isnan(r)</div>
<div class="line"><span class="lineno"> 1768</span>    <span class="keywordflow">if</span> nan_mask.any():</div>
<div class="line"><span class="lineno"> 1769</span>        nan_mask &amp;= ~isnan(x).any(axis=(-2, -1))</div>
<div class="line"><span class="lineno"> 1770</span>        <span class="keywordflow">if</span> r.ndim &gt; 0:</div>
<div class="line"><span class="lineno"> 1771</span>            r[nan_mask] = Inf</div>
<div class="line"><span class="lineno"> 1772</span>        <span class="keywordflow">elif</span> nan_mask:</div>
<div class="line"><span class="lineno"> 1773</span>            r[()] = Inf</div>
<div class="line"><span class="lineno"> 1774</span> </div>
<div class="line"><span class="lineno"> 1775</span>    <span class="comment"># Convention is to return scalars instead of 0d arrays</span></div>
<div class="line"><span class="lineno"> 1776</span>    <span class="keywordflow">if</span> r.ndim == 0:</div>
<div class="line"><span class="lineno"> 1777</span>        r = r[()]</div>
<div class="line"><span class="lineno"> 1778</span> </div>
<div class="line"><span class="lineno"> 1779</span>    <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno"> 1780</span> </div>
<div class="line"><span class="lineno"> 1781</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abefd159870d4ba793e2d0900aefbebad" name="abefd159870d4ba793e2d0900aefbebad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefd159870d4ba793e2d0900aefbebad">&#9670;&#160;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.det </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the determinant of an array.

Parameters
----------
a : (..., M, M) array_like
    Input array to compute determinants for.

Returns
-------
det : (...) array_like
    Determinant of `a`.

See Also
--------
slogdet : Another way to represent the determinant, more suitable
  for large matrices where underflow/overflow may occur.
scipy.linalg.det : Similar function in SciPy.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The determinant is computed via LU factorization using the LAPACK
routine ``z/dgetrf``.

Examples
--------
The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.linalg.det(a)
-2.0 # may vary

Computing determinants for a stack of matrices:

&gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
&gt;&gt;&gt; a.shape
(3, 2, 2)
&gt;&gt;&gt; np.linalg.det(a)
array([-2., -3., -8.])</pre> <div class="fragment"><div class="line"><span class="lineno"> 2086</span><span class="keyword">def </span>det(a):</div>
<div class="line"><span class="lineno"> 2087</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral">    Compute the determinant of an array.</span></div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">        Input array to compute determinants for.</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">    det : (...) array_like</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral">        Determinant of `a`.</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral">    slogdet : Another way to represent the determinant, more suitable</span></div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral">      for large matrices where underflow/overflow may occur.</span></div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral">    scipy.linalg.det : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">    The determinant is computed via LU factorization using the LAPACK</span></div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">    routine ``z/dgetrf``.</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral">    The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral">    &gt;&gt;&gt; np.linalg.det(a)</span></div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">    -2.0 # may vary</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral">    Computing determinants for a stack of matrices:</span></div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])</span></div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral">    &gt;&gt;&gt; a.shape</span></div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">    (3, 2, 2)</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral">    &gt;&gt;&gt; np.linalg.det(a)</span></div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral">    array([-2., -3., -8.])</span></div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2134</span>    a = asarray(a)</div>
<div class="line"><span class="lineno"> 2135</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno"> 2136</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno"> 2137</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 2138</span>    signature = <span class="stringliteral">&#39;D-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;d&#39;</span></div>
<div class="line"><span class="lineno"> 2139</span>    r = _umath_linalg.det(a, signature=signature)</div>
<div class="line"><span class="lineno"> 2140</span>    r = r.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2141</span>    <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno"> 2142</span> </div>
<div class="line"><span class="lineno"> 2143</span> </div>
<div class="line"><span class="lineno"> 2144</span><span class="comment"># Linear Least Squares</span></div>
<div class="line"><span class="lineno"> 2145</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3865b410b9a4d07ac35578669b34754a" name="a3865b410b9a4d07ac35578669b34754a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3865b410b9a4d07ac35578669b34754a">&#9670;&#160;</a></span>eig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.eig </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the eigenvalues and right eigenvectors of a square array.

Parameters
----------
a : (..., M, M) array
    Matrices for which the eigenvalues and right eigenvectors will
    be computed

Returns
-------
w : (..., M) array
    The eigenvalues, each repeated according to its multiplicity.
    The eigenvalues are not necessarily ordered. The resulting
    array will be of complex type, unless the imaginary part is
    zero in which case it will be cast to a real type. When `a`
    is real the resulting eigenvalues will be real (0 imaginary
    part) or occur in conjugate pairs

v : (..., M, M) array
    The normalized (unit "length") eigenvectors, such that the
    column ``v[:,i]`` is the eigenvector corresponding to the
    eigenvalue ``w[i]``.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvals : eigenvalues of a non-symmetric array.
eigh : eigenvalues and eigenvectors of a real symmetric or complex
       Hermitian (conjugate symmetric) array.
eigvalsh : eigenvalues of a real symmetric or complex Hermitian
           (conjugate symmetric) array.
scipy.linalg.eig : Similar function in SciPy that also solves the
                   generalized eigenvalue problem.
scipy.linalg.schur : Best choice for unitary and other non-Hermitian
                     normal matrices.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the ``_geev`` LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

The number `w` is an eigenvalue of `a` if there exists a vector
`v` such that ``a @ v = w * v``. Thus, the arrays `a`, `w`, and
`v` satisfy the equations ``a @ v[:,i] = w[i] * v[:,i]``
for :math:`i \\in \\{0,...,M-1\\}`.

The array `v` of eigenvectors may not be of maximum rank, that is, some
of the columns may be linearly dependent, although round-off error may
obscure that fact. If the eigenvalues are all different, then theoretically
the eigenvectors are linearly independent and `a` can be diagonalized by
a similarity transformation using `v`, i.e, ``inv(v) @ a @ v`` is diagonal.

For non-Hermitian normal matrices the SciPy function `scipy.linalg.schur`
is preferred because the matrix `v` is guaranteed to be unitary, which is
not the case when using `eig`. The Schur factorization produces an
upper triangular matrix rather than a diagonal matrix, but for normal
matrices only the diagonal of the upper triangular matrix is needed, the
rest is roundoff error.

Finally, it is emphasized that `v` consists of the *right* (as in
right-hand side) eigenvectors of `a`.  A vector `y` satisfying
``y.T @ a = z * y.T`` for some number `z` is called a *left*
eigenvector of `a`, and, in general, the left and right eigenvectors
of a matrix are not necessarily the (perhaps conjugate) transposes
of each other.

References
----------
G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
Academic Press, Inc., 1980, Various pp.

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA

(Almost) trivial example with real e-values and e-vectors.

&gt;&gt;&gt; w, v = LA.eig(np.diag((1, 2, 3)))
&gt;&gt;&gt; w; v
array([1., 2., 3.])
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

Real matrix possessing complex e-values and e-vectors; note that the
e-values are complex conjugates of each other.

&gt;&gt;&gt; w, v = LA.eig(np.array([[1, -1], [1, 1]]))
&gt;&gt;&gt; w; v
array([1.+1.j, 1.-1.j])
array([[0.70710678+0.j        , 0.70710678-0.j        ],
       [0.        -0.70710678j, 0.        +0.70710678j]])

Complex-valued matrix with real e-values (but complex-valued e-vectors);
note that ``a.conj().T == a``, i.e., `a` is Hermitian.

&gt;&gt;&gt; a = np.array([[1, 1j], [-1j, 1]])
&gt;&gt;&gt; w, v = LA.eig(a)
&gt;&gt;&gt; w; v
array([2.+0.j, 0.+0.j])
array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary
       [ 0.70710678+0.j        , -0.        +0.70710678j]])

Be careful about round-off error!

&gt;&gt;&gt; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
&gt;&gt;&gt; # Theor. e-values are 1 +/- 1e-9
&gt;&gt;&gt; w, v = LA.eig(a)
&gt;&gt;&gt; w; v
array([1., 1.])
array([[1., 0.],
       [0., 1.]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1169</span><span class="keyword">def </span>eig(a):</div>
<div class="line"><span class="lineno"> 1170</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    Compute the eigenvalues and right eigenvectors of a square array.</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    a : (..., M, M) array</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">        Matrices for which the eigenvalues and right eigenvectors will</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">        be computed</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">    w : (..., M) array</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">        The eigenvalues, each repeated according to its multiplicity.</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">        The eigenvalues are not necessarily ordered. The resulting</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">        array will be of complex type, unless the imaginary part is</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">        zero in which case it will be cast to a real type. When `a`</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">        is real the resulting eigenvalues will be real (0 imaginary</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">        part) or occur in conjugate pairs</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    v : (..., M, M) array</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">        The normalized (unit &quot;length&quot;) eigenvectors, such that the</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">        column ``v[:,i]`` is the eigenvector corresponding to the</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">        eigenvalue ``w[i]``.</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">        If the eigenvalue computation does not converge.</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    eigvals : eigenvalues of a non-symmetric array.</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    eigh : eigenvalues and eigenvectors of a real symmetric or complex</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">           Hermitian (conjugate symmetric) array.</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    eigvalsh : eigenvalues of a real symmetric or complex Hermitian</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">               (conjugate symmetric) array.</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    scipy.linalg.eig : Similar function in SciPy that also solves the</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">                       generalized eigenvalue problem.</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    scipy.linalg.schur : Best choice for unitary and other non-Hermitian</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">                         normal matrices.</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    This is implemented using the ``_geev`` LAPACK routines which compute</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    the eigenvalues and eigenvectors of general square arrays.</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">    The number `w` is an eigenvalue of `a` if there exists a vector</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">    `v` such that ``a @ v = w * v``. Thus, the arrays `a`, `w`, and</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">    `v` satisfy the equations ``a @ v[:,i] = w[i] * v[:,i]``</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">    for :math:`i \\in \\{0,...,M-1\\}`.</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    The array `v` of eigenvectors may not be of maximum rank, that is, some</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">    of the columns may be linearly dependent, although round-off error may</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    obscure that fact. If the eigenvalues are all different, then theoretically</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">    the eigenvectors are linearly independent and `a` can be diagonalized by</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">    a similarity transformation using `v`, i.e, ``inv(v) @ a @ v`` is diagonal.</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">    For non-Hermitian normal matrices the SciPy function `scipy.linalg.schur`</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">    is preferred because the matrix `v` is guaranteed to be unitary, which is</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    not the case when using `eig`. The Schur factorization produces an</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    upper triangular matrix rather than a diagonal matrix, but for normal</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">    matrices only the diagonal of the upper triangular matrix is needed, the</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    rest is roundoff error.</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    Finally, it is emphasized that `v` consists of the *right* (as in</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    right-hand side) eigenvectors of `a`.  A vector `y` satisfying</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">    ``y.T @ a = z * y.T`` for some number `z` is called a *left*</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">    eigenvector of `a`, and, in general, the left and right eigenvectors</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    of a matrix are not necessarily the (perhaps conjugate) transposes</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    of each other.</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">    Academic Press, Inc., 1980, Various pp.</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    &gt;&gt;&gt; from numpy import linalg as LA</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    (Almost) trivial example with real e-values and e-vectors.</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    &gt;&gt;&gt; w, v = LA.eig(np.diag((1, 2, 3)))</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    &gt;&gt;&gt; w; v</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    array([1., 2., 3.])</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    array([[1., 0., 0.],</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">           [0., 1., 0.],</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">           [0., 0., 1.]])</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">    Real matrix possessing complex e-values and e-vectors; note that the</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">    e-values are complex conjugates of each other.</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">    &gt;&gt;&gt; w, v = LA.eig(np.array([[1, -1], [1, 1]]))</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    &gt;&gt;&gt; w; v</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    array([1.+1.j, 1.-1.j])</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    array([[0.70710678+0.j        , 0.70710678-0.j        ],</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">           [0.        -0.70710678j, 0.        +0.70710678j]])</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    Complex-valued matrix with real e-values (but complex-valued e-vectors);</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">    note that ``a.conj().T == a``, i.e., `a` is Hermitian.</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 1j], [-1j, 1]])</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    &gt;&gt;&gt; w, v = LA.eig(a)</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    &gt;&gt;&gt; w; v</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    array([2.+0.j, 0.+0.j])</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">           [ 0.70710678+0.j        , -0.        +0.70710678j]])</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    Be careful about round-off error!</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    &gt;&gt;&gt; # Theor. e-values are 1 +/- 1e-9</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    &gt;&gt;&gt; w, v = LA.eig(a)</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    &gt;&gt;&gt; w; v</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    array([1., 1.])</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    array([[1., 0.],</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">           [0., 1.]])</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1295</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno"> 1296</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno"> 1297</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno"> 1298</span>    _assert_finite(a)</div>
<div class="line"><span class="lineno"> 1299</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 1300</span> </div>
<div class="line"><span class="lineno"> 1301</span>    extobj = get_linalg_error_extobj(</div>
<div class="line"><span class="lineno"> 1302</span>        _raise_linalgerror_eigenvalues_nonconvergence)</div>
<div class="line"><span class="lineno"> 1303</span>    signature = <span class="stringliteral">&#39;D-&gt;DD&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;DD&#39;</span></div>
<div class="line"><span class="lineno"> 1304</span>    w, vt = _umath_linalg.eig(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno"> 1305</span> </div>
<div class="line"><span class="lineno"> 1306</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isComplexType(t) <span class="keywordflow">and</span> all(w.imag == 0.0):</div>
<div class="line"><span class="lineno"> 1307</span>        w = w.real</div>
<div class="line"><span class="lineno"> 1308</span>        vt = vt.real</div>
<div class="line"><span class="lineno"> 1309</span>        result_t = _realType(result_t)</div>
<div class="line"><span class="lineno"> 1310</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1311</span>        result_t = _complexType(result_t)</div>
<div class="line"><span class="lineno"> 1312</span> </div>
<div class="line"><span class="lineno"> 1313</span>    vt = vt.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1314</span>    <span class="keywordflow">return</span> w.astype(result_t, copy=<span class="keyword">False</span>), wrap(vt)</div>
<div class="line"><span class="lineno"> 1315</span> </div>
<div class="line"><span class="lineno"> 1316</span> </div>
<div class="line"><span class="lineno"> 1317</span><span class="preprocessor">@array_function_dispatch(_eigvalsh_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c40172a6047b318226fe270b78a41b6" name="a3c40172a6047b318226fe270b78a41b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c40172a6047b318226fe270b78a41b6">&#9670;&#160;</a></span>eigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.eigh </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>UPLO</em> = <code>'L'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the eigenvalues and eigenvectors of a complex Hermitian
(conjugate symmetric) or a real symmetric matrix.

Returns two objects, a 1-D array containing the eigenvalues of `a`, and
a 2-D square array or matrix (depending on the input type) of the
corresponding eigenvectors (in columns).

Parameters
----------
a : (..., M, M) array
    Hermitian or real symmetric matrices whose eigenvalues and
    eigenvectors are to be computed.
UPLO : {'L', 'U'}, optional
    Specifies whether the calculation is done with the lower triangular
    part of `a` ('L', default) or the upper triangular part ('U').
    Irrespective of this value only the real parts of the diagonal will
    be considered in the computation to preserve the notion of a Hermitian
    matrix. It therefore follows that the imaginary part of the diagonal
    will always be treated as zero.

Returns
-------
w : (..., M) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.
v : {(..., M, M) ndarray, (..., M, M) matrix}
    The column ``v[:, i]`` is the normalized eigenvector corresponding
    to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
    a matrix object.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvalsh : eigenvalues of real symmetric or complex Hermitian
           (conjugate symmetric) arrays.
eig : eigenvalues and right eigenvectors for non-symmetric arrays.
eigvals : eigenvalues of non-symmetric arrays.
scipy.linalg.eigh : Similar function in SciPy (but also solves the
                    generalized eigenvalue problem).

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues/eigenvectors are computed using LAPACK routines ``_syevd``,
``_heevd``.

The eigenvalues of real symmetric or complex Hermitian matrices are
always real. [1]_ The array `v` of (column) eigenvectors is unitary
and `a`, `w`, and `v` satisfy the equations
``dot(a, v[:, i]) = w[i] * v[:, i]``.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 222.

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])
&gt;&gt;&gt; a
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
&gt;&gt;&gt; w, v = LA.eigh(a)
&gt;&gt;&gt; w; v
array([0.17157288, 5.82842712])
array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
       [ 0.        +0.38268343j,  0.        -0.92387953j]])

&gt;&gt;&gt; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])
&gt;&gt;&gt; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
array([0.+0.j, 0.+0.j])

&gt;&gt;&gt; A = np.matrix(a) # what happens if input is a matrix object
&gt;&gt;&gt; A
matrix([[ 1.+0.j, -0.-2.j],
        [ 0.+2.j,  5.+0.j]])
&gt;&gt;&gt; w, v = LA.eigh(A)
&gt;&gt;&gt; w; v
array([0.17157288, 5.82842712])
matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
        [ 0.        +0.38268343j,  0.        -0.92387953j]])

&gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal
&gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
&gt;&gt;&gt; a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
&gt;&gt;&gt; # with UPLO='L' this is numerically equivalent to using LA.eig() with:
&gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
&gt;&gt;&gt; b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
&gt;&gt;&gt; wa, va = LA.eigh(a)
&gt;&gt;&gt; wb, vb = LA.eig(b)
&gt;&gt;&gt; wa; wb
array([1., 6.])
array([6.+0.j, 1.+0.j])
&gt;&gt;&gt; va; vb
array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary
       [ 0.        +0.89442719j,  0.        -0.4472136j ]])
array([[ 0.89442719+0.j       , -0.        +0.4472136j],
       [-0.        +0.4472136j,  0.89442719+0.j       ]])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1318</span><span class="keyword">def </span>eigh(a, UPLO=&#39;L&#39;):</div>
<div class="line"><span class="lineno"> 1319</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    Return the eigenvalues and eigenvectors of a complex Hermitian</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    (conjugate symmetric) or a real symmetric matrix.</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    Returns two objects, a 1-D array containing the eigenvalues of `a`, and</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    a 2-D square array or matrix (depending on the input type) of the</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    corresponding eigenvectors (in columns).</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">    a : (..., M, M) array</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">        Hermitian or real symmetric matrices whose eigenvalues and</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">        eigenvectors are to be computed.</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    UPLO : {&#39;L&#39;, &#39;U&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">        Specifies whether the calculation is done with the lower triangular</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">        part of `a` (&#39;L&#39;, default) or the upper triangular part (&#39;U&#39;).</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">        Irrespective of this value only the real parts of the diagonal will</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">        be considered in the computation to preserve the notion of a Hermitian</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">        matrix. It therefore follows that the imaginary part of the diagonal</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">        will always be treated as zero.</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    w : (..., M) ndarray</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">        The eigenvalues in ascending order, each repeated according to</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">        its multiplicity.</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    v : {(..., M, M) ndarray, (..., M, M) matrix}</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">        The column ``v[:, i]`` is the normalized eigenvector corresponding</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">        to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">        a matrix object.</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">        If the eigenvalue computation does not converge.</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    eigvalsh : eigenvalues of real symmetric or complex Hermitian</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">               (conjugate symmetric) arrays.</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    eig : eigenvalues and right eigenvectors for non-symmetric arrays.</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    eigvals : eigenvalues of non-symmetric arrays.</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    scipy.linalg.eigh : Similar function in SciPy (but also solves the</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">                        generalized eigenvalue problem).</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    The eigenvalues/eigenvectors are computed using LAPACK routines ``_syevd``,</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    ``_heevd``.</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    The eigenvalues of real symmetric or complex Hermitian matrices are</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    always real. [1]_ The array `v` of (column) eigenvectors is unitary</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">    and `a`, `w`, and `v` satisfy the equations</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">    ``dot(a, v[:, i]) = w[i] * v[:, i]``.</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">           FL, Academic Press, Inc., 1980, pg. 222.</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    &gt;&gt;&gt; from numpy import linalg as LA</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    array([[ 1.+0.j, -0.-2.j],</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">           [ 0.+2.j,  5.+0.j]])</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">    &gt;&gt;&gt; w, v = LA.eigh(a)</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">    &gt;&gt;&gt; w; v</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    array([0.17157288, 5.82842712])</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">           [ 0.        +0.38268343j,  0.        -0.92387953j]])</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">    array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">    array([0.+0.j, 0.+0.j])</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    &gt;&gt;&gt; A = np.matrix(a) # what happens if input is a matrix object</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    &gt;&gt;&gt; A</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    matrix([[ 1.+0.j, -0.-2.j],</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">            [ 0.+2.j,  5.+0.j]])</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    &gt;&gt;&gt; w, v = LA.eigh(A)</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    &gt;&gt;&gt; w; v</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    array([0.17157288, 5.82842712])</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">            [ 0.        +0.38268343j,  0.        -0.92387953j]])</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    &gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">    array([[5.+2.j, 9.-2.j],</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">           [0.+2.j, 2.-1.j]])</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">    &gt;&gt;&gt; # with UPLO=&#39;L&#39; this is numerically equivalent to using LA.eig() with:</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">    array([[5.+0.j, 0.-2.j],</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">           [0.+2.j, 2.+0.j]])</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    &gt;&gt;&gt; wa, va = LA.eigh(a)</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    &gt;&gt;&gt; wb, vb = LA.eig(b)</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    &gt;&gt;&gt; wa; wb</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    array([1., 6.])</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    array([6.+0.j, 1.+0.j])</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    &gt;&gt;&gt; va; vb</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">           [ 0.        +0.89442719j,  0.        -0.4472136j ]])</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">    array([[ 0.89442719+0.j       , -0.        +0.4472136j],</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">           [-0.        +0.4472136j,  0.89442719+0.j       ]])</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1434</span>    UPLO = UPLO.upper()</div>
<div class="line"><span class="lineno"> 1435</span>    <span class="keywordflow">if</span> UPLO <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;L&#39;</span>, <span class="stringliteral">&#39;U&#39;</span>):</div>
<div class="line"><span class="lineno"> 1436</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;UPLO argument must be &#39;L&#39; or &#39;U&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1437</span> </div>
<div class="line"><span class="lineno"> 1438</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno"> 1439</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno"> 1440</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno"> 1441</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 1442</span> </div>
<div class="line"><span class="lineno"> 1443</span>    extobj = get_linalg_error_extobj(</div>
<div class="line"><span class="lineno"> 1444</span>        _raise_linalgerror_eigenvalues_nonconvergence)</div>
<div class="line"><span class="lineno"> 1445</span>    <span class="keywordflow">if</span> UPLO == <span class="stringliteral">&#39;L&#39;</span>:</div>
<div class="line"><span class="lineno"> 1446</span>        gufunc = _umath_linalg.eigh_lo</div>
<div class="line"><span class="lineno"> 1447</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1448</span>        gufunc = _umath_linalg.eigh_up</div>
<div class="line"><span class="lineno"> 1449</span> </div>
<div class="line"><span class="lineno"> 1450</span>    signature = <span class="stringliteral">&#39;D-&gt;dD&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;dd&#39;</span></div>
<div class="line"><span class="lineno"> 1451</span>    w, vt = gufunc(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno"> 1452</span>    w = w.astype(_realType(result_t), copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1453</span>    vt = vt.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1454</span>    <span class="keywordflow">return</span> w, wrap(vt)</div>
<div class="line"><span class="lineno"> 1455</span> </div>
<div class="line"><span class="lineno"> 1456</span> </div>
<div class="line"><span class="lineno"> 1457</span><span class="comment"># Singular value decomposition</span></div>
<div class="line"><span class="lineno"> 1458</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aff7ac4d2bd2d2acaaaf7b0d401355e2b" name="aff7ac4d2bd2d2acaaaf7b0d401355e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7ac4d2bd2d2acaaaf7b0d401355e2b">&#9670;&#160;</a></span>eigvals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.eigvals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the eigenvalues of a general matrix.

Main difference between `eigvals` and `eig`: the eigenvectors aren't
returned.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues will be computed.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues, each repeated according to its multiplicity.
    They are not necessarily ordered, nor are they necessarily
    real for real matrices.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eig : eigenvalues and right eigenvectors of general arrays
eigvalsh : eigenvalues of real symmetric or complex Hermitian
           (conjugate symmetric) arrays.
eigh : eigenvalues and eigenvectors of real symmetric or complex
       Hermitian (conjugate symmetric) arrays.
scipy.linalg.eigvals : Similar function in SciPy.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the ``_geev`` LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

Examples
--------
Illustration, using the fact that the eigenvalues of a diagonal matrix
are its diagonal elements, that multiplying a matrix on the left
by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
of `Q`), preserves the eigenvalues of the "middle" matrix.  In other words,
if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
``A``:

&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; x = np.random.random()
&gt;&gt;&gt; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
&gt;&gt;&gt; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
(1.0, 1.0, 0.0)

Now multiply a diagonal matrix by ``Q`` on one side and by ``Q.T`` on the other:

&gt;&gt;&gt; D = np.diag((-1,1))
&gt;&gt;&gt; LA.eigvals(D)
array([-1.,  1.])
&gt;&gt;&gt; A = np.dot(Q, D)
&gt;&gt;&gt; A = np.dot(A, Q.T)
&gt;&gt;&gt; LA.eigvals(A)
array([ 1., -1.]) # random</pre> <div class="fragment"><div class="line"><span class="lineno">  970</span><span class="keyword">def </span>eigvals(a):</div>
<div class="line"><span class="lineno">  971</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">    Compute the eigenvalues of a general matrix.</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">    Main difference between `eigvals` and `eig`: the eigenvectors aren&#39;t</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    returned.</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">        A complex- or real-valued matrix whose eigenvalues will be computed.</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    w : (..., M,) ndarray</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">        The eigenvalues, each repeated according to its multiplicity.</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">        They are not necessarily ordered, nor are they necessarily</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">        real for real matrices.</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">        If the eigenvalue computation does not converge.</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    eig : eigenvalues and right eigenvectors of general arrays</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    eigvalsh : eigenvalues of real symmetric or complex Hermitian</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">               (conjugate symmetric) arrays.</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    eigh : eigenvalues and eigenvectors of real symmetric or complex</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">           Hermitian (conjugate symmetric) arrays.</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    scipy.linalg.eigvals : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    This is implemented using the ``_geev`` LAPACK routines which compute</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    the eigenvalues and eigenvectors of general square arrays.</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    Illustration, using the fact that the eigenvalues of a diagonal matrix</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    are its diagonal elements, that multiplying a matrix on the left</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    of `Q`), preserves the eigenvalues of the &quot;middle&quot; matrix.  In other words,</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    ``A``:</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    &gt;&gt;&gt; from numpy import linalg as LA</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    &gt;&gt;&gt; x = np.random.random()</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    &gt;&gt;&gt; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    (1.0, 1.0, 0.0)</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    Now multiply a diagonal matrix by ``Q`` on one side and by ``Q.T`` on the other:</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    &gt;&gt;&gt; D = np.diag((-1,1))</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    &gt;&gt;&gt; LA.eigvals(D)</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    array([-1.,  1.])</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    &gt;&gt;&gt; A = np.dot(Q, D)</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    &gt;&gt;&gt; A = np.dot(A, Q.T)</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    &gt;&gt;&gt; LA.eigvals(A)</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    array([ 1., -1.]) # random</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1040</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno"> 1041</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno"> 1042</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno"> 1043</span>    _assert_finite(a)</div>
<div class="line"><span class="lineno"> 1044</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 1045</span> </div>
<div class="line"><span class="lineno"> 1046</span>    extobj = get_linalg_error_extobj(</div>
<div class="line"><span class="lineno"> 1047</span>        _raise_linalgerror_eigenvalues_nonconvergence)</div>
<div class="line"><span class="lineno"> 1048</span>    signature = <span class="stringliteral">&#39;D-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;D&#39;</span></div>
<div class="line"><span class="lineno"> 1049</span>    w = _umath_linalg.eigvals(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno"> 1050</span> </div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isComplexType(t):</div>
<div class="line"><span class="lineno"> 1052</span>        <span class="keywordflow">if</span> all(w.imag == 0):</div>
<div class="line"><span class="lineno"> 1053</span>            w = w.real</div>
<div class="line"><span class="lineno"> 1054</span>            result_t = _realType(result_t)</div>
<div class="line"><span class="lineno"> 1055</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1056</span>            result_t = _complexType(result_t)</div>
<div class="line"><span class="lineno"> 1057</span> </div>
<div class="line"><span class="lineno"> 1058</span>    <span class="keywordflow">return</span> w.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1059</span> </div>
<div class="line"><span class="lineno"> 1060</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a14126dbdd00c4414f1bfbb5b912ee503" name="a14126dbdd00c4414f1bfbb5b912ee503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14126dbdd00c4414f1bfbb5b912ee503">&#9670;&#160;</a></span>eigvalsh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.eigvalsh </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>UPLO</em> = <code>'L'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the eigenvalues of a complex Hermitian or real symmetric matrix.

Main difference from eigh: the eigenvectors are not computed.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues are to be
    computed.
UPLO : {'L', 'U'}, optional
    Specifies whether the calculation is done with the lower triangular
    part of `a` ('L', default) or the upper triangular part ('U').
    Irrespective of this value only the real parts of the diagonal will
    be considered in the computation to preserve the notion of a Hermitian
    matrix. It therefore follows that the imaginary part of the diagonal
    will always be treated as zero.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigh : eigenvalues and eigenvectors of real symmetric or complex Hermitian
       (conjugate symmetric) arrays.
eigvals : eigenvalues of general real or complex arrays.
eig : eigenvalues and right eigenvectors of general real or complex
      arrays.
scipy.linalg.eigvalsh : Similar function in SciPy.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues are computed using LAPACK routines ``_syevd``, ``_heevd``.

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])
&gt;&gt;&gt; LA.eigvalsh(a)
array([ 0.17157288,  5.82842712]) # may vary

&gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal
&gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
&gt;&gt;&gt; a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
&gt;&gt;&gt; # with UPLO='L' this is numerically equivalent to using LA.eigvals()
&gt;&gt;&gt; # with:
&gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
&gt;&gt;&gt; b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
&gt;&gt;&gt; wa = LA.eigvalsh(a)
&gt;&gt;&gt; wb = LA.eigvals(b)
&gt;&gt;&gt; wa; wb
array([1., 6.])
array([6.+0.j, 1.+0.j])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1066</span><span class="keyword">def </span>eigvalsh(a, UPLO=&#39;L&#39;):</div>
<div class="line"><span class="lineno"> 1067</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    Compute the eigenvalues of a complex Hermitian or real symmetric matrix.</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    Main difference from eigh: the eigenvectors are not computed.</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        A complex- or real-valued matrix whose eigenvalues are to be</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        computed.</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    UPLO : {&#39;L&#39;, &#39;U&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">        Specifies whether the calculation is done with the lower triangular</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">        part of `a` (&#39;L&#39;, default) or the upper triangular part (&#39;U&#39;).</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">        Irrespective of this value only the real parts of the diagonal will</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">        be considered in the computation to preserve the notion of a Hermitian</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">        matrix. It therefore follows that the imaginary part of the diagonal</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">        will always be treated as zero.</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    w : (..., M,) ndarray</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">        The eigenvalues in ascending order, each repeated according to</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">        its multiplicity.</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        If the eigenvalue computation does not converge.</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    eigh : eigenvalues and eigenvectors of real symmetric or complex Hermitian</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">           (conjugate symmetric) arrays.</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">    eigvals : eigenvalues of general real or complex arrays.</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    eig : eigenvalues and right eigenvectors of general real or complex</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">          arrays.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    scipy.linalg.eigvalsh : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">    The eigenvalues are computed using LAPACK routines ``_syevd``, ``_heevd``.</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    &gt;&gt;&gt; from numpy import linalg as LA</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    &gt;&gt;&gt; LA.eigvalsh(a)</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    array([ 0.17157288,  5.82842712]) # may vary</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    &gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    array([[5.+2.j, 9.-2.j],</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">           [0.+2.j, 2.-1.j]])</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    &gt;&gt;&gt; # with UPLO=&#39;L&#39; this is numerically equivalent to using LA.eigvals()</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    &gt;&gt;&gt; # with:</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    array([[5.+0.j, 0.-2.j],</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">           [0.+2.j, 2.+0.j]])</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    &gt;&gt;&gt; wa = LA.eigvalsh(a)</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    &gt;&gt;&gt; wb = LA.eigvals(b)</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    &gt;&gt;&gt; wa; wb</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    array([1., 6.])</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">    array([6.+0.j, 1.+0.j])</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1140</span>    UPLO = UPLO.upper()</div>
<div class="line"><span class="lineno"> 1141</span>    <span class="keywordflow">if</span> UPLO <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;L&#39;</span>, <span class="stringliteral">&#39;U&#39;</span>):</div>
<div class="line"><span class="lineno"> 1142</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;UPLO argument must be &#39;L&#39; or &#39;U&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1143</span> </div>
<div class="line"><span class="lineno"> 1144</span>    extobj = get_linalg_error_extobj(</div>
<div class="line"><span class="lineno"> 1145</span>        _raise_linalgerror_eigenvalues_nonconvergence)</div>
<div class="line"><span class="lineno"> 1146</span>    <span class="keywordflow">if</span> UPLO == <span class="stringliteral">&#39;L&#39;</span>:</div>
<div class="line"><span class="lineno"> 1147</span>        gufunc = _umath_linalg.eigvalsh_lo</div>
<div class="line"><span class="lineno"> 1148</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1149</span>        gufunc = _umath_linalg.eigvalsh_up</div>
<div class="line"><span class="lineno"> 1150</span> </div>
<div class="line"><span class="lineno"> 1151</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno"> 1152</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno"> 1153</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno"> 1154</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 1155</span>    signature = <span class="stringliteral">&#39;D-&gt;d&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;d&#39;</span></div>
<div class="line"><span class="lineno"> 1156</span>    w = gufunc(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno"> 1157</span>    <span class="keywordflow">return</span> w.astype(_realType(result_t), copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1158</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a745386a4df63f7c9f9eadc6cdbba61b3" name="a745386a4df63f7c9f9eadc6cdbba61b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745386a4df63f7c9f9eadc6cdbba61b3">&#9670;&#160;</a></span>get_linalg_error_extobj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.get_linalg_error_extobj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  107</span><span class="keyword">def </span>get_linalg_error_extobj(callback):</div>
<div class="line"><span class="lineno">  108</span>    extobj = list(_linalg_error_extobj)  <span class="comment"># make a copy</span></div>
<div class="line"><span class="lineno">  109</span>    extobj[2] = callback</div>
<div class="line"><span class="lineno">  110</span>    <span class="keywordflow">return</span> extobj</div>
<div class="line"><span class="lineno">  111</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab17f2260411a13c61c0ab3f0f9396032" name="ab17f2260411a13c61c0ab3f0f9396032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17f2260411a13c61c0ab3f0f9396032">&#9670;&#160;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.inv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (multiplicative) inverse of a matrix.

Given a square matrix `a`, return the matrix `ainv` satisfying
``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.

Parameters
----------
a : (..., M, M) array_like
    Matrix to be inverted.

Returns
-------
ainv : (..., M, M) ndarray or matrix
    (Multiplicative) inverse of the matrix `a`.

Raises
------
LinAlgError
    If `a` is not square or inversion fails.

See Also
--------
scipy.linalg.inv : Similar function in SciPy.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

Examples
--------
&gt;&gt;&gt; from numpy.linalg import inv
&gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])
&gt;&gt;&gt; ainv = inv(a)
&gt;&gt;&gt; np.allclose(np.dot(a, ainv), np.eye(2))
True
&gt;&gt;&gt; np.allclose(np.dot(ainv, a), np.eye(2))
True

If a is a matrix object, then the return value is a matrix as well:

&gt;&gt;&gt; ainv = inv(np.matrix(a))
&gt;&gt;&gt; ainv
matrix([[-2. ,  1. ],
        [ 1.5, -0.5]])

Inverses of several matrices can be computed at once:

&gt;&gt;&gt; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
&gt;&gt;&gt; inv(a)
array([[[-2.  ,  1.  ],
        [ 1.5 , -0.5 ]],
       [[-1.25,  0.75],
        [ 0.75, -0.25]]])</pre> <div class="fragment"><div class="line"><span class="lineno">  470</span><span class="keyword">def </span>inv(a):</div>
<div class="line"><span class="lineno">  471</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    Compute the (multiplicative) inverse of a matrix.</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    Given a square matrix `a`, return the matrix `ainv` satisfying</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    ``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        Matrix to be inverted.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    ainv : (..., M, M) ndarray or matrix</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        (Multiplicative) inverse of the matrix `a`.</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        If `a` is not square or inversion fails.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    scipy.linalg.inv : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.linalg import inv</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    &gt;&gt;&gt; ainv = inv(a)</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(np.dot(a, ainv), np.eye(2))</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(np.dot(ainv, a), np.eye(2))</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    If a is a matrix object, then the return value is a matrix as well:</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    &gt;&gt;&gt; ainv = inv(np.matrix(a))</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    &gt;&gt;&gt; ainv</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    matrix([[-2. ,  1. ],</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">            [ 1.5, -0.5]])</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    Inverses of several matrices can be computed at once:</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    &gt;&gt;&gt; inv(a)</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    array([[[-2.  ,  1.  ],</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">            [ 1.5 , -0.5 ]],</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">           [[-1.25,  0.75],</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">            [ 0.75, -0.25]]])</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  531</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno">  532</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno">  533</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno">  534</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno">  535</span> </div>
<div class="line"><span class="lineno">  536</span>    signature = <span class="stringliteral">&#39;D-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;d&#39;</span></div>
<div class="line"><span class="lineno">  537</span>    extobj = get_linalg_error_extobj(_raise_linalgerror_singular)</div>
<div class="line"><span class="lineno">  538</span>    ainv = _umath_linalg.inv(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno">  539</span>    <span class="keywordflow">return</span> wrap(ainv.astype(result_t, copy=<span class="keyword">False</span>))</div>
<div class="line"><span class="lineno">  540</span> </div>
<div class="line"><span class="lineno">  541</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7c2894feb89ce0f8c4ffe78918bfd8d" name="aa7c2894feb89ce0f8c4ffe78918bfd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c2894feb89ce0f8c4ffe78918bfd8d">&#9670;&#160;</a></span>isComplexType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.isComplexType </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  117</span><span class="keyword">def </span>isComplexType(t):</div>
<div class="line"><span class="lineno">  118</span>    <span class="keywordflow">return</span> issubclass(t, complexfloating)</div>
<div class="line"><span class="lineno">  119</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a45c871d4070603e5365a9ded025813da" name="a45c871d4070603e5365a9ded025813da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c871d4070603e5365a9ded025813da">&#9670;&#160;</a></span>lstsq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.lstsq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>&quot;warn&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the least-squares solution to a linear matrix equation.

Computes the vector `x` that approximately solves the equation
``a @ x = b``. The equation may be under-, well-, or over-determined
(i.e., the number of linearly independent rows of `a` can be less than,
equal to, or greater than its number of linearly independent columns).
If `a` is square and of full rank, then `x` (but for round-off error)
is the "exact" solution of the equation. Else, `x` minimizes the
Euclidean 2-norm :math:`||b - ax||`. If there are multiple minimizing
solutions, the one with the smallest 2-norm :math:`||x||` is returned.

Parameters
----------
a : (M, N) array_like
    "Coefficient" matrix.
b : {(M,), (M, K)} array_like
    Ordinate or "dependent variable" values. If `b` is two-dimensional,
    the least-squares solution is calculated for each of the `K` columns
    of `b`.
rcond : float, optional
    Cut-off ratio for small singular values of `a`.
    For the purposes of rank determination, singular values are treated
    as zero if they are smaller than `rcond` times the largest singular
    value of `a`.

    .. versionchanged:: 1.14.0
       If not set, a FutureWarning is given. The previous default
       of ``-1`` will use the machine precision as `rcond` parameter,
       the new default will use the machine precision times `max(M, N)`.
       To silence the warning and use the new default, use ``rcond=None``,
       to keep using the old behavior, use ``rcond=-1``.

Returns
-------
x : {(N,), (N, K)} ndarray
    Least-squares solution. If `b` is two-dimensional,
    the solutions are in the `K` columns of `x`.
residuals : {(1,), (K,), (0,)} ndarray
    Sums of squared residuals: Squared Euclidean 2-norm for each column in
    ``b - a @ x``.
    If the rank of `a` is &lt; N or M &lt;= N, this is an empty array.
    If `b` is 1-dimensional, this is a (1,) shape array.
    Otherwise the shape is (K,).
rank : int
    Rank of matrix `a`.
s : (min(M, N),) ndarray
    Singular values of `a`.

Raises
------
LinAlgError
    If computation does not converge.

See Also
--------
scipy.linalg.lstsq : Similar function in SciPy.

Notes
-----
If `b` is a matrix, then all array results are returned as matrices.

Examples
--------
Fit a line, ``y = mx + c``, through some noisy data-points:

&gt;&gt;&gt; x = np.array([0, 1, 2, 3])
&gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])

By examining the coefficients, we see that the line should have a
gradient of roughly 1 and cut the y-axis at, more or less, -1.

We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``
and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:

&gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T
&gt;&gt;&gt; A
array([[ 0.,  1.],
       [ 1.,  1.],
       [ 2.,  1.],
       [ 3.,  1.]])

&gt;&gt;&gt; m, c = np.linalg.lstsq(A, y, rcond=None)[0]
&gt;&gt;&gt; m, c
(1.0 -0.95) # may vary

Plot the data along with the fitted line:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; _ = plt.plot(x, y, 'o', label='Original data', markersize=10)
&gt;&gt;&gt; _ = plt.plot(x, m*x + c, 'r', label='Fitted line')
&gt;&gt;&gt; _ = plt.legend()
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2151</span><span class="keyword">def </span>lstsq(a, b, rcond=&quot;warn&quot;):</div>
<div class="line"><span class="lineno"> 2152</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2153</span><span class="stringliteral">    Return the least-squares solution to a linear matrix equation.</span></div>
<div class="line"><span class="lineno"> 2154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2155</span><span class="stringliteral">    Computes the vector `x` that approximately solves the equation</span></div>
<div class="line"><span class="lineno"> 2156</span><span class="stringliteral">    ``a @ x = b``. The equation may be under-, well-, or over-determined</span></div>
<div class="line"><span class="lineno"> 2157</span><span class="stringliteral">    (i.e., the number of linearly independent rows of `a` can be less than,</span></div>
<div class="line"><span class="lineno"> 2158</span><span class="stringliteral">    equal to, or greater than its number of linearly independent columns).</span></div>
<div class="line"><span class="lineno"> 2159</span><span class="stringliteral">    If `a` is square and of full rank, then `x` (but for round-off error)</span></div>
<div class="line"><span class="lineno"> 2160</span><span class="stringliteral">    is the &quot;exact&quot; solution of the equation. Else, `x` minimizes the</span></div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">    Euclidean 2-norm :math:`||b - ax||`. If there are multiple minimizing</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral">    solutions, the one with the smallest 2-norm :math:`||x||` is returned.</span></div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">    a : (M, N) array_like</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">        &quot;Coefficient&quot; matrix.</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">    b : {(M,), (M, K)} array_like</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">        Ordinate or &quot;dependent variable&quot; values. If `b` is two-dimensional,</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral">        the least-squares solution is calculated for each of the `K` columns</span></div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">        of `b`.</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral">    rcond : float, optional</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral">        Cut-off ratio for small singular values of `a`.</span></div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">        For the purposes of rank determination, singular values are treated</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">        as zero if they are smaller than `rcond` times the largest singular</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">        value of `a`.</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral">        .. versionchanged:: 1.14.0</span></div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">           If not set, a FutureWarning is given. The previous default</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">           of ``-1`` will use the machine precision as `rcond` parameter,</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral">           the new default will use the machine precision times `max(M, N)`.</span></div>
<div class="line"><span class="lineno"> 2182</span><span class="stringliteral">           To silence the warning and use the new default, use ``rcond=None``,</span></div>
<div class="line"><span class="lineno"> 2183</span><span class="stringliteral">           to keep using the old behavior, use ``rcond=-1``.</span></div>
<div class="line"><span class="lineno"> 2184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2185</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2186</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2187</span><span class="stringliteral">    x : {(N,), (N, K)} ndarray</span></div>
<div class="line"><span class="lineno"> 2188</span><span class="stringliteral">        Least-squares solution. If `b` is two-dimensional,</span></div>
<div class="line"><span class="lineno"> 2189</span><span class="stringliteral">        the solutions are in the `K` columns of `x`.</span></div>
<div class="line"><span class="lineno"> 2190</span><span class="stringliteral">    residuals : {(1,), (K,), (0,)} ndarray</span></div>
<div class="line"><span class="lineno"> 2191</span><span class="stringliteral">        Sums of squared residuals: Squared Euclidean 2-norm for each column in</span></div>
<div class="line"><span class="lineno"> 2192</span><span class="stringliteral">        ``b - a @ x``.</span></div>
<div class="line"><span class="lineno"> 2193</span><span class="stringliteral">        If the rank of `a` is &lt; N or M &lt;= N, this is an empty array.</span></div>
<div class="line"><span class="lineno"> 2194</span><span class="stringliteral">        If `b` is 1-dimensional, this is a (1,) shape array.</span></div>
<div class="line"><span class="lineno"> 2195</span><span class="stringliteral">        Otherwise the shape is (K,).</span></div>
<div class="line"><span class="lineno"> 2196</span><span class="stringliteral">    rank : int</span></div>
<div class="line"><span class="lineno"> 2197</span><span class="stringliteral">        Rank of matrix `a`.</span></div>
<div class="line"><span class="lineno"> 2198</span><span class="stringliteral">    s : (min(M, N),) ndarray</span></div>
<div class="line"><span class="lineno"> 2199</span><span class="stringliteral">        Singular values of `a`.</span></div>
<div class="line"><span class="lineno"> 2200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2201</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 2202</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 2203</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 2204</span><span class="stringliteral">        If computation does not converge.</span></div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2206</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2207</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2208</span><span class="stringliteral">    scipy.linalg.lstsq : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral">    If `b` is a matrix, then all array results are returned as matrices.</span></div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">    Fit a line, ``y = mx + c``, through some noisy data-points:</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral">    By examining the coefficients, we see that the line should have a</span></div>
<div class="line"><span class="lineno"> 2222</span><span class="stringliteral">    gradient of roughly 1 and cut the y-axis at, more or less, -1.</span></div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral">    We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``</span></div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral">    and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">    &gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">    &gt;&gt;&gt; A</span></div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">    array([[ 0.,  1.],</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">           [ 1.,  1.],</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral">           [ 2.,  1.],</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">           [ 3.,  1.]])</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">    &gt;&gt;&gt; m, c = np.linalg.lstsq(A, y, rcond=None)[0]</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral">    &gt;&gt;&gt; m, c</span></div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    (1.0 -0.95) # may vary</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral">    Plot the data along with the fitted line:</span></div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">    &gt;&gt;&gt; _ = plt.plot(x, y, &#39;o&#39;, label=&#39;Original data&#39;, markersize=10)</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">    &gt;&gt;&gt; _ = plt.plot(x, m*x + c, &#39;r&#39;, label=&#39;Fitted line&#39;)</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">    &gt;&gt;&gt; _ = plt.legend()</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2247</span>    a, _ = _makearray(a)</div>
<div class="line"><span class="lineno"> 2248</span>    b, wrap = _makearray(b)</div>
<div class="line"><span class="lineno"> 2249</span>    is_1d = b.ndim == 1</div>
<div class="line"><span class="lineno"> 2250</span>    <span class="keywordflow">if</span> is_1d:</div>
<div class="line"><span class="lineno"> 2251</span>        b = b[:, newaxis]</div>
<div class="line"><span class="lineno"> 2252</span>    _assert_2d(a, b)</div>
<div class="line"><span class="lineno"> 2253</span>    m, n = a.shape[-2:]</div>
<div class="line"><span class="lineno"> 2254</span>    m2, n_rhs = b.shape[-2:]</div>
<div class="line"><span class="lineno"> 2255</span>    <span class="keywordflow">if</span> m != m2:</div>
<div class="line"><span class="lineno"> 2256</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&#39;Incompatible dimensions&#39;</span>)</div>
<div class="line"><span class="lineno"> 2257</span> </div>
<div class="line"><span class="lineno"> 2258</span>    t, result_t = _commonType(a, b)</div>
<div class="line"><span class="lineno"> 2259</span>    result_real_t = _realType(result_t)</div>
<div class="line"><span class="lineno"> 2260</span> </div>
<div class="line"><span class="lineno"> 2261</span>    <span class="comment"># Determine default rcond value</span></div>
<div class="line"><span class="lineno"> 2262</span>    <span class="keywordflow">if</span> rcond == <span class="stringliteral">&quot;warn&quot;</span>:</div>
<div class="line"><span class="lineno"> 2263</span>        <span class="comment"># 2017-08-19, 1.14.0</span></div>
<div class="line"><span class="lineno"> 2264</span>        warnings.warn(<span class="stringliteral">&quot;`rcond` parameter will change to the default of &quot;</span></div>
<div class="line"><span class="lineno"> 2265</span>                      <span class="stringliteral">&quot;machine precision times ``max(M, N)`` where M and N &quot;</span></div>
<div class="line"><span class="lineno"> 2266</span>                      <span class="stringliteral">&quot;are the input matrix dimensions.\n&quot;</span></div>
<div class="line"><span class="lineno"> 2267</span>                      <span class="stringliteral">&quot;To use the future default and silence this warning &quot;</span></div>
<div class="line"><span class="lineno"> 2268</span>                      <span class="stringliteral">&quot;we advise to pass `rcond=None`, to keep using the old, &quot;</span></div>
<div class="line"><span class="lineno"> 2269</span>                      <span class="stringliteral">&quot;explicitly pass `rcond=-1`.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2270</span>                      FutureWarning, stacklevel=3)</div>
<div class="line"><span class="lineno"> 2271</span>        rcond = -1</div>
<div class="line"><span class="lineno"> 2272</span>    <span class="keywordflow">if</span> rcond <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2273</span>        rcond = finfo(t).eps * max(n, m)</div>
<div class="line"><span class="lineno"> 2274</span> </div>
<div class="line"><span class="lineno"> 2275</span>    <span class="keywordflow">if</span> m &lt;= n:</div>
<div class="line"><span class="lineno"> 2276</span>        gufunc = _umath_linalg.lstsq_m</div>
<div class="line"><span class="lineno"> 2277</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2278</span>        gufunc = _umath_linalg.lstsq_n</div>
<div class="line"><span class="lineno"> 2279</span> </div>
<div class="line"><span class="lineno"> 2280</span>    signature = <span class="stringliteral">&#39;DDd-&gt;Ddid&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;ddd-&gt;ddid&#39;</span></div>
<div class="line"><span class="lineno"> 2281</span>    extobj = get_linalg_error_extobj(_raise_linalgerror_lstsq)</div>
<div class="line"><span class="lineno"> 2282</span>    <span class="keywordflow">if</span> n_rhs == 0:</div>
<div class="line"><span class="lineno"> 2283</span>        <span class="comment"># lapack can&#39;t handle n_rhs = 0 - so allocate the array one larger in that axis</span></div>
<div class="line"><span class="lineno"> 2284</span>        b = zeros(b.shape[:-2] + (m, n_rhs + 1), dtype=b.dtype)</div>
<div class="line"><span class="lineno"> 2285</span>    x, resids, rank, s = gufunc(a, b, rcond, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno"> 2286</span>    <span class="keywordflow">if</span> m == 0:</div>
<div class="line"><span class="lineno"> 2287</span>        x[...] = 0</div>
<div class="line"><span class="lineno"> 2288</span>    <span class="keywordflow">if</span> n_rhs == 0:</div>
<div class="line"><span class="lineno"> 2289</span>        <span class="comment"># remove the item we added</span></div>
<div class="line"><span class="lineno"> 2290</span>        x = x[..., :n_rhs]</div>
<div class="line"><span class="lineno"> 2291</span>        resids = resids[..., :n_rhs]</div>
<div class="line"><span class="lineno"> 2292</span> </div>
<div class="line"><span class="lineno"> 2293</span>    <span class="comment"># remove the axis we added</span></div>
<div class="line"><span class="lineno"> 2294</span>    <span class="keywordflow">if</span> is_1d:</div>
<div class="line"><span class="lineno"> 2295</span>        x = x.squeeze(axis=-1)</div>
<div class="line"><span class="lineno"> 2296</span>        <span class="comment"># we probably should squeeze resids too, but we can&#39;t</span></div>
<div class="line"><span class="lineno"> 2297</span>        <span class="comment"># without breaking compatibility.</span></div>
<div class="line"><span class="lineno"> 2298</span> </div>
<div class="line"><span class="lineno"> 2299</span>    <span class="comment"># as documented</span></div>
<div class="line"><span class="lineno"> 2300</span>    <span class="keywordflow">if</span> rank != n <span class="keywordflow">or</span> m &lt;= n:</div>
<div class="line"><span class="lineno"> 2301</span>        resids = array([], result_real_t)</div>
<div class="line"><span class="lineno"> 2302</span> </div>
<div class="line"><span class="lineno"> 2303</span>    <span class="comment"># coerce output arrays</span></div>
<div class="line"><span class="lineno"> 2304</span>    s = s.astype(result_real_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2305</span>    resids = resids.astype(result_real_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2306</span>    x = x.astype(result_t, copy=<span class="keyword">True</span>)  <span class="comment"># Copying lets the memory in r_parts be freed</span></div>
<div class="line"><span class="lineno"> 2307</span>    <span class="keywordflow">return</span> wrap(x), wrap(resids), rank, s</div>
<div class="line"><span class="lineno"> 2308</span> </div>
<div class="line"><span class="lineno"> 2309</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a86d569ae90f74c4129df6e5980186a78" name="a86d569ae90f74c4129df6e5980186a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d569ae90f74c4129df6e5980186a78">&#9670;&#160;</a></span>matrix_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.matrix_power </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Raise a square matrix to the (integer) power `n`.

For positive integers `n`, the power is computed by repeated matrix
squarings and matrix multiplications. If ``n == 0``, the identity matrix
of the same shape as M is returned. If ``n &lt; 0``, the inverse
is computed and then raised to the ``abs(n)``.

.. note:: Stacks of object matrices are not currently supported.

Parameters
----------
a : (..., M, M) array_like
    Matrix to be "powered".
n : int
    The exponent can be any integer or long integer, positive,
    negative, or zero.

Returns
-------
a**n : (..., M, M) ndarray or matrix object
    The return value is the same shape and type as `M`;
    if the exponent is positive or zero then the type of the
    elements is the same as those of `M`. If the exponent is
    negative the elements are floating-point.

Raises
------
LinAlgError
    For matrices that are not square or that (for negative powers) cannot
    be inverted numerically.

Examples
--------
&gt;&gt;&gt; from numpy.linalg import matrix_power
&gt;&gt;&gt; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
&gt;&gt;&gt; matrix_power(i, 3) # should = -i
array([[ 0, -1],
       [ 1,  0]])
&gt;&gt;&gt; matrix_power(i, 0)
array([[1, 0],
       [0, 1]])
&gt;&gt;&gt; matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
array([[ 0.,  1.],
       [-1.,  0.]])

Somewhat more sophisticated example

&gt;&gt;&gt; q = np.zeros((4, 4))
&gt;&gt;&gt; q[0:2, 0:2] = -i
&gt;&gt;&gt; q[2:4, 2:4] = i
&gt;&gt;&gt; q # one of the three quaternion units not equal to 1
array([[ 0., -1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.],
       [ 0.,  0., -1.,  0.]])
&gt;&gt;&gt; matrix_power(q, 2) # = -np.eye(4)
array([[-1.,  0.,  0.,  0.],
       [ 0., -1.,  0.,  0.],
       [ 0.,  0., -1.,  0.],
       [ 0.,  0.,  0., -1.]])</pre> <div class="fragment"><div class="line"><span class="lineno">  547</span><span class="keyword">def </span>matrix_power(a, n):</div>
<div class="line"><span class="lineno">  548</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    Raise a square matrix to the (integer) power `n`.</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    For positive integers `n`, the power is computed by repeated matrix</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    squarings and matrix multiplications. If ``n == 0``, the identity matrix</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    of the same shape as M is returned. If ``n &lt; 0``, the inverse</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    is computed and then raised to the ``abs(n)``.</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    .. note:: Stacks of object matrices are not currently supported.</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">        Matrix to be &quot;powered&quot;.</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">        The exponent can be any integer or long integer, positive,</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">        negative, or zero.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    a**n : (..., M, M) ndarray or matrix object</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        The return value is the same shape and type as `M`;</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        if the exponent is positive or zero then the type of the</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        elements is the same as those of `M`. If the exponent is</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        negative the elements are floating-point.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        For matrices that are not square or that (for negative powers) cannot</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        be inverted numerically.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.linalg import matrix_power</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    &gt;&gt;&gt; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    &gt;&gt;&gt; matrix_power(i, 3) # should = -i</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    array([[ 0, -1],</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">           [ 1,  0]])</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    &gt;&gt;&gt; matrix_power(i, 0)</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    array([[1, 0],</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">           [0, 1]])</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    &gt;&gt;&gt; matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    array([[ 0.,  1.],</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">           [-1.,  0.]])</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    Somewhat more sophisticated example</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    &gt;&gt;&gt; q = np.zeros((4, 4))</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    &gt;&gt;&gt; q[0:2, 0:2] = -i</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    &gt;&gt;&gt; q[2:4, 2:4] = i</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    &gt;&gt;&gt; q # one of the three quaternion units not equal to 1</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    array([[ 0., -1.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">           [ 1.,  0.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">           [ 0.,  0.,  0.,  1.],</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">           [ 0.,  0., -1.,  0.]])</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    &gt;&gt;&gt; matrix_power(q, 2) # = -np.eye(4)</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    array([[-1.,  0.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">           [ 0., -1.,  0.,  0.],</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">           [ 0.,  0., -1.,  0.],</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">           [ 0.,  0.,  0., -1.]])</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  611</span>    a = asanyarray(a)</div>
<div class="line"><span class="lineno">  612</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno">  613</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno">  614</span> </div>
<div class="line"><span class="lineno">  615</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  616</span>        n = operator.index(n)</div>
<div class="line"><span class="lineno">  617</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  618</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;exponent must be an integer&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  619</span> </div>
<div class="line"><span class="lineno">  620</span>    <span class="comment"># Fall back on dot for object arrays. Object arrays are not supported by</span></div>
<div class="line"><span class="lineno">  621</span>    <span class="comment"># the current implementation of matmul using einsum</span></div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordflow">if</span> a.dtype != object:</div>
<div class="line"><span class="lineno">  623</span>        fmatmul = matmul</div>
<div class="line"><span class="lineno">  624</span>    <span class="keywordflow">elif</span> a.ndim == 2:</div>
<div class="line"><span class="lineno">  625</span>        fmatmul = dot</div>
<div class="line"><span class="lineno">  626</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  627</span>        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno">  628</span>            <span class="stringliteral">&quot;matrix_power not supported for stacks of object arrays&quot;</span>)</div>
<div class="line"><span class="lineno">  629</span> </div>
<div class="line"><span class="lineno">  630</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno">  631</span>        a = empty_like(a)</div>
<div class="line"><span class="lineno">  632</span>        a[...] = eye(a.shape[-2], dtype=a.dtype)</div>
<div class="line"><span class="lineno">  633</span>        <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span>    <span class="keywordflow">elif</span> n &lt; 0:</div>
<div class="line"><span class="lineno">  636</span>        a = inv(a)</div>
<div class="line"><span class="lineno">  637</span>        n = abs(n)</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span>    <span class="comment"># short-cuts.</span></div>
<div class="line"><span class="lineno">  640</span>    <span class="keywordflow">if</span> n == 1:</div>
<div class="line"><span class="lineno">  641</span>        <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>    <span class="keywordflow">elif</span> n == 2:</div>
<div class="line"><span class="lineno">  644</span>        <span class="keywordflow">return</span> fmatmul(a, a)</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>    <span class="keywordflow">elif</span> n == 3:</div>
<div class="line"><span class="lineno">  647</span>        <span class="keywordflow">return</span> fmatmul(fmatmul(a, a), a)</div>
<div class="line"><span class="lineno">  648</span> </div>
<div class="line"><span class="lineno">  649</span>    <span class="comment"># Use binary decomposition to reduce the number of matrix multiplications.</span></div>
<div class="line"><span class="lineno">  650</span>    <span class="comment"># Here, we iterate over the bits of n, from LSB to MSB, raise `a` to</span></div>
<div class="line"><span class="lineno">  651</span>    <span class="comment"># increasing powers of 2, and multiply into the result as needed.</span></div>
<div class="line"><span class="lineno">  652</span>    z = result = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  653</span>    <span class="keywordflow">while</span> n &gt; 0:</div>
<div class="line"><span class="lineno">  654</span>        z = a <span class="keywordflow">if</span> z <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> fmatmul(z, z)</div>
<div class="line"><span class="lineno">  655</span>        n, bit = divmod(n, 2)</div>
<div class="line"><span class="lineno">  656</span>        <span class="keywordflow">if</span> bit:</div>
<div class="line"><span class="lineno">  657</span>            result = z <span class="keywordflow">if</span> result <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> fmatmul(result, z)</div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span><span class="comment"># Cholesky decomposition</span></div>
<div class="line"><span class="lineno">  663</span> </div>
<div class="line"><span class="lineno">  664</span> </div>
<div class="line"><span class="lineno">  665</span><span class="preprocessor">@array_function_dispatch(_unary_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a07a54f41be367169cf0a47c4057c5c27" name="a07a54f41be367169cf0a47c4057c5c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a54f41be367169cf0a47c4057c5c27">&#9670;&#160;</a></span>matrix_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.matrix_rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hermitian</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return matrix rank of array using SVD method

Rank of the array is the number of singular values of the array that are
greater than `tol`.

.. versionchanged:: 1.14
   Can now operate on stacks of matrices

Parameters
----------
A : {(M,), (..., M, N)} array_like
    Input vector or stack of matrices.
tol : (...) array_like, float, optional
    Threshold below which SVD values are considered zero. If `tol` is
    None, and ``S`` is an array with singular values for `M`, and
    ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
    set to ``S.max() * max(M, N) * eps``.

    .. versionchanged:: 1.14
       Broadcasted against the stack of matrices
hermitian : bool, optional
    If True, `A` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.14

Returns
-------
rank : (...) array_like
    Rank of A.

Notes
-----
The default threshold to detect rank deficiency is a test on the magnitude
of the singular values of `A`.  By default, we identify singular values less
than ``S.max() * max(M, N) * eps`` as indicating rank deficiency (with
the symbols defined above). This is the algorithm MATLAB uses [1].  It also
appears in *Numerical recipes* in the discussion of SVD solutions for linear
least squares [2].

This default threshold is designed to detect rank deficiency accounting for
the numerical errors of the SVD computation.  Imagine that there is a column
in `A` that is an exact (in floating point) linear combination of other
columns in `A`. Computing the SVD on `A` will not produce a singular value
exactly equal to 0 in general: any difference of the smallest SVD value from
0 will be caused by numerical imprecision in the calculation of the SVD.
Our threshold for small SVD values takes this numerical imprecision into
account, and the default threshold will detect such numerical rank
deficiency.  The threshold may declare a matrix `A` rank deficient even if
the linear combination of some columns of `A` is not exactly equal to
another column of `A` but only numerically very close to another column of
`A`.

We chose our default threshold because it is in wide use.  Other thresholds
are possible.  For example, elsewhere in the 2007 edition of *Numerical
recipes* there is an alternative threshold of ``S.max() *
np.finfo(A.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe
this threshold as being based on "expected roundoff error" (p 71).

The thresholds above deal with floating point roundoff error in the
calculation of the SVD.  However, you may have more information about the
sources of error in `A` that would make you consider other tolerance values
to detect *effective* rank deficiency.  The most useful measure of the
tolerance depends on the operations you intend to use on your matrix.  For
example, if your data come from uncertain measurements with uncertainties
greater than floating point epsilon, choosing a tolerance near that
uncertainty may be preferable.  The tolerance may be absolute if the
uncertainties are absolute rather than relative.

References
----------
.. [1] MATLAB reference documentation, "Rank"
       https://www.mathworks.com/help/techdoc/ref/rank.html
.. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
       "Numerical Recipes (3rd edition)", Cambridge University Press, 2007,
       page 795.

Examples
--------
&gt;&gt;&gt; from numpy.linalg import matrix_rank
&gt;&gt;&gt; matrix_rank(np.eye(4)) # Full rank matrix
4
&gt;&gt;&gt; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
&gt;&gt;&gt; matrix_rank(I)
3
&gt;&gt;&gt; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
1
&gt;&gt;&gt; matrix_rank(np.zeros((4,)))
0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1787</span><span class="keyword">def </span>matrix_rank(A, tol=None, hermitian=False):</div>
<div class="line"><span class="lineno"> 1788</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">    Return matrix rank of array using SVD method</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">    Rank of the array is the number of singular values of the array that are</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    greater than `tol`.</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">    .. versionchanged:: 1.14</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">       Can now operate on stacks of matrices</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">    A : {(M,), (..., M, N)} array_like</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        Input vector or stack of matrices.</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">    tol : (...) array_like, float, optional</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        Threshold below which SVD values are considered zero. If `tol` is</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">        None, and ``S`` is an array with singular values for `M`, and</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">        ``eps`` is the epsilon value for datatype of ``S``, then `tol` is</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">        set to ``S.max() * max(M, N) * eps``.</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">        .. versionchanged:: 1.14</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">           Broadcasted against the stack of matrices</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">    hermitian : bool, optional</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">        If True, `A` is assumed to be Hermitian (symmetric if real-valued),</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">        enabling a more efficient method for finding singular values.</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">        Defaults to False.</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">        .. versionadded:: 1.14</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">    rank : (...) array_like</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        Rank of A.</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    The default threshold to detect rank deficiency is a test on the magnitude</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    of the singular values of `A`.  By default, we identify singular values less</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    than ``S.max() * max(M, N) * eps`` as indicating rank deficiency (with</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    the symbols defined above). This is the algorithm MATLAB uses [1].  It also</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    appears in *Numerical recipes* in the discussion of SVD solutions for linear</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    least squares [2].</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    This default threshold is designed to detect rank deficiency accounting for</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    the numerical errors of the SVD computation.  Imagine that there is a column</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    in `A` that is an exact (in floating point) linear combination of other</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    columns in `A`. Computing the SVD on `A` will not produce a singular value</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    exactly equal to 0 in general: any difference of the smallest SVD value from</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    0 will be caused by numerical imprecision in the calculation of the SVD.</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">    Our threshold for small SVD values takes this numerical imprecision into</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">    account, and the default threshold will detect such numerical rank</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    deficiency.  The threshold may declare a matrix `A` rank deficient even if</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">    the linear combination of some columns of `A` is not exactly equal to</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">    another column of `A` but only numerically very close to another column of</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">    `A`.</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">    We chose our default threshold because it is in wide use.  Other thresholds</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">    are possible.  For example, elsewhere in the 2007 edition of *Numerical</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">    recipes* there is an alternative threshold of ``S.max() *</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">    np.finfo(A.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">    this threshold as being based on &quot;expected roundoff error&quot; (p 71).</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    The thresholds above deal with floating point roundoff error in the</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">    calculation of the SVD.  However, you may have more information about the</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    sources of error in `A` that would make you consider other tolerance values</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">    to detect *effective* rank deficiency.  The most useful measure of the</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    tolerance depends on the operations you intend to use on your matrix.  For</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    example, if your data come from uncertain measurements with uncertainties</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    greater than floating point epsilon, choosing a tolerance near that</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    uncertainty may be preferable.  The tolerance may be absolute if the</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    uncertainties are absolute rather than relative.</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">    .. [1] MATLAB reference documentation, &quot;Rank&quot;</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">           https://www.mathworks.com/help/techdoc/ref/rank.html</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    .. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">           &quot;Numerical Recipes (3rd edition)&quot;, Cambridge University Press, 2007,</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">           page 795.</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.linalg import matrix_rank</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">    &gt;&gt;&gt; matrix_rank(np.eye(4)) # Full rank matrix</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">    4</span></div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">    &gt;&gt;&gt; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">    &gt;&gt;&gt; matrix_rank(I)</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral">    3</span></div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    &gt;&gt;&gt; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    &gt;&gt;&gt; matrix_rank(np.zeros((4,)))</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1880</span>    A = asarray(A)</div>
<div class="line"><span class="lineno"> 1881</span>    <span class="keywordflow">if</span> A.ndim &lt; 2:</div>
<div class="line"><span class="lineno"> 1882</span>        <span class="keywordflow">return</span> int(<span class="keywordflow">not</span> all(A==0))</div>
<div class="line"><span class="lineno"> 1883</span>    S = svd(A, compute_uv=<span class="keyword">False</span>, hermitian=hermitian)</div>
<div class="line"><span class="lineno"> 1884</span>    <span class="keywordflow">if</span> tol <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1885</span>        tol = S.max(axis=-1, keepdims=<span class="keyword">True</span>) * max(A.shape[-2:]) * finfo(S.dtype).eps</div>
<div class="line"><span class="lineno"> 1886</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1887</span>        tol = asarray(tol)[..., newaxis]</div>
<div class="line"><span class="lineno"> 1888</span>    <span class="keywordflow">return</span> count_nonzero(S &gt; tol, axis=-1)</div>
<div class="line"><span class="lineno"> 1889</span> </div>
<div class="line"><span class="lineno"> 1890</span> </div>
<div class="line"><span class="lineno"> 1891</span><span class="comment"># Generalized inverse</span></div>
<div class="line"><span class="lineno"> 1892</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a88c3416113850ed22c95bcb81b371689" name="a88c3416113850ed22c95bcb81b371689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c3416113850ed22c95bcb81b371689">&#9670;&#160;</a></span>multi_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.multi_dot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the dot product of two or more arrays in a single function call,
while automatically selecting the fastest evaluation order.

`multi_dot` chains `numpy.dot` and uses optimal parenthesization
of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
this can speed up the multiplication a lot.

If the first argument is 1-D it is treated as a row vector.
If the last argument is 1-D it is treated as a column vector.
The other arguments must be 2-D.

Think of `multi_dot` as::

    def multi_dot(arrays): return functools.reduce(np.dot, arrays)


Parameters
----------
arrays : sequence of array_like
    If the first argument is 1-D it is treated as row vector.
    If the last argument is 1-D it is treated as column vector.
    The other arguments must be 2-D.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a, b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

    .. versionadded:: 1.19.0

Returns
-------
output : ndarray
    Returns the dot product of the supplied arrays.

See Also
--------
numpy.dot : dot multiplication with two arguments.

References
----------

.. [1] Cormen, "Introduction to Algorithms", Chapter 15.2, p. 370-378
.. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication

Examples
--------
`multi_dot` allows you to write::

&gt;&gt;&gt; from numpy.linalg import multi_dot
&gt;&gt;&gt; # Prepare some data
&gt;&gt;&gt; A = np.random.random((10000, 100))
&gt;&gt;&gt; B = np.random.random((100, 1000))
&gt;&gt;&gt; C = np.random.random((1000, 5))
&gt;&gt;&gt; D = np.random.random((5, 333))
&gt;&gt;&gt; # the actual dot multiplication
&gt;&gt;&gt; _ = multi_dot([A, B, C, D])

instead of::

&gt;&gt;&gt; _ = np.dot(np.dot(np.dot(A, B), C), D)
&gt;&gt;&gt; # or
&gt;&gt;&gt; _ = A.dot(B).dot(C).dot(D)

Notes
-----
The cost for a matrix multiplication can be calculated with the
following function::

    def cost(A, B):
        return A.shape[0] * A.shape[1] * B.shape[1]

Assume we have three matrices
:math:`A_{10x100}, B_{100x5}, C_{5x50}`.

The costs for the two different parenthesizations are as follows::

    cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
    cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000</pre> <div class="fragment"><div class="line"><span class="lineno"> 2603</span><span class="keyword">def </span>multi_dot(arrays, *, out=None):</div>
<div class="line"><span class="lineno"> 2604</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2605</span><span class="stringliteral">    Compute the dot product of two or more arrays in a single function call,</span></div>
<div class="line"><span class="lineno"> 2606</span><span class="stringliteral">    while automatically selecting the fastest evaluation order.</span></div>
<div class="line"><span class="lineno"> 2607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2608</span><span class="stringliteral">    `multi_dot` chains `numpy.dot` and uses optimal parenthesization</span></div>
<div class="line"><span class="lineno"> 2609</span><span class="stringliteral">    of the matrices [1]_ [2]_. Depending on the shapes of the matrices,</span></div>
<div class="line"><span class="lineno"> 2610</span><span class="stringliteral">    this can speed up the multiplication a lot.</span></div>
<div class="line"><span class="lineno"> 2611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2612</span><span class="stringliteral">    If the first argument is 1-D it is treated as a row vector.</span></div>
<div class="line"><span class="lineno"> 2613</span><span class="stringliteral">    If the last argument is 1-D it is treated as a column vector.</span></div>
<div class="line"><span class="lineno"> 2614</span><span class="stringliteral">    The other arguments must be 2-D.</span></div>
<div class="line"><span class="lineno"> 2615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2616</span><span class="stringliteral">    Think of `multi_dot` as::</span></div>
<div class="line"><span class="lineno"> 2617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2618</span><span class="stringliteral">        def multi_dot(arrays): return functools.reduce(np.dot, arrays)</span></div>
<div class="line"><span class="lineno"> 2619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2621</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2622</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2623</span><span class="stringliteral">    arrays : sequence of array_like</span></div>
<div class="line"><span class="lineno"> 2624</span><span class="stringliteral">        If the first argument is 1-D it is treated as row vector.</span></div>
<div class="line"><span class="lineno"> 2625</span><span class="stringliteral">        If the last argument is 1-D it is treated as column vector.</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral">        The other arguments must be 2-D.</span></div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral">        Output argument. This must have the exact kind that would be returned</span></div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">        if it was not used. In particular, it must have the right type, must be</span></div>
<div class="line"><span class="lineno"> 2630</span><span class="stringliteral">        C-contiguous, and its dtype must be the dtype that would be returned</span></div>
<div class="line"><span class="lineno"> 2631</span><span class="stringliteral">        for `dot(a, b)`. This is a performance feature. Therefore, if these</span></div>
<div class="line"><span class="lineno"> 2632</span><span class="stringliteral">        conditions are not met, an exception is raised, instead of attempting</span></div>
<div class="line"><span class="lineno"> 2633</span><span class="stringliteral">        to be flexible.</span></div>
<div class="line"><span class="lineno"> 2634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2635</span><span class="stringliteral">        .. versionadded:: 1.19.0</span></div>
<div class="line"><span class="lineno"> 2636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2637</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2638</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2639</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno"> 2640</span><span class="stringliteral">        Returns the dot product of the supplied arrays.</span></div>
<div class="line"><span class="lineno"> 2641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2642</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2643</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2644</span><span class="stringliteral">    numpy.dot : dot multiplication with two arguments.</span></div>
<div class="line"><span class="lineno"> 2645</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2646</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2647</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2649</span><span class="stringliteral">    .. [1] Cormen, &quot;Introduction to Algorithms&quot;, Chapter 15.2, p. 370-378</span></div>
<div class="line"><span class="lineno"> 2650</span><span class="stringliteral">    .. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication</span></div>
<div class="line"><span class="lineno"> 2651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2652</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral">    `multi_dot` allows you to write::</span></div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.linalg import multi_dot</span></div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral">    &gt;&gt;&gt; # Prepare some data</span></div>
<div class="line"><span class="lineno"> 2658</span><span class="stringliteral">    &gt;&gt;&gt; A = np.random.random((10000, 100))</span></div>
<div class="line"><span class="lineno"> 2659</span><span class="stringliteral">    &gt;&gt;&gt; B = np.random.random((100, 1000))</span></div>
<div class="line"><span class="lineno"> 2660</span><span class="stringliteral">    &gt;&gt;&gt; C = np.random.random((1000, 5))</span></div>
<div class="line"><span class="lineno"> 2661</span><span class="stringliteral">    &gt;&gt;&gt; D = np.random.random((5, 333))</span></div>
<div class="line"><span class="lineno"> 2662</span><span class="stringliteral">    &gt;&gt;&gt; # the actual dot multiplication</span></div>
<div class="line"><span class="lineno"> 2663</span><span class="stringliteral">    &gt;&gt;&gt; _ = multi_dot([A, B, C, D])</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2665</span><span class="stringliteral">    instead of::</span></div>
<div class="line"><span class="lineno"> 2666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2667</span><span class="stringliteral">    &gt;&gt;&gt; _ = np.dot(np.dot(np.dot(A, B), C), D)</span></div>
<div class="line"><span class="lineno"> 2668</span><span class="stringliteral">    &gt;&gt;&gt; # or</span></div>
<div class="line"><span class="lineno"> 2669</span><span class="stringliteral">    &gt;&gt;&gt; _ = A.dot(B).dot(C).dot(D)</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">    The cost for a matrix multiplication can be calculated with the</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">    following function::</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral">        def cost(A, B):</span></div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral">            return A.shape[0] * A.shape[1] * B.shape[1]</span></div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral">    Assume we have three matrices</span></div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">    :math:`A_{10x100}, B_{100x5}, C_{5x50}`.</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral">    The costs for the two different parenthesizations are as follows::</span></div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">        cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500</span></div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral">        cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000</span></div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2688</span>    n = len(arrays)</div>
<div class="line"><span class="lineno"> 2689</span>    <span class="comment"># optimization only makes sense for len(arrays) &gt; 2</span></div>
<div class="line"><span class="lineno"> 2690</span>    <span class="keywordflow">if</span> n &lt; 2:</div>
<div class="line"><span class="lineno"> 2691</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expecting at least two arrays.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2692</span>    <span class="keywordflow">elif</span> n == 2:</div>
<div class="line"><span class="lineno"> 2693</span>        <span class="keywordflow">return</span> dot(arrays[0], arrays[1], out=out)</div>
<div class="line"><span class="lineno"> 2694</span> </div>
<div class="line"><span class="lineno"> 2695</span>    arrays = [asanyarray(a) <span class="keywordflow">for</span> a <span class="keywordflow">in</span> arrays]</div>
<div class="line"><span class="lineno"> 2696</span> </div>
<div class="line"><span class="lineno"> 2697</span>    <span class="comment"># save original ndim to reshape the result array into the proper form later</span></div>
<div class="line"><span class="lineno"> 2698</span>    ndim_first, ndim_last = arrays[0].ndim, arrays[-1].ndim</div>
<div class="line"><span class="lineno"> 2699</span>    <span class="comment"># Explicitly convert vectors to 2D arrays to keep the logic of the internal</span></div>
<div class="line"><span class="lineno"> 2700</span>    <span class="comment"># _multi_dot_* functions as simple as possible.</span></div>
<div class="line"><span class="lineno"> 2701</span>    <span class="keywordflow">if</span> arrays[0].ndim == 1:</div>
<div class="line"><span class="lineno"> 2702</span>        arrays[0] = atleast_2d(arrays[0])</div>
<div class="line"><span class="lineno"> 2703</span>    <span class="keywordflow">if</span> arrays[-1].ndim == 1:</div>
<div class="line"><span class="lineno"> 2704</span>        arrays[-1] = atleast_2d(arrays[-1]).T</div>
<div class="line"><span class="lineno"> 2705</span>    _assert_2d(*arrays)</div>
<div class="line"><span class="lineno"> 2706</span> </div>
<div class="line"><span class="lineno"> 2707</span>    <span class="comment"># _multi_dot_three is much faster than _multi_dot_matrix_chain_order</span></div>
<div class="line"><span class="lineno"> 2708</span>    <span class="keywordflow">if</span> n == 3:</div>
<div class="line"><span class="lineno"> 2709</span>        result = _multi_dot_three(arrays[0], arrays[1], arrays[2], out=out)</div>
<div class="line"><span class="lineno"> 2710</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2711</span>        order = _multi_dot_matrix_chain_order(arrays)</div>
<div class="line"><span class="lineno"> 2712</span>        result = _multi_dot(arrays, order, 0, n - 1, out=out)</div>
<div class="line"><span class="lineno"> 2713</span> </div>
<div class="line"><span class="lineno"> 2714</span>    <span class="comment"># return proper shape</span></div>
<div class="line"><span class="lineno"> 2715</span>    <span class="keywordflow">if</span> ndim_first == 1 <span class="keywordflow">and</span> ndim_last == 1:</div>
<div class="line"><span class="lineno"> 2716</span>        <span class="keywordflow">return</span> result[0, 0]  <span class="comment"># scalar</span></div>
<div class="line"><span class="lineno"> 2717</span>    <span class="keywordflow">elif</span> ndim_first == 1 <span class="keywordflow">or</span> ndim_last == 1:</div>
<div class="line"><span class="lineno"> 2718</span>        <span class="keywordflow">return</span> result.ravel()  <span class="comment"># 1-D</span></div>
<div class="line"><span class="lineno"> 2719</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2720</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 2721</span> </div>
<div class="line"><span class="lineno"> 2722</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a54ed0342a9f0d9562f149924eb17d591" name="a54ed0342a9f0d9562f149924eb17d591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ed0342a9f0d9562f149924eb17d591">&#9670;&#160;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.norm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ord</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Matrix or vector norm.

This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the ``ord`` parameter.

Parameters
----------
x : array_like
    Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
    is None. If both `axis` and `ord` are None, the 2-norm of
    ``x.ravel`` will be returned.
ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object. The default is None.
axis : {None, int, 2-tuple of ints}, optional.
    If `axis` is an integer, it specifies the axis of `x` along which to
    compute the vector norms.  If `axis` is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If `axis` is None then either a vector norm (when `x`
    is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
    is None.

    .. versionadded:: 1.8.0

keepdims : bool, optional
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original `x`.

    .. versionadded:: 1.10.0

Returns
-------
n : float or ndarray
    Norm of the matrix or vector(s).

See Also
--------
scipy.linalg.norm : Similar function in SciPy.

Notes
-----
For values of ``ord &lt; 1``, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.

The following norms can be calculated:

=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
'nuc'  nuclear norm                  --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)**ord)**(1./ord)
=====  ============================  ==========================

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

The nuclear norm is the sum of the singular values.

Both the Frobenius and nuclear norm orders are only defined for
matrices and raise a ValueError when ``x.ndim != 2``.

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.arange(9) - 4
&gt;&gt;&gt; a
array([-4, -3, -2, ...,  2,  3,  4])
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])

&gt;&gt;&gt; LA.norm(a)
7.745966692414834
&gt;&gt;&gt; LA.norm(b)
7.745966692414834
&gt;&gt;&gt; LA.norm(b, 'fro')
7.745966692414834
&gt;&gt;&gt; LA.norm(a, np.inf)
4.0
&gt;&gt;&gt; LA.norm(b, np.inf)
9.0
&gt;&gt;&gt; LA.norm(a, -np.inf)
0.0
&gt;&gt;&gt; LA.norm(b, -np.inf)
2.0

&gt;&gt;&gt; LA.norm(a, 1)
20.0
&gt;&gt;&gt; LA.norm(b, 1)
7.0
&gt;&gt;&gt; LA.norm(a, -1)
-4.6566128774142013e-010
&gt;&gt;&gt; LA.norm(b, -1)
6.0
&gt;&gt;&gt; LA.norm(a, 2)
7.745966692414834
&gt;&gt;&gt; LA.norm(b, 2)
7.3484692283495345

&gt;&gt;&gt; LA.norm(a, -2)
0.0
&gt;&gt;&gt; LA.norm(b, -2)
1.8570331885190563e-016 # may vary
&gt;&gt;&gt; LA.norm(a, 3)
5.8480354764257312 # may vary
&gt;&gt;&gt; LA.norm(a, -3)
0.0

Using the `axis` argument to compute vector norms:

&gt;&gt;&gt; c = np.array([[ 1, 2, 3],
...               [-1, 1, 4]])
&gt;&gt;&gt; LA.norm(c, axis=0)
array([ 1.41421356,  2.23606798,  5.        ])
&gt;&gt;&gt; LA.norm(c, axis=1)
array([ 3.74165739,  4.24264069])
&gt;&gt;&gt; LA.norm(c, ord=1, axis=1)
array([ 6.,  6.])

Using the `axis` argument to compute matrix norms:

&gt;&gt;&gt; m = np.arange(8).reshape(2,2,2)
&gt;&gt;&gt; LA.norm(m, axis=(1,2))
array([  3.74165739,  11.22497216])
&gt;&gt;&gt; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
(3.7416573867739413, 11.224972160321824)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2343</span><span class="keyword">def </span>norm(x, ord=None, axis=None, keepdims=False):</div>
<div class="line"><span class="lineno"> 2344</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2345</span><span class="stringliteral">    Matrix or vector norm.</span></div>
<div class="line"><span class="lineno"> 2346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2347</span><span class="stringliteral">    This function is able to return one of eight different matrix norms,</span></div>
<div class="line"><span class="lineno"> 2348</span><span class="stringliteral">    or one of an infinite number of vector norms (described below), depending</span></div>
<div class="line"><span class="lineno"> 2349</span><span class="stringliteral">    on the value of the ``ord`` parameter.</span></div>
<div class="line"><span class="lineno"> 2350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2351</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2352</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2353</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 2354</span><span class="stringliteral">        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`</span></div>
<div class="line"><span class="lineno"> 2355</span><span class="stringliteral">        is None. If both `axis` and `ord` are None, the 2-norm of</span></div>
<div class="line"><span class="lineno"> 2356</span><span class="stringliteral">        ``x.ravel`` will be returned.</span></div>
<div class="line"><span class="lineno"> 2357</span><span class="stringliteral">    ord : {non-zero int, inf, -inf, &#39;fro&#39;, &#39;nuc&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2358</span><span class="stringliteral">        Order of the norm (see table under ``Notes``). inf means numpy&#39;s</span></div>
<div class="line"><span class="lineno"> 2359</span><span class="stringliteral">        `inf` object. The default is None.</span></div>
<div class="line"><span class="lineno"> 2360</span><span class="stringliteral">    axis : {None, int, 2-tuple of ints}, optional.</span></div>
<div class="line"><span class="lineno"> 2361</span><span class="stringliteral">        If `axis` is an integer, it specifies the axis of `x` along which to</span></div>
<div class="line"><span class="lineno"> 2362</span><span class="stringliteral">        compute the vector norms.  If `axis` is a 2-tuple, it specifies the</span></div>
<div class="line"><span class="lineno"> 2363</span><span class="stringliteral">        axes that hold 2-D matrices, and the matrix norms of these matrices</span></div>
<div class="line"><span class="lineno"> 2364</span><span class="stringliteral">        are computed.  If `axis` is None then either a vector norm (when `x`</span></div>
<div class="line"><span class="lineno"> 2365</span><span class="stringliteral">        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default</span></div>
<div class="line"><span class="lineno"> 2366</span><span class="stringliteral">        is None.</span></div>
<div class="line"><span class="lineno"> 2367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2368</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 2369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2370</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 2371</span><span class="stringliteral">        If this is set to True, the axes which are normed over are left in the</span></div>
<div class="line"><span class="lineno"> 2372</span><span class="stringliteral">        result as dimensions with size one.  With this option the result will</span></div>
<div class="line"><span class="lineno"> 2373</span><span class="stringliteral">        broadcast correctly against the original `x`.</span></div>
<div class="line"><span class="lineno"> 2374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2375</span><span class="stringliteral">        .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 2376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2377</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2378</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2379</span><span class="stringliteral">    n : float or ndarray</span></div>
<div class="line"><span class="lineno"> 2380</span><span class="stringliteral">        Norm of the matrix or vector(s).</span></div>
<div class="line"><span class="lineno"> 2381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2382</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2383</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2384</span><span class="stringliteral">    scipy.linalg.norm : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2387</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2388</span><span class="stringliteral">    For values of ``ord &lt; 1``, the result is, strictly speaking, not a</span></div>
<div class="line"><span class="lineno"> 2389</span><span class="stringliteral">    mathematical &#39;norm&#39;, but it may still be useful for various numerical</span></div>
<div class="line"><span class="lineno"> 2390</span><span class="stringliteral">    purposes.</span></div>
<div class="line"><span class="lineno"> 2391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2392</span><span class="stringliteral">    The following norms can be calculated:</span></div>
<div class="line"><span class="lineno"> 2393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2394</span><span class="stringliteral">    =====  ============================  ==========================</span></div>
<div class="line"><span class="lineno"> 2395</span><span class="stringliteral">    ord    norm for matrices             norm for vectors</span></div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral">    =====  ============================  ==========================</span></div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral">    None   Frobenius norm                2-norm</span></div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">    &#39;fro&#39;  Frobenius norm                --</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral">    &#39;nuc&#39;  nuclear norm                  --</span></div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">    inf    max(sum(abs(x), axis=1))      max(abs(x))</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral">    -inf   min(sum(abs(x), axis=1))      min(abs(x))</span></div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral">    0      --                            sum(x != 0)</span></div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">    1      max(sum(abs(x), axis=0))      as below</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">    -1     min(sum(abs(x), axis=0))      as below</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral">    2      2-norm (largest sing. value)  as below</span></div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">    -2     smallest singular value       as below</span></div>
<div class="line"><span class="lineno"> 2407</span><span class="stringliteral">    other  --                            sum(abs(x)**ord)**(1./ord)</span></div>
<div class="line"><span class="lineno"> 2408</span><span class="stringliteral">    =====  ============================  ==========================</span></div>
<div class="line"><span class="lineno"> 2409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2410</span><span class="stringliteral">    The Frobenius norm is given by [1]_:</span></div>
<div class="line"><span class="lineno"> 2411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral">        :math:`||A||_F = [\\sum_{i,j} abs(a_{i,j})^2]^{1/2}`</span></div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral">    The nuclear norm is the sum of the singular values.</span></div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral">    Both the Frobenius and nuclear norm orders are only defined for</span></div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral">    matrices and raise a ValueError when ``x.ndim != 2``.</span></div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2419</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2420</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2421</span><span class="stringliteral">    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,</span></div>
<div class="line"><span class="lineno"> 2422</span><span class="stringliteral">           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</span></div>
<div class="line"><span class="lineno"> 2423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2424</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2425</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2426</span><span class="stringliteral">    &gt;&gt;&gt; from numpy import linalg as LA</span></div>
<div class="line"><span class="lineno"> 2427</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(9) - 4</span></div>
<div class="line"><span class="lineno"> 2428</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 2429</span><span class="stringliteral">    array([-4, -3, -2, ...,  2,  3,  4])</span></div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral">    &gt;&gt;&gt; b = a.reshape((3, 3))</span></div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral">    array([[-4, -3, -2],</span></div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral">           [-1,  0,  1],</span></div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">           [ 2,  3,  4]])</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a)</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">    7.745966692414834</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b)</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">    7.745966692414834</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b, &#39;fro&#39;)</span></div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    7.745966692414834</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, np.inf)</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b, np.inf)</span></div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">    9.0</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, -np.inf)</span></div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b, -np.inf)</span></div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, 1)</span></div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">    20.0</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b, 1)</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">    7.0</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, -1)</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">    -4.6566128774142013e-010</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b, -1)</span></div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">    6.0</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, 2)</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral">    7.745966692414834</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b, 2)</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral">    7.3484692283495345</span></div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, -2)</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(b, -2)</span></div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral">    1.8570331885190563e-016 # may vary</span></div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, 3)</span></div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">    5.8480354764257312 # may vary</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(a, -3)</span></div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">    Using the `axis` argument to compute vector norms:</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">    &gt;&gt;&gt; c = np.array([[ 1, 2, 3],</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">    ...               [-1, 1, 4]])</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(c, axis=0)</span></div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">    array([ 1.41421356,  2.23606798,  5.        ])</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(c, axis=1)</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral">    array([ 3.74165739,  4.24264069])</span></div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(c, ord=1, axis=1)</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">    array([ 6.,  6.])</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">    Using the `axis` argument to compute matrix norms:</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">    &gt;&gt;&gt; m = np.arange(8).reshape(2,2,2)</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(m, axis=(1,2))</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">    array([  3.74165739,  11.22497216])</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">    &gt;&gt;&gt; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral">    (3.7416573867739413, 11.224972160321824)</span></div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2493</span>    x = asarray(x)</div>
<div class="line"><span class="lineno"> 2494</span> </div>
<div class="line"><span class="lineno"> 2495</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> issubclass(x.dtype.type, (inexact, object_)):</div>
<div class="line"><span class="lineno"> 2496</span>        x = x.astype(float)</div>
<div class="line"><span class="lineno"> 2497</span> </div>
<div class="line"><span class="lineno"> 2498</span>    <span class="comment"># Immediately handle some default, simple, fast, and common cases.</span></div>
<div class="line"><span class="lineno"> 2499</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2500</span>        ndim = x.ndim</div>
<div class="line"><span class="lineno"> 2501</span>        <span class="keywordflow">if</span> ((ord <span class="keywordflow">is</span> <span class="keywordtype">None</span>) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 2502</span>            (ord <span class="keywordflow">in</span> (<span class="stringliteral">&#39;f&#39;</span>, <span class="stringliteral">&#39;fro&#39;</span>) <span class="keywordflow">and</span> ndim == 2) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 2503</span>            (ord == 2 <span class="keywordflow">and</span> ndim == 1)):</div>
<div class="line"><span class="lineno"> 2504</span> </div>
<div class="line"><span class="lineno"> 2505</span>            x = x.ravel(order=<span class="stringliteral">&#39;K&#39;</span>)</div>
<div class="line"><span class="lineno"> 2506</span>            <span class="keywordflow">if</span> isComplexType(x.dtype.type):</div>
<div class="line"><span class="lineno"> 2507</span>                x_real = x.real</div>
<div class="line"><span class="lineno"> 2508</span>                x_imag = x.imag</div>
<div class="line"><span class="lineno"> 2509</span>                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)</div>
<div class="line"><span class="lineno"> 2510</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2511</span>                sqnorm = x.dot(x)</div>
<div class="line"><span class="lineno"> 2512</span>            ret = sqrt(sqnorm)</div>
<div class="line"><span class="lineno"> 2513</span>            <span class="keywordflow">if</span> keepdims:</div>
<div class="line"><span class="lineno"> 2514</span>                ret = ret.reshape(ndim*[1])</div>
<div class="line"><span class="lineno"> 2515</span>            <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 2516</span> </div>
<div class="line"><span class="lineno"> 2517</span>    <span class="comment"># Normalize the `axis` argument to a tuple.</span></div>
<div class="line"><span class="lineno"> 2518</span>    nd = x.ndim</div>
<div class="line"><span class="lineno"> 2519</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2520</span>        axis = tuple(range(nd))</div>
<div class="line"><span class="lineno"> 2521</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(axis, tuple):</div>
<div class="line"><span class="lineno"> 2522</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2523</span>            axis = int(axis)</div>
<div class="line"><span class="lineno"> 2524</span>        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 2525</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;&#39;axis&#39; must be None, an integer or a tuple of integers&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 2526</span>        axis = (axis,)</div>
<div class="line"><span class="lineno"> 2527</span> </div>
<div class="line"><span class="lineno"> 2528</span>    <span class="keywordflow">if</span> len(axis) == 1:</div>
<div class="line"><span class="lineno"> 2529</span>        <span class="keywordflow">if</span> ord == Inf:</div>
<div class="line"><span class="lineno"> 2530</span>            <span class="keywordflow">return</span> abs(x).max(axis=axis, keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 2531</span>        <span class="keywordflow">elif</span> ord == -Inf:</div>
<div class="line"><span class="lineno"> 2532</span>            <span class="keywordflow">return</span> abs(x).min(axis=axis, keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 2533</span>        <span class="keywordflow">elif</span> ord == 0:</div>
<div class="line"><span class="lineno"> 2534</span>            <span class="comment"># Zero norm</span></div>
<div class="line"><span class="lineno"> 2535</span>            <span class="keywordflow">return</span> (x != 0).astype(x.real.dtype).sum(axis=axis, keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 2536</span>        <span class="keywordflow">elif</span> ord == 1:</div>
<div class="line"><span class="lineno"> 2537</span>            <span class="comment"># special case for speedup</span></div>
<div class="line"><span class="lineno"> 2538</span>            <span class="keywordflow">return</span> add.reduce(abs(x), axis=axis, keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 2539</span>        <span class="keywordflow">elif</span> ord <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> ord == 2:</div>
<div class="line"><span class="lineno"> 2540</span>            <span class="comment"># special case for speedup</span></div>
<div class="line"><span class="lineno"> 2541</span>            s = (x.conj() * x).real</div>
<div class="line"><span class="lineno"> 2542</span>            <span class="keywordflow">return</span> sqrt(add.reduce(s, axis=axis, keepdims=keepdims))</div>
<div class="line"><span class="lineno"> 2543</span>        <span class="comment"># None of the str-type keywords for ord (&#39;fro&#39;, &#39;nuc&#39;)</span></div>
<div class="line"><span class="lineno"> 2544</span>        <span class="comment"># are valid for vectors</span></div>
<div class="line"><span class="lineno"> 2545</span>        <span class="keywordflow">elif</span> isinstance(ord, str):</div>
<div class="line"><span class="lineno"> 2546</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid norm order &#39;{ord}&#39; for vectors&quot;</span>)</div>
<div class="line"><span class="lineno"> 2547</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2548</span>            absx = abs(x)</div>
<div class="line"><span class="lineno"> 2549</span>            absx **= ord</div>
<div class="line"><span class="lineno"> 2550</span>            ret = add.reduce(absx, axis=axis, keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 2551</span>            ret **= reciprocal(ord, dtype=ret.dtype)</div>
<div class="line"><span class="lineno"> 2552</span>            <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 2553</span>    <span class="keywordflow">elif</span> len(axis) == 2:</div>
<div class="line"><span class="lineno"> 2554</span>        row_axis, col_axis = axis</div>
<div class="line"><span class="lineno"> 2555</span>        row_axis = normalize_axis_index(row_axis, nd)</div>
<div class="line"><span class="lineno"> 2556</span>        col_axis = normalize_axis_index(col_axis, nd)</div>
<div class="line"><span class="lineno"> 2557</span>        <span class="keywordflow">if</span> row_axis == col_axis:</div>
<div class="line"><span class="lineno"> 2558</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Duplicate axes given.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2559</span>        <span class="keywordflow">if</span> ord == 2:</div>
<div class="line"><span class="lineno"> 2560</span>            ret =  _multi_svd_norm(x, row_axis, col_axis, amax)</div>
<div class="line"><span class="lineno"> 2561</span>        <span class="keywordflow">elif</span> ord == -2:</div>
<div class="line"><span class="lineno"> 2562</span>            ret = _multi_svd_norm(x, row_axis, col_axis, amin)</div>
<div class="line"><span class="lineno"> 2563</span>        <span class="keywordflow">elif</span> ord == 1:</div>
<div class="line"><span class="lineno"> 2564</span>            <span class="keywordflow">if</span> col_axis &gt; row_axis:</div>
<div class="line"><span class="lineno"> 2565</span>                col_axis -= 1</div>
<div class="line"><span class="lineno"> 2566</span>            ret = add.reduce(abs(x), axis=row_axis).max(axis=col_axis)</div>
<div class="line"><span class="lineno"> 2567</span>        <span class="keywordflow">elif</span> ord == Inf:</div>
<div class="line"><span class="lineno"> 2568</span>            <span class="keywordflow">if</span> row_axis &gt; col_axis:</div>
<div class="line"><span class="lineno"> 2569</span>                row_axis -= 1</div>
<div class="line"><span class="lineno"> 2570</span>            ret = add.reduce(abs(x), axis=col_axis).max(axis=row_axis)</div>
<div class="line"><span class="lineno"> 2571</span>        <span class="keywordflow">elif</span> ord == -1:</div>
<div class="line"><span class="lineno"> 2572</span>            <span class="keywordflow">if</span> col_axis &gt; row_axis:</div>
<div class="line"><span class="lineno"> 2573</span>                col_axis -= 1</div>
<div class="line"><span class="lineno"> 2574</span>            ret = add.reduce(abs(x), axis=row_axis).min(axis=col_axis)</div>
<div class="line"><span class="lineno"> 2575</span>        <span class="keywordflow">elif</span> ord == -Inf:</div>
<div class="line"><span class="lineno"> 2576</span>            <span class="keywordflow">if</span> row_axis &gt; col_axis:</div>
<div class="line"><span class="lineno"> 2577</span>                row_axis -= 1</div>
<div class="line"><span class="lineno"> 2578</span>            ret = add.reduce(abs(x), axis=col_axis).min(axis=row_axis)</div>
<div class="line"><span class="lineno"> 2579</span>        <span class="keywordflow">elif</span> ord <span class="keywordflow">in</span> [<span class="keywordtype">None</span>, <span class="stringliteral">&#39;fro&#39;</span>, <span class="stringliteral">&#39;f&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2580</span>            ret = sqrt(add.reduce((x.conj() * x).real, axis=axis))</div>
<div class="line"><span class="lineno"> 2581</span>        <span class="keywordflow">elif</span> ord == <span class="stringliteral">&#39;nuc&#39;</span>:</div>
<div class="line"><span class="lineno"> 2582</span>            ret = _multi_svd_norm(x, row_axis, col_axis, sum)</div>
<div class="line"><span class="lineno"> 2583</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2584</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid norm order for matrices.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2585</span>        <span class="keywordflow">if</span> keepdims:</div>
<div class="line"><span class="lineno"> 2586</span>            ret_shape = list(x.shape)</div>
<div class="line"><span class="lineno"> 2587</span>            ret_shape[axis[0]] = 1</div>
<div class="line"><span class="lineno"> 2588</span>            ret_shape[axis[1]] = 1</div>
<div class="line"><span class="lineno"> 2589</span>            ret = ret.reshape(ret_shape)</div>
<div class="line"><span class="lineno"> 2590</span>        <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 2591</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2592</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Improper number of dimensions to norm.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2593</span> </div>
<div class="line"><span class="lineno"> 2594</span> </div>
<div class="line"><span class="lineno"> 2595</span><span class="comment"># multi_dot</span></div>
<div class="line"><span class="lineno"> 2596</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af00f981974b0138052c72eefbe4eff6a" name="af00f981974b0138052c72eefbe4eff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00f981974b0138052c72eefbe4eff6a">&#9670;&#160;</a></span>pinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.pinv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rcond</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hermitian</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
*large* singular values.

.. versionchanged:: 1.14
   Can now operate on stacks of matrices

Parameters
----------
a : (..., M, N) array_like
    Matrix or stack of matrices to be pseudo-inverted.
rcond : (...) array_like of float
    Cutoff for small singular values.
    Singular values less than or equal to
    ``rcond * largest_singular_value`` are set to zero.
    Broadcasts against the stack of matrices.
hermitian : bool, optional
    If True, `a` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.17.0

Returns
-------
B : (..., N, M) ndarray
    The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
    is `B`.

Raises
------
LinAlgError
    If the SVD computation does not converge.

See Also
--------
scipy.linalg.pinv : Similar function in SciPy.
scipy.linalg.pinvh : Compute the (Moore-Penrose) pseudo-inverse of a
                     Hermitian matrix.

Notes
-----
The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
defined as: "the matrix that 'solves' [the least-squares problem]
:math:`Ax = b`," i.e., if :math:`\\bar{x}` is said solution, then
:math:`A^+` is that matrix such that :math:`\\bar{x} = A^+b`.

It can be shown that if :math:`Q_1 \\Sigma Q_2^T = A` is the singular
value decomposition of A, then
:math:`A^+ = Q_2 \\Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are
orthogonal matrices, :math:`\\Sigma` is a diagonal matrix consisting
of A's so-called singular values, (followed, typically, by
zeros), and then :math:`\\Sigma^+` is simply the diagonal matrix
consisting of the reciprocals of A's singular values
(again, followed by zeros). [1]_

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pp. 139-142.

Examples
--------
The following example checks that ``a * a+ * a == a`` and
``a+ * a * a+ == a+``:

&gt;&gt;&gt; a = np.random.randn(9, 6)
&gt;&gt;&gt; B = np.linalg.pinv(a)
&gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))
True
&gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1898</span><span class="keyword">def </span>pinv(a, rcond=1e-15, hermitian=False):</div>
<div class="line"><span class="lineno"> 1899</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    Compute the (Moore-Penrose) pseudo-inverse of a matrix.</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">    Calculate the generalized inverse of a matrix using its</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">    singular-value decomposition (SVD) and including all</span></div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">    *large* singular values.</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">    .. versionchanged:: 1.14</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">       Can now operate on stacks of matrices</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">    a : (..., M, N) array_like</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">        Matrix or stack of matrices to be pseudo-inverted.</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">    rcond : (...) array_like of float</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">        Cutoff for small singular values.</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">        Singular values less than or equal to</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">        ``rcond * largest_singular_value`` are set to zero.</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">        Broadcasts against the stack of matrices.</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral">    hermitian : bool, optional</span></div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">        If True, `a` is assumed to be Hermitian (symmetric if real-valued),</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">        enabling a more efficient method for finding singular values.</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">        Defaults to False.</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral">    B : (..., N, M) ndarray</span></div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">        The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral">        is `B`.</span></div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral">        If the SVD computation does not converge.</span></div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral">    scipy.linalg.pinv : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral">    scipy.linalg.pinvh : Compute the (Moore-Penrose) pseudo-inverse of a</span></div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral">                         Hermitian matrix.</span></div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">    The pseudo-inverse of a matrix A, denoted :math:`A^+`, is</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">    defined as: &quot;the matrix that &#39;solves&#39; [the least-squares problem]</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">    :math:`Ax = b`,&quot; i.e., if :math:`\\bar{x}` is said solution, then</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">    :math:`A^+` is that matrix such that :math:`\\bar{x} = A^+b`.</span></div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral">    It can be shown that if :math:`Q_1 \\Sigma Q_2^T = A` is the singular</span></div>
<div class="line"><span class="lineno"> 1950</span><span class="stringliteral">    value decomposition of A, then</span></div>
<div class="line"><span class="lineno"> 1951</span><span class="stringliteral">    :math:`A^+ = Q_2 \\Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are</span></div>
<div class="line"><span class="lineno"> 1952</span><span class="stringliteral">    orthogonal matrices, :math:`\\Sigma` is a diagonal matrix consisting</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral">    of A&#39;s so-called singular values, (followed, typically, by</span></div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">    zeros), and then :math:`\\Sigma^+` is simply the diagonal matrix</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">    consisting of the reciprocals of A&#39;s singular values</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral">    (again, followed by zeros). [1]_</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">           FL, Academic Press, Inc., 1980, pp. 139-142.</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">    The following example checks that ``a * a+ * a == a`` and</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">    ``a+ * a * a+ == a+``:</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">    &gt;&gt;&gt; a = np.random.randn(9, 6)</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">    &gt;&gt;&gt; B = np.linalg.pinv(a)</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1976</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno"> 1977</span>    rcond = asarray(rcond)</div>
<div class="line"><span class="lineno"> 1978</span>    <span class="keywordflow">if</span> _is_empty_2d(a):</div>
<div class="line"><span class="lineno"> 1979</span>        m, n = a.shape[-2:]</div>
<div class="line"><span class="lineno"> 1980</span>        res = empty(a.shape[:-2] + (n, m), dtype=a.dtype)</div>
<div class="line"><span class="lineno"> 1981</span>        <span class="keywordflow">return</span> wrap(res)</div>
<div class="line"><span class="lineno"> 1982</span>    a = a.conjugate()</div>
<div class="line"><span class="lineno"> 1983</span>    u, s, vt = svd(a, full_matrices=<span class="keyword">False</span>, hermitian=hermitian)</div>
<div class="line"><span class="lineno"> 1984</span> </div>
<div class="line"><span class="lineno"> 1985</span>    <span class="comment"># discard small singular values</span></div>
<div class="line"><span class="lineno"> 1986</span>    cutoff = rcond[..., newaxis] * amax(s, axis=-1, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1987</span>    large = s &gt; cutoff</div>
<div class="line"><span class="lineno"> 1988</span>    s = divide(1, s, where=large, out=s)</div>
<div class="line"><span class="lineno"> 1989</span>    s[~large] = 0</div>
<div class="line"><span class="lineno"> 1990</span> </div>
<div class="line"><span class="lineno"> 1991</span>    res = matmul(transpose(vt), multiply(s[..., newaxis], transpose(u)))</div>
<div class="line"><span class="lineno"> 1992</span>    <span class="keywordflow">return</span> wrap(res)</div>
<div class="line"><span class="lineno"> 1993</span> </div>
<div class="line"><span class="lineno"> 1994</span> </div>
<div class="line"><span class="lineno"> 1995</span><span class="comment"># Determinant</span></div>
<div class="line"><span class="lineno"> 1996</span> </div>
<div class="line"><span class="lineno"> 1997</span> </div>
<div class="line"><span class="lineno"> 1998</span><span class="preprocessor">@array_function_dispatch(_unary_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aff2be88b893be73b57a619b251238af5" name="aff2be88b893be73b57a619b251238af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2be88b893be73b57a619b251238af5">&#9670;&#160;</a></span>qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.qr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'reduced'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the qr factorization of a matrix.

Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
upper-triangular.

Parameters
----------
a : array_like, shape (..., M, N)
    An array-like object with the dimensionality of at least 2.
mode : {'reduced', 'complete', 'r', 'raw'}, optional
    If K = min(M, N), then

    * 'reduced'  : returns q, r with dimensions
                   (..., M, K), (..., K, N) (default)
    * 'complete' : returns q, r with dimensions (..., M, M), (..., M, N)
    * 'r'        : returns r only with dimensions (..., K, N)
    * 'raw'      : returns h, tau with dimensions (..., N, M), (..., K,)

    The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
    see the notes for more information. The default is 'reduced', and to
    maintain backward compatibility with earlier versions of numpy both
    it and the old default 'full' can be omitted. Note that array h
    returned in 'raw' mode is transposed for calling Fortran. The
    'economic' mode is deprecated.  The modes 'full' and 'economic' may
    be passed using only the first letter for backwards compatibility,
    but all others must be spelled out. See the Notes for more
    explanation.


Returns
-------
q : ndarray of float or complex, optional
    A matrix with orthonormal columns. When mode = 'complete' the
    result is an orthogonal/unitary matrix depending on whether or not
    a is real/complex. The determinant may be either +/- 1 in that
    case. In case the number of dimensions in the input array is
    greater than 2 then a stack of the matrices with above properties
    is returned.
r : ndarray of float or complex, optional
    The upper-triangular matrix or a stack of upper-triangular
    matrices if the number of dimensions in the input array is greater
    than 2.
(h, tau) : ndarrays of np.double or np.cdouble, optional
    The array h contains the Householder reflectors that generate q
    along with r. The tau array contains scaling factors for the
    reflectors. In the deprecated  'economic' mode only h is returned.

Raises
------
LinAlgError
    If factoring fails.

See Also
--------
scipy.linalg.qr : Similar function in SciPy.
scipy.linalg.rq : Compute RQ decomposition of a matrix.

Notes
-----
This is an interface to the LAPACK routines ``dgeqrf``, ``zgeqrf``,
``dorgqr``, and ``zungqr``.

For more information on the qr factorization, see for example:
https://en.wikipedia.org/wiki/QR_factorization

Subclasses of `ndarray` are preserved except for the 'raw' mode. So if
`a` is of type `matrix`, all the return values will be matrices too.

New 'reduced', 'complete', and 'raw' options for mode were added in
NumPy 1.8.0 and the old option 'full' was made an alias of 'reduced'.  In
addition the options 'full' and 'economic' were deprecated.  Because
'full' was the previous default and 'reduced' is the new default,
backward compatibility can be maintained by letting `mode` default.
The 'raw' option was added so that LAPACK routines that can multiply
arrays by q using the Householder reflectors can be used. Note that in
this case the returned arrays are of type np.double or np.cdouble and
the h array is transposed to be FORTRAN compatible.  No routines using
the 'raw' return are currently exposed by numpy, but some are available
in lapack_lite and just await the necessary work.

Examples
--------
&gt;&gt;&gt; a = np.random.randn(9, 6)
&gt;&gt;&gt; q, r = np.linalg.qr(a)
&gt;&gt;&gt; np.allclose(a, np.dot(q, r))  # a does equal qr
True
&gt;&gt;&gt; r2 = np.linalg.qr(a, mode='r')
&gt;&gt;&gt; np.allclose(r, r2)  # mode='r' returns the same r as mode='full'
True
&gt;&gt;&gt; a = np.random.normal(size=(3, 2, 2)) # Stack of 2 x 2 matrices as input
&gt;&gt;&gt; q, r = np.linalg.qr(a)
&gt;&gt;&gt; q.shape
(3, 2, 2)
&gt;&gt;&gt; r.shape
(3, 2, 2)
&gt;&gt;&gt; np.allclose(a, np.matmul(q, r))
True

Example illustrating a common use of `qr`: solving of least squares
problems

What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
and you'll see that it should be y0 = 0, m = 1.)  The answer is provided
by solving the over-determined matrix equation ``Ax = b``, where::

  A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
  x = array([[y0], [m]])
  b = array([[1], [0], [2], [1]])

If A = qr such that q is orthonormal (which is always possible via
Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,
however, we simply use `lstsq`.)

&gt;&gt;&gt; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
&gt;&gt;&gt; A
array([[0, 1],
       [1, 1],
       [1, 1],
       [2, 1]])
&gt;&gt;&gt; b = np.array([1, 2, 2, 3])
&gt;&gt;&gt; q, r = np.linalg.qr(A)
&gt;&gt;&gt; p = np.dot(q.T, b)
&gt;&gt;&gt; np.dot(np.linalg.inv(r), p)
array([  1.,   1.])</pre> <div class="fragment"><div class="line"><span class="lineno">  767</span><span class="keyword">def </span>qr(a, mode=&#39;reduced&#39;):</div>
<div class="line"><span class="lineno">  768</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    Compute the qr factorization of a matrix.</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    upper-triangular.</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    a : array_like, shape (..., M, N)</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">        An array-like object with the dimensionality of at least 2.</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    mode : {&#39;reduced&#39;, &#39;complete&#39;, &#39;r&#39;, &#39;raw&#39;}, optional</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        If K = min(M, N), then</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">        * &#39;reduced&#39;  : returns q, r with dimensions</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">                       (..., M, K), (..., K, N) (default)</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        * &#39;complete&#39; : returns q, r with dimensions (..., M, M), (..., M, N)</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        * &#39;r&#39;        : returns r only with dimensions (..., K, N)</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        * &#39;raw&#39;      : returns h, tau with dimensions (..., N, M), (..., K,)</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        The options &#39;reduced&#39;, &#39;complete, and &#39;raw&#39; are new in numpy 1.8,</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        see the notes for more information. The default is &#39;reduced&#39;, and to</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">        maintain backward compatibility with earlier versions of numpy both</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">        it and the old default &#39;full&#39; can be omitted. Note that array h</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">        returned in &#39;raw&#39; mode is transposed for calling Fortran. The</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        &#39;economic&#39; mode is deprecated.  The modes &#39;full&#39; and &#39;economic&#39; may</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">        be passed using only the first letter for backwards compatibility,</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        but all others must be spelled out. See the Notes for more</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        explanation.</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    q : ndarray of float or complex, optional</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">        A matrix with orthonormal columns. When mode = &#39;complete&#39; the</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">        result is an orthogonal/unitary matrix depending on whether or not</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">        a is real/complex. The determinant may be either +/- 1 in that</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        case. In case the number of dimensions in the input array is</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        greater than 2 then a stack of the matrices with above properties</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        is returned.</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    r : ndarray of float or complex, optional</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        The upper-triangular matrix or a stack of upper-triangular</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        matrices if the number of dimensions in the input array is greater</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">        than 2.</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    (h, tau) : ndarrays of np.double or np.cdouble, optional</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">        The array h contains the Householder reflectors that generate q</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">        along with r. The tau array contains scaling factors for the</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">        reflectors. In the deprecated  &#39;economic&#39; mode only h is returned.</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        If factoring fails.</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    scipy.linalg.qr : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    scipy.linalg.rq : Compute RQ decomposition of a matrix.</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    This is an interface to the LAPACK routines ``dgeqrf``, ``zgeqrf``,</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    ``dorgqr``, and ``zungqr``.</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    For more information on the qr factorization, see for example:</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    https://en.wikipedia.org/wiki/QR_factorization</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    Subclasses of `ndarray` are preserved except for the &#39;raw&#39; mode. So if</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    `a` is of type `matrix`, all the return values will be matrices too.</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    New &#39;reduced&#39;, &#39;complete&#39;, and &#39;raw&#39; options for mode were added in</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    NumPy 1.8.0 and the old option &#39;full&#39; was made an alias of &#39;reduced&#39;.  In</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    addition the options &#39;full&#39; and &#39;economic&#39; were deprecated.  Because</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    &#39;full&#39; was the previous default and &#39;reduced&#39; is the new default,</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    backward compatibility can be maintained by letting `mode` default.</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    The &#39;raw&#39; option was added so that LAPACK routines that can multiply</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">    arrays by q using the Householder reflectors can be used. Note that in</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    this case the returned arrays are of type np.double or np.cdouble and</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    the h array is transposed to be FORTRAN compatible.  No routines using</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    the &#39;raw&#39; return are currently exposed by numpy, but some are available</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    in lapack_lite and just await the necessary work.</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    &gt;&gt;&gt; a = np.random.randn(9, 6)</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    &gt;&gt;&gt; q, r = np.linalg.qr(a)</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, np.dot(q, r))  # a does equal qr</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    &gt;&gt;&gt; r2 = np.linalg.qr(a, mode=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(r, r2)  # mode=&#39;r&#39; returns the same r as mode=&#39;full&#39;</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    &gt;&gt;&gt; a = np.random.normal(size=(3, 2, 2)) # Stack of 2 x 2 matrices as input</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    &gt;&gt;&gt; q, r = np.linalg.qr(a)</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    &gt;&gt;&gt; q.shape</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    (3, 2, 2)</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    &gt;&gt;&gt; r.shape</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    (3, 2, 2)</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, np.matmul(q, r))</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    Example illustrating a common use of `qr`: solving of least squares</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    problems</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    and you&#39;ll see that it should be y0 = 0, m = 1.)  The answer is provided</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    by solving the over-determined matrix equation ``Ax = b``, where::</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">      A = array([[0, 1], [1, 1], [1, 1], [2, 1]])</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">      x = array([[y0], [m]])</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">      b = array([[1], [0], [2], [1]])</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    If A = qr such that q is orthonormal (which is always possible via</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    however, we simply use `lstsq`.)</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    &gt;&gt;&gt; A</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">           [1, 1],</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">           [1, 1],</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">           [2, 1]])</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 2, 2, 3])</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    &gt;&gt;&gt; q, r = np.linalg.qr(A)</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    &gt;&gt;&gt; p = np.dot(q.T, b)</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(np.linalg.inv(r), p)</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    array([  1.,   1.])</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  896</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;reduced&#39;</span>, <span class="stringliteral">&#39;complete&#39;</span>, <span class="stringliteral">&#39;r&#39;</span>, <span class="stringliteral">&#39;raw&#39;</span>):</div>
<div class="line"><span class="lineno">  897</span>        <span class="keywordflow">if</span> mode <span class="keywordflow">in</span> (<span class="stringliteral">&#39;f&#39;</span>, <span class="stringliteral">&#39;full&#39;</span>):</div>
<div class="line"><span class="lineno">  898</span>            <span class="comment"># 2013-04-01, 1.8</span></div>
<div class="line"><span class="lineno">  899</span>            msg = <span class="stringliteral">&quot;&quot;</span>.join((</div>
<div class="line"><span class="lineno">  900</span>                    <span class="stringliteral">&quot;The &#39;full&#39; option is deprecated in favor of &#39;reduced&#39;.\n&quot;</span>,</div>
<div class="line"><span class="lineno">  901</span>                    <span class="stringliteral">&quot;For backward compatibility let mode default.&quot;</span>))</div>
<div class="line"><span class="lineno">  902</span>            warnings.warn(msg, DeprecationWarning, stacklevel=3)</div>
<div class="line"><span class="lineno">  903</span>            mode = <span class="stringliteral">&#39;reduced&#39;</span></div>
<div class="line"><span class="lineno">  904</span>        <span class="keywordflow">elif</span> mode <span class="keywordflow">in</span> (<span class="stringliteral">&#39;e&#39;</span>, <span class="stringliteral">&#39;economic&#39;</span>):</div>
<div class="line"><span class="lineno">  905</span>            <span class="comment"># 2013-04-01, 1.8</span></div>
<div class="line"><span class="lineno">  906</span>            msg = <span class="stringliteral">&quot;The &#39;economic&#39; option is deprecated.&quot;</span></div>
<div class="line"><span class="lineno">  907</span>            warnings.warn(msg, DeprecationWarning, stacklevel=3)</div>
<div class="line"><span class="lineno">  908</span>            mode = <span class="stringliteral">&#39;economic&#39;</span></div>
<div class="line"><span class="lineno">  909</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  910</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Unrecognized mode &#39;{mode}&#39;&quot;</span>)</div>
<div class="line"><span class="lineno">  911</span> </div>
<div class="line"><span class="lineno">  912</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno">  913</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno">  914</span>    m, n = a.shape[-2:]</div>
<div class="line"><span class="lineno">  915</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno">  916</span>    a = a.astype(t, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  917</span>    a = _to_native_byte_order(a)</div>
<div class="line"><span class="lineno">  918</span>    mn = min(m, n)</div>
<div class="line"><span class="lineno">  919</span> </div>
<div class="line"><span class="lineno">  920</span>    <span class="keywordflow">if</span> m &lt;= n:</div>
<div class="line"><span class="lineno">  921</span>        gufunc = _umath_linalg.qr_r_raw_m</div>
<div class="line"><span class="lineno">  922</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  923</span>        gufunc = _umath_linalg.qr_r_raw_n</div>
<div class="line"><span class="lineno">  924</span> </div>
<div class="line"><span class="lineno">  925</span>    signature = <span class="stringliteral">&#39;D-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;d&#39;</span></div>
<div class="line"><span class="lineno">  926</span>    extobj = get_linalg_error_extobj(_raise_linalgerror_qr)</div>
<div class="line"><span class="lineno">  927</span>    tau = gufunc(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno">  928</span> </div>
<div class="line"><span class="lineno">  929</span>    <span class="comment"># handle modes that don&#39;t return q</span></div>
<div class="line"><span class="lineno">  930</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;r&#39;</span>:</div>
<div class="line"><span class="lineno">  931</span>        r = triu(a[..., :mn, :])</div>
<div class="line"><span class="lineno">  932</span>        r = r.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  933</span>        <span class="keywordflow">return</span> wrap(r)</div>
<div class="line"><span class="lineno">  934</span> </div>
<div class="line"><span class="lineno">  935</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;raw&#39;</span>:</div>
<div class="line"><span class="lineno">  936</span>        q = transpose(a)</div>
<div class="line"><span class="lineno">  937</span>        q = q.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  938</span>        tau = tau.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  939</span>        <span class="keywordflow">return</span> wrap(q), tau</div>
<div class="line"><span class="lineno">  940</span> </div>
<div class="line"><span class="lineno">  941</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;economic&#39;</span>:</div>
<div class="line"><span class="lineno">  942</span>        a = a.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  943</span>        <span class="keywordflow">return</span> wrap(a)</div>
<div class="line"><span class="lineno">  944</span> </div>
<div class="line"><span class="lineno">  945</span>    <span class="comment"># mc is the number of columns in the resulting q</span></div>
<div class="line"><span class="lineno">  946</span>    <span class="comment"># matrix. If the mode is complete then it is </span></div>
<div class="line"><span class="lineno">  947</span>    <span class="comment"># same as number of rows, and if the mode is reduced,</span></div>
<div class="line"><span class="lineno">  948</span>    <span class="comment"># then it is the minimum of number of rows and columns.</span></div>
<div class="line"><span class="lineno">  949</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;complete&#39;</span> <span class="keywordflow">and</span> m &gt; n:</div>
<div class="line"><span class="lineno">  950</span>        mc = m</div>
<div class="line"><span class="lineno">  951</span>        gufunc = _umath_linalg.qr_complete</div>
<div class="line"><span class="lineno">  952</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  953</span>        mc = mn</div>
<div class="line"><span class="lineno">  954</span>        gufunc = _umath_linalg.qr_reduced</div>
<div class="line"><span class="lineno">  955</span> </div>
<div class="line"><span class="lineno">  956</span>    signature = <span class="stringliteral">&#39;DD-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;dd-&gt;d&#39;</span></div>
<div class="line"><span class="lineno">  957</span>    extobj = get_linalg_error_extobj(_raise_linalgerror_qr)</div>
<div class="line"><span class="lineno">  958</span>    q = gufunc(a, tau, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno">  959</span>    r = triu(a[..., :mc, :])</div>
<div class="line"><span class="lineno">  960</span> </div>
<div class="line"><span class="lineno">  961</span>    q = q.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  962</span>    r = r.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  963</span> </div>
<div class="line"><span class="lineno">  964</span>    <span class="keywordflow">return</span> wrap(q), wrap(r)</div>
<div class="line"><span class="lineno">  965</span> </div>
<div class="line"><span class="lineno">  966</span><span class="comment"># Eigenvalues</span></div>
<div class="line"><span class="lineno">  967</span> </div>
<div class="line"><span class="lineno">  968</span> </div>
<div class="line"><span class="lineno">  969</span><span class="preprocessor">@array_function_dispatch(_unary_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a209de2fe316cc96d6ccd173f1bb86591" name="a209de2fe316cc96d6ccd173f1bb86591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209de2fe316cc96d6ccd173f1bb86591">&#9670;&#160;</a></span>slogdet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.slogdet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the sign and (natural) logarithm of the determinant of an array.

If an array has a very small or very large determinant, then a call to
`det` may overflow or underflow. This routine is more robust against such
issues, because it computes the logarithm of the determinant rather than
the determinant itself.

Parameters
----------
a : (..., M, M) array_like
    Input array, has to be a square 2-D array.

Returns
-------
sign : (...) array_like
    A number representing the sign of the determinant. For a real matrix,
    this is 1, 0, or -1. For a complex matrix, this is a complex number
    with absolute value 1 (i.e., it is on the unit circle), or else 0.
logdet : (...) array_like
    The natural log of the absolute value of the determinant.

If the determinant is zero, then `sign` will be 0 and `logdet` will be
-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.

See Also
--------
det

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

.. versionadded:: 1.6.0

The determinant is computed via LU factorization using the LAPACK
routine ``z/dgetrf``.


Examples
--------
The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:

&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; (sign, logdet) = np.linalg.slogdet(a)
&gt;&gt;&gt; (sign, logdet)
(-1, 0.69314718055994529) # may vary
&gt;&gt;&gt; sign * np.exp(logdet)
-2.0

Computing log-determinants for a stack of matrices:

&gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
&gt;&gt;&gt; a.shape
(3, 2, 2)
&gt;&gt;&gt; sign, logdet = np.linalg.slogdet(a)
&gt;&gt;&gt; (sign, logdet)
(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
&gt;&gt;&gt; sign * np.exp(logdet)
array([-2., -3., -8.])

This routine succeeds where ordinary `det` does not:

&gt;&gt;&gt; np.linalg.det(np.eye(500) * 0.1)
0.0
&gt;&gt;&gt; np.linalg.slogdet(np.eye(500) * 0.1)
(1, -1151.2925464970228)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1999</span><span class="keyword">def </span>slogdet(a):</div>
<div class="line"><span class="lineno"> 2000</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">    Compute the sign and (natural) logarithm of the determinant of an array.</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral">    If an array has a very small or very large determinant, then a call to</span></div>
<div class="line"><span class="lineno"> 2004</span><span class="stringliteral">    `det` may overflow or underflow. This routine is more robust against such</span></div>
<div class="line"><span class="lineno"> 2005</span><span class="stringliteral">    issues, because it computes the logarithm of the determinant rather than</span></div>
<div class="line"><span class="lineno"> 2006</span><span class="stringliteral">    the determinant itself.</span></div>
<div class="line"><span class="lineno"> 2007</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2008</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral">        Input array, has to be a square 2-D array.</span></div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">    sign : (...) array_like</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral">        A number representing the sign of the determinant. For a real matrix,</span></div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral">        this is 1, 0, or -1. For a complex matrix, this is a complex number</span></div>
<div class="line"><span class="lineno"> 2018</span><span class="stringliteral">        with absolute value 1 (i.e., it is on the unit circle), or else 0.</span></div>
<div class="line"><span class="lineno"> 2019</span><span class="stringliteral">    logdet : (...) array_like</span></div>
<div class="line"><span class="lineno"> 2020</span><span class="stringliteral">        The natural log of the absolute value of the determinant.</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">    If the determinant is zero, then `sign` will be 0 and `logdet` will be</span></div>
<div class="line"><span class="lineno"> 2023</span><span class="stringliteral">    -Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.</span></div>
<div class="line"><span class="lineno"> 2024</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2025</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2026</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2027</span><span class="stringliteral">    det</span></div>
<div class="line"><span class="lineno"> 2028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2029</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2030</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2031</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2032</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 2033</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2034</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno"> 2035</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno"> 2036</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">    The determinant is computed via LU factorization using the LAPACK</span></div>
<div class="line"><span class="lineno"> 2040</span><span class="stringliteral">    routine ``z/dgetrf``.</span></div>
<div class="line"><span class="lineno"> 2041</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2043</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2044</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2045</span><span class="stringliteral">    The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:</span></div>
<div class="line"><span class="lineno"> 2046</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2047</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span></div>
<div class="line"><span class="lineno"> 2048</span><span class="stringliteral">    &gt;&gt;&gt; (sign, logdet) = np.linalg.slogdet(a)</span></div>
<div class="line"><span class="lineno"> 2049</span><span class="stringliteral">    &gt;&gt;&gt; (sign, logdet)</span></div>
<div class="line"><span class="lineno"> 2050</span><span class="stringliteral">    (-1, 0.69314718055994529) # may vary</span></div>
<div class="line"><span class="lineno"> 2051</span><span class="stringliteral">    &gt;&gt;&gt; sign * np.exp(logdet)</span></div>
<div class="line"><span class="lineno"> 2052</span><span class="stringliteral">    -2.0</span></div>
<div class="line"><span class="lineno"> 2053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2054</span><span class="stringliteral">    Computing log-determinants for a stack of matrices:</span></div>
<div class="line"><span class="lineno"> 2055</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2056</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])</span></div>
<div class="line"><span class="lineno"> 2057</span><span class="stringliteral">    &gt;&gt;&gt; a.shape</span></div>
<div class="line"><span class="lineno"> 2058</span><span class="stringliteral">    (3, 2, 2)</span></div>
<div class="line"><span class="lineno"> 2059</span><span class="stringliteral">    &gt;&gt;&gt; sign, logdet = np.linalg.slogdet(a)</span></div>
<div class="line"><span class="lineno"> 2060</span><span class="stringliteral">    &gt;&gt;&gt; (sign, logdet)</span></div>
<div class="line"><span class="lineno"> 2061</span><span class="stringliteral">    (array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))</span></div>
<div class="line"><span class="lineno"> 2062</span><span class="stringliteral">    &gt;&gt;&gt; sign * np.exp(logdet)</span></div>
<div class="line"><span class="lineno"> 2063</span><span class="stringliteral">    array([-2., -3., -8.])</span></div>
<div class="line"><span class="lineno"> 2064</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2065</span><span class="stringliteral">    This routine succeeds where ordinary `det` does not:</span></div>
<div class="line"><span class="lineno"> 2066</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2067</span><span class="stringliteral">    &gt;&gt;&gt; np.linalg.det(np.eye(500) * 0.1)</span></div>
<div class="line"><span class="lineno"> 2068</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 2069</span><span class="stringliteral">    &gt;&gt;&gt; np.linalg.slogdet(np.eye(500) * 0.1)</span></div>
<div class="line"><span class="lineno"> 2070</span><span class="stringliteral">    (1, -1151.2925464970228)</span></div>
<div class="line"><span class="lineno"> 2071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2072</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2073</span>    a = asarray(a)</div>
<div class="line"><span class="lineno"> 2074</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno"> 2075</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno"> 2076</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 2077</span>    real_t = _realType(result_t)</div>
<div class="line"><span class="lineno"> 2078</span>    signature = <span class="stringliteral">&#39;D-&gt;Dd&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;dd&#39;</span></div>
<div class="line"><span class="lineno"> 2079</span>    sign, logdet = _umath_linalg.slogdet(a, signature=signature)</div>
<div class="line"><span class="lineno"> 2080</span>    sign = sign.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2081</span>    logdet = logdet.astype(real_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2082</span>    <span class="keywordflow">return</span> sign, logdet</div>
<div class="line"><span class="lineno"> 2083</span> </div>
<div class="line"><span class="lineno"> 2084</span> </div>
<div class="line"><span class="lineno"> 2085</span><span class="preprocessor">@array_function_dispatch(_unary_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a21a52eeca46e495eb5c1d0549d35e4" name="a4a21a52eeca46e495eb5c1d0549d35e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a21a52eeca46e495eb5c1d0549d35e4">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a linear matrix equation, or system of linear scalar equations.

Computes the "exact" solution, `x`, of the well-determined, i.e., full
rank, linear matrix equation `ax = b`.

Parameters
----------
a : (..., M, M) array_like
    Coefficient matrix.
b : {(..., M,), (..., M, K)}, array_like
    Ordinate or "dependent variable" values.

Returns
-------
x : {(..., M,), (..., M, K)} ndarray
    Solution to the system a x = b.  Returned shape is identical to `b`.

Raises
------
LinAlgError
    If `a` is singular or not square.

See Also
--------
scipy.linalg.solve : Similar function in SciPy.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The solutions are computed using LAPACK routine ``_gesv``.

`a` must be square and of full-rank, i.e., all rows (or, equivalently,
columns) must be linearly independent; if either is not true, use
`lstsq` for the least-squares best "solution" of the
system/equation.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 22.

Examples
--------
Solve the system of equations ``x0 + 2 * x1 = 1`` and ``3 * x0 + 5 * x1 = 2``:

&gt;&gt;&gt; a = np.array([[1, 2], [3, 5]])
&gt;&gt;&gt; b = np.array([1, 2])
&gt;&gt;&gt; x = np.linalg.solve(a, b)
&gt;&gt;&gt; x
array([-1.,  1.])

Check that the solution is correct:

&gt;&gt;&gt; np.allclose(np.dot(a, x), b)
True</pre> <div class="fragment"><div class="line"><span class="lineno">  307</span><span class="keyword">def </span>solve(a, b):</div>
<div class="line"><span class="lineno">  308</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    Solve a linear matrix equation, or system of linear scalar equations.</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    Computes the &quot;exact&quot; solution, `x`, of the well-determined, i.e., full</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    rank, linear matrix equation `ax = b`.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    a : (..., M, M) array_like</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        Coefficient matrix.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    b : {(..., M,), (..., M, K)}, array_like</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        Ordinate or &quot;dependent variable&quot; values.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    x : {(..., M,), (..., M, K)} ndarray</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        Solution to the system a x = b.  Returned shape is identical to `b`.</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        If `a` is singular or not square.</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    scipy.linalg.solve : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    details.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    The solutions are computed using LAPACK routine ``_gesv``.</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    `a` must be square and of full-rank, i.e., all rows (or, equivalently,</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    columns) must be linearly independent; if either is not true, use</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    `lstsq` for the least-squares best &quot;solution&quot; of the</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    system/equation.</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">           FL, Academic Press, Inc., 1980, pg. 22.</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    Solve the system of equations ``x0 + 2 * x1 = 1`` and ``3 * x0 + 5 * x1 = 2``:</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 5]])</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1, 2])</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linalg.solve(a, b)</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    array([-1.,  1.])</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    Check that the solution is correct:</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(np.dot(a, x), b)</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  371</span>    a, _ = _makearray(a)</div>
<div class="line"><span class="lineno">  372</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno">  373</span>    _assert_stacked_square(a)</div>
<div class="line"><span class="lineno">  374</span>    b, wrap = _makearray(b)</div>
<div class="line"><span class="lineno">  375</span>    t, result_t = _commonType(a, b)</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span>    <span class="comment"># We use the b = (..., M,) logic, only if the number of extra dimensions</span></div>
<div class="line"><span class="lineno">  378</span>    <span class="comment"># match exactly</span></div>
<div class="line"><span class="lineno">  379</span>    <span class="keywordflow">if</span> b.ndim == a.ndim - 1:</div>
<div class="line"><span class="lineno">  380</span>        gufunc = _umath_linalg.solve1</div>
<div class="line"><span class="lineno">  381</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  382</span>        gufunc = _umath_linalg.solve</div>
<div class="line"><span class="lineno">  383</span> </div>
<div class="line"><span class="lineno">  384</span>    signature = <span class="stringliteral">&#39;DD-&gt;D&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;dd-&gt;d&#39;</span></div>
<div class="line"><span class="lineno">  385</span>    extobj = get_linalg_error_extobj(_raise_linalgerror_singular)</div>
<div class="line"><span class="lineno">  386</span>    r = gufunc(a, b, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">return</span> wrap(r.astype(result_t, copy=<span class="keyword">False</span>))</div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac87161c382942444130ad2df8e3c1c65" name="ac87161c382942444130ad2df8e3c1c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87161c382942444130ad2df8e3c1c65">&#9670;&#160;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_matrices</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_uv</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hermitian</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Singular Value Decomposition.

When `a` is a 2D array, and ``full_matrices=False``, then it is
factorized as ``u @ np.diag(s) @ vh = (u * s) @ vh``, where
`u` and the Hermitian transpose of `vh` are 2D arrays with
orthonormal columns and `s` is a 1D array of `a`'s singular
values. When `a` is higher-dimensional, SVD is applied in
stacked mode as explained below.

Parameters
----------
a : (..., M, N) array_like
    A real or complex array with ``a.ndim &gt;= 2``.
full_matrices : bool, optional
    If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and
    ``(..., N, N)``, respectively.  Otherwise, the shapes are
    ``(..., M, K)`` and ``(..., K, N)``, respectively, where
    ``K = min(M, N)``.
compute_uv : bool, optional
    Whether or not to compute `u` and `vh` in addition to `s`.  True
    by default.
hermitian : bool, optional
    If True, `a` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.17.0

Returns
-------
u : { (..., M, M), (..., M, K) } array
    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`. The size of the last two dimensions
    depends on the value of `full_matrices`. Only returned when
    `compute_uv` is True.
s : (..., K) array
    Vector(s) with the singular values, within each vector sorted in
    descending order. The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`.
vh : { (..., N, N), (..., K, N) } array
    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`. The size of the last two dimensions
    depends on the value of `full_matrices`. Only returned when
    `compute_uv` is True.

Raises
------
LinAlgError
    If SVD computation does not converge.

See Also
--------
scipy.linalg.svd : Similar function in SciPy.
scipy.linalg.svdvals : Compute singular values of a matrix.

Notes
-----

.. versionchanged:: 1.8.0
   Broadcasting rules apply, see the `numpy.linalg` documentation for
   details.

The decomposition is performed using LAPACK routine ``_gesdd``.

SVD is usually described for the factorization of a 2D matrix :math:`A`.
The higher-dimensional case will be discussed below. In the 2D case, SVD is
written as :math:`A = U S V^H`, where :math:`A = a`, :math:`U= u`,
:math:`S= \\mathtt{np.diag}(s)` and :math:`V^H = vh`. The 1D array `s`
contains the singular values of `a` and `u` and `vh` are unitary. The rows
of `vh` are the eigenvectors of :math:`A^H A` and the columns of `u` are
the eigenvectors of :math:`A A^H`. In both cases the corresponding
(possibly non-zero) eigenvalues are given by ``s**2``.

If `a` has more than two dimensions, then broadcasting rules apply, as
explained in :ref:`routines.linalg-broadcasting`. This means that SVD is
working in "stacked" mode: it iterates over all indices of the first
``a.ndim - 2`` dimensions and for each combination SVD is applied to the
last two indices. The matrix `a` can be reconstructed from the
decomposition with either ``(u * s[..., None, :]) @ vh`` or
``u @ (s[..., None] * vh)``. (The ``@`` operator can be replaced by the
function ``np.matmul`` for python versions below 3.5.)

If `a` is a ``matrix`` object (as opposed to an ``ndarray``), then so are
all the return values.

Examples
--------
&gt;&gt;&gt; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)
&gt;&gt;&gt; b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)

Reconstruction based on full SVD, 2D case:

&gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=True)
&gt;&gt;&gt; u.shape, s.shape, vh.shape
((9, 9), (6,), (6, 6))
&gt;&gt;&gt; np.allclose(a, np.dot(u[:, :6] * s, vh))
True
&gt;&gt;&gt; smat = np.zeros((9, 6), dtype=complex)
&gt;&gt;&gt; smat[:6, :6] = np.diag(s)
&gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))
True

Reconstruction based on reduced SVD, 2D case:

&gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=False)
&gt;&gt;&gt; u.shape, s.shape, vh.shape
((9, 6), (6,), (6, 6))
&gt;&gt;&gt; np.allclose(a, np.dot(u * s, vh))
True
&gt;&gt;&gt; smat = np.diag(s)
&gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))
True

Reconstruction based on full SVD, 4D case:

&gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=True)
&gt;&gt;&gt; u.shape, s.shape, vh.shape
((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
&gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))
True
&gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))
True

Reconstruction based on reduced SVD, 4D case:

&gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=False)
&gt;&gt;&gt; u.shape, s.shape, vh.shape
((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
&gt;&gt;&gt; np.allclose(b, np.matmul(u * s[..., None, :], vh))
True
&gt;&gt;&gt; np.allclose(b, np.matmul(u, s[..., None] * vh))
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 1464</span><span class="keyword">def </span>svd(a, full_matrices=True, compute_uv=True, hermitian=False):</div>
<div class="line"><span class="lineno"> 1465</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    Singular Value Decomposition.</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">    When `a` is a 2D array, and ``full_matrices=False``, then it is</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">    factorized as ``u @ np.diag(s) @ vh = (u * s) @ vh``, where</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">    `u` and the Hermitian transpose of `vh` are 2D arrays with</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">    orthonormal columns and `s` is a 1D array of `a`&#39;s singular</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    values. When `a` is higher-dimensional, SVD is applied in</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">    stacked mode as explained below.</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">    a : (..., M, N) array_like</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">        A real or complex array with ``a.ndim &gt;= 2``.</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">    full_matrices : bool, optional</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">        If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">        ``(..., N, N)``, respectively.  Otherwise, the shapes are</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">        ``(..., M, K)`` and ``(..., K, N)``, respectively, where</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">        ``K = min(M, N)``.</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">    compute_uv : bool, optional</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">        Whether or not to compute `u` and `vh` in addition to `s`.  True</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">        by default.</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">    hermitian : bool, optional</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">        If True, `a` is assumed to be Hermitian (symmetric if real-valued),</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">        enabling a more efficient method for finding singular values.</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">        Defaults to False.</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">        .. versionadded:: 1.17.0</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">    u : { (..., M, M), (..., M, K) } array</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">        Unitary array(s). The first ``a.ndim - 2`` dimensions have the same</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">        size as those of the input `a`. The size of the last two dimensions</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">        depends on the value of `full_matrices`. Only returned when</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">        `compute_uv` is True.</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    s : (..., K) array</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">        Vector(s) with the singular values, within each vector sorted in</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">        descending order. The first ``a.ndim - 2`` dimensions have the same</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">        size as those of the input `a`.</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    vh : { (..., N, N), (..., K, N) } array</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">        Unitary array(s). The first ``a.ndim - 2`` dimensions have the same</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">        size as those of the input `a`. The size of the last two dimensions</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">        depends on the value of `full_matrices`. Only returned when</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">        `compute_uv` is True.</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">        If SVD computation does not converge.</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">    scipy.linalg.svd : Similar function in SciPy.</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">    scipy.linalg.svdvals : Compute singular values of a matrix.</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">    .. versionchanged:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">       Broadcasting rules apply, see the `numpy.linalg` documentation for</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">       details.</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    The decomposition is performed using LAPACK routine ``_gesdd``.</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    SVD is usually described for the factorization of a 2D matrix :math:`A`.</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    The higher-dimensional case will be discussed below. In the 2D case, SVD is</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    written as :math:`A = U S V^H`, where :math:`A = a`, :math:`U= u`,</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    :math:`S= \\mathtt{np.diag}(s)` and :math:`V^H = vh`. The 1D array `s`</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">    contains the singular values of `a` and `u` and `vh` are unitary. The rows</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">    of `vh` are the eigenvectors of :math:`A^H A` and the columns of `u` are</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">    the eigenvectors of :math:`A A^H`. In both cases the corresponding</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    (possibly non-zero) eigenvalues are given by ``s**2``.</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">    If `a` has more than two dimensions, then broadcasting rules apply, as</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    explained in :ref:`routines.linalg-broadcasting`. This means that SVD is</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    working in &quot;stacked&quot; mode: it iterates over all indices of the first</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    ``a.ndim - 2`` dimensions and for each combination SVD is applied to the</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">    last two indices. The matrix `a` can be reconstructed from the</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    decomposition with either ``(u * s[..., None, :]) @ vh`` or</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">    ``u @ (s[..., None] * vh)``. (The ``@`` operator can be replaced by the</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">    function ``np.matmul`` for python versions below 3.5.)</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    If `a` is a ``matrix`` object (as opposed to an ``ndarray``), then so are</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    all the return values.</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    &gt;&gt;&gt; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    &gt;&gt;&gt; b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    Reconstruction based on full SVD, 2D case:</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=True)</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">    ((9, 9), (6,), (6, 6))</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, np.dot(u[:, :6] * s, vh))</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    &gt;&gt;&gt; smat = np.zeros((9, 6), dtype=complex)</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">    &gt;&gt;&gt; smat[:6, :6] = np.diag(s)</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral">    Reconstruction based on reduced SVD, 2D case:</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=False)</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">    ((9, 6), (6,), (6, 6))</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, np.dot(u * s, vh))</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">    &gt;&gt;&gt; smat = np.diag(s)</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral">    Reconstruction based on full SVD, 4D case:</span></div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=True)</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">    ((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    Reconstruction based on reduced SVD, 4D case:</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=False)</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    ((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(b, np.matmul(u * s[..., None, :], vh))</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(b, np.matmul(u, s[..., None] * vh))</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1600</span>    <span class="keyword">import</span> numpy <span class="keyword">as</span> _nx</div>
<div class="line"><span class="lineno"> 1601</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno"> 1602</span> </div>
<div class="line"><span class="lineno"> 1603</span>    <span class="keywordflow">if</span> hermitian:</div>
<div class="line"><span class="lineno"> 1604</span>        <span class="comment"># note: lapack svd returns eigenvalues with s ** 2 sorted descending,</span></div>
<div class="line"><span class="lineno"> 1605</span>        <span class="comment"># but eig returns s sorted ascending, so we re-order the eigenvalues</span></div>
<div class="line"><span class="lineno"> 1606</span>        <span class="comment"># and related arrays to have the correct order</span></div>
<div class="line"><span class="lineno"> 1607</span>        <span class="keywordflow">if</span> compute_uv:</div>
<div class="line"><span class="lineno"> 1608</span>            s, u = eigh(a)</div>
<div class="line"><span class="lineno"> 1609</span>            sgn = sign(s)</div>
<div class="line"><span class="lineno"> 1610</span>            s = abs(s)</div>
<div class="line"><span class="lineno"> 1611</span>            sidx = argsort(s)[..., ::-1]</div>
<div class="line"><span class="lineno"> 1612</span>            sgn = _nx.take_along_axis(sgn, sidx, axis=-1)</div>
<div class="line"><span class="lineno"> 1613</span>            s = _nx.take_along_axis(s, sidx, axis=-1)</div>
<div class="line"><span class="lineno"> 1614</span>            u = _nx.take_along_axis(u, sidx[..., <span class="keywordtype">None</span>, :], axis=-1)</div>
<div class="line"><span class="lineno"> 1615</span>            <span class="comment"># singular values are unsigned, move the sign into v</span></div>
<div class="line"><span class="lineno"> 1616</span>            vt = transpose(u * sgn[..., <span class="keywordtype">None</span>, :]).conjugate()</div>
<div class="line"><span class="lineno"> 1617</span>            <span class="keywordflow">return</span> wrap(u), s, wrap(vt)</div>
<div class="line"><span class="lineno"> 1618</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1619</span>            s = eigvalsh(a)</div>
<div class="line"><span class="lineno"> 1620</span>            s = abs(s)</div>
<div class="line"><span class="lineno"> 1621</span>            <span class="keywordflow">return</span> sort(s)[..., ::-1]</div>
<div class="line"><span class="lineno"> 1622</span> </div>
<div class="line"><span class="lineno"> 1623</span>    _assert_stacked_2d(a)</div>
<div class="line"><span class="lineno"> 1624</span>    t, result_t = _commonType(a)</div>
<div class="line"><span class="lineno"> 1625</span> </div>
<div class="line"><span class="lineno"> 1626</span>    extobj = get_linalg_error_extobj(_raise_linalgerror_svd_nonconvergence)</div>
<div class="line"><span class="lineno"> 1627</span> </div>
<div class="line"><span class="lineno"> 1628</span>    m, n = a.shape[-2:]</div>
<div class="line"><span class="lineno"> 1629</span>    <span class="keywordflow">if</span> compute_uv:</div>
<div class="line"><span class="lineno"> 1630</span>        <span class="keywordflow">if</span> full_matrices:</div>
<div class="line"><span class="lineno"> 1631</span>            <span class="keywordflow">if</span> m &lt; n:</div>
<div class="line"><span class="lineno"> 1632</span>                gufunc = _umath_linalg.svd_m_f</div>
<div class="line"><span class="lineno"> 1633</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1634</span>                gufunc = _umath_linalg.svd_n_f</div>
<div class="line"><span class="lineno"> 1635</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1636</span>            <span class="keywordflow">if</span> m &lt; n:</div>
<div class="line"><span class="lineno"> 1637</span>                gufunc = _umath_linalg.svd_m_s</div>
<div class="line"><span class="lineno"> 1638</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1639</span>                gufunc = _umath_linalg.svd_n_s</div>
<div class="line"><span class="lineno"> 1640</span> </div>
<div class="line"><span class="lineno"> 1641</span>        signature = <span class="stringliteral">&#39;D-&gt;DdD&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;ddd&#39;</span></div>
<div class="line"><span class="lineno"> 1642</span>        u, s, vh = gufunc(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno"> 1643</span>        u = u.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1644</span>        s = s.astype(_realType(result_t), copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1645</span>        vh = vh.astype(result_t, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1646</span>        <span class="keywordflow">return</span> wrap(u), s, wrap(vh)</div>
<div class="line"><span class="lineno"> 1647</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1648</span>        <span class="keywordflow">if</span> m &lt; n:</div>
<div class="line"><span class="lineno"> 1649</span>            gufunc = _umath_linalg.svd_m</div>
<div class="line"><span class="lineno"> 1650</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1651</span>            gufunc = _umath_linalg.svd_n</div>
<div class="line"><span class="lineno"> 1652</span> </div>
<div class="line"><span class="lineno"> 1653</span>        signature = <span class="stringliteral">&#39;D-&gt;d&#39;</span> <span class="keywordflow">if</span> isComplexType(t) <span class="keywordflow">else</span> <span class="stringliteral">&#39;d-&gt;d&#39;</span></div>
<div class="line"><span class="lineno"> 1654</span>        s = gufunc(a, signature=signature, extobj=extobj)</div>
<div class="line"><span class="lineno"> 1655</span>        s = s.astype(_realType(result_t), copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1656</span>        <span class="keywordflow">return</span> s</div>
<div class="line"><span class="lineno"> 1657</span> </div>
<div class="line"><span class="lineno"> 1658</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a05cdbc2a157ce505a12a4265ce69dda6" name="a05cdbc2a157ce505a12a4265ce69dda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cdbc2a157ce505a12a4265ce69dda6">&#9670;&#160;</a></span>tensorinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.tensorinv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the 'inverse' of an N-dimensional array.

The result is an inverse for `a` relative to the tensordot operation
``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,
``tensordot(tensorinv(a), a, ind)`` is the "identity" tensor for the
tensordot operation.

Parameters
----------
a : array_like
    Tensor to 'invert'. Its shape must be 'square', i. e.,
    ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.
ind : int, optional
    Number of first indices that are involved in the inverse sum.
    Must be a positive integer, default is 2.

Returns
-------
b : ndarray
    `a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
numpy.tensordot, tensorsolve

Examples
--------
&gt;&gt;&gt; a = np.eye(4*6)
&gt;&gt;&gt; a.shape = (4, 6, 8, 3)
&gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=2)
&gt;&gt;&gt; ainv.shape
(8, 3, 4, 6)
&gt;&gt;&gt; b = np.random.randn(4, 6)
&gt;&gt;&gt; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
True

&gt;&gt;&gt; a = np.eye(4*6)
&gt;&gt;&gt; a.shape = (24, 8, 3)
&gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=1)
&gt;&gt;&gt; ainv.shape
(8, 3, 24)
&gt;&gt;&gt; b = np.random.randn(24)
&gt;&gt;&gt; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
True</pre> <div class="fragment"><div class="line"><span class="lineno">  396</span><span class="keyword">def </span>tensorinv(a, ind=2):</div>
<div class="line"><span class="lineno">  397</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    Compute the &#39;inverse&#39; of an N-dimensional array.</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    The result is an inverse for `a` relative to the tensordot operation</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    ``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    ``tensordot(tensorinv(a), a, ind)`` is the &quot;identity&quot; tensor for the</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    tensordot operation.</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">        Tensor to &#39;invert&#39;. Its shape must be &#39;square&#39;, i. e.,</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    ind : int, optional</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        Number of first indices that are involved in the inverse sum.</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">        Must be a positive integer, default is 2.</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    b : ndarray</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">        `a`&#39;s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        If `a` is singular or not &#39;square&#39; (in the above sense).</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    numpy.tensordot, tensorsolve</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    &gt;&gt;&gt; a = np.eye(4*6)</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    &gt;&gt;&gt; a.shape = (4, 6, 8, 3)</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=2)</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    &gt;&gt;&gt; ainv.shape</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    (8, 3, 4, 6)</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    &gt;&gt;&gt; b = np.random.randn(4, 6)</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    &gt;&gt;&gt; a = np.eye(4*6)</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    &gt;&gt;&gt; a.shape = (24, 8, 3)</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=1)</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    &gt;&gt;&gt; ainv.shape</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    (8, 3, 24)</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    &gt;&gt;&gt; b = np.random.randn(24)</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  449</span>    a = asarray(a)</div>
<div class="line"><span class="lineno">  450</span>    oldshape = a.shape</div>
<div class="line"><span class="lineno">  451</span>    prod = 1</div>
<div class="line"><span class="lineno">  452</span>    <span class="keywordflow">if</span> ind &gt; 0:</div>
<div class="line"><span class="lineno">  453</span>        invshape = oldshape[ind:] + oldshape[:ind]</div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> oldshape[ind:]:</div>
<div class="line"><span class="lineno">  455</span>            prod *= k</div>
<div class="line"><span class="lineno">  456</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  457</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid ind argument.&quot;</span>)</div>
<div class="line"><span class="lineno">  458</span>    a = a.reshape(prod, -1)</div>
<div class="line"><span class="lineno">  459</span>    ia = inv(a)</div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">return</span> ia.reshape(*invshape)</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span> </div>
<div class="line"><span class="lineno">  463</span><span class="comment"># Matrix inversion</span></div>
<div class="line"><span class="lineno">  464</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af4904dfc53632855f934147ecef5e8a0" name="af4904dfc53632855f934147ecef5e8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4904dfc53632855f934147ecef5e8a0">&#9670;&#160;</a></span>tensorsolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.tensorsolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the tensor equation ``a x = b`` for x.

It is assumed that all indices of `x` are summed over in the product,
together with the rightmost indices of `a`, as is done in, for example,
``tensordot(a, x, axes=x.ndim)``.

Parameters
----------
a : array_like
    Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
    the shape of that sub-tensor of `a` consisting of the appropriate
    number of its rightmost indices, and must be such that
    ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
    'square').
b : array_like
    Right-hand tensor, which can be of any shape.
axes : tuple of ints, optional
    Axes in `a` to reorder to the right, before inversion.
    If None (default), no reordering is done.

Returns
-------
x : ndarray, shape Q

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
numpy.tensordot, tensorinv, numpy.einsum

Examples
--------
&gt;&gt;&gt; a = np.eye(2*3*4)
&gt;&gt;&gt; a.shape = (2*3, 4, 2, 3, 4)
&gt;&gt;&gt; b = np.random.randn(2*3, 4)
&gt;&gt;&gt; x = np.linalg.tensorsolve(a, b)
&gt;&gt;&gt; x.shape
(2, 3, 4)
&gt;&gt;&gt; np.allclose(np.tensordot(a, x, axes=3), b)
True</pre> <div class="fragment"><div class="line"><span class="lineno">  226</span><span class="keyword">def </span>tensorsolve(a, b, axes=None):</div>
<div class="line"><span class="lineno">  227</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Solve the tensor equation ``a x = b`` for x.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    It is assumed that all indices of `x` are summed over in the product,</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    together with the rightmost indices of `a`, as is done in, for example,</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    ``tensordot(a, x, axes=x.ndim)``.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        the shape of that sub-tensor of `a` consisting of the appropriate</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        number of its rightmost indices, and must be such that</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">        ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">        &#39;square&#39;).</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">        Right-hand tensor, which can be of any shape.</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    axes : tuple of ints, optional</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        Axes in `a` to reorder to the right, before inversion.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">        If None (default), no reordering is done.</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    x : ndarray, shape Q</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    LinAlgError</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">        If `a` is singular or not &#39;square&#39; (in the above sense).</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    numpy.tensordot, tensorinv, numpy.einsum</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    &gt;&gt;&gt; a = np.eye(2*3*4)</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    &gt;&gt;&gt; a.shape = (2*3, 4, 2, 3, 4)</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    &gt;&gt;&gt; b = np.random.randn(2*3, 4)</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linalg.tensorsolve(a, b)</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    &gt;&gt;&gt; x.shape</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    (2, 3, 4)</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(np.tensordot(a, x, axes=3), b)</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  273</span>    a, wrap = _makearray(a)</div>
<div class="line"><span class="lineno">  274</span>    b = asarray(b)</div>
<div class="line"><span class="lineno">  275</span>    an = a.ndim</div>
<div class="line"><span class="lineno">  276</span> </div>
<div class="line"><span class="lineno">  277</span>    <span class="keywordflow">if</span> axes <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  278</span>        allaxes = list(range(0, an))</div>
<div class="line"><span class="lineno">  279</span>        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> axes:</div>
<div class="line"><span class="lineno">  280</span>            allaxes.remove(k)</div>
<div class="line"><span class="lineno">  281</span>            allaxes.insert(an, k)</div>
<div class="line"><span class="lineno">  282</span>        a = a.transpose(allaxes)</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>    oldshape = a.shape[-(an-b.ndim):]</div>
<div class="line"><span class="lineno">  285</span>    prod = 1</div>
<div class="line"><span class="lineno">  286</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> oldshape:</div>
<div class="line"><span class="lineno">  287</span>        prod *= k</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span>    <span class="keywordflow">if</span> a.size != prod ** 2:</div>
<div class="line"><span class="lineno">  290</span>        <span class="keywordflow">raise</span> LinAlgError(</div>
<div class="line"><span class="lineno">  291</span>            <span class="stringliteral">&quot;Input arrays must satisfy the requirement \</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">            prod(a.shape[b.ndim:]) == prod(a.shape[:b.ndim])&quot;</span></div>
<div class="line"><span class="lineno">  293</span>        )</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>    a = a.reshape(prod, prod)</div>
<div class="line"><span class="lineno">  296</span>    b = b.ravel()</div>
<div class="line"><span class="lineno">  297</span>    res = wrap(solve(a, b))</div>
<div class="line"><span class="lineno">  298</span>    res.shape = oldshape</div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af2bd7e50c24e75af531053ee81b9e755" name="af2bd7e50c24e75af531053ee81b9e755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bd7e50c24e75af531053ee81b9e755">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.transpose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transpose each matrix in a stack of matrices.

Unlike np.transpose, this only swaps the last two axes, rather than all of
them

Parameters
----------
a : (...,M,N) array_like

Returns
-------
aT : (...,N,M) ndarray
</pre> <div class="fragment"><div class="line"><span class="lineno">  202</span><span class="keyword">def </span>transpose(a):</div>
<div class="line"><span class="lineno">  203</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    Transpose each matrix in a stack of matrices.</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    Unlike np.transpose, this only swaps the last two axes, rather than all of</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    them</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    a : (...,M,N) array_like</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    aT : (...,N,M) ndarray</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  217</span>    <span class="keywordflow">return</span> swapaxes(a, -1, -2)</div>
<div class="line"><span class="lineno">  218</span> </div>
<div class="line"><span class="lineno">  219</span><span class="comment"># Linear equations</span></div>
<div class="line"><span class="lineno">  220</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af2229168993a702c198ddbb01a8030d9" name="af2229168993a702c198ddbb01a8030d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2229168993a702c198ddbb01a8030d9">&#9670;&#160;</a></span>_complex_types_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict numpy.linalg.linalg._complex_types_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {single : csingle,</div>
<div class="line"><span class="lineno">    2</span>                      double : cdouble,</div>
<div class="line"><span class="lineno">    3</span>                      csingle : csingle,</div>
<div class="line"><span class="lineno">    4</span>                      cdouble : cdouble}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a68eacc11c4a69383222b25cd70ffecd3" name="a68eacc11c4a69383222b25cd70ffecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eacc11c4a69383222b25cd70ffecd3">&#9670;&#160;</a></span>_linalg_error_extobj</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg._linalg_error_extobj = <a class="el" href="namespacenumpy_1_1linalg_1_1linalg.html#a358192a7ade9dc95145c9ff0a23cf0fe">_determine_error_states</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcd9ba979a8aab5ef704105f77ac77c4" name="afcd9ba979a8aab5ef704105f77ac77c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd9ba979a8aab5ef704105f77ac77c4">&#9670;&#160;</a></span>_real_types_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict numpy.linalg.linalg._real_types_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {single : single,</div>
<div class="line"><span class="lineno">    2</span>                   double : double,</div>
<div class="line"><span class="lineno">    3</span>                   csingle : single,</div>
<div class="line"><span class="lineno">    4</span>                   cdouble : double}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acbaf0497d21f2a1a0cce4283e9b33791" name="acbaf0497d21f2a1a0cce4283e9b33791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaf0497d21f2a1a0cce4283e9b33791">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy.linalg&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b5b13c1ab5625fec5215d3a9b5e16ce" name="a3b5b13c1ab5625fec5215d3a9b5e16ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5b13c1ab5625fec5215d3a9b5e16ce">&#9670;&#160;</a></span>fortran_int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.linalg.linalg.fortran_int = intc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
