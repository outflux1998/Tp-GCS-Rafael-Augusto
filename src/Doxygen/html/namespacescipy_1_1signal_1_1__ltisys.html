<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.signal._ltisys Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal.html">signal</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html">_ltisys</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.signal._ltisys Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_bunch.html">Bunch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1dlti.html">dlti</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_linear_time_invariant.html">LinearTimeInvariant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1lti.html">lti</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_state_space.html">StateSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_state_space_continuous.html">StateSpaceContinuous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_state_space_discrete.html">StateSpaceDiscrete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_transfer_function.html">TransferFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_transfer_function_continuous.html">TransferFunctionContinuous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_transfer_function_discrete.html">TransferFunctionDiscrete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_zeros_poles_gain.html">ZerosPolesGain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_zeros_poles_gain_continuous.html">ZerosPolesGainContinuous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1signal_1_1__ltisys_1_1_zeros_poles_gain_discrete.html">ZerosPolesGainDiscrete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a73239b2f2cfaa982c8db857756f6c6e8" id="r_a73239b2f2cfaa982c8db857756f6c6e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a73239b2f2cfaa982c8db857756f6c6e8">_atleast_2d_or_none</a> (arg)</td></tr>
<tr class="separator:a73239b2f2cfaa982c8db857756f6c6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43193c10de2bb05be9d1c60fbcf2f764" id="r_a43193c10de2bb05be9d1c60fbcf2f764"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a43193c10de2bb05be9d1c60fbcf2f764">lsim2</a> (system, U=None, T=None, X0=None, **kwargs)</td></tr>
<tr class="separator:a43193c10de2bb05be9d1c60fbcf2f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5c6bfaa9b8432b53aab337c9687edf" id="r_ade5c6bfaa9b8432b53aab337c9687edf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#ade5c6bfaa9b8432b53aab337c9687edf">_cast_to_array_dtype</a> (in1, in2)</td></tr>
<tr class="separator:ade5c6bfaa9b8432b53aab337c9687edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81706d4397767b146b651c5cebc2fd2" id="r_ad81706d4397767b146b651c5cebc2fd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#ad81706d4397767b146b651c5cebc2fd2">lsim</a> (system, U, T, X0=None, interp=True)</td></tr>
<tr class="separator:ad81706d4397767b146b651c5cebc2fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a16b8d04be9ec49f5fbe645706801" id="r_a4e4a16b8d04be9ec49f5fbe645706801"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a4e4a16b8d04be9ec49f5fbe645706801">_default_response_times</a> (A, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a4e4a16b8d04be9ec49f5fbe645706801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e8d379f94d78becbd5dd16b97734ec" id="r_a09e8d379f94d78becbd5dd16b97734ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a09e8d379f94d78becbd5dd16b97734ec">impulse</a> (system, X0=None, T=None, N=None)</td></tr>
<tr class="separator:a09e8d379f94d78becbd5dd16b97734ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26f9ff8dfac66c8fb42c282fb27d9da" id="r_ae26f9ff8dfac66c8fb42c282fb27d9da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#ae26f9ff8dfac66c8fb42c282fb27d9da">impulse2</a> (system, X0=None, T=None, N=None, **kwargs)</td></tr>
<tr class="separator:ae26f9ff8dfac66c8fb42c282fb27d9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531d2c4ab049182357f13971cf8e58e5" id="r_a531d2c4ab049182357f13971cf8e58e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a531d2c4ab049182357f13971cf8e58e5">step</a> (system, X0=None, T=None, N=None)</td></tr>
<tr class="separator:a531d2c4ab049182357f13971cf8e58e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d583450772b85b02f687c6b097ebe7" id="r_a14d583450772b85b02f687c6b097ebe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a14d583450772b85b02f687c6b097ebe7">step2</a> (system, X0=None, T=None, N=None, **kwargs)</td></tr>
<tr class="separator:a14d583450772b85b02f687c6b097ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4" id="r_aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4">bode</a> (system, <a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=100)</td></tr>
<tr class="separator:aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5224b7e7920b072f5a40d9776f9687f5" id="r_a5224b7e7920b072f5a40d9776f9687f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a5224b7e7920b072f5a40d9776f9687f5">freqresp</a> (system, <a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=10000)</td></tr>
<tr class="separator:a5224b7e7920b072f5a40d9776f9687f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af808660cbb91d4fbdda9047943da7eb8" id="r_af808660cbb91d4fbdda9047943da7eb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#af808660cbb91d4fbdda9047943da7eb8">_valid_inputs</a> (A, B, <a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>, method, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>, maxiter)</td></tr>
<tr class="separator:af808660cbb91d4fbdda9047943da7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c186b25c05f27e99b1a79ee1e4221c" id="r_af2c186b25c05f27e99b1a79ee1e4221c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#af2c186b25c05f27e99b1a79ee1e4221c">_order_complex_poles</a> (<a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>)</td></tr>
<tr class="separator:af2c186b25c05f27e99b1a79ee1e4221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe429b12ac7b4287bb921166424a371" id="r_a8fe429b12ac7b4287bb921166424a371"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a8fe429b12ac7b4287bb921166424a371">_KNV0</a> (B, ker_pole, transfer_matrix, <a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>, <a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>)</td></tr>
<tr class="separator:a8fe429b12ac7b4287bb921166424a371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4288e056f809dfaa360e79ec95fe64" id="r_a1f4288e056f809dfaa360e79ec95fe64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a1f4288e056f809dfaa360e79ec95fe64">_YT_real</a> (ker_pole, Q, transfer_matrix, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, <a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>)</td></tr>
<tr class="separator:a1f4288e056f809dfaa360e79ec95fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e40ad626e73edc303306365d185c6c" id="r_a35e40ad626e73edc303306365d185c6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a35e40ad626e73edc303306365d185c6c">_YT_complex</a> (ker_pole, Q, transfer_matrix, <a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, <a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>)</td></tr>
<tr class="separator:a35e40ad626e73edc303306365d185c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62d2ed2235dc24c84e2605cc275157e" id="r_af62d2ed2235dc24c84e2605cc275157e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#af62d2ed2235dc24c84e2605cc275157e">_YT_loop</a> (ker_pole, transfer_matrix, <a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>, B, maxiter, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>)</td></tr>
<tr class="separator:af62d2ed2235dc24c84e2605cc275157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acb1db2b4f17e1560fd36bfd84e8a04" id="r_a9acb1db2b4f17e1560fd36bfd84e8a04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a9acb1db2b4f17e1560fd36bfd84e8a04">_KNV0_loop</a> (ker_pole, transfer_matrix, <a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>, B, maxiter, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>)</td></tr>
<tr class="separator:a9acb1db2b4f17e1560fd36bfd84e8a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028e75567f2c624a3c1434b630817736" id="r_a028e75567f2c624a3c1434b630817736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a028e75567f2c624a3c1434b630817736">place_poles</a> (A, B, <a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>, method=&quot;YT&quot;, <a class="el" href="__lapack__subroutines_8h.html#aa4a017e91ee751f9803a1bdb6caf1c06">rtol</a>=1e-3, maxiter=30)</td></tr>
<tr class="separator:a028e75567f2c624a3c1434b630817736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aab993a41192c63bde62a840751cdd9" id="r_a5aab993a41192c63bde62a840751cdd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a5aab993a41192c63bde62a840751cdd9">dlsim</a> (system, u, t=None, x0=None)</td></tr>
<tr class="separator:a5aab993a41192c63bde62a840751cdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7232a366e580be2067d3bc8340c639f2" id="r_a7232a366e580be2067d3bc8340c639f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a7232a366e580be2067d3bc8340c639f2">dimpulse</a> (system, x0=None, t=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None)</td></tr>
<tr class="separator:a7232a366e580be2067d3bc8340c639f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106cc5e8301c0883b141e59dbf53cf8" id="r_a1106cc5e8301c0883b141e59dbf53cf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a1106cc5e8301c0883b141e59dbf53cf8">dstep</a> (system, x0=None, t=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None)</td></tr>
<tr class="separator:a1106cc5e8301c0883b141e59dbf53cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc2d5055e90d297dbde688307acaa5b" id="r_aafc2d5055e90d297dbde688307acaa5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#aafc2d5055e90d297dbde688307acaa5b">dfreqresp</a> (system, <a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=10000, whole=False)</td></tr>
<tr class="separator:aafc2d5055e90d297dbde688307acaa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008bf6e9a51183d42a73d86718cb879c" id="r_a008bf6e9a51183d42a73d86718cb879c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__ltisys.html#a008bf6e9a51183d42a73d86718cb879c">dbode</a> (system, <a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=100)</td></tr>
<tr class="separator:a008bf6e9a51183d42a73d86718cb879c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">ltisys -- a collection of classes and functions for modeling linear
time invariant systems.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a73239b2f2cfaa982c8db857756f6c6e8" name="a73239b2f2cfaa982c8db857756f6c6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73239b2f2cfaa982c8db857756f6c6e8">&#9670;&#160;</a></span>_atleast_2d_or_none()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._atleast_2d_or_none </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1220</span><span class="keyword">def </span>_atleast_2d_or_none(arg):</div>
<div class="line"><span class="lineno"> 1221</span>    <span class="keywordflow">if</span> arg <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1222</span>        <span class="keywordflow">return</span> atleast_2d(arg)</div>
<div class="line"><span class="lineno"> 1223</span> </div>
<div class="line"><span class="lineno"> 1224</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ade5c6bfaa9b8432b53aab337c9687edf" name="ade5c6bfaa9b8432b53aab337c9687edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5c6bfaa9b8432b53aab337c9687edf">&#9670;&#160;</a></span>_cast_to_array_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._cast_to_array_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Cast array to dtype of other array, while avoiding ComplexWarning.

Those can be raised when casting complex to real.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1941</span><span class="keyword">def </span>_cast_to_array_dtype(in1, in2):</div>
<div class="line"><span class="lineno"> 1942</span>    <span class="stringliteral">&quot;&quot;&quot;Cast array to dtype of other array, while avoiding ComplexWarning.</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">    Those can be raised when casting complex to real.</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1946</span>    <span class="keywordflow">if</span> numpy.issubdtype(in2.dtype, numpy.float64):</div>
<div class="line"><span class="lineno"> 1947</span>        <span class="comment"># dtype to cast to is not complex, so use .real</span></div>
<div class="line"><span class="lineno"> 1948</span>        in1 = in1.real.astype(in2.dtype)</div>
<div class="line"><span class="lineno"> 1949</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1950</span>        in1 = in1.astype(in2.dtype)</div>
<div class="line"><span class="lineno"> 1951</span> </div>
<div class="line"><span class="lineno"> 1952</span>    <span class="keywordflow">return</span> in1</div>
<div class="line"><span class="lineno"> 1953</span> </div>
<div class="line"><span class="lineno"> 1954</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e4a16b8d04be9ec49f5fbe645706801" name="a4e4a16b8d04be9ec49f5fbe645706801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4a16b8d04be9ec49f5fbe645706801">&#9670;&#160;</a></span>_default_response_times()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._default_response_times </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a reasonable set of time samples for the response time.

This function is used by `impulse`, `impulse2`, `step` and `step2`
to compute the response time when the `T` argument to the function
is None.

Parameters
----------
A : array_like
    The system matrix, which is square.
n : int
    The number of time samples to generate.

Returns
-------
t : ndarray
    The 1-D array of length `n` of time samples at which the response
    is to be computed.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2171</span><span class="keyword">def </span>_default_response_times(A, n):</div>
<div class="line"><span class="lineno"> 2172</span>    <span class="stringliteral">&quot;&quot;&quot;Compute a reasonable set of time samples for the response time.</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">    This function is used by `impulse`, `impulse2`, `step` and `step2`</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">    to compute the response time when the `T` argument to the function</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">    is None.</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">    A : array_like</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral">        The system matrix, which is square.</span></div>
<div class="line"><span class="lineno"> 2182</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno"> 2183</span><span class="stringliteral">        The number of time samples to generate.</span></div>
<div class="line"><span class="lineno"> 2184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2185</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2186</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2187</span><span class="stringliteral">    t : ndarray</span></div>
<div class="line"><span class="lineno"> 2188</span><span class="stringliteral">        The 1-D array of length `n` of time samples at which the response</span></div>
<div class="line"><span class="lineno"> 2189</span><span class="stringliteral">        is to be computed.</span></div>
<div class="line"><span class="lineno"> 2190</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2191</span>    <span class="comment"># Create a reasonable time interval.</span></div>
<div class="line"><span class="lineno"> 2192</span>    <span class="comment"># TODO: This could use some more work.</span></div>
<div class="line"><span class="lineno"> 2193</span>    <span class="comment"># For example, what is expected when the system is unstable?</span></div>
<div class="line"><span class="lineno"> 2194</span>    vals = linalg.eigvals(A)</div>
<div class="line"><span class="lineno"> 2195</span>    r = min(abs(real(vals)))</div>
<div class="line"><span class="lineno"> 2196</span>    <span class="keywordflow">if</span> r == 0.0:</div>
<div class="line"><span class="lineno"> 2197</span>        r = 1.0</div>
<div class="line"><span class="lineno"> 2198</span>    tc = 1.0 / r</div>
<div class="line"><span class="lineno"> 2199</span>    t = linspace(0.0, 7 * tc, n)</div>
<div class="line"><span class="lineno"> 2200</span>    <span class="keywordflow">return</span> t</div>
<div class="line"><span class="lineno"> 2201</span> </div>
<div class="line"><span class="lineno"> 2202</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8fe429b12ac7b4287bb921166424a371" name="a8fe429b12ac7b4287bb921166424a371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe429b12ac7b4287bb921166424a371">&#9670;&#160;</a></span>_KNV0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._KNV0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ker_pole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transfer_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Algorithm "KNV0" Kautsky et Al. Robust pole
assignment in linear state feedback, Int journal of Control
1985, vol 41 p 1129-&gt;1155
https://la.epfl.ch/files/content/sites/la/files/
    users/105941/public/KautskyNicholsDooren</pre> <div class="fragment"><div class="line"><span class="lineno"> 2741</span><span class="keyword">def </span>_KNV0(B, ker_pole, transfer_matrix, j, poles):</div>
<div class="line"><span class="lineno"> 2742</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral">    Algorithm &quot;KNV0&quot; Kautsky et Al. Robust pole</span></div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral">    assignment in linear state feedback, Int journal of Control</span></div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral">    1985, vol 41 p 1129-&gt;1155</span></div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral">    https://la.epfl.ch/files/content/sites/la/files/</span></div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral">        users/105941/public/KautskyNicholsDooren</span></div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2750</span>    <span class="comment"># Remove xj form the base</span></div>
<div class="line"><span class="lineno"> 2751</span>    transfer_matrix_not_j = np.delete(transfer_matrix, j, axis=1)</div>
<div class="line"><span class="lineno"> 2752</span>    <span class="comment"># If we QR this matrix in full mode Q=Q0|Q1</span></div>
<div class="line"><span class="lineno"> 2753</span>    <span class="comment"># then Q1 will be a single column orthogonnal to</span></div>
<div class="line"><span class="lineno"> 2754</span>    <span class="comment"># Q0, that&#39;s what we are looking for !</span></div>
<div class="line"><span class="lineno"> 2755</span> </div>
<div class="line"><span class="lineno"> 2756</span>    <span class="comment"># After merge of gh-4249 great speed improvements could be achieved</span></div>
<div class="line"><span class="lineno"> 2757</span>    <span class="comment"># using QR updates instead of full QR in the line below</span></div>
<div class="line"><span class="lineno"> 2758</span> </div>
<div class="line"><span class="lineno"> 2759</span>    <span class="comment"># To debug with numpy qr uncomment the line below</span></div>
<div class="line"><span class="lineno"> 2760</span>    <span class="comment"># Q, R = np.linalg.qr(transfer_matrix_not_j, mode=&quot;complete&quot;)</span></div>
<div class="line"><span class="lineno"> 2761</span>    Q, R = s_qr(transfer_matrix_not_j, mode=<span class="stringliteral">&quot;full&quot;</span>)</div>
<div class="line"><span class="lineno"> 2762</span> </div>
<div class="line"><span class="lineno"> 2763</span>    mat_ker_pj = np.dot(ker_pole[j], ker_pole[j].T)</div>
<div class="line"><span class="lineno"> 2764</span>    yj = np.dot(mat_ker_pj, Q[:, -1])</div>
<div class="line"><span class="lineno"> 2765</span> </div>
<div class="line"><span class="lineno"> 2766</span>    <span class="comment"># If Q[:, -1] is &quot;almost&quot; orthogonal to ker_pole[j] its</span></div>
<div class="line"><span class="lineno"> 2767</span>    <span class="comment"># projection into ker_pole[j] will yield a vector</span></div>
<div class="line"><span class="lineno"> 2768</span>    <span class="comment"># close to 0.  As we are looking for a vector in ker_pole[j]</span></div>
<div class="line"><span class="lineno"> 2769</span>    <span class="comment"># simply stick with transfer_matrix[:, j] (unless someone provides me with</span></div>
<div class="line"><span class="lineno"> 2770</span>    <span class="comment"># a better choice ?)</span></div>
<div class="line"><span class="lineno"> 2771</span> </div>
<div class="line"><span class="lineno"> 2772</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.allclose(yj, 0):</div>
<div class="line"><span class="lineno"> 2773</span>        xj = yj/np.linalg.norm(yj)</div>
<div class="line"><span class="lineno"> 2774</span>        transfer_matrix[:, j] = xj</div>
<div class="line"><span class="lineno"> 2775</span> </div>
<div class="line"><span class="lineno"> 2776</span>        <span class="comment"># KNV does not support complex poles, using YT technique the two lines</span></div>
<div class="line"><span class="lineno"> 2777</span>        <span class="comment"># below seem to work 9 out of 10 times but it is not reliable enough:</span></div>
<div class="line"><span class="lineno"> 2778</span>        <span class="comment"># transfer_matrix[:, j]=real(xj)</span></div>
<div class="line"><span class="lineno"> 2779</span>        <span class="comment"># transfer_matrix[:, j+1]=imag(xj)</span></div>
<div class="line"><span class="lineno"> 2780</span> </div>
<div class="line"><span class="lineno"> 2781</span>        <span class="comment"># Add this at the beginning of this function if you wish to test</span></div>
<div class="line"><span class="lineno"> 2782</span>        <span class="comment"># complex support:</span></div>
<div class="line"><span class="lineno"> 2783</span>        <span class="comment">#    if ~np.isreal(P[j]) and (j&gt;=B.shape[0]-1 or P[j]!=np.conj(P[j+1])):</span></div>
<div class="line"><span class="lineno"> 2784</span>        <span class="comment">#        return</span></div>
<div class="line"><span class="lineno"> 2785</span>        <span class="comment"># Problems arise when imag(xj)=&gt;0 I have no idea on how to fix this</span></div>
<div class="line"><span class="lineno"> 2786</span> </div>
<div class="line"><span class="lineno"> 2787</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9acb1db2b4f17e1560fd36bfd84e8a04" name="a9acb1db2b4f17e1560fd36bfd84e8a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acb1db2b4f17e1560fd36bfd84e8a04">&#9670;&#160;</a></span>_KNV0_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._KNV0_loop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ker_pole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transfer_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Loop over all poles one by one and apply KNV method 0 algorithm
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3027</span><span class="keyword">def </span>_KNV0_loop(ker_pole, transfer_matrix, poles, B, maxiter, rtol):</div>
<div class="line"><span class="lineno"> 3028</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral">    Loop over all poles one by one and apply KNV method 0 algorithm</span></div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3031</span>    <span class="comment"># This method is useful only because we need to be able to call</span></div>
<div class="line"><span class="lineno"> 3032</span>    <span class="comment"># _KNV0 from YT without looping over all poles, otherwise it would</span></div>
<div class="line"><span class="lineno"> 3033</span>    <span class="comment"># have been fine to mix _KNV0_loop and _KNV0 in a single function</span></div>
<div class="line"><span class="lineno"> 3034</span>    stop = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3035</span>    nb_try = 0</div>
<div class="line"><span class="lineno"> 3036</span>    <span class="keywordflow">while</span> nb_try &lt; maxiter <span class="keywordflow">and</span> <span class="keywordflow">not</span> stop:</div>
<div class="line"><span class="lineno"> 3037</span>        det_transfer_matrixb = np.abs(np.linalg.det(transfer_matrix))</div>
<div class="line"><span class="lineno"> 3038</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(B.shape[0]):</div>
<div class="line"><span class="lineno"> 3039</span>            _KNV0(B, ker_pole, transfer_matrix, j, poles)</div>
<div class="line"><span class="lineno"> 3040</span> </div>
<div class="line"><span class="lineno"> 3041</span>        det_transfer_matrix = np.max((np.sqrt(np.spacing(1)),</div>
<div class="line"><span class="lineno"> 3042</span>                                  np.abs(np.linalg.det(transfer_matrix))))</div>
<div class="line"><span class="lineno"> 3043</span>        cur_rtol = np.abs((det_transfer_matrix - det_transfer_matrixb) /</div>
<div class="line"><span class="lineno"> 3044</span>                       det_transfer_matrix)</div>
<div class="line"><span class="lineno"> 3045</span>        <span class="keywordflow">if</span> cur_rtol &lt; rtol <span class="keywordflow">and</span> det_transfer_matrix &gt; np.sqrt(np.spacing(1)):</div>
<div class="line"><span class="lineno"> 3046</span>            <span class="comment"># Convergence test from YT page 21</span></div>
<div class="line"><span class="lineno"> 3047</span>            stop = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3048</span> </div>
<div class="line"><span class="lineno"> 3049</span>        nb_try += 1</div>
<div class="line"><span class="lineno"> 3050</span>    <span class="keywordflow">return</span> stop, cur_rtol, nb_try</div>
<div class="line"><span class="lineno"> 3051</span> </div>
<div class="line"><span class="lineno"> 3052</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af2c186b25c05f27e99b1a79ee1e4221c" name="af2c186b25c05f27e99b1a79ee1e4221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c186b25c05f27e99b1a79ee1e4221c">&#9670;&#160;</a></span>_order_complex_poles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._order_complex_poles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check we have complex conjugates pairs and reorder P according to YT, ie
real_poles, complex_i, conjugate complex_i, ....
The lexicographic sort on the complex poles is added to help the user to
compare sets of poles.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2721</span><span class="keyword">def </span>_order_complex_poles(poles):</div>
<div class="line"><span class="lineno"> 2722</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2723</span><span class="stringliteral">    Check we have complex conjugates pairs and reorder P according to YT, ie</span></div>
<div class="line"><span class="lineno"> 2724</span><span class="stringliteral">    real_poles, complex_i, conjugate complex_i, ....</span></div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral">    The lexicographic sort on the complex poles is added to help the user to</span></div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral">    compare sets of poles.</span></div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2728</span>    ordered_poles = np.sort(poles[np.isreal(poles)])</div>
<div class="line"><span class="lineno"> 2729</span>    im_poles = []</div>
<div class="line"><span class="lineno"> 2730</span>    <span class="keywordflow">for</span> p <span class="keywordflow">in</span> np.sort(poles[np.imag(poles) &lt; 0]):</div>
<div class="line"><span class="lineno"> 2731</span>        <span class="keywordflow">if</span> np.conj(p) <span class="keywordflow">in</span> poles:</div>
<div class="line"><span class="lineno"> 2732</span>            im_poles.extend((p, np.conj(p)))</div>
<div class="line"><span class="lineno"> 2733</span> </div>
<div class="line"><span class="lineno"> 2734</span>    ordered_poles = np.hstack((ordered_poles, im_poles))</div>
<div class="line"><span class="lineno"> 2735</span> </div>
<div class="line"><span class="lineno"> 2736</span>    <span class="keywordflow">if</span> poles.shape[0] != len(ordered_poles):</div>
<div class="line"><span class="lineno"> 2737</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Complex poles must come with their conjugates&quot;</span>)</div>
<div class="line"><span class="lineno"> 2738</span>    <span class="keywordflow">return</span> ordered_poles</div>
<div class="line"><span class="lineno"> 2739</span> </div>
<div class="line"><span class="lineno"> 2740</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af808660cbb91d4fbdda9047943da7eb8" name="af808660cbb91d4fbdda9047943da7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af808660cbb91d4fbdda9047943da7eb8">&#9670;&#160;</a></span>_valid_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._valid_inputs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check the poles come in complex conjugage pairs
Check shapes of A, B and poles are compatible.
Check the method chosen is compatible with provided poles
Return update method to use and ordered poles</pre> <div class="fragment"><div class="line"><span class="lineno"> 2670</span><span class="keyword">def </span>_valid_inputs(A, B, poles, method, rtol, maxiter):</div>
<div class="line"><span class="lineno"> 2671</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">    Check the poles come in complex conjugage pairs</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">    Check shapes of A, B and poles are compatible.</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">    Check the method chosen is compatible with provided poles</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">    Return update method to use and ordered poles</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2678</span>    poles = np.asarray(poles)</div>
<div class="line"><span class="lineno"> 2679</span>    <span class="keywordflow">if</span> poles.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2680</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Poles must be a 1D array like.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2681</span>    <span class="comment"># Will raise ValueError if poles do not come in complex conjugates pairs</span></div>
<div class="line"><span class="lineno"> 2682</span>    poles = _order_complex_poles(poles)</div>
<div class="line"><span class="lineno"> 2683</span>    <span class="keywordflow">if</span> A.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 2684</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;A must be a 2D array/matrix.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2685</span>    <span class="keywordflow">if</span> B.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 2686</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;B must be a 2D array/matrix&quot;</span>)</div>
<div class="line"><span class="lineno"> 2687</span>    <span class="keywordflow">if</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno"> 2688</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;A must be square&quot;</span>)</div>
<div class="line"><span class="lineno"> 2689</span>    <span class="keywordflow">if</span> len(poles) &gt; A.shape[0]:</div>
<div class="line"><span class="lineno"> 2690</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;maximum number of poles is %d but you asked for %d&quot;</span> %</div>
<div class="line"><span class="lineno"> 2691</span>                         (A.shape[0], len(poles)))</div>
<div class="line"><span class="lineno"> 2692</span>    <span class="keywordflow">if</span> len(poles) &lt; A.shape[0]:</div>
<div class="line"><span class="lineno"> 2693</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;number of poles is %d but you should provide %d&quot;</span> %</div>
<div class="line"><span class="lineno"> 2694</span>                         (len(poles), A.shape[0]))</div>
<div class="line"><span class="lineno"> 2695</span>    r = np.linalg.matrix_rank(B)</div>
<div class="line"><span class="lineno"> 2696</span>    <span class="keywordflow">for</span> p <span class="keywordflow">in</span> poles:</div>
<div class="line"><span class="lineno"> 2697</span>        <span class="keywordflow">if</span> sum(p == poles) &gt; r:</div>
<div class="line"><span class="lineno"> 2698</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;at least one of the requested pole is repeated &quot;</span></div>
<div class="line"><span class="lineno"> 2699</span>                             <span class="stringliteral">&quot;more than rank(B) times&quot;</span>)</div>
<div class="line"><span class="lineno"> 2700</span>    <span class="comment"># Choose update method</span></div>
<div class="line"><span class="lineno"> 2701</span>    update_loop = _YT_loop</div>
<div class="line"><span class="lineno"> 2702</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;KNV0&#39;</span>,<span class="stringliteral">&#39;YT&#39;</span>):</div>
<div class="line"><span class="lineno"> 2703</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The method keyword must be one of &#39;YT&#39; or &#39;KNV0&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 2704</span> </div>
<div class="line"><span class="lineno"> 2705</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;KNV0&quot;</span>:</div>
<div class="line"><span class="lineno"> 2706</span>        update_loop = _KNV0_loop</div>
<div class="line"><span class="lineno"> 2707</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> all(np.isreal(poles)):</div>
<div class="line"><span class="lineno"> 2708</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Complex poles are not supported by KNV0&quot;</span>)</div>
<div class="line"><span class="lineno"> 2709</span> </div>
<div class="line"><span class="lineno"> 2710</span>    <span class="keywordflow">if</span> maxiter &lt; 1:</div>
<div class="line"><span class="lineno"> 2711</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;maxiter must be at least equal to 1&quot;</span>)</div>
<div class="line"><span class="lineno"> 2712</span> </div>
<div class="line"><span class="lineno"> 2713</span>    <span class="comment"># We do not check rtol &lt;= 0 as the user can use a negative rtol to</span></div>
<div class="line"><span class="lineno"> 2714</span>    <span class="comment"># force maxiter iterations</span></div>
<div class="line"><span class="lineno"> 2715</span>    <span class="keywordflow">if</span> rtol &gt; 1:</div>
<div class="line"><span class="lineno"> 2716</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;rtol can not be greater than 1&quot;</span>)</div>
<div class="line"><span class="lineno"> 2717</span> </div>
<div class="line"><span class="lineno"> 2718</span>    <span class="keywordflow">return</span> update_loop, poles</div>
<div class="line"><span class="lineno"> 2719</span> </div>
<div class="line"><span class="lineno"> 2720</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a35e40ad626e73edc303306365d185c6c" name="a35e40ad626e73edc303306365d185c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e40ad626e73edc303306365d185c6c">&#9670;&#160;</a></span>_YT_complex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._YT_complex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ker_pole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transfer_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Applies algorithm from YT section 6.2 page 20 related to complex pairs
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2853</span><span class="keyword">def </span>_YT_complex(ker_pole, Q, transfer_matrix, i, j):</div>
<div class="line"><span class="lineno"> 2854</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2855</span><span class="stringliteral">    Applies algorithm from YT section 6.2 page 20 related to complex pairs</span></div>
<div class="line"><span class="lineno"> 2856</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2857</span>    <span class="comment"># step 1 page 20</span></div>
<div class="line"><span class="lineno"> 2858</span>    ur = np.sqrt(2)*Q[:, -2, np.newaxis]</div>
<div class="line"><span class="lineno"> 2859</span>    ui = np.sqrt(2)*Q[:, -1, np.newaxis]</div>
<div class="line"><span class="lineno"> 2860</span>    u = ur + 1j*ui</div>
<div class="line"><span class="lineno"> 2861</span> </div>
<div class="line"><span class="lineno"> 2862</span>    <span class="comment"># step 2 page 20</span></div>
<div class="line"><span class="lineno"> 2863</span>    ker_pole_ij = ker_pole[i]</div>
<div class="line"><span class="lineno"> 2864</span>    m = np.dot(np.dot(np.conj(ker_pole_ij.T), np.dot(u, np.conj(u).T) -</div>
<div class="line"><span class="lineno"> 2865</span>               np.dot(np.conj(u), u.T)), ker_pole_ij)</div>
<div class="line"><span class="lineno"> 2866</span> </div>
<div class="line"><span class="lineno"> 2867</span>    <span class="comment"># step 3 page 20</span></div>
<div class="line"><span class="lineno"> 2868</span>    e_val, e_vec = np.linalg.eig(m)</div>
<div class="line"><span class="lineno"> 2869</span>    <span class="comment"># sort eigenvalues according to their module</span></div>
<div class="line"><span class="lineno"> 2870</span>    e_val_idx = np.argsort(np.abs(e_val))</div>
<div class="line"><span class="lineno"> 2871</span>    mu1 = e_vec[:, e_val_idx[-1], np.newaxis]</div>
<div class="line"><span class="lineno"> 2872</span>    mu2 = e_vec[:, e_val_idx[-2], np.newaxis]</div>
<div class="line"><span class="lineno"> 2873</span> </div>
<div class="line"><span class="lineno"> 2874</span>    <span class="comment"># what follows is a rough python translation of the formulas</span></div>
<div class="line"><span class="lineno"> 2875</span>    <span class="comment"># in section 6.2 page 20 (step 4)</span></div>
<div class="line"><span class="lineno"> 2876</span> </div>
<div class="line"><span class="lineno"> 2877</span>    <span class="comment"># remember transfer_matrix_i has been split as</span></div>
<div class="line"><span class="lineno"> 2878</span>    <span class="comment"># transfer_matrix[i]=real(transfer_matrix_i) and</span></div>
<div class="line"><span class="lineno"> 2879</span>    <span class="comment"># transfer_matrix[j]=imag(transfer_matrix_i)</span></div>
<div class="line"><span class="lineno"> 2880</span>    transfer_matrix_j_mo_transfer_matrix_j = (</div>
<div class="line"><span class="lineno"> 2881</span>        transfer_matrix[:, i, np.newaxis] +</div>
<div class="line"><span class="lineno"> 2882</span>        1j*transfer_matrix[:, j, np.newaxis]</div>
<div class="line"><span class="lineno"> 2883</span>        )</div>
<div class="line"><span class="lineno"> 2884</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.allclose(np.abs(e_val[e_val_idx[-1]]),</div>
<div class="line"><span class="lineno"> 2885</span>                              np.abs(e_val[e_val_idx[-2]])):</div>
<div class="line"><span class="lineno"> 2886</span>        ker_pole_mu = np.dot(ker_pole_ij, mu1)</div>
<div class="line"><span class="lineno"> 2887</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2888</span>        mu1_mu2_matrix = np.hstack((mu1, mu2))</div>
<div class="line"><span class="lineno"> 2889</span>        ker_pole_mu = np.dot(ker_pole_ij, mu1_mu2_matrix)</div>
<div class="line"><span class="lineno"> 2890</span>    transfer_matrix_i_j = np.dot(np.dot(ker_pole_mu, np.conj(ker_pole_mu.T)),</div>
<div class="line"><span class="lineno"> 2891</span>                              transfer_matrix_j_mo_transfer_matrix_j)</div>
<div class="line"><span class="lineno"> 2892</span> </div>
<div class="line"><span class="lineno"> 2893</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.allclose(transfer_matrix_i_j, 0):</div>
<div class="line"><span class="lineno"> 2894</span>        transfer_matrix_i_j = (transfer_matrix_i_j /</div>
<div class="line"><span class="lineno"> 2895</span>            np.linalg.norm(transfer_matrix_i_j))</div>
<div class="line"><span class="lineno"> 2896</span>        transfer_matrix[:, i] = np.real(transfer_matrix_i_j[:, 0])</div>
<div class="line"><span class="lineno"> 2897</span>        transfer_matrix[:, j] = np.imag(transfer_matrix_i_j[:, 0])</div>
<div class="line"><span class="lineno"> 2898</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2899</span>        <span class="comment"># same idea as in YT_real</span></div>
<div class="line"><span class="lineno"> 2900</span>        transfer_matrix[:, i] = np.real(ker_pole_mu[:, 0])</div>
<div class="line"><span class="lineno"> 2901</span>        transfer_matrix[:, j] = np.imag(ker_pole_mu[:, 0])</div>
<div class="line"><span class="lineno"> 2902</span> </div>
<div class="line"><span class="lineno"> 2903</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af62d2ed2235dc24c84e2605cc275157e" name="af62d2ed2235dc24c84e2605cc275157e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62d2ed2235dc24c84e2605cc275157e">&#9670;&#160;</a></span>_YT_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._YT_loop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ker_pole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transfer_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Algorithm "YT" Tits, Yang. Globally Convergent
Algorithms for Robust Pole Assignment by State Feedback
https://hdl.handle.net/1903/5598
The poles P have to be sorted accordingly to section 6.2 page 20</pre> <div class="fragment"><div class="line"><span class="lineno"> 2904</span><span class="keyword">def </span>_YT_loop(ker_pole, transfer_matrix, poles, B, maxiter, rtol):</div>
<div class="line"><span class="lineno"> 2905</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2906</span><span class="stringliteral">    Algorithm &quot;YT&quot; Tits, Yang. Globally Convergent</span></div>
<div class="line"><span class="lineno"> 2907</span><span class="stringliteral">    Algorithms for Robust Pole Assignment by State Feedback</span></div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral">    https://hdl.handle.net/1903/5598</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral">    The poles P have to be sorted accordingly to section 6.2 page 20</span></div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2912</span>    <span class="comment"># The IEEE edition of the YT paper gives useful information on the</span></div>
<div class="line"><span class="lineno"> 2913</span>    <span class="comment"># optimal update order for the real poles in order to minimize the number</span></div>
<div class="line"><span class="lineno"> 2914</span>    <span class="comment"># of times we have to loop over all poles, see page 1442</span></div>
<div class="line"><span class="lineno"> 2915</span>    nb_real = poles[np.isreal(poles)].shape[0]</div>
<div class="line"><span class="lineno"> 2916</span>    <span class="comment"># hnb =&gt; Half Nb Real</span></div>
<div class="line"><span class="lineno"> 2917</span>    hnb = nb_real // 2</div>
<div class="line"><span class="lineno"> 2918</span> </div>
<div class="line"><span class="lineno"> 2919</span>    <span class="comment"># Stick to the indices in the paper and then remove one to get numpy array</span></div>
<div class="line"><span class="lineno"> 2920</span>    <span class="comment"># index it is a bit easier to link the code to the paper this way even if it</span></div>
<div class="line"><span class="lineno"> 2921</span>    <span class="comment"># is not very clean. The paper is unclear about what should be done when</span></div>
<div class="line"><span class="lineno"> 2922</span>    <span class="comment"># there is only one real pole =&gt; use KNV0 on this real pole seem to work</span></div>
<div class="line"><span class="lineno"> 2923</span>    <span class="keywordflow">if</span> nb_real &gt; 0:</div>
<div class="line"><span class="lineno"> 2924</span>        <span class="comment">#update the biggest real pole with the smallest one</span></div>
<div class="line"><span class="lineno"> 2925</span>        update_order = [[nb_real], [1]]</div>
<div class="line"><span class="lineno"> 2926</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2927</span>        update_order = [[],[]]</div>
<div class="line"><span class="lineno"> 2928</span> </div>
<div class="line"><span class="lineno"> 2929</span>    r_comp = np.arange(nb_real+1, len(poles)+1, 2)</div>
<div class="line"><span class="lineno"> 2930</span>    <span class="comment"># step 1.a</span></div>
<div class="line"><span class="lineno"> 2931</span>    r_p = np.arange(1, hnb+nb_real % 2)</div>
<div class="line"><span class="lineno"> 2932</span>    update_order[0].extend(2*r_p)</div>
<div class="line"><span class="lineno"> 2933</span>    update_order[1].extend(2*r_p+1)</div>
<div class="line"><span class="lineno"> 2934</span>    <span class="comment"># step 1.b</span></div>
<div class="line"><span class="lineno"> 2935</span>    update_order[0].extend(r_comp)</div>
<div class="line"><span class="lineno"> 2936</span>    update_order[1].extend(r_comp+1)</div>
<div class="line"><span class="lineno"> 2937</span>    <span class="comment"># step 1.c</span></div>
<div class="line"><span class="lineno"> 2938</span>    r_p = np.arange(1, hnb+1)</div>
<div class="line"><span class="lineno"> 2939</span>    update_order[0].extend(2*r_p-1)</div>
<div class="line"><span class="lineno"> 2940</span>    update_order[1].extend(2*r_p)</div>
<div class="line"><span class="lineno"> 2941</span>    <span class="comment"># step 1.d</span></div>
<div class="line"><span class="lineno"> 2942</span>    <span class="keywordflow">if</span> hnb == 0 <span class="keywordflow">and</span> np.isreal(poles[0]):</div>
<div class="line"><span class="lineno"> 2943</span>        update_order[0].append(1)</div>
<div class="line"><span class="lineno"> 2944</span>        update_order[1].append(1)</div>
<div class="line"><span class="lineno"> 2945</span>    update_order[0].extend(r_comp)</div>
<div class="line"><span class="lineno"> 2946</span>    update_order[1].extend(r_comp+1)</div>
<div class="line"><span class="lineno"> 2947</span>    <span class="comment"># step 2.a</span></div>
<div class="line"><span class="lineno"> 2948</span>    r_j = np.arange(2, hnb+nb_real % 2)</div>
<div class="line"><span class="lineno"> 2949</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> r_j:</div>
<div class="line"><span class="lineno"> 2950</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, hnb+1):</div>
<div class="line"><span class="lineno"> 2951</span>            update_order[0].append(i)</div>
<div class="line"><span class="lineno"> 2952</span>            update_order[1].append(i+j)</div>
<div class="line"><span class="lineno"> 2953</span>    <span class="comment"># step 2.b</span></div>
<div class="line"><span class="lineno"> 2954</span>    <span class="keywordflow">if</span> hnb == 0 <span class="keywordflow">and</span> np.isreal(poles[0]):</div>
<div class="line"><span class="lineno"> 2955</span>        update_order[0].append(1)</div>
<div class="line"><span class="lineno"> 2956</span>        update_order[1].append(1)</div>
<div class="line"><span class="lineno"> 2957</span>    update_order[0].extend(r_comp)</div>
<div class="line"><span class="lineno"> 2958</span>    update_order[1].extend(r_comp+1)</div>
<div class="line"><span class="lineno"> 2959</span>    <span class="comment"># step 2.c</span></div>
<div class="line"><span class="lineno"> 2960</span>    r_j = np.arange(2, hnb+nb_real % 2)</div>
<div class="line"><span class="lineno"> 2961</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> r_j:</div>
<div class="line"><span class="lineno"> 2962</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(hnb+1, nb_real+1):</div>
<div class="line"><span class="lineno"> 2963</span>            idx_1 = i+j</div>
<div class="line"><span class="lineno"> 2964</span>            <span class="keywordflow">if</span> idx_1 &gt; nb_real:</div>
<div class="line"><span class="lineno"> 2965</span>                idx_1 = i+j-nb_real</div>
<div class="line"><span class="lineno"> 2966</span>            update_order[0].append(i)</div>
<div class="line"><span class="lineno"> 2967</span>            update_order[1].append(idx_1)</div>
<div class="line"><span class="lineno"> 2968</span>    <span class="comment"># step 2.d</span></div>
<div class="line"><span class="lineno"> 2969</span>    <span class="keywordflow">if</span> hnb == 0 <span class="keywordflow">and</span> np.isreal(poles[0]):</div>
<div class="line"><span class="lineno"> 2970</span>        update_order[0].append(1)</div>
<div class="line"><span class="lineno"> 2971</span>        update_order[1].append(1)</div>
<div class="line"><span class="lineno"> 2972</span>    update_order[0].extend(r_comp)</div>
<div class="line"><span class="lineno"> 2973</span>    update_order[1].extend(r_comp+1)</div>
<div class="line"><span class="lineno"> 2974</span>    <span class="comment"># step 3.a</span></div>
<div class="line"><span class="lineno"> 2975</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, hnb+1):</div>
<div class="line"><span class="lineno"> 2976</span>        update_order[0].append(i)</div>
<div class="line"><span class="lineno"> 2977</span>        update_order[1].append(i+hnb)</div>
<div class="line"><span class="lineno"> 2978</span>    <span class="comment"># step 3.b</span></div>
<div class="line"><span class="lineno"> 2979</span>    <span class="keywordflow">if</span> hnb == 0 <span class="keywordflow">and</span> np.isreal(poles[0]):</div>
<div class="line"><span class="lineno"> 2980</span>        update_order[0].append(1)</div>
<div class="line"><span class="lineno"> 2981</span>        update_order[1].append(1)</div>
<div class="line"><span class="lineno"> 2982</span>    update_order[0].extend(r_comp)</div>
<div class="line"><span class="lineno"> 2983</span>    update_order[1].extend(r_comp+1)</div>
<div class="line"><span class="lineno"> 2984</span> </div>
<div class="line"><span class="lineno"> 2985</span>    update_order = np.array(update_order).T-1</div>
<div class="line"><span class="lineno"> 2986</span>    stop = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2987</span>    nb_try = 0</div>
<div class="line"><span class="lineno"> 2988</span>    <span class="keywordflow">while</span> nb_try &lt; maxiter <span class="keywordflow">and</span> <span class="keywordflow">not</span> stop:</div>
<div class="line"><span class="lineno"> 2989</span>        det_transfer_matrixb = np.abs(np.linalg.det(transfer_matrix))</div>
<div class="line"><span class="lineno"> 2990</span>        <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> update_order:</div>
<div class="line"><span class="lineno"> 2991</span>            <span class="keywordflow">if</span> i == j:</div>
<div class="line"><span class="lineno"> 2992</span>                <span class="keyword">assert</span> i == 0, <span class="stringliteral">&quot;i!=0 for KNV call in YT&quot;</span></div>
<div class="line"><span class="lineno"> 2993</span>                <span class="keyword">assert</span> np.isreal(poles[i]), <span class="stringliteral">&quot;calling KNV on a complex pole&quot;</span></div>
<div class="line"><span class="lineno"> 2994</span>                _KNV0(B, ker_pole, transfer_matrix, i, poles)</div>
<div class="line"><span class="lineno"> 2995</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2996</span>                transfer_matrix_not_i_j = np.delete(transfer_matrix, (i, j),</div>
<div class="line"><span class="lineno"> 2997</span>                                                    axis=1)</div>
<div class="line"><span class="lineno"> 2998</span>                <span class="comment"># after merge of gh-4249 great speed improvements could be</span></div>
<div class="line"><span class="lineno"> 2999</span>                <span class="comment"># achieved using QR updates instead of full QR in the line below</span></div>
<div class="line"><span class="lineno"> 3000</span> </div>
<div class="line"><span class="lineno"> 3001</span>                <span class="comment">#to debug with numpy qr uncomment the line below</span></div>
<div class="line"><span class="lineno"> 3002</span>                <span class="comment">#Q, _ = np.linalg.qr(transfer_matrix_not_i_j, mode=&quot;complete&quot;)</span></div>
<div class="line"><span class="lineno"> 3003</span>                Q, _ = s_qr(transfer_matrix_not_i_j, mode=<span class="stringliteral">&quot;full&quot;</span>)</div>
<div class="line"><span class="lineno"> 3004</span> </div>
<div class="line"><span class="lineno"> 3005</span>                <span class="keywordflow">if</span> np.isreal(poles[i]):</div>
<div class="line"><span class="lineno"> 3006</span>                    <span class="keyword">assert</span> np.isreal(poles[j]), <span class="stringliteral">&quot;mixing real and complex &quot;</span> + \</div>
<div class="line"><span class="lineno"> 3007</span>                        <span class="stringliteral">&quot;in YT_real&quot;</span> + str(poles)</div>
<div class="line"><span class="lineno"> 3008</span>                    _YT_real(ker_pole, Q, transfer_matrix, i, j)</div>
<div class="line"><span class="lineno"> 3009</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3010</span>                    <span class="keyword">assert</span> ~np.isreal(poles[i]), <span class="stringliteral">&quot;mixing real and complex &quot;</span> + \</div>
<div class="line"><span class="lineno"> 3011</span>                        <span class="stringliteral">&quot;in YT_real&quot;</span> + str(poles)</div>
<div class="line"><span class="lineno"> 3012</span>                    _YT_complex(ker_pole, Q, transfer_matrix, i, j)</div>
<div class="line"><span class="lineno"> 3013</span> </div>
<div class="line"><span class="lineno"> 3014</span>        det_transfer_matrix = np.max((np.sqrt(np.spacing(1)),</div>
<div class="line"><span class="lineno"> 3015</span>                                  np.abs(np.linalg.det(transfer_matrix))))</div>
<div class="line"><span class="lineno"> 3016</span>        cur_rtol = np.abs(</div>
<div class="line"><span class="lineno"> 3017</span>            (det_transfer_matrix -</div>
<div class="line"><span class="lineno"> 3018</span>             det_transfer_matrixb) /</div>
<div class="line"><span class="lineno"> 3019</span>            det_transfer_matrix)</div>
<div class="line"><span class="lineno"> 3020</span>        <span class="keywordflow">if</span> cur_rtol &lt; rtol <span class="keywordflow">and</span> det_transfer_matrix &gt; np.sqrt(np.spacing(1)):</div>
<div class="line"><span class="lineno"> 3021</span>            <span class="comment"># Convergence test from YT page 21</span></div>
<div class="line"><span class="lineno"> 3022</span>            stop = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3023</span>        nb_try += 1</div>
<div class="line"><span class="lineno"> 3024</span>    <span class="keywordflow">return</span> stop, cur_rtol, nb_try</div>
<div class="line"><span class="lineno"> 3025</span> </div>
<div class="line"><span class="lineno"> 3026</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f4288e056f809dfaa360e79ec95fe64" name="a1f4288e056f809dfaa360e79ec95fe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4288e056f809dfaa360e79ec95fe64">&#9670;&#160;</a></span>_YT_real()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._YT_real </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ker_pole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transfer_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Applies algorithm from YT section 6.1 page 19 related to real pairs
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2788</span><span class="keyword">def </span>_YT_real(ker_pole, Q, transfer_matrix, i, j):</div>
<div class="line"><span class="lineno"> 2789</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">    Applies algorithm from YT section 6.1 page 19 related to real pairs</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2792</span>    <span class="comment"># step 1 page 19</span></div>
<div class="line"><span class="lineno"> 2793</span>    u = Q[:, -2, np.newaxis]</div>
<div class="line"><span class="lineno"> 2794</span>    v = Q[:, -1, np.newaxis]</div>
<div class="line"><span class="lineno"> 2795</span> </div>
<div class="line"><span class="lineno"> 2796</span>    <span class="comment"># step 2 page 19</span></div>
<div class="line"><span class="lineno"> 2797</span>    m = np.dot(np.dot(ker_pole[i].T, np.dot(u, v.T) -</div>
<div class="line"><span class="lineno"> 2798</span>        np.dot(v, u.T)), ker_pole[j])</div>
<div class="line"><span class="lineno"> 2799</span> </div>
<div class="line"><span class="lineno"> 2800</span>    <span class="comment"># step 3 page 19</span></div>
<div class="line"><span class="lineno"> 2801</span>    um, sm, vm = np.linalg.svd(m)</div>
<div class="line"><span class="lineno"> 2802</span>    <span class="comment"># mu1, mu2 two first columns of U =&gt; 2 first lines of U.T</span></div>
<div class="line"><span class="lineno"> 2803</span>    mu1, mu2 = um.T[:2, :, np.newaxis]</div>
<div class="line"><span class="lineno"> 2804</span>    <span class="comment"># VM is V.T with numpy we want the first two lines of V.T</span></div>
<div class="line"><span class="lineno"> 2805</span>    nu1, nu2 = vm[:2, :, np.newaxis]</div>
<div class="line"><span class="lineno"> 2806</span> </div>
<div class="line"><span class="lineno"> 2807</span>    <span class="comment"># what follows is a rough python translation of the formulas</span></div>
<div class="line"><span class="lineno"> 2808</span>    <span class="comment"># in section 6.2 page 20 (step 4)</span></div>
<div class="line"><span class="lineno"> 2809</span>    transfer_matrix_j_mo_transfer_matrix_j = np.vstack((</div>
<div class="line"><span class="lineno"> 2810</span>            transfer_matrix[:, i, np.newaxis],</div>
<div class="line"><span class="lineno"> 2811</span>            transfer_matrix[:, j, np.newaxis]))</div>
<div class="line"><span class="lineno"> 2812</span> </div>
<div class="line"><span class="lineno"> 2813</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.allclose(sm[0], sm[1]):</div>
<div class="line"><span class="lineno"> 2814</span>        ker_pole_imo_mu1 = np.dot(ker_pole[i], mu1)</div>
<div class="line"><span class="lineno"> 2815</span>        ker_pole_i_nu1 = np.dot(ker_pole[j], nu1)</div>
<div class="line"><span class="lineno"> 2816</span>        ker_pole_mu_nu = np.vstack((ker_pole_imo_mu1, ker_pole_i_nu1))</div>
<div class="line"><span class="lineno"> 2817</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2818</span>        ker_pole_ij = np.vstack((</div>
<div class="line"><span class="lineno"> 2819</span>                                np.hstack((ker_pole[i],</div>
<div class="line"><span class="lineno"> 2820</span>                                           np.zeros(ker_pole[i].shape))),</div>
<div class="line"><span class="lineno"> 2821</span>                                np.hstack((np.zeros(ker_pole[j].shape),</div>
<div class="line"><span class="lineno"> 2822</span>                                                    ker_pole[j]))</div>
<div class="line"><span class="lineno"> 2823</span>                                ))</div>
<div class="line"><span class="lineno"> 2824</span>        mu_nu_matrix = np.vstack(</div>
<div class="line"><span class="lineno"> 2825</span>            (np.hstack((mu1, mu2)), np.hstack((nu1, nu2)))</div>
<div class="line"><span class="lineno"> 2826</span>            )</div>
<div class="line"><span class="lineno"> 2827</span>        ker_pole_mu_nu = np.dot(ker_pole_ij, mu_nu_matrix)</div>
<div class="line"><span class="lineno"> 2828</span>    transfer_matrix_ij = np.dot(np.dot(ker_pole_mu_nu, ker_pole_mu_nu.T),</div>
<div class="line"><span class="lineno"> 2829</span>                             transfer_matrix_j_mo_transfer_matrix_j)</div>
<div class="line"><span class="lineno"> 2830</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.allclose(transfer_matrix_ij, 0):</div>
<div class="line"><span class="lineno"> 2831</span>        transfer_matrix_ij = (np.sqrt(2)*transfer_matrix_ij /</div>
<div class="line"><span class="lineno"> 2832</span>                              np.linalg.norm(transfer_matrix_ij))</div>
<div class="line"><span class="lineno"> 2833</span>        transfer_matrix[:, i] = transfer_matrix_ij[</div>
<div class="line"><span class="lineno"> 2834</span>            :transfer_matrix[:, i].shape[0], 0</div>
<div class="line"><span class="lineno"> 2835</span>            ]</div>
<div class="line"><span class="lineno"> 2836</span>        transfer_matrix[:, j] = transfer_matrix_ij[</div>
<div class="line"><span class="lineno"> 2837</span>            transfer_matrix[:, i].shape[0]:, 0</div>
<div class="line"><span class="lineno"> 2838</span>            ]</div>
<div class="line"><span class="lineno"> 2839</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2840</span>        <span class="comment"># As in knv0 if transfer_matrix_j_mo_transfer_matrix_j is orthogonal to</span></div>
<div class="line"><span class="lineno"> 2841</span>        <span class="comment"># Vect{ker_pole_mu_nu} assign transfer_matrixi/transfer_matrix_j to</span></div>
<div class="line"><span class="lineno"> 2842</span>        <span class="comment"># ker_pole_mu_nu and iterate. As we are looking for a vector in</span></div>
<div class="line"><span class="lineno"> 2843</span>        <span class="comment"># Vect{Matker_pole_MU_NU} (see section 6.1 page 19) this might help</span></div>
<div class="line"><span class="lineno"> 2844</span>        <span class="comment"># (that&#39;s a guess, not a claim !)</span></div>
<div class="line"><span class="lineno"> 2845</span>        transfer_matrix[:, i] = ker_pole_mu_nu[</div>
<div class="line"><span class="lineno"> 2846</span>            :transfer_matrix[:, i].shape[0], 0</div>
<div class="line"><span class="lineno"> 2847</span>            ]</div>
<div class="line"><span class="lineno"> 2848</span>        transfer_matrix[:, j] = ker_pole_mu_nu[</div>
<div class="line"><span class="lineno"> 2849</span>            transfer_matrix[:, i].shape[0]:, 0</div>
<div class="line"><span class="lineno"> 2850</span>            ]</div>
<div class="line"><span class="lineno"> 2851</span> </div>
<div class="line"><span class="lineno"> 2852</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4" name="aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4">&#9670;&#160;</a></span>bode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.bode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate Bode magnitude and phase data of a continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

w : array_like, optional
    Array of frequencies (in rad/s). Magnitude and phase data is calculated
    for every value in this array. If not given a reasonable set will be
    calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
    Frequency array [rad/s]
mag : 1D ndarray
    Magnitude array [dB]
phase : 1D ndarray
    Phase array [deg]

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 1])
&gt;&gt;&gt; w, mag, phase = signal.bode(sys)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2514</span><span class="keyword">def </span>bode(system, w=None, n=100):</div>
<div class="line"><span class="lineno"> 2515</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">    Calculate Bode magnitude and phase data of a continuous-time system.</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral">    system : an instance of the LTI class or a tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">            * 1 (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral">            * 2 (num, den)</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral">            * 3 (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral">            * 4 (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">    w : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">        Array of frequencies (in rad/s). Magnitude and phase data is calculated</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral">        for every value in this array. If not given a reasonable set will be</span></div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">        calculated.</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">        Number of frequency points to compute if `w` is not given. The `n`</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">        frequencies are logarithmically spaced in an interval chosen to</span></div>
<div class="line"><span class="lineno"> 2536</span><span class="stringliteral">        include the influence of the poles and zeros of the system.</span></div>
<div class="line"><span class="lineno"> 2537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2538</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2539</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2540</span><span class="stringliteral">    w : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">        Frequency array [rad/s]</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral">    mag : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral">        Magnitude array [dB]</span></div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">    phase : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral">        Phase array [deg]</span></div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2555</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2556</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2557</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2558</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral">    &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 1])</span></div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral">    &gt;&gt;&gt; w, mag, phase = signal.bode(sys)</span></div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2570</span>    w, y = freqresp(system, w=w, n=n)</div>
<div class="line"><span class="lineno"> 2571</span> </div>
<div class="line"><span class="lineno"> 2572</span>    mag = 20.0 * numpy.log10(abs(y))</div>
<div class="line"><span class="lineno"> 2573</span>    phase = numpy.unwrap(numpy.arctan2(y.imag, y.real)) * 180.0 / numpy.pi</div>
<div class="line"><span class="lineno"> 2574</span> </div>
<div class="line"><span class="lineno"> 2575</span>    <span class="keywordflow">return</span> w, mag, phase</div>
<div class="line"><span class="lineno"> 2576</span> </div>
<div class="line"><span class="lineno"> 2577</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a008bf6e9a51183d42a73d86718cb879c" name="a008bf6e9a51183d42a73d86718cb879c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008bf6e9a51183d42a73d86718cb879c">&#9670;&#160;</a></span>dbode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dbode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate Bode magnitude and phase data of a discrete-time system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:

    * 1 (instance of `dlti`)
    * 2 (num, den, dt)
    * 3 (zeros, poles, gain, dt)
    * 4 (A, B, C, D, dt)

w : array_like, optional
Array of frequencies (in radians/sample). Magnitude and phase data is
calculated for every value in this array. If not given a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if `w` is not given. The `n`
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
Frequency array [rad/time_unit]
mag : 1D ndarray
Magnitude array [dB]
phase : 1D ndarray
Phase array [deg]

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.18.0

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct the transfer function :math:`H(z) = \frac{1}{z^2 + 2z + 3}` with
a sampling time of 0.05 seconds:

&gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)

Equivalent: sys.bode()

&gt;&gt;&gt; w, mag, phase = signal.dbode(sys)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3791</span><span class="keyword">def </span>dbode(system, w=None, n=100):</div>
<div class="line"><span class="lineno"> 3792</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3793</span><span class="stringliteral">    Calculate Bode magnitude and phase data of a discrete-time system.</span></div>
<div class="line"><span class="lineno"> 3794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3795</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3796</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3797</span><span class="stringliteral">    system : an instance of the LTI class or a tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 3798</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 3799</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 3800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3801</span><span class="stringliteral">            * 1 (instance of `dlti`)</span></div>
<div class="line"><span class="lineno"> 3802</span><span class="stringliteral">            * 2 (num, den, dt)</span></div>
<div class="line"><span class="lineno"> 3803</span><span class="stringliteral">            * 3 (zeros, poles, gain, dt)</span></div>
<div class="line"><span class="lineno"> 3804</span><span class="stringliteral">            * 4 (A, B, C, D, dt)</span></div>
<div class="line"><span class="lineno"> 3805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3806</span><span class="stringliteral">    w : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3807</span><span class="stringliteral">        Array of frequencies (in radians/sample). Magnitude and phase data is</span></div>
<div class="line"><span class="lineno"> 3808</span><span class="stringliteral">        calculated for every value in this array. If not given a reasonable</span></div>
<div class="line"><span class="lineno"> 3809</span><span class="stringliteral">        set will be calculated.</span></div>
<div class="line"><span class="lineno"> 3810</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 3811</span><span class="stringliteral">        Number of frequency points to compute if `w` is not given. The `n`</span></div>
<div class="line"><span class="lineno"> 3812</span><span class="stringliteral">        frequencies are logarithmically spaced in an interval chosen to</span></div>
<div class="line"><span class="lineno"> 3813</span><span class="stringliteral">        include the influence of the poles and zeros of the system.</span></div>
<div class="line"><span class="lineno"> 3814</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3815</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3816</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3817</span><span class="stringliteral">    w : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 3818</span><span class="stringliteral">        Frequency array [rad/time_unit]</span></div>
<div class="line"><span class="lineno"> 3819</span><span class="stringliteral">    mag : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 3820</span><span class="stringliteral">        Magnitude array [dB]</span></div>
<div class="line"><span class="lineno"> 3821</span><span class="stringliteral">    phase : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 3822</span><span class="stringliteral">        Phase array [deg]</span></div>
<div class="line"><span class="lineno"> 3823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3824</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3825</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3826</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 3827</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 3828</span><span class="stringliteral">    order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 3829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3830</span><span class="stringliteral">    .. versionadded:: 0.18.0</span></div>
<div class="line"><span class="lineno"> 3831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3832</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3833</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3834</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3835</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3837</span><span class="stringliteral">    Construct the transfer function :math:`H(z) = \frac{1}{z^2 + 2z + 3}` with</span></div>
<div class="line"><span class="lineno"> 3838</span><span class="stringliteral">    a sampling time of 0.05 seconds:</span></div>
<div class="line"><span class="lineno"> 3839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3840</span><span class="stringliteral">    &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)</span></div>
<div class="line"><span class="lineno"> 3841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3842</span><span class="stringliteral">    Equivalent: sys.bode()</span></div>
<div class="line"><span class="lineno"> 3843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3844</span><span class="stringliteral">    &gt;&gt;&gt; w, mag, phase = signal.dbode(sys)</span></div>
<div class="line"><span class="lineno"> 3845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3846</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3847</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot</span></div>
<div class="line"><span class="lineno"> 3848</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3849</span><span class="stringliteral">    &gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot</span></div>
<div class="line"><span class="lineno"> 3850</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3852</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3853</span>    w, y = dfreqresp(system, w=w, n=n)</div>
<div class="line"><span class="lineno"> 3854</span> </div>
<div class="line"><span class="lineno"> 3855</span>    <span class="keywordflow">if</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 3856</span>        dt = system.dt</div>
<div class="line"><span class="lineno"> 3857</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3858</span>        dt = system[-1]</div>
<div class="line"><span class="lineno"> 3859</span> </div>
<div class="line"><span class="lineno"> 3860</span>    mag = 20.0 * numpy.log10(abs(y))</div>
<div class="line"><span class="lineno"> 3861</span>    phase = numpy.rad2deg(numpy.unwrap(numpy.angle(y)))</div>
<div class="line"><span class="lineno"> 3862</span> </div>
<div class="line"><span class="lineno"> 3863</span>    <span class="keywordflow">return</span> w / dt, mag, phase</div>
</div><!-- fragment -->
</div>
</div>
<a id="aafc2d5055e90d297dbde688307acaa5b" name="aafc2d5055e90d297dbde688307acaa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc2d5055e90d297dbde688307acaa5b">&#9670;&#160;</a></span>dfreqresp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dfreqresp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>10000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>whole</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the frequency response of a discrete-time system.

Parameters
----------
system : an instance of the `dlti` class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `dlti`)
        * 2 (numerator, denominator, dt)
        * 3 (zeros, poles, gain, dt)
        * 4 (A, B, C, D, dt)

w : array_like, optional
    Array of frequencies (in radians/sample). Magnitude and phase data is
    calculated for every value in this array. If not given a reasonable
    set will be calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.
whole : bool, optional
    Normally, if 'w' is not given, frequencies are computed from 0 to the
    Nyquist frequency, pi radians/sample (upper-half of unit-circle). If
    `whole` is True, compute frequencies from 0 to 2*pi radians/sample.

Returns
-------
w : 1D ndarray
    Frequency array [radians/sample]
H : 1D ndarray
    Array of complex magnitude values

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.18.0

Examples
--------
Generating the Nyquist plot of a transfer function

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct the transfer function
:math:`H(z) = \frac{1}{z^2 + 2z + 3}` with a sampling time of 0.05
seconds:

&gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)

&gt;&gt;&gt; w, H = signal.dfreqresp(sys)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(H.real, H.imag, "b")
&gt;&gt;&gt; plt.plot(H.real, -H.imag, "r")
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3691</span><span class="keyword">def </span>dfreqresp(system, w=None, n=10000, whole=False):</div>
<div class="line"><span class="lineno"> 3692</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3693</span><span class="stringliteral">    Calculate the frequency response of a discrete-time system.</span></div>
<div class="line"><span class="lineno"> 3694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3695</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3696</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3697</span><span class="stringliteral">    system : an instance of the `dlti` class or a tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 3698</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 3699</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 3700</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3701</span><span class="stringliteral">            * 1 (instance of `dlti`)</span></div>
<div class="line"><span class="lineno"> 3702</span><span class="stringliteral">            * 2 (numerator, denominator, dt)</span></div>
<div class="line"><span class="lineno"> 3703</span><span class="stringliteral">            * 3 (zeros, poles, gain, dt)</span></div>
<div class="line"><span class="lineno"> 3704</span><span class="stringliteral">            * 4 (A, B, C, D, dt)</span></div>
<div class="line"><span class="lineno"> 3705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3706</span><span class="stringliteral">    w : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3707</span><span class="stringliteral">        Array of frequencies (in radians/sample). Magnitude and phase data is</span></div>
<div class="line"><span class="lineno"> 3708</span><span class="stringliteral">        calculated for every value in this array. If not given a reasonable</span></div>
<div class="line"><span class="lineno"> 3709</span><span class="stringliteral">        set will be calculated.</span></div>
<div class="line"><span class="lineno"> 3710</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 3711</span><span class="stringliteral">        Number of frequency points to compute if `w` is not given. The `n`</span></div>
<div class="line"><span class="lineno"> 3712</span><span class="stringliteral">        frequencies are logarithmically spaced in an interval chosen to</span></div>
<div class="line"><span class="lineno"> 3713</span><span class="stringliteral">        include the influence of the poles and zeros of the system.</span></div>
<div class="line"><span class="lineno"> 3714</span><span class="stringliteral">    whole : bool, optional</span></div>
<div class="line"><span class="lineno"> 3715</span><span class="stringliteral">        Normally, if &#39;w&#39; is not given, frequencies are computed from 0 to the</span></div>
<div class="line"><span class="lineno"> 3716</span><span class="stringliteral">        Nyquist frequency, pi radians/sample (upper-half of unit-circle). If</span></div>
<div class="line"><span class="lineno"> 3717</span><span class="stringliteral">        `whole` is True, compute frequencies from 0 to 2*pi radians/sample.</span></div>
<div class="line"><span class="lineno"> 3718</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3719</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3720</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3721</span><span class="stringliteral">    w : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 3722</span><span class="stringliteral">        Frequency array [radians/sample]</span></div>
<div class="line"><span class="lineno"> 3723</span><span class="stringliteral">    H : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 3724</span><span class="stringliteral">        Array of complex magnitude values</span></div>
<div class="line"><span class="lineno"> 3725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3726</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3727</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3728</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 3729</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 3730</span><span class="stringliteral">    order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 3731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3732</span><span class="stringliteral">    .. versionadded:: 0.18.0</span></div>
<div class="line"><span class="lineno"> 3733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3734</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3735</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3736</span><span class="stringliteral">    Generating the Nyquist plot of a transfer function</span></div>
<div class="line"><span class="lineno"> 3737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3738</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3739</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3741</span><span class="stringliteral">    Construct the transfer function</span></div>
<div class="line"><span class="lineno"> 3742</span><span class="stringliteral">    :math:`H(z) = \frac{1}{z^2 + 2z + 3}` with a sampling time of 0.05</span></div>
<div class="line"><span class="lineno"> 3743</span><span class="stringliteral">    seconds:</span></div>
<div class="line"><span class="lineno"> 3744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3745</span><span class="stringliteral">    &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)</span></div>
<div class="line"><span class="lineno"> 3746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3747</span><span class="stringliteral">    &gt;&gt;&gt; w, H = signal.dfreqresp(sys)</span></div>
<div class="line"><span class="lineno"> 3748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3749</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3750</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(H.real, H.imag, &quot;b&quot;)</span></div>
<div class="line"><span class="lineno"> 3751</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(H.real, -H.imag, &quot;r&quot;)</span></div>
<div class="line"><span class="lineno"> 3752</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3754</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3755</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 3756</span>        <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 3757</span>            <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;dfreqresp can only be used with &#39;</span></div>
<div class="line"><span class="lineno"> 3758</span>                                 <span class="stringliteral">&#39;discrete-time systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3759</span> </div>
<div class="line"><span class="lineno"> 3760</span>        system = dlti(*system[:-1], dt=system[-1])</div>
<div class="line"><span class="lineno"> 3761</span> </div>
<div class="line"><span class="lineno"> 3762</span>    <span class="keywordflow">if</span> isinstance(system, StateSpace):</div>
<div class="line"><span class="lineno"> 3763</span>        <span class="comment"># No SS-&gt;ZPK code exists right now, just SS-&gt;TF-&gt;ZPK</span></div>
<div class="line"><span class="lineno"> 3764</span>        system = system._as_tf()</div>
<div class="line"><span class="lineno"> 3765</span> </div>
<div class="line"><span class="lineno"> 3766</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(system, (TransferFunction, ZerosPolesGain)):</div>
<div class="line"><span class="lineno"> 3767</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Unknown system type&#39;</span>)</div>
<div class="line"><span class="lineno"> 3768</span> </div>
<div class="line"><span class="lineno"> 3769</span>    <span class="keywordflow">if</span> system.inputs != 1 <span class="keywordflow">or</span> system.outputs != 1:</div>
<div class="line"><span class="lineno"> 3770</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;dfreqresp requires a SISO (single input, single &quot;</span></div>
<div class="line"><span class="lineno"> 3771</span>                         <span class="stringliteral">&quot;output) system.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3772</span> </div>
<div class="line"><span class="lineno"> 3773</span>    <span class="keywordflow">if</span> w <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3774</span>        worN = w</div>
<div class="line"><span class="lineno"> 3775</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3776</span>        worN = n</div>
<div class="line"><span class="lineno"> 3777</span> </div>
<div class="line"><span class="lineno"> 3778</span>    <span class="keywordflow">if</span> isinstance(system, TransferFunction):</div>
<div class="line"><span class="lineno"> 3779</span>        <span class="comment"># Convert numerator and denominator from polynomials in the variable</span></div>
<div class="line"><span class="lineno"> 3780</span>        <span class="comment"># &#39;z&#39; to polynomials in the variable &#39;z^-1&#39;, as freqz expects.</span></div>
<div class="line"><span class="lineno"> 3781</span>        num, den = TransferFunction._z_to_zinv(system.num.ravel(), system.den)</div>
<div class="line"><span class="lineno"> 3782</span>        w, h = freqz(num, den, worN=worN, whole=whole)</div>
<div class="line"><span class="lineno"> 3783</span> </div>
<div class="line"><span class="lineno"> 3784</span>    <span class="keywordflow">elif</span> isinstance(system, ZerosPolesGain):</div>
<div class="line"><span class="lineno"> 3785</span>        w, h = freqz_zpk(system.zeros, system.poles, system.gain, worN=worN,</div>
<div class="line"><span class="lineno"> 3786</span>                         whole=whole)</div>
<div class="line"><span class="lineno"> 3787</span> </div>
<div class="line"><span class="lineno"> 3788</span>    <span class="keywordflow">return</span> w, h</div>
<div class="line"><span class="lineno"> 3789</span> </div>
<div class="line"><span class="lineno"> 3790</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7232a366e580be2067d3bc8340c639f2" name="a7232a366e580be2067d3bc8340c639f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7232a366e580be2067d3bc8340c639f2">&#9670;&#160;</a></span>dimpulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dimpulse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Impulse response of discrete-time system.

Parameters
----------
system : tuple of array_like or instance of `dlti`
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1: (instance of `dlti`)
        * 3: (num, den, dt)
        * 4: (zeros, poles, gain, dt)
        * 5: (A, B, C, D, dt)

x0 : array_like, optional
    Initial state-vector.  Defaults to zero.
t : array_like, optional
    Time points.  Computed if not given.
n : int, optional
    The number of time points to compute (if `t` is not given).

Returns
-------
tout : ndarray
    Time values for the output, as a 1-D array.
yout : tuple of ndarray
    Impulse response of system.  Each element of the tuple represents
    the output of the system based on an impulse in each input.

See Also
--------
impulse, dstep, dlsim, cont2discrete

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5))
&gt;&gt;&gt; t, y = signal.dimpulse(butter, n=25)
&gt;&gt;&gt; plt.step(t, np.squeeze(y))
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.xlabel('n [samples]')
&gt;&gt;&gt; plt.ylabel('Amplitude')</pre> <div class="fragment"><div class="line"><span class="lineno"> 3520</span><span class="keyword">def </span>dimpulse(system, x0=None, t=None, n=None):</div>
<div class="line"><span class="lineno"> 3521</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3522</span><span class="stringliteral">    Impulse response of discrete-time system.</span></div>
<div class="line"><span class="lineno"> 3523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3524</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3525</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3526</span><span class="stringliteral">    system : tuple of array_like or instance of `dlti`</span></div>
<div class="line"><span class="lineno"> 3527</span><span class="stringliteral">        A tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 3528</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 3529</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 3530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3531</span><span class="stringliteral">            * 1: (instance of `dlti`)</span></div>
<div class="line"><span class="lineno"> 3532</span><span class="stringliteral">            * 3: (num, den, dt)</span></div>
<div class="line"><span class="lineno"> 3533</span><span class="stringliteral">            * 4: (zeros, poles, gain, dt)</span></div>
<div class="line"><span class="lineno"> 3534</span><span class="stringliteral">            * 5: (A, B, C, D, dt)</span></div>
<div class="line"><span class="lineno"> 3535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3536</span><span class="stringliteral">    x0 : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3537</span><span class="stringliteral">        Initial state-vector.  Defaults to zero.</span></div>
<div class="line"><span class="lineno"> 3538</span><span class="stringliteral">    t : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3539</span><span class="stringliteral">        Time points.  Computed if not given.</span></div>
<div class="line"><span class="lineno"> 3540</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 3541</span><span class="stringliteral">        The number of time points to compute (if `t` is not given).</span></div>
<div class="line"><span class="lineno"> 3542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3543</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3544</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3545</span><span class="stringliteral">    tout : ndarray</span></div>
<div class="line"><span class="lineno"> 3546</span><span class="stringliteral">        Time values for the output, as a 1-D array.</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral">    yout : tuple of ndarray</span></div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral">        Impulse response of system.  Each element of the tuple represents</span></div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">        the output of the system based on an impulse in each input.</span></div>
<div class="line"><span class="lineno"> 3550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3551</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3552</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3553</span><span class="stringliteral">    impulse, dstep, dlsim, cont2discrete</span></div>
<div class="line"><span class="lineno"> 3554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3555</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3556</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3557</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3558</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3560</span><span class="stringliteral">    &gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5))</span></div>
<div class="line"><span class="lineno"> 3561</span><span class="stringliteral">    &gt;&gt;&gt; t, y = signal.dimpulse(butter, n=25)</span></div>
<div class="line"><span class="lineno"> 3562</span><span class="stringliteral">    &gt;&gt;&gt; plt.step(t, np.squeeze(y))</span></div>
<div class="line"><span class="lineno"> 3563</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid()</span></div>
<div class="line"><span class="lineno"> 3564</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;n [samples]&#39;)</span></div>
<div class="line"><span class="lineno"> 3565</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3568</span>    <span class="comment"># Convert system to dlti-StateSpace</span></div>
<div class="line"><span class="lineno"> 3569</span>    <span class="keywordflow">if</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 3570</span>        system = system._as_ss()</div>
<div class="line"><span class="lineno"> 3571</span>    <span class="keywordflow">elif</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 3572</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;dimpulse can only be used with discrete-time &#39;</span></div>
<div class="line"><span class="lineno"> 3573</span>                             <span class="stringliteral">&#39;dlti systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3574</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3575</span>        system = dlti(*system[:-1], dt=system[-1])._as_ss()</div>
<div class="line"><span class="lineno"> 3576</span> </div>
<div class="line"><span class="lineno"> 3577</span>    <span class="comment"># Default to 100 samples if unspecified</span></div>
<div class="line"><span class="lineno"> 3578</span>    <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3579</span>        n = 100</div>
<div class="line"><span class="lineno"> 3580</span> </div>
<div class="line"><span class="lineno"> 3581</span>    <span class="comment"># If time is not specified, use the number of samples</span></div>
<div class="line"><span class="lineno"> 3582</span>    <span class="comment"># and system dt</span></div>
<div class="line"><span class="lineno"> 3583</span>    <span class="keywordflow">if</span> t <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3584</span>        t = np.linspace(0, n * system.dt, n, endpoint=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3585</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3586</span>        t = np.asarray(t)</div>
<div class="line"><span class="lineno"> 3587</span> </div>
<div class="line"><span class="lineno"> 3588</span>    <span class="comment"># For each input, implement a step change</span></div>
<div class="line"><span class="lineno"> 3589</span>    yout = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3590</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, system.inputs):</div>
<div class="line"><span class="lineno"> 3591</span>        u = np.zeros((t.shape[0], system.inputs))</div>
<div class="line"><span class="lineno"> 3592</span>        u[0, i] = 1.0</div>
<div class="line"><span class="lineno"> 3593</span> </div>
<div class="line"><span class="lineno"> 3594</span>        one_output = dlsim(system, u, t=t, x0=x0)</div>
<div class="line"><span class="lineno"> 3595</span> </div>
<div class="line"><span class="lineno"> 3596</span>        <span class="keywordflow">if</span> yout <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3597</span>            yout = (one_output[1],)</div>
<div class="line"><span class="lineno"> 3598</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3599</span>            yout = yout + (one_output[1],)</div>
<div class="line"><span class="lineno"> 3600</span> </div>
<div class="line"><span class="lineno"> 3601</span>        tout = one_output[0]</div>
<div class="line"><span class="lineno"> 3602</span> </div>
<div class="line"><span class="lineno"> 3603</span>    <span class="keywordflow">return</span> tout, yout</div>
<div class="line"><span class="lineno"> 3604</span> </div>
<div class="line"><span class="lineno"> 3605</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5aab993a41192c63bde62a840751cdd9" name="a5aab993a41192c63bde62a840751cdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aab993a41192c63bde62a840751cdd9">&#9670;&#160;</a></span>dlsim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dlsim </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simulate output of a discrete-time linear system.

Parameters
----------
system : tuple of array_like or instance of `dlti`
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1: (instance of `dlti`)
        * 3: (num, den, dt)
        * 4: (zeros, poles, gain, dt)
        * 5: (A, B, C, D, dt)

u : array_like
    An input array describing the input at each time `t` (interpolation is
    assumed between given times).  If there are multiple inputs, then each
    column of the rank-2 array represents an input.
t : array_like, optional
    The time steps at which the input is defined.  If `t` is given, it
    must be the same length as `u`, and the final value in `t` determines
    the number of steps returned in the output.
x0 : array_like, optional
    The initial conditions on the state vector (zero by default).

Returns
-------
tout : ndarray
    Time values for the output, as a 1-D array.
yout : ndarray
    System response, as a 1-D array.
xout : ndarray, optional
    Time-evolution of the state-vector.  Only generated if the input is a
    `StateSpace` system.

See Also
--------
lsim, dstep, dimpulse, cont2discrete

Examples
--------
A simple integrator transfer function with a discrete time step of 1.0
could be implemented as:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; tf = ([1.0,], [1.0, -1.0], 1.0)
&gt;&gt;&gt; t_in = [0.0, 1.0, 2.0, 3.0]
&gt;&gt;&gt; u = np.asarray([0.0, 0.0, 1.0, 1.0])
&gt;&gt;&gt; t_out, y = signal.dlsim(tf, u, t=t_in)
&gt;&gt;&gt; y.T
array([[ 0.,  0.,  0.,  1.]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3404</span><span class="keyword">def </span>dlsim(system, u, t=None, x0=None):</div>
<div class="line"><span class="lineno"> 3405</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3406</span><span class="stringliteral">    Simulate output of a discrete-time linear system.</span></div>
<div class="line"><span class="lineno"> 3407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3408</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3409</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3410</span><span class="stringliteral">    system : tuple of array_like or instance of `dlti`</span></div>
<div class="line"><span class="lineno"> 3411</span><span class="stringliteral">        A tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 3412</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 3413</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 3414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3415</span><span class="stringliteral">            * 1: (instance of `dlti`)</span></div>
<div class="line"><span class="lineno"> 3416</span><span class="stringliteral">            * 3: (num, den, dt)</span></div>
<div class="line"><span class="lineno"> 3417</span><span class="stringliteral">            * 4: (zeros, poles, gain, dt)</span></div>
<div class="line"><span class="lineno"> 3418</span><span class="stringliteral">            * 5: (A, B, C, D, dt)</span></div>
<div class="line"><span class="lineno"> 3419</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3420</span><span class="stringliteral">    u : array_like</span></div>
<div class="line"><span class="lineno"> 3421</span><span class="stringliteral">        An input array describing the input at each time `t` (interpolation is</span></div>
<div class="line"><span class="lineno"> 3422</span><span class="stringliteral">        assumed between given times).  If there are multiple inputs, then each</span></div>
<div class="line"><span class="lineno"> 3423</span><span class="stringliteral">        column of the rank-2 array represents an input.</span></div>
<div class="line"><span class="lineno"> 3424</span><span class="stringliteral">    t : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3425</span><span class="stringliteral">        The time steps at which the input is defined.  If `t` is given, it</span></div>
<div class="line"><span class="lineno"> 3426</span><span class="stringliteral">        must be the same length as `u`, and the final value in `t` determines</span></div>
<div class="line"><span class="lineno"> 3427</span><span class="stringliteral">        the number of steps returned in the output.</span></div>
<div class="line"><span class="lineno"> 3428</span><span class="stringliteral">    x0 : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3429</span><span class="stringliteral">        The initial conditions on the state vector (zero by default).</span></div>
<div class="line"><span class="lineno"> 3430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3431</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3432</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3433</span><span class="stringliteral">    tout : ndarray</span></div>
<div class="line"><span class="lineno"> 3434</span><span class="stringliteral">        Time values for the output, as a 1-D array.</span></div>
<div class="line"><span class="lineno"> 3435</span><span class="stringliteral">    yout : ndarray</span></div>
<div class="line"><span class="lineno"> 3436</span><span class="stringliteral">        System response, as a 1-D array.</span></div>
<div class="line"><span class="lineno"> 3437</span><span class="stringliteral">    xout : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3438</span><span class="stringliteral">        Time-evolution of the state-vector.  Only generated if the input is a</span></div>
<div class="line"><span class="lineno"> 3439</span><span class="stringliteral">        `StateSpace` system.</span></div>
<div class="line"><span class="lineno"> 3440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral">    lsim, dstep, dimpulse, cont2discrete</span></div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3446</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3447</span><span class="stringliteral">    A simple integrator transfer function with a discrete time step of 1.0</span></div>
<div class="line"><span class="lineno"> 3448</span><span class="stringliteral">    could be implemented as:</span></div>
<div class="line"><span class="lineno"> 3449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3450</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3451</span><span class="stringliteral">    &gt;&gt;&gt; tf = ([1.0,], [1.0, -1.0], 1.0)</span></div>
<div class="line"><span class="lineno"> 3452</span><span class="stringliteral">    &gt;&gt;&gt; t_in = [0.0, 1.0, 2.0, 3.0]</span></div>
<div class="line"><span class="lineno"> 3453</span><span class="stringliteral">    &gt;&gt;&gt; u = np.asarray([0.0, 0.0, 1.0, 1.0])</span></div>
<div class="line"><span class="lineno"> 3454</span><span class="stringliteral">    &gt;&gt;&gt; t_out, y = signal.dlsim(tf, u, t=t_in)</span></div>
<div class="line"><span class="lineno"> 3455</span><span class="stringliteral">    &gt;&gt;&gt; y.T</span></div>
<div class="line"><span class="lineno"> 3456</span><span class="stringliteral">    array([[ 0.,  0.,  0.,  1.]])</span></div>
<div class="line"><span class="lineno"> 3457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3458</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3459</span>    <span class="comment"># Convert system to dlti-StateSpace</span></div>
<div class="line"><span class="lineno"> 3460</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 3461</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;dlsim can only be used with discrete-time dlti &#39;</span></div>
<div class="line"><span class="lineno"> 3462</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3463</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 3464</span>        system = dlti(*system[:-1], dt=system[-1])</div>
<div class="line"><span class="lineno"> 3465</span> </div>
<div class="line"><span class="lineno"> 3466</span>    <span class="comment"># Condition needed to ensure output remains compatible</span></div>
<div class="line"><span class="lineno"> 3467</span>    is_ss_input = isinstance(system, StateSpace)</div>
<div class="line"><span class="lineno"> 3468</span>    system = system._as_ss()</div>
<div class="line"><span class="lineno"> 3469</span> </div>
<div class="line"><span class="lineno"> 3470</span>    u = np.atleast_1d(u)</div>
<div class="line"><span class="lineno"> 3471</span> </div>
<div class="line"><span class="lineno"> 3472</span>    <span class="keywordflow">if</span> u.ndim == 1:</div>
<div class="line"><span class="lineno"> 3473</span>        u = np.atleast_2d(u).T</div>
<div class="line"><span class="lineno"> 3474</span> </div>
<div class="line"><span class="lineno"> 3475</span>    <span class="keywordflow">if</span> t <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3476</span>        out_samples = len(u)</div>
<div class="line"><span class="lineno"> 3477</span>        stoptime = (out_samples - 1) * system.dt</div>
<div class="line"><span class="lineno"> 3478</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3479</span>        stoptime = t[-1]</div>
<div class="line"><span class="lineno"> 3480</span>        out_samples = int(np.floor(stoptime / system.dt)) + 1</div>
<div class="line"><span class="lineno"> 3481</span> </div>
<div class="line"><span class="lineno"> 3482</span>    <span class="comment"># Pre-build output arrays</span></div>
<div class="line"><span class="lineno"> 3483</span>    xout = np.zeros((out_samples, system.A.shape[0]))</div>
<div class="line"><span class="lineno"> 3484</span>    yout = np.zeros((out_samples, system.C.shape[0]))</div>
<div class="line"><span class="lineno"> 3485</span>    tout = np.linspace(0.0, stoptime, num=out_samples)</div>
<div class="line"><span class="lineno"> 3486</span> </div>
<div class="line"><span class="lineno"> 3487</span>    <span class="comment"># Check initial condition</span></div>
<div class="line"><span class="lineno"> 3488</span>    <span class="keywordflow">if</span> x0 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3489</span>        xout[0, :] = np.zeros((system.A.shape[1],))</div>
<div class="line"><span class="lineno"> 3490</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3491</span>        xout[0, :] = np.asarray(x0)</div>
<div class="line"><span class="lineno"> 3492</span> </div>
<div class="line"><span class="lineno"> 3493</span>    <span class="comment"># Pre-interpolate inputs into the desired time steps</span></div>
<div class="line"><span class="lineno"> 3494</span>    <span class="keywordflow">if</span> t <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3495</span>        u_dt = u</div>
<div class="line"><span class="lineno"> 3496</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3497</span>        <span class="keywordflow">if</span> len(u.shape) == 1:</div>
<div class="line"><span class="lineno"> 3498</span>            u = u[:, np.newaxis]</div>
<div class="line"><span class="lineno"> 3499</span> </div>
<div class="line"><span class="lineno"> 3500</span>        u_dt_interp = interp1d(t, u.transpose(), copy=<span class="keyword">False</span>, bounds_error=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3501</span>        u_dt = u_dt_interp(tout).transpose()</div>
<div class="line"><span class="lineno"> 3502</span> </div>
<div class="line"><span class="lineno"> 3503</span>    <span class="comment"># Simulate the system</span></div>
<div class="line"><span class="lineno"> 3504</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, out_samples - 1):</div>
<div class="line"><span class="lineno"> 3505</span>        xout[i+1, :] = (np.dot(system.A, xout[i, :]) +</div>
<div class="line"><span class="lineno"> 3506</span>                        np.dot(system.B, u_dt[i, :]))</div>
<div class="line"><span class="lineno"> 3507</span>        yout[i, :] = (np.dot(system.C, xout[i, :]) +</div>
<div class="line"><span class="lineno"> 3508</span>                      np.dot(system.D, u_dt[i, :]))</div>
<div class="line"><span class="lineno"> 3509</span> </div>
<div class="line"><span class="lineno"> 3510</span>    <span class="comment"># Last point</span></div>
<div class="line"><span class="lineno"> 3511</span>    yout[out_samples-1, :] = (np.dot(system.C, xout[out_samples-1, :]) +</div>
<div class="line"><span class="lineno"> 3512</span>                              np.dot(system.D, u_dt[out_samples-1, :]))</div>
<div class="line"><span class="lineno"> 3513</span> </div>
<div class="line"><span class="lineno"> 3514</span>    <span class="keywordflow">if</span> is_ss_input:</div>
<div class="line"><span class="lineno"> 3515</span>        <span class="keywordflow">return</span> tout, yout, xout</div>
<div class="line"><span class="lineno"> 3516</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3517</span>        <span class="keywordflow">return</span> tout, yout</div>
<div class="line"><span class="lineno"> 3518</span> </div>
<div class="line"><span class="lineno"> 3519</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1106cc5e8301c0883b141e59dbf53cf8" name="a1106cc5e8301c0883b141e59dbf53cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1106cc5e8301c0883b141e59dbf53cf8">&#9670;&#160;</a></span>dstep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dstep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Step response of discrete-time system.

Parameters
----------
system : tuple of array_like
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1: (instance of `dlti`)
        * 3: (num, den, dt)
        * 4: (zeros, poles, gain, dt)
        * 5: (A, B, C, D, dt)

x0 : array_like, optional
    Initial state-vector.  Defaults to zero.
t : array_like, optional
    Time points.  Computed if not given.
n : int, optional
    The number of time points to compute (if `t` is not given).

Returns
-------
tout : ndarray
    Output time points, as a 1-D array.
yout : tuple of ndarray
    Step response of system.  Each element of the tuple represents
    the output of the system based on a step response to each input.

See Also
--------
step, dimpulse, dlsim, cont2discrete

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5))
&gt;&gt;&gt; t, y = signal.dstep(butter, n=25)
&gt;&gt;&gt; plt.step(t, np.squeeze(y))
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.xlabel('n [samples]')
&gt;&gt;&gt; plt.ylabel('Amplitude')
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3606</span><span class="keyword">def </span>dstep(system, x0=None, t=None, n=None):</div>
<div class="line"><span class="lineno"> 3607</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3608</span><span class="stringliteral">    Step response of discrete-time system.</span></div>
<div class="line"><span class="lineno"> 3609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3610</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3611</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3612</span><span class="stringliteral">    system : tuple of array_like</span></div>
<div class="line"><span class="lineno"> 3613</span><span class="stringliteral">        A tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 3614</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 3615</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 3616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3617</span><span class="stringliteral">            * 1: (instance of `dlti`)</span></div>
<div class="line"><span class="lineno"> 3618</span><span class="stringliteral">            * 3: (num, den, dt)</span></div>
<div class="line"><span class="lineno"> 3619</span><span class="stringliteral">            * 4: (zeros, poles, gain, dt)</span></div>
<div class="line"><span class="lineno"> 3620</span><span class="stringliteral">            * 5: (A, B, C, D, dt)</span></div>
<div class="line"><span class="lineno"> 3621</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3622</span><span class="stringliteral">    x0 : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3623</span><span class="stringliteral">        Initial state-vector.  Defaults to zero.</span></div>
<div class="line"><span class="lineno"> 3624</span><span class="stringliteral">    t : array_like, optional</span></div>
<div class="line"><span class="lineno"> 3625</span><span class="stringliteral">        Time points.  Computed if not given.</span></div>
<div class="line"><span class="lineno"> 3626</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 3627</span><span class="stringliteral">        The number of time points to compute (if `t` is not given).</span></div>
<div class="line"><span class="lineno"> 3628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3629</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3630</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3631</span><span class="stringliteral">    tout : ndarray</span></div>
<div class="line"><span class="lineno"> 3632</span><span class="stringliteral">        Output time points, as a 1-D array.</span></div>
<div class="line"><span class="lineno"> 3633</span><span class="stringliteral">    yout : tuple of ndarray</span></div>
<div class="line"><span class="lineno"> 3634</span><span class="stringliteral">        Step response of system.  Each element of the tuple represents</span></div>
<div class="line"><span class="lineno"> 3635</span><span class="stringliteral">        the output of the system based on a step response to each input.</span></div>
<div class="line"><span class="lineno"> 3636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3637</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3638</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3639</span><span class="stringliteral">    step, dimpulse, dlsim, cont2discrete</span></div>
<div class="line"><span class="lineno"> 3640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3641</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3642</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3643</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3644</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3645</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3646</span><span class="stringliteral">    &gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5))</span></div>
<div class="line"><span class="lineno"> 3647</span><span class="stringliteral">    &gt;&gt;&gt; t, y = signal.dstep(butter, n=25)</span></div>
<div class="line"><span class="lineno"> 3648</span><span class="stringliteral">    &gt;&gt;&gt; plt.step(t, np.squeeze(y))</span></div>
<div class="line"><span class="lineno"> 3649</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid()</span></div>
<div class="line"><span class="lineno"> 3650</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;n [samples]&#39;)</span></div>
<div class="line"><span class="lineno"> 3651</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 3652</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3653</span>    <span class="comment"># Convert system to dlti-StateSpace</span></div>
<div class="line"><span class="lineno"> 3654</span>    <span class="keywordflow">if</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 3655</span>        system = system._as_ss()</div>
<div class="line"><span class="lineno"> 3656</span>    <span class="keywordflow">elif</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 3657</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;dstep can only be used with discrete-time dlti &#39;</span></div>
<div class="line"><span class="lineno"> 3658</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3659</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3660</span>        system = dlti(*system[:-1], dt=system[-1])._as_ss()</div>
<div class="line"><span class="lineno"> 3661</span> </div>
<div class="line"><span class="lineno"> 3662</span>    <span class="comment"># Default to 100 samples if unspecified</span></div>
<div class="line"><span class="lineno"> 3663</span>    <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3664</span>        n = 100</div>
<div class="line"><span class="lineno"> 3665</span> </div>
<div class="line"><span class="lineno"> 3666</span>    <span class="comment"># If time is not specified, use the number of samples</span></div>
<div class="line"><span class="lineno"> 3667</span>    <span class="comment"># and system dt</span></div>
<div class="line"><span class="lineno"> 3668</span>    <span class="keywordflow">if</span> t <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3669</span>        t = np.linspace(0, n * system.dt, n, endpoint=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3670</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3671</span>        t = np.asarray(t)</div>
<div class="line"><span class="lineno"> 3672</span> </div>
<div class="line"><span class="lineno"> 3673</span>    <span class="comment"># For each input, implement a step change</span></div>
<div class="line"><span class="lineno"> 3674</span>    yout = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3675</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, system.inputs):</div>
<div class="line"><span class="lineno"> 3676</span>        u = np.zeros((t.shape[0], system.inputs))</div>
<div class="line"><span class="lineno"> 3677</span>        u[:, i] = np.ones((t.shape[0],))</div>
<div class="line"><span class="lineno"> 3678</span> </div>
<div class="line"><span class="lineno"> 3679</span>        one_output = dlsim(system, u, t=t, x0=x0)</div>
<div class="line"><span class="lineno"> 3680</span> </div>
<div class="line"><span class="lineno"> 3681</span>        <span class="keywordflow">if</span> yout <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3682</span>            yout = (one_output[1],)</div>
<div class="line"><span class="lineno"> 3683</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3684</span>            yout = yout + (one_output[1],)</div>
<div class="line"><span class="lineno"> 3685</span> </div>
<div class="line"><span class="lineno"> 3686</span>        tout = one_output[0]</div>
<div class="line"><span class="lineno"> 3687</span> </div>
<div class="line"><span class="lineno"> 3688</span>    <span class="keywordflow">return</span> tout, yout</div>
<div class="line"><span class="lineno"> 3689</span> </div>
<div class="line"><span class="lineno"> 3690</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5224b7e7920b072f5a40d9776f9687f5" name="a5224b7e7920b072f5a40d9776f9687f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5224b7e7920b072f5a40d9776f9687f5">&#9670;&#160;</a></span>freqresp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.freqresp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the frequency response of a continuous-time system.

Parameters
----------
system : an instance of the `lti` class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

w : array_like, optional
    Array of frequencies (in rad/s). Magnitude and phase data is
    calculated for every value in this array. If not given, a reasonable
    set will be calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
    Frequency array [rad/s]
H : 1D ndarray
    Array of complex magnitude values

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
Generating the Nyquist plot of a transfer function

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct the transfer function :math:`H(s) = \frac{5}{(s-1)^3}`:

&gt;&gt;&gt; s1 = signal.ZerosPolesGain([], [1, 1, 1], [5])

&gt;&gt;&gt; w, H = signal.freqresp(s1)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(H.real, H.imag, "b")
&gt;&gt;&gt; plt.plot(H.real, -H.imag, "r")
&gt;&gt;&gt; plt.show()
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2578</span><span class="keyword">def </span>freqresp(system, w=None, n=10000):</div>
<div class="line"><span class="lineno"> 2579</span>    <span class="stringliteral">r&quot;&quot;&quot;Calculate the frequency response of a continuous-time system.</span></div>
<div class="line"><span class="lineno"> 2580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2581</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2582</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2583</span><span class="stringliteral">    system : an instance of the `lti` class or a tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 2584</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral">            * 1 (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral">            * 2 (num, den)</span></div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral">            * 3 (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">            * 4 (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral">    w : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2593</span><span class="stringliteral">        Array of frequencies (in rad/s). Magnitude and phase data is</span></div>
<div class="line"><span class="lineno"> 2594</span><span class="stringliteral">        calculated for every value in this array. If not given, a reasonable</span></div>
<div class="line"><span class="lineno"> 2595</span><span class="stringliteral">        set will be calculated.</span></div>
<div class="line"><span class="lineno"> 2596</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 2597</span><span class="stringliteral">        Number of frequency points to compute if `w` is not given. The `n`</span></div>
<div class="line"><span class="lineno"> 2598</span><span class="stringliteral">        frequencies are logarithmically spaced in an interval chosen to</span></div>
<div class="line"><span class="lineno"> 2599</span><span class="stringliteral">        include the influence of the poles and zeros of the system.</span></div>
<div class="line"><span class="lineno"> 2600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2601</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2602</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2603</span><span class="stringliteral">    w : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2604</span><span class="stringliteral">        Frequency array [rad/s]</span></div>
<div class="line"><span class="lineno"> 2605</span><span class="stringliteral">    H : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2606</span><span class="stringliteral">        Array of complex magnitude values</span></div>
<div class="line"><span class="lineno"> 2607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2608</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2609</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2610</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 2611</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 2612</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 2613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2614</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2615</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2616</span><span class="stringliteral">    Generating the Nyquist plot of a transfer function</span></div>
<div class="line"><span class="lineno"> 2617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2618</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2619</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2621</span><span class="stringliteral">    Construct the transfer function :math:`H(s) = \frac{5}{(s-1)^3}`:</span></div>
<div class="line"><span class="lineno"> 2622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2623</span><span class="stringliteral">    &gt;&gt;&gt; s1 = signal.ZerosPolesGain([], [1, 1, 1], [5])</span></div>
<div class="line"><span class="lineno"> 2624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2625</span><span class="stringliteral">    &gt;&gt;&gt; w, H = signal.freqresp(s1)</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(H.real, H.imag, &quot;b&quot;)</span></div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(H.real, -H.imag, &quot;r&quot;)</span></div>
<div class="line"><span class="lineno"> 2630</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2631</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2632</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 2633</span>        <span class="keywordflow">if</span> isinstance(system, (TransferFunction, ZerosPolesGain)):</div>
<div class="line"><span class="lineno"> 2634</span>            sys = system</div>
<div class="line"><span class="lineno"> 2635</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2636</span>            sys = system._as_zpk()</div>
<div class="line"><span class="lineno"> 2637</span>    <span class="keywordflow">elif</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 2638</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;freqresp can only be used with continuous-time &#39;</span></div>
<div class="line"><span class="lineno"> 2639</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2640</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2641</span>        sys = lti(*system)._as_zpk()</div>
<div class="line"><span class="lineno"> 2642</span> </div>
<div class="line"><span class="lineno"> 2643</span>    <span class="keywordflow">if</span> sys.inputs != 1 <span class="keywordflow">or</span> sys.outputs != 1:</div>
<div class="line"><span class="lineno"> 2644</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;freqresp() requires a SISO (single input, single &quot;</span></div>
<div class="line"><span class="lineno"> 2645</span>                         <span class="stringliteral">&quot;output) system.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2646</span> </div>
<div class="line"><span class="lineno"> 2647</span>    <span class="keywordflow">if</span> w <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2648</span>        worN = w</div>
<div class="line"><span class="lineno"> 2649</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2650</span>        worN = n</div>
<div class="line"><span class="lineno"> 2651</span> </div>
<div class="line"><span class="lineno"> 2652</span>    <span class="keywordflow">if</span> isinstance(sys, TransferFunction):</div>
<div class="line"><span class="lineno"> 2653</span>        <span class="comment"># In the call to freqs(), sys.num.ravel() is used because there are</span></div>
<div class="line"><span class="lineno"> 2654</span>        <span class="comment"># cases where sys.num is a 2-D array with a single row.</span></div>
<div class="line"><span class="lineno"> 2655</span>        w, h = freqs(sys.num.ravel(), sys.den, worN=worN)</div>
<div class="line"><span class="lineno"> 2656</span> </div>
<div class="line"><span class="lineno"> 2657</span>    <span class="keywordflow">elif</span> isinstance(sys, ZerosPolesGain):</div>
<div class="line"><span class="lineno"> 2658</span>        w, h = freqs_zpk(sys.zeros, sys.poles, sys.gain, worN=worN)</div>
<div class="line"><span class="lineno"> 2659</span> </div>
<div class="line"><span class="lineno"> 2660</span>    <span class="keywordflow">return</span> w, h</div>
<div class="line"><span class="lineno"> 2661</span> </div>
<div class="line"><span class="lineno"> 2662</span> </div>
<div class="line"><span class="lineno"> 2663</span><span class="comment"># This class will be used by place_poles to return its results</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="comment"># see https://code.activestate.com/recipes/52308/</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a09e8d379f94d78becbd5dd16b97734ec" name="a09e8d379f94d78becbd5dd16b97734ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e8d379f94d78becbd5dd16b97734ec">&#9670;&#160;</a></span>impulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.impulse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Impulse response of continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector.  Defaults to zero.
T : array_like, optional
    Time points.  Computed if not given.
N : int, optional
    The number of time points to compute (if `T` is not given).

Returns
-------
T : ndarray
    A 1-D array of time points.
yout : ndarray
    A 1-D array containing the impulse response of the system (except for
    singularities at zero).

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
Compute the impulse response of a second order system with a repeated
root: ``x''(t) + 2*x'(t) + x(t) = u(t)``

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0])
&gt;&gt;&gt; t, y = signal.impulse(system)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, y)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2203</span><span class="keyword">def </span>impulse(system, X0=None, T=None, N=None):</div>
<div class="line"><span class="lineno"> 2204</span>    <span class="stringliteral">&quot;&quot;&quot;Impulse response of continuous-time system.</span></div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2206</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2207</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2208</span><span class="stringliteral">    system : an instance of the LTI class or a tuple of array_like</span></div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral">        describing the system.</span></div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral">            * 1 (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">            * 2 (num, den)</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral">            * 3 (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">            * 4 (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">    X0 : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">        Initial state-vector.  Defaults to zero.</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral">    T : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral">        Time points.  Computed if not given.</span></div>
<div class="line"><span class="lineno"> 2222</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral">        The number of time points to compute (if `T` is not given).</span></div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">    T : ndarray</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">        A 1-D array of time points.</span></div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">    yout : ndarray</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">        A 1-D array containing the impulse response of the system (except for</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral">        singularities at zero).</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">    Compute the impulse response of a second order system with a repeated</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">    root: ``x&#39;&#39;(t) + 2*x&#39;(t) + x(t) = u(t)``</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral">    &gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0])</span></div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">    &gt;&gt;&gt; t, y = signal.impulse(system)</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y)</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2251</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 2252</span>        sys = system._as_ss()</div>
<div class="line"><span class="lineno"> 2253</span>    <span class="keywordflow">elif</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 2254</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;impulse can only be used with continuous-time &#39;</span></div>
<div class="line"><span class="lineno"> 2255</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2256</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2257</span>        sys = lti(*system)._as_ss()</div>
<div class="line"><span class="lineno"> 2258</span>    <span class="keywordflow">if</span> X0 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2259</span>        X = squeeze(sys.B)</div>
<div class="line"><span class="lineno"> 2260</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2261</span>        X = squeeze(sys.B + X0)</div>
<div class="line"><span class="lineno"> 2262</span>    <span class="keywordflow">if</span> N <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2263</span>        N = 100</div>
<div class="line"><span class="lineno"> 2264</span>    <span class="keywordflow">if</span> T <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2265</span>        T = _default_response_times(sys.A, N)</div>
<div class="line"><span class="lineno"> 2266</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2267</span>        T = asarray(T)</div>
<div class="line"><span class="lineno"> 2268</span> </div>
<div class="line"><span class="lineno"> 2269</span>    _, h, _ = lsim(sys, 0., T, X, interp=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2270</span>    <span class="keywordflow">return</span> T, h</div>
<div class="line"><span class="lineno"> 2271</span> </div>
<div class="line"><span class="lineno"> 2272</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae26f9ff8dfac66c8fb42c282fb27d9da" name="ae26f9ff8dfac66c8fb42c282fb27d9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26f9ff8dfac66c8fb42c282fb27d9da">&#9670;&#160;</a></span>impulse2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.impulse2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Impulse response of a single-input, continuous-time linear system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : 1-D array_like, optional
    The initial condition of the state vector.  Default: 0 (the
    zero vector).
T : 1-D array_like, optional
    The time steps at which the input is defined and at which the
    output is desired.  If `T` is not given, the function will
    generate a set of time samples automatically.
N : int, optional
    Number of time points to compute.  Default: 100.
kwargs : various types
    Additional keyword arguments are passed on to the function
    `scipy.signal.lsim2`, which in turn passes them on to
    `scipy.integrate.odeint`; see the latter's documentation for
    information about these arguments.

Returns
-------
T : ndarray
    The time values for the output.
yout : ndarray
    The output response of the system.

See Also
--------
impulse, lsim2, scipy.integrate.odeint

Notes
-----
The solution is generated by calling `scipy.signal.lsim2`, which uses
the differential equation solver `scipy.integrate.odeint`.

If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.8.0

Examples
--------
Compute the impulse response of a second order system with a repeated
root: ``x''(t) + 2*x'(t) + x(t) = u(t)``

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0])
&gt;&gt;&gt; t, y = signal.impulse2(system)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, y)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2273</span><span class="keyword">def </span>impulse2(system, X0=None, T=None, N=None, **kwargs):</div>
<div class="line"><span class="lineno"> 2274</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral">    Impulse response of a single-input, continuous-time linear system.</span></div>
<div class="line"><span class="lineno"> 2276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2277</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2278</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2279</span><span class="stringliteral">    system : an instance of the LTI class or a tuple of array_like</span></div>
<div class="line"><span class="lineno"> 2280</span><span class="stringliteral">        describing the system.</span></div>
<div class="line"><span class="lineno"> 2281</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 2282</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 2283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2284</span><span class="stringliteral">            * 1 (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 2285</span><span class="stringliteral">            * 2 (num, den)</span></div>
<div class="line"><span class="lineno"> 2286</span><span class="stringliteral">            * 3 (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 2287</span><span class="stringliteral">            * 4 (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 2288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2289</span><span class="stringliteral">    X0 : 1-D array_like, optional</span></div>
<div class="line"><span class="lineno"> 2290</span><span class="stringliteral">        The initial condition of the state vector.  Default: 0 (the</span></div>
<div class="line"><span class="lineno"> 2291</span><span class="stringliteral">        zero vector).</span></div>
<div class="line"><span class="lineno"> 2292</span><span class="stringliteral">    T : 1-D array_like, optional</span></div>
<div class="line"><span class="lineno"> 2293</span><span class="stringliteral">        The time steps at which the input is defined and at which the</span></div>
<div class="line"><span class="lineno"> 2294</span><span class="stringliteral">        output is desired.  If `T` is not given, the function will</span></div>
<div class="line"><span class="lineno"> 2295</span><span class="stringliteral">        generate a set of time samples automatically.</span></div>
<div class="line"><span class="lineno"> 2296</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 2297</span><span class="stringliteral">        Number of time points to compute.  Default: 100.</span></div>
<div class="line"><span class="lineno"> 2298</span><span class="stringliteral">    kwargs : various types</span></div>
<div class="line"><span class="lineno"> 2299</span><span class="stringliteral">        Additional keyword arguments are passed on to the function</span></div>
<div class="line"><span class="lineno"> 2300</span><span class="stringliteral">        `scipy.signal.lsim2`, which in turn passes them on to</span></div>
<div class="line"><span class="lineno"> 2301</span><span class="stringliteral">        `scipy.integrate.odeint`; see the latter&#39;s documentation for</span></div>
<div class="line"><span class="lineno"> 2302</span><span class="stringliteral">        information about these arguments.</span></div>
<div class="line"><span class="lineno"> 2303</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2304</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2305</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2306</span><span class="stringliteral">    T : ndarray</span></div>
<div class="line"><span class="lineno"> 2307</span><span class="stringliteral">        The time values for the output.</span></div>
<div class="line"><span class="lineno"> 2308</span><span class="stringliteral">    yout : ndarray</span></div>
<div class="line"><span class="lineno"> 2309</span><span class="stringliteral">        The output response of the system.</span></div>
<div class="line"><span class="lineno"> 2310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2311</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2312</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2313</span><span class="stringliteral">    impulse, lsim2, scipy.integrate.odeint</span></div>
<div class="line"><span class="lineno"> 2314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2315</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2316</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2317</span><span class="stringliteral">    The solution is generated by calling `scipy.signal.lsim2`, which uses</span></div>
<div class="line"><span class="lineno"> 2318</span><span class="stringliteral">    the differential equation solver `scipy.integrate.odeint`.</span></div>
<div class="line"><span class="lineno"> 2319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2320</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 2321</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 2322</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 2323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2324</span><span class="stringliteral">    .. versionadded:: 0.8.0</span></div>
<div class="line"><span class="lineno"> 2325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2326</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2328</span><span class="stringliteral">    Compute the impulse response of a second order system with a repeated</span></div>
<div class="line"><span class="lineno"> 2329</span><span class="stringliteral">    root: ``x&#39;&#39;(t) + 2*x&#39;(t) + x(t) = u(t)``</span></div>
<div class="line"><span class="lineno"> 2330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2331</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2332</span><span class="stringliteral">    &gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0])</span></div>
<div class="line"><span class="lineno"> 2333</span><span class="stringliteral">    &gt;&gt;&gt; t, y = signal.impulse2(system)</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y)</span></div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2338</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 2339</span>        sys = system._as_ss()</div>
<div class="line"><span class="lineno"> 2340</span>    <span class="keywordflow">elif</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 2341</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;impulse2 can only be used with continuous-time &#39;</span></div>
<div class="line"><span class="lineno"> 2342</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2343</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2344</span>        sys = lti(*system)._as_ss()</div>
<div class="line"><span class="lineno"> 2345</span>    B = sys.B</div>
<div class="line"><span class="lineno"> 2346</span>    <span class="keywordflow">if</span> B.shape[-1] != 1:</div>
<div class="line"><span class="lineno"> 2347</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;impulse2() requires a single-input system.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2348</span>    B = B.squeeze()</div>
<div class="line"><span class="lineno"> 2349</span>    <span class="keywordflow">if</span> X0 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2350</span>        X0 = zeros_like(B)</div>
<div class="line"><span class="lineno"> 2351</span>    <span class="keywordflow">if</span> N <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2352</span>        N = 100</div>
<div class="line"><span class="lineno"> 2353</span>    <span class="keywordflow">if</span> T <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2354</span>        T = _default_response_times(sys.A, N)</div>
<div class="line"><span class="lineno"> 2355</span> </div>
<div class="line"><span class="lineno"> 2356</span>    <span class="comment"># Move the impulse in the input to the initial conditions, and then</span></div>
<div class="line"><span class="lineno"> 2357</span>    <span class="comment"># solve using lsim2().</span></div>
<div class="line"><span class="lineno"> 2358</span>    ic = B + X0</div>
<div class="line"><span class="lineno"> 2359</span>    Tr, Yr, Xr = lsim2(sys, T=T, X0=ic, **kwargs)</div>
<div class="line"><span class="lineno"> 2360</span>    <span class="keywordflow">return</span> Tr, Yr</div>
<div class="line"><span class="lineno"> 2361</span> </div>
<div class="line"><span class="lineno"> 2362</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad81706d4397767b146b651c5cebc2fd2" name="ad81706d4397767b146b651c5cebc2fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81706d4397767b146b651c5cebc2fd2">&#9670;&#160;</a></span>lsim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.lsim </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simulate output of a continuous-time linear system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

    * 1: (instance of `lti`)
    * 2: (num, den)
    * 3: (zeros, poles, gain)
    * 4: (A, B, C, D)

U : array_like
    An input array describing the input at each time `T`
    (interpolation is assumed between given times).  If there are
    multiple inputs, then each column of the rank-2 array
    represents an input.  If U = 0 or None, a zero input is used.
T : array_like
    The time steps at which the input is defined and at which the
    output is desired.  Must be nonnegative, increasing, and equally spaced.
X0 : array_like, optional
    The initial conditions on the state vector (zero by default).
interp : bool, optional
    Whether to use linear (True, the default) or zero-order-hold (False)
    interpolation for the input array.

Returns
-------
T : 1D ndarray
    Time values for the output.
yout : 1D ndarray
    System response.
xout : ndarray
    Time evolution of the state vector.

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
We'll use `lsim` to simulate an analog Bessel filter applied to
a signal.

&gt;&gt;&gt; from scipy.signal import bessel, lsim
&gt;&gt;&gt; import matplotlib.pyplot as plt

Create a low-pass Bessel filter with a cutoff of 12 Hz.

&gt;&gt;&gt; b, a = bessel(N=5, Wn=2*np.pi*12, btype='lowpass', analog=True)

Generate data to which the filter is applied.

&gt;&gt;&gt; t = np.linspace(0, 1.25, 500, endpoint=False)

The input signal is the sum of three sinusoidal curves, with
frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly
eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal.

&gt;&gt;&gt; u = (np.cos(2*np.pi*4*t) + 0.6*np.sin(2*np.pi*40*t) +
...      0.5*np.cos(2*np.pi*80*t))

Simulate the filter with `lsim`.

&gt;&gt;&gt; tout, yout, xout = lsim((b, a), U=u, T=t)

Plot the result.

&gt;&gt;&gt; plt.plot(t, u, 'r', alpha=0.5, linewidth=1, label='input')
&gt;&gt;&gt; plt.plot(tout, yout, 'k', linewidth=1.5, label='output')
&gt;&gt;&gt; plt.legend(loc='best', shadow=True, framealpha=1)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()

In a second example, we simulate a double integrator ``y'' = u``, with
a constant input ``u = 1``.  We'll use the state space representation
of the integrator.

&gt;&gt;&gt; from scipy.signal import lti
&gt;&gt;&gt; A = np.array([[0.0, 1.0], [0.0, 0.0]])
&gt;&gt;&gt; B = np.array([[0.0], [1.0]])
&gt;&gt;&gt; C = np.array([[1.0, 0.0]])
&gt;&gt;&gt; D = 0.0
&gt;&gt;&gt; system = lti(A, B, C, D)

`t` and `u` define the time and input signal for the system to
be simulated.

&gt;&gt;&gt; t = np.linspace(0, 5, num=50)
&gt;&gt;&gt; u = np.ones_like(t)

Compute the simulation, and then plot `y`.  As expected, the plot shows
the curve ``y = 0.5*t**2``.

&gt;&gt;&gt; tout, y, x = lsim(system, u, t)
&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1955</span><span class="keyword">def </span>lsim(system, U, T, X0=None, interp=True):</div>
<div class="line"><span class="lineno"> 1956</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral">    Simulate output of a continuous-time linear system.</span></div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">    system : an instance of the LTI class or a tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">        * 1: (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">        * 2: (num, den)</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">        * 3: (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">        * 4: (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    U : array_like</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">        An input array describing the input at each time `T`</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">        (interpolation is assumed between given times).  If there are</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">        multiple inputs, then each column of the rank-2 array</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">        represents an input.  If U = 0 or None, a zero input is used.</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">    T : array_like</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">        The time steps at which the input is defined and at which the</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">        output is desired.  Must be nonnegative, increasing, and equally spaced.</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">    X0 : array_like, optional</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral">        The initial conditions on the state vector (zero by default).</span></div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">    interp : bool, optional</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">        Whether to use linear (True, the default) or zero-order-hold (False)</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral">        interpolation for the input array.</span></div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">    T : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral">        Time values for the output.</span></div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    yout : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral">        System response.</span></div>
<div class="line"><span class="lineno"> 1990</span><span class="stringliteral">    xout : ndarray</span></div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral">        Time evolution of the state vector.</span></div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1993</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">    We&#39;ll use `lsim` to simulate an analog Bessel filter applied to</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral">    a signal.</span></div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2004</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import bessel, lsim</span></div>
<div class="line"><span class="lineno"> 2005</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2007</span><span class="stringliteral">    Create a low-pass Bessel filter with a cutoff of 12 Hz.</span></div>
<div class="line"><span class="lineno"> 2008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">    &gt;&gt;&gt; b, a = bessel(N=5, Wn=2*np.pi*12, btype=&#39;lowpass&#39;, analog=True)</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral">    Generate data to which the filter is applied.</span></div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 1.25, 500, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">    The input signal is the sum of three sinusoidal curves, with</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral">    frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly</span></div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral">    eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal.</span></div>
<div class="line"><span class="lineno"> 2018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2019</span><span class="stringliteral">    &gt;&gt;&gt; u = (np.cos(2*np.pi*4*t) + 0.6*np.sin(2*np.pi*40*t) +</span></div>
<div class="line"><span class="lineno"> 2020</span><span class="stringliteral">    ...      0.5*np.cos(2*np.pi*80*t))</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">    Simulate the filter with `lsim`.</span></div>
<div class="line"><span class="lineno"> 2023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2024</span><span class="stringliteral">    &gt;&gt;&gt; tout, yout, xout = lsim((b, a), U=u, T=t)</span></div>
<div class="line"><span class="lineno"> 2025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2026</span><span class="stringliteral">    Plot the result.</span></div>
<div class="line"><span class="lineno"> 2027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2028</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, u, &#39;r&#39;, alpha=0.5, linewidth=1, label=&#39;input&#39;)</span></div>
<div class="line"><span class="lineno"> 2029</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(tout, yout, &#39;k&#39;, linewidth=1.5, label=&#39;output&#39;)</span></div>
<div class="line"><span class="lineno"> 2030</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;, shadow=True, framealpha=1)</span></div>
<div class="line"><span class="lineno"> 2031</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(alpha=0.3)</span></div>
<div class="line"><span class="lineno"> 2032</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span></div>
<div class="line"><span class="lineno"> 2033</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2034</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2035</span><span class="stringliteral">    In a second example, we simulate a double integrator ``y&#39;&#39; = u``, with</span></div>
<div class="line"><span class="lineno"> 2036</span><span class="stringliteral">    a constant input ``u = 1``.  We&#39;ll use the state space representation</span></div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral">    of the integrator.</span></div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import lti</span></div>
<div class="line"><span class="lineno"> 2040</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[0.0, 1.0], [0.0, 0.0]])</span></div>
<div class="line"><span class="lineno"> 2041</span><span class="stringliteral">    &gt;&gt;&gt; B = np.array([[0.0], [1.0]])</span></div>
<div class="line"><span class="lineno"> 2042</span><span class="stringliteral">    &gt;&gt;&gt; C = np.array([[1.0, 0.0]])</span></div>
<div class="line"><span class="lineno"> 2043</span><span class="stringliteral">    &gt;&gt;&gt; D = 0.0</span></div>
<div class="line"><span class="lineno"> 2044</span><span class="stringliteral">    &gt;&gt;&gt; system = lti(A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 2045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2046</span><span class="stringliteral">    `t` and `u` define the time and input signal for the system to</span></div>
<div class="line"><span class="lineno"> 2047</span><span class="stringliteral">    be simulated.</span></div>
<div class="line"><span class="lineno"> 2048</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2049</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 5, num=50)</span></div>
<div class="line"><span class="lineno"> 2050</span><span class="stringliteral">    &gt;&gt;&gt; u = np.ones_like(t)</span></div>
<div class="line"><span class="lineno"> 2051</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2052</span><span class="stringliteral">    Compute the simulation, and then plot `y`.  As expected, the plot shows</span></div>
<div class="line"><span class="lineno"> 2053</span><span class="stringliteral">    the curve ``y = 0.5*t**2``.</span></div>
<div class="line"><span class="lineno"> 2054</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2055</span><span class="stringliteral">    &gt;&gt;&gt; tout, y, x = lsim(system, u, t)</span></div>
<div class="line"><span class="lineno"> 2056</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y)</span></div>
<div class="line"><span class="lineno"> 2057</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(alpha=0.3)</span></div>
<div class="line"><span class="lineno"> 2058</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span></div>
<div class="line"><span class="lineno"> 2059</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2061</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2062</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 2063</span>        sys = system._as_ss()</div>
<div class="line"><span class="lineno"> 2064</span>    <span class="keywordflow">elif</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 2065</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;lsim can only be used with continuous-time &#39;</span></div>
<div class="line"><span class="lineno"> 2066</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2067</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2068</span>        sys = lti(*system)._as_ss()</div>
<div class="line"><span class="lineno"> 2069</span>    T = atleast_1d(T)</div>
<div class="line"><span class="lineno"> 2070</span>    <span class="keywordflow">if</span> len(T.shape) != 1:</div>
<div class="line"><span class="lineno"> 2071</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;T must be a rank-1 array.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2072</span> </div>
<div class="line"><span class="lineno"> 2073</span>    A, B, C, D = map(np.asarray, (sys.A, sys.B, sys.C, sys.D))</div>
<div class="line"><span class="lineno"> 2074</span>    n_states = A.shape[0]</div>
<div class="line"><span class="lineno"> 2075</span>    n_inputs = B.shape[1]</div>
<div class="line"><span class="lineno"> 2076</span> </div>
<div class="line"><span class="lineno"> 2077</span>    n_steps = T.size</div>
<div class="line"><span class="lineno"> 2078</span>    <span class="keywordflow">if</span> X0 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2079</span>        X0 = zeros(n_states, sys.A.dtype)</div>
<div class="line"><span class="lineno"> 2080</span>    xout = np.empty((n_steps, n_states), sys.A.dtype)</div>
<div class="line"><span class="lineno"> 2081</span> </div>
<div class="line"><span class="lineno"> 2082</span>    <span class="keywordflow">if</span> T[0] == 0:</div>
<div class="line"><span class="lineno"> 2083</span>        xout[0] = X0</div>
<div class="line"><span class="lineno"> 2084</span>    <span class="keywordflow">elif</span> T[0] &gt; 0:</div>
<div class="line"><span class="lineno"> 2085</span>        <span class="comment"># step forward to initial time, with zero input</span></div>
<div class="line"><span class="lineno"> 2086</span>        xout[0] = dot(X0, linalg.expm(transpose(A) * T[0]))</div>
<div class="line"><span class="lineno"> 2087</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2088</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Initial time must be nonnegative&quot;</span>)</div>
<div class="line"><span class="lineno"> 2089</span> </div>
<div class="line"><span class="lineno"> 2090</span>    no_input = (U <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 2091</span>                (isinstance(U, (int, float)) <span class="keywordflow">and</span> U == 0.) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 2092</span>                <span class="keywordflow">not</span> np.any(U))</div>
<div class="line"><span class="lineno"> 2093</span> </div>
<div class="line"><span class="lineno"> 2094</span>    <span class="keywordflow">if</span> n_steps == 1:</div>
<div class="line"><span class="lineno"> 2095</span>        yout = squeeze(dot(xout, transpose(C)))</div>
<div class="line"><span class="lineno"> 2096</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> no_input:</div>
<div class="line"><span class="lineno"> 2097</span>            yout += squeeze(dot(U, transpose(D)))</div>
<div class="line"><span class="lineno"> 2098</span>        <span class="keywordflow">return</span> T, squeeze(yout), squeeze(xout)</div>
<div class="line"><span class="lineno"> 2099</span> </div>
<div class="line"><span class="lineno"> 2100</span>    dt = T[1] - T[0]</div>
<div class="line"><span class="lineno"> 2101</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.allclose((T[1:] - T[:-1]) / dt, 1.0):</div>
<div class="line"><span class="lineno"> 2102</span>        warnings.warn(<span class="stringliteral">&quot;Non-uniform timesteps are deprecated. Results may be &quot;</span></div>
<div class="line"><span class="lineno"> 2103</span>                      <span class="stringliteral">&quot;slow and/or inaccurate.&quot;</span>, DeprecationWarning)</div>
<div class="line"><span class="lineno"> 2104</span>        <span class="keywordflow">return</span> lsim2(system, U, T, X0)</div>
<div class="line"><span class="lineno"> 2105</span> </div>
<div class="line"><span class="lineno"> 2106</span>    <span class="keywordflow">if</span> no_input:</div>
<div class="line"><span class="lineno"> 2107</span>        <span class="comment"># Zero input: just use matrix exponential</span></div>
<div class="line"><span class="lineno"> 2108</span>        <span class="comment"># take transpose because state is a row vector</span></div>
<div class="line"><span class="lineno"> 2109</span>        expAT_dt = linalg.expm(transpose(A) * dt)</div>
<div class="line"><span class="lineno"> 2110</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, n_steps):</div>
<div class="line"><span class="lineno"> 2111</span>            xout[i] = dot(xout[i-1], expAT_dt)</div>
<div class="line"><span class="lineno"> 2112</span>        yout = squeeze(dot(xout, transpose(C)))</div>
<div class="line"><span class="lineno"> 2113</span>        <span class="keywordflow">return</span> T, squeeze(yout), squeeze(xout)</div>
<div class="line"><span class="lineno"> 2114</span> </div>
<div class="line"><span class="lineno"> 2115</span>    <span class="comment"># Nonzero input</span></div>
<div class="line"><span class="lineno"> 2116</span>    U = atleast_1d(U)</div>
<div class="line"><span class="lineno"> 2117</span>    <span class="keywordflow">if</span> U.ndim == 1:</div>
<div class="line"><span class="lineno"> 2118</span>        U = U[:, np.newaxis]</div>
<div class="line"><span class="lineno"> 2119</span> </div>
<div class="line"><span class="lineno"> 2120</span>    <span class="keywordflow">if</span> U.shape[0] != n_steps:</div>
<div class="line"><span class="lineno"> 2121</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;U must have the same number of rows &quot;</span></div>
<div class="line"><span class="lineno"> 2122</span>                         <span class="stringliteral">&quot;as elements in T.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2123</span> </div>
<div class="line"><span class="lineno"> 2124</span>    <span class="keywordflow">if</span> U.shape[1] != n_inputs:</div>
<div class="line"><span class="lineno"> 2125</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;System does not define that many inputs.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2126</span> </div>
<div class="line"><span class="lineno"> 2127</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> interp:</div>
<div class="line"><span class="lineno"> 2128</span>        <span class="comment"># Zero-order hold</span></div>
<div class="line"><span class="lineno"> 2129</span>        <span class="comment"># Algorithm: to integrate from time 0 to time dt, we solve</span></div>
<div class="line"><span class="lineno"> 2130</span>        <span class="comment">#   xdot = A x + B u,  x(0) = x0</span></div>
<div class="line"><span class="lineno"> 2131</span>        <span class="comment">#   udot = 0,          u(0) = u0.</span></div>
<div class="line"><span class="lineno"> 2132</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2133</span>        <span class="comment"># Solution is</span></div>
<div class="line"><span class="lineno"> 2134</span>        <span class="comment">#   [ x(dt) ]       [ A*dt   B*dt ] [ x0 ]</span></div>
<div class="line"><span class="lineno"> 2135</span>        <span class="comment">#   [ u(dt) ] = exp [  0     0    ] [ u0 ]</span></div>
<div class="line"><span class="lineno"> 2136</span>        M = np.vstack([np.hstack([A * dt, B * dt]),</div>
<div class="line"><span class="lineno"> 2137</span>                       np.zeros((n_inputs, n_states + n_inputs))])</div>
<div class="line"><span class="lineno"> 2138</span>        <span class="comment"># transpose everything because the state and input are row vectors</span></div>
<div class="line"><span class="lineno"> 2139</span>        expMT = linalg.expm(transpose(M))</div>
<div class="line"><span class="lineno"> 2140</span>        Ad = expMT[:n_states, :n_states]</div>
<div class="line"><span class="lineno"> 2141</span>        Bd = expMT[n_states:, :n_states]</div>
<div class="line"><span class="lineno"> 2142</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, n_steps):</div>
<div class="line"><span class="lineno"> 2143</span>            xout[i] = dot(xout[i-1], Ad) + dot(U[i-1], Bd)</div>
<div class="line"><span class="lineno"> 2144</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2145</span>        <span class="comment"># Linear interpolation between steps</span></div>
<div class="line"><span class="lineno"> 2146</span>        <span class="comment"># Algorithm: to integrate from time 0 to time dt, with linear</span></div>
<div class="line"><span class="lineno"> 2147</span>        <span class="comment"># interpolation between inputs u(0) = u0 and u(dt) = u1, we solve</span></div>
<div class="line"><span class="lineno"> 2148</span>        <span class="comment">#   xdot = A x + B u,        x(0) = x0</span></div>
<div class="line"><span class="lineno"> 2149</span>        <span class="comment">#   udot = (u1 - u0) / dt,   u(0) = u0.</span></div>
<div class="line"><span class="lineno"> 2150</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2151</span>        <span class="comment"># Solution is</span></div>
<div class="line"><span class="lineno"> 2152</span>        <span class="comment">#   [ x(dt) ]       [ A*dt  B*dt  0 ] [  x0   ]</span></div>
<div class="line"><span class="lineno"> 2153</span>        <span class="comment">#   [ u(dt) ] = exp [  0     0    I ] [  u0   ]</span></div>
<div class="line"><span class="lineno"> 2154</span>        <span class="comment">#   [u1 - u0]       [  0     0    0 ] [u1 - u0]</span></div>
<div class="line"><span class="lineno"> 2155</span>        M = np.vstack([np.hstack([A * dt, B * dt,</div>
<div class="line"><span class="lineno"> 2156</span>                                  np.zeros((n_states, n_inputs))]),</div>
<div class="line"><span class="lineno"> 2157</span>                       np.hstack([np.zeros((n_inputs, n_states + n_inputs)),</div>
<div class="line"><span class="lineno"> 2158</span>                                  np.identity(n_inputs)]),</div>
<div class="line"><span class="lineno"> 2159</span>                       np.zeros((n_inputs, n_states + 2 * n_inputs))])</div>
<div class="line"><span class="lineno"> 2160</span>        expMT = linalg.expm(transpose(M))</div>
<div class="line"><span class="lineno"> 2161</span>        Ad = expMT[:n_states, :n_states]</div>
<div class="line"><span class="lineno"> 2162</span>        Bd1 = expMT[n_states+n_inputs:, :n_states]</div>
<div class="line"><span class="lineno"> 2163</span>        Bd0 = expMT[n_states:n_states + n_inputs, :n_states] - Bd1</div>
<div class="line"><span class="lineno"> 2164</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, n_steps):</div>
<div class="line"><span class="lineno"> 2165</span>            xout[i] = (dot(xout[i-1], Ad) + dot(U[i-1], Bd0) + dot(U[i], Bd1))</div>
<div class="line"><span class="lineno"> 2166</span> </div>
<div class="line"><span class="lineno"> 2167</span>    yout = (squeeze(dot(xout, transpose(C))) + squeeze(dot(U, transpose(D))))</div>
<div class="line"><span class="lineno"> 2168</span>    <span class="keywordflow">return</span> T, squeeze(yout), squeeze(xout)</div>
<div class="line"><span class="lineno"> 2169</span> </div>
<div class="line"><span class="lineno"> 2170</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a43193c10de2bb05be9d1c60fbcf2f764" name="a43193c10de2bb05be9d1c60fbcf2f764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43193c10de2bb05be9d1c60fbcf2f764">&#9670;&#160;</a></span>lsim2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.lsim2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>U</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simulate output of a continuous-time linear system, by using
the ODE solver `scipy.integrate.odeint`.

Parameters
----------
system : an instance of the `lti` class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

    * 1: (instance of `lti`)
    * 2: (num, den)
    * 3: (zeros, poles, gain)
    * 4: (A, B, C, D)

U : array_like (1D or 2D), optional
    An input array describing the input at each time T.  Linear
    interpolation is used between given times.  If there are
    multiple inputs, then each column of the rank-2 array
    represents an input.  If U is not given, the input is assumed
    to be zero.
T : array_like (1D or 2D), optional
    The time steps at which the input is defined and at which the
    output is desired.  The default is 101 evenly spaced points on
    the interval [0,10.0].
X0 : array_like (1D), optional
    The initial condition of the state vector.  If `X0` is not
    given, the initial conditions are assumed to be 0.
kwargs : dict
    Additional keyword arguments are passed on to the function
    `odeint`.  See the notes below for more details.

Returns
-------
T : 1D ndarray
    The time values for the output.
yout : ndarray
    The response of the system.
xout : ndarray
    The time-evolution of the state-vector.

Notes
-----
This function uses `scipy.integrate.odeint` to solve the
system's differential equations.  Additional keyword arguments
given to `lsim2` are passed on to `odeint`.  See the documentation
for `scipy.integrate.odeint` for the full list of arguments.

If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

See Also
--------
lsim

Examples
--------
We'll use `lsim2` to simulate an analog Bessel filter applied to
a signal.

&gt;&gt;&gt; from scipy.signal import bessel, lsim2
&gt;&gt;&gt; import matplotlib.pyplot as plt

Create a low-pass Bessel filter with a cutoff of 12 Hz.

&gt;&gt;&gt; b, a = bessel(N=5, Wn=2*np.pi*12, btype='lowpass', analog=True)

Generate data to which the filter is applied.

&gt;&gt;&gt; t = np.linspace(0, 1.25, 500, endpoint=False)

The input signal is the sum of three sinusoidal curves, with
frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly
eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal.

&gt;&gt;&gt; u = (np.cos(2*np.pi*4*t) + 0.6*np.sin(2*np.pi*40*t) +
...      0.5*np.cos(2*np.pi*80*t))

Simulate the filter with `lsim2`.

&gt;&gt;&gt; tout, yout, xout = lsim2((b, a), U=u, T=t)

Plot the result.

&gt;&gt;&gt; plt.plot(t, u, 'r', alpha=0.5, linewidth=1, label='input')
&gt;&gt;&gt; plt.plot(tout, yout, 'k', linewidth=1.5, label='output')
&gt;&gt;&gt; plt.legend(loc='best', shadow=True, framealpha=1)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()

In a second example, we simulate a double integrator ``y'' = u``, with
a constant input ``u = 1``.  We'll use the state space representation
of the integrator.

&gt;&gt;&gt; from scipy.signal import lti
&gt;&gt;&gt; A = np.array([[0, 1], [0, 0]])
&gt;&gt;&gt; B = np.array([[0], [1]])
&gt;&gt;&gt; C = np.array([[1, 0]])
&gt;&gt;&gt; D = 0
&gt;&gt;&gt; system = lti(A, B, C, D)

`t` and `u` define the time and input signal for the system to
be simulated.

&gt;&gt;&gt; t = np.linspace(0, 5, num=50)
&gt;&gt;&gt; u = np.ones_like(t)

Compute the simulation, and then plot `y`.  As expected, the plot shows
the curve ``y = 0.5*t**2``.

&gt;&gt;&gt; tout, y, x = lsim2(system, u, t)
&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1764</span><span class="keyword">def </span>lsim2(system, U=None, T=None, X0=None, **kwargs):</div>
<div class="line"><span class="lineno"> 1765</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">    Simulate output of a continuous-time linear system, by using</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">    the ODE solver `scipy.integrate.odeint`.</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    system : an instance of the `lti` class or a tuple describing the system.</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">        * 1: (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">        * 2: (num, den)</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">        * 3: (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">        * 4: (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    U : array_like (1D or 2D), optional</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">        An input array describing the input at each time T.  Linear</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">        interpolation is used between given times.  If there are</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">        multiple inputs, then each column of the rank-2 array</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">        represents an input.  If U is not given, the input is assumed</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">        to be zero.</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">    T : array_like (1D or 2D), optional</span></div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">        The time steps at which the input is defined and at which the</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">        output is desired.  The default is 101 evenly spaced points on</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">        the interval [0,10.0].</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">    X0 : array_like (1D), optional</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">        The initial condition of the state vector.  If `X0` is not</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">        given, the initial conditions are assumed to be 0.</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">    kwargs : dict</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">        Additional keyword arguments are passed on to the function</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">        `odeint`.  See the notes below for more details.</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">    T : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        The time values for the output.</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">    yout : ndarray</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        The response of the system.</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">    xout : ndarray</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">        The time-evolution of the state-vector.</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">    This function uses `scipy.integrate.odeint` to solve the</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">    system&#39;s differential equations.  Additional keyword arguments</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">    given to `lsim2` are passed on to `odeint`.  See the documentation</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">    for `scipy.integrate.odeint` for the full list of arguments.</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">    lsim</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    We&#39;ll use `lsim2` to simulate an analog Bessel filter applied to</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    a signal.</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import bessel, lsim2</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">    Create a low-pass Bessel filter with a cutoff of 12 Hz.</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    &gt;&gt;&gt; b, a = bessel(N=5, Wn=2*np.pi*12, btype=&#39;lowpass&#39;, analog=True)</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    Generate data to which the filter is applied.</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 1.25, 500, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">    The input signal is the sum of three sinusoidal curves, with</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">    eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal.</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">    &gt;&gt;&gt; u = (np.cos(2*np.pi*4*t) + 0.6*np.sin(2*np.pi*40*t) +</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">    ...      0.5*np.cos(2*np.pi*80*t))</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">    Simulate the filter with `lsim2`.</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">    &gt;&gt;&gt; tout, yout, xout = lsim2((b, a), U=u, T=t)</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    Plot the result.</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, u, &#39;r&#39;, alpha=0.5, linewidth=1, label=&#39;input&#39;)</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(tout, yout, &#39;k&#39;, linewidth=1.5, label=&#39;output&#39;)</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;, shadow=True, framealpha=1)</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(alpha=0.3)</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    In a second example, we simulate a double integrator ``y&#39;&#39; = u``, with</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral">    a constant input ``u = 1``.  We&#39;ll use the state space representation</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    of the integrator.</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import lti</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[0, 1], [0, 0]])</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    &gt;&gt;&gt; B = np.array([[0], [1]])</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">    &gt;&gt;&gt; C = np.array([[1, 0]])</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">    &gt;&gt;&gt; D = 0</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral">    &gt;&gt;&gt; system = lti(A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">    `t` and `u` define the time and input signal for the system to</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">    be simulated.</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 5, num=50)</span></div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">    &gt;&gt;&gt; u = np.ones_like(t)</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral">    Compute the simulation, and then plot `y`.  As expected, the plot shows</span></div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    the curve ``y = 0.5*t**2``.</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    &gt;&gt;&gt; tout, y, x = lsim2(system, u, t)</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y)</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(alpha=0.3)</span></div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span></div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1884</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 1885</span>        sys = system._as_ss()</div>
<div class="line"><span class="lineno"> 1886</span>    <span class="keywordflow">elif</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 1887</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;lsim2 can only be used with continuous-time &#39;</span></div>
<div class="line"><span class="lineno"> 1888</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1889</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1890</span>        sys = lti(*system)._as_ss()</div>
<div class="line"><span class="lineno"> 1891</span> </div>
<div class="line"><span class="lineno"> 1892</span>    <span class="keywordflow">if</span> X0 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1893</span>        X0 = zeros(sys.B.shape[0], sys.A.dtype)</div>
<div class="line"><span class="lineno"> 1894</span> </div>
<div class="line"><span class="lineno"> 1895</span>    <span class="keywordflow">if</span> T <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1896</span>        <span class="comment"># XXX T should really be a required argument, but U was</span></div>
<div class="line"><span class="lineno"> 1897</span>        <span class="comment"># changed from a required positional argument to a keyword,</span></div>
<div class="line"><span class="lineno"> 1898</span>        <span class="comment"># and T is after U in the argument list.  So we either: change</span></div>
<div class="line"><span class="lineno"> 1899</span>        <span class="comment"># the API and move T in front of U; check here for T being</span></div>
<div class="line"><span class="lineno"> 1900</span>        <span class="comment"># None and raise an exception; or assign a default value to T</span></div>
<div class="line"><span class="lineno"> 1901</span>        <span class="comment"># here.  This code implements the latter.</span></div>
<div class="line"><span class="lineno"> 1902</span>        T = linspace(0, 10.0, 101)</div>
<div class="line"><span class="lineno"> 1903</span> </div>
<div class="line"><span class="lineno"> 1904</span>    T = atleast_1d(T)</div>
<div class="line"><span class="lineno"> 1905</span>    <span class="keywordflow">if</span> len(T.shape) != 1:</div>
<div class="line"><span class="lineno"> 1906</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;T must be a rank-1 array.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1907</span> </div>
<div class="line"><span class="lineno"> 1908</span>    <span class="keywordflow">if</span> U <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1909</span>        U = atleast_1d(U)</div>
<div class="line"><span class="lineno"> 1910</span>        <span class="keywordflow">if</span> len(U.shape) == 1:</div>
<div class="line"><span class="lineno"> 1911</span>            U = U.reshape(-1, 1)</div>
<div class="line"><span class="lineno"> 1912</span>        sU = U.shape</div>
<div class="line"><span class="lineno"> 1913</span>        <span class="keywordflow">if</span> sU[0] != len(T):</div>
<div class="line"><span class="lineno"> 1914</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;U must have the same number of rows &quot;</span></div>
<div class="line"><span class="lineno"> 1915</span>                             <span class="stringliteral">&quot;as elements in T.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1916</span> </div>
<div class="line"><span class="lineno"> 1917</span>        <span class="keywordflow">if</span> sU[1] != sys.inputs:</div>
<div class="line"><span class="lineno"> 1918</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The number of inputs in U (%d) is not &quot;</span></div>
<div class="line"><span class="lineno"> 1919</span>                             <span class="stringliteral">&quot;compatible with the number of system &quot;</span></div>
<div class="line"><span class="lineno"> 1920</span>                             <span class="stringliteral">&quot;inputs (%d)&quot;</span> % (sU[1], sys.inputs))</div>
<div class="line"><span class="lineno"> 1921</span>        <span class="comment"># Create a callable that uses linear interpolation to</span></div>
<div class="line"><span class="lineno"> 1922</span>        <span class="comment"># calculate the input at any time.</span></div>
<div class="line"><span class="lineno"> 1923</span>        ufunc = interpolate.interp1d(T, U, kind=<span class="stringliteral">&#39;linear&#39;</span>,</div>
<div class="line"><span class="lineno"> 1924</span>                                     axis=0, bounds_error=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1925</span> </div>
<div class="line"><span class="lineno"> 1926</span>        <span class="keyword">def </span>fprime(x, t, sys, ufunc):</div>
<div class="line"><span class="lineno"> 1927</span>            <span class="stringliteral">&quot;&quot;&quot;The vector field of the linear system.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1928</span>            <span class="keywordflow">return</span> dot(sys.A, x) + squeeze(dot(sys.B, nan_to_num(<a class="code hl_struct" href="structufunc.html">ufunc</a>([t]))))</div>
<div class="line"><span class="lineno"> 1929</span>        xout = integrate.odeint(fprime, X0, T, args=(sys, ufunc), **kwargs)</div>
<div class="line"><span class="lineno"> 1930</span>        yout = dot(sys.C, transpose(xout)) + dot(sys.D, transpose(U))</div>
<div class="line"><span class="lineno"> 1931</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1932</span>        <span class="keyword">def </span>fprime(x, t, sys):</div>
<div class="line"><span class="lineno"> 1933</span>            <span class="stringliteral">&quot;&quot;&quot;The vector field of the linear system.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1934</span>            <span class="keywordflow">return</span> dot(sys.A, x)</div>
<div class="line"><span class="lineno"> 1935</span>        xout = integrate.odeint(fprime, X0, T, args=(sys,), **kwargs)</div>
<div class="line"><span class="lineno"> 1936</span>        yout = dot(sys.C, transpose(xout))</div>
<div class="line"><span class="lineno"> 1937</span> </div>
<div class="line"><span class="lineno"> 1938</span>    <span class="keywordflow">return</span> T, squeeze(transpose(yout)), xout</div>
<div class="line"><span class="lineno"> 1939</span> </div>
<div class="line"><span class="lineno"> 1940</span> </div>
<div class="ttc" id="astructufunc_html"><div class="ttname"><a href="structufunc.html">ufunc</a></div><div class="ttdef"><b>Definition</b> generate_umath_validation_data.cpp:10</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a028e75567f2c624a3c1434b630817736" name="a028e75567f2c624a3c1434b630817736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028e75567f2c624a3c1434b630817736">&#9670;&#160;</a></span>place_poles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.place_poles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;YT&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute K such that eigenvalues (A - dot(B, K))=poles.

K is the gain matrix such as the plant described by the linear system
``AX+BU`` will have its closed-loop poles, i.e the eigenvalues ``A - B*K``,
as close as possible to those asked for in poles.

SISO, MISO and MIMO systems are supported.

Parameters
----------
A, B : ndarray
    State-space representation of linear system ``AX + BU``.
poles : array_like
    Desired real poles and/or complex conjugates poles.
    Complex poles are only supported with ``method="YT"`` (default).
method: {'YT', 'KNV0'}, optional
    Which method to choose to find the gain matrix K. One of:

        - 'YT': Yang Tits
        - 'KNV0': Kautsky, Nichols, Van Dooren update method 0

    See References and Notes for details on the algorithms.
rtol: float, optional
    After each iteration the determinant of the eigenvectors of
    ``A - B*K`` is compared to its previous value, when the relative
    error between these two values becomes lower than `rtol` the algorithm
    stops.  Default is 1e-3.
maxiter: int, optional
    Maximum number of iterations to compute the gain matrix.
    Default is 30.

Returns
-------
full_state_feedback : Bunch object
    full_state_feedback is composed of:
        gain_matrix : 1-D ndarray
            The closed loop matrix K such as the eigenvalues of ``A-BK``
            are as close as possible to the requested poles.
        computed_poles : 1-D ndarray
            The poles corresponding to ``A-BK`` sorted as first the real
            poles in increasing order, then the complex congugates in
            lexicographic order.
        requested_poles : 1-D ndarray
            The poles the algorithm was asked to place sorted as above,
            they may differ from what was achieved.
        X : 2-D ndarray
            The transfer matrix such as ``X * diag(poles) = (A - B*K)*X``
            (see Notes)
        rtol : float
            The relative tolerance achieved on ``det(X)`` (see Notes).
            `rtol` will be NaN if it is possible to solve the system
            ``diag(poles) = (A - B*K)``, or 0 when the optimization
            algorithms can't do anything i.e when ``B.shape[1] == 1``.
        nb_iter : int
            The number of iterations performed before converging.
            `nb_iter` will be NaN if it is possible to solve the system
            ``diag(poles) = (A - B*K)``, or 0 when the optimization
            algorithms can't do anything i.e when ``B.shape[1] == 1``.

Notes
-----
The Tits and Yang (YT), [2]_ paper is an update of the original Kautsky et
al. (KNV) paper [1]_.  KNV relies on rank-1 updates to find the transfer
matrix X such that ``X * diag(poles) = (A - B*K)*X``, whereas YT uses
rank-2 updates. This yields on average more robust solutions (see [2]_
pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV
does not in its original version.  Only update method 0 proposed by KNV has
been implemented here, hence the name ``'KNV0'``.

KNV extended to complex poles is used in Matlab's ``place`` function, YT is
distributed under a non-free licence by Slicot under the name ``robpole``.
It is unclear and undocumented how KNV0 has been extended to complex poles
(Tits and Yang claim on page 14 of their paper that their method can not be
used to extend KNV to complex poles), therefore only YT supports them in
this implementation.

As the solution to the problem of pole placement is not unique for MIMO
systems, both methods start with a tentative transfer matrix which is
altered in various way to increase its determinant.  Both methods have been
proven to converge to a stable solution, however depending on the way the
initial transfer matrix is chosen they will converge to different
solutions and therefore there is absolutely no guarantee that using
``'KNV0'`` will yield results similar to Matlab's or any other
implementation of these algorithms.

Using the default method ``'YT'`` should be fine in most cases; ``'KNV0'``
is only provided because it is needed by ``'YT'`` in some specific cases.
Furthermore ``'YT'`` gives on average more robust results than ``'KNV0'``
when ``abs(det(X))`` is used as a robustness indicator.

[2]_ is available as a technical report on the following URL:
https://hdl.handle.net/1903/5598

References
----------
.. [1] J. Kautsky, N.K. Nichols and P. van Dooren, "Robust pole assignment
       in linear state feedback", International Journal of Control, Vol. 41
       pp. 1129-1155, 1985.
.. [2] A.L. Tits and Y. Yang, "Globally convergent algorithms for robust
       pole assignment by state feedback", IEEE Transactions on Automatic
       Control, Vol. 41, pp. 1432-1452, 1996.

Examples
--------
A simple example demonstrating real pole placement using both KNV and YT
algorithms.  This is example number 1 from section 4 of the reference KNV
publication ([1]_):

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; A = np.array([[ 1.380,  -0.2077,  6.715, -5.676  ],
...               [-0.5814, -4.290,   0,      0.6750 ],
...               [ 1.067,   4.273,  -6.654,  5.893  ],
...               [ 0.0480,  4.273,   1.343, -2.104  ]])
&gt;&gt;&gt; B = np.array([[ 0,      5.679 ],
...               [ 1.136,  1.136 ],
...               [ 0,      0,    ],
...               [-3.146,  0     ]])
&gt;&gt;&gt; P = np.array([-0.2, -0.5, -5.0566, -8.6659])

Now compute K with KNV method 0, with the default YT method and with the YT
method while forcing 100 iterations of the algorithm and print some results
after each call.

&gt;&gt;&gt; fsf1 = signal.place_poles(A, B, P, method='KNV0')
&gt;&gt;&gt; fsf1.gain_matrix
array([[ 0.20071427, -0.96665799,  0.24066128, -0.10279785],
       [ 0.50587268,  0.57779091,  0.51795763, -0.41991442]])

&gt;&gt;&gt; fsf2 = signal.place_poles(A, B, P)  # uses YT method
&gt;&gt;&gt; fsf2.computed_poles
array([-8.6659, -5.0566, -0.5   , -0.2   ])

&gt;&gt;&gt; fsf3 = signal.place_poles(A, B, P, rtol=-1, maxiter=100)
&gt;&gt;&gt; fsf3.X
array([[ 0.52072442+0.j, -0.08409372+0.j, -0.56847937+0.j,  0.74823657+0.j],
       [-0.04977751+0.j, -0.80872954+0.j,  0.13566234+0.j, -0.29322906+0.j],
       [-0.82266932+0.j, -0.19168026+0.j, -0.56348322+0.j, -0.43815060+0.j],
       [ 0.22267347+0.j,  0.54967577+0.j, -0.58387806+0.j, -0.40271926+0.j]])

The absolute value of the determinant of X is a good indicator to check the
robustness of the results, both ``'KNV0'`` and ``'YT'`` aim at maximizing
it.  Below a comparison of the robustness of the results above:

&gt;&gt;&gt; abs(np.linalg.det(fsf1.X)) &lt; abs(np.linalg.det(fsf2.X))
True
&gt;&gt;&gt; abs(np.linalg.det(fsf2.X)) &lt; abs(np.linalg.det(fsf3.X))
True

Now a simple example for complex poles:

&gt;&gt;&gt; A = np.array([[ 0,  7/3.,  0,   0   ],
...               [ 0,   0,    0,  7/9. ],
...               [ 0,   0,    0,   0   ],
...               [ 0,   0,    0,   0   ]])
&gt;&gt;&gt; B = np.array([[ 0,  0 ],
...               [ 0,  0 ],
...               [ 1,  0 ],
...               [ 0,  1 ]])
&gt;&gt;&gt; P = np.array([-3, -1, -2-1j, -2+1j]) / 3.
&gt;&gt;&gt; fsf = signal.place_poles(A, B, P, method='YT')

We can plot the desired and computed poles in the complex plane:

&gt;&gt;&gt; t = np.linspace(0, 2*np.pi, 401)
&gt;&gt;&gt; plt.plot(np.cos(t), np.sin(t), 'k--')  # unit circle
&gt;&gt;&gt; plt.plot(fsf.requested_poles.real, fsf.requested_poles.imag,
...          'wo', label='Desired')
&gt;&gt;&gt; plt.plot(fsf.computed_poles.real, fsf.computed_poles.imag, 'bx',
...          label='Placed')
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.axis('image')
&gt;&gt;&gt; plt.axis([-1.1, 1.1, -1.1, 1.1])
&gt;&gt;&gt; plt.legend(bbox_to_anchor=(1.05, 1), loc=2, numpoints=1)</pre> <div class="fragment"><div class="line"><span class="lineno"> 3053</span><span class="keyword">def </span>place_poles(A, B, poles, method=&quot;YT&quot;, rtol=1e-3, maxiter=30):</div>
<div class="line"><span class="lineno"> 3054</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3055</span><span class="stringliteral">    Compute K such that eigenvalues (A - dot(B, K))=poles.</span></div>
<div class="line"><span class="lineno"> 3056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3057</span><span class="stringliteral">    K is the gain matrix such as the plant described by the linear system</span></div>
<div class="line"><span class="lineno"> 3058</span><span class="stringliteral">    ``AX+BU`` will have its closed-loop poles, i.e the eigenvalues ``A - B*K``,</span></div>
<div class="line"><span class="lineno"> 3059</span><span class="stringliteral">    as close as possible to those asked for in poles.</span></div>
<div class="line"><span class="lineno"> 3060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3061</span><span class="stringliteral">    SISO, MISO and MIMO systems are supported.</span></div>
<div class="line"><span class="lineno"> 3062</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3063</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3064</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3065</span><span class="stringliteral">    A, B : ndarray</span></div>
<div class="line"><span class="lineno"> 3066</span><span class="stringliteral">        State-space representation of linear system ``AX + BU``.</span></div>
<div class="line"><span class="lineno"> 3067</span><span class="stringliteral">    poles : array_like</span></div>
<div class="line"><span class="lineno"> 3068</span><span class="stringliteral">        Desired real poles and/or complex conjugates poles.</span></div>
<div class="line"><span class="lineno"> 3069</span><span class="stringliteral">        Complex poles are only supported with ``method=&quot;YT&quot;`` (default).</span></div>
<div class="line"><span class="lineno"> 3070</span><span class="stringliteral">    method: {&#39;YT&#39;, &#39;KNV0&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3071</span><span class="stringliteral">        Which method to choose to find the gain matrix K. One of:</span></div>
<div class="line"><span class="lineno"> 3072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3073</span><span class="stringliteral">            - &#39;YT&#39;: Yang Tits</span></div>
<div class="line"><span class="lineno"> 3074</span><span class="stringliteral">            - &#39;KNV0&#39;: Kautsky, Nichols, Van Dooren update method 0</span></div>
<div class="line"><span class="lineno"> 3075</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3076</span><span class="stringliteral">        See References and Notes for details on the algorithms.</span></div>
<div class="line"><span class="lineno"> 3077</span><span class="stringliteral">    rtol: float, optional</span></div>
<div class="line"><span class="lineno"> 3078</span><span class="stringliteral">        After each iteration the determinant of the eigenvectors of</span></div>
<div class="line"><span class="lineno"> 3079</span><span class="stringliteral">        ``A - B*K`` is compared to its previous value, when the relative</span></div>
<div class="line"><span class="lineno"> 3080</span><span class="stringliteral">        error between these two values becomes lower than `rtol` the algorithm</span></div>
<div class="line"><span class="lineno"> 3081</span><span class="stringliteral">        stops.  Default is 1e-3.</span></div>
<div class="line"><span class="lineno"> 3082</span><span class="stringliteral">    maxiter: int, optional</span></div>
<div class="line"><span class="lineno"> 3083</span><span class="stringliteral">        Maximum number of iterations to compute the gain matrix.</span></div>
<div class="line"><span class="lineno"> 3084</span><span class="stringliteral">        Default is 30.</span></div>
<div class="line"><span class="lineno"> 3085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3086</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3087</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3088</span><span class="stringliteral">    full_state_feedback : Bunch object</span></div>
<div class="line"><span class="lineno"> 3089</span><span class="stringliteral">        full_state_feedback is composed of:</span></div>
<div class="line"><span class="lineno"> 3090</span><span class="stringliteral">            gain_matrix : 1-D ndarray</span></div>
<div class="line"><span class="lineno"> 3091</span><span class="stringliteral">                The closed loop matrix K such as the eigenvalues of ``A-BK``</span></div>
<div class="line"><span class="lineno"> 3092</span><span class="stringliteral">                are as close as possible to the requested poles.</span></div>
<div class="line"><span class="lineno"> 3093</span><span class="stringliteral">            computed_poles : 1-D ndarray</span></div>
<div class="line"><span class="lineno"> 3094</span><span class="stringliteral">                The poles corresponding to ``A-BK`` sorted as first the real</span></div>
<div class="line"><span class="lineno"> 3095</span><span class="stringliteral">                poles in increasing order, then the complex congugates in</span></div>
<div class="line"><span class="lineno"> 3096</span><span class="stringliteral">                lexicographic order.</span></div>
<div class="line"><span class="lineno"> 3097</span><span class="stringliteral">            requested_poles : 1-D ndarray</span></div>
<div class="line"><span class="lineno"> 3098</span><span class="stringliteral">                The poles the algorithm was asked to place sorted as above,</span></div>
<div class="line"><span class="lineno"> 3099</span><span class="stringliteral">                they may differ from what was achieved.</span></div>
<div class="line"><span class="lineno"> 3100</span><span class="stringliteral">            X : 2-D ndarray</span></div>
<div class="line"><span class="lineno"> 3101</span><span class="stringliteral">                The transfer matrix such as ``X * diag(poles) = (A - B*K)*X``</span></div>
<div class="line"><span class="lineno"> 3102</span><span class="stringliteral">                (see Notes)</span></div>
<div class="line"><span class="lineno"> 3103</span><span class="stringliteral">            rtol : float</span></div>
<div class="line"><span class="lineno"> 3104</span><span class="stringliteral">                The relative tolerance achieved on ``det(X)`` (see Notes).</span></div>
<div class="line"><span class="lineno"> 3105</span><span class="stringliteral">                `rtol` will be NaN if it is possible to solve the system</span></div>
<div class="line"><span class="lineno"> 3106</span><span class="stringliteral">                ``diag(poles) = (A - B*K)``, or 0 when the optimization</span></div>
<div class="line"><span class="lineno"> 3107</span><span class="stringliteral">                algorithms can&#39;t do anything i.e when ``B.shape[1] == 1``.</span></div>
<div class="line"><span class="lineno"> 3108</span><span class="stringliteral">            nb_iter : int</span></div>
<div class="line"><span class="lineno"> 3109</span><span class="stringliteral">                The number of iterations performed before converging.</span></div>
<div class="line"><span class="lineno"> 3110</span><span class="stringliteral">                `nb_iter` will be NaN if it is possible to solve the system</span></div>
<div class="line"><span class="lineno"> 3111</span><span class="stringliteral">                ``diag(poles) = (A - B*K)``, or 0 when the optimization</span></div>
<div class="line"><span class="lineno"> 3112</span><span class="stringliteral">                algorithms can&#39;t do anything i.e when ``B.shape[1] == 1``.</span></div>
<div class="line"><span class="lineno"> 3113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3114</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3115</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3116</span><span class="stringliteral">    The Tits and Yang (YT), [2]_ paper is an update of the original Kautsky et</span></div>
<div class="line"><span class="lineno"> 3117</span><span class="stringliteral">    al. (KNV) paper [1]_.  KNV relies on rank-1 updates to find the transfer</span></div>
<div class="line"><span class="lineno"> 3118</span><span class="stringliteral">    matrix X such that ``X * diag(poles) = (A - B*K)*X``, whereas YT uses</span></div>
<div class="line"><span class="lineno"> 3119</span><span class="stringliteral">    rank-2 updates. This yields on average more robust solutions (see [2]_</span></div>
<div class="line"><span class="lineno"> 3120</span><span class="stringliteral">    pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV</span></div>
<div class="line"><span class="lineno"> 3121</span><span class="stringliteral">    does not in its original version.  Only update method 0 proposed by KNV has</span></div>
<div class="line"><span class="lineno"> 3122</span><span class="stringliteral">    been implemented here, hence the name ``&#39;KNV0&#39;``.</span></div>
<div class="line"><span class="lineno"> 3123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3124</span><span class="stringliteral">    KNV extended to complex poles is used in Matlab&#39;s ``place`` function, YT is</span></div>
<div class="line"><span class="lineno"> 3125</span><span class="stringliteral">    distributed under a non-free licence by Slicot under the name ``robpole``.</span></div>
<div class="line"><span class="lineno"> 3126</span><span class="stringliteral">    It is unclear and undocumented how KNV0 has been extended to complex poles</span></div>
<div class="line"><span class="lineno"> 3127</span><span class="stringliteral">    (Tits and Yang claim on page 14 of their paper that their method can not be</span></div>
<div class="line"><span class="lineno"> 3128</span><span class="stringliteral">    used to extend KNV to complex poles), therefore only YT supports them in</span></div>
<div class="line"><span class="lineno"> 3129</span><span class="stringliteral">    this implementation.</span></div>
<div class="line"><span class="lineno"> 3130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3131</span><span class="stringliteral">    As the solution to the problem of pole placement is not unique for MIMO</span></div>
<div class="line"><span class="lineno"> 3132</span><span class="stringliteral">    systems, both methods start with a tentative transfer matrix which is</span></div>
<div class="line"><span class="lineno"> 3133</span><span class="stringliteral">    altered in various way to increase its determinant.  Both methods have been</span></div>
<div class="line"><span class="lineno"> 3134</span><span class="stringliteral">    proven to converge to a stable solution, however depending on the way the</span></div>
<div class="line"><span class="lineno"> 3135</span><span class="stringliteral">    initial transfer matrix is chosen they will converge to different</span></div>
<div class="line"><span class="lineno"> 3136</span><span class="stringliteral">    solutions and therefore there is absolutely no guarantee that using</span></div>
<div class="line"><span class="lineno"> 3137</span><span class="stringliteral">    ``&#39;KNV0&#39;`` will yield results similar to Matlab&#39;s or any other</span></div>
<div class="line"><span class="lineno"> 3138</span><span class="stringliteral">    implementation of these algorithms.</span></div>
<div class="line"><span class="lineno"> 3139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral">    Using the default method ``&#39;YT&#39;`` should be fine in most cases; ``&#39;KNV0&#39;``</span></div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral">    is only provided because it is needed by ``&#39;YT&#39;`` in some specific cases.</span></div>
<div class="line"><span class="lineno"> 3142</span><span class="stringliteral">    Furthermore ``&#39;YT&#39;`` gives on average more robust results than ``&#39;KNV0&#39;``</span></div>
<div class="line"><span class="lineno"> 3143</span><span class="stringliteral">    when ``abs(det(X))`` is used as a robustness indicator.</span></div>
<div class="line"><span class="lineno"> 3144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3145</span><span class="stringliteral">    [2]_ is available as a technical report on the following URL:</span></div>
<div class="line"><span class="lineno"> 3146</span><span class="stringliteral">    https://hdl.handle.net/1903/5598</span></div>
<div class="line"><span class="lineno"> 3147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3148</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3149</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3150</span><span class="stringliteral">    .. [1] J. Kautsky, N.K. Nichols and P. van Dooren, &quot;Robust pole assignment</span></div>
<div class="line"><span class="lineno"> 3151</span><span class="stringliteral">           in linear state feedback&quot;, International Journal of Control, Vol. 41</span></div>
<div class="line"><span class="lineno"> 3152</span><span class="stringliteral">           pp. 1129-1155, 1985.</span></div>
<div class="line"><span class="lineno"> 3153</span><span class="stringliteral">    .. [2] A.L. Tits and Y. Yang, &quot;Globally convergent algorithms for robust</span></div>
<div class="line"><span class="lineno"> 3154</span><span class="stringliteral">           pole assignment by state feedback&quot;, IEEE Transactions on Automatic</span></div>
<div class="line"><span class="lineno"> 3155</span><span class="stringliteral">           Control, Vol. 41, pp. 1432-1452, 1996.</span></div>
<div class="line"><span class="lineno"> 3156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3157</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3158</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3159</span><span class="stringliteral">    A simple example demonstrating real pole placement using both KNV and YT</span></div>
<div class="line"><span class="lineno"> 3160</span><span class="stringliteral">    algorithms.  This is example number 1 from section 4 of the reference KNV</span></div>
<div class="line"><span class="lineno"> 3161</span><span class="stringliteral">    publication ([1]_):</span></div>
<div class="line"><span class="lineno"> 3162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3163</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3164</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3166</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[ 1.380,  -0.2077,  6.715, -5.676  ],</span></div>
<div class="line"><span class="lineno"> 3167</span><span class="stringliteral">    ...               [-0.5814, -4.290,   0,      0.6750 ],</span></div>
<div class="line"><span class="lineno"> 3168</span><span class="stringliteral">    ...               [ 1.067,   4.273,  -6.654,  5.893  ],</span></div>
<div class="line"><span class="lineno"> 3169</span><span class="stringliteral">    ...               [ 0.0480,  4.273,   1.343, -2.104  ]])</span></div>
<div class="line"><span class="lineno"> 3170</span><span class="stringliteral">    &gt;&gt;&gt; B = np.array([[ 0,      5.679 ],</span></div>
<div class="line"><span class="lineno"> 3171</span><span class="stringliteral">    ...               [ 1.136,  1.136 ],</span></div>
<div class="line"><span class="lineno"> 3172</span><span class="stringliteral">    ...               [ 0,      0,    ],</span></div>
<div class="line"><span class="lineno"> 3173</span><span class="stringliteral">    ...               [-3.146,  0     ]])</span></div>
<div class="line"><span class="lineno"> 3174</span><span class="stringliteral">    &gt;&gt;&gt; P = np.array([-0.2, -0.5, -5.0566, -8.6659])</span></div>
<div class="line"><span class="lineno"> 3175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3176</span><span class="stringliteral">    Now compute K with KNV method 0, with the default YT method and with the YT</span></div>
<div class="line"><span class="lineno"> 3177</span><span class="stringliteral">    method while forcing 100 iterations of the algorithm and print some results</span></div>
<div class="line"><span class="lineno"> 3178</span><span class="stringliteral">    after each call.</span></div>
<div class="line"><span class="lineno"> 3179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3180</span><span class="stringliteral">    &gt;&gt;&gt; fsf1 = signal.place_poles(A, B, P, method=&#39;KNV0&#39;)</span></div>
<div class="line"><span class="lineno"> 3181</span><span class="stringliteral">    &gt;&gt;&gt; fsf1.gain_matrix</span></div>
<div class="line"><span class="lineno"> 3182</span><span class="stringliteral">    array([[ 0.20071427, -0.96665799,  0.24066128, -0.10279785],</span></div>
<div class="line"><span class="lineno"> 3183</span><span class="stringliteral">           [ 0.50587268,  0.57779091,  0.51795763, -0.41991442]])</span></div>
<div class="line"><span class="lineno"> 3184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3185</span><span class="stringliteral">    &gt;&gt;&gt; fsf2 = signal.place_poles(A, B, P)  # uses YT method</span></div>
<div class="line"><span class="lineno"> 3186</span><span class="stringliteral">    &gt;&gt;&gt; fsf2.computed_poles</span></div>
<div class="line"><span class="lineno"> 3187</span><span class="stringliteral">    array([-8.6659, -5.0566, -0.5   , -0.2   ])</span></div>
<div class="line"><span class="lineno"> 3188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3189</span><span class="stringliteral">    &gt;&gt;&gt; fsf3 = signal.place_poles(A, B, P, rtol=-1, maxiter=100)</span></div>
<div class="line"><span class="lineno"> 3190</span><span class="stringliteral">    &gt;&gt;&gt; fsf3.X</span></div>
<div class="line"><span class="lineno"> 3191</span><span class="stringliteral">    array([[ 0.52072442+0.j, -0.08409372+0.j, -0.56847937+0.j,  0.74823657+0.j],</span></div>
<div class="line"><span class="lineno"> 3192</span><span class="stringliteral">           [-0.04977751+0.j, -0.80872954+0.j,  0.13566234+0.j, -0.29322906+0.j],</span></div>
<div class="line"><span class="lineno"> 3193</span><span class="stringliteral">           [-0.82266932+0.j, -0.19168026+0.j, -0.56348322+0.j, -0.43815060+0.j],</span></div>
<div class="line"><span class="lineno"> 3194</span><span class="stringliteral">           [ 0.22267347+0.j,  0.54967577+0.j, -0.58387806+0.j, -0.40271926+0.j]])</span></div>
<div class="line"><span class="lineno"> 3195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3196</span><span class="stringliteral">    The absolute value of the determinant of X is a good indicator to check the</span></div>
<div class="line"><span class="lineno"> 3197</span><span class="stringliteral">    robustness of the results, both ``&#39;KNV0&#39;`` and ``&#39;YT&#39;`` aim at maximizing</span></div>
<div class="line"><span class="lineno"> 3198</span><span class="stringliteral">    it.  Below a comparison of the robustness of the results above:</span></div>
<div class="line"><span class="lineno"> 3199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3200</span><span class="stringliteral">    &gt;&gt;&gt; abs(np.linalg.det(fsf1.X)) &lt; abs(np.linalg.det(fsf2.X))</span></div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral">    &gt;&gt;&gt; abs(np.linalg.det(fsf2.X)) &lt; abs(np.linalg.det(fsf3.X))</span></div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3205</span><span class="stringliteral">    Now a simple example for complex poles:</span></div>
<div class="line"><span class="lineno"> 3206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3207</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[ 0,  7/3.,  0,   0   ],</span></div>
<div class="line"><span class="lineno"> 3208</span><span class="stringliteral">    ...               [ 0,   0,    0,  7/9. ],</span></div>
<div class="line"><span class="lineno"> 3209</span><span class="stringliteral">    ...               [ 0,   0,    0,   0   ],</span></div>
<div class="line"><span class="lineno"> 3210</span><span class="stringliteral">    ...               [ 0,   0,    0,   0   ]])</span></div>
<div class="line"><span class="lineno"> 3211</span><span class="stringliteral">    &gt;&gt;&gt; B = np.array([[ 0,  0 ],</span></div>
<div class="line"><span class="lineno"> 3212</span><span class="stringliteral">    ...               [ 0,  0 ],</span></div>
<div class="line"><span class="lineno"> 3213</span><span class="stringliteral">    ...               [ 1,  0 ],</span></div>
<div class="line"><span class="lineno"> 3214</span><span class="stringliteral">    ...               [ 0,  1 ]])</span></div>
<div class="line"><span class="lineno"> 3215</span><span class="stringliteral">    &gt;&gt;&gt; P = np.array([-3, -1, -2-1j, -2+1j]) / 3.</span></div>
<div class="line"><span class="lineno"> 3216</span><span class="stringliteral">    &gt;&gt;&gt; fsf = signal.place_poles(A, B, P, method=&#39;YT&#39;)</span></div>
<div class="line"><span class="lineno"> 3217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3218</span><span class="stringliteral">    We can plot the desired and computed poles in the complex plane:</span></div>
<div class="line"><span class="lineno"> 3219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3220</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 2*np.pi, 401)</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(np.cos(t), np.sin(t), &#39;k--&#39;)  # unit circle</span></div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(fsf.requested_poles.real, fsf.requested_poles.imag,</span></div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral">    ...          &#39;wo&#39;, label=&#39;Desired&#39;)</span></div>
<div class="line"><span class="lineno"> 3224</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(fsf.computed_poles.real, fsf.computed_poles.imag, &#39;bx&#39;,</span></div>
<div class="line"><span class="lineno"> 3225</span><span class="stringliteral">    ...          label=&#39;Placed&#39;)</span></div>
<div class="line"><span class="lineno"> 3226</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid()</span></div>
<div class="line"><span class="lineno"> 3227</span><span class="stringliteral">    &gt;&gt;&gt; plt.axis(&#39;image&#39;)</span></div>
<div class="line"><span class="lineno"> 3228</span><span class="stringliteral">    &gt;&gt;&gt; plt.axis([-1.1, 1.1, -1.1, 1.1])</span></div>
<div class="line"><span class="lineno"> 3229</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(bbox_to_anchor=(1.05, 1), loc=2, numpoints=1)</span></div>
<div class="line"><span class="lineno"> 3230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3231</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3232</span>    <span class="comment"># Move away all the inputs checking, it only adds noise to the code</span></div>
<div class="line"><span class="lineno"> 3233</span>    update_loop, poles = _valid_inputs(A, B, poles, method, rtol, maxiter)</div>
<div class="line"><span class="lineno"> 3234</span> </div>
<div class="line"><span class="lineno"> 3235</span>    <span class="comment"># The current value of the relative tolerance we achieved</span></div>
<div class="line"><span class="lineno"> 3236</span>    cur_rtol = 0</div>
<div class="line"><span class="lineno"> 3237</span>    <span class="comment"># The number of iterations needed before converging</span></div>
<div class="line"><span class="lineno"> 3238</span>    nb_iter = 0</div>
<div class="line"><span class="lineno"> 3239</span> </div>
<div class="line"><span class="lineno"> 3240</span>    <span class="comment"># Step A: QR decomposition of B page 1132 KN</span></div>
<div class="line"><span class="lineno"> 3241</span>    <span class="comment"># to debug with numpy qr uncomment the line below</span></div>
<div class="line"><span class="lineno"> 3242</span>    <span class="comment"># u, z = np.linalg.qr(B, mode=&quot;complete&quot;)</span></div>
<div class="line"><span class="lineno"> 3243</span>    u, z = s_qr(B, mode=<span class="stringliteral">&quot;full&quot;</span>)</div>
<div class="line"><span class="lineno"> 3244</span>    rankB = np.linalg.matrix_rank(B)</div>
<div class="line"><span class="lineno"> 3245</span>    u0 = u[:, :rankB]</div>
<div class="line"><span class="lineno"> 3246</span>    u1 = u[:, rankB:]</div>
<div class="line"><span class="lineno"> 3247</span>    z = z[:rankB, :]</div>
<div class="line"><span class="lineno"> 3248</span> </div>
<div class="line"><span class="lineno"> 3249</span>    <span class="comment"># If we can use the identity matrix as X the solution is obvious</span></div>
<div class="line"><span class="lineno"> 3250</span>    <span class="keywordflow">if</span> B.shape[0] == rankB:</div>
<div class="line"><span class="lineno"> 3251</span>        <span class="comment"># if B is square and full rank there is only one solution</span></div>
<div class="line"><span class="lineno"> 3252</span>        <span class="comment"># such as (A+BK)=inv(X)*diag(P)*X with X=eye(A.shape[0])</span></div>
<div class="line"><span class="lineno"> 3253</span>        <span class="comment"># i.e K=inv(B)*(diag(P)-A)</span></div>
<div class="line"><span class="lineno"> 3254</span>        <span class="comment"># if B has as many lines as its rank (but not square) there are many</span></div>
<div class="line"><span class="lineno"> 3255</span>        <span class="comment"># solutions and we can choose one using least squares</span></div>
<div class="line"><span class="lineno"> 3256</span>        <span class="comment"># =&gt; use lstsq in both cases.</span></div>
<div class="line"><span class="lineno"> 3257</span>        <span class="comment"># In both cases the transfer matrix X will be eye(A.shape[0]) and I</span></div>
<div class="line"><span class="lineno"> 3258</span>        <span class="comment"># can hardly think of a better one so there is nothing to optimize</span></div>
<div class="line"><span class="lineno"> 3259</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3260</span>        <span class="comment"># for complex poles we use the following trick</span></div>
<div class="line"><span class="lineno"> 3261</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3262</span>        <span class="comment"># |a -b| has for eigenvalues a+b and a-b</span></div>
<div class="line"><span class="lineno"> 3263</span>        <span class="comment"># |b a|</span></div>
<div class="line"><span class="lineno"> 3264</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3265</span>        <span class="comment"># |a+bi 0| has the obvious eigenvalues a+bi and a-bi</span></div>
<div class="line"><span class="lineno"> 3266</span>        <span class="comment"># |0 a-bi|</span></div>
<div class="line"><span class="lineno"> 3267</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3268</span>        <span class="comment"># e.g solving the first one in R gives the solution</span></div>
<div class="line"><span class="lineno"> 3269</span>        <span class="comment"># for the second one in C</span></div>
<div class="line"><span class="lineno"> 3270</span>        diag_poles = np.zeros(A.shape)</div>
<div class="line"><span class="lineno"> 3271</span>        idx = 0</div>
<div class="line"><span class="lineno"> 3272</span>        <span class="keywordflow">while</span> idx &lt; poles.shape[0]:</div>
<div class="line"><span class="lineno"> 3273</span>            p = poles[idx]</div>
<div class="line"><span class="lineno"> 3274</span>            diag_poles[idx, idx] = np.real(p)</div>
<div class="line"><span class="lineno"> 3275</span>            <span class="keywordflow">if</span> ~np.isreal(p):</div>
<div class="line"><span class="lineno"> 3276</span>                diag_poles[idx, idx+1] = -np.imag(p)</div>
<div class="line"><span class="lineno"> 3277</span>                diag_poles[idx+1, idx+1] = np.real(p)</div>
<div class="line"><span class="lineno"> 3278</span>                diag_poles[idx+1, idx] = np.imag(p)</div>
<div class="line"><span class="lineno"> 3279</span>                idx += 1  <span class="comment"># skip next one</span></div>
<div class="line"><span class="lineno"> 3280</span>            idx += 1</div>
<div class="line"><span class="lineno"> 3281</span>        gain_matrix = np.linalg.lstsq(B, diag_poles-A, rcond=-1)[0]</div>
<div class="line"><span class="lineno"> 3282</span>        transfer_matrix = np.eye(A.shape[0])</div>
<div class="line"><span class="lineno"> 3283</span>        cur_rtol = np.nan</div>
<div class="line"><span class="lineno"> 3284</span>        nb_iter = np.nan</div>
<div class="line"><span class="lineno"> 3285</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3286</span>        <span class="comment"># step A (p1144 KNV) and beginning of step F: decompose</span></div>
<div class="line"><span class="lineno"> 3287</span>        <span class="comment"># dot(U1.T, A-P[i]*I).T and build our set of transfer_matrix vectors</span></div>
<div class="line"><span class="lineno"> 3288</span>        <span class="comment"># in the same loop</span></div>
<div class="line"><span class="lineno"> 3289</span>        ker_pole = []</div>
<div class="line"><span class="lineno"> 3290</span> </div>
<div class="line"><span class="lineno"> 3291</span>        <span class="comment"># flag to skip the conjugate of a complex pole</span></div>
<div class="line"><span class="lineno"> 3292</span>        skip_conjugate = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3293</span>        <span class="comment"># select orthonormal base ker_pole for each Pole and vectors for</span></div>
<div class="line"><span class="lineno"> 3294</span>        <span class="comment"># transfer_matrix</span></div>
<div class="line"><span class="lineno"> 3295</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(B.shape[0]):</div>
<div class="line"><span class="lineno"> 3296</span>            <span class="keywordflow">if</span> skip_conjugate:</div>
<div class="line"><span class="lineno"> 3297</span>                skip_conjugate = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3298</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 3299</span>            pole_space_j = np.dot(u1.T, A-poles[j]*np.eye(B.shape[0])).T</div>
<div class="line"><span class="lineno"> 3300</span> </div>
<div class="line"><span class="lineno"> 3301</span>            <span class="comment"># after QR Q=Q0|Q1</span></div>
<div class="line"><span class="lineno"> 3302</span>            <span class="comment"># only Q0 is used to reconstruct  the qr&#39;ed (dot Q, R) matrix.</span></div>
<div class="line"><span class="lineno"> 3303</span>            <span class="comment"># Q1 is orthogonnal to Q0 and will be multiplied by the zeros in</span></div>
<div class="line"><span class="lineno"> 3304</span>            <span class="comment"># R when using mode &quot;complete&quot;. In default mode Q1 and the zeros</span></div>
<div class="line"><span class="lineno"> 3305</span>            <span class="comment"># in R are not computed</span></div>
<div class="line"><span class="lineno"> 3306</span> </div>
<div class="line"><span class="lineno"> 3307</span>            <span class="comment"># To debug with numpy qr uncomment the line below</span></div>
<div class="line"><span class="lineno"> 3308</span>            <span class="comment"># Q, _ = np.linalg.qr(pole_space_j, mode=&quot;complete&quot;)</span></div>
<div class="line"><span class="lineno"> 3309</span>            Q, _ = s_qr(pole_space_j, mode=<span class="stringliteral">&quot;full&quot;</span>)</div>
<div class="line"><span class="lineno"> 3310</span> </div>
<div class="line"><span class="lineno"> 3311</span>            ker_pole_j = Q[:, pole_space_j.shape[1]:]</div>
<div class="line"><span class="lineno"> 3312</span> </div>
<div class="line"><span class="lineno"> 3313</span>            <span class="comment"># We want to select one vector in ker_pole_j to build the transfer</span></div>
<div class="line"><span class="lineno"> 3314</span>            <span class="comment"># matrix, however qr returns sometimes vectors with zeros on the</span></div>
<div class="line"><span class="lineno"> 3315</span>            <span class="comment"># same line for each pole and this yields very long convergence</span></div>
<div class="line"><span class="lineno"> 3316</span>            <span class="comment"># times.</span></div>
<div class="line"><span class="lineno"> 3317</span>            <span class="comment"># Or some other times a set of vectors, one with zero imaginary</span></div>
<div class="line"><span class="lineno"> 3318</span>            <span class="comment"># part and one (or several) with imaginary parts. After trying</span></div>
<div class="line"><span class="lineno"> 3319</span>            <span class="comment"># many ways to select the best possible one (eg ditch vectors</span></div>
<div class="line"><span class="lineno"> 3320</span>            <span class="comment"># with zero imaginary part for complex poles) I ended up summing</span></div>
<div class="line"><span class="lineno"> 3321</span>            <span class="comment"># all vectors in ker_pole_j, this solves 100% of the problems and</span></div>
<div class="line"><span class="lineno"> 3322</span>            <span class="comment"># is a valid choice for transfer_matrix.</span></div>
<div class="line"><span class="lineno"> 3323</span>            <span class="comment"># This way for complex poles we are sure to have a non zero</span></div>
<div class="line"><span class="lineno"> 3324</span>            <span class="comment"># imaginary part that way, and the problem of lines full of zeros</span></div>
<div class="line"><span class="lineno"> 3325</span>            <span class="comment"># in transfer_matrix is solved too as when a vector from</span></div>
<div class="line"><span class="lineno"> 3326</span>            <span class="comment"># ker_pole_j has a zero the other one(s) when</span></div>
<div class="line"><span class="lineno"> 3327</span>            <span class="comment"># ker_pole_j.shape[1]&gt;1) for sure won&#39;t have a zero there.</span></div>
<div class="line"><span class="lineno"> 3328</span> </div>
<div class="line"><span class="lineno"> 3329</span>            transfer_matrix_j = np.sum(ker_pole_j, axis=1)[:, np.newaxis]</div>
<div class="line"><span class="lineno"> 3330</span>            transfer_matrix_j = (transfer_matrix_j /</div>
<div class="line"><span class="lineno"> 3331</span>                                 np.linalg.norm(transfer_matrix_j))</div>
<div class="line"><span class="lineno"> 3332</span>            <span class="keywordflow">if</span> ~np.isreal(poles[j]):  <span class="comment"># complex pole</span></div>
<div class="line"><span class="lineno"> 3333</span>                transfer_matrix_j = np.hstack([np.real(transfer_matrix_j),</div>
<div class="line"><span class="lineno"> 3334</span>                                               np.imag(transfer_matrix_j)])</div>
<div class="line"><span class="lineno"> 3335</span>                ker_pole.extend([ker_pole_j, ker_pole_j])</div>
<div class="line"><span class="lineno"> 3336</span> </div>
<div class="line"><span class="lineno"> 3337</span>                <span class="comment"># Skip next pole as it is the conjugate</span></div>
<div class="line"><span class="lineno"> 3338</span>                skip_conjugate = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3339</span>            <span class="keywordflow">else</span>:  <span class="comment"># real pole, nothing to do</span></div>
<div class="line"><span class="lineno"> 3340</span>                ker_pole.append(ker_pole_j)</div>
<div class="line"><span class="lineno"> 3341</span> </div>
<div class="line"><span class="lineno"> 3342</span>            <span class="keywordflow">if</span> j == 0:</div>
<div class="line"><span class="lineno"> 3343</span>                transfer_matrix = transfer_matrix_j</div>
<div class="line"><span class="lineno"> 3344</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3345</span>                transfer_matrix = np.hstack((transfer_matrix, transfer_matrix_j))</div>
<div class="line"><span class="lineno"> 3346</span> </div>
<div class="line"><span class="lineno"> 3347</span>        <span class="keywordflow">if</span> rankB &gt; 1:  <span class="comment"># otherwise there is nothing we can optimize</span></div>
<div class="line"><span class="lineno"> 3348</span>            stop, cur_rtol, nb_iter = update_loop(ker_pole, transfer_matrix,</div>
<div class="line"><span class="lineno"> 3349</span>                                                  poles, B, maxiter, rtol)</div>
<div class="line"><span class="lineno"> 3350</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> stop <span class="keywordflow">and</span> rtol &gt; 0:</div>
<div class="line"><span class="lineno"> 3351</span>                <span class="comment"># if rtol&lt;=0 the user has probably done that on purpose,</span></div>
<div class="line"><span class="lineno"> 3352</span>                <span class="comment"># don&#39;t annoy him</span></div>
<div class="line"><span class="lineno"> 3353</span>                err_msg = (</div>
<div class="line"><span class="lineno"> 3354</span>                    <span class="stringliteral">&quot;Convergence was not reached after maxiter iterations.\n&quot;</span></div>
<div class="line"><span class="lineno"> 3355</span>                    <span class="stringliteral">&quot;You asked for a relative tolerance of %f we got %f&quot;</span> %</div>
<div class="line"><span class="lineno"> 3356</span>                    (rtol, cur_rtol)</div>
<div class="line"><span class="lineno"> 3357</span>                    )</div>
<div class="line"><span class="lineno"> 3358</span>                warnings.warn(err_msg)</div>
<div class="line"><span class="lineno"> 3359</span> </div>
<div class="line"><span class="lineno"> 3360</span>        <span class="comment"># reconstruct transfer_matrix to match complex conjugate pairs,</span></div>
<div class="line"><span class="lineno"> 3361</span>        <span class="comment"># ie transfer_matrix_j/transfer_matrix_j+1 are</span></div>
<div class="line"><span class="lineno"> 3362</span>        <span class="comment"># Re(Complex_pole), Im(Complex_pole) now and will be Re-Im/Re+Im after</span></div>
<div class="line"><span class="lineno"> 3363</span>        transfer_matrix = transfer_matrix.astype(complex)</div>
<div class="line"><span class="lineno"> 3364</span>        idx = 0</div>
<div class="line"><span class="lineno"> 3365</span>        <span class="keywordflow">while</span> idx &lt; poles.shape[0]-1:</div>
<div class="line"><span class="lineno"> 3366</span>            <span class="keywordflow">if</span> ~np.isreal(poles[idx]):</div>
<div class="line"><span class="lineno"> 3367</span>                rel = transfer_matrix[:, idx].copy()</div>
<div class="line"><span class="lineno"> 3368</span>                img = transfer_matrix[:, idx+1]</div>
<div class="line"><span class="lineno"> 3369</span>                <span class="comment"># rel will be an array referencing a column of transfer_matrix</span></div>
<div class="line"><span class="lineno"> 3370</span>                <span class="comment"># if we don&#39;t copy() it will changer after the next line and</span></div>
<div class="line"><span class="lineno"> 3371</span>                <span class="comment"># and the line after will not yield the correct value</span></div>
<div class="line"><span class="lineno"> 3372</span>                transfer_matrix[:, idx] = rel-1j*img</div>
<div class="line"><span class="lineno"> 3373</span>                transfer_matrix[:, idx+1] = rel+1j*img</div>
<div class="line"><span class="lineno"> 3374</span>                idx += 1  <span class="comment"># skip next one</span></div>
<div class="line"><span class="lineno"> 3375</span>            idx += 1</div>
<div class="line"><span class="lineno"> 3376</span> </div>
<div class="line"><span class="lineno"> 3377</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3378</span>            m = np.linalg.solve(transfer_matrix.T, np.dot(np.diag(poles),</div>
<div class="line"><span class="lineno"> 3379</span>                                                          transfer_matrix.T)).T</div>
<div class="line"><span class="lineno"> 3380</span>            gain_matrix = np.linalg.solve(z, np.dot(u0.T, m-A))</div>
<div class="line"><span class="lineno"> 3381</span>        <span class="keywordflow">except</span> np.linalg.LinAlgError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 3382</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The poles you&#39;ve chosen can&#39;t be placed. &quot;</span></div>
<div class="line"><span class="lineno"> 3383</span>                             <span class="stringliteral">&quot;Check the controllability matrix and try &quot;</span></div>
<div class="line"><span class="lineno"> 3384</span>                             <span class="stringliteral">&quot;another set of poles&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 3385</span> </div>
<div class="line"><span class="lineno"> 3386</span>    <span class="comment"># Beware: Kautsky solves A+BK but the usual form is A-BK</span></div>
<div class="line"><span class="lineno"> 3387</span>    gain_matrix = -gain_matrix</div>
<div class="line"><span class="lineno"> 3388</span>    <span class="comment"># K still contains complex with ~=0j imaginary parts, get rid of them</span></div>
<div class="line"><span class="lineno"> 3389</span>    gain_matrix = np.real(gain_matrix)</div>
<div class="line"><span class="lineno"> 3390</span> </div>
<div class="line"><span class="lineno"> 3391</span>    full_state_feedback = Bunch()</div>
<div class="line"><span class="lineno"> 3392</span>    full_state_feedback.gain_matrix = gain_matrix</div>
<div class="line"><span class="lineno"> 3393</span>    full_state_feedback.computed_poles = _order_complex_poles(</div>
<div class="line"><span class="lineno"> 3394</span>        np.linalg.eig(A - np.dot(B, gain_matrix))[0]</div>
<div class="line"><span class="lineno"> 3395</span>        )</div>
<div class="line"><span class="lineno"> 3396</span>    full_state_feedback.requested_poles = poles</div>
<div class="line"><span class="lineno"> 3397</span>    full_state_feedback.X = transfer_matrix</div>
<div class="line"><span class="lineno"> 3398</span>    full_state_feedback.rtol = cur_rtol</div>
<div class="line"><span class="lineno"> 3399</span>    full_state_feedback.nb_iter = nb_iter</div>
<div class="line"><span class="lineno"> 3400</span> </div>
<div class="line"><span class="lineno"> 3401</span>    <span class="keywordflow">return</span> full_state_feedback</div>
<div class="line"><span class="lineno"> 3402</span> </div>
<div class="line"><span class="lineno"> 3403</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a531d2c4ab049182357f13971cf8e58e5" name="a531d2c4ab049182357f13971cf8e58e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531d2c4ab049182357f13971cf8e58e5">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.step </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Step response of continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector (default is zero).
T : array_like, optional
    Time points (computed if not given).
N : int, optional
    Number of time points to compute if `T` is not given.

Returns
-------
T : 1D ndarray
    Output time points.
yout : 1D ndarray
    Step response of system.

See also
--------
scipy.signal.step2

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; lti = signal.lti([1.0], [1.0, 1.0])
&gt;&gt;&gt; t, y = signal.step(lti)
&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.xlabel('Time [s]')
&gt;&gt;&gt; plt.ylabel('Amplitude')
&gt;&gt;&gt; plt.title('Step response for 1. Order Lowpass')
&gt;&gt;&gt; plt.grid()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2363</span><span class="keyword">def </span>step(system, X0=None, T=None, N=None):</div>
<div class="line"><span class="lineno"> 2364</span>    <span class="stringliteral">&quot;&quot;&quot;Step response of continuous-time system.</span></div>
<div class="line"><span class="lineno"> 2365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2366</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2367</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2368</span><span class="stringliteral">    system : an instance of the LTI class or a tuple of array_like</span></div>
<div class="line"><span class="lineno"> 2369</span><span class="stringliteral">        describing the system.</span></div>
<div class="line"><span class="lineno"> 2370</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 2371</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 2372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2373</span><span class="stringliteral">            * 1 (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 2374</span><span class="stringliteral">            * 2 (num, den)</span></div>
<div class="line"><span class="lineno"> 2375</span><span class="stringliteral">            * 3 (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 2376</span><span class="stringliteral">            * 4 (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 2377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2378</span><span class="stringliteral">    X0 : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2379</span><span class="stringliteral">        Initial state-vector (default is zero).</span></div>
<div class="line"><span class="lineno"> 2380</span><span class="stringliteral">    T : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2381</span><span class="stringliteral">        Time points (computed if not given).</span></div>
<div class="line"><span class="lineno"> 2382</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 2383</span><span class="stringliteral">        Number of time points to compute if `T` is not given.</span></div>
<div class="line"><span class="lineno"> 2384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2387</span><span class="stringliteral">    T : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2388</span><span class="stringliteral">        Output time points.</span></div>
<div class="line"><span class="lineno"> 2389</span><span class="stringliteral">    yout : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2390</span><span class="stringliteral">        Step response of system.</span></div>
<div class="line"><span class="lineno"> 2391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2392</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno"> 2393</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2394</span><span class="stringliteral">    scipy.signal.step2</span></div>
<div class="line"><span class="lineno"> 2395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">    &gt;&gt;&gt; lti = signal.lti([1.0], [1.0, 1.0])</span></div>
<div class="line"><span class="lineno"> 2407</span><span class="stringliteral">    &gt;&gt;&gt; t, y = signal.step(lti)</span></div>
<div class="line"><span class="lineno"> 2408</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y)</span></div>
<div class="line"><span class="lineno"> 2409</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [s]&#39;)</span></div>
<div class="line"><span class="lineno"> 2410</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 2411</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&#39;Step response for 1. Order Lowpass&#39;)</span></div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid()</span></div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2415</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 2416</span>        sys = system._as_ss()</div>
<div class="line"><span class="lineno"> 2417</span>    <span class="keywordflow">elif</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 2418</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;step can only be used with continuous-time &#39;</span></div>
<div class="line"><span class="lineno"> 2419</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2420</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2421</span>        sys = lti(*system)._as_ss()</div>
<div class="line"><span class="lineno"> 2422</span>    <span class="keywordflow">if</span> N <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2423</span>        N = 100</div>
<div class="line"><span class="lineno"> 2424</span>    <span class="keywordflow">if</span> T <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2425</span>        T = _default_response_times(sys.A, N)</div>
<div class="line"><span class="lineno"> 2426</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2427</span>        T = asarray(T)</div>
<div class="line"><span class="lineno"> 2428</span>    U = ones(T.shape, sys.A.dtype)</div>
<div class="line"><span class="lineno"> 2429</span>    vals = lsim(sys, U, T, X0=X0, interp=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2430</span>    <span class="keywordflow">return</span> vals[0], vals[1]</div>
<div class="line"><span class="lineno"> 2431</span> </div>
<div class="line"><span class="lineno"> 2432</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a14d583450772b85b02f687c6b097ebe7" name="a14d583450772b85b02f687c6b097ebe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d583450772b85b02f687c6b097ebe7">&#9670;&#160;</a></span>step2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.step2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X0</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Step response of continuous-time system.

This function is functionally the same as `scipy.signal.step`, but
it uses the function `scipy.signal.lsim2` to compute the step
response.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector (default is zero).
T : array_like, optional
    Time points (computed if not given).
N : int, optional
    Number of time points to compute if `T` is not given.
kwargs : various types
    Additional keyword arguments are passed on the function
    `scipy.signal.lsim2`, which in turn passes them on to
    `scipy.integrate.odeint`.  See the documentation for
    `scipy.integrate.odeint` for information about these arguments.

Returns
-------
T : 1D ndarray
    Output time points.
yout : 1D ndarray
    Step response of system.

See also
--------
scipy.signal.step

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; lti = signal.lti([1.0], [1.0, 1.0])
&gt;&gt;&gt; t, y = signal.step2(lti)
&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.xlabel('Time [s]')
&gt;&gt;&gt; plt.ylabel('Amplitude')
&gt;&gt;&gt; plt.title('Step response for 1. Order Lowpass')
&gt;&gt;&gt; plt.grid()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2433</span><span class="keyword">def </span>step2(system, X0=None, T=None, N=None, **kwargs):</div>
<div class="line"><span class="lineno"> 2434</span>    <span class="stringliteral">&quot;&quot;&quot;Step response of continuous-time system.</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">    This function is functionally the same as `scipy.signal.step`, but</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">    it uses the function `scipy.signal.lsim2` to compute the step</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">    response.</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">    system : an instance of the LTI class or a tuple of array_like</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">        describing the system.</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral">        The following gives the number of elements in the tuple and</span></div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">        the interpretation:</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">            * 1 (instance of `lti`)</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral">            * 2 (num, den)</span></div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">            * 3 (zeros, poles, gain)</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">            * 4 (A, B, C, D)</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">    X0 : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">        Initial state-vector (default is zero).</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">    T : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">        Time points (computed if not given).</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral">        Number of time points to compute if `T` is not given.</span></div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">    kwargs : various types</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">        Additional keyword arguments are passed on the function</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral">        `scipy.signal.lsim2`, which in turn passes them on to</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">        `scipy.integrate.odeint`.  See the documentation for</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral">        `scipy.integrate.odeint` for information about these arguments.</span></div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral">    T : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral">        Output time points.</span></div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral">    yout : 1D ndarray</span></div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">        Step response of system.</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">    scipy.signal.step</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral">    If (num, den) is passed in for ``system``, coefficients for both the</span></div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">    numerator and denominator should be specified in descending exponent</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">    .. versionadded:: 0.8.0</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    &gt;&gt;&gt; lti = signal.lti([1.0], [1.0, 1.0])</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">    &gt;&gt;&gt; t, y = signal.step2(lti)</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y)</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time [s]&#39;)</span></div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&#39;Step response for 1. Order Lowpass&#39;)</span></div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid()</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2496</span>    <span class="keywordflow">if</span> isinstance(system, lti):</div>
<div class="line"><span class="lineno"> 2497</span>        sys = system._as_ss()</div>
<div class="line"><span class="lineno"> 2498</span>    <span class="keywordflow">elif</span> isinstance(system, dlti):</div>
<div class="line"><span class="lineno"> 2499</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;step2 can only be used with continuous-time &#39;</span></div>
<div class="line"><span class="lineno"> 2500</span>                             <span class="stringliteral">&#39;systems.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2501</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2502</span>        sys = lti(*system)._as_ss()</div>
<div class="line"><span class="lineno"> 2503</span>    <span class="keywordflow">if</span> N <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2504</span>        N = 100</div>
<div class="line"><span class="lineno"> 2505</span>    <span class="keywordflow">if</span> T <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2506</span>        T = _default_response_times(sys.A, N)</div>
<div class="line"><span class="lineno"> 2507</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2508</span>        T = asarray(T)</div>
<div class="line"><span class="lineno"> 2509</span>    U = ones(T.shape, sys.A.dtype)</div>
<div class="line"><span class="lineno"> 2510</span>    vals = lsim2(sys, U, T, X0=X0, **kwargs)</div>
<div class="line"><span class="lineno"> 2511</span>    <span class="keywordflow">return</span> vals[0], vals[1]</div>
<div class="line"><span class="lineno"> 2512</span> </div>
<div class="line"><span class="lineno"> 2513</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
