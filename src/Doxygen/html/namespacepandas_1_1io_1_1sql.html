<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.io.sql Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1io.html">io</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1io_1_1sql.html">sql</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.io.sql Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1sql_1_1_base_engine.html">BaseEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1sql_1_1_pandas_s_q_l.html">PandasSQL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_l_alchemy_engine.html">SQLAlchemyEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_l_database.html">SQLDatabase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_lite_database.html">SQLiteDatabase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_lite_table.html">SQLiteTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_l_table.html">SQLTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3ff5c67f1738188078cda1b4d8fc020c" id="r_a3ff5c67f1738188078cda1b4d8fc020c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a3ff5c67f1738188078cda1b4d8fc020c">_convert_params</a> (sql, params)</td></tr>
<tr class="separator:a3ff5c67f1738188078cda1b4d8fc020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43da01ce3b7a8e882bab2bf30f1e90e" id="r_aa43da01ce3b7a8e882bab2bf30f1e90e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#aa43da01ce3b7a8e882bab2bf30f1e90e">_process_parse_dates_argument</a> (parse_dates)</td></tr>
<tr class="separator:aa43da01ce3b7a8e882bab2bf30f1e90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91148364d9654f813440474711f171e7" id="r_a91148364d9654f813440474711f171e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a91148364d9654f813440474711f171e7">_handle_date_column</a> (col, bool|None utc=None, str|dict[str, Any]|None format=None)</td></tr>
<tr class="separator:a91148364d9654f813440474711f171e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb6491889e8ad545988d2e392fcd5e8" id="r_a3cb6491889e8ad545988d2e392fcd5e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a3cb6491889e8ad545988d2e392fcd5e8">_parse_date_columns</a> (data_frame, parse_dates)</td></tr>
<tr class="separator:a3cb6491889e8ad545988d2e392fcd5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdc2ba7383580ec80f21088e0dafeaa" id="r_accdc2ba7383580ec80f21088e0dafeaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#accdc2ba7383580ec80f21088e0dafeaa">_wrap_result</a> (data, columns, index_col=None, bool coerce_float=True, parse_dates=None, DtypeArg|None dtype=None)</td></tr>
<tr class="separator:accdc2ba7383580ec80f21088e0dafeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba42e94abda0c7396e30e5192e7d651" id="r_aeba42e94abda0c7396e30e5192e7d651"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#aeba42e94abda0c7396e30e5192e7d651">execute</a> (sql, con, params=None)</td></tr>
<tr class="separator:aeba42e94abda0c7396e30e5192e7d651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4a6db14c6b11072aa08e0c11746705" id="r_a3e4a6db14c6b11072aa08e0c11746705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a3e4a6db14c6b11072aa08e0c11746705">read_sql_table</a> (table_name, con, schema=..., str|list[str]|None index_col=..., coerce_float=..., list[str]|dict[str, str]|None parse_dates=..., list[str]|None columns=..., None chunksize=...)</td></tr>
<tr class="separator:a3e4a6db14c6b11072aa08e0c11746705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c08c534969db426edfec7d5c47422df" id="r_a4c08c534969db426edfec7d5c47422df"><td class="memItemLeft" align="right" valign="top">Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a4c08c534969db426edfec7d5c47422df">read_sql_table</a> (table_name, con, schema=..., str|list[str]|None index_col=..., coerce_float=..., list[str]|dict[str, str]|None parse_dates=..., list[str]|None columns=..., int chunksize=...)</td></tr>
<tr class="separator:a4c08c534969db426edfec7d5c47422df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5e3a7d894a929956048836c1b1d9f5" id="r_a9c5e3a7d894a929956048836c1b1d9f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a9c5e3a7d894a929956048836c1b1d9f5">read_sql_table</a> (str table_name, con, str|None schema=None, str|list[str]|None index_col=None, bool coerce_float=True, list[str]|dict[str, str]|None parse_dates=None, list[str]|None columns=None, int|None chunksize=None)</td></tr>
<tr class="separator:a9c5e3a7d894a929956048836c1b1d9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a25e74a8ef0650fdd972a37c4564544" id="r_a5a25e74a8ef0650fdd972a37c4564544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a5a25e74a8ef0650fdd972a37c4564544">read_sql_query</a> (sql, con, str|list[str]|None index_col=..., coerce_float=..., list[str]|dict[str, str]|None params=..., list[str]|dict[str, str]|None parse_dates=..., None chunksize=..., DtypeArg|None dtype=...)</td></tr>
<tr class="separator:a5a25e74a8ef0650fdd972a37c4564544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e28c0667df0dd7ae5dc3fc7ebb296f" id="r_a46e28c0667df0dd7ae5dc3fc7ebb296f"><td class="memItemLeft" align="right" valign="top">Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a46e28c0667df0dd7ae5dc3fc7ebb296f">read_sql_query</a> (sql, con, str|list[str]|None index_col=..., coerce_float=..., list[str]|dict[str, str]|None params=..., list[str]|dict[str, str]|None parse_dates=..., int chunksize=..., DtypeArg|None dtype=...)</td></tr>
<tr class="separator:a46e28c0667df0dd7ae5dc3fc7ebb296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7106369a854aada61a1ae9c5085ccff" id="r_ab7106369a854aada61a1ae9c5085ccff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#ab7106369a854aada61a1ae9c5085ccff">read_sql_query</a> (sql, con, str|list[str]|None index_col=None, bool coerce_float=True, list[str]|dict[str, str]|None params=None, list[str]|dict[str, str]|None parse_dates=None, int|None chunksize=None, DtypeArg|None dtype=None)</td></tr>
<tr class="separator:ab7106369a854aada61a1ae9c5085ccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab455c75e0d04c53cb99e08db92509c2d" id="r_ab455c75e0d04c53cb99e08db92509c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#ab455c75e0d04c53cb99e08db92509c2d">read_sql</a> (sql, con, str|list[str]|None index_col=..., coerce_float=..., params=..., parse_dates=..., list[str] columns=..., None chunksize=...)</td></tr>
<tr class="separator:ab455c75e0d04c53cb99e08db92509c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2ac5260273dd561e7d8bced5ceedcd" id="r_acc2ac5260273dd561e7d8bced5ceedcd"><td class="memItemLeft" align="right" valign="top">Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#acc2ac5260273dd561e7d8bced5ceedcd">read_sql</a> (sql, con, str|list[str]|None index_col=..., coerce_float=..., params=..., parse_dates=..., list[str] columns=..., int chunksize=...)</td></tr>
<tr class="separator:acc2ac5260273dd561e7d8bced5ceedcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0a6831bc3160fccf112128c3c7d1fc" id="r_a8e0a6831bc3160fccf112128c3c7d1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a8e0a6831bc3160fccf112128c3c7d1fc">read_sql</a> (sql, con, str|list[str]|None index_col=None, bool coerce_float=True, params=None, parse_dates=None, list[str]|None columns=None, int|None chunksize=None)</td></tr>
<tr class="separator:a8e0a6831bc3160fccf112128c3c7d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7770a6d779acf18aeade328d2a2cbd2c" id="r_a7770a6d779acf18aeade328d2a2cbd2c"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a7770a6d779acf18aeade328d2a2cbd2c">to_sql</a> (frame, str name, con, str|None schema=None, str if_exists=&quot;fail&quot;, bool index=True, IndexLabel index_label=None, int|None chunksize=None, DtypeArg|None dtype=None, str|None method=None, str engine=&quot;auto&quot;, **engine_kwargs)</td></tr>
<tr class="separator:a7770a6d779acf18aeade328d2a2cbd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481d992f90af2849fdc44ae80127e13f" id="r_a481d992f90af2849fdc44ae80127e13f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a481d992f90af2849fdc44ae80127e13f">has_table</a> (str table_name, con, str|None schema=None)</td></tr>
<tr class="separator:a481d992f90af2849fdc44ae80127e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc7372768ca26cb5386ff0b6c667e3" id="r_a25cc7372768ca26cb5386ff0b6c667e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_l_database.html">SQLDatabase</a>|<a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_lite_database.html">SQLiteDatabase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a25cc7372768ca26cb5386ff0b6c667e3">pandasSQL_builder</a> (con, str|None schema=None)</td></tr>
<tr class="separator:a25cc7372768ca26cb5386ff0b6c667e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215b5bf10d7ec240725cb0439f6d8ad0" id="r_a215b5bf10d7ec240725cb0439f6d8ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1io_1_1sql_1_1_base_engine.html">BaseEngine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a215b5bf10d7ec240725cb0439f6d8ad0">get_engine</a> (str engine)</td></tr>
<tr class="separator:a215b5bf10d7ec240725cb0439f6d8ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ed55df37f9beb31d83f99fe4211e84" id="r_a82ed55df37f9beb31d83f99fe4211e84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a82ed55df37f9beb31d83f99fe4211e84">_get_unicode_name</a> (name)</td></tr>
<tr class="separator:a82ed55df37f9beb31d83f99fe4211e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae423e7ba262beea0310f17c874676ff2" id="r_ae423e7ba262beea0310f17c874676ff2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#ae423e7ba262beea0310f17c874676ff2">_get_valid_sqlite_name</a> (name)</td></tr>
<tr class="separator:ae423e7ba262beea0310f17c874676ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0244b565d56f904bc774fcd553cc9bf6" id="r_a0244b565d56f904bc774fcd553cc9bf6"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a0244b565d56f904bc774fcd553cc9bf6">get_schema</a> (frame, str name, keys=None, con=None, DtypeArg|None dtype=None, str|None schema=None)</td></tr>
<tr class="separator:a0244b565d56f904bc774fcd553cc9bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa7cfd1d87ee3e84467f1437462970a29" id="r_aa7cfd1d87ee3e84467f1437462970a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#aa7cfd1d87ee3e84467f1437462970a29">table_exists</a> = <a class="el" href="namespacepandas_1_1io_1_1sql.html#a481d992f90af2849fdc44ae80127e13f">has_table</a></td></tr>
<tr class="separator:aa7cfd1d87ee3e84467f1437462970a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe412bc2640a94db1e0989b222767ed" id="r_a6fe412bc2640a94db1e0989b222767ed"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1sql.html#a6fe412bc2640a94db1e0989b222767ed">_SQL_TYPES</a></td></tr>
<tr class="separator:a6fe412bc2640a94db1e0989b222767ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Collection of query wrappers / abstractions to both facilitate data
retrieval and to reduce dependency on DB-specific API.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a3ff5c67f1738188078cda1b4d8fc020c" name="a3ff5c67f1738188078cda1b4d8fc020c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff5c67f1738188078cda1b4d8fc020c">&#9670;&#160;</a></span>_convert_params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql._convert_params </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert SQL and params args to DBAPI2.0 compliant format.</pre> <div class="fragment"><div class="line"><span class="lineno">   66</span><span class="keyword">def </span>_convert_params(sql, params):</div>
<div class="line"><span class="lineno">   67</span>    <span class="stringliteral">&quot;&quot;&quot;Convert SQL and params args to DBAPI2.0 compliant format.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   68</span>    args = [sql]</div>
<div class="line"><span class="lineno">   69</span>    <span class="keywordflow">if</span> params <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   70</span>        <span class="keywordflow">if</span> hasattr(params, <span class="stringliteral">&quot;keys&quot;</span>):  <span class="comment"># test if params is a mapping</span></div>
<div class="line"><span class="lineno">   71</span>            args += [params]</div>
<div class="line"><span class="lineno">   72</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   73</span>            args += [list(params)]</div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">return</span> args</div>
<div class="line"><span class="lineno">   75</span> </div>
<div class="line"><span class="lineno">   76</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a82ed55df37f9beb31d83f99fe4211e84" name="a82ed55df37f9beb31d83f99fe4211e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ed55df37f9beb31d83f99fe4211e84">&#9670;&#160;</a></span>_get_unicode_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql._get_unicode_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1819</span><span class="keyword">def </span>_get_unicode_name(name):</div>
<div class="line"><span class="lineno"> 1820</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1821</span>        uname = str(name).encode(<span class="stringliteral">&quot;utf-8&quot;</span>, <span class="stringliteral">&quot;strict&quot;</span>).decode(<span class="stringliteral">&quot;utf-8&quot;</span>)</div>
<div class="line"><span class="lineno"> 1822</span>    <span class="keywordflow">except</span> UnicodeError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1823</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Cannot convert identifier to UTF-8: &#39;{name}&#39;&quot;</span>) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 1824</span>    <span class="keywordflow">return</span> uname</div>
<div class="line"><span class="lineno"> 1825</span> </div>
<div class="line"><span class="lineno"> 1826</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae423e7ba262beea0310f17c874676ff2" name="ae423e7ba262beea0310f17c874676ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae423e7ba262beea0310f17c874676ff2">&#9670;&#160;</a></span>_get_valid_sqlite_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql._get_valid_sqlite_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1827</span><span class="keyword">def </span>_get_valid_sqlite_name(name):</div>
<div class="line"><span class="lineno"> 1828</span>    <span class="comment"># See https://stackoverflow.com/questions/6514274/how-do-you-escape-strings\</span></div>
<div class="line"><span class="lineno"> 1829</span>    <span class="comment"># -for-sqlite-table-column-names-in-python</span></div>
<div class="line"><span class="lineno"> 1830</span>    <span class="comment"># Ensure the string can be encoded as UTF-8.</span></div>
<div class="line"><span class="lineno"> 1831</span>    <span class="comment"># Ensure the string does not include any NUL characters.</span></div>
<div class="line"><span class="lineno"> 1832</span>    <span class="comment"># Replace all &quot; with &quot;&quot;.</span></div>
<div class="line"><span class="lineno"> 1833</span>    <span class="comment"># Wrap the entire thing in double quotes.</span></div>
<div class="line"><span class="lineno"> 1834</span> </div>
<div class="line"><span class="lineno"> 1835</span>    uname = _get_unicode_name(name)</div>
<div class="line"><span class="lineno"> 1836</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(uname):</div>
<div class="line"><span class="lineno"> 1837</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Empty table or column name specified&quot;</span>)</div>
<div class="line"><span class="lineno"> 1838</span> </div>
<div class="line"><span class="lineno"> 1839</span>    nul_index = uname.find(<span class="stringliteral">&quot;\x00&quot;</span>)</div>
<div class="line"><span class="lineno"> 1840</span>    <span class="keywordflow">if</span> nul_index &gt;= 0:</div>
<div class="line"><span class="lineno"> 1841</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;SQLite identifier cannot contain NULs&quot;</span>)</div>
<div class="line"><span class="lineno"> 1842</span>    <span class="keywordflow">return</span> <span class="stringliteral">&#39;&quot;&#39;</span> + uname.replace(<span class="stringliteral">&#39;&quot;&#39;</span>, <span class="stringliteral">&#39;&quot;&quot;&#39;</span>) + <span class="stringliteral">&#39;&quot;&#39;</span></div>
<div class="line"><span class="lineno"> 1843</span> </div>
<div class="line"><span class="lineno"> 1844</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a91148364d9654f813440474711f171e7" name="a91148364d9654f813440474711f171e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91148364d9654f813440474711f171e7">&#9670;&#160;</a></span>_handle_date_column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql._handle_date_column </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>utc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | dict[str, Any] | None &#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   90</span>):</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">if</span> isinstance(format, dict):</div>
<div class="line"><span class="lineno">   92</span>        <span class="comment"># GH35185 Allow custom error values in parse_dates argument of</span></div>
<div class="line"><span class="lineno">   93</span>        <span class="comment"># read_sql like functions.</span></div>
<div class="line"><span class="lineno">   94</span>        <span class="comment"># Format can take on custom to_datetime argument values such as</span></div>
<div class="line"><span class="lineno">   95</span>        <span class="comment"># {&quot;errors&quot;: &quot;coerce&quot;} or {&quot;dayfirst&quot;: True}</span></div>
<div class="line"><span class="lineno">   96</span>        error: DateTimeErrorChoices = format.pop(<span class="stringliteral">&quot;errors&quot;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">or</span> <span class="stringliteral">&quot;ignore&quot;</span></div>
<div class="line"><span class="lineno">   97</span>        <span class="keywordflow">return</span> to_datetime(col, errors=error, **format)</div>
<div class="line"><span class="lineno">   98</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   99</span>        <span class="comment"># Allow passing of formatting string for integers</span></div>
<div class="line"><span class="lineno">  100</span>        <span class="comment"># GH17855</span></div>
<div class="line"><span class="lineno">  101</span>        <span class="keywordflow">if</span> format <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno">  102</span>            issubclass(col.dtype.type, np.floating)</div>
<div class="line"><span class="lineno">  103</span>            <span class="keywordflow">or</span> issubclass(col.dtype.type, np.integer)</div>
<div class="line"><span class="lineno">  104</span>        ):</div>
<div class="line"><span class="lineno">  105</span>            format = <span class="stringliteral">&quot;s&quot;</span></div>
<div class="line"><span class="lineno">  106</span>        <span class="keywordflow">if</span> format <span class="keywordflow">in</span> [<span class="stringliteral">&quot;D&quot;</span>, <span class="stringliteral">&quot;d&quot;</span>, <span class="stringliteral">&quot;h&quot;</span>, <span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;s&quot;</span>, <span class="stringliteral">&quot;ms&quot;</span>, <span class="stringliteral">&quot;us&quot;</span>, <span class="stringliteral">&quot;ns&quot;</span>]:</div>
<div class="line"><span class="lineno">  107</span>            <span class="keywordflow">return</span> to_datetime(col, errors=<span class="stringliteral">&quot;coerce&quot;</span>, unit=format, utc=utc)</div>
<div class="line"><span class="lineno">  108</span>        <span class="keywordflow">elif</span> is_datetime64tz_dtype(col.dtype):</div>
<div class="line"><span class="lineno">  109</span>            <span class="comment"># coerce to UTC timezone</span></div>
<div class="line"><span class="lineno">  110</span>            <span class="comment"># GH11216</span></div>
<div class="line"><span class="lineno">  111</span>            <span class="keywordflow">return</span> to_datetime(col, utc=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  112</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  113</span>            <span class="keywordflow">return</span> to_datetime(col, errors=<span class="stringliteral">&quot;coerce&quot;</span>, format=format, utc=utc)</div>
<div class="line"><span class="lineno">  114</span> </div>
<div class="line"><span class="lineno">  115</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3cb6491889e8ad545988d2e392fcd5e8" name="a3cb6491889e8ad545988d2e392fcd5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb6491889e8ad545988d2e392fcd5e8">&#9670;&#160;</a></span>_parse_date_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql._parse_date_columns </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parse_dates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Force non-datetime columns to be read as such.
Supports both string formatted and integer timestamp columns.
</pre> <div class="fragment"><div class="line"><span class="lineno">  116</span><span class="keyword">def </span>_parse_date_columns(data_frame, parse_dates):</div>
<div class="line"><span class="lineno">  117</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    Force non-datetime columns to be read as such.</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    Supports both string formatted and integer timestamp columns.</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  121</span>    parse_dates = _process_parse_dates_argument(parse_dates)</div>
<div class="line"><span class="lineno">  122</span> </div>
<div class="line"><span class="lineno">  123</span>    <span class="comment"># we want to coerce datetime64_tz dtypes for now to UTC</span></div>
<div class="line"><span class="lineno">  124</span>    <span class="comment"># we could in theory do a &#39;nice&#39; conversion from a FixedOffset tz</span></div>
<div class="line"><span class="lineno">  125</span>    <span class="comment"># GH11216</span></div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">for</span> col_name, df_col <span class="keywordflow">in</span> data_frame.items():</div>
<div class="line"><span class="lineno">  127</span>        <span class="keywordflow">if</span> is_datetime64tz_dtype(df_col.dtype) <span class="keywordflow">or</span> col_name <span class="keywordflow">in</span> parse_dates:</div>
<div class="line"><span class="lineno">  128</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  129</span>                fmt = parse_dates[col_name]</div>
<div class="line"><span class="lineno">  130</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  131</span>                fmt = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  132</span>            data_frame[col_name] = _handle_date_column(df_col, format=fmt)</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordflow">return</span> data_frame</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa43da01ce3b7a8e882bab2bf30f1e90e" name="aa43da01ce3b7a8e882bab2bf30f1e90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43da01ce3b7a8e882bab2bf30f1e90e">&#9670;&#160;</a></span>_process_parse_dates_argument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql._process_parse_dates_argument </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parse_dates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Process parse_dates argument for read_sql functions</pre> <div class="fragment"><div class="line"><span class="lineno">   77</span><span class="keyword">def </span>_process_parse_dates_argument(parse_dates):</div>
<div class="line"><span class="lineno">   78</span>    <span class="stringliteral">&quot;&quot;&quot;Process parse_dates argument for read_sql functions&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   79</span>    <span class="comment"># handle non-list entries for parse_dates gracefully</span></div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">if</span> parse_dates <span class="keywordflow">is</span> <span class="keyword">True</span> <span class="keywordflow">or</span> parse_dates <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> parse_dates <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno">   81</span>        parse_dates = []</div>
<div class="line"><span class="lineno">   82</span> </div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> hasattr(parse_dates, <span class="stringliteral">&quot;__iter__&quot;</span>):</div>
<div class="line"><span class="lineno">   84</span>        parse_dates = [parse_dates]</div>
<div class="line"><span class="lineno">   85</span>    <span class="keywordflow">return</span> parse_dates</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="accdc2ba7383580ec80f21088e0dafeaa" name="accdc2ba7383580ec80f21088e0dafeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdc2ba7383580ec80f21088e0dafeaa">&#9670;&#160;</a></span>_wrap_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql._wrap_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index_col</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wrap result set of query in a DataFrame.</pre> <div class="fragment"><div class="line"><span class="lineno">  144</span>):</div>
<div class="line"><span class="lineno">  145</span>    <span class="stringliteral">&quot;&quot;&quot;Wrap result set of query in a DataFrame.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  146</span>    frame = DataFrame.from_records(data, columns=columns, coerce_float=coerce_float)</div>
<div class="line"><span class="lineno">  147</span> </div>
<div class="line"><span class="lineno">  148</span>    <span class="keywordflow">if</span> dtype:</div>
<div class="line"><span class="lineno">  149</span>        frame = frame.astype(dtype)</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>    frame = _parse_date_columns(frame, parse_dates)</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    <span class="keywordflow">if</span> index_col <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  154</span>        frame.set_index(index_col, inplace=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">return</span> frame</div>
<div class="line"><span class="lineno">  157</span> </div>
<div class="line"><span class="lineno">  158</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeba42e94abda0c7396e30e5192e7d651" name="aeba42e94abda0c7396e30e5192e7d651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba42e94abda0c7396e30e5192e7d651">&#9670;&#160;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.io.sql.execute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Execute the given SQL query using the provided connection object.

Parameters
----------
sql : string
    SQL query to be executed.
con : SQLAlchemy connectable(engine/connection) or sqlite3 connection
    Using SQLAlchemy makes it possible to use any DB supported by the
    library.
    If a DBAPI2 object, only sqlite3 is supported.
params : list or tuple, optional, default: None
    List of parameters to pass to execute method.

Returns
-------
Results Iterable
</pre> <div class="fragment"><div class="line"><span class="lineno">  159</span><span class="keyword">def </span>execute(sql, con, params=None):</div>
<div class="line"><span class="lineno">  160</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    Execute the given SQL query using the provided connection object.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    sql : string</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">        SQL query to be executed.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    con : SQLAlchemy connectable(engine/connection) or sqlite3 connection</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        Using SQLAlchemy makes it possible to use any DB supported by the</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        library.</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        If a DBAPI2 object, only sqlite3 is supported.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    params : list or tuple, optional, default: None</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        List of parameters to pass to execute method.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    Results Iterable</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  178</span>    pandas_sql = pandasSQL_builder(con)</div>
<div class="line"><span class="lineno">  179</span>    args = _convert_params(sql, params)</div>
<div class="line"><span class="lineno">  180</span>    <span class="keywordflow">return</span> pandas_sql.execute(*args)</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span> </div>
<div class="line"><span class="lineno">  183</span><span class="comment"># -----------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno">  184</span><span class="comment"># -- Read and write to DataFrames</span></div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a215b5bf10d7ec240725cb0439f6d8ad0" name="a215b5bf10d7ec240725cb0439f6d8ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215b5bf10d7ec240725cb0439f6d8ad0">&#9670;&#160;</a></span>get_engine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1io_1_1sql_1_1_base_engine.html">BaseEngine</a> pandas.io.sql.get_engine </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>engine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">return our implementation</pre> <div class="fragment"><div class="line"><span class="lineno"> 1338</span><span class="keyword">def </span>get_engine(engine: str) -&gt; BaseEngine:</div>
<div class="line"><span class="lineno"> 1339</span>    <span class="stringliteral">&quot;&quot;&quot;return our implementation&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1340</span>    <span class="keywordflow">if</span> engine == <span class="stringliteral">&quot;auto&quot;</span>:</div>
<div class="line"><span class="lineno"> 1341</span>        engine = get_option(<span class="stringliteral">&quot;io.sql.engine&quot;</span>)</div>
<div class="line"><span class="lineno"> 1342</span> </div>
<div class="line"><span class="lineno"> 1343</span>    <span class="keywordflow">if</span> engine == <span class="stringliteral">&quot;auto&quot;</span>:</div>
<div class="line"><span class="lineno"> 1344</span>        <span class="comment"># try engines in this order</span></div>
<div class="line"><span class="lineno"> 1345</span>        engine_classes = [SQLAlchemyEngine]</div>
<div class="line"><span class="lineno"> 1346</span> </div>
<div class="line"><span class="lineno"> 1347</span>        error_msgs = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1348</span>        <span class="keywordflow">for</span> engine_class <span class="keywordflow">in</span> engine_classes:</div>
<div class="line"><span class="lineno"> 1349</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1350</span>                <span class="keywordflow">return</span> engine_class()</div>
<div class="line"><span class="lineno"> 1351</span>            <span class="keywordflow">except</span> ImportError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1352</span>                error_msgs += <span class="stringliteral">&quot;\n - &quot;</span> + str(err)</div>
<div class="line"><span class="lineno"> 1353</span> </div>
<div class="line"><span class="lineno"> 1354</span>        <span class="keywordflow">raise</span> ImportError(</div>
<div class="line"><span class="lineno"> 1355</span>            <span class="stringliteral">&quot;Unable to find a usable engine; &quot;</span></div>
<div class="line"><span class="lineno"> 1356</span>            <span class="stringliteral">&quot;tried using: &#39;sqlalchemy&#39;.\n&quot;</span></div>
<div class="line"><span class="lineno"> 1357</span>            <span class="stringliteral">&quot;A suitable version of &quot;</span></div>
<div class="line"><span class="lineno"> 1358</span>            <span class="stringliteral">&quot;sqlalchemy is required for sql I/O &quot;</span></div>
<div class="line"><span class="lineno"> 1359</span>            <span class="stringliteral">&quot;support.\n&quot;</span></div>
<div class="line"><span class="lineno"> 1360</span>            <span class="stringliteral">&quot;Trying to import the above resulted in these errors:&quot;</span></div>
<div class="line"><span class="lineno"> 1361</span>            f<span class="stringliteral">&quot;{error_msgs}&quot;</span></div>
<div class="line"><span class="lineno"> 1362</span>        )</div>
<div class="line"><span class="lineno"> 1363</span> </div>
<div class="line"><span class="lineno"> 1364</span>    <span class="keywordflow">elif</span> engine == <span class="stringliteral">&quot;sqlalchemy&quot;</span>:</div>
<div class="line"><span class="lineno"> 1365</span>        <span class="keywordflow">return</span> SQLAlchemyEngine()</div>
<div class="line"><span class="lineno"> 1366</span> </div>
<div class="line"><span class="lineno"> 1367</span>    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;engine must be one of &#39;auto&#39;, &#39;sqlalchemy&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1368</span> </div>
<div class="line"><span class="lineno"> 1369</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0244b565d56f904bc774fcd553cc9bf6" name="a0244b565d56f904bc774fcd553cc9bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0244b565d56f904bc774fcd553cc9bf6">&#9670;&#160;</a></span>get_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str pandas.io.sql.get_schema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the SQL db table schema for the given frame.

Parameters
----------
frame : DataFrame
name : str
    name of SQL table
keys : string or sequence, default: None
    columns to use a primary key
con: an open SQL database connection object or a SQLAlchemy connectable
    Using SQLAlchemy makes it possible to use any DB supported by that
    library, default: None
    If a DBAPI2 object, only sqlite3 is supported.
dtype : dict of column name to SQL type, default None
    Optional specifying the datatype for columns. The SQL type should
    be a SQLAlchemy type, or a string for sqlite3 fallback connection.
schema: str, default: None
    Optional specifying the schema to be used in creating the table.

    .. versionadded:: 1.2.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2231</span>) -&gt; str:</div>
<div class="line"><span class="lineno"> 2232</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">    Get the SQL db table schema for the given frame.</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral">    frame : DataFrame</span></div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral">    name : str</span></div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">        name of SQL table</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral">    keys : string or sequence, default: None</span></div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">        columns to use a primary key</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">    con: an open SQL database connection object or a SQLAlchemy connectable</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">        Using SQLAlchemy makes it possible to use any DB supported by that</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">        library, default: None</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral">        If a DBAPI2 object, only sqlite3 is supported.</span></div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">    dtype : dict of column name to SQL type, default None</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">        Optional specifying the datatype for columns. The SQL type should</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">        be a SQLAlchemy type, or a string for sqlite3 fallback connection.</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral">    schema: str, default: None</span></div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral">        Optional specifying the schema to be used in creating the table.</span></div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral">        .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2254</span>    pandas_sql = pandasSQL_builder(con=con)</div>
<div class="line"><span class="lineno"> 2255</span>    <span class="keywordflow">return</span> pandas_sql._create_sql_schema(</div>
<div class="line"><span class="lineno"> 2256</span>        frame, name, keys=keys, dtype=dtype, schema=schema</div>
<div class="line"><span class="lineno"> 2257</span>    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a481d992f90af2849fdc44ae80127e13f" name="a481d992f90af2849fdc44ae80127e13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481d992f90af2849fdc44ae80127e13f">&#9670;&#160;</a></span>has_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.io.sql.has_table </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if DataBase has named table.

Parameters
----------
table_name: string
    Name of SQL table.
con: SQLAlchemy connectable(engine/connection) or sqlite3 DBAPI2 connection
    Using SQLAlchemy makes it possible to use any DB supported by that
    library.
    If a DBAPI2 object, only sqlite3 is supported.
schema : string, default None
    Name of SQL schema in database to write to (if database flavor supports
    this). If None, use default schema (default).

Returns
-------
boolean
</pre> <div class="fragment"><div class="line"><span class="lineno">  710</span><span class="keyword">def </span>has_table(table_name: str, con, schema: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>) -&gt; bool:</div>
<div class="line"><span class="lineno">  711</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    Check if DataBase has named table.</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    table_name: string</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        Name of SQL table.</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    con: SQLAlchemy connectable(engine/connection) or sqlite3 DBAPI2 connection</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        Using SQLAlchemy makes it possible to use any DB supported by that</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">        library.</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">        If a DBAPI2 object, only sqlite3 is supported.</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    schema : string, default None</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">        Name of SQL schema in database to write to (if database flavor supports</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">        this). If None, use default schema (default).</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    boolean</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  730</span>    pandas_sql = pandasSQL_builder(con, schema=schema)</div>
<div class="line"><span class="lineno">  731</span>    <span class="keywordflow">return</span> pandas_sql.has_table(table_name)</div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="line"><span class="lineno">  733</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a25cc7372768ca26cb5386ff0b6c667e3" name="a25cc7372768ca26cb5386ff0b6c667e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cc7372768ca26cb5386ff0b6c667e3">&#9670;&#160;</a></span>pandasSQL_builder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_l_database.html">SQLDatabase</a> | <a class="el" href="classpandas_1_1io_1_1sql_1_1_s_q_lite_database.html">SQLiteDatabase</a> pandas.io.sql.pandasSQL_builder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convenience function to return the correct PandasSQL subclass based on the
provided parameters.
</pre> <div class="fragment"><div class="line"><span class="lineno">  737</span><span class="keyword">def </span>pandasSQL_builder(con, schema: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>) -&gt; SQLDatabase | SQLiteDatabase:</div>
<div class="line"><span class="lineno">  738</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    Convenience function to return the correct PandasSQL subclass based on the</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    provided parameters.</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  742</span>    <span class="keyword">import</span> sqlite3</div>
<div class="line"><span class="lineno">  743</span>    <span class="keyword">import</span> warnings</div>
<div class="line"><span class="lineno">  744</span> </div>
<div class="line"><span class="lineno">  745</span>    <span class="keywordflow">if</span> isinstance(con, sqlite3.Connection) <span class="keywordflow">or</span> con <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  746</span>        <span class="keywordflow">return</span> SQLiteDatabase(con)</div>
<div class="line"><span class="lineno">  747</span> </div>
<div class="line"><span class="lineno">  748</span>    sqlalchemy = import_optional_dependency(<span class="stringliteral">&quot;sqlalchemy&quot;</span>, errors=<span class="stringliteral">&quot;ignore&quot;</span>)</div>
<div class="line"><span class="lineno">  749</span> </div>
<div class="line"><span class="lineno">  750</span>    <span class="keywordflow">if</span> isinstance(con, str):</div>
<div class="line"><span class="lineno">  751</span>        <span class="keywordflow">if</span> sqlalchemy <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  752</span>            <span class="keywordflow">raise</span> ImportError(<span class="stringliteral">&quot;Using URI string without sqlalchemy installed.&quot;</span>)</div>
<div class="line"><span class="lineno">  753</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  754</span>            con = sqlalchemy.create_engine(con)</div>
<div class="line"><span class="lineno">  755</span> </div>
<div class="line"><span class="lineno">  756</span>    <span class="keywordflow">if</span> sqlalchemy <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> isinstance(con, sqlalchemy.engine.Connectable):</div>
<div class="line"><span class="lineno">  757</span>        <span class="keywordflow">return</span> SQLDatabase(con, schema=schema)</div>
<div class="line"><span class="lineno">  758</span> </div>
<div class="line"><span class="lineno">  759</span>    warnings.warn(</div>
<div class="line"><span class="lineno">  760</span>        <span class="stringliteral">&quot;pandas only supports SQLAlchemy connectable (engine/connection) or &quot;</span></div>
<div class="line"><span class="lineno">  761</span>        <span class="stringliteral">&quot;database string URI or sqlite3 DBAPI2 connection. &quot;</span></div>
<div class="line"><span class="lineno">  762</span>        <span class="stringliteral">&quot;Other DBAPI2 objects are not tested. Please consider using SQLAlchemy.&quot;</span>,</div>
<div class="line"><span class="lineno">  763</span>        UserWarning,</div>
<div class="line"><span class="lineno">  764</span>        stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  765</span>    )</div>
<div class="line"><span class="lineno">  766</span>    <span class="keywordflow">return</span> SQLiteDatabase(con)</div>
<div class="line"><span class="lineno">  767</span> </div>
<div class="line"><span class="lineno">  768</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acc2ac5260273dd561e7d8bced5ceedcd" name="acc2ac5260273dd561e7d8bced5ceedcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2ac5260273dd561e7d8bced5ceedcd">&#9670;&#160;</a></span>read_sql() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>] pandas.io.sql.read_sql </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] &#160;</td>
          <td class="paramname"><em>columns</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  432</span>) -&gt; Iterator[DataFrame]:</div>
<div class="line"><span class="lineno">  433</span>    ...</div>
<div class="line"><span class="lineno">  434</span> </div>
<div class="line"><span class="lineno">  435</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab455c75e0d04c53cb99e08db92509c2d" name="ab455c75e0d04c53cb99e08db92509c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab455c75e0d04c53cb99e08db92509c2d">&#9670;&#160;</a></span>read_sql() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.io.sql.read_sql </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] &#160;</td>
          <td class="paramname"><em>columns</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  418</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  419</span>    ...</div>
<div class="line"><span class="lineno">  420</span> </div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e0a6831bc3160fccf112128c3c7d1fc" name="a8e0a6831bc3160fccf112128c3c7d1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0a6831bc3160fccf112128c3c7d1fc">&#9670;&#160;</a></span>read_sql() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> | Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>] pandas.io.sql.read_sql </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>columns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read SQL query or database table into a DataFrame.

This function is a convenience wrapper around ``read_sql_table`` and
``read_sql_query`` (for backward compatibility). It will delegate
to the specific function depending on the provided input. A SQL query
will be routed to ``read_sql_query``, while a database table name will
be routed to ``read_sql_table``. Note that the delegated function might
have more specific notes about their functionality not listed here.

Parameters
----------
sql : str or SQLAlchemy Selectable (select or text object)
    SQL query to be executed or a table name.
con : SQLAlchemy connectable, str, or sqlite3 connection
    Using SQLAlchemy makes it possible to use any DB supported by that
    library. If a DBAPI2 object, only sqlite3 is supported. The user is responsible
    for engine disposal and connection closure for the SQLAlchemy connectable; str
    connections are closed automatically. See
    `here &lt;https://docs.sqlalchemy.org/en/13/core/connections.html&gt;`_.
index_col : str or list of str, optional, default: None
    Column(s) to set as index(MultiIndex).
coerce_float : bool, default True
    Attempts to convert values of non-string, non-numeric objects (like
    decimal.Decimal) to floating point, useful for SQL result sets.
params : list, tuple or dict, optional, default: None
    List of parameters to pass to execute method.  The syntax used
    to pass parameters is database driver dependent. Check your
    database driver documentation for which of the five syntax styles,
    described in PEP 249's paramstyle, is supported.
    Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}.
parse_dates : list or dict, default: None
    - List of column names to parse as dates.
    - Dict of ``{column_name: format string}`` where format string is
      strftime compatible in case of parsing string times, or is one of
      (D, s, ns, ms, us) in case of parsing integer timestamps.
    - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
      to the keyword arguments of :func:`pandas.to_datetime`
      Especially useful with databases without native Datetime support,
      such as SQLite.
columns : list, default: None
    List of column names to select from SQL table (only used when reading
    a table).
chunksize : int, default None
    If specified, return an iterator where `chunksize` is the
    number of rows to include in each chunk.

Returns
-------
DataFrame or Iterator[DataFrame]

See Also
--------
read_sql_table : Read SQL database table into a DataFrame.
read_sql_query : Read SQL query into a DataFrame.

Examples
--------
Read data from SQL via either a SQL query or a SQL tablename.
When using a SQLite database only SQL queries are accepted,
providing only the SQL tablename will result in an error.

&gt;&gt;&gt; from sqlite3 import connect
&gt;&gt;&gt; conn = connect(':memory:')
&gt;&gt;&gt; df = pd.DataFrame(data=[[0, '10/11/12'], [1, '12/11/10']],
...                   columns=['int_column', 'date_column'])
&gt;&gt;&gt; df.to_sql('test_data', conn)
2

&gt;&gt;&gt; pd.read_sql('SELECT int_column, date_column FROM test_data', conn)
   int_column date_column
0           0    10/11/12
1           1    12/11/10

&gt;&gt;&gt; pd.read_sql('test_data', 'postgres:///db_name')  # doctest:+SKIP

Apply date parsing to columns through the ``parse_dates`` argument

&gt;&gt;&gt; pd.read_sql('SELECT int_column, date_column FROM test_data',
...             conn,
...             parse_dates=["date_column"])
   int_column date_column
0           0  2012-10-11
1           1  2010-12-11

The ``parse_dates`` argument calls ``pd.to_datetime`` on the provided columns.
Custom argument values for applying ``pd.to_datetime`` on a column are specified
via a dictionary format:
1. Ignore errors while parsing the values of "date_column"

&gt;&gt;&gt; pd.read_sql('SELECT int_column, date_column FROM test_data',
...             conn,
...             parse_dates={"date_column": {"errors": "ignore"}})
   int_column date_column
0           0  2012-10-11
1           1  2010-12-11

2. Apply a dayfirst date parsing order on the values of "date_column"

&gt;&gt;&gt; pd.read_sql('SELECT int_column, date_column FROM test_data',
...             conn,
...             parse_dates={"date_column": {"dayfirst": True}})
   int_column date_column
0           0  2012-11-10
1           1  2010-11-12

3. Apply custom formatting when date parsing the values of "date_column"

&gt;&gt;&gt; pd.read_sql('SELECT int_column, date_column FROM test_data',
...             conn,
...             parse_dates={"date_column": {"format": "%d/%m/%y"}})
   int_column date_column
0           0  2012-11-10
1           1  2010-11-12
</pre> <div class="fragment"><div class="line"><span class="lineno">  445</span>) -&gt; DataFrame | Iterator[DataFrame]:</div>
<div class="line"><span class="lineno">  446</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    Read SQL query or database table into a DataFrame.</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    This function is a convenience wrapper around ``read_sql_table`` and</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    ``read_sql_query`` (for backward compatibility). It will delegate</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    to the specific function depending on the provided input. A SQL query</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    will be routed to ``read_sql_query``, while a database table name will</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    be routed to ``read_sql_table``. Note that the delegated function might</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    have more specific notes about their functionality not listed here.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    sql : str or SQLAlchemy Selectable (select or text object)</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        SQL query to be executed or a table name.</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    con : SQLAlchemy connectable, str, or sqlite3 connection</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">        Using SQLAlchemy makes it possible to use any DB supported by that</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        library. If a DBAPI2 object, only sqlite3 is supported. The user is responsible</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        for engine disposal and connection closure for the SQLAlchemy connectable; str</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        connections are closed automatically. See</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">        `here &lt;https://docs.sqlalchemy.org/en/13/core/connections.html&gt;`_.</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    index_col : str or list of str, optional, default: None</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        Column(s) to set as index(MultiIndex).</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    coerce_float : bool, default True</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        Attempts to convert values of non-string, non-numeric objects (like</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        decimal.Decimal) to floating point, useful for SQL result sets.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    params : list, tuple or dict, optional, default: None</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        List of parameters to pass to execute method.  The syntax used</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        to pass parameters is database driver dependent. Check your</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        database driver documentation for which of the five syntax styles,</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        described in PEP 249&#39;s paramstyle, is supported.</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        Eg. for psycopg2, uses %(name)s so use params={&#39;name&#39; : &#39;value&#39;}.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    parse_dates : list or dict, default: None</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        - List of column names to parse as dates.</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        - Dict of ``{column_name: format string}`` where format string is</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">          strftime compatible in case of parsing string times, or is one of</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">          (D, s, ns, ms, us) in case of parsing integer timestamps.</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        - Dict of ``{column_name: arg dict}``, where the arg dict corresponds</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">          to the keyword arguments of :func:`pandas.to_datetime`</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">          Especially useful with databases without native Datetime support,</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">          such as SQLite.</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    columns : list, default: None</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        List of column names to select from SQL table (only used when reading</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        a table).</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    chunksize : int, default None</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        If specified, return an iterator where `chunksize` is the</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">        number of rows to include in each chunk.</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    DataFrame or Iterator[DataFrame]</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    read_sql_table : Read SQL database table into a DataFrame.</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    read_sql_query : Read SQL query into a DataFrame.</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    Read data from SQL via either a SQL query or a SQL tablename.</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    When using a SQLite database only SQL queries are accepted,</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    providing only the SQL tablename will result in an error.</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    &gt;&gt;&gt; from sqlite3 import connect</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &gt;&gt;&gt; conn = connect(&#39;:memory:&#39;)</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    &gt;&gt;&gt; df = pd.DataFrame(data=[[0, &#39;10/11/12&#39;], [1, &#39;12/11/10&#39;]],</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    ...                   columns=[&#39;int_column&#39;, &#39;date_column&#39;])</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    &gt;&gt;&gt; df.to_sql(&#39;test_data&#39;, conn)</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    2</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    &gt;&gt;&gt; pd.read_sql(&#39;SELECT int_column, date_column FROM test_data&#39;, conn)</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">       int_column date_column</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    0           0    10/11/12</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    1           1    12/11/10</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    &gt;&gt;&gt; pd.read_sql(&#39;test_data&#39;, &#39;postgres:///db_name&#39;)  # doctest:+SKIP</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    Apply date parsing to columns through the ``parse_dates`` argument</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    &gt;&gt;&gt; pd.read_sql(&#39;SELECT int_column, date_column FROM test_data&#39;,</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    ...             conn,</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    ...             parse_dates=[&quot;date_column&quot;])</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">       int_column date_column</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    0           0  2012-10-11</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    1           1  2010-12-11</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    The ``parse_dates`` argument calls ``pd.to_datetime`` on the provided columns.</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    Custom argument values for applying ``pd.to_datetime`` on a column are specified</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    via a dictionary format:</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    1. Ignore errors while parsing the values of &quot;date_column&quot;</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    &gt;&gt;&gt; pd.read_sql(&#39;SELECT int_column, date_column FROM test_data&#39;,</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    ...             conn,</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    ...             parse_dates={&quot;date_column&quot;: {&quot;errors&quot;: &quot;ignore&quot;}})</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">       int_column date_column</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    0           0  2012-10-11</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    1           1  2010-12-11</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    2. Apply a dayfirst date parsing order on the values of &quot;date_column&quot;</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    &gt;&gt;&gt; pd.read_sql(&#39;SELECT int_column, date_column FROM test_data&#39;,</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    ...             conn,</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    ...             parse_dates={&quot;date_column&quot;: {&quot;dayfirst&quot;: True}})</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">       int_column date_column</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    0           0  2012-11-10</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    1           1  2010-11-12</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    3. Apply custom formatting when date parsing the values of &quot;date_column&quot;</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    &gt;&gt;&gt; pd.read_sql(&#39;SELECT int_column, date_column FROM test_data&#39;,</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    ...             conn,</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    ...             parse_dates={&quot;date_column&quot;: {&quot;format&quot;: &quot;%d/%m/%y&quot;}})</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">       int_column date_column</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    0           0  2012-11-10</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    1           1  2010-11-12</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  561</span>    pandas_sql = pandasSQL_builder(con)</div>
<div class="line"><span class="lineno">  562</span> </div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">if</span> isinstance(pandas_sql, SQLiteDatabase):</div>
<div class="line"><span class="lineno">  564</span>        <span class="keywordflow">return</span> pandas_sql.read_query(</div>
<div class="line"><span class="lineno">  565</span>            sql,</div>
<div class="line"><span class="lineno">  566</span>            index_col=index_col,</div>
<div class="line"><span class="lineno">  567</span>            params=params,</div>
<div class="line"><span class="lineno">  568</span>            coerce_float=coerce_float,</div>
<div class="line"><span class="lineno">  569</span>            parse_dates=parse_dates,</div>
<div class="line"><span class="lineno">  570</span>            chunksize=chunksize,</div>
<div class="line"><span class="lineno">  571</span>        )</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  574</span>        _is_table_name = pandas_sql.has_table(sql)</div>
<div class="line"><span class="lineno">  575</span>    <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  576</span>        <span class="comment"># using generic exception to catch errors from sql drivers (GH24988)</span></div>
<div class="line"><span class="lineno">  577</span>        _is_table_name = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  578</span> </div>
<div class="line"><span class="lineno">  579</span>    <span class="keywordflow">if</span> _is_table_name:</div>
<div class="line"><span class="lineno">  580</span>        pandas_sql.meta.reflect(bind=pandas_sql.connectable, only=[sql])</div>
<div class="line"><span class="lineno">  581</span>        <span class="keywordflow">return</span> pandas_sql.read_table(</div>
<div class="line"><span class="lineno">  582</span>            sql,</div>
<div class="line"><span class="lineno">  583</span>            index_col=index_col,</div>
<div class="line"><span class="lineno">  584</span>            coerce_float=coerce_float,</div>
<div class="line"><span class="lineno">  585</span>            parse_dates=parse_dates,</div>
<div class="line"><span class="lineno">  586</span>            columns=columns,</div>
<div class="line"><span class="lineno">  587</span>            chunksize=chunksize,</div>
<div class="line"><span class="lineno">  588</span>        )</div>
<div class="line"><span class="lineno">  589</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  590</span>        <span class="keywordflow">return</span> pandas_sql.read_query(</div>
<div class="line"><span class="lineno">  591</span>            sql,</div>
<div class="line"><span class="lineno">  592</span>            index_col=index_col,</div>
<div class="line"><span class="lineno">  593</span>            params=params,</div>
<div class="line"><span class="lineno">  594</span>            coerce_float=coerce_float,</div>
<div class="line"><span class="lineno">  595</span>            parse_dates=parse_dates,</div>
<div class="line"><span class="lineno">  596</span>            chunksize=chunksize,</div>
<div class="line"><span class="lineno">  597</span>        )</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a46e28c0667df0dd7ae5dc3fc7ebb296f" name="a46e28c0667df0dd7ae5dc3fc7ebb296f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e28c0667df0dd7ae5dc3fc7ebb296f">&#9670;&#160;</a></span>read_sql_query() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>] pandas.io.sql.read_sql_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>params</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  325</span>) -&gt; Iterator[DataFrame]:</div>
<div class="line"><span class="lineno">  326</span>    ...</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a25e74a8ef0650fdd972a37c4564544" name="a5a25e74a8ef0650fdd972a37c4564544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a25e74a8ef0650fdd972a37c4564544">&#9670;&#160;</a></span>read_sql_query() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.io.sql.read_sql_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>params</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  311</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  312</span>    ...</div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7106369a854aada61a1ae9c5085ccff" name="ab7106369a854aada61a1ae9c5085ccff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7106369a854aada61a1ae9c5085ccff">&#9670;&#160;</a></span>read_sql_query() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> | Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>] pandas.io.sql.read_sql_query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read SQL query into a DataFrame.

Returns a DataFrame corresponding to the result set of the query
string. Optionally provide an `index_col` parameter to use one of the
columns as the index, otherwise default integer index will be used.

Parameters
----------
sql : str SQL query or SQLAlchemy Selectable (select or text object)
    SQL query to be executed.
con : SQLAlchemy connectable, str, or sqlite3 connection
    Using SQLAlchemy makes it possible to use any DB supported by that
    library. If a DBAPI2 object, only sqlite3 is supported.
index_col : str or list of str, optional, default: None
    Column(s) to set as index(MultiIndex).
coerce_float : bool, default True
    Attempts to convert values of non-string, non-numeric objects (like
    decimal.Decimal) to floating point. Useful for SQL result sets.
params : list, tuple or dict, optional, default: None
    List of parameters to pass to execute method.  The syntax used
    to pass parameters is database driver dependent. Check your
    database driver documentation for which of the five syntax styles,
    described in PEP 249's paramstyle, is supported.
    Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}.
parse_dates : list or dict, default: None
    - List of column names to parse as dates.
    - Dict of ``{column_name: format string}`` where format string is
      strftime compatible in case of parsing string times, or is one of
      (D, s, ns, ms, us) in case of parsing integer timestamps.
    - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
      to the keyword arguments of :func:`pandas.to_datetime`
      Especially useful with databases without native Datetime support,
      such as SQLite.
chunksize : int, default None
    If specified, return an iterator where `chunksize` is the number of
    rows to include in each chunk.
dtype : Type name or dict of columns
    Data type for data or columns. E.g. np.float64 or
    {‘a’: np.float64, ‘b’: np.int32, ‘c’: ‘Int64’}.

    .. versionadded:: 1.3.0

Returns
-------
DataFrame or Iterator[DataFrame]

See Also
--------
read_sql_table : Read SQL database table into a DataFrame.
read_sql : Read SQL query or database table into a DataFrame.

Notes
-----
Any datetime values with time zone information parsed via the `parse_dates`
parameter will be converted to UTC.
</pre> <div class="fragment"><div class="line"><span class="lineno">  338</span>) -&gt; DataFrame | Iterator[DataFrame]:</div>
<div class="line"><span class="lineno">  339</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    Read SQL query into a DataFrame.</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    Returns a DataFrame corresponding to the result set of the query</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    string. Optionally provide an `index_col` parameter to use one of the</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    columns as the index, otherwise default integer index will be used.</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    sql : str SQL query or SQLAlchemy Selectable (select or text object)</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">        SQL query to be executed.</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    con : SQLAlchemy connectable, str, or sqlite3 connection</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">        Using SQLAlchemy makes it possible to use any DB supported by that</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        library. If a DBAPI2 object, only sqlite3 is supported.</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    index_col : str or list of str, optional, default: None</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">        Column(s) to set as index(MultiIndex).</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    coerce_float : bool, default True</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        Attempts to convert values of non-string, non-numeric objects (like</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        decimal.Decimal) to floating point. Useful for SQL result sets.</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    params : list, tuple or dict, optional, default: None</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">        List of parameters to pass to execute method.  The syntax used</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        to pass parameters is database driver dependent. Check your</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">        database driver documentation for which of the five syntax styles,</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">        described in PEP 249&#39;s paramstyle, is supported.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">        Eg. for psycopg2, uses %(name)s so use params={&#39;name&#39; : &#39;value&#39;}.</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    parse_dates : list or dict, default: None</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">        - List of column names to parse as dates.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">        - Dict of ``{column_name: format string}`` where format string is</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">          strftime compatible in case of parsing string times, or is one of</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">          (D, s, ns, ms, us) in case of parsing integer timestamps.</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">        - Dict of ``{column_name: arg dict}``, where the arg dict corresponds</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">          to the keyword arguments of :func:`pandas.to_datetime`</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">          Especially useful with databases without native Datetime support,</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">          such as SQLite.</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    chunksize : int, default None</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        If specified, return an iterator where `chunksize` is the number of</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        rows to include in each chunk.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    dtype : Type name or dict of columns</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        Data type for data or columns. E.g. np.float64 or</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        {‘a’: np.float64, ‘b’: np.int32, ‘c’: ‘Int64’}.</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        .. versionadded:: 1.3.0</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    DataFrame or Iterator[DataFrame]</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    read_sql_table : Read SQL database table into a DataFrame.</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    read_sql : Read SQL query or database table into a DataFrame.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    Any datetime values with time zone information parsed via the `parse_dates`</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    parameter will be converted to UTC.</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  396</span>    pandas_sql = pandasSQL_builder(con)</div>
<div class="line"><span class="lineno">  397</span>    <span class="keywordflow">return</span> pandas_sql.read_query(</div>
<div class="line"><span class="lineno">  398</span>        sql,</div>
<div class="line"><span class="lineno">  399</span>        index_col=index_col,</div>
<div class="line"><span class="lineno">  400</span>        params=params,</div>
<div class="line"><span class="lineno">  401</span>        coerce_float=coerce_float,</div>
<div class="line"><span class="lineno">  402</span>        parse_dates=parse_dates,</div>
<div class="line"><span class="lineno">  403</span>        chunksize=chunksize,</div>
<div class="line"><span class="lineno">  404</span>        dtype=dtype,</div>
<div class="line"><span class="lineno">  405</span>    )</div>
<div class="line"><span class="lineno">  406</span> </div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c5e3a7d894a929956048836c1b1d9f5" name="a9c5e3a7d894a929956048836c1b1d9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5e3a7d894a929956048836c1b1d9f5">&#9670;&#160;</a></span>read_sql_table() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> | Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>] pandas.io.sql.read_sql_table </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>columns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read SQL database table into a DataFrame.

Given a table name and a SQLAlchemy connectable, returns a DataFrame.
This function does not support DBAPI connections.

Parameters
----------
table_name : str
    Name of SQL table in database.
con : SQLAlchemy connectable or str
    A database URI could be provided as str.
    SQLite DBAPI connection mode not supported.
schema : str, default None
    Name of SQL schema in database to query (if database flavor
    supports this). Uses default schema if None (default).
index_col : str or list of str, optional, default: None
    Column(s) to set as index(MultiIndex).
coerce_float : bool, default True
    Attempts to convert values of non-string, non-numeric objects (like
    decimal.Decimal) to floating point. Can result in loss of Precision.
parse_dates : list or dict, default None
    - List of column names to parse as dates.
    - Dict of ``{column_name: format string}`` where format string is
      strftime compatible in case of parsing string times or is one of
      (D, s, ns, ms, us) in case of parsing integer timestamps.
    - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
      to the keyword arguments of :func:`pandas.to_datetime`
      Especially useful with databases without native Datetime support,
      such as SQLite.
columns : list, default None
    List of column names to select from SQL table.
chunksize : int, default None
    If specified, returns an iterator where `chunksize` is the number of
    rows to include in each chunk.

Returns
-------
DataFrame or Iterator[DataFrame]
    A SQL table is returned as two-dimensional data structure with labeled
    axes.

See Also
--------
read_sql_query : Read SQL query into a DataFrame.
read_sql : Read SQL query or database table into a DataFrame.

Notes
-----
Any datetime values with time zone information will be converted to UTC.

Examples
--------
&gt;&gt;&gt; pd.read_sql_table('table_name', 'postgres:///db_name')  # doctest:+SKIP
</pre> <div class="fragment"><div class="line"><span class="lineno">  224</span>) -&gt; DataFrame | Iterator[DataFrame]:</div>
<div class="line"><span class="lineno">  225</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Read SQL database table into a DataFrame.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Given a table name and a SQLAlchemy connectable, returns a DataFrame.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    This function does not support DBAPI connections.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    table_name : str</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        Name of SQL table in database.</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    con : SQLAlchemy connectable or str</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        A database URI could be provided as str.</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        SQLite DBAPI connection mode not supported.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    schema : str, default None</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        Name of SQL schema in database to query (if database flavor</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">        supports this). Uses default schema if None (default).</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    index_col : str or list of str, optional, default: None</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        Column(s) to set as index(MultiIndex).</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    coerce_float : bool, default True</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        Attempts to convert values of non-string, non-numeric objects (like</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        decimal.Decimal) to floating point. Can result in loss of Precision.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    parse_dates : list or dict, default None</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        - List of column names to parse as dates.</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        - Dict of ``{column_name: format string}`` where format string is</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">          strftime compatible in case of parsing string times or is one of</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">          (D, s, ns, ms, us) in case of parsing integer timestamps.</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        - Dict of ``{column_name: arg dict}``, where the arg dict corresponds</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">          to the keyword arguments of :func:`pandas.to_datetime`</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">          Especially useful with databases without native Datetime support,</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">          such as SQLite.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    columns : list, default None</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        List of column names to select from SQL table.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    chunksize : int, default None</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">        If specified, returns an iterator where `chunksize` is the number of</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        rows to include in each chunk.</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    DataFrame or Iterator[DataFrame]</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">        A SQL table is returned as two-dimensional data structure with labeled</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">        axes.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    read_sql_query : Read SQL query into a DataFrame.</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    read_sql : Read SQL query or database table into a DataFrame.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    Any datetime values with time zone information will be converted to UTC.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    &gt;&gt;&gt; pd.read_sql_table(&#39;table_name&#39;, &#39;postgres:///db_name&#39;)  # doctest:+SKIP</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  280</span>    pandas_sql = pandasSQL_builder(con, schema=schema)</div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> pandas_sql.has_table(table_name):</div>
<div class="line"><span class="lineno">  282</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Table {table_name} not found&quot;</span>)</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>    <span class="comment"># error: Item &quot;SQLiteDatabase&quot; of &quot;Union[SQLDatabase, SQLiteDatabase]&quot;</span></div>
<div class="line"><span class="lineno">  285</span>    <span class="comment"># has no attribute &quot;read_table&quot;</span></div>
<div class="line"><span class="lineno">  286</span>    table = pandas_sql.read_table(  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno">  287</span>        table_name,</div>
<div class="line"><span class="lineno">  288</span>        index_col=index_col,</div>
<div class="line"><span class="lineno">  289</span>        coerce_float=coerce_float,</div>
<div class="line"><span class="lineno">  290</span>        parse_dates=parse_dates,</div>
<div class="line"><span class="lineno">  291</span>        columns=columns,</div>
<div class="line"><span class="lineno">  292</span>        chunksize=chunksize,</div>
<div class="line"><span class="lineno">  293</span>    )</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">if</span> table <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  296</span>        <span class="keywordflow">return</span> table</div>
<div class="line"><span class="lineno">  297</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  298</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Table {table_name} not found&quot;</span>, con)</div>
<div class="line"><span class="lineno">  299</span> </div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c08c534969db426edfec7d5c47422df" name="a4c08c534969db426edfec7d5c47422df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c08c534969db426edfec7d5c47422df">&#9670;&#160;</a></span>read_sql_table() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>] pandas.io.sql.read_sql_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>schema</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>columns</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  211</span>) -&gt; Iterator[DataFrame]:</div>
<div class="line"><span class="lineno">  212</span>    ...</div>
<div class="line"><span class="lineno">  213</span> </div>
<div class="line"><span class="lineno">  214</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e4a6db14c6b11072aa08e0c11746705" name="a3e4a6db14c6b11072aa08e0c11746705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4a6db14c6b11072aa08e0c11746705">&#9670;&#160;</a></span>read_sql_table() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.io.sql.read_sql_table </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>schema</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | list[str] | None &#160;</td>
          <td class="paramname"><em>index_col</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coerce_float</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | dict[str, str] | None &#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str] | None &#160;</td>
          <td class="paramname"><em>columns</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  197</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  198</span>    ...</div>
<div class="line"><span class="lineno">  199</span> </div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7770a6d779acf18aeade328d2a2cbd2c" name="a7770a6d779acf18aeade328d2a2cbd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7770a6d779acf18aeade328d2a2cbd2c">&#9670;&#160;</a></span>to_sql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None pandas.io.sql.to_sql </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>schema</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>if_exists</em> = <code>&quot;fail&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>index</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel &#160;</td>
          <td class="paramname"><em>index_label</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>chunksize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>engine</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>engine_kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write records stored in a DataFrame to a SQL database.

Parameters
----------
frame : DataFrame, Series
name : str
    Name of SQL table.
con : SQLAlchemy connectable(engine/connection) or database string URI
    or sqlite3 DBAPI2 connection
    Using SQLAlchemy makes it possible to use any DB supported by that
    library.
    If a DBAPI2 object, only sqlite3 is supported.
schema : str, optional
    Name of SQL schema in database to write to (if database flavor
    supports this). If None, use default schema (default).
if_exists : {'fail', 'replace', 'append'}, default 'fail'
    - fail: If table exists, do nothing.
    - replace: If table exists, drop it, recreate it, and insert data.
    - append: If table exists, insert data. Create if does not exist.
index : bool, default True
    Write DataFrame index as a column.
index_label : str or sequence, optional
    Column label for index column(s). If None is given (default) and
    `index` is True, then the index names are used.
    A sequence should be given if the DataFrame uses MultiIndex.
chunksize : int, optional
    Specify the number of rows in each batch to be written at a time.
    By default, all rows will be written at once.
dtype : dict or scalar, optional
    Specifying the datatype for columns. If a dictionary is used, the
    keys should be the column names and the values should be the
    SQLAlchemy types or strings for the sqlite3 fallback mode. If a
    scalar is provided, it will be applied to all columns.
method : {None, 'multi', callable}, optional
    Controls the SQL insertion clause used:

    - None : Uses standard SQL ``INSERT`` clause (one per row).
    - ``'multi'``: Pass multiple values in a single ``INSERT`` clause.
    - callable with signature ``(pd_table, conn, keys, data_iter) -&gt; int | None``.

    Details and a sample callable implementation can be found in the
    section :ref:`insert method &lt;io.sql.method&gt;`.
engine : {'auto', 'sqlalchemy'}, default 'auto'
    SQL engine library to use. If 'auto', then the option
    ``io.sql.engine`` is used. The default ``io.sql.engine``
    behavior is 'sqlalchemy'

    .. versionadded:: 1.3.0

**engine_kwargs
    Any additional kwargs are passed to the engine.

Returns
-------
None or int
    Number of rows affected by to_sql. None is returned if the callable
    passed into ``method`` does not return an integer number of rows.

    .. versionadded:: 1.4.0

Notes
-----
The returned rows affected is the sum of the ``rowcount`` attribute of ``sqlite3.Cursor``
or SQLAlchemy connectable. The returned value may not reflect the exact number of written
rows as stipulated in the
`sqlite3 &lt;https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.rowcount&gt;`__ or
`SQLAlchemy &lt;https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.BaseCursorResult.rowcount&gt;`__
</pre> <div class="fragment"><div class="line"><span class="lineno">  613</span>) -&gt; int | <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  614</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    Write records stored in a DataFrame to a SQL database.</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    frame : DataFrame, Series</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    name : str</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        Name of SQL table.</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    con : SQLAlchemy connectable(engine/connection) or database string URI</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">        or sqlite3 DBAPI2 connection</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        Using SQLAlchemy makes it possible to use any DB supported by that</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        library.</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">        If a DBAPI2 object, only sqlite3 is supported.</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    schema : str, optional</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">        Name of SQL schema in database to write to (if database flavor</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">        supports this). If None, use default schema (default).</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    if_exists : {&#39;fail&#39;, &#39;replace&#39;, &#39;append&#39;}, default &#39;fail&#39;</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        - fail: If table exists, do nothing.</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">        - replace: If table exists, drop it, recreate it, and insert data.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">        - append: If table exists, insert data. Create if does not exist.</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    index : bool, default True</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">        Write DataFrame index as a column.</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    index_label : str or sequence, optional</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        Column label for index column(s). If None is given (default) and</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">        `index` is True, then the index names are used.</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">        A sequence should be given if the DataFrame uses MultiIndex.</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    chunksize : int, optional</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">        Specify the number of rows in each batch to be written at a time.</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        By default, all rows will be written at once.</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    dtype : dict or scalar, optional</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">        Specifying the datatype for columns. If a dictionary is used, the</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        keys should be the column names and the values should be the</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">        SQLAlchemy types or strings for the sqlite3 fallback mode. If a</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        scalar is provided, it will be applied to all columns.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    method : {None, &#39;multi&#39;, callable}, optional</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        Controls the SQL insertion clause used:</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">        - None : Uses standard SQL ``INSERT`` clause (one per row).</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        - ``&#39;multi&#39;``: Pass multiple values in a single ``INSERT`` clause.</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        - callable with signature ``(pd_table, conn, keys, data_iter) -&gt; int | None``.</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        Details and a sample callable implementation can be found in the</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        section :ref:`insert method &lt;io.sql.method&gt;`.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    engine : {&#39;auto&#39;, &#39;sqlalchemy&#39;}, default &#39;auto&#39;</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        SQL engine library to use. If &#39;auto&#39;, then the option</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        ``io.sql.engine`` is used. The default ``io.sql.engine``</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        behavior is &#39;sqlalchemy&#39;</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        .. versionadded:: 1.3.0</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    **engine_kwargs</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        Any additional kwargs are passed to the engine.</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    None or int</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        Number of rows affected by to_sql. None is returned if the callable</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        passed into ``method`` does not return an integer number of rows.</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">        .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    The returned rows affected is the sum of the ``rowcount`` attribute of ``sqlite3.Cursor``</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    or SQLAlchemy connectable. The returned value may not reflect the exact number of written</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    rows as stipulated in the</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    `sqlite3 &lt;https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.rowcount&gt;`__ or</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    `SQLAlchemy &lt;https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.BaseCursorResult.rowcount&gt;`__</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    &quot;&quot;&quot;</span>  <span class="comment"># noqa:E501</span></div>
<div class="line"><span class="lineno">  683</span>    <span class="keywordflow">if</span> if_exists <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&quot;fail&quot;</span>, <span class="stringliteral">&quot;replace&quot;</span>, <span class="stringliteral">&quot;append&quot;</span>):</div>
<div class="line"><span class="lineno">  684</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;&#39;{if_exists}&#39; is not valid for if_exists&quot;</span>)</div>
<div class="line"><span class="lineno">  685</span> </div>
<div class="line"><span class="lineno">  686</span>    pandas_sql = pandasSQL_builder(con, schema=schema)</div>
<div class="line"><span class="lineno">  687</span> </div>
<div class="line"><span class="lineno">  688</span>    <span class="keywordflow">if</span> isinstance(frame, Series):</div>
<div class="line"><span class="lineno">  689</span>        frame = frame.to_frame()</div>
<div class="line"><span class="lineno">  690</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(frame, DataFrame):</div>
<div class="line"><span class="lineno">  691</span>        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno">  692</span>            <span class="stringliteral">&quot;&#39;frame&#39; argument should be either a Series or a DataFrame&quot;</span></div>
<div class="line"><span class="lineno">  693</span>        )</div>
<div class="line"><span class="lineno">  694</span> </div>
<div class="line"><span class="lineno">  695</span>    <span class="keywordflow">return</span> pandas_sql.to_sql(</div>
<div class="line"><span class="lineno">  696</span>        frame,</div>
<div class="line"><span class="lineno">  697</span>        name,</div>
<div class="line"><span class="lineno">  698</span>        if_exists=if_exists,</div>
<div class="line"><span class="lineno">  699</span>        index=index,</div>
<div class="line"><span class="lineno">  700</span>        index_label=index_label,</div>
<div class="line"><span class="lineno">  701</span>        schema=schema,</div>
<div class="line"><span class="lineno">  702</span>        chunksize=chunksize,</div>
<div class="line"><span class="lineno">  703</span>        dtype=dtype,</div>
<div class="line"><span class="lineno">  704</span>        method=method,</div>
<div class="line"><span class="lineno">  705</span>        engine=engine,</div>
<div class="line"><span class="lineno">  706</span>        **engine_kwargs,</div>
<div class="line"><span class="lineno">  707</span>    )</div>
<div class="line"><span class="lineno">  708</span> </div>
<div class="line"><span class="lineno">  709</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6fe412bc2640a94db1e0989b222767ed" name="a6fe412bc2640a94db1e0989b222767ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe412bc2640a94db1e0989b222767ed">&#9670;&#160;</a></span>_SQL_TYPES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.io.sql._SQL_TYPES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;string&quot;</span>: <span class="stringliteral">&quot;TEXT&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;floating&quot;</span>: <span class="stringliteral">&quot;REAL&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;integer&quot;</span>: <span class="stringliteral">&quot;INTEGER&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;datetime&quot;</span>: <span class="stringliteral">&quot;TIMESTAMP&quot;</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;date&quot;</span>: <span class="stringliteral">&quot;DATE&quot;</span>,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;time&quot;</span>: <span class="stringliteral">&quot;TIME&quot;</span>,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;boolean&quot;</span>: <span class="stringliteral">&quot;INTEGER&quot;</span>,</div>
<div class="line"><span class="lineno">    9</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7cfd1d87ee3e84467f1437462970a29" name="aa7cfd1d87ee3e84467f1437462970a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cfd1d87ee3e84467f1437462970a29">&#9670;&#160;</a></span>table_exists</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.io.sql.table_exists = <a class="el" href="namespacepandas_1_1io_1_1sql.html#a481d992f90af2849fdc44ae80127e13f">has_table</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
