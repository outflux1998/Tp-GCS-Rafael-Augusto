<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.linalg._matfuncs Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html">_matfuncs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg._matfuncs Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a05a2b5e07664ebfce8a689d3fbf3e6cf" id="r_a05a2b5e07664ebfce8a689d3fbf3e6cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a05a2b5e07664ebfce8a689d3fbf3e6cf">_asarray_square</a> (A)</td></tr>
<tr class="memdesc:a05a2b5e07664ebfce8a689d3fbf3e6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions.  <br /></td></tr>
<tr class="separator:a05a2b5e07664ebfce8a689d3fbf3e6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa09eb301194b21a0927ed064f32801" id="r_abaa09eb301194b21a0927ed064f32801"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#abaa09eb301194b21a0927ed064f32801">_maybe_real</a> (A, B, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=None)</td></tr>
<tr class="separator:abaa09eb301194b21a0927ed064f32801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96d70c734b036dd8dbf7fb87e5978f1" id="r_ab96d70c734b036dd8dbf7fb87e5978f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#ab96d70c734b036dd8dbf7fb87e5978f1">fractional_matrix_power</a> (A, t)</td></tr>
<tr class="memdesc:ab96d70c734b036dd8dbf7fb87e5978f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix functions.  <br /></td></tr>
<tr class="separator:ab96d70c734b036dd8dbf7fb87e5978f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc544afa3b784dda9f742dc92abc723" id="r_a4dc544afa3b784dda9f742dc92abc723"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a4dc544afa3b784dda9f742dc92abc723">logm</a> (A, disp=True)</td></tr>
<tr class="separator:a4dc544afa3b784dda9f742dc92abc723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edbf3475cc0c5e6e7701aeae53e3e45" id="r_a9edbf3475cc0c5e6e7701aeae53e3e45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a9edbf3475cc0c5e6e7701aeae53e3e45">expm</a> (A)</td></tr>
<tr class="separator:a9edbf3475cc0c5e6e7701aeae53e3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9a70da144ebd7e293232984aa4a250" id="r_a3c9a70da144ebd7e293232984aa4a250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a3c9a70da144ebd7e293232984aa4a250">_exp_sinch</a> (x)</td></tr>
<tr class="separator:a3c9a70da144ebd7e293232984aa4a250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ad72297d785e035af8ef4758d69ba8" id="r_a03ad72297d785e035af8ef4758d69ba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a03ad72297d785e035af8ef4758d69ba8">cosm</a> (A)</td></tr>
<tr class="separator:a03ad72297d785e035af8ef4758d69ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e99a09f6c589271840bfd95e5b486a2" id="r_a8e99a09f6c589271840bfd95e5b486a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a8e99a09f6c589271840bfd95e5b486a2">sinm</a> (A)</td></tr>
<tr class="separator:a8e99a09f6c589271840bfd95e5b486a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78ae302b448227e7da621691243e3e4" id="r_ad78ae302b448227e7da621691243e3e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#ad78ae302b448227e7da621691243e3e4">tanm</a> (A)</td></tr>
<tr class="separator:ad78ae302b448227e7da621691243e3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7f46803ff176233973b65648f0f705" id="r_a8b7f46803ff176233973b65648f0f705"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a8b7f46803ff176233973b65648f0f705">coshm</a> (A)</td></tr>
<tr class="separator:a8b7f46803ff176233973b65648f0f705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b85f6f126ab691a7864badfd995171" id="r_ae5b85f6f126ab691a7864badfd995171"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#ae5b85f6f126ab691a7864badfd995171">sinhm</a> (A)</td></tr>
<tr class="separator:ae5b85f6f126ab691a7864badfd995171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa2595514d8229c828e71e95adbc282" id="r_a4aa2595514d8229c828e71e95adbc282"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a4aa2595514d8229c828e71e95adbc282">tanhm</a> (A)</td></tr>
<tr class="separator:a4aa2595514d8229c828e71e95adbc282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a713ca22800d9fe9c00a5608be2c99c" id="r_a1a713ca22800d9fe9c00a5608be2c99c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a1a713ca22800d9fe9c00a5608be2c99c">funm</a> (A, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, disp=True)</td></tr>
<tr class="separator:a1a713ca22800d9fe9c00a5608be2c99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241dd03afab2072a15bdccb481bf5812" id="r_a241dd03afab2072a15bdccb481bf5812"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a241dd03afab2072a15bdccb481bf5812">signm</a> (A, disp=True)</td></tr>
<tr class="separator:a241dd03afab2072a15bdccb481bf5812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaab816e6d56905a12a502b211a5e7ff" id="r_aeaab816e6d56905a12a502b211a5e7ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#aeaab816e6d56905a12a502b211a5e7ff">khatri_rao</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b)</td></tr>
<tr class="separator:aeaab816e6d56905a12a502b211a5e7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a836b45113aeaa4577c5a7d2fed5a5969" id="r_a836b45113aeaa4577c5a7d2fed5a5969"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a836b45113aeaa4577c5a7d2fed5a5969">eps</a> = np.finfo('<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>').eps</td></tr>
<tr class="separator:a836b45113aeaa4577c5a7d2fed5a5969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcda5082d96e3a0d6ce409f93b72e71" id="r_a1dcda5082d96e3a0d6ce409f93b72e71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a1dcda5082d96e3a0d6ce409f93b72e71">feps</a> = np.finfo('<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>').<a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a836b45113aeaa4577c5a7d2fed5a5969">eps</a></td></tr>
<tr class="separator:a1dcda5082d96e3a0d6ce409f93b72e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb829b26a93c85b6faab8111d76b6b2c" id="r_acb829b26a93c85b6faab8111d76b6b2c"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#acb829b26a93c85b6faab8111d76b6b2c">_array_precision</a> = {'<a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>': 1, 'l': 1, '<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>': 0, '<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>': 1, 'F': 0, 'D': 1}</td></tr>
<tr class="separator:acb829b26a93c85b6faab8111d76b6b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a05a2b5e07664ebfce8a689d3fbf3e6cf" name="a05a2b5e07664ebfce8a689d3fbf3e6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a2b5e07664ebfce8a689d3fbf3e6cf">&#9670;&#160;</a></span>_asarray_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs._asarray_square </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility functions. </p>
<pre class="fragment">Wraps asarray with the extra requirement that the input be a square matrix.

The motivation is that the matfuncs module has real functions that have
been lifted to square matrix functions.

Parameters
----------
A : array_like
    A square matrix.

Returns
-------
out : ndarray
    An ndarray copy or view or other representation of A.</pre> <div class="fragment"><div class="line"><span class="lineno">   36</span><span class="keyword">def </span>_asarray_square(A):</div>
<div class="line"><span class="lineno">   37</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    Wraps asarray with the extra requirement that the input be a square matrix.</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    The motivation is that the matfuncs module has real functions that have</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    been lifted to square matrix functions.</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    A : array_like</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        A square matrix.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        An ndarray copy or view or other representation of A.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   54</span>    A = np.asarray(A)</div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">if</span> len(A.shape) != 2 <span class="keywordflow">or</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">   56</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected square array_like input&#39;</span>)</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">return</span> A</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c9a70da144ebd7e293232984aa4a250" name="a3c9a70da144ebd7e293232984aa4a250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9a70da144ebd7e293232984aa4a250">&#9670;&#160;</a></span>_exp_sinch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs._exp_sinch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  386</span><span class="keyword">def </span>_exp_sinch(x):</div>
<div class="line"><span class="lineno">  387</span>    <span class="comment"># Higham&#39;s formula (10.42), might overflow, see GH-11839</span></div>
<div class="line"><span class="lineno">  388</span>    lexp_diff = np.diff(np.exp(x))</div>
<div class="line"><span class="lineno">  389</span>    l_diff = np.diff(x)</div>
<div class="line"><span class="lineno">  390</span>    mask_z = l_diff == 0.</div>
<div class="line"><span class="lineno">  391</span>    lexp_diff[~mask_z] /= l_diff[~mask_z]</div>
<div class="line"><span class="lineno">  392</span>    lexp_diff[mask_z] = np.exp(x[:-1][mask_z])</div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">return</span> lexp_diff</div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abaa09eb301194b21a0927ed064f32801" name="abaa09eb301194b21a0927ed064f32801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa09eb301194b21a0927ed064f32801">&#9670;&#160;</a></span>_maybe_real()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs._maybe_real </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return either B or the real part of B, depending on properties of A and B.

The motivation is that B has been computed as a complicated function of A,
and B may be perturbed by negligible imaginary components.
If A is real and B is complex with small imaginary components,
then return a real copy of B.  The assumption in that case would be that
the imaginary components of B are numerical artifacts.

Parameters
----------
A : ndarray
    Input array whose type is to be checked as real vs. complex.
B : ndarray
    Array to be returned, possibly without its imaginary part.
tol : float
    Absolute tolerance.

Returns
-------
out : real or complex array
    Either the input array B or only the real part of the input array B.</pre> <div class="fragment"><div class="line"><span class="lineno">   60</span><span class="keyword">def </span>_maybe_real(A, B, tol=None):</div>
<div class="line"><span class="lineno">   61</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    Return either B or the real part of B, depending on properties of A and B.</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    The motivation is that B has been computed as a complicated function of A,</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    and B may be perturbed by negligible imaginary components.</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    If A is real and B is complex with small imaginary components,</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    then return a real copy of B.  The assumption in that case would be that</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    the imaginary components of B are numerical artifacts.</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    A : ndarray</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">        Input array whose type is to be checked as real vs. complex.</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    B : ndarray</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        Array to be returned, possibly without its imaginary part.</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    tol : float</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">        Absolute tolerance.</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    out : real or complex array</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        Either the input array B or only the real part of the input array B.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   85</span>    <span class="comment"># Note that booleans and integers compare as real.</span></div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordflow">if</span> np.isrealobj(A) <span class="keywordflow">and</span> np.iscomplexobj(B):</div>
<div class="line"><span class="lineno">   87</span>        <span class="keywordflow">if</span> tol <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   88</span>            tol = {0:feps*1e3, 1:eps*1e6}[_array_precision[B.dtype.char]]</div>
<div class="line"><span class="lineno">   89</span>        <span class="keywordflow">if</span> np.allclose(B.imag, 0.0, atol=tol):</div>
<div class="line"><span class="lineno">   90</span>            B = B.real</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">return</span> B</div>
<div class="line"><span class="lineno">   92</span> </div>
<div class="line"><span class="lineno">   93</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b7f46803ff176233973b65648f0f705" name="a8b7f46803ff176233973b65648f0f705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7f46803ff176233973b65648f0f705">&#9670;&#160;</a></span>coshm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.coshm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the hyperbolic matrix cosine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
coshm : (N, N) ndarray
    Hyperbolic matrix cosine of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; c = coshm(a)
&gt;&gt;&gt; c
array([[ 11.24592233,  38.76236492],
       [ 12.92078831,  50.00828725]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

&gt;&gt;&gt; t = tanhm(a)
&gt;&gt;&gt; s = sinhm(a)
&gt;&gt;&gt; t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])</pre> <div class="fragment"><div class="line"><span class="lineno">  512</span><span class="keyword">def </span>coshm(A):</div>
<div class="line"><span class="lineno">  513</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    Compute the hyperbolic matrix cosine.</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    This routine uses expm to compute the matrix exponentials.</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    coshm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">        Hyperbolic matrix cosine of `A`</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    &gt;&gt;&gt; c = coshm(a)</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    &gt;&gt;&gt; c</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    array([[ 11.24592233,  38.76236492],</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">           [ 12.92078831,  50.00828725]])</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    &gt;&gt;&gt; t = tanhm(a)</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    &gt;&gt;&gt; s = sinhm(a)</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    &gt;&gt;&gt; t - s.dot(np.linalg.inv(c))</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    array([[  2.72004641e-15,   4.55191440e-15],</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">           [  0.00000000e+00,  -5.55111512e-16]])</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  546</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  547</span>    <span class="keywordflow">return</span> _maybe_real(A, 0.5 * (expm(A) + expm(-A)))</div>
<div class="line"><span class="lineno">  548</span> </div>
<div class="line"><span class="lineno">  549</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a03ad72297d785e035af8ef4758d69ba8" name="a03ad72297d785e035af8ef4758d69ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ad72297d785e035af8ef4758d69ba8">&#9670;&#160;</a></span>cosm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.cosm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the matrix cosine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array

Returns
-------
cosm : (N, N) ndarray
    Matrix cosine of A

Examples
--------
&gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

&gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])
&gt;&gt;&gt; expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
&gt;&gt;&gt; cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</pre> <div class="fragment"><div class="line"><span class="lineno">  396</span><span class="keyword">def </span>cosm(A):</div>
<div class="line"><span class="lineno">  397</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    Compute the matrix cosine.</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    This routine uses expm to compute the matrix exponentials.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    cosm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        Matrix cosine of A</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    Euler&#39;s identity (exp(i*theta) = cos(theta) + i*sin(theta))</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    applied to a matrix:</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    &gt;&gt;&gt; expm(1j*a)</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">           [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    &gt;&gt;&gt; cosm(a) + 1j*sinm(a)</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">           [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  428</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  429</span>    <span class="keywordflow">if</span> np.iscomplexobj(A):</div>
<div class="line"><span class="lineno">  430</span>        <span class="keywordflow">return</span> 0.5*(expm(1j*A) + expm(-1j*A))</div>
<div class="line"><span class="lineno">  431</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  432</span>        <span class="keywordflow">return</span> expm(1j*A).real</div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9edbf3475cc0c5e6e7701aeae53e3e45" name="a9edbf3475cc0c5e6e7701aeae53e3e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edbf3475cc0c5e6e7701aeae53e3e45">&#9670;&#160;</a></span>expm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.expm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the matrix exponential of an array.

Parameters
----------
A : ndarray
    Input with last two dimensions are square ``(..., n, n)``.

Returns
-------
eA : ndarray
    The resulting matrix exponential with the same shape of ``A``

Notes
-----
Implements the algorithm given in [1], which is essentially a Pade
approximation with a variable order that is decided based on the array
data.

For input with size ``n``, the memory usage is in the worst case in the
order of ``8*(n**2)``. If the input data is not of single and double
precision of real and complex dtypes, it is copied to a new array.

For cases ``n &gt;= 400``, the exact 1-norm computation cost, breaks even with
1-norm estimation and from that point on the estimation scheme given in
[2] is used to decide on the approximation order.

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham, (2009), "A New Scaling
       and Squaring Algorithm for the Matrix Exponential", SIAM J. Matrix
       Anal. Appl. 31(3):970-989, :doi:`10.1137/09074721X`

.. [2] Nicholas J. Higham and Francoise Tisseur (2000), "A Block Algorithm
       for Matrix 1-Norm Estimation, with an Application to 1-Norm
       Pseudospectra." SIAM J. Matrix Anal. Appl. 21(4):1185-1201,
       :doi:`10.1137/S0895479899356080`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm

Matrix version of the formula exp(0) = 1:

&gt;&gt;&gt; expm(np.zeros((3, 2, 2)))
array([[[1., 0.],
        [0., 1.]],
&lt;BLANKLINE&gt;
       [[1., 0.],
        [0., 1.]],
&lt;BLANKLINE&gt;
       [[1., 0.],
        [0., 1.]]])

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

&gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])
&gt;&gt;&gt; expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
&gt;&gt;&gt; cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</pre> <div class="fragment"><div class="line"><span class="lineno">  213</span><span class="keyword">def </span>expm(A):</div>
<div class="line"><span class="lineno">  214</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the matrix exponential of an array.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    A : ndarray</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        Input with last two dimensions are square ``(..., n, n)``.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    eA : ndarray</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">        The resulting matrix exponential with the same shape of ``A``</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Implements the algorithm given in [1], which is essentially a Pade</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    approximation with a variable order that is decided based on the array</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    data.</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    For input with size ``n``, the memory usage is in the worst case in the</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    order of ``8*(n**2)``. If the input data is not of single and double</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    precision of real and complex dtypes, it is copied to a new array.</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    For cases ``n &gt;= 400``, the exact 1-norm computation cost, breaks even with</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    1-norm estimation and from that point on the estimation scheme given in</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    [2] is used to decide on the approximation order.</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    .. [1] Awad H. Al-Mohy and Nicholas J. Higham, (2009), &quot;A New Scaling</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">           and Squaring Algorithm for the Matrix Exponential&quot;, SIAM J. Matrix</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">           Anal. Appl. 31(3):970-989, :doi:`10.1137/09074721X`</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    .. [2] Nicholas J. Higham and Francoise Tisseur (2000), &quot;A Block Algorithm</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">           for Matrix 1-Norm Estimation, with an Application to 1-Norm</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">           Pseudospectra.&quot; SIAM J. Matrix Anal. Appl. 21(4):1185-1201,</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">           :doi:`10.1137/S0895479899356080`</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    Matrix version of the formula exp(0) = 1:</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    &gt;&gt;&gt; expm(np.zeros((3, 2, 2)))</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    array([[[1., 0.],</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">            [0., 1.]],</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    &lt;BLANKLINE&gt;</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">           [[1., 0.],</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">            [0., 1.]],</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    &lt;BLANKLINE&gt;</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">           [[1., 0.],</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">            [0., 1.]]])</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    Euler&#39;s identity (exp(i*theta) = cos(theta) + i*sin(theta))</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    applied to a matrix:</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    &gt;&gt;&gt; expm(1j*a)</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">           [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    &gt;&gt;&gt; cosm(a) + 1j*sinm(a)</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">           [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  279</span>    a = np.asarray(A)</div>
<div class="line"><span class="lineno">  280</span>    <span class="keywordflow">if</span> a.size == 1 <span class="keywordflow">and</span> a.ndim &lt; 2:</div>
<div class="line"><span class="lineno">  281</span>        <span class="keywordflow">return</span> np.array([[np.exp(a.item())]])</div>
<div class="line"><span class="lineno">  282</span> </div>
<div class="line"><span class="lineno">  283</span>    <span class="keywordflow">if</span> a.ndim &lt; 2:</div>
<div class="line"><span class="lineno">  284</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&#39;The input array must be at least two-dimensional&#39;</span>)</div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">if</span> a.shape[-1] != a.shape[-2]:</div>
<div class="line"><span class="lineno">  286</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&#39;Last 2 dimensions of the array must be square&#39;</span>)</div>
<div class="line"><span class="lineno">  287</span>    n = a.shape[-1]</div>
<div class="line"><span class="lineno">  288</span>    <span class="comment"># Empty array</span></div>
<div class="line"><span class="lineno">  289</span>    <span class="keywordflow">if</span> min(*a.shape) == 0:</div>
<div class="line"><span class="lineno">  290</span>        <span class="keywordflow">return</span> np.empty_like(a)</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>    <span class="comment"># Scalar case</span></div>
<div class="line"><span class="lineno">  293</span>    <span class="keywordflow">if</span> a.shape[-2:] == (1, 1):</div>
<div class="line"><span class="lineno">  294</span>        <span class="keywordflow">return</span> np.exp(a)</div>
<div class="line"><span class="lineno">  295</span> </div>
<div class="line"><span class="lineno">  296</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.issubdtype(a.dtype, np.inexact):</div>
<div class="line"><span class="lineno">  297</span>        a = a.astype(float)</div>
<div class="line"><span class="lineno">  298</span>    <span class="keywordflow">elif</span> a.dtype == np.float16:</div>
<div class="line"><span class="lineno">  299</span>        a = a.astype(np.float32)</div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>    <span class="comment"># Explicit formula for 2x2 case, formula (2.2) in [1]</span></div>
<div class="line"><span class="lineno">  302</span>    <span class="comment"># without Kahan&#39;s method numerical instabilities can occur.</span></div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">if</span> a.shape[-2:] == (2, 2):</div>
<div class="line"><span class="lineno">  304</span>        a1, a2, a3, a4 = (a[..., [0], [0]],</div>
<div class="line"><span class="lineno">  305</span>                          a[..., [0], [1]],</div>
<div class="line"><span class="lineno">  306</span>                          a[..., [1], [0]],</div>
<div class="line"><span class="lineno">  307</span>                          a[..., [1], [1]])</div>
<div class="line"><span class="lineno">  308</span>        mu = csqrt((a1-a4)**2 + 4*a2*a3)/2.  <span class="comment"># csqrt slow but handles neg.vals</span></div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>        eApD2 = np.exp((a1+a4)/2.)</div>
<div class="line"><span class="lineno">  311</span>        AmD2 = (a1 - a4)/2.</div>
<div class="line"><span class="lineno">  312</span>        coshMu = np.cosh(mu)</div>
<div class="line"><span class="lineno">  313</span>        sinchMu = np.ones_like(coshMu)</div>
<div class="line"><span class="lineno">  314</span>        mask = mu != 0</div>
<div class="line"><span class="lineno">  315</span>        sinchMu[mask] = np.sinh(mu[mask]) / mu[mask]</div>
<div class="line"><span class="lineno">  316</span>        eA = np.empty((a.shape), dtype=mu.dtype)</div>
<div class="line"><span class="lineno">  317</span>        eA[..., [0], [0]] = eApD2 * (coshMu + AmD2*sinchMu)</div>
<div class="line"><span class="lineno">  318</span>        eA[..., [0], [1]] = eApD2 * a2 * sinchMu</div>
<div class="line"><span class="lineno">  319</span>        eA[..., [1], [0]] = eApD2 * a3 * sinchMu</div>
<div class="line"><span class="lineno">  320</span>        eA[..., [1], [1]] = eApD2 * (coshMu - AmD2*sinchMu)</div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">if</span> np.isrealobj(a):</div>
<div class="line"><span class="lineno">  322</span>            <span class="keywordflow">return</span> eA.real</div>
<div class="line"><span class="lineno">  323</span>        <span class="keywordflow">return</span> eA</div>
<div class="line"><span class="lineno">  324</span> </div>
<div class="line"><span class="lineno">  325</span>    <span class="comment"># larger problem with unspecified stacked dimensions.</span></div>
<div class="line"><span class="lineno">  326</span>    n = a.shape[-1]</div>
<div class="line"><span class="lineno">  327</span>    eA = np.empty(a.shape, dtype=a.dtype)</div>
<div class="line"><span class="lineno">  328</span>    <span class="comment"># working memory to hold intermediate arrays</span></div>
<div class="line"><span class="lineno">  329</span>    Am = np.empty((5, n, n), dtype=a.dtype)</div>
<div class="line"><span class="lineno">  330</span> </div>
<div class="line"><span class="lineno">  331</span>    <span class="comment"># Main loop to go through the slices of an ndarray and passing to expm</span></div>
<div class="line"><span class="lineno">  332</span>    <span class="keywordflow">for</span> ind <span class="keywordflow">in</span> product(*[range(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> a.shape[:-2]]):</div>
<div class="line"><span class="lineno">  333</span>        aw = a[ind]</div>
<div class="line"><span class="lineno">  334</span> </div>
<div class="line"><span class="lineno">  335</span>        lu = bandwidth(aw)</div>
<div class="line"><span class="lineno">  336</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> any(lu):  <span class="comment"># a is diagonal?</span></div>
<div class="line"><span class="lineno">  337</span>            eA[ind] = np.diag(np.exp(np.diag(aw)))</div>
<div class="line"><span class="lineno">  338</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>        <span class="comment"># Generic/triangular case; copy the slice into scratch and send.</span></div>
<div class="line"><span class="lineno">  341</span>        <span class="comment"># Am will be mutated by pick_pade_structure</span></div>
<div class="line"><span class="lineno">  342</span>        Am[0, :, :] = aw</div>
<div class="line"><span class="lineno">  343</span>        m, s = pick_pade_structure(Am)</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span>        <span class="keywordflow">if</span> s != 0:  <span class="comment"># scaling needed</span></div>
<div class="line"><span class="lineno">  346</span>            Am[:4] *= [[[2**(-s)]], [[4**(-s)]], [[16**(-s)]], [[64**(-s)]]]</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>        pade_UV_calc(Am, n, m)</div>
<div class="line"><span class="lineno">  349</span>        eAw = Am[0]</div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">if</span> s != 0:  <span class="comment"># squaring needed</span></div>
<div class="line"><span class="lineno">  352</span> </div>
<div class="line"><span class="lineno">  353</span>            <span class="keywordflow">if</span> (lu[1] == 0) <span class="keywordflow">or</span> (lu[0] == 0):  <span class="comment"># lower/upper triangular</span></div>
<div class="line"><span class="lineno">  354</span>                <span class="comment"># This branch implements Code Fragment 2.1 of [1]</span></div>
<div class="line"><span class="lineno">  355</span> </div>
<div class="line"><span class="lineno">  356</span>                diag_aw = np.diag(aw)</div>
<div class="line"><span class="lineno">  357</span>                <span class="comment"># einsum returns a writable view</span></div>
<div class="line"><span class="lineno">  358</span>                np.einsum(<span class="stringliteral">&#39;ii-&gt;i&#39;</span>, eAw)[:] = np.exp(diag_aw * 2**(-s))</div>
<div class="line"><span class="lineno">  359</span>                <span class="comment"># super/sub diagonal</span></div>
<div class="line"><span class="lineno">  360</span>                sd = np.diag(aw, k=-1 <span class="keywordflow">if</span> lu[1] == 0 <span class="keywordflow">else</span> 1)</div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(s-1, -1, -1):</div>
<div class="line"><span class="lineno">  363</span>                    eAw = eAw @ eAw</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>                    <span class="comment"># diagonal</span></div>
<div class="line"><span class="lineno">  366</span>                    np.einsum(<span class="stringliteral">&#39;ii-&gt;i&#39;</span>, eAw)[:] = np.exp(diag_aw * 2.**(-i))</div>
<div class="line"><span class="lineno">  367</span>                    exp_sd = _exp_sinch(diag_aw * (2.**(-i))) * (sd * 2**(-i))</div>
<div class="line"><span class="lineno">  368</span>                    <span class="keywordflow">if</span> lu[1] == 0:  <span class="comment"># lower</span></div>
<div class="line"><span class="lineno">  369</span>                        np.einsum(<span class="stringliteral">&#39;ii-&gt;i&#39;</span>, eAw[1:, :-1])[:] = exp_sd</div>
<div class="line"><span class="lineno">  370</span>                    <span class="keywordflow">else</span>:  <span class="comment"># upper</span></div>
<div class="line"><span class="lineno">  371</span>                        np.einsum(<span class="stringliteral">&#39;ii-&gt;i&#39;</span>, eAw[:-1, 1:])[:] = exp_sd</div>
<div class="line"><span class="lineno">  372</span> </div>
<div class="line"><span class="lineno">  373</span>            <span class="keywordflow">else</span>:  <span class="comment"># generic</span></div>
<div class="line"><span class="lineno">  374</span>                <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(s):</div>
<div class="line"><span class="lineno">  375</span>                    eAw = eAw @ eAw</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span>        <span class="comment"># Zero out the entries from np.empty in case of triangular input</span></div>
<div class="line"><span class="lineno">  378</span>        <span class="keywordflow">if</span> (lu[0] == 0) <span class="keywordflow">or</span> (lu[1] == 0):</div>
<div class="line"><span class="lineno">  379</span>            eA[ind] = np.triu(eAw) <span class="keywordflow">if</span> lu[0] == 0 <span class="keywordflow">else</span> np.tril(eAw)</div>
<div class="line"><span class="lineno">  380</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  381</span>            eA[ind] = eAw</div>
<div class="line"><span class="lineno">  382</span> </div>
<div class="line"><span class="lineno">  383</span>    <span class="keywordflow">return</span> eA</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab96d70c734b036dd8dbf7fb87e5978f1" name="ab96d70c734b036dd8dbf7fb87e5978f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96d70c734b036dd8dbf7fb87e5978f1">&#9670;&#160;</a></span>fractional_matrix_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.fractional_matrix_power </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix functions. </p>
<pre class="fragment">Compute the fractional power of a matrix.

Proceeds according to the discussion in section (6) of [1]_.

Parameters
----------
A : (N, N) array_like
    Matrix whose fractional power to evaluate.
t : float
    Fractional power.

Returns
-------
X : (N, N) array_like
    The fractional power of the matrix.

References
----------
.. [1] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798

Examples
--------
&gt;&gt;&gt; from scipy.linalg import fractional_matrix_power
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; b = fractional_matrix_power(a, 0.5)
&gt;&gt;&gt; b
array([[ 0.75592895,  1.13389342],
       [ 0.37796447,  1.88982237]])
&gt;&gt;&gt; np.dot(b, b)      # Verify square root
array([[ 1.,  3.],
       [ 1.,  4.]])</pre> <div class="fragment"><div class="line"><span class="lineno">   98</span><span class="keyword">def </span>fractional_matrix_power(A, t):</div>
<div class="line"><span class="lineno">   99</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    Compute the fractional power of a matrix.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    Proceeds according to the discussion in section (6) of [1]_.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        Matrix whose fractional power to evaluate.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    t : float</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        Fractional power.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    X : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        The fractional power of the matrix.</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    .. [1] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import fractional_matrix_power</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &gt;&gt;&gt; b = fractional_matrix_power(a, 0.5)</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    array([[ 0.75592895,  1.13389342],</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">           [ 0.37796447,  1.88982237]])</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(b, b)      # Verify square root</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    array([[ 1.,  3.],</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">           [ 1.,  4.]])</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  136</span>    <span class="comment"># This fixes some issue with imports;</span></div>
<div class="line"><span class="lineno">  137</span>    <span class="comment"># this function calls onenormest which is in scipy.sparse.</span></div>
<div class="line"><span class="lineno">  138</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  139</span>    <span class="keyword">import</span> <a class="code hl_namespace" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html">scipy.linalg._matfuncs_inv_ssq</a></div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#ad42f8a958adba7d7dc6afcb8d006823e">scipy.linalg._matfuncs_inv_ssq._fractional_matrix_power</a>(A, t)</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="ttc" id="anamespacescipy_1_1linalg_1_1__matfuncs__inv__ssq_html"><div class="ttname"><a href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html">scipy.linalg._matfuncs_inv_ssq</a></div><div class="ttdef"><b>Definition</b> _matfuncs_inv_ssq.py:1</div></div>
<div class="ttc" id="anamespacescipy_1_1linalg_1_1__matfuncs__inv__ssq_html_ad42f8a958adba7d7dc6afcb8d006823e"><div class="ttname"><a href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#ad42f8a958adba7d7dc6afcb8d006823e">scipy.linalg._matfuncs_inv_ssq._fractional_matrix_power</a></div><div class="ttdeci">_fractional_matrix_power(A, p)</div><div class="ttdef"><b>Definition</b> _matfuncs_inv_ssq.py:671</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a713ca22800d9fe9c00a5608be2c99c" name="a1a713ca22800d9fe9c00a5608be2c99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a713ca22800d9fe9c00a5608be2c99c">&#9670;&#160;</a></span>funm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.funm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a matrix function specified by a callable.

Returns the value of matrix-valued function ``f`` at `A`. The
function ``f`` is an extension of the scalar-valued function `func`
to matrices.

Parameters
----------
A : (N, N) array_like
    Matrix at which to evaluate the function
func : callable
    Callable object that evaluates a scalar function f.
    Must be vectorized (eg. using vectorize).
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
funm : (N, N) ndarray
    Value of the matrix function specified by func evaluated at `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

Examples
--------
&gt;&gt;&gt; from scipy.linalg import funm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; funm(a, lambda x: x*x)
array([[  4.,  15.],
       [  5.,  19.]])
&gt;&gt;&gt; a.dot(a)
array([[  4.,  15.],
       [  5.,  19.]])

Notes
-----
This function implements the general algorithm based on Schur decomposition
(Algorithm 9.1.1. in [1]_).

If the input matrix is known to be diagonalizable, then relying on the
eigendecomposition is likely to be faster. For example, if your matrix is
Hermitian, you can do

&gt;&gt;&gt; from scipy.linalg import eigh
&gt;&gt;&gt; def funm_herm(a, func, check_finite=False):
...     w, v = eigh(a, check_finite=check_finite)
...     ## if you further know that your matrix is positive semidefinite,
...     ## you can optionally guard against precision errors by doing
...     # w = np.maximum(w, 0)
...     w = func(w)
...     return (v * w).dot(v.conj().T)

References
----------
.. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.</pre> <div class="fragment"><div class="line"><span class="lineno">  626</span><span class="keyword">def </span>funm(A, func, disp=True):</div>
<div class="line"><span class="lineno">  627</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    Evaluate a matrix function specified by a callable.</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    Returns the value of matrix-valued function ``f`` at `A`. The</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    function ``f`` is an extension of the scalar-valued function `func`</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    to matrices.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        Matrix at which to evaluate the function</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    func : callable</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">        Callable object that evaluates a scalar function f.</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">        Must be vectorized (eg. using vectorize).</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        Print warning if error in the result is estimated large</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">        instead of returning estimated error. (Default: True)</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    funm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">        Value of the matrix function specified by func evaluated at `A`</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    errest : float</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">        (if disp == False)</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        1-norm of the estimated error, ||err||_1 / ||A||_1</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import funm</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    &gt;&gt;&gt; funm(a, lambda x: x*x)</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    array([[  4.,  15.],</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">           [  5.,  19.]])</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    &gt;&gt;&gt; a.dot(a)</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    array([[  4.,  15.],</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">           [  5.,  19.]])</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    This function implements the general algorithm based on Schur decomposition</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    (Algorithm 9.1.1. in [1]_).</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    If the input matrix is known to be diagonalizable, then relying on the</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    eigendecomposition is likely to be faster. For example, if your matrix is</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    Hermitian, you can do</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import eigh</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    &gt;&gt;&gt; def funm_herm(a, func, check_finite=False):</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    ...     w, v = eigh(a, check_finite=check_finite)</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    ...     ## if you further know that your matrix is positive semidefinite,</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    ...     ## you can optionally guard against precision errors by doing</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    ...     # w = np.maximum(w, 0)</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    ...     w = func(w)</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    ...     return (v * w).dot(v.conj().T)</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    .. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  688</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  689</span>    <span class="comment"># Perform Shur decomposition (lapack ?gees)</span></div>
<div class="line"><span class="lineno">  690</span>    T, Z = schur(A)</div>
<div class="line"><span class="lineno">  691</span>    T, Z = rsf2csf(T,Z)</div>
<div class="line"><span class="lineno">  692</span>    n,n = T.shape</div>
<div class="line"><span class="lineno">  693</span>    F = diag(<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(diag(T)))  <span class="comment"># apply function to diagonal elements</span></div>
<div class="line"><span class="lineno">  694</span>    F = F.astype(T.dtype.char)  <span class="comment"># e.g., when F is real but T is complex</span></div>
<div class="line"><span class="lineno">  695</span> </div>
<div class="line"><span class="lineno">  696</span>    minden = abs(T[0,0])</div>
<div class="line"><span class="lineno">  697</span> </div>
<div class="line"><span class="lineno">  698</span>    <span class="comment"># implement Algorithm 11.1.1 from Golub and Van Loan</span></div>
<div class="line"><span class="lineno">  699</span>    <span class="comment">#                 &quot;matrix Computations.&quot;</span></div>
<div class="line"><span class="lineno">  700</span>    <span class="keywordflow">for</span> p <span class="keywordflow">in</span> range(1,n):</div>
<div class="line"><span class="lineno">  701</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1,n-p+1):</div>
<div class="line"><span class="lineno">  702</span>            j = i + p</div>
<div class="line"><span class="lineno">  703</span>            s = T[i-1,j-1] * (F[j-1,j-1] - F[i-1,i-1])</div>
<div class="line"><span class="lineno">  704</span>            ksl = slice(i,j-1)</div>
<div class="line"><span class="lineno">  705</span>            val = dot(T[i-1,ksl],F[ksl,j-1]) - dot(F[i-1,ksl],T[ksl,j-1])</div>
<div class="line"><span class="lineno">  706</span>            s = s + val</div>
<div class="line"><span class="lineno">  707</span>            den = T[j-1,j-1] - T[i-1,i-1]</div>
<div class="line"><span class="lineno">  708</span>            <span class="keywordflow">if</span> den != 0.0:</div>
<div class="line"><span class="lineno">  709</span>                s = s / den</div>
<div class="line"><span class="lineno">  710</span>            F[i-1,j-1] = s</div>
<div class="line"><span class="lineno">  711</span>            minden = min(minden,abs(den))</div>
<div class="line"><span class="lineno">  712</span> </div>
<div class="line"><span class="lineno">  713</span>    F = dot(dot(Z, F), transpose(conjugate(Z)))</div>
<div class="line"><span class="lineno">  714</span>    F = _maybe_real(A, F)</div>
<div class="line"><span class="lineno">  715</span> </div>
<div class="line"><span class="lineno">  716</span>    tol = {0:feps, 1:eps}[_array_precision[F.dtype.char]]</div>
<div class="line"><span class="lineno">  717</span>    <span class="keywordflow">if</span> minden == 0.0:</div>
<div class="line"><span class="lineno">  718</span>        minden = tol</div>
<div class="line"><span class="lineno">  719</span>    err = min(1, max(tol,(tol/minden)*norm(triu(T,1),1)))</div>
<div class="line"><span class="lineno">  720</span>    <span class="keywordflow">if</span> prod(ravel(logical_not(isfinite(F))),axis=0):</div>
<div class="line"><span class="lineno">  721</span>        err = Inf</div>
<div class="line"><span class="lineno">  722</span>    <span class="keywordflow">if</span> disp:</div>
<div class="line"><span class="lineno">  723</span>        <span class="keywordflow">if</span> err &gt; 1000*tol:</div>
<div class="line"><span class="lineno">  724</span>            print(<span class="stringliteral">&quot;funm result may be inaccurate, approximate err =&quot;</span>, err)</div>
<div class="line"><span class="lineno">  725</span>        <span class="keywordflow">return</span> F</div>
<div class="line"><span class="lineno">  726</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  727</span>        <span class="keywordflow">return</span> F, err</div>
<div class="line"><span class="lineno">  728</span> </div>
<div class="line"><span class="lineno">  729</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeaab816e6d56905a12a502b211a5e7ff" name="aeaab816e6d56905a12a502b211a5e7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaab816e6d56905a12a502b211a5e7ff">&#9670;&#160;</a></span>khatri_rao()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.khatri_rao </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Khatri-rao product

A column-wise Kronecker product of two matrices

Parameters
----------
a : (n, k) array_like
    Input array
b : (m, k) array_like
    Input array

Returns
-------
c:  (n*m, k) ndarray
    Khatri-rao product of `a` and `b`.

Notes
-----
The mathematical definition of the Khatri-Rao product is:

.. math::

    (A_{ij}  \bigotimes B_{ij})_{ij}

which is the Kronecker product of every column of A and B, e.g.::

    c = np.vstack([np.kron(a[:, k], b[:, k]) for k in range(b.shape[1])]).T

See Also
--------
kron : Kronecker product

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; b = np.array([[3, 4, 5], [6, 7, 8], [2, 3, 9]])
&gt;&gt;&gt; linalg.khatri_rao(a, b)
array([[ 3,  8, 15],
       [ 6, 14, 24],
       [ 2,  6, 27],
       [12, 20, 30],
       [24, 35, 48],
       [ 8, 15, 54]])</pre> <div class="fragment"><div class="line"><span class="lineno">  810</span><span class="keyword">def </span>khatri_rao(a, b):</div>
<div class="line"><span class="lineno">  811</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    Khatri-rao product</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    A column-wise Kronecker product of two matrices</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    a : (n, k) array_like</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    b : (m, k) array_like</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    c:  (n*m, k) ndarray</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        Khatri-rao product of `a` and `b`.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    The mathematical definition of the Khatri-Rao product is:</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        (A_{ij}  \bigotimes B_{ij})_{ij}</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    which is the Kronecker product of every column of A and B, e.g.::</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">        c = np.vstack([np.kron(a[:, k], b[:, k]) for k in range(b.shape[1])]).T</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    kron : Kronecker product</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import linalg</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[3, 4, 5], [6, 7, 8], [2, 3, 9]])</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    &gt;&gt;&gt; linalg.khatri_rao(a, b)</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    array([[ 3,  8, 15],</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">           [ 6, 14, 24],</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">           [ 2,  6, 27],</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">           [12, 20, 30],</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">           [24, 35, 48],</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">           [ 8, 15, 54]])</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  858</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno">  859</span>    b = np.asarray(b)</div>
<div class="line"><span class="lineno">  860</span> </div>
<div class="line"><span class="lineno">  861</span>    <span class="keywordflow">if</span> not(a.ndim == 2 <span class="keywordflow">and</span> b.ndim == 2):</div>
<div class="line"><span class="lineno">  862</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The both arrays should be 2-dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno">  863</span> </div>
<div class="line"><span class="lineno">  864</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> a.shape[1] == b.shape[1]:</div>
<div class="line"><span class="lineno">  865</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The number of columns for both arrays &quot;</span></div>
<div class="line"><span class="lineno">  866</span>                         <span class="stringliteral">&quot;should be equal.&quot;</span>)</div>
<div class="line"><span class="lineno">  867</span> </div>
<div class="line"><span class="lineno">  868</span>    <span class="comment"># c = np.vstack([np.kron(a[:, k], b[:, k]) for k in range(b.shape[1])]).T</span></div>
<div class="line"><span class="lineno">  869</span>    c = a[..., :, np.newaxis, :] * b[..., np.newaxis, :, :]</div>
<div class="line"><span class="lineno">  870</span>    <span class="keywordflow">return</span> c.reshape((-1,) + c.shape[2:])</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4dc544afa3b784dda9f742dc92abc723" name="a4dc544afa3b784dda9f742dc92abc723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc544afa3b784dda9f742dc92abc723">&#9670;&#160;</a></span>logm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.logm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute matrix logarithm.

The matrix logarithm is the inverse of
expm: expm(logm(`A`)) == `A`

Parameters
----------
A : (N, N) array_like
    Matrix whose logarithm to evaluate
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
logm : (N, N) ndarray
    Matrix logarithm of `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
       "Improved Inverse Scaling and Squaring Algorithms
       for the Matrix Logarithm."
       SIAM Journal on Scientific Computing, 34 (4). C152-C169.
       ISSN 1095-7197

.. [2] Nicholas J. Higham (2008)
       "Functions of Matrices: Theory and Computation"
       ISBN 978-0-898716-46-7

.. [3] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798

Examples
--------
&gt;&gt;&gt; from scipy.linalg import logm, expm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; b = logm(a)
&gt;&gt;&gt; b
array([[-1.02571087,  2.05142174],
       [ 0.68380725,  1.02571087]])
&gt;&gt;&gt; expm(b)         # Verify expm(logm(a)) returns a
array([[ 1.,  3.],
       [ 1.,  4.]])</pre> <div class="fragment"><div class="line"><span class="lineno">  143</span><span class="keyword">def </span>logm(A, disp=True):</div>
<div class="line"><span class="lineno">  144</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    Compute matrix logarithm.</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    The matrix logarithm is the inverse of</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    expm: expm(logm(`A`)) == `A`</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        Matrix whose logarithm to evaluate</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        Print warning if error in the result is estimated large</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">        instead of returning estimated error. (Default: True)</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    logm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        Matrix logarithm of `A`</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    errest : float</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">        (if disp == False)</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        1-norm of the estimated error, ||err||_1 / ||A||_1</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">           &quot;Improved Inverse Scaling and Squaring Algorithms</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">           for the Matrix Logarithm.&quot;</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">           SIAM Journal on Scientific Computing, 34 (4). C152-C169.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">           ISSN 1095-7197</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    .. [2] Nicholas J. Higham (2008)</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">           &quot;Functions of Matrices: Theory and Computation&quot;</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">           ISBN 978-0-898716-46-7</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    .. [3] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import logm, expm</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    &gt;&gt;&gt; b = logm(a)</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    array([[-1.02571087,  2.05142174],</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">           [ 0.68380725,  1.02571087]])</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    &gt;&gt;&gt; expm(b)         # Verify expm(logm(a)) returns a</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    array([[ 1.,  3.],</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">           [ 1.,  4.]])</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  197</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  198</span>    <span class="comment"># Avoid circular import ... this is OK, right?</span></div>
<div class="line"><span class="lineno">  199</span>    <span class="keyword">import</span> <a class="code hl_namespace" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html">scipy.linalg._matfuncs_inv_ssq</a></div>
<div class="line"><span class="lineno">  200</span>    F = <a class="code hl_function" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a8f65c2252da70eeedd5e2a66036df70d">scipy.linalg._matfuncs_inv_ssq._logm</a>(A)</div>
<div class="line"><span class="lineno">  201</span>    F = _maybe_real(A, F)</div>
<div class="line"><span class="lineno">  202</span>    errtol = 1000*eps</div>
<div class="line"><span class="lineno">  203</span>    <span class="comment">#TODO use a better error approximation</span></div>
<div class="line"><span class="lineno">  204</span>    errest = norm(expm(F)-A,1) / norm(A,1)</div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">if</span> disp:</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isfinite(errest) <span class="keywordflow">or</span> errest &gt;= errtol:</div>
<div class="line"><span class="lineno">  207</span>            print(<span class="stringliteral">&quot;logm result may be inaccurate, approximate err =&quot;</span>, errest)</div>
<div class="line"><span class="lineno">  208</span>        <span class="keywordflow">return</span> F</div>
<div class="line"><span class="lineno">  209</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  210</span>        <span class="keywordflow">return</span> F, errest</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span> </div>
<div class="ttc" id="anamespacescipy_1_1linalg_1_1__matfuncs__inv__ssq_html_a8f65c2252da70eeedd5e2a66036df70d"><div class="ttname"><a href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a8f65c2252da70eeedd5e2a66036df70d">scipy.linalg._matfuncs_inv_ssq._logm</a></div><div class="ttdeci">_logm(A)</div><div class="ttdef"><b>Definition</b> _matfuncs_inv_ssq.py:840</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a241dd03afab2072a15bdccb481bf5812" name="a241dd03afab2072a15bdccb481bf5812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241dd03afab2072a15bdccb481bf5812">&#9670;&#160;</a></span>signm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.signm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Matrix sign function.

Extension of the scalar sign(x) to matrices.

Parameters
----------
A : (N, N) array_like
    Matrix at which to evaluate the sign function
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
signm : (N, N) ndarray
    Value of the sign function at `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

Examples
--------
&gt;&gt;&gt; from scipy.linalg import signm, eigvals
&gt;&gt;&gt; a = [[1,2,3], [1,2,1], [1,1,1]]
&gt;&gt;&gt; eigvals(a)
array([ 4.12488542+0.j, -0.76155718+0.j,  0.63667176+0.j])
&gt;&gt;&gt; eigvals(signm(a))
array([-1.+0.j,  1.+0.j,  1.+0.j])</pre> <div class="fragment"><div class="line"><span class="lineno">  730</span><span class="keyword">def </span>signm(A, disp=True):</div>
<div class="line"><span class="lineno">  731</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    Matrix sign function.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    Extension of the scalar sign(x) to matrices.</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        Matrix at which to evaluate the sign function</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    disp : bool, optional</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">        Print warning if error in the result is estimated large</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">        instead of returning estimated error. (Default: True)</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    signm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        Value of the sign function at `A`</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    errest : float</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        (if disp == False)</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        1-norm of the estimated error, ||err||_1 / ||A||_1</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import signm, eigvals</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    &gt;&gt;&gt; a = [[1,2,3], [1,2,1], [1,1,1]]</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    &gt;&gt;&gt; eigvals(a)</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    array([ 4.12488542+0.j, -0.76155718+0.j,  0.63667176+0.j])</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    &gt;&gt;&gt; eigvals(signm(a))</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    array([-1.+0.j,  1.+0.j,  1.+0.j])</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  763</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span>    <span class="keyword">def </span>rounded_sign(x):</div>
<div class="line"><span class="lineno">  766</span>        rx = np.real(x)</div>
<div class="line"><span class="lineno">  767</span>        <span class="keywordflow">if</span> rx.dtype.char == <span class="stringliteral">&#39;f&#39;</span>:</div>
<div class="line"><span class="lineno">  768</span>            c = 1e3*feps*amax(x)</div>
<div class="line"><span class="lineno">  769</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  770</span>            c = 1e3*eps*amax(x)</div>
<div class="line"><span class="lineno">  771</span>        <span class="keywordflow">return</span> sign((absolute(rx) &gt; c) * rx)</div>
<div class="line"><span class="lineno">  772</span>    result, errest = funm(A, rounded_sign, disp=0)</div>
<div class="line"><span class="lineno">  773</span>    errtol = {0:1e3*feps, 1:1e3*eps}[_array_precision[result.dtype.char]]</div>
<div class="line"><span class="lineno">  774</span>    <span class="keywordflow">if</span> errest &lt; errtol:</div>
<div class="line"><span class="lineno">  775</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span>    <span class="comment"># Handle signm of defective matrices:</span></div>
<div class="line"><span class="lineno">  778</span> </div>
<div class="line"><span class="lineno">  779</span>    <span class="comment"># See &quot;E.D.Denman and J.Leyva-Ramos, Appl.Math.Comp.,</span></div>
<div class="line"><span class="lineno">  780</span>    <span class="comment"># 8:237-250,1981&quot; for how to improve the following (currently a</span></div>
<div class="line"><span class="lineno">  781</span>    <span class="comment"># rather naive) iteration process:</span></div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>    <span class="comment"># a = result # sometimes iteration converges faster but where??</span></div>
<div class="line"><span class="lineno">  784</span> </div>
<div class="line"><span class="lineno">  785</span>    <span class="comment"># Shifting to avoid zero eigenvalues. How to ensure that shifting does</span></div>
<div class="line"><span class="lineno">  786</span>    <span class="comment"># not change the spectrum too much?</span></div>
<div class="line"><span class="lineno">  787</span>    vals = svd(A, compute_uv=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  788</span>    max_sv = np.amax(vals)</div>
<div class="line"><span class="lineno">  789</span>    <span class="comment"># min_nonzero_sv = vals[(vals&gt;max_sv*errtol).tolist().count(1)-1]</span></div>
<div class="line"><span class="lineno">  790</span>    <span class="comment"># c = 0.5/min_nonzero_sv</span></div>
<div class="line"><span class="lineno">  791</span>    c = 0.5/max_sv</div>
<div class="line"><span class="lineno">  792</span>    S0 = A + c*np.identity(A.shape[0])</div>
<div class="line"><span class="lineno">  793</span>    prev_errest = errest</div>
<div class="line"><span class="lineno">  794</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(100):</div>
<div class="line"><span class="lineno">  795</span>        iS0 = inv(S0)</div>
<div class="line"><span class="lineno">  796</span>        S0 = 0.5*(S0 + iS0)</div>
<div class="line"><span class="lineno">  797</span>        Pp = 0.5*(dot(S0,S0)+S0)</div>
<div class="line"><span class="lineno">  798</span>        errest = norm(dot(Pp,Pp)-Pp,1)</div>
<div class="line"><span class="lineno">  799</span>        <span class="keywordflow">if</span> errest &lt; errtol <span class="keywordflow">or</span> prev_errest == errest:</div>
<div class="line"><span class="lineno">  800</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  801</span>        prev_errest = errest</div>
<div class="line"><span class="lineno">  802</span>    <span class="keywordflow">if</span> disp:</div>
<div class="line"><span class="lineno">  803</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isfinite(errest) <span class="keywordflow">or</span> errest &gt;= errtol:</div>
<div class="line"><span class="lineno">  804</span>            print(<span class="stringliteral">&quot;signm result may be inaccurate, approximate err =&quot;</span>, errest)</div>
<div class="line"><span class="lineno">  805</span>        <span class="keywordflow">return</span> S0</div>
<div class="line"><span class="lineno">  806</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  807</span>        <span class="keywordflow">return</span> S0, errest</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5b85f6f126ab691a7864badfd995171" name="ae5b85f6f126ab691a7864badfd995171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b85f6f126ab691a7864badfd995171">&#9670;&#160;</a></span>sinhm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.sinhm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the hyperbolic matrix sine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
sinhm : (N, N) ndarray
    Hyperbolic matrix sine of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; s = sinhm(a)
&gt;&gt;&gt; s
array([[ 10.57300653,  39.28826594],
       [ 13.09608865,  49.86127247]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

&gt;&gt;&gt; t = tanhm(a)
&gt;&gt;&gt; c = coshm(a)
&gt;&gt;&gt; t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])</pre> <div class="fragment"><div class="line"><span class="lineno">  550</span><span class="keyword">def </span>sinhm(A):</div>
<div class="line"><span class="lineno">  551</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    Compute the hyperbolic matrix sine.</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    This routine uses expm to compute the matrix exponentials.</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    sinhm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">        Hyperbolic matrix sine of `A`</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    &gt;&gt;&gt; s = sinhm(a)</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    array([[ 10.57300653,  39.28826594],</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">           [ 13.09608865,  49.86127247]])</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    &gt;&gt;&gt; t = tanhm(a)</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    &gt;&gt;&gt; c = coshm(a)</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    &gt;&gt;&gt; t - s.dot(np.linalg.inv(c))</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    array([[  2.72004641e-15,   4.55191440e-15],</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">           [  0.00000000e+00,  -5.55111512e-16]])</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  584</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  585</span>    <span class="keywordflow">return</span> _maybe_real(A, 0.5 * (expm(A) - expm(-A)))</div>
<div class="line"><span class="lineno">  586</span> </div>
<div class="line"><span class="lineno">  587</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e99a09f6c589271840bfd95e5b486a2" name="a8e99a09f6c589271840bfd95e5b486a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e99a09f6c589271840bfd95e5b486a2">&#9670;&#160;</a></span>sinm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.sinm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the matrix sine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
sinm : (N, N) ndarray
    Matrix sine of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

&gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])
&gt;&gt;&gt; expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
&gt;&gt;&gt; cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</pre> <div class="fragment"><div class="line"><span class="lineno">  435</span><span class="keyword">def </span>sinm(A):</div>
<div class="line"><span class="lineno">  436</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    Compute the matrix sine.</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    This routine uses expm to compute the matrix exponentials.</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    sinm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        Matrix sine of `A`</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    Euler&#39;s identity (exp(i*theta) = cos(theta) + i*sin(theta))</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    applied to a matrix:</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    &gt;&gt;&gt; expm(1j*a)</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">           [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    &gt;&gt;&gt; cosm(a) + 1j*sinm(a)</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">           [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  467</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  468</span>    <span class="keywordflow">if</span> np.iscomplexobj(A):</div>
<div class="line"><span class="lineno">  469</span>        <span class="keywordflow">return</span> -0.5j*(expm(1j*A) - expm(-1j*A))</div>
<div class="line"><span class="lineno">  470</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  471</span>        <span class="keywordflow">return</span> expm(1j*A).imag</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4aa2595514d8229c828e71e95adbc282" name="a4aa2595514d8229c828e71e95adbc282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa2595514d8229c828e71e95adbc282">&#9670;&#160;</a></span>tanhm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.tanhm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the hyperbolic matrix tangent.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array

Returns
-------
tanhm : (N, N) ndarray
    Hyperbolic matrix tangent of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; t = tanhm(a)
&gt;&gt;&gt; t
array([[ 0.3428582 ,  0.51987926],
       [ 0.17329309,  0.86273746]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

&gt;&gt;&gt; s = sinhm(a)
&gt;&gt;&gt; c = coshm(a)
&gt;&gt;&gt; t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])</pre> <div class="fragment"><div class="line"><span class="lineno">  588</span><span class="keyword">def </span>tanhm(A):</div>
<div class="line"><span class="lineno">  589</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    Compute the hyperbolic matrix tangent.</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    This routine uses expm to compute the matrix exponentials.</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    tanhm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        Hyperbolic matrix tangent of `A`</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    &gt;&gt;&gt; t = tanhm(a)</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    &gt;&gt;&gt; t</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    array([[ 0.3428582 ,  0.51987926],</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">           [ 0.17329309,  0.86273746]])</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    &gt;&gt;&gt; s = sinhm(a)</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    &gt;&gt;&gt; c = coshm(a)</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    &gt;&gt;&gt; t - s.dot(np.linalg.inv(c))</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    array([[  2.72004641e-15,   4.55191440e-15],</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">           [  0.00000000e+00,  -5.55111512e-16]])</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  622</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  623</span>    <span class="keywordflow">return</span> _maybe_real(A, solve(coshm(A), sinhm(A)))</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad78ae302b448227e7da621691243e3e4" name="ad78ae302b448227e7da621691243e3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78ae302b448227e7da621691243e3e4">&#9670;&#160;</a></span>tanm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.tanm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the matrix tangent.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
tanm : (N, N) ndarray
    Matrix tangent of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanm, sinm, cosm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; t = tanm(a)
&gt;&gt;&gt; t
array([[ -2.00876993,  -8.41880636],
       [ -2.80626879, -10.42757629]])

Verify tanm(a) = sinm(a).dot(inv(cosm(a)))

&gt;&gt;&gt; s = sinm(a)
&gt;&gt;&gt; c = cosm(a)
&gt;&gt;&gt; s.dot(np.linalg.inv(c))
array([[ -2.00876993,  -8.41880636],
       [ -2.80626879, -10.42757629]])</pre> <div class="fragment"><div class="line"><span class="lineno">  474</span><span class="keyword">def </span>tanm(A):</div>
<div class="line"><span class="lineno">  475</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    Compute the matrix tangent.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    This routine uses expm to compute the matrix exponentials.</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    tanm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        Matrix tangent of `A`</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.linalg import tanm, sinm, cosm</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    &gt;&gt;&gt; t = tanm(a)</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    &gt;&gt;&gt; t</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    array([[ -2.00876993,  -8.41880636],</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">           [ -2.80626879, -10.42757629]])</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    Verify tanm(a) = sinm(a).dot(inv(cosm(a)))</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    &gt;&gt;&gt; s = sinm(a)</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    &gt;&gt;&gt; c = cosm(a)</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    &gt;&gt;&gt; s.dot(np.linalg.inv(c))</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    array([[ -2.00876993,  -8.41880636],</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">           [ -2.80626879, -10.42757629]])</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  508</span>    A = _asarray_square(A)</div>
<div class="line"><span class="lineno">  509</span>    <span class="keywordflow">return</span> _maybe_real(A, solve(cosm(A), sinm(A)))</div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acb829b26a93c85b6faab8111d76b6b2c" name="acb829b26a93c85b6faab8111d76b6b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb829b26a93c85b6faab8111d76b6b2c">&#9670;&#160;</a></span>_array_precision</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.linalg._matfuncs._array_precision = {'<a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>': 1, 'l': 1, '<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>': 0, '<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>': 1, 'F': 0, 'D': 1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a836b45113aeaa4577c5a7d2fed5a5969" name="a836b45113aeaa4577c5a7d2fed5a5969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836b45113aeaa4577c5a7d2fed5a5969">&#9670;&#160;</a></span>eps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.eps = np.finfo('<a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>').eps</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dcda5082d96e3a0d6ce409f93b72e71" name="a1dcda5082d96e3a0d6ce409f93b72e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcda5082d96e3a0d6ce409f93b72e71">&#9670;&#160;</a></span>feps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs.feps = np.finfo('<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>').<a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs.html#a836b45113aeaa4577c5a7d2fed5a5969">eps</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
