<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.fft._helper Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1fft.html">fft</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1fft_1_1__helper.html">_helper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.fft._helper Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a513f7a731a170da6474469096b1db215" id="r_a513f7a731a170da6474469096b1db215"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fft_1_1__helper.html#a513f7a731a170da6474469096b1db215">next_fast_len</a> (target, real=False)</td></tr>
<tr class="separator:a513f7a731a170da6474469096b1db215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a965875a7b6c085f77ad66eec1d0db8" id="r_a0a965875a7b6c085f77ad66eec1d0db8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fft_1_1__helper.html#a0a965875a7b6c085f77ad66eec1d0db8">_init_nd_shape_and_axes</a> (x, shape, axes)</td></tr>
<tr class="separator:a0a965875a7b6c085f77ad66eec1d0db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aff29bf5fa24dce5e726f6a68e9a9004e" id="r_aff29bf5fa24dce5e726f6a68e9a9004e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fft_1_1__helper.html#aff29bf5fa24dce5e726f6a68e9a9004e">next_fast_len</a> = update_wrapper(lru_cache()(_helper.good_size), next_fast_len)</td></tr>
<tr class="separator:aff29bf5fa24dce5e726f6a68e9a9004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0a965875a7b6c085f77ad66eec1d0db8" name="a0a965875a7b6c085f77ad66eec1d0db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a965875a7b6c085f77ad66eec1d0db8">&#9670;&#160;</a></span>_init_nd_shape_and_axes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.fft._helper._init_nd_shape_and_axes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Handle shape and axes arguments for N-D transforms.

Returns the shape and axes in a standard form, taking into account negative
values and checking for various potential errors.

Parameters
----------
x : array_like
    The input array.
shape : int or array_like of ints or None
    The shape of the result. If both `shape` and `axes` (see below) are
    None, `shape` is ``x.shape``; if `shape` is None but `axes` is
    not None, then `shape` is ``numpy.take(x.shape, axes, axis=0)``.
    If `shape` is -1, the size of the corresponding dimension of `x` is
    used.
axes : int or array_like of ints or None
    Axes along which the calculation is computed.
    The default is over all axes.
    Negative indices are automatically converted to their positive
    counterparts.

Returns
-------
shape : array
    The shape of the result. It is a 1-D integer array.
axes : array
    The shape of the result. It is a 1-D integer array.</pre> <div class="fragment"><div class="line"><span class="lineno">   70</span><span class="keyword">def </span>_init_nd_shape_and_axes(x, shape, axes):</div>
<div class="line"><span class="lineno">   71</span>    <span class="stringliteral">&quot;&quot;&quot;Handle shape and axes arguments for N-D transforms.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    Returns the shape and axes in a standard form, taking into account negative</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    values and checking for various potential errors.</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        The input array.</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    shape : int or array_like of ints or None</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">        The shape of the result. If both `shape` and `axes` (see below) are</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        None, `shape` is ``x.shape``; if `shape` is None but `axes` is</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">        not None, then `shape` is ``numpy.take(x.shape, axes, axis=0)``.</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        If `shape` is -1, the size of the corresponding dimension of `x` is</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        used.</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    axes : int or array_like of ints or None</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        Axes along which the calculation is computed.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        The default is over all axes.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        Negative indices are automatically converted to their positive</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        counterparts.</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    shape : array</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        The shape of the result. It is a 1-D integer array.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    axes : array</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        The shape of the result. It is a 1-D integer array.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">return</span> _helper._init_nd_shape_and_axes(x, shape, axes)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a513f7a731a170da6474469096b1db215" name="a513f7a731a170da6474469096b1db215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513f7a731a170da6474469096b1db215">&#9670;&#160;</a></span>next_fast_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.fft._helper.next_fast_len </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>real</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the next fast size of input data to ``fft``, for zero-padding, etc.

SciPy's FFT algorithms gain their speed by a recursive divide and conquer
strategy. This relies on efficient functions for small prime factors of the
input length. Thus, the transforms are fastest when using composites of the
prime factors handled by the fft implementation. If there are efficient
functions for all radices &lt;= `n`, then the result will be a number `x`
&gt;= ``target`` with only prime factors &lt; `n`. (Also known as `n`-smooth
numbers)

Parameters
----------
target : int
    Length to start searching from. Must be a positive integer.
real : bool, optional
    True if the FFT involves real input or output (e.g., `rfft` or `hfft`
    but not `fft`). Defaults to False.

Returns
-------
out : int
    The smallest fast length greater than or equal to ``target``.

Notes
-----
The result of this function may change in future as performance
considerations change, for example, if new prime factors are added.

Calling `fft` or `ifft` with real input data performs an ``'R2C'``
transform internally.

Examples
--------
On a particular machine, an FFT of prime length takes 11.4 ms:

&gt;&gt;&gt; from scipy import fft
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; min_len = 93059  # prime length is worst case for speed
&gt;&gt;&gt; a = rng.standard_normal(min_len)
&gt;&gt;&gt; b = fft.fft(a)

Zero-padding to the next regular length reduces computation time to
1.6 ms, a speedup of 7.3 times:

&gt;&gt;&gt; fft.next_fast_len(min_len, real=True)
93312
&gt;&gt;&gt; b = fft.fft(a, 93312)

Rounding up to the next power of 2 is not optimal, taking 3.0 ms to
compute; 1.9 times longer than the size given by ``next_fast_len``:

&gt;&gt;&gt; b = fft.fft(a, 131072)</pre> <div class="fragment"><div class="line"><span class="lineno">    6</span><span class="keyword">def </span>next_fast_len(target, real=False):</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;&quot;&quot;Find the next fast size of input data to ``fft``, for zero-padding, etc.</span></div>
<div class="line"><span class="lineno">    8</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">    9</span><span class="stringliteral">    SciPy&#39;s FFT algorithms gain their speed by a recursive divide and conquer</span></div>
<div class="line"><span class="lineno">   10</span><span class="stringliteral">    strategy. This relies on efficient functions for small prime factors of the</span></div>
<div class="line"><span class="lineno">   11</span><span class="stringliteral">    input length. Thus, the transforms are fastest when using composites of the</span></div>
<div class="line"><span class="lineno">   12</span><span class="stringliteral">    prime factors handled by the fft implementation. If there are efficient</span></div>
<div class="line"><span class="lineno">   13</span><span class="stringliteral">    functions for all radices &lt;= `n`, then the result will be a number `x`</span></div>
<div class="line"><span class="lineno">   14</span><span class="stringliteral">    &gt;= ``target`` with only prime factors &lt; `n`. (Also known as `n`-smooth</span></div>
<div class="line"><span class="lineno">   15</span><span class="stringliteral">    numbers)</span></div>
<div class="line"><span class="lineno">   16</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   17</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   18</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral">    target : int</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral">        Length to start searching from. Must be a positive integer.</span></div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral">    real : bool, optional</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">        True if the FFT involves real input or output (e.g., `rfft` or `hfft`</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">        but not `fft`). Defaults to False.</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    out : int</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">        The smallest fast length greater than or equal to ``target``.</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    The result of this function may change in future as performance</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    considerations change, for example, if new prime factors are added.</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    Calling `fft` or `ifft` with real input data performs an ``&#39;R2C&#39;``</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    transform internally.</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    On a particular machine, an FFT of prime length takes 11.4 ms:</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import fft</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    &gt;&gt;&gt; min_len = 93059  # prime length is worst case for speed</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    &gt;&gt;&gt; a = rng.standard_normal(min_len)</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    &gt;&gt;&gt; b = fft.fft(a)</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    Zero-padding to the next regular length reduces computation time to</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    1.6 ms, a speedup of 7.3 times:</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    &gt;&gt;&gt; fft.next_fast_len(min_len, real=True)</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    93312</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    &gt;&gt;&gt; b = fft.fft(a, 93312)</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    Rounding up to the next power of 2 is not optimal, taking 3.0 ms to</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    compute; 1.9 times longer than the size given by ``next_fast_len``:</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    &gt;&gt;&gt; b = fft.fft(a, 131072)</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   61</span>    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span> </div>
<div class="line"><span class="lineno">   64</span><span class="comment"># Directly wrap the c-function good_size but take the docstring etc., from the</span></div>
<div class="line"><span class="lineno">   65</span><span class="comment"># next_fast_len function above</span></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aff29bf5fa24dce5e726f6a68e9a9004e" name="aff29bf5fa24dce5e726f6a68e9a9004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff29bf5fa24dce5e726f6a68e9a9004e">&#9670;&#160;</a></span>next_fast_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.fft._helper.next_fast_len = update_wrapper(lru_cache()(_helper.good_size), next_fast_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
