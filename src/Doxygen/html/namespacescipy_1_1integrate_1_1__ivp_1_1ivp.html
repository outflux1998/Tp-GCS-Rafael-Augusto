<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.integrate._ivp.ivp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1integrate.html">integrate</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp.html">_ivp</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html">ivp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.integrate._ivp.ivp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1integrate_1_1__ivp_1_1ivp_1_1_ode_result.html">OdeResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2bd524e6874fbf3d7eb6197e22f391f7" id="r_a2bd524e6874fbf3d7eb6197e22f391f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html#a2bd524e6874fbf3d7eb6197e22f391f7">prepare_events</a> (events)</td></tr>
<tr class="separator:a2bd524e6874fbf3d7eb6197e22f391f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69a224cb82ae44c7221aec878313de6" id="r_af69a224cb82ae44c7221aec878313de6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html#af69a224cb82ae44c7221aec878313de6">solve_event_equation</a> (event, sol, t_old, t)</td></tr>
<tr class="separator:af69a224cb82ae44c7221aec878313de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e233bb8153b216ec17cdda179d98da2" id="r_a2e233bb8153b216ec17cdda179d98da2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html#a2e233bb8153b216ec17cdda179d98da2">handle_events</a> (sol, events, active_events, is_terminal, t_old, t)</td></tr>
<tr class="separator:a2e233bb8153b216ec17cdda179d98da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb40a6f493108b392e598070ec378dc" id="r_aedb40a6f493108b392e598070ec378dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html#aedb40a6f493108b392e598070ec378dc">find_active_events</a> (<a class="el" href="__lapack__subroutines_8h.html#aeb0d2dd2a2609d5775607acf542b2161">g</a>, g_new, direction)</td></tr>
<tr class="separator:aedb40a6f493108b392e598070ec378dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f365255db6d7cf4fcfeebdcc68ec11e" id="r_a2f365255db6d7cf4fcfeebdcc68ec11e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html#a2f365255db6d7cf4fcfeebdcc68ec11e">solve_ivp</a> (fun, t_span, <a class="el" href="__ufuncs__defs_8h.html#a5bbf55bb92a1d8c0de447a483a82f1e2">y0</a>, method='<a class="el" href="classscipy_1_1integrate_1_1__ivp_1_1rk_1_1_r_k45.html">RK45</a>', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options)</td></tr>
<tr class="separator:a2f365255db6d7cf4fcfeebdcc68ec11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a80440f90e45322aa39e237b7055ce687" id="r_a80440f90e45322aa39e237b7055ce687"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html#a80440f90e45322aa39e237b7055ce687">METHODS</a></td></tr>
<tr class="separator:a80440f90e45322aa39e237b7055ce687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fea86006b69f5100e628e463bff7a2" id="r_ae1fea86006b69f5100e628e463bff7a2"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html#ae1fea86006b69f5100e628e463bff7a2">MESSAGES</a></td></tr>
<tr class="separator:ae1fea86006b69f5100e628e463bff7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aedb40a6f493108b392e598070ec378dc" name="aedb40a6f493108b392e598070ec378dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb40a6f493108b392e598070ec378dc">&#9670;&#160;</a></span>find_active_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.find_active_events </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find which event occurred during an integration step.

Parameters
----------
g, g_new : array_like, shape (n_events,)
    Values of event functions at a current and next points.
direction : ndarray, shape (n_events,)
    Event "direction" according to the definition in `solve_ivp`.

Returns
-------
active_events : ndarray
    Indices of events which occurred during the step.
</pre> <div class="fragment"><div class="line"><span class="lineno">  130</span><span class="keyword">def </span>find_active_events(g, g_new, direction):</div>
<div class="line"><span class="lineno">  131</span>    <span class="stringliteral">&quot;&quot;&quot;Find which event occurred during an integration step.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    g, g_new : array_like, shape (n_events,)</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        Values of event functions at a current and next points.</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    direction : ndarray, shape (n_events,)</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        Event &quot;direction&quot; according to the definition in `solve_ivp`.</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    active_events : ndarray</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        Indices of events which occurred during the step.</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  145</span>    g, g_new = np.asarray(g), np.asarray(g_new)</div>
<div class="line"><span class="lineno">  146</span>    up = (g &lt;= 0) &amp; (g_new &gt;= 0)</div>
<div class="line"><span class="lineno">  147</span>    down = (g &gt;= 0) &amp; (g_new &lt;= 0)</div>
<div class="line"><span class="lineno">  148</span>    either = up | down</div>
<div class="line"><span class="lineno">  149</span>    mask = (up &amp; (direction &gt; 0) |</div>
<div class="line"><span class="lineno">  150</span>            down &amp; (direction &lt; 0) |</div>
<div class="line"><span class="lineno">  151</span>            either &amp; (direction == 0))</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    <span class="keywordflow">return</span> np.nonzero(mask)[0]</div>
<div class="line"><span class="lineno">  154</span> </div>
<div class="line"><span class="lineno">  155</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e233bb8153b216ec17cdda179d98da2" name="a2e233bb8153b216ec17cdda179d98da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e233bb8153b216ec17cdda179d98da2">&#9670;&#160;</a></span>handle_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.handle_events </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>active_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>is_terminal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function to handle events.

Parameters
----------
sol : DenseOutput
    Function ``sol(t)`` which evaluates an ODE solution between `t_old`
    and  `t`.
events : list of callables, length n_events
    Event functions with signatures ``event(t, y)``.
active_events : ndarray
    Indices of events which occurred.
is_terminal : ndarray, shape (n_events,)
    Which events are terminal.
t_old, t : float
    Previous and new values of time.

Returns
-------
root_indices : ndarray
    Indices of events which take zero between `t_old` and `t` and before
    a possible termination.
roots : ndarray
    Values of t at which events occurred.
terminate : bool
    Whether a terminal event occurred.
</pre> <div class="fragment"><div class="line"><span class="lineno">   81</span><span class="keyword">def </span>handle_events(sol, events, active_events, is_terminal, t_old, t):</div>
<div class="line"><span class="lineno">   82</span>    <span class="stringliteral">&quot;&quot;&quot;Helper function to handle events.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    sol : DenseOutput</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        Function ``sol(t)`` which evaluates an ODE solution between `t_old`</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        and  `t`.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    events : list of callables, length n_events</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        Event functions with signatures ``event(t, y)``.</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    active_events : ndarray</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        Indices of events which occurred.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    is_terminal : ndarray, shape (n_events,)</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        Which events are terminal.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    t_old, t : float</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        Previous and new values of time.</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    root_indices : ndarray</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        Indices of events which take zero between `t_old` and `t` and before</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        a possible termination.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    roots : ndarray</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        Values of t at which events occurred.</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    terminate : bool</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        Whether a terminal event occurred.</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  108</span>    roots = [solve_event_equation(events[event_index], sol, t_old, t)</div>
<div class="line"><span class="lineno">  109</span>             <span class="keywordflow">for</span> event_index <span class="keywordflow">in</span> active_events]</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span>    roots = np.asarray(roots)</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>    <span class="keywordflow">if</span> np.any(is_terminal[active_events]):</div>
<div class="line"><span class="lineno">  114</span>        <span class="keywordflow">if</span> t &gt; t_old:</div>
<div class="line"><span class="lineno">  115</span>            order = np.argsort(roots)</div>
<div class="line"><span class="lineno">  116</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  117</span>            order = np.argsort(-roots)</div>
<div class="line"><span class="lineno">  118</span>        active_events = active_events[order]</div>
<div class="line"><span class="lineno">  119</span>        roots = roots[order]</div>
<div class="line"><span class="lineno">  120</span>        t = np.nonzero(is_terminal[active_events])[0][0]</div>
<div class="line"><span class="lineno">  121</span>        active_events = active_events[:t + 1]</div>
<div class="line"><span class="lineno">  122</span>        roots = roots[:t + 1]</div>
<div class="line"><span class="lineno">  123</span>        terminate = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  125</span>        terminate = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  126</span> </div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">return</span> active_events, roots, terminate</div>
<div class="line"><span class="lineno">  128</span> </div>
<div class="line"><span class="lineno">  129</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2bd524e6874fbf3d7eb6197e22f391f7" name="a2bd524e6874fbf3d7eb6197e22f391f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd524e6874fbf3d7eb6197e22f391f7">&#9670;&#160;</a></span>prepare_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.prepare_events </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Standardize event functions and extract is_terminal and direction.</pre> <div class="fragment"><div class="line"><span class="lineno">   28</span><span class="keyword">def </span>prepare_events(events):</div>
<div class="line"><span class="lineno">   29</span>    <span class="stringliteral">&quot;&quot;&quot;Standardize event functions and extract is_terminal and direction.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   30</span>    <span class="keywordflow">if</span> callable(events):</div>
<div class="line"><span class="lineno">   31</span>        events = (events,)</div>
<div class="line"><span class="lineno">   32</span> </div>
<div class="line"><span class="lineno">   33</span>    <span class="keywordflow">if</span> events <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   34</span>        is_terminal = np.empty(len(events), dtype=bool)</div>
<div class="line"><span class="lineno">   35</span>        direction = np.empty(len(events))</div>
<div class="line"><span class="lineno">   36</span>        <span class="keywordflow">for</span> i, event <span class="keywordflow">in</span> enumerate(events):</div>
<div class="line"><span class="lineno">   37</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   38</span>                is_terminal[i] = event.terminal</div>
<div class="line"><span class="lineno">   39</span>            <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno">   40</span>                is_terminal[i] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   41</span> </div>
<div class="line"><span class="lineno">   42</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   43</span>                direction[i] = event.direction</div>
<div class="line"><span class="lineno">   44</span>            <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno">   45</span>                direction[i] = 0</div>
<div class="line"><span class="lineno">   46</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   47</span>        is_terminal = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">   48</span>        direction = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">return</span> events, is_terminal, direction</div>
<div class="line"><span class="lineno">   51</span> </div>
<div class="line"><span class="lineno">   52</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af69a224cb82ae44c7221aec878313de6" name="af69a224cb82ae44c7221aec878313de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69a224cb82ae44c7221aec878313de6">&#9670;&#160;</a></span>solve_event_equation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.solve_event_equation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve an equation corresponding to an ODE event.

The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an
ODE solver using some sort of interpolation. It is solved by
`scipy.optimize.brentq` with xtol=atol=4*EPS.

Parameters
----------
event : callable
    Function ``event(t, y)``.
sol : callable
    Function ``sol(t)`` which evaluates an ODE solution between `t_old`
    and  `t`.
t_old, t : float
    Previous and new values of time. They will be used as a bracketing
    interval.

Returns
-------
root : float
    Found solution.
</pre> <div class="fragment"><div class="line"><span class="lineno">   53</span><span class="keyword">def </span>solve_event_equation(event, sol, t_old, t):</div>
<div class="line"><span class="lineno">   54</span>    <span class="stringliteral">&quot;&quot;&quot;Solve an equation corresponding to an ODE event.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    ODE solver using some sort of interpolation. It is solved by</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    `scipy.optimize.brentq` with xtol=atol=4*EPS.</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    event : callable</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">        Function ``event(t, y)``.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    sol : callable</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        Function ``sol(t)`` which evaluates an ODE solution between `t_old`</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        and  `t`.</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    t_old, t : float</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">        Previous and new values of time. They will be used as a bracketing</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">        interval.</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    root : float</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">        Found solution.</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   76</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1optimize.html">scipy.optimize</a> <span class="keyword">import</span> brentq</div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">return</span> brentq(<span class="keyword">lambda</span> t: event(t, sol(t)), t_old, t,</div>
<div class="line"><span class="lineno">   78</span>                  xtol=4 * EPS, rtol=4 * EPS)</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="ttc" id="anamespacescipy_1_1optimize_html"><div class="ttname"><a href="namespacescipy_1_1optimize.html">scipy.optimize</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f365255db6d7cf4fcfeebdcc68ec11e" name="a2f365255db6d7cf4fcfeebdcc68ec11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f365255db6d7cf4fcfeebdcc68ec11e">&#9670;&#160;</a></span>solve_ivp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.solve_ivp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t_span</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'<a class="el" href="classscipy_1_1integrate_1_1__ivp_1_1rk_1_1_r_k45.html">RK45</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t_eval</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dense_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>events</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vectorized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve an initial value problem for a system of ODEs.

This function numerically integrates a system of ordinary differential
equations given an initial value::

    dy / dt = f(t, y)
    y(t0) = y0

Here t is a 1-D independent variable (time), y(t) is an
N-D vector-valued function (state), and an N-D
vector-valued function f(t, y) determines the differential equations.
The goal is to find y(t) approximately satisfying the differential
equations, given an initial value y(t0)=y0.

Some of the solvers support integration in the complex domain, but note
that for stiff ODE solvers, the right-hand side must be
complex-differentiable (satisfy Cauchy-Riemann equations [11]_).
To solve a problem in the complex domain, pass y0 with a complex data type.
Another option always available is to rewrite your problem for real and
imaginary parts separately.

Parameters
----------
fun : callable
    Right-hand side of the system. The calling signature is ``fun(t, y)``.
    Here `t` is a scalar, and there are two options for the ndarray `y`:
    It can either have shape (n,); then `fun` must return array_like with
    shape (n,). Alternatively, it can have shape (n, k); then `fun`
    must return an array_like with shape (n, k), i.e., each column
    corresponds to a single column in `y`. The choice between the two
    options is determined by `vectorized` argument (see below). The
    vectorized implementation allows a faster approximation of the Jacobian
    by finite differences (required for stiff solvers).
t_span : 2-tuple of floats
    Interval of integration (t0, tf). The solver starts with t=t0 and
    integrates until it reaches t=tf.
y0 : array_like, shape (n,)
    Initial state. For problems in the complex domain, pass `y0` with a
    complex data type (even if the initial value is purely real).
method : string or `OdeSolver`, optional
    Integration method to use:

        * 'RK45' (default): Explicit Runge-Kutta method of order 5(4) [1]_.
          The error is controlled assuming accuracy of the fourth-order
          method, but steps are taken using the fifth-order accurate
          formula (local extrapolation is done). A quartic interpolation
          polynomial is used for the dense output [2]_. Can be applied in
          the complex domain.
        * 'RK23': Explicit Runge-Kutta method of order 3(2) [3]_. The error
          is controlled assuming accuracy of the second-order method, but
          steps are taken using the third-order accurate formula (local
          extrapolation is done). A cubic Hermite polynomial is used for the
          dense output. Can be applied in the complex domain.
        * 'DOP853': Explicit Runge-Kutta method of order 8 [13]_.
          Python implementation of the "DOP853" algorithm originally
          written in Fortran [14]_. A 7-th order interpolation polynomial
          accurate to 7-th order is used for the dense output.
          Can be applied in the complex domain.
        * 'Radau': Implicit Runge-Kutta method of the Radau IIA family of
          order 5 [4]_. The error is controlled with a third-order accurate
          embedded formula. A cubic polynomial which satisfies the
          collocation conditions is used for the dense output.
        * 'BDF': Implicit multi-step variable-order (1 to 5) method based
          on a backward differentiation formula for the derivative
          approximation [5]_. The implementation follows the one described
          in [6]_. A quasi-constant step scheme is used and accuracy is
          enhanced using the NDF modification. Can be applied in the
          complex domain.
        * 'LSODA': Adams/BDF method with automatic stiffness detection and
          switching [7]_, [8]_. This is a wrapper of the Fortran solver
          from ODEPACK.

    Explicit Runge-Kutta methods ('RK23', 'RK45', 'DOP853') should be used
    for non-stiff problems and implicit methods ('Radau', 'BDF') for
    stiff problems [9]_. Among Runge-Kutta methods, 'DOP853' is recommended
    for solving with high precision (low values of `rtol` and `atol`).

    If not sure, first try to run 'RK45'. If it makes unusually many
    iterations, diverges, or fails, your problem is likely to be stiff and
    you should use 'Radau' or 'BDF'. 'LSODA' can also be a good universal
    choice, but it might be somewhat less convenient to work with as it
    wraps old Fortran code.

    You can also pass an arbitrary class derived from `OdeSolver` which
    implements the solver.
t_eval : array_like or None, optional
    Times at which to store the computed solution, must be sorted and lie
    within `t_span`. If None (default), use points selected by the solver.
dense_output : bool, optional
    Whether to compute a continuous solution. Default is False.
events : callable, or list of callables, optional
    Events to track. If None (default), no events will be tracked.
    Each event occurs at the zeros of a continuous function of time and
    state. Each function must have the signature ``event(t, y)`` and return
    a float. The solver will find an accurate value of `t` at which
    ``event(t, y(t)) = 0`` using a root-finding algorithm. By default, all
    zeros will be found. The solver looks for a sign change over each step,
    so if multiple zero crossings occur within one step, events may be
    missed. Additionally each `event` function might have the following
    attributes:

        terminal: bool, optional
            Whether to terminate integration if this event occurs.
            Implicitly False if not assigned.
        direction: float, optional
            Direction of a zero crossing. If `direction` is positive,
            `event` will only trigger when going from negative to positive,
            and vice versa if `direction` is negative. If 0, then either
            direction will trigger event. Implicitly 0 if not assigned.

    You can assign attributes like ``event.terminal = True`` to any
    function in Python.
vectorized : bool, optional
    Whether `fun` is implemented in a vectorized fashion. Default is False.
args : tuple, optional
    Additional arguments to pass to the user-defined functions.  If given,
    the additional arguments are passed to all user-defined functions.
    So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,
    then `jac` (if given) and any event functions must have the same
    signature, and `args` must be a tuple of length 3.
**options
    Options passed to a chosen solver. All options available for already
    implemented solvers are listed below.
first_step : float or None, optional
    Initial step size. Default is `None` which means that the algorithm
    should choose.
max_step : float, optional
    Maximum allowed step size. Default is np.inf, i.e., the step size is not
    bounded and determined solely by the solver.
rtol, atol : float or array_like, optional
    Relative and absolute tolerances. The solver keeps the local error
    estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a
    relative accuracy (number of correct digits), while `atol` controls
    absolute accuracy (number of correct decimal places). To achieve the
    desired `rtol`, set `atol` to be smaller than the smallest value that
    can be expected from ``rtol * abs(y)`` so that `rtol` dominates the
    allowable error. If `atol` is larger than ``rtol * abs(y)`` the
    number of correct digits is not guaranteed. Conversely, to achieve the
    desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller
    than `atol`. If components of y have different scales, it might be
    beneficial to set different `atol` values for different components by
    passing array_like with shape (n,) for `atol`. Default values are
    1e-3 for `rtol` and 1e-6 for `atol`.
jac : array_like, sparse_matrix, callable or None, optional
    Jacobian matrix of the right-hand side of the system with respect
    to y, required by the 'Radau', 'BDF' and 'LSODA' method. The
    Jacobian matrix has shape (n, n) and its element (i, j) is equal to
    ``d f_i / d y_j``.  There are three ways to define the Jacobian:

        * If array_like or sparse_matrix, the Jacobian is assumed to
          be constant. Not supported by 'LSODA'.
        * If callable, the Jacobian is assumed to depend on both
          t and y; it will be called as ``jac(t, y)``, as necessary.
          For 'Radau' and 'BDF' methods, the return value might be a
          sparse matrix.
        * If None (default), the Jacobian will be approximated by
          finite differences.

    It is generally recommended to provide the Jacobian rather than
    relying on a finite-difference approximation.
jac_sparsity : array_like, sparse matrix or None, optional
    Defines a sparsity structure of the Jacobian matrix for a finite-
    difference approximation. Its shape must be (n, n). This argument
    is ignored if `jac` is not `None`. If the Jacobian has only few
    non-zero elements in *each* row, providing the sparsity structure
    will greatly speed up the computations [10]_. A zero entry means that
    a corresponding element in the Jacobian is always zero. If None
    (default), the Jacobian is assumed to be dense.
    Not supported by 'LSODA', see `lband` and `uband` instead.
lband, uband : int or None, optional
    Parameters defining the bandwidth of the Jacobian for the 'LSODA'
    method, i.e., ``jac[i, j] != 0 only for i - lband &lt;= j &lt;= i + uband``.
    Default is None. Setting these requires your jac routine to return the
    Jacobian in the packed format: the returned array must have ``n``
    columns and ``uband + lband + 1`` rows in which Jacobian diagonals are
    written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.
    The same format is used in `scipy.linalg.solve_banded` (check for an
    illustration).  These parameters can be also used with ``jac=None`` to
    reduce the number of Jacobian elements estimated by finite differences.
min_step : float, optional
    The minimum allowed step size for 'LSODA' method.
    By default `min_step` is zero.

Returns
-------
Bunch object with the following fields defined:
t : ndarray, shape (n_points,)
    Time points.
y : ndarray, shape (n, n_points)
    Values of the solution at `t`.
sol : `OdeSolution` or None
    Found solution as `OdeSolution` instance; None if `dense_output` was
    set to False.
t_events : list of ndarray or None
    Contains for each event type a list of arrays at which an event of
    that type event was detected. None if `events` was None.
y_events : list of ndarray or None
    For each value of `t_events`, the corresponding value of the solution.
    None if `events` was None.
nfev : int
    Number of evaluations of the right-hand side.
njev : int
    Number of evaluations of the Jacobian.
nlu : int
    Number of LU decompositions.
status : int
    Reason for algorithm termination:

        * -1: Integration step failed.
        *  0: The solver successfully reached the end of `tspan`.
        *  1: A termination event occurred.

message : string
    Human-readable description of the termination reason.
success : bool
    True if the solver reached the interval end or a termination event
    occurred (``status &gt;= 0``).

References
----------
.. [1] J. R. Dormand, P. J. Prince, "A family of embedded Runge-Kutta
       formulae", Journal of Computational and Applied Mathematics, Vol. 6,
       No. 1, pp. 19-26, 1980.
.. [2] L. W. Shampine, "Some Practical Runge-Kutta Formulas", Mathematics
       of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.
.. [3] P. Bogacki, L.F. Shampine, "A 3(2) Pair of Runge-Kutta Formulas",
       Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.
.. [4] E. Hairer, G. Wanner, "Solving Ordinary Differential Equations II:
       Stiff and Differential-Algebraic Problems", Sec. IV.8.
.. [5] `Backward Differentiation Formula
        &lt;https://en.wikipedia.org/wiki/Backward_differentiation_formula&gt;`_
        on Wikipedia.
.. [6] L. F. Shampine, M. W. Reichelt, "THE MATLAB ODE SUITE", SIAM J. SCI.
       COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.
.. [7] A. C. Hindmarsh, "ODEPACK, A Systematized Collection of ODE
       Solvers," IMACS Transactions on Scientific Computation, Vol 1.,
       pp. 55-64, 1983.
.. [8] L. Petzold, "Automatic selection of methods for solving stiff and
       nonstiff systems of ordinary differential equations", SIAM Journal
       on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,
       1983.
.. [9] `Stiff equation &lt;https://en.wikipedia.org/wiki/Stiff_equation&gt;`_ on
       Wikipedia.
.. [10] A. Curtis, M. J. D. Powell, and J. Reid, "On the estimation of
        sparse Jacobian matrices", Journal of the Institute of Mathematics
        and its Applications, 13, pp. 117-120, 1974.
.. [11] `Cauchy-Riemann equations
         &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on
         Wikipedia.
.. [12] `Lotka-Volterra equations
        &lt;https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations&gt;`_
        on Wikipedia.
.. [13] E. Hairer, S. P. Norsett G. Wanner, "Solving Ordinary Differential
        Equations I: Nonstiff Problems", Sec. II.
.. [14] `Page with original Fortran code of DOP853
        &lt;http://www.unige.ch/~hairer/software.html&gt;`_.

Examples
--------
Basic exponential decay showing automatically chosen time points.

&gt;&gt;&gt; from scipy.integrate import solve_ivp
&gt;&gt;&gt; def exponential_decay(t, y): return -0.5 * y
&gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])
&gt;&gt;&gt; print(sol.t)
[ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806
  8.33328988 10.        ]
&gt;&gt;&gt; print(sol.y)
[[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045
  0.03107158 0.01350781]
 [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091
  0.06214316 0.02701561]
 [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181
  0.12428631 0.05403123]]

Specifying points where the solution is desired.

&gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],
...                 t_eval=[0, 1, 2, 4, 10])
&gt;&gt;&gt; print(sol.t)
[ 0  1  2  4 10]
&gt;&gt;&gt; print(sol.y)
[[2.         1.21305369 0.73534021 0.27066736 0.01350938]
 [4.         2.42610739 1.47068043 0.54133472 0.02701876]
 [8.         4.85221478 2.94136085 1.08266944 0.05403753]]

Cannon fired upward with terminal event upon impact. The ``terminal`` and
``direction`` fields of an event are applied by monkey patching a function.
Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts
at position 0 with velocity +10. Note that the integration never reaches
t=100 because the event is terminal.

&gt;&gt;&gt; def upward_cannon(t, y): return [y[1], -0.5]
&gt;&gt;&gt; def hit_ground(t, y): return y[0]
&gt;&gt;&gt; hit_ground.terminal = True
&gt;&gt;&gt; hit_ground.direction = -1
&gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)
&gt;&gt;&gt; print(sol.t_events)
[array([40.])]
&gt;&gt;&gt; print(sol.t)
[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]

Use `dense_output` and `events` to find position, which is 100, at the apex
of the cannonball's trajectory. Apex is not defined as terminal, so both
apex and hit_ground are found. There is no information at t=20, so the sol
attribute is used to evaluate the solution. The sol attribute is returned
by setting ``dense_output=True``. Alternatively, the `y_events` attribute
can be used to access the solution at the time of the event.

&gt;&gt;&gt; def apex(t, y): return y[1]
&gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10],
...                 events=(hit_ground, apex), dense_output=True)
&gt;&gt;&gt; print(sol.t_events)
[array([40.]), array([20.])]
&gt;&gt;&gt; print(sol.t)
[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]
&gt;&gt;&gt; print(sol.sol(sol.t_events[1][0]))
[100.   0.]
&gt;&gt;&gt; print(sol.y_events)
[array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]

As an example of a system with additional parameters, we'll implement
the Lotka-Volterra equations [12]_.

&gt;&gt;&gt; def lotkavolterra(t, z, a, b, c, d):
...     x, y = z
...     return [a*x - b*x*y, -c*y + d*x*y]
...

We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`
argument.

&gt;&gt;&gt; sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),
...                 dense_output=True)

Compute a dense solution and plot it.

&gt;&gt;&gt; t = np.linspace(0, 15, 300)
&gt;&gt;&gt; z = sol.sol(t)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, z.T)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.legend(['x', 'y'], shadow=True)
&gt;&gt;&gt; plt.title('Lotka-Volterra System')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  157</span>              events=<span class="keywordtype">None</span>, vectorized=<span class="keyword">False</span>, args=<span class="keywordtype">None</span>, **options):</div>
<div class="line"><span class="lineno">  158</span>    <span class="stringliteral">&quot;&quot;&quot;Solve an initial value problem for a system of ODEs.</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    This function numerically integrates a system of ordinary differential</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    equations given an initial value::</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">        dy / dt = f(t, y)</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">        y(t0) = y0</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    Here t is a 1-D independent variable (time), y(t) is an</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    N-D vector-valued function (state), and an N-D</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    vector-valued function f(t, y) determines the differential equations.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    The goal is to find y(t) approximately satisfying the differential</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    equations, given an initial value y(t0)=y0.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    Some of the solvers support integration in the complex domain, but note</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    that for stiff ODE solvers, the right-hand side must be</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    To solve a problem in the complex domain, pass y0 with a complex data type.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    Another option always available is to rewrite your problem for real and</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    imaginary parts separately.</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    fun : callable</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        Right-hand side of the system. The calling signature is ``fun(t, y)``.</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">        Here `t` is a scalar, and there are two options for the ndarray `y`:</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        It can either have shape (n,); then `fun` must return array_like with</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        shape (n,). Alternatively, it can have shape (n, k); then `fun`</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        must return an array_like with shape (n, k), i.e., each column</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">        corresponds to a single column in `y`. The choice between the two</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        options is determined by `vectorized` argument (see below). The</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">        vectorized implementation allows a faster approximation of the Jacobian</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">        by finite differences (required for stiff solvers).</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    t_span : 2-tuple of floats</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        Interval of integration (t0, tf). The solver starts with t=t0 and</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        integrates until it reaches t=tf.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    y0 : array_like, shape (n,)</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        Initial state. For problems in the complex domain, pass `y0` with a</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">        complex data type (even if the initial value is purely real).</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    method : string or `OdeSolver`, optional</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">        Integration method to use:</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">            * &#39;RK45&#39; (default): Explicit Runge-Kutta method of order 5(4) [1]_.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">              The error is controlled assuming accuracy of the fourth-order</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">              method, but steps are taken using the fifth-order accurate</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">              formula (local extrapolation is done). A quartic interpolation</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">              polynomial is used for the dense output [2]_. Can be applied in</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">              the complex domain.</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">            * &#39;RK23&#39;: Explicit Runge-Kutta method of order 3(2) [3]_. The error</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">              is controlled assuming accuracy of the second-order method, but</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">              steps are taken using the third-order accurate formula (local</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">              extrapolation is done). A cubic Hermite polynomial is used for the</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">              dense output. Can be applied in the complex domain.</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">            * &#39;DOP853&#39;: Explicit Runge-Kutta method of order 8 [13]_.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">              Python implementation of the &quot;DOP853&quot; algorithm originally</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">              written in Fortran [14]_. A 7-th order interpolation polynomial</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">              accurate to 7-th order is used for the dense output.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">              Can be applied in the complex domain.</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">            * &#39;Radau&#39;: Implicit Runge-Kutta method of the Radau IIA family of</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">              order 5 [4]_. The error is controlled with a third-order accurate</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">              embedded formula. A cubic polynomial which satisfies the</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">              collocation conditions is used for the dense output.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">            * &#39;BDF&#39;: Implicit multi-step variable-order (1 to 5) method based</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">              on a backward differentiation formula for the derivative</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">              approximation [5]_. The implementation follows the one described</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">              in [6]_. A quasi-constant step scheme is used and accuracy is</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">              enhanced using the NDF modification. Can be applied in the</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">              complex domain.</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">            * &#39;LSODA&#39;: Adams/BDF method with automatic stiffness detection and</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">              switching [7]_, [8]_. This is a wrapper of the Fortran solver</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">              from ODEPACK.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        Explicit Runge-Kutta methods (&#39;RK23&#39;, &#39;RK45&#39;, &#39;DOP853&#39;) should be used</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        for non-stiff problems and implicit methods (&#39;Radau&#39;, &#39;BDF&#39;) for</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        stiff problems [9]_. Among Runge-Kutta methods, &#39;DOP853&#39; is recommended</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        for solving with high precision (low values of `rtol` and `atol`).</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">        If not sure, first try to run &#39;RK45&#39;. If it makes unusually many</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        iterations, diverges, or fails, your problem is likely to be stiff and</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        you should use &#39;Radau&#39; or &#39;BDF&#39;. &#39;LSODA&#39; can also be a good universal</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        choice, but it might be somewhat less convenient to work with as it</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        wraps old Fortran code.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">        You can also pass an arbitrary class derived from `OdeSolver` which</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        implements the solver.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    t_eval : array_like or None, optional</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        Times at which to store the computed solution, must be sorted and lie</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        within `t_span`. If None (default), use points selected by the solver.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    dense_output : bool, optional</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        Whether to compute a continuous solution. Default is False.</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    events : callable, or list of callables, optional</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        Events to track. If None (default), no events will be tracked.</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">        Each event occurs at the zeros of a continuous function of time and</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        state. Each function must have the signature ``event(t, y)`` and return</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        a float. The solver will find an accurate value of `t` at which</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default, all</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">        zeros will be found. The solver looks for a sign change over each step,</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">        so if multiple zero crossings occur within one step, events may be</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        missed. Additionally each `event` function might have the following</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">        attributes:</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">            terminal: bool, optional</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">                Whether to terminate integration if this event occurs.</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">                Implicitly False if not assigned.</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">            direction: float, optional</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">                Direction of a zero crossing. If `direction` is positive,</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">                `event` will only trigger when going from negative to positive,</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">                and vice versa if `direction` is negative. If 0, then either</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">                direction will trigger event. Implicitly 0 if not assigned.</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        You can assign attributes like ``event.terminal = True`` to any</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">        function in Python.</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    vectorized : bool, optional</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        Whether `fun` is implemented in a vectorized fashion. Default is False.</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">        Additional arguments to pass to the user-defined functions.  If given,</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        the additional arguments are passed to all user-defined functions.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        then `jac` (if given) and any event functions must have the same</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        signature, and `args` must be a tuple of length 3.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    **options</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        Options passed to a chosen solver. All options available for already</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        implemented solvers are listed below.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    first_step : float or None, optional</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        Initial step size. Default is `None` which means that the algorithm</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        should choose.</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    max_step : float, optional</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        Maximum allowed step size. Default is np.inf, i.e., the step size is not</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        bounded and determined solely by the solver.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    rtol, atol : float or array_like, optional</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        Relative and absolute tolerances. The solver keeps the local error</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">        relative accuracy (number of correct digits), while `atol` controls</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        absolute accuracy (number of correct decimal places). To achieve the</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        desired `rtol`, set `atol` to be smaller than the smallest value that</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        allowable error. If `atol` is larger than ``rtol * abs(y)`` the</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        number of correct digits is not guaranteed. Conversely, to achieve the</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        than `atol`. If components of y have different scales, it might be</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        beneficial to set different `atol` values for different components by</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        passing array_like with shape (n,) for `atol`. Default values are</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        1e-3 for `rtol` and 1e-6 for `atol`.</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    jac : array_like, sparse_matrix, callable or None, optional</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">        Jacobian matrix of the right-hand side of the system with respect</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        to y, required by the &#39;Radau&#39;, &#39;BDF&#39; and &#39;LSODA&#39; method. The</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        Jacobian matrix has shape (n, n) and its element (i, j) is equal to</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        ``d f_i / d y_j``.  There are three ways to define the Jacobian:</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">            * If array_like or sparse_matrix, the Jacobian is assumed to</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">              be constant. Not supported by &#39;LSODA&#39;.</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">            * If callable, the Jacobian is assumed to depend on both</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">              t and y; it will be called as ``jac(t, y)``, as necessary.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">              For &#39;Radau&#39; and &#39;BDF&#39; methods, the return value might be a</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">              sparse matrix.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">            * If None (default), the Jacobian will be approximated by</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">              finite differences.</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">        It is generally recommended to provide the Jacobian rather than</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        relying on a finite-difference approximation.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    jac_sparsity : array_like, sparse matrix or None, optional</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        Defines a sparsity structure of the Jacobian matrix for a finite-</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">        difference approximation. Its shape must be (n, n). This argument</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        is ignored if `jac` is not `None`. If the Jacobian has only few</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">        non-zero elements in *each* row, providing the sparsity structure</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">        will greatly speed up the computations [10]_. A zero entry means that</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        a corresponding element in the Jacobian is always zero. If None</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        (default), the Jacobian is assumed to be dense.</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">        Not supported by &#39;LSODA&#39;, see `lband` and `uband` instead.</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    lband, uband : int or None, optional</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">        Parameters defining the bandwidth of the Jacobian for the &#39;LSODA&#39;</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        method, i.e., ``jac[i, j] != 0 only for i - lband &lt;= j &lt;= i + uband``.</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">        Default is None. Setting these requires your jac routine to return the</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        Jacobian in the packed format: the returned array must have ``n``</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        The same format is used in `scipy.linalg.solve_banded` (check for an</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">        illustration).  These parameters can be also used with ``jac=None`` to</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        reduce the number of Jacobian elements estimated by finite differences.</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    min_step : float, optional</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        The minimum allowed step size for &#39;LSODA&#39; method.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">        By default `min_step` is zero.</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    Bunch object with the following fields defined:</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    t : ndarray, shape (n_points,)</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">        Time points.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    y : ndarray, shape (n, n_points)</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">        Values of the solution at `t`.</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    sol : `OdeSolution` or None</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">        Found solution as `OdeSolution` instance; None if `dense_output` was</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        set to False.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    t_events : list of ndarray or None</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        Contains for each event type a list of arrays at which an event of</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">        that type event was detected. None if `events` was None.</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    y_events : list of ndarray or None</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        For each value of `t_events`, the corresponding value of the solution.</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        None if `events` was None.</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    nfev : int</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">        Number of evaluations of the right-hand side.</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    njev : int</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        Number of evaluations of the Jacobian.</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    nlu : int</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">        Number of LU decompositions.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    status : int</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">        Reason for algorithm termination:</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">            * -1: Integration step failed.</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">            *  0: The solver successfully reached the end of `tspan`.</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">            *  1: A termination event occurred.</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    message : string</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">        Human-readable description of the termination reason.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    success : bool</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">        True if the solver reached the interval end or a termination event</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        occurred (``status &gt;= 0``).</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    .. [1] J. R. Dormand, P. J. Prince, &quot;A family of embedded Runge-Kutta</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">           formulae&quot;, Journal of Computational and Applied Mathematics, Vol. 6,</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">           No. 1, pp. 19-26, 1980.</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    .. [2] L. W. Shampine, &quot;Some Practical Runge-Kutta Formulas&quot;, Mathematics</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    .. [3] P. Bogacki, L.F. Shampine, &quot;A 3(2) Pair of Runge-Kutta Formulas&quot;,</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    .. [4] E. Hairer, G. Wanner, &quot;Solving Ordinary Differential Equations II:</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">           Stiff and Differential-Algebraic Problems&quot;, Sec. IV.8.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    .. [5] `Backward Differentiation Formula</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">            &lt;https://en.wikipedia.org/wiki/Backward_differentiation_formula&gt;`_</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">            on Wikipedia.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    .. [6] L. F. Shampine, M. W. Reichelt, &quot;THE MATLAB ODE SUITE&quot;, SIAM J. SCI.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    .. [7] A. C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">           Solvers,&quot; IMACS Transactions on Scientific Computation, Vol 1.,</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">           pp. 55-64, 1983.</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    .. [8] L. Petzold, &quot;Automatic selection of methods for solving stiff and</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">           nonstiff systems of ordinary differential equations&quot;, SIAM Journal</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">           1983.</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    .. [9] `Stiff equation &lt;https://en.wikipedia.org/wiki/Stiff_equation&gt;`_ on</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">           Wikipedia.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, &quot;On the estimation of</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">            sparse Jacobian matrices&quot;, Journal of the Institute of Mathematics</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">            and its Applications, 13, pp. 117-120, 1974.</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    .. [11] `Cauchy-Riemann equations</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">             &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">             Wikipedia.</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    .. [12] `Lotka-Volterra equations</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">            &lt;https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations&gt;`_</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">            on Wikipedia.</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    .. [13] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">            Equations I: Nonstiff Problems&quot;, Sec. II.</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    .. [14] `Page with original Fortran code of DOP853</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">            &lt;http://www.unige.ch/~hairer/software.html&gt;`_.</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    Basic exponential decay showing automatically chosen time points.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.integrate import solve_ivp</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    &gt;&gt;&gt; def exponential_decay(t, y): return -0.5 * y</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.t)</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">      8.33328988 10.        ]</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.y)</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">      0.03107158 0.01350781]</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">      0.06214316 0.02701561]</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">      0.12428631 0.05403123]]</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    Specifying points where the solution is desired.</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    ...                 t_eval=[0, 1, 2, 4, 10])</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.t)</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    [ 0  1  2  4 10]</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.y)</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">     [4.         2.42610739 1.47068043 0.54133472 0.02701876]</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    Cannon fired upward with terminal event upon impact. The ``terminal`` and</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    ``direction`` fields of an event are applied by monkey patching a function.</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    at position 0 with velocity +10. Note that the integration never reaches</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    t=100 because the event is terminal.</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    &gt;&gt;&gt; def upward_cannon(t, y): return [y[1], -0.5]</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    &gt;&gt;&gt; def hit_ground(t, y): return y[0]</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    &gt;&gt;&gt; hit_ground.terminal = True</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    &gt;&gt;&gt; hit_ground.direction = -1</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.t_events)</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    [array([40.])]</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.t)</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    Use `dense_output` and `events` to find position, which is 100, at the apex</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    of the cannonball&#39;s trajectory. Apex is not defined as terminal, so both</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    apex and hit_ground are found. There is no information at t=20, so the sol</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    attribute is used to evaluate the solution. The sol attribute is returned</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    by setting ``dense_output=True``. Alternatively, the `y_events` attribute</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    can be used to access the solution at the time of the event.</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    &gt;&gt;&gt; def apex(t, y): return y[1]</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10],</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    ...                 events=(hit_ground, apex), dense_output=True)</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.t_events)</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    [array([40.]), array([20.])]</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.t)</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.sol(sol.t_events[1][0]))</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    [100.   0.]</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    &gt;&gt;&gt; print(sol.y_events)</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    As an example of a system with additional parameters, we&#39;ll implement</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    the Lotka-Volterra equations [12]_.</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    &gt;&gt;&gt; def lotkavolterra(t, z, a, b, c, d):</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    ...     x, y = z</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    ...     return [a*x - b*x*y, -c*y + d*x*y]</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    argument.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    &gt;&gt;&gt; sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    ...                 dense_output=True)</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    Compute a dense solution and plot it.</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 15, 300)</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    &gt;&gt;&gt; z = sol.sol(t)</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, z.T)</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend([&#39;x&#39;, &#39;y&#39;], shadow=True)</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&#39;Lotka-Volterra System&#39;)</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  507</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> METHODS <span class="keywordflow">and</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno">  508</span>            inspect.isclass(method) <span class="keywordflow">and</span> issubclass(method, OdeSolver)):</div>
<div class="line"><span class="lineno">  509</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`method` must be one of {} or OdeSolver class.&quot;</span></div>
<div class="line"><span class="lineno">  510</span>                         .format(METHODS))</div>
<div class="line"><span class="lineno">  511</span> </div>
<div class="line"><span class="lineno">  512</span>    t0, tf = map(float, t_span)</div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">if</span> args <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  515</span>        <span class="comment"># Wrap the user&#39;s fun (and jac, if given) in lambdas to hide the</span></div>
<div class="line"><span class="lineno">  516</span>        <span class="comment"># additional parameters.  Pass in the original fun as a keyword</span></div>
<div class="line"><span class="lineno">  517</span>        <span class="comment"># argument to keep it in the scope of the lambda.</span></div>
<div class="line"><span class="lineno">  518</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  519</span>            _ = [*(args)]</div>
<div class="line"><span class="lineno">  520</span>        <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> exp:</div>
<div class="line"><span class="lineno">  521</span>            suggestion_tuple = (</div>
<div class="line"><span class="lineno">  522</span>                <span class="stringliteral">&quot;Supplied &#39;args&#39; cannot be unpacked. Please supply `args`&quot;</span></div>
<div class="line"><span class="lineno">  523</span>                f<span class="stringliteral">&quot; as a tuple (e.g. `args=({args},)`)&quot;</span></div>
<div class="line"><span class="lineno">  524</span>            )</div>
<div class="line"><span class="lineno">  525</span>            <span class="keywordflow">raise</span> TypeError(suggestion_tuple) <span class="keyword">from</span> exp</div>
<div class="line"><span class="lineno">  526</span> </div>
<div class="line"><span class="lineno">  527</span>        fun = <span class="keyword">lambda</span> t, x, fun=fun: fun(t, x, *args)</div>
<div class="line"><span class="lineno">  528</span>        jac = options.get(<span class="stringliteral">&#39;jac&#39;</span>)</div>
<div class="line"><span class="lineno">  529</span>        <span class="keywordflow">if</span> callable(jac):</div>
<div class="line"><span class="lineno">  530</span>            options[<span class="stringliteral">&#39;jac&#39;</span>] = <span class="keyword">lambda</span> t, x: jac(t, x, *args)</div>
<div class="line"><span class="lineno">  531</span> </div>
<div class="line"><span class="lineno">  532</span>    <span class="keywordflow">if</span> t_eval <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  533</span>        t_eval = np.asarray(t_eval)</div>
<div class="line"><span class="lineno">  534</span>        <span class="keywordflow">if</span> t_eval.ndim != 1:</div>
<div class="line"><span class="lineno">  535</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`t_eval` must be 1-dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>        <span class="keywordflow">if</span> np.any(t_eval &lt; min(t0, tf)) <span class="keywordflow">or</span> np.any(t_eval &gt; max(t0, tf)):</div>
<div class="line"><span class="lineno">  538</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Values in `t_eval` are not within `t_span`.&quot;</span>)</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>        d = np.diff(t_eval)</div>
<div class="line"><span class="lineno">  541</span>        <span class="keywordflow">if</span> tf &gt; t0 <span class="keywordflow">and</span> np.any(d &lt;= 0) <span class="keywordflow">or</span> tf &lt; t0 <span class="keywordflow">and</span> np.any(d &gt;= 0):</div>
<div class="line"><span class="lineno">  542</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Values in `t_eval` are not properly sorted.&quot;</span>)</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  544</span>        <span class="keywordflow">if</span> tf &gt; t0:</div>
<div class="line"><span class="lineno">  545</span>            t_eval_i = 0</div>
<div class="line"><span class="lineno">  546</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  547</span>            <span class="comment"># Make order of t_eval decreasing to use np.searchsorted.</span></div>
<div class="line"><span class="lineno">  548</span>            t_eval = t_eval[::-1]</div>
<div class="line"><span class="lineno">  549</span>            <span class="comment"># This will be an upper bound for slices.</span></div>
<div class="line"><span class="lineno">  550</span>            t_eval_i = t_eval.shape[0]</div>
<div class="line"><span class="lineno">  551</span> </div>
<div class="line"><span class="lineno">  552</span>    <span class="keywordflow">if</span> method <span class="keywordflow">in</span> METHODS:</div>
<div class="line"><span class="lineno">  553</span>        method = METHODS[method]</div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span>    solver = method(fun, t0, y0, tf, vectorized=vectorized, **options)</div>
<div class="line"><span class="lineno">  556</span> </div>
<div class="line"><span class="lineno">  557</span>    <span class="keywordflow">if</span> t_eval <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  558</span>        ts = [t0]</div>
<div class="line"><span class="lineno">  559</span>        ys = [y0]</div>
<div class="line"><span class="lineno">  560</span>    <span class="keywordflow">elif</span> t_eval <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> dense_output:</div>
<div class="line"><span class="lineno">  561</span>        ts = []</div>
<div class="line"><span class="lineno">  562</span>        ti = [t0]</div>
<div class="line"><span class="lineno">  563</span>        ys = []</div>
<div class="line"><span class="lineno">  564</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  565</span>        ts = []</div>
<div class="line"><span class="lineno">  566</span>        ys = []</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>    interpolants = []</div>
<div class="line"><span class="lineno">  569</span> </div>
<div class="line"><span class="lineno">  570</span>    events, is_terminal, event_dir = prepare_events(events)</div>
<div class="line"><span class="lineno">  571</span> </div>
<div class="line"><span class="lineno">  572</span>    <span class="keywordflow">if</span> events <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  573</span>        <span class="keywordflow">if</span> args <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  574</span>            <span class="comment"># Wrap user functions in lambdas to hide the additional parameters.</span></div>
<div class="line"><span class="lineno">  575</span>            <span class="comment"># The original event function is passed as a keyword argument to the</span></div>
<div class="line"><span class="lineno">  576</span>            <span class="comment"># lambda to keep the original function in scope (i.e., avoid the</span></div>
<div class="line"><span class="lineno">  577</span>            <span class="comment"># late binding closure &quot;gotcha&quot;).</span></div>
<div class="line"><span class="lineno">  578</span>            events = [<span class="keyword">lambda</span> t, x, event=event: event(t, x, *args)</div>
<div class="line"><span class="lineno">  579</span>                      <span class="keywordflow">for</span> event <span class="keywordflow">in</span> events]</div>
<div class="line"><span class="lineno">  580</span>        g = [event(t0, y0) <span class="keywordflow">for</span> event <span class="keywordflow">in</span> events]</div>
<div class="line"><span class="lineno">  581</span>        t_events = [[] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(len(events))]</div>
<div class="line"><span class="lineno">  582</span>        y_events = [[] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(len(events))]</div>
<div class="line"><span class="lineno">  583</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  584</span>        t_events = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  585</span>        y_events = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  586</span> </div>
<div class="line"><span class="lineno">  587</span>    status = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">while</span> status <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  589</span>        message = solver.step()</div>
<div class="line"><span class="lineno">  590</span> </div>
<div class="line"><span class="lineno">  591</span>        <span class="keywordflow">if</span> solver.status == <span class="stringliteral">&#39;finished&#39;</span>:</div>
<div class="line"><span class="lineno">  592</span>            status = 0</div>
<div class="line"><span class="lineno">  593</span>        <span class="keywordflow">elif</span> solver.status == <span class="stringliteral">&#39;failed&#39;</span>:</div>
<div class="line"><span class="lineno">  594</span>            status = -1</div>
<div class="line"><span class="lineno">  595</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  596</span> </div>
<div class="line"><span class="lineno">  597</span>        t_old = solver.t_old</div>
<div class="line"><span class="lineno">  598</span>        t = solver.t</div>
<div class="line"><span class="lineno">  599</span>        y = solver.y</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>        <span class="keywordflow">if</span> dense_output:</div>
<div class="line"><span class="lineno">  602</span>            sol = solver.dense_output()</div>
<div class="line"><span class="lineno">  603</span>            interpolants.append(sol)</div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  605</span>            sol = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  606</span> </div>
<div class="line"><span class="lineno">  607</span>        <span class="keywordflow">if</span> events <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  608</span>            g_new = [event(t, y) <span class="keywordflow">for</span> event <span class="keywordflow">in</span> events]</div>
<div class="line"><span class="lineno">  609</span>            active_events = find_active_events(g, g_new, event_dir)</div>
<div class="line"><span class="lineno">  610</span>            <span class="keywordflow">if</span> active_events.size &gt; 0:</div>
<div class="line"><span class="lineno">  611</span>                <span class="keywordflow">if</span> sol <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  612</span>                    sol = solver.dense_output()</div>
<div class="line"><span class="lineno">  613</span> </div>
<div class="line"><span class="lineno">  614</span>                root_indices, roots, terminate = handle_events(</div>
<div class="line"><span class="lineno">  615</span>                    sol, events, active_events, is_terminal, t_old, t)</div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span>                <span class="keywordflow">for</span> e, te <span class="keywordflow">in</span> zip(root_indices, roots):</div>
<div class="line"><span class="lineno">  618</span>                    t_events[e].append(te)</div>
<div class="line"><span class="lineno">  619</span>                    y_events[e].append(sol(te))</div>
<div class="line"><span class="lineno">  620</span> </div>
<div class="line"><span class="lineno">  621</span>                <span class="keywordflow">if</span> terminate:</div>
<div class="line"><span class="lineno">  622</span>                    status = 1</div>
<div class="line"><span class="lineno">  623</span>                    t = roots[-1]</div>
<div class="line"><span class="lineno">  624</span>                    y = sol(t)</div>
<div class="line"><span class="lineno">  625</span> </div>
<div class="line"><span class="lineno">  626</span>            g = g_new</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>        <span class="keywordflow">if</span> t_eval <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  629</span>            ts.append(t)</div>
<div class="line"><span class="lineno">  630</span>            ys.append(y)</div>
<div class="line"><span class="lineno">  631</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  632</span>            <span class="comment"># The value in t_eval equal to t will be included.</span></div>
<div class="line"><span class="lineno">  633</span>            <span class="keywordflow">if</span> solver.direction &gt; 0:</div>
<div class="line"><span class="lineno">  634</span>                t_eval_i_new = np.searchsorted(t_eval, t, side=<span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno">  635</span>                t_eval_step = t_eval[t_eval_i:t_eval_i_new]</div>
<div class="line"><span class="lineno">  636</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  637</span>                t_eval_i_new = np.searchsorted(t_eval, t, side=<span class="stringliteral">&#39;left&#39;</span>)</div>
<div class="line"><span class="lineno">  638</span>                <span class="comment"># It has to be done with two slice operations, because</span></div>
<div class="line"><span class="lineno">  639</span>                <span class="comment"># you can&#39;t slice to 0th element inclusive using backward</span></div>
<div class="line"><span class="lineno">  640</span>                <span class="comment"># slicing.</span></div>
<div class="line"><span class="lineno">  641</span>                t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-1]</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>            <span class="keywordflow">if</span> t_eval_step.size &gt; 0:</div>
<div class="line"><span class="lineno">  644</span>                <span class="keywordflow">if</span> sol <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  645</span>                    sol = solver.dense_output()</div>
<div class="line"><span class="lineno">  646</span>                ts.append(t_eval_step)</div>
<div class="line"><span class="lineno">  647</span>                ys.append(sol(t_eval_step))</div>
<div class="line"><span class="lineno">  648</span>                t_eval_i = t_eval_i_new</div>
<div class="line"><span class="lineno">  649</span> </div>
<div class="line"><span class="lineno">  650</span>        <span class="keywordflow">if</span> t_eval <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> dense_output:</div>
<div class="line"><span class="lineno">  651</span>            ti.append(t)</div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span>    message = MESSAGES.get(status, message)</div>
<div class="line"><span class="lineno">  654</span> </div>
<div class="line"><span class="lineno">  655</span>    <span class="keywordflow">if</span> t_events <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  656</span>        t_events = [np.asarray(te) <span class="keywordflow">for</span> te <span class="keywordflow">in</span> t_events]</div>
<div class="line"><span class="lineno">  657</span>        y_events = [np.asarray(ye) <span class="keywordflow">for</span> ye <span class="keywordflow">in</span> y_events]</div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span>    <span class="keywordflow">if</span> t_eval <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  660</span>        ts = np.array(ts)</div>
<div class="line"><span class="lineno">  661</span>        ys = np.vstack(ys).T</div>
<div class="line"><span class="lineno">  662</span>    <span class="keywordflow">elif</span> ts:</div>
<div class="line"><span class="lineno">  663</span>        ts = np.hstack(ts)</div>
<div class="line"><span class="lineno">  664</span>        ys = np.hstack(ys)</div>
<div class="line"><span class="lineno">  665</span> </div>
<div class="line"><span class="lineno">  666</span>    <span class="keywordflow">if</span> dense_output:</div>
<div class="line"><span class="lineno">  667</span>        <span class="keywordflow">if</span> t_eval <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  668</span>            sol = OdeSolution(ts, interpolants)</div>
<div class="line"><span class="lineno">  669</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  670</span>            sol = OdeSolution(ti, interpolants)</div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  672</span>        sol = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  673</span> </div>
<div class="line"><span class="lineno">  674</span>    <span class="keywordflow">return</span> OdeResult(t=ts, y=ys, sol=sol, t_events=t_events, y_events=y_events,</div>
<div class="line"><span class="lineno">  675</span>                     nfev=solver.nfev, njev=solver.njev, nlu=solver.nlu,</div>
<div class="line"><span class="lineno">  676</span>                     status=status, message=message, success=status &gt;= 0)</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae1fea86006b69f5100e628e463bff7a2" name="ae1fea86006b69f5100e628e463bff7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fea86006b69f5100e628e463bff7a2">&#9670;&#160;</a></span>MESSAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.integrate._ivp.ivp.MESSAGES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {0: <span class="stringliteral">&quot;The solver successfully reached the end of the integration interval.&quot;</span>,</div>
<div class="line"><span class="lineno">    2</span>            1: <span class="stringliteral">&quot;A termination event occurred.&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a80440f90e45322aa39e237b7055ce687" name="a80440f90e45322aa39e237b7055ce687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80440f90e45322aa39e237b7055ce687">&#9670;&#160;</a></span>METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.integrate._ivp.ivp.METHODS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {<span class="stringliteral">&#39;RK23&#39;</span>: RK23,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;RK45&#39;</span>: RK45,</div>
<div class="line"><span class="lineno">    3</span>           <span class="stringliteral">&#39;DOP853&#39;</span>: DOP853,</div>
<div class="line"><span class="lineno">    4</span>           <span class="stringliteral">&#39;Radau&#39;</span>: Radau,</div>
<div class="line"><span class="lineno">    5</span>           <span class="stringliteral">&#39;BDF&#39;</span>: BDF,</div>
<div class="line"><span class="lineno">    6</span>           <span class="stringliteral">&#39;LSODA&#39;</span>: LSODA}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
