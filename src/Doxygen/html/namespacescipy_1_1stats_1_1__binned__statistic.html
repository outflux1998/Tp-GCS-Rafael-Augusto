<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.stats._binned_statistic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats.html">stats</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html">_binned_statistic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.stats._binned_statistic Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5cd625761034ea56de8bda72e2be7d3e" id="r_a5cd625761034ea56de8bda72e2be7d3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#a5cd625761034ea56de8bda72e2be7d3e">binned_statistic</a> (x, values, statistic='mean', bins=10, range=None)</td></tr>
<tr class="separator:a5cd625761034ea56de8bda72e2be7d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b0bb6c6eab69e2bbb24f8059db82f5" id="r_a33b0bb6c6eab69e2bbb24f8059db82f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#a33b0bb6c6eab69e2bbb24f8059db82f5">binned_statistic_2d</a> (x, y, values, statistic='mean', bins=10, range=None, expand_binnumbers=False)</td></tr>
<tr class="separator:a33b0bb6c6eab69e2bbb24f8059db82f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501a78ea072090c86a91fbb425112eca" id="r_a501a78ea072090c86a91fbb425112eca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#a501a78ea072090c86a91fbb425112eca">binned_statistic_dd</a> (sample, values, statistic='mean', bins=10, range=None, expand_binnumbers=False, binned_statistic_result=None)</td></tr>
<tr class="separator:a501a78ea072090c86a91fbb425112eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54c4429488ccb2bab3a8a43b38c50bb" id="r_ab54c4429488ccb2bab3a8a43b38c50bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#ab54c4429488ccb2bab3a8a43b38c50bb">_calc_binned_statistic</a> (Vdim, bin_numbers, result, values, stat_func)</td></tr>
<tr class="separator:ab54c4429488ccb2bab3a8a43b38c50bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c08bd7a9626e3c1c6a533195897c22" id="r_a46c08bd7a9626e3c1c6a533195897c22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#a46c08bd7a9626e3c1c6a533195897c22">_create_binned_data</a> (bin_numbers, unique_bin_numbers, values, vv)</td></tr>
<tr class="separator:a46c08bd7a9626e3c1c6a533195897c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5aba885684856e29831cac609fdc4c" id="r_a5f5aba885684856e29831cac609fdc4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#a5f5aba885684856e29831cac609fdc4c">_bin_edges</a> (sample, bins=None, range=None)</td></tr>
<tr class="separator:a5f5aba885684856e29831cac609fdc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add91192a96b892185e2f050dd18c69f4" id="r_add91192a96b892185e2f050dd18c69f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#add91192a96b892185e2f050dd18c69f4">_bin_numbers</a> (sample, nbin, edges, dedges)</td></tr>
<tr class="separator:add91192a96b892185e2f050dd18c69f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af3aefb84ad5eb757a8ba5ce7f048ced8" id="r_af3aefb84ad5eb757a8ba5ce7f048ced8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#af3aefb84ad5eb757a8ba5ce7f048ced8">BinnedStatisticResult</a></td></tr>
<tr class="separator:af3aefb84ad5eb757a8ba5ce7f048ced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4dc99b57178267a2e4f2ad08ab55ed" id="r_acc4dc99b57178267a2e4f2ad08ab55ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#acc4dc99b57178267a2e4f2ad08ab55ed">BinnedStatistic2dResult</a></td></tr>
<tr class="separator:acc4dc99b57178267a2e4f2ad08ab55ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925fd2515e3d7b9c71daccb7a6095551" id="r_a925fd2515e3d7b9c71daccb7a6095551"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__binned__statistic.html#a925fd2515e3d7b9c71daccb7a6095551">BinnedStatisticddResult</a></td></tr>
<tr class="separator:a925fd2515e3d7b9c71daccb7a6095551"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5f5aba885684856e29831cac609fdc4c" name="a5f5aba885684856e29831cac609fdc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5aba885684856e29831cac609fdc4c">&#9670;&#160;</a></span>_bin_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic._bin_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Create edge arrays
</pre> <div class="fragment"><div class="line"><span class="lineno">  681</span><span class="keyword">def </span>_bin_edges(sample, bins=None, range=None):</div>
<div class="line"><span class="lineno">  682</span>    <span class="stringliteral">&quot;&quot;&quot; Create edge arrays</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  684</span>    Dlen, Ndim = sample.shape</div>
<div class="line"><span class="lineno">  685</span> </div>
<div class="line"><span class="lineno">  686</span>    nbin = np.empty(Ndim, int)    <span class="comment"># Number of bins in each dimension</span></div>
<div class="line"><span class="lineno">  687</span>    edges = Ndim * [<span class="keywordtype">None</span>]         <span class="comment"># Bin edges for each dim (will be 2D array)</span></div>
<div class="line"><span class="lineno">  688</span>    dedges = Ndim * [<span class="keywordtype">None</span>]        <span class="comment"># Spacing between edges (will be 2D array)</span></div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span>    <span class="comment"># Select range for each dimension</span></div>
<div class="line"><span class="lineno">  691</span>    <span class="comment"># Used only if number of bins is given.</span></div>
<div class="line"><span class="lineno">  692</span>    <span class="keywordflow">if</span> range <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  693</span>        smin = np.atleast_1d(np.array(sample.min(axis=0), float))</div>
<div class="line"><span class="lineno">  694</span>        smax = np.atleast_1d(np.array(sample.max(axis=0), float))</div>
<div class="line"><span class="lineno">  695</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  696</span>        <span class="keywordflow">if</span> len(range) != Ndim:</div>
<div class="line"><span class="lineno">  697</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  698</span>                f<span class="stringliteral">&quot;range given for {len(range)} dimensions; {Ndim} required&quot;</span>)</div>
<div class="line"><span class="lineno">  699</span>        smin = np.empty(Ndim)</div>
<div class="line"><span class="lineno">  700</span>        smax = np.empty(Ndim)</div>
<div class="line"><span class="lineno">  701</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> builtins.range(Ndim):</div>
<div class="line"><span class="lineno">  702</span>            <span class="keywordflow">if</span> range[i][1] &lt; range[i][0]:</div>
<div class="line"><span class="lineno">  703</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  704</span>                    <span class="stringliteral">&quot;In {}range, start must be &lt;= stop&quot;</span>.format(</div>
<div class="line"><span class="lineno">  705</span>                        f<span class="stringliteral">&quot;dimension {i + 1} of &quot;</span> <span class="keywordflow">if</span> Ndim &gt; 1 <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span>))</div>
<div class="line"><span class="lineno">  706</span>            smin[i], smax[i] = range[i]</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span>    <span class="comment"># Make sure the bins have a finite width.</span></div>
<div class="line"><span class="lineno">  709</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> builtins.range(len(smin)):</div>
<div class="line"><span class="lineno">  710</span>        <span class="keywordflow">if</span> smin[i] == smax[i]:</div>
<div class="line"><span class="lineno">  711</span>            smin[i] = smin[i] - .5</div>
<div class="line"><span class="lineno">  712</span>            smax[i] = smax[i] + .5</div>
<div class="line"><span class="lineno">  713</span> </div>
<div class="line"><span class="lineno">  714</span>    <span class="comment"># Preserve sample floating point precision in bin edges</span></div>
<div class="line"><span class="lineno">  715</span>    edges_dtype = (sample.dtype <span class="keywordflow">if</span> np.issubdtype(sample.dtype, np.floating)</div>
<div class="line"><span class="lineno">  716</span>                   <span class="keywordflow">else</span> float)</div>
<div class="line"><span class="lineno">  717</span> </div>
<div class="line"><span class="lineno">  718</span>    <span class="comment"># Create edge arrays</span></div>
<div class="line"><span class="lineno">  719</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> builtins.range(Ndim):</div>
<div class="line"><span class="lineno">  720</span>        <span class="keywordflow">if</span> np.isscalar(bins[i]):</div>
<div class="line"><span class="lineno">  721</span>            nbin[i] = bins[i] + 2  <span class="comment"># +2 for outlier bins</span></div>
<div class="line"><span class="lineno">  722</span>            edges[i] = np.linspace(smin[i], smax[i], nbin[i] - 1,</div>
<div class="line"><span class="lineno">  723</span>                                   dtype=edges_dtype)</div>
<div class="line"><span class="lineno">  724</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  725</span>            edges[i] = np.asarray(bins[i], edges_dtype)</div>
<div class="line"><span class="lineno">  726</span>            nbin[i] = len(edges[i]) + 1  <span class="comment"># +1 for outlier bins</span></div>
<div class="line"><span class="lineno">  727</span>        dedges[i] = np.diff(edges[i])</div>
<div class="line"><span class="lineno">  728</span> </div>
<div class="line"><span class="lineno">  729</span>    nbin = np.asarray(nbin)</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span>    <span class="keywordflow">return</span> nbin, edges, dedges</div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="line"><span class="lineno">  733</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="add91192a96b892185e2f050dd18c69f4" name="add91192a96b892185e2f050dd18c69f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add91192a96b892185e2f050dd18c69f4">&#9670;&#160;</a></span>_bin_numbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic._bin_numbers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dedges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the bin number each sample falls into, in each dimension
</pre> <div class="fragment"><div class="line"><span class="lineno">  734</span><span class="keyword">def </span>_bin_numbers(sample, nbin, edges, dedges):</div>
<div class="line"><span class="lineno">  735</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the bin number each sample falls into, in each dimension</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  737</span>    Dlen, Ndim = sample.shape</div>
<div class="line"><span class="lineno">  738</span> </div>
<div class="line"><span class="lineno">  739</span>    sampBin = [</div>
<div class="line"><span class="lineno">  740</span>        np.digitize(sample[:, i], edges[i])</div>
<div class="line"><span class="lineno">  741</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(Ndim)</div>
<div class="line"><span class="lineno">  742</span>    ]</div>
<div class="line"><span class="lineno">  743</span> </div>
<div class="line"><span class="lineno">  744</span>    <span class="comment"># Using `digitize`, values that fall on an edge are put in the right bin.</span></div>
<div class="line"><span class="lineno">  745</span>    <span class="comment"># For the rightmost bin, we want values equal to the right</span></div>
<div class="line"><span class="lineno">  746</span>    <span class="comment"># edge to be counted in the last bin, and not as an outlier.</span></div>
<div class="line"><span class="lineno">  747</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(Ndim):</div>
<div class="line"><span class="lineno">  748</span>        <span class="comment"># Find the rounding precision</span></div>
<div class="line"><span class="lineno">  749</span>        dedges_min = dedges[i].min()</div>
<div class="line"><span class="lineno">  750</span>        <span class="keywordflow">if</span> dedges_min == 0:</div>
<div class="line"><span class="lineno">  751</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The smallest edge difference is numerically 0.&#39;</span>)</div>
<div class="line"><span class="lineno">  752</span>        decimal = int(-np.log10(dedges_min)) + 6</div>
<div class="line"><span class="lineno">  753</span>        <span class="comment"># Find which points are on the rightmost edge.</span></div>
<div class="line"><span class="lineno">  754</span>        on_edge = np.where((sample[:, i] &gt;= edges[i][-1]) &amp;</div>
<div class="line"><span class="lineno">  755</span>                           (np.around(sample[:, i], decimal) ==</div>
<div class="line"><span class="lineno">  756</span>                            np.around(edges[i][-1], decimal)))[0]</div>
<div class="line"><span class="lineno">  757</span>        <span class="comment"># Shift these points one bin to the left.</span></div>
<div class="line"><span class="lineno">  758</span>        sampBin[i][on_edge] -= 1</div>
<div class="line"><span class="lineno">  759</span> </div>
<div class="line"><span class="lineno">  760</span>    <span class="comment"># Compute the sample indices in the flattened statistic matrix.</span></div>
<div class="line"><span class="lineno">  761</span>    binnumbers = np.ravel_multi_index(sampBin, nbin)</div>
<div class="line"><span class="lineno">  762</span> </div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">return</span> binnumbers</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab54c4429488ccb2bab3a8a43b38c50bb" name="ab54c4429488ccb2bab3a8a43b38c50bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54c4429488ccb2bab3a8a43b38c50bb">&#9670;&#160;</a></span>_calc_binned_statistic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic._calc_binned_statistic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Vdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bin_numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stat_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  659</span><span class="keyword">def </span>_calc_binned_statistic(Vdim, bin_numbers, result, values, stat_func):</div>
<div class="line"><span class="lineno">  660</span>    unique_bin_numbers = np.unique(bin_numbers)</div>
<div class="line"><span class="lineno">  661</span>    <span class="keywordflow">for</span> vv <span class="keywordflow">in</span> builtins.range(Vdim):</div>
<div class="line"><span class="lineno">  662</span>        bin_map = _create_binned_data(bin_numbers, unique_bin_numbers,</div>
<div class="line"><span class="lineno">  663</span>                                      values, vv)</div>
<div class="line"><span class="lineno">  664</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> unique_bin_numbers:</div>
<div class="line"><span class="lineno">  665</span>            result[vv, i] = stat_func(np.array(bin_map[i]))</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a46c08bd7a9626e3c1c6a533195897c22" name="a46c08bd7a9626e3c1c6a533195897c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c08bd7a9626e3c1c6a533195897c22">&#9670;&#160;</a></span>_create_binned_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic._create_binned_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bin_numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unique_bin_numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Create hashmap of bin ids to values in bins
key: bin number
value: list of binned data
</pre> <div class="fragment"><div class="line"><span class="lineno">  668</span><span class="keyword">def </span>_create_binned_data(bin_numbers, unique_bin_numbers, values, vv):</div>
<div class="line"><span class="lineno">  669</span>    <span class="stringliteral">&quot;&quot;&quot; Create hashmap of bin ids to values in bins</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    key: bin number</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    value: list of binned data</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  673</span>    bin_map = dict()</div>
<div class="line"><span class="lineno">  674</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> unique_bin_numbers:</div>
<div class="line"><span class="lineno">  675</span>        bin_map[i] = []</div>
<div class="line"><span class="lineno">  676</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> builtins.range(len(bin_numbers)):</div>
<div class="line"><span class="lineno">  677</span>        bin_map[bin_numbers[i]].append(values[vv, i])</div>
<div class="line"><span class="lineno">  678</span>    <span class="keywordflow">return</span> bin_map</div>
<div class="line"><span class="lineno">  679</span> </div>
<div class="line"><span class="lineno">  680</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5cd625761034ea56de8bda72e2be7d3e" name="a5cd625761034ea56de8bda72e2be7d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd625761034ea56de8bda72e2be7d3e">&#9670;&#160;</a></span>binned_statistic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic.binned_statistic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em> = <code>'mean'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a binned statistic for one or more sets of data.

This is a generalization of a histogram function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values (or set of values) within each bin.

Parameters
----------
x : (N,) array_like
    A sequence of values to be binned.
values : (N,) array_like or list of (N,) array_like
    The data on which the statistic will be computed.  This must be
    the same shape as `x`, or a set of sequences - each the same shape as
    `x`.  If `values` is a set of sequences, the statistic will be computed
    on each independently.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'std' : compute the standard deviation within each bin. This
        is implicitly calculated with ddof=0.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * 'min' : compute the minimum of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'max' : compute the maximum of values for point within each bin.
        Empty bins will be represented by NaN.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : int or sequence of scalars, optional
    If `bins` is an int, it defines the number of equal-width bins in the
    given range (10 by default).  If `bins` is a sequence, it defines the
    bin edges, including the rightmost edge, allowing for non-uniform bin
    widths.  Values in `x` that are smaller than lowest bin edge are
    assigned to bin number 0, values beyond the highest bin are assigned to
    ``bins[-1]``.  If the bin edges are specified, the number of bins will
    be, (nx = len(bins)-1).
range : (float, float) or [(float, float)], optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(x.min(), x.max())``.  Values outside the range are
    ignored.

Returns
-------
statistic : array
    The values of the selected statistic in each bin.
bin_edges : array of dtype float
    Return the bin edges ``(length(statistic)+1)``.
binnumber: 1-D ndarray of ints
    Indices of the bins (corresponding to `bin_edges`) in which each value
    of `x` belongs.  Same length as `values`.  A binnumber of `i` means the
    corresponding value is between (bin_edges[i-1], bin_edges[i]).

See Also
--------
numpy.digitize, numpy.histogram, binned_statistic_2d, binned_statistic_dd

Notes
-----
All but the last (righthand-most) bin is half-open.  In other words, if
`bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,
but excluding 2) and the second ``[2, 3)``.  The last bin, however, is
``[3, 4]``, which *includes* 4.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

First some basic examples:

Create two evenly spaced bins in the range of the given sample, and sum the
corresponding values in each of those bins:

&gt;&gt;&gt; values = [1.0, 1.0, 2.0, 1.5, 3.0]
&gt;&gt;&gt; stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)
BinnedStatisticResult(statistic=array([4. , 4.5]),
        bin_edges=array([1., 4., 7.]), binnumber=array([1, 1, 1, 2, 2]))

Multiple arrays of values can also be passed.  The statistic is calculated
on each set independently:

&gt;&gt;&gt; values = [[1.0, 1.0, 2.0, 1.5, 3.0], [2.0, 2.0, 4.0, 3.0, 6.0]]
&gt;&gt;&gt; stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)
BinnedStatisticResult(statistic=array([[4. , 4.5],
       [8. , 9. ]]), bin_edges=array([1., 4., 7.]),
       binnumber=array([1, 1, 1, 2, 2]))

&gt;&gt;&gt; stats.binned_statistic([1, 2, 1, 2, 4], np.arange(5), statistic='mean',
...                        bins=3)
BinnedStatisticResult(statistic=array([1., 2., 4.]),
        bin_edges=array([1., 2., 3., 4.]),
        binnumber=array([1, 2, 1, 2, 3]))

As a second example, we now generate some random data of sailing boat speed
as a function of wind speed, and then determine how fast our boat is for
certain wind speeds:

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; windspeed = 8 * rng.random(500)
&gt;&gt;&gt; boatspeed = .3 * windspeed**.5 + .2 * rng.random(500)
&gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(windspeed,
...                 boatspeed, statistic='median', bins=[1,2,3,4,5,6,7])
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(windspeed, boatspeed, 'b.', label='raw data')
&gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=5,
...            label='binned statistic of data')
&gt;&gt;&gt; plt.legend()

Now we can use ``binnumber`` to select all datapoints with a windspeed
below 1:

&gt;&gt;&gt; low_boatspeed = boatspeed[binnumber == 0]

As a final example, we will use ``bin_edges`` and ``binnumber`` to make a
plot of a distribution that shows the mean and distribution around that
mean per bin, on top of a regular histogram and the probability
distribution function:

&gt;&gt;&gt; x = np.linspace(0, 5, num=500)
&gt;&gt;&gt; x_pdf = stats.maxwell.pdf(x)
&gt;&gt;&gt; samples = stats.maxwell.rvs(size=10000)

&gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(x, x_pdf,
...         statistic='mean', bins=25)
&gt;&gt;&gt; bin_width = (bin_edges[1] - bin_edges[0])
&gt;&gt;&gt; bin_centers = bin_edges[1:] - bin_width/2

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.hist(samples, bins=50, density=True, histtype='stepfilled',
...          alpha=0.2, label='histogram of data')
&gt;&gt;&gt; plt.plot(x, x_pdf, 'r-', label='analytical pdf')
&gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=2,
...            label='binned statistic of data')
&gt;&gt;&gt; plt.plot((binnumber - 0.5) * bin_width, x_pdf, 'g.', alpha=0.5)
&gt;&gt;&gt; plt.legend(fontsize=10)
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">   17</span>                     bins=10, range=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">   18</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral">    Compute a binned statistic for one or more sets of data.</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral">    This is a generalization of a histogram function.  A histogram divides</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">    the space into bins, and returns the count of the number of points in</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    each bin.  This function allows the computation of the sum, mean, median,</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">    or other statistic of the values (or set of values) within each bin.</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    x : (N,) array_like</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">        A sequence of values to be binned.</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    values : (N,) array_like or list of (N,) array_like</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">        The data on which the statistic will be computed.  This must be</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">        the same shape as `x`, or a set of sequences - each the same shape as</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">        `x`.  If `values` is a set of sequences, the statistic will be computed</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">        on each independently.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    statistic : string or callable, optional</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">        The statistic to compute (default is &#39;mean&#39;).</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        The following statistics are available:</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">          * &#39;mean&#39; : compute the mean of values for points within each bin.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">          * &#39;std&#39; : compute the standard deviation within each bin. This</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">            is implicitly calculated with ddof=0.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">          * &#39;median&#39; : compute the median of values for points within each</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">            bin. Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">          * &#39;count&#39; : compute the count of points within each bin.  This is</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">            identical to an unweighted histogram.  `values` array is not</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">            referenced.</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">          * &#39;sum&#39; : compute the sum of values for points within each bin.</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">            This is identical to a weighted histogram.</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">          * &#39;min&#39; : compute the minimum of values for points within each bin.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">          * &#39;max&#39; : compute the maximum of values for point within each bin.</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">          * function : a user-defined function which takes a 1D array of</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">            values, and outputs a single numerical statistic. This function</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">            will be called on the values in each bin.  Empty bins will be</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">            represented by function([]), or NaN if this returns an error.</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    bins : int or sequence of scalars, optional</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        If `bins` is an int, it defines the number of equal-width bins in the</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        given range (10 by default).  If `bins` is a sequence, it defines the</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        bin edges, including the rightmost edge, allowing for non-uniform bin</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">        widths.  Values in `x` that are smaller than lowest bin edge are</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">        assigned to bin number 0, values beyond the highest bin are assigned to</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        ``bins[-1]``.  If the bin edges are specified, the number of bins will</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        be, (nx = len(bins)-1).</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    range : (float, float) or [(float, float)], optional</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">        The lower and upper range of the bins.  If not provided, range</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">        is simply ``(x.min(), x.max())``.  Values outside the range are</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">        ignored.</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    statistic : array</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        The values of the selected statistic in each bin.</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    bin_edges : array of dtype float</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">        Return the bin edges ``(length(statistic)+1)``.</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    binnumber: 1-D ndarray of ints</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        Indices of the bins (corresponding to `bin_edges`) in which each value</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">        of `x` belongs.  Same length as `values`.  A binnumber of `i` means the</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">        corresponding value is between (bin_edges[i-1], bin_edges[i]).</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    numpy.digitize, numpy.histogram, binned_statistic_2d, binned_statistic_dd</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    All but the last (righthand-most) bin is half-open.  In other words, if</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    but excluding 2) and the second ``[2, 3)``.  The last bin, however, is</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    ``[3, 4]``, which *includes* 4.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    First some basic examples:</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    Create two evenly spaced bins in the range of the given sample, and sum the</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    corresponding values in each of those bins:</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    &gt;&gt;&gt; values = [1.0, 1.0, 2.0, 1.5, 3.0]</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    &gt;&gt;&gt; stats.binned_statistic([1, 1, 2, 5, 7], values, &#39;sum&#39;, bins=2)</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    BinnedStatisticResult(statistic=array([4. , 4.5]),</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">            bin_edges=array([1., 4., 7.]), binnumber=array([1, 1, 1, 2, 2]))</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    Multiple arrays of values can also be passed.  The statistic is calculated</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    on each set independently:</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    &gt;&gt;&gt; values = [[1.0, 1.0, 2.0, 1.5, 3.0], [2.0, 2.0, 4.0, 3.0, 6.0]]</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &gt;&gt;&gt; stats.binned_statistic([1, 1, 2, 5, 7], values, &#39;sum&#39;, bins=2)</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    BinnedStatisticResult(statistic=array([[4. , 4.5],</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">           [8. , 9. ]]), bin_edges=array([1., 4., 7.]),</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">           binnumber=array([1, 1, 1, 2, 2]))</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; stats.binned_statistic([1, 2, 1, 2, 4], np.arange(5), statistic=&#39;mean&#39;,</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    ...                        bins=3)</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    BinnedStatisticResult(statistic=array([1., 2., 4.]),</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">            bin_edges=array([1., 2., 3., 4.]),</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">            binnumber=array([1, 2, 1, 2, 3]))</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    As a second example, we now generate some random data of sailing boat speed</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    as a function of wind speed, and then determine how fast our boat is for</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    certain wind speeds:</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    &gt;&gt;&gt; windspeed = 8 * rng.random(500)</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    &gt;&gt;&gt; boatspeed = .3 * windspeed**.5 + .2 * rng.random(500)</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    &gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(windspeed,</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    ...                 boatspeed, statistic=&#39;median&#39;, bins=[1,2,3,4,5,6,7])</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(windspeed, boatspeed, &#39;b.&#39;, label=&#39;raw data&#39;)</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    &gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors=&#39;g&#39;, lw=5,</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    ...            label=&#39;binned statistic of data&#39;)</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend()</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    Now we can use ``binnumber`` to select all datapoints with a windspeed</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    below 1:</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    &gt;&gt;&gt; low_boatspeed = boatspeed[binnumber == 0]</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    As a final example, we will use ``bin_edges`` and ``binnumber`` to make a</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    plot of a distribution that shows the mean and distribution around that</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    mean per bin, on top of a regular histogram and the probability</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    distribution function:</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 5, num=500)</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    &gt;&gt;&gt; x_pdf = stats.maxwell.pdf(x)</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    &gt;&gt;&gt; samples = stats.maxwell.rvs(size=10000)</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    &gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(x, x_pdf,</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    ...         statistic=&#39;mean&#39;, bins=25)</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    &gt;&gt;&gt; bin_width = (bin_edges[1] - bin_edges[0])</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    &gt;&gt;&gt; bin_centers = bin_edges[1:] - bin_width/2</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    &gt;&gt;&gt; plt.hist(samples, bins=50, density=True, histtype=&#39;stepfilled&#39;,</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    ...          alpha=0.2, label=&#39;histogram of data&#39;)</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, x_pdf, &#39;r-&#39;, label=&#39;analytical pdf&#39;)</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    &gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors=&#39;g&#39;, lw=2,</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    ...            label=&#39;binned statistic of data&#39;)</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot((binnumber - 0.5) * bin_width, x_pdf, &#39;g.&#39;, alpha=0.5)</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(fontsize=10)</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  171</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  172</span>        N = len(bins)</div>
<div class="line"><span class="lineno">  173</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  174</span>        N = 1</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordflow">if</span> N != 1:</div>
<div class="line"><span class="lineno">  177</span>        bins = [np.asarray(bins, float)]</div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>    <span class="keywordflow">if</span> range <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  180</span>        <span class="keywordflow">if</span> len(range) == 2:</div>
<div class="line"><span class="lineno">  181</span>            range = [range]</div>
<div class="line"><span class="lineno">  182</span> </div>
<div class="line"><span class="lineno">  183</span>    medians, edges, binnumbers = binned_statistic_dd(</div>
<div class="line"><span class="lineno">  184</span>        [x], values, statistic, bins, range)</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">return</span> BinnedStatisticResult(medians, edges[0], binnumbers)</div>
<div class="line"><span class="lineno">  187</span> </div>
<div class="line"><span class="lineno">  188</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a33b0bb6c6eab69e2bbb24f8059db82f5" name="a33b0bb6c6eab69e2bbb24f8059db82f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b0bb6c6eab69e2bbb24f8059db82f5">&#9670;&#160;</a></span>binned_statistic_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic.binned_statistic_2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em> = <code>'mean'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expand_binnumbers</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a bidimensional binned statistic for one or more sets of data.

This is a generalization of a histogram2d function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values (or set of values) within each bin.

Parameters
----------
x : (N,) array_like
    A sequence of values to be binned along the first dimension.
y : (N,) array_like
    A sequence of values to be binned along the second dimension.
values : (N,) array_like or list of (N,) array_like
    The data on which the statistic will be computed.  This must be
    the same shape as `x`, or a list of sequences - each with the same
    shape as `x`.  If `values` is such a list, the statistic will be
    computed on each independently.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'std' : compute the standard deviation within each bin. This
        is implicitly calculated with ddof=0.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * 'min' : compute the minimum of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'max' : compute the maximum of values for point within each bin.
        Empty bins will be represented by NaN.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : int or [int, int] or array_like or [array, array], optional
    The bin specification:

      * the number of bins for the two dimensions (nx = ny = bins),
      * the number of bins in each dimension (nx, ny = bins),
      * the bin edges for the two dimensions (x_edge = y_edge = bins),
      * the bin edges in each dimension (x_edge, y_edge = bins).

    If the bin edges are specified, the number of bins will be,
    (nx = len(x_edge)-1, ny = len(y_edge)-1).

range : (2,2) array_like, optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be
    considered outliers and not tallied in the histogram.
expand_binnumbers : bool, optional
    'False' (default): the returned `binnumber` is a shape (N,) array of
    linearized bin indices.
    'True': the returned `binnumber` is 'unraveled' into a shape (2,N)
    ndarray, where each row gives the bin numbers in the corresponding
    dimension.
    See the `binnumber` returned value, and the `Examples` section.

    .. versionadded:: 0.17.0

Returns
-------
statistic : (nx, ny) ndarray
    The values of the selected statistic in each two-dimensional bin.
x_edge : (nx + 1) ndarray
    The bin edges along the first dimension.
y_edge : (ny + 1) ndarray
    The bin edges along the second dimension.
binnumber : (N,) array of ints or (2,N) ndarray of ints
    This assigns to each element of `sample` an integer that represents the
    bin in which this observation falls.  The representation depends on the
    `expand_binnumbers` argument.  See `Notes` for details.


See Also
--------
numpy.digitize, numpy.histogram2d, binned_statistic, binned_statistic_dd

Notes
-----
Binedges:
All but the last (righthand-most) bin is half-open.  In other words, if
`bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,
but excluding 2) and the second ``[2, 3)``.  The last bin, however, is
``[3, 4]``, which *includes* 4.

`binnumber`:
This returned argument assigns to each element of `sample` an integer that
represents the bin in which it belongs.  The representation depends on the
`expand_binnumbers` argument. If 'False' (default): The returned
`binnumber` is a shape (N,) array of linearized indices mapping each
element of `sample` to its corresponding bin (using row-major ordering).
Note that the returned linearized bin indices are used for an array with
extra bins on the outer binedges to capture values outside of the defined
bin bounds.
If 'True': The returned `binnumber` is a shape (2,N) ndarray where
each row indicates bin placements for each dimension respectively.  In each
dimension, a binnumber of `i` means the corresponding value is between
(D_edge[i-1], D_edge[i]), where 'D' is either 'x' or 'y'.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import stats

Calculate the counts with explicit bin-edges:

&gt;&gt;&gt; x = [0.1, 0.1, 0.1, 0.6]
&gt;&gt;&gt; y = [2.1, 2.6, 2.1, 2.1]
&gt;&gt;&gt; binx = [0.0, 0.5, 1.0]
&gt;&gt;&gt; biny = [2.0, 2.5, 3.0]
&gt;&gt;&gt; ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx, biny])
&gt;&gt;&gt; ret.statistic
array([[2., 1.],
       [1., 0.]])

The bin in which each sample is placed is given by the `binnumber`
returned parameter.  By default, these are the linearized bin indices:

&gt;&gt;&gt; ret.binnumber
array([5, 6, 5, 9])

The bin indices can also be expanded into separate entries for each
dimension using the `expand_binnumbers` parameter:

&gt;&gt;&gt; ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx, biny],
...                                 expand_binnumbers=True)
&gt;&gt;&gt; ret.binnumber
array([[1, 1, 1, 2],
       [1, 2, 1, 1]])

Which shows that the first three elements belong in the xbin 1, and the
fourth into xbin 2; and so on for y.</pre> <div class="fragment"><div class="line"><span class="lineno">  195</span>                        bins=10, range=<span class="keywordtype">None</span>, expand_binnumbers=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  196</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    Compute a bidimensional binned statistic for one or more sets of data.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    This is a generalization of a histogram2d function.  A histogram divides</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    the space into bins, and returns the count of the number of points in</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    each bin.  This function allows the computation of the sum, mean, median,</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    or other statistic of the values (or set of values) within each bin.</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    x : (N,) array_like</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        A sequence of values to be binned along the first dimension.</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    y : (N,) array_like</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        A sequence of values to be binned along the second dimension.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    values : (N,) array_like or list of (N,) array_like</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        The data on which the statistic will be computed.  This must be</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        the same shape as `x`, or a list of sequences - each with the same</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        shape as `x`.  If `values` is such a list, the statistic will be</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        computed on each independently.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    statistic : string or callable, optional</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        The statistic to compute (default is &#39;mean&#39;).</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        The following statistics are available:</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">          * &#39;mean&#39; : compute the mean of values for points within each bin.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">          * &#39;std&#39; : compute the standard deviation within each bin. This</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">            is implicitly calculated with ddof=0.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">          * &#39;median&#39; : compute the median of values for points within each</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">            bin. Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">          * &#39;count&#39; : compute the count of points within each bin.  This is</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">            identical to an unweighted histogram.  `values` array is not</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">            referenced.</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">          * &#39;sum&#39; : compute the sum of values for points within each bin.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">            This is identical to a weighted histogram.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">          * &#39;min&#39; : compute the minimum of values for points within each bin.</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">          * &#39;max&#39; : compute the maximum of values for point within each bin.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">          * function : a user-defined function which takes a 1D array of</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">            values, and outputs a single numerical statistic. This function</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">            will be called on the values in each bin.  Empty bins will be</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">            represented by function([]), or NaN if this returns an error.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    bins : int or [int, int] or array_like or [array, array], optional</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">        The bin specification:</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">          * the number of bins for the two dimensions (nx = ny = bins),</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">          * the number of bins in each dimension (nx, ny = bins),</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">          * the bin edges for the two dimensions (x_edge = y_edge = bins),</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">          * the bin edges in each dimension (x_edge, y_edge = bins).</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        If the bin edges are specified, the number of bins will be,</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        (nx = len(x_edge)-1, ny = len(y_edge)-1).</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    range : (2,2) array_like, optional</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        The leftmost and rightmost edges of the bins along each dimension</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        (if not specified explicitly in the `bins` parameters):</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">        considered outliers and not tallied in the histogram.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    expand_binnumbers : bool, optional</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        &#39;False&#39; (default): the returned `binnumber` is a shape (N,) array of</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">        linearized bin indices.</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">        &#39;True&#39;: the returned `binnumber` is &#39;unraveled&#39; into a shape (2,N)</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        ndarray, where each row gives the bin numbers in the corresponding</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        See the `binnumber` returned value, and the `Examples` section.</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">        .. versionadded:: 0.17.0</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    statistic : (nx, ny) ndarray</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        The values of the selected statistic in each two-dimensional bin.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    x_edge : (nx + 1) ndarray</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">        The bin edges along the first dimension.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    y_edge : (ny + 1) ndarray</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        The bin edges along the second dimension.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    binnumber : (N,) array of ints or (2,N) ndarray of ints</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        This assigns to each element of `sample` an integer that represents the</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        bin in which this observation falls.  The representation depends on the</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        `expand_binnumbers` argument.  See `Notes` for details.</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    numpy.digitize, numpy.histogram2d, binned_statistic, binned_statistic_dd</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    Binedges:</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    All but the last (righthand-most) bin is half-open.  In other words, if</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    but excluding 2) and the second ``[2, 3)``.  The last bin, however, is</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    ``[3, 4]``, which *includes* 4.</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    `binnumber`:</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    This returned argument assigns to each element of `sample` an integer that</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    represents the bin in which it belongs.  The representation depends on the</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    `expand_binnumbers` argument. If &#39;False&#39; (default): The returned</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    `binnumber` is a shape (N,) array of linearized indices mapping each</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    element of `sample` to its corresponding bin (using row-major ordering).</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    Note that the returned linearized bin indices are used for an array with</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    extra bins on the outer binedges to capture values outside of the defined</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    bin bounds.</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    If &#39;True&#39;: The returned `binnumber` is a shape (2,N) ndarray where</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    each row indicates bin placements for each dimension respectively.  In each</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    dimension, a binnumber of `i` means the corresponding value is between</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    (D_edge[i-1], D_edge[i]), where &#39;D&#39; is either &#39;x&#39; or &#39;y&#39;.</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    Calculate the counts with explicit bin-edges:</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    &gt;&gt;&gt; x = [0.1, 0.1, 0.1, 0.6]</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    &gt;&gt;&gt; y = [2.1, 2.6, 2.1, 2.1]</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    &gt;&gt;&gt; binx = [0.0, 0.5, 1.0]</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    &gt;&gt;&gt; biny = [2.0, 2.5, 3.0]</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    &gt;&gt;&gt; ret = stats.binned_statistic_2d(x, y, None, &#39;count&#39;, bins=[binx, biny])</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    &gt;&gt;&gt; ret.statistic</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    array([[2., 1.],</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">           [1., 0.]])</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    The bin in which each sample is placed is given by the `binnumber`</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    returned parameter.  By default, these are the linearized bin indices:</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    &gt;&gt;&gt; ret.binnumber</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    array([5, 6, 5, 9])</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    The bin indices can also be expanded into separate entries for each</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    dimension using the `expand_binnumbers` parameter:</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    &gt;&gt;&gt; ret = stats.binned_statistic_2d(x, y, None, &#39;count&#39;, bins=[binx, biny],</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    ...                                 expand_binnumbers=True)</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    &gt;&gt;&gt; ret.binnumber</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    array([[1, 1, 1, 2],</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">           [1, 2, 1, 1]])</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    Which shows that the first three elements belong in the xbin 1, and the</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    fourth into xbin 2; and so on for y.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>    <span class="comment"># This code is based on np.histogram2d</span></div>
<div class="line"><span class="lineno">  343</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  344</span>        N = len(bins)</div>
<div class="line"><span class="lineno">  345</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  346</span>        N = 1</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>    <span class="keywordflow">if</span> N != 1 <span class="keywordflow">and</span> N != 2:</div>
<div class="line"><span class="lineno">  349</span>        xedges = yedges = np.asarray(bins, float)</div>
<div class="line"><span class="lineno">  350</span>        bins = [xedges, yedges]</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>    medians, edges, binnumbers = binned_statistic_dd(</div>
<div class="line"><span class="lineno">  353</span>        [x, y], values, statistic, bins, range,</div>
<div class="line"><span class="lineno">  354</span>        expand_binnumbers=expand_binnumbers)</div>
<div class="line"><span class="lineno">  355</span> </div>
<div class="line"><span class="lineno">  356</span>    <span class="keywordflow">return</span> BinnedStatistic2dResult(medians, edges[0], edges[1], binnumbers)</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a501a78ea072090c86a91fbb425112eca" name="a501a78ea072090c86a91fbb425112eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501a78ea072090c86a91fbb425112eca">&#9670;&#160;</a></span>binned_statistic_dd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic.binned_statistic_dd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em> = <code>'mean'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expand_binnumbers</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>binned_statistic_result</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a multidimensional binned statistic for a set of data.

This is a generalization of a histogramdd function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values within each bin.

Parameters
----------
sample : array_like
    Data to histogram passed as a sequence of N arrays of length D, or
    as an (N,D) array.
values : (N,) array_like or list of (N,) array_like
    The data on which the statistic will be computed.  This must be
    the same shape as `sample`, or a list of sequences - each with the
    same shape as `sample`.  If `values` is such a list, the statistic
    will be computed on each independently.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * 'std' : compute the standard deviation within each bin. This
        is implicitly calculated with ddof=0. If the number of values
        within a given bin is 0 or 1, the computed standard deviation value
        will be 0 for the bin.
      * 'min' : compute the minimum of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'max' : compute the maximum of values for point within each bin.
        Empty bins will be represented by NaN.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : sequence or positive int, optional
    The bin specification must be in one of the following forms:

      * A sequence of arrays describing the bin edges along each dimension.
      * The number of bins for each dimension (nx, ny, ... = bins).
      * The number of bins for all dimensions (nx = ny = ... = bins).
range : sequence, optional
    A sequence of lower and upper bin edges to be used if the edges are
    not given explicitly in `bins`. Defaults to the minimum and maximum
    values along each dimension.
expand_binnumbers : bool, optional
    'False' (default): the returned `binnumber` is a shape (N,) array of
    linearized bin indices.
    'True': the returned `binnumber` is 'unraveled' into a shape (D,N)
    ndarray, where each row gives the bin numbers in the corresponding
    dimension.
    See the `binnumber` returned value, and the `Examples` section of
    `binned_statistic_2d`.
binned_statistic_result : binnedStatisticddResult
    Result of a previous call to the function in order to reuse bin edges
    and bin numbers with new values and/or a different statistic.
    To reuse bin numbers, `expand_binnumbers` must have been set to False
    (the default)

    .. versionadded:: 0.17.0

Returns
-------
statistic : ndarray, shape(nx1, nx2, nx3,...)
    The values of the selected statistic in each two-dimensional bin.
bin_edges : list of ndarrays
    A list of D arrays describing the (nxi + 1) bin edges for each
    dimension.
binnumber : (N,) array of ints or (D,N) ndarray of ints
    This assigns to each element of `sample` an integer that represents the
    bin in which this observation falls.  The representation depends on the
    `expand_binnumbers` argument.  See `Notes` for details.


See Also
--------
numpy.digitize, numpy.histogramdd, binned_statistic, binned_statistic_2d

Notes
-----
Binedges:
All but the last (righthand-most) bin is half-open in each dimension.  In
other words, if `bins` is ``[1, 2, 3, 4]``, then the first bin is
``[1, 2)`` (including 1, but excluding 2) and the second ``[2, 3)``.  The
last bin, however, is ``[3, 4]``, which *includes* 4.

`binnumber`:
This returned argument assigns to each element of `sample` an integer that
represents the bin in which it belongs.  The representation depends on the
`expand_binnumbers` argument. If 'False' (default): The returned
`binnumber` is a shape (N,) array of linearized indices mapping each
element of `sample` to its corresponding bin (using row-major ordering).
If 'True': The returned `binnumber` is a shape (D,N) ndarray where
each row indicates bin placements for each dimension respectively.  In each
dimension, a binnumber of `i` means the corresponding value is between
(bin_edges[D][i-1], bin_edges[D][i]), for each dimension 'D'.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from mpl_toolkits.mplot3d import Axes3D

Take an array of 600 (x, y) coordinates as an example.
`binned_statistic_dd` can handle arrays of higher dimension `D`. But a plot
of dimension `D+1` is required.

&gt;&gt;&gt; mu = np.array([0., 1.])
&gt;&gt;&gt; sigma = np.array([[1., -0.5],[-0.5, 1.5]])
&gt;&gt;&gt; multinormal = stats.multivariate_normal(mu, sigma)
&gt;&gt;&gt; data = multinormal.rvs(size=600, random_state=235412)
&gt;&gt;&gt; data.shape
(600, 2)

Create bins and count how many arrays fall in each bin:

&gt;&gt;&gt; N = 60
&gt;&gt;&gt; x = np.linspace(-3, 3, N)
&gt;&gt;&gt; y = np.linspace(-3, 4, N)
&gt;&gt;&gt; ret = stats.binned_statistic_dd(data, np.arange(600), bins=[x, y],
...                                 statistic='count')
&gt;&gt;&gt; bincounts = ret.statistic

Set the volume and the location of bars:

&gt;&gt;&gt; dx = x[1] - x[0]
&gt;&gt;&gt; dy = y[1] - y[0]
&gt;&gt;&gt; x, y = np.meshgrid(x[:-1]+dx/2, y[:-1]+dy/2)
&gt;&gt;&gt; z = 0

&gt;&gt;&gt; bincounts = bincounts.ravel()
&gt;&gt;&gt; x = x.ravel()
&gt;&gt;&gt; y = y.ravel()

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111, projection='3d')
&gt;&gt;&gt; with np.errstate(divide='ignore'):   # silence random axes3d warning
...     ax.bar3d(x, y, z, dx, dy, bincounts)

Reuse bin numbers and bin edges with new values:

&gt;&gt;&gt; ret2 = stats.binned_statistic_dd(data, -np.arange(600),
...                                  binned_statistic_result=ret,
...                                  statistic='mean')
</pre> <div class="fragment"><div class="line"><span class="lineno">  366</span>                        binned_statistic_result=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  367</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    Compute a multidimensional binned statistic for a set of data.</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    This is a generalization of a histogramdd function.  A histogram divides</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    the space into bins, and returns the count of the number of points in</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    each bin.  This function allows the computation of the sum, mean, median,</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    or other statistic of the values within each bin.</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    sample : array_like</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        Data to histogram passed as a sequence of N arrays of length D, or</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        as an (N,D) array.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    values : (N,) array_like or list of (N,) array_like</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        The data on which the statistic will be computed.  This must be</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">        the same shape as `sample`, or a list of sequences - each with the</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        same shape as `sample`.  If `values` is such a list, the statistic</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">        will be computed on each independently.</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    statistic : string or callable, optional</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">        The statistic to compute (default is &#39;mean&#39;).</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        The following statistics are available:</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">          * &#39;mean&#39; : compute the mean of values for points within each bin.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">          * &#39;median&#39; : compute the median of values for points within each</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">            bin. Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">          * &#39;count&#39; : compute the count of points within each bin.  This is</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">            identical to an unweighted histogram.  `values` array is not</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">            referenced.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">          * &#39;sum&#39; : compute the sum of values for points within each bin.</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">            This is identical to a weighted histogram.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">          * &#39;std&#39; : compute the standard deviation within each bin. This</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">            is implicitly calculated with ddof=0. If the number of values</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">            within a given bin is 0 or 1, the computed standard deviation value</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">            will be 0 for the bin.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">          * &#39;min&#39; : compute the minimum of values for points within each bin.</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">          * &#39;max&#39; : compute the maximum of values for point within each bin.</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">            Empty bins will be represented by NaN.</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">          * function : a user-defined function which takes a 1D array of</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">            values, and outputs a single numerical statistic. This function</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">            will be called on the values in each bin.  Empty bins will be</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">            represented by function([]), or NaN if this returns an error.</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    bins : sequence or positive int, optional</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">        The bin specification must be in one of the following forms:</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">          * A sequence of arrays describing the bin edges along each dimension.</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">          * The number of bins for each dimension (nx, ny, ... = bins).</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">          * The number of bins for all dimensions (nx = ny = ... = bins).</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    range : sequence, optional</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">        A sequence of lower and upper bin edges to be used if the edges are</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        not given explicitly in `bins`. Defaults to the minimum and maximum</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">        values along each dimension.</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    expand_binnumbers : bool, optional</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        &#39;False&#39; (default): the returned `binnumber` is a shape (N,) array of</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">        linearized bin indices.</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        &#39;True&#39;: the returned `binnumber` is &#39;unraveled&#39; into a shape (D,N)</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">        ndarray, where each row gives the bin numbers in the corresponding</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">        See the `binnumber` returned value, and the `Examples` section of</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">        `binned_statistic_2d`.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    binned_statistic_result : binnedStatisticddResult</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        Result of a previous call to the function in order to reuse bin edges</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        and bin numbers with new values and/or a different statistic.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        To reuse bin numbers, `expand_binnumbers` must have been set to False</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        (the default)</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        .. versionadded:: 0.17.0</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    statistic : ndarray, shape(nx1, nx2, nx3,...)</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        The values of the selected statistic in each two-dimensional bin.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    bin_edges : list of ndarrays</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        A list of D arrays describing the (nxi + 1) bin edges for each</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    binnumber : (N,) array of ints or (D,N) ndarray of ints</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        This assigns to each element of `sample` an integer that represents the</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        bin in which this observation falls.  The representation depends on the</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        `expand_binnumbers` argument.  See `Notes` for details.</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    numpy.digitize, numpy.histogramdd, binned_statistic, binned_statistic_2d</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Binedges:</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    All but the last (righthand-most) bin is half-open in each dimension.  In</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    other words, if `bins` is ``[1, 2, 3, 4]``, then the first bin is</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    ``[1, 2)`` (including 1, but excluding 2) and the second ``[2, 3)``.  The</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    last bin, however, is ``[3, 4]``, which *includes* 4.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    `binnumber`:</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    This returned argument assigns to each element of `sample` an integer that</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    represents the bin in which it belongs.  The representation depends on the</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    `expand_binnumbers` argument. If &#39;False&#39; (default): The returned</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    `binnumber` is a shape (N,) array of linearized indices mapping each</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    element of `sample` to its corresponding bin (using row-major ordering).</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    If &#39;True&#39;: The returned `binnumber` is a shape (D,N) ndarray where</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    each row indicates bin placements for each dimension respectively.  In each</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    dimension, a binnumber of `i` means the corresponding value is between</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    (bin_edges[D][i-1], bin_edges[D][i]), for each dimension &#39;D&#39;.</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    &gt;&gt;&gt; from mpl_toolkits.mplot3d import Axes3D</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    Take an array of 600 (x, y) coordinates as an example.</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    `binned_statistic_dd` can handle arrays of higher dimension `D`. But a plot</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    of dimension `D+1` is required.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    &gt;&gt;&gt; mu = np.array([0., 1.])</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    &gt;&gt;&gt; sigma = np.array([[1., -0.5],[-0.5, 1.5]])</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    &gt;&gt;&gt; multinormal = stats.multivariate_normal(mu, sigma)</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    &gt;&gt;&gt; data = multinormal.rvs(size=600, random_state=235412)</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    &gt;&gt;&gt; data.shape</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    (600, 2)</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    Create bins and count how many arrays fall in each bin:</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    &gt;&gt;&gt; N = 60</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(-3, 3, N)</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    &gt;&gt;&gt; y = np.linspace(-3, 4, N)</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    &gt;&gt;&gt; ret = stats.binned_statistic_dd(data, np.arange(600), bins=[x, y],</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    ...                                 statistic=&#39;count&#39;)</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    &gt;&gt;&gt; bincounts = ret.statistic</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    Set the volume and the location of bars:</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    &gt;&gt;&gt; dx = x[1] - x[0]</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    &gt;&gt;&gt; dy = y[1] - y[0]</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    &gt;&gt;&gt; x, y = np.meshgrid(x[:-1]+dx/2, y[:-1]+dy/2)</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    &gt;&gt;&gt; z = 0</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    &gt;&gt;&gt; bincounts = bincounts.ravel()</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &gt;&gt;&gt; x = x.ravel()</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    &gt;&gt;&gt; y = y.ravel()</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure()</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(111, projection=&#39;3d&#39;)</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;):   # silence random axes3d warning</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    ...     ax.bar3d(x, y, z, dx, dy, bincounts)</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    Reuse bin numbers and bin edges with new values:</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    &gt;&gt;&gt; ret2 = stats.binned_statistic_dd(data, -np.arange(600),</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    ...                                  binned_statistic_result=ret,</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    ...                                  statistic=&#39;mean&#39;)</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  523</span>    known_stats = [<span class="stringliteral">&#39;mean&#39;</span>, <span class="stringliteral">&#39;median&#39;</span>, <span class="stringliteral">&#39;count&#39;</span>, <span class="stringliteral">&#39;sum&#39;</span>, <span class="stringliteral">&#39;std&#39;</span>, <span class="stringliteral">&#39;min&#39;</span>, <span class="stringliteral">&#39;max&#39;</span>]</div>
<div class="line"><span class="lineno">  524</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(statistic) <span class="keywordflow">and</span> statistic <span class="keywordflow">not</span> <span class="keywordflow">in</span> known_stats:</div>
<div class="line"><span class="lineno">  525</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;invalid statistic %r&#39;</span> % (statistic,))</div>
<div class="line"><span class="lineno">  526</span> </div>
<div class="line"><span class="lineno">  527</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  528</span>        bins = index(bins)</div>
<div class="line"><span class="lineno">  529</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  530</span>        <span class="comment"># bins is not an integer</span></div>
<div class="line"><span class="lineno">  531</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  532</span>    <span class="comment"># If bins was an integer-like object, now it is an actual Python int.</span></div>
<div class="line"><span class="lineno">  533</span> </div>
<div class="line"><span class="lineno">  534</span>    <span class="comment"># NOTE: for _bin_edges(), see e.g. gh-11365</span></div>
<div class="line"><span class="lineno">  535</span>    <span class="keywordflow">if</span> isinstance(bins, int) <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.isfinite(sample).all():</div>
<div class="line"><span class="lineno">  536</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;%r contains non-finite values.&#39;</span> % (sample,))</div>
<div class="line"><span class="lineno">  537</span> </div>
<div class="line"><span class="lineno">  538</span>    <span class="comment"># `Ndim` is the number of dimensions (e.g. `2` for `binned_statistic_2d`)</span></div>
<div class="line"><span class="lineno">  539</span>    <span class="comment"># `Dlen` is the length of elements along each dimension.</span></div>
<div class="line"><span class="lineno">  540</span>    <span class="comment"># This code is based on np.histogramdd</span></div>
<div class="line"><span class="lineno">  541</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  542</span>        <span class="comment"># `sample` is an ND-array.</span></div>
<div class="line"><span class="lineno">  543</span>        Dlen, Ndim = sample.shape</div>
<div class="line"><span class="lineno">  544</span>    <span class="keywordflow">except</span> (AttributeError, ValueError):</div>
<div class="line"><span class="lineno">  545</span>        <span class="comment"># `sample` is a sequence of 1D arrays.</span></div>
<div class="line"><span class="lineno">  546</span>        sample = np.atleast_2d(sample).T</div>
<div class="line"><span class="lineno">  547</span>        Dlen, Ndim = sample.shape</div>
<div class="line"><span class="lineno">  548</span> </div>
<div class="line"><span class="lineno">  549</span>    <span class="comment"># Store initial shape of `values` to preserve it in the output</span></div>
<div class="line"><span class="lineno">  550</span>    values = np.asarray(values)</div>
<div class="line"><span class="lineno">  551</span>    input_shape = list(values.shape)</div>
<div class="line"><span class="lineno">  552</span>    <span class="comment"># Make sure that `values` is 2D to iterate over rows</span></div>
<div class="line"><span class="lineno">  553</span>    values = np.atleast_2d(values)</div>
<div class="line"><span class="lineno">  554</span>    Vdim, Vlen = values.shape</div>
<div class="line"><span class="lineno">  555</span> </div>
<div class="line"><span class="lineno">  556</span>    <span class="comment"># Make sure `values` match `sample`</span></div>
<div class="line"><span class="lineno">  557</span>    if(statistic != <span class="stringliteral">&#39;count&#39;</span> <span class="keywordflow">and</span> Vlen != Dlen):</div>
<div class="line"><span class="lineno">  558</span>        <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;The number of `values` elements must match the &#39;</span></div>
<div class="line"><span class="lineno">  559</span>                             <span class="stringliteral">&#39;length of each `sample` dimension.&#39;</span>)</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  562</span>        M = len(bins)</div>
<div class="line"><span class="lineno">  563</span>        <span class="keywordflow">if</span> M != Ndim:</div>
<div class="line"><span class="lineno">  564</span>            <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;The dimension of bins must be equal &#39;</span></div>
<div class="line"><span class="lineno">  565</span>                                 <span class="stringliteral">&#39;to the dimension of the sample x.&#39;</span>)</div>
<div class="line"><span class="lineno">  566</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  567</span>        bins = Ndim * [bins]</div>
<div class="line"><span class="lineno">  568</span> </div>
<div class="line"><span class="lineno">  569</span>    <span class="keywordflow">if</span> binned_statistic_result <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  570</span>        nbin, edges, dedges = _bin_edges(sample, bins, range)</div>
<div class="line"><span class="lineno">  571</span>        binnumbers = _bin_numbers(sample, nbin, edges, dedges)</div>
<div class="line"><span class="lineno">  572</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  573</span>        edges = binned_statistic_result.bin_edges</div>
<div class="line"><span class="lineno">  574</span>        nbin = np.array([len(edges[i]) + 1 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> builtins.range(Ndim)])</div>
<div class="line"><span class="lineno">  575</span>        <span class="comment"># +1 for outlier bins</span></div>
<div class="line"><span class="lineno">  576</span>        dedges = [np.diff(edges[i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> builtins.range(Ndim)]</div>
<div class="line"><span class="lineno">  577</span>        binnumbers = binned_statistic_result.binnumber</div>
<div class="line"><span class="lineno">  578</span> </div>
<div class="line"><span class="lineno">  579</span>    result = np.empty([Vdim, nbin.prod()], float)</div>
<div class="line"><span class="lineno">  580</span> </div>
<div class="line"><span class="lineno">  581</span>    <span class="keywordflow">if</span> statistic == <span class="stringliteral">&#39;mean&#39;</span>:</div>
<div class="line"><span class="lineno">  582</span>        result.fill(np.nan)</div>
<div class="line"><span class="lineno">  583</span>        flatcount = np.bincount(binnumbers, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  584</span>        a = flatcount.nonzero()</div>
<div class="line"><span class="lineno">  585</span>        <span class="keywordflow">for</span> vv <span class="keywordflow">in</span> builtins.range(Vdim):</div>
<div class="line"><span class="lineno">  586</span>            flatsum = np.bincount(binnumbers, values[vv])</div>
<div class="line"><span class="lineno">  587</span>            result[vv, a] = flatsum[a] / flatcount[a]</div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">elif</span> statistic == <span class="stringliteral">&#39;std&#39;</span>:</div>
<div class="line"><span class="lineno">  589</span>        result.fill(np.nan)</div>
<div class="line"><span class="lineno">  590</span>        flatcount = np.bincount(binnumbers, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  591</span>        a = flatcount.nonzero()</div>
<div class="line"><span class="lineno">  592</span>        <span class="keywordflow">for</span> vv <span class="keywordflow">in</span> builtins.range(Vdim):</div>
<div class="line"><span class="lineno">  593</span>            flatsum = np.bincount(binnumbers, values[vv])</div>
<div class="line"><span class="lineno">  594</span>            delta = values[vv] - flatsum[binnumbers] / flatcount[binnumbers]</div>
<div class="line"><span class="lineno">  595</span>            std = np.sqrt(np.bincount(binnumbers, delta**2)[a] / flatcount[a])</div>
<div class="line"><span class="lineno">  596</span>            result[vv, a] = std</div>
<div class="line"><span class="lineno">  597</span>    <span class="keywordflow">elif</span> statistic == <span class="stringliteral">&#39;count&#39;</span>:</div>
<div class="line"><span class="lineno">  598</span>        result.fill(0)</div>
<div class="line"><span class="lineno">  599</span>        flatcount = np.bincount(binnumbers, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  600</span>        a = np.arange(len(flatcount))</div>
<div class="line"><span class="lineno">  601</span>        result[:, a] = flatcount[np.newaxis, :]</div>
<div class="line"><span class="lineno">  602</span>    <span class="keywordflow">elif</span> statistic == <span class="stringliteral">&#39;sum&#39;</span>:</div>
<div class="line"><span class="lineno">  603</span>        result.fill(0)</div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">for</span> vv <span class="keywordflow">in</span> builtins.range(Vdim):</div>
<div class="line"><span class="lineno">  605</span>            flatsum = np.bincount(binnumbers, values[vv])</div>
<div class="line"><span class="lineno">  606</span>            a = np.arange(len(flatsum))</div>
<div class="line"><span class="lineno">  607</span>            result[vv, a] = flatsum</div>
<div class="line"><span class="lineno">  608</span>    <span class="keywordflow">elif</span> statistic == <span class="stringliteral">&#39;median&#39;</span>:</div>
<div class="line"><span class="lineno">  609</span>        result.fill(np.nan)</div>
<div class="line"><span class="lineno">  610</span>        <span class="keywordflow">for</span> vv <span class="keywordflow">in</span> builtins.range(Vdim):</div>
<div class="line"><span class="lineno">  611</span>            i = np.lexsort((values[vv], binnumbers))</div>
<div class="line"><span class="lineno">  612</span>            _, j, counts = np.unique(binnumbers[i],</div>
<div class="line"><span class="lineno">  613</span>                                     return_index=<span class="keyword">True</span>, return_counts=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  614</span>            mid = j + (counts - 1) / 2</div>
<div class="line"><span class="lineno">  615</span>            mid_a = values[vv, i][np.floor(mid).astype(int)]</div>
<div class="line"><span class="lineno">  616</span>            mid_b = values[vv, i][np.ceil(mid).astype(int)]</div>
<div class="line"><span class="lineno">  617</span>            medians = (mid_a + mid_b) / 2</div>
<div class="line"><span class="lineno">  618</span>            result[vv, binnumbers[i][j]] = medians</div>
<div class="line"><span class="lineno">  619</span>    <span class="keywordflow">elif</span> statistic == <span class="stringliteral">&#39;min&#39;</span>:</div>
<div class="line"><span class="lineno">  620</span>        result.fill(np.nan)</div>
<div class="line"><span class="lineno">  621</span>        <span class="keywordflow">for</span> vv <span class="keywordflow">in</span> builtins.range(Vdim):</div>
<div class="line"><span class="lineno">  622</span>            i = np.argsort(values[vv])[::-1]  <span class="comment"># Reversed so the min is last</span></div>
<div class="line"><span class="lineno">  623</span>            result[vv, binnumbers[i]] = values[vv, i]</div>
<div class="line"><span class="lineno">  624</span>    <span class="keywordflow">elif</span> statistic == <span class="stringliteral">&#39;max&#39;</span>:</div>
<div class="line"><span class="lineno">  625</span>        result.fill(np.nan)</div>
<div class="line"><span class="lineno">  626</span>        <span class="keywordflow">for</span> vv <span class="keywordflow">in</span> builtins.range(Vdim):</div>
<div class="line"><span class="lineno">  627</span>            i = np.argsort(values[vv])</div>
<div class="line"><span class="lineno">  628</span>            result[vv, binnumbers[i]] = values[vv, i]</div>
<div class="line"><span class="lineno">  629</span>    <span class="keywordflow">elif</span> callable(statistic):</div>
<div class="line"><span class="lineno">  630</span>        <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>), suppress_warnings() <span class="keyword">as</span> sup:</div>
<div class="line"><span class="lineno">  631</span>            sup.filter(RuntimeWarning)</div>
<div class="line"><span class="lineno">  632</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  633</span>                null = statistic([])</div>
<div class="line"><span class="lineno">  634</span>            <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  635</span>                null = np.nan</div>
<div class="line"><span class="lineno">  636</span>        result.fill(null)</div>
<div class="line"><span class="lineno">  637</span>        _calc_binned_statistic(Vdim, binnumbers, result, values, statistic)</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span>    <span class="comment"># Shape into a proper matrix</span></div>
<div class="line"><span class="lineno">  640</span>    result = result.reshape(np.append(Vdim, nbin))</div>
<div class="line"><span class="lineno">  641</span> </div>
<div class="line"><span class="lineno">  642</span>    <span class="comment"># Remove outliers (indices 0 and -1 for each bin-dimension).</span></div>
<div class="line"><span class="lineno">  643</span>    core = tuple([slice(<span class="keywordtype">None</span>)] + Ndim * [slice(1, -1)])</div>
<div class="line"><span class="lineno">  644</span>    result = result[core]</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>    <span class="comment"># Unravel binnumbers into an ndarray, each row the bins for each dimension</span></div>
<div class="line"><span class="lineno">  647</span>    if(expand_binnumbers <span class="keywordflow">and</span> Ndim &gt; 1):</div>
<div class="line"><span class="lineno">  648</span>        binnumbers = np.asarray(np.unravel_index(binnumbers, nbin))</div>
<div class="line"><span class="lineno">  649</span> </div>
<div class="line"><span class="lineno">  650</span>    <span class="keywordflow">if</span> np.any(result.shape[1:] != nbin - 2):</div>
<div class="line"><span class="lineno">  651</span>        <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&#39;Internal Shape Error&#39;</span>)</div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span>    <span class="comment"># Reshape to have output (`result`) match input (`values`) shape</span></div>
<div class="line"><span class="lineno">  654</span>    result = result.reshape(input_shape[:-1] + list(nbin-2))</div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span>    <span class="keywordflow">return</span> BinnedStatisticddResult(result, edges, binnumbers)</div>
<div class="line"><span class="lineno">  657</span> </div>
<div class="line"><span class="lineno">  658</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acc4dc99b57178267a2e4f2ad08ab55ed" name="acc4dc99b57178267a2e4f2ad08ab55ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4dc99b57178267a2e4f2ad08ab55ed">&#9670;&#160;</a></span>BinnedStatistic2dResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic.BinnedStatistic2dResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;BinnedStatistic2dResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                     (<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;x_edge&#39;</span>, <span class="stringliteral">&#39;y_edge&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                                      <span class="stringliteral">&#39;binnumber&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a925fd2515e3d7b9c71daccb7a6095551" name="a925fd2515e3d7b9c71daccb7a6095551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925fd2515e3d7b9c71daccb7a6095551">&#9670;&#160;</a></span>BinnedStatisticddResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic.BinnedStatisticddResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;BinnedStatisticddResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                     (<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;bin_edges&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                                      <span class="stringliteral">&#39;binnumber&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="af3aefb84ad5eb757a8ba5ce7f048ced8" name="af3aefb84ad5eb757a8ba5ce7f048ced8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3aefb84ad5eb757a8ba5ce7f048ced8">&#9670;&#160;</a></span>BinnedStatisticResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._binned_statistic.BinnedStatisticResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;BinnedStatisticResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                   (<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;bin_edges&#39;</span>, <span class="stringliteral">&#39;binnumber&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
