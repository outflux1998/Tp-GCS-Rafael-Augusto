<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.core.shape_base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html">shape_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.core.shape_base Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac24abb59a089b237071d03a3b4daf333" id="r_ac24abb59a089b237071d03a3b4daf333"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#ac24abb59a089b237071d03a3b4daf333">_atleast_1d_dispatcher</a> (*arys)</td></tr>
<tr class="separator:ac24abb59a089b237071d03a3b4daf333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae705b9a3271089f51809c99a224dcf4b" id="r_ae705b9a3271089f51809c99a224dcf4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#ae705b9a3271089f51809c99a224dcf4b">atleast_1d</a> (*arys)</td></tr>
<tr class="separator:ae705b9a3271089f51809c99a224dcf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8a0c249b1561281ee2e897fefa14b3" id="r_abb8a0c249b1561281ee2e897fefa14b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#abb8a0c249b1561281ee2e897fefa14b3">_atleast_2d_dispatcher</a> (*arys)</td></tr>
<tr class="separator:abb8a0c249b1561281ee2e897fefa14b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d9b91150c1c9f9e2a423dc5fd701fc" id="r_ae0d9b91150c1c9f9e2a423dc5fd701fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#ae0d9b91150c1c9f9e2a423dc5fd701fc">atleast_2d</a> (*arys)</td></tr>
<tr class="separator:ae0d9b91150c1c9f9e2a423dc5fd701fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171c724d955502c2e2a72c529e0fcf42" id="r_a171c724d955502c2e2a72c529e0fcf42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a171c724d955502c2e2a72c529e0fcf42">_atleast_3d_dispatcher</a> (*arys)</td></tr>
<tr class="separator:a171c724d955502c2e2a72c529e0fcf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0cf3b0a03bde8d9c432387e90e2566" id="r_a9e0cf3b0a03bde8d9c432387e90e2566"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a9e0cf3b0a03bde8d9c432387e90e2566">atleast_3d</a> (*arys)</td></tr>
<tr class="separator:a9e0cf3b0a03bde8d9c432387e90e2566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0d6d131150a1f94f1d078197c7e66" id="r_ae7e0d6d131150a1f94f1d078197c7e66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#ae7e0d6d131150a1f94f1d078197c7e66">_arrays_for_stack_dispatcher</a> (arrays, stacklevel=4)</td></tr>
<tr class="separator:ae7e0d6d131150a1f94f1d078197c7e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb11fa31905335cc1e55ed60455706f" id="r_afbb11fa31905335cc1e55ed60455706f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#afbb11fa31905335cc1e55ed60455706f">_vhstack_dispatcher</a> (tup, *dtype=None, casting=None)</td></tr>
<tr class="separator:afbb11fa31905335cc1e55ed60455706f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468893bd623bab5e8d9e4b2c676713f2" id="r_a468893bd623bab5e8d9e4b2c676713f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a468893bd623bab5e8d9e4b2c676713f2">vstack</a> (tup, *dtype=None, casting=&quot;same_kind&quot;)</td></tr>
<tr class="separator:a468893bd623bab5e8d9e4b2c676713f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6a7b2a0881f44ceb6dbb11d16ecee1" id="r_abf6a7b2a0881f44ceb6dbb11d16ecee1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#abf6a7b2a0881f44ceb6dbb11d16ecee1">hstack</a> (tup, *dtype=None, casting=&quot;same_kind&quot;)</td></tr>
<tr class="separator:abf6a7b2a0881f44ceb6dbb11d16ecee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcc1ef3610bca18582008d8e55944df" id="r_a4fcc1ef3610bca18582008d8e55944df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a4fcc1ef3610bca18582008d8e55944df">_stack_dispatcher</a> (arrays, axis=None, out=None, *dtype=None, casting=None)</td></tr>
<tr class="separator:a4fcc1ef3610bca18582008d8e55944df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8092208c70aa6a10dd743aa135b3b581" id="r_a8092208c70aa6a10dd743aa135b3b581"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a8092208c70aa6a10dd743aa135b3b581">stack</a> (arrays, axis=0, out=None, *dtype=None, casting=&quot;same_kind&quot;)</td></tr>
<tr class="separator:a8092208c70aa6a10dd743aa135b3b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5571456ff00d0df51d026c89f9840ce8" id="r_a5571456ff00d0df51d026c89f9840ce8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a5571456ff00d0df51d026c89f9840ce8">_block_format_index</a> (index)</td></tr>
<tr class="separator:a5571456ff00d0df51d026c89f9840ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc04fcff7e967ef1a48aa2f667416b97" id="r_afc04fcff7e967ef1a48aa2f667416b97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#afc04fcff7e967ef1a48aa2f667416b97">_block_check_depths_match</a> (arrays, parent_index=[])</td></tr>
<tr class="separator:afc04fcff7e967ef1a48aa2f667416b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15f7e9d574d0d73e6361ce43fc62f56" id="r_aa15f7e9d574d0d73e6361ce43fc62f56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#aa15f7e9d574d0d73e6361ce43fc62f56">_atleast_nd</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, ndim)</td></tr>
<tr class="separator:aa15f7e9d574d0d73e6361ce43fc62f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05df921c496de22e255e55a9adf155e" id="r_ad05df921c496de22e255e55a9adf155e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#ad05df921c496de22e255e55a9adf155e">_accumulate</a> (values)</td></tr>
<tr class="separator:ad05df921c496de22e255e55a9adf155e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dfb8ef3c9c2aa8f363bf77347a3ac8" id="r_a45dfb8ef3c9c2aa8f363bf77347a3ac8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a45dfb8ef3c9c2aa8f363bf77347a3ac8">_concatenate_shapes</a> (shapes, axis)</td></tr>
<tr class="separator:a45dfb8ef3c9c2aa8f363bf77347a3ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab2762d3a51e6e21b3d36db17c5e2f" id="r_ad3ab2762d3a51e6e21b3d36db17c5e2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#ad3ab2762d3a51e6e21b3d36db17c5e2f">_block_info_recursion</a> (arrays, max_depth, result_ndim, depth=0)</td></tr>
<tr class="separator:ad3ab2762d3a51e6e21b3d36db17c5e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51e354091338cbfb426efb09fa6c99" id="r_a7e51e354091338cbfb426efb09fa6c99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a7e51e354091338cbfb426efb09fa6c99">_block</a> (arrays, max_depth, result_ndim, depth=0)</td></tr>
<tr class="separator:a7e51e354091338cbfb426efb09fa6c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e088c596f2b6c767fa6a3a317ab82a" id="r_a90e088c596f2b6c767fa6a3a317ab82a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a90e088c596f2b6c767fa6a3a317ab82a">_block_dispatcher</a> (arrays)</td></tr>
<tr class="separator:a90e088c596f2b6c767fa6a3a317ab82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b892426ce4cdcaceea3908b51dff188" id="r_a9b892426ce4cdcaceea3908b51dff188"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a9b892426ce4cdcaceea3908b51dff188">block</a> (arrays)</td></tr>
<tr class="separator:a9b892426ce4cdcaceea3908b51dff188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2a9f3e8deed7aabab9b05c901f9aba" id="r_a3e2a9f3e8deed7aabab9b05c901f9aba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a3e2a9f3e8deed7aabab9b05c901f9aba">_block_setup</a> (arrays)</td></tr>
<tr class="separator:a3e2a9f3e8deed7aabab9b05c901f9aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b65f06ab88270f1e3292674e4da714c" id="r_a3b65f06ab88270f1e3292674e4da714c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a3b65f06ab88270f1e3292674e4da714c">_block_slicing</a> (arrays, list_ndim, result_ndim)</td></tr>
<tr class="separator:a3b65f06ab88270f1e3292674e4da714c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de516e514ffbf926a53c64349905d3" id="r_a99de516e514ffbf926a53c64349905d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a99de516e514ffbf926a53c64349905d3">_block_concatenate</a> (arrays, list_ndim, result_ndim)</td></tr>
<tr class="separator:a99de516e514ffbf926a53c64349905d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a45fc2ea67d94098cb4d63aca7a7ef92c" id="r_a45fc2ea67d94098cb4d63aca7a7ef92c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a45fc2ea67d94098cb4d63aca7a7ef92c">array_function_dispatch</a></td></tr>
<tr class="separator:a45fc2ea67d94098cb4d63aca7a7ef92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a69f9d599b839b2b180a5544040033d" id="r_a0a69f9d599b839b2b180a5544040033d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a0a69f9d599b839b2b180a5544040033d">_size</a> = getattr(_from_nx.size, '__wrapped__', _from_nx.size)</td></tr>
<tr class="separator:a0a69f9d599b839b2b180a5544040033d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46668d1e091199fd7659771cfc24dce4" id="r_a46668d1e091199fd7659771cfc24dce4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#a46668d1e091199fd7659771cfc24dce4">_ndim</a> = getattr(_from_nx.ndim, '__wrapped__', _from_nx.ndim)</td></tr>
<tr class="separator:a46668d1e091199fd7659771cfc24dce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5eb5150180bd32e4fe7c6a81e8ae95" id="r_acf5eb5150180bd32e4fe7c6a81e8ae95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1shape__base.html#acf5eb5150180bd32e4fe7c6a81e8ae95">_concatenate</a></td></tr>
<tr class="separator:acf5eb5150180bd32e4fe7c6a81e8ae95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad05df921c496de22e255e55a9adf155e" name="ad05df921c496de22e255e55a9adf155e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05df921c496de22e255e55a9adf155e">&#9670;&#160;</a></span>_accumulate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._accumulate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  574</span><span class="keyword">def </span>_accumulate(values):</div>
<div class="line"><span class="lineno">  575</span>    <span class="keywordflow">return</span> list(itertools.accumulate(values))</div>
<div class="line"><span class="lineno">  576</span> </div>
<div class="line"><span class="lineno">  577</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7e0d6d131150a1f94f1d078197c7e66" name="ae7e0d6d131150a1f94f1d078197c7e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0d6d131150a1f94f1d078197c7e66">&#9670;&#160;</a></span>_arrays_for_stack_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._arrays_for_stack_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stacklevel</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  207</span><span class="keyword">def </span>_arrays_for_stack_dispatcher(arrays, stacklevel=4):</div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(arrays, <span class="stringliteral">&#39;__getitem__&#39;</span>) <span class="keywordflow">and</span> hasattr(arrays, <span class="stringliteral">&#39;__iter__&#39;</span>):</div>
<div class="line"><span class="lineno">  209</span>        warnings.warn(<span class="stringliteral">&#39;arrays to stack must be passed as a &quot;sequence&quot; type &#39;</span></div>
<div class="line"><span class="lineno">  210</span>                      <span class="stringliteral">&#39;such as list or tuple. Support for non-sequence &#39;</span></div>
<div class="line"><span class="lineno">  211</span>                      <span class="stringliteral">&#39;iterables such as generators is deprecated as of &#39;</span></div>
<div class="line"><span class="lineno">  212</span>                      <span class="stringliteral">&#39;NumPy 1.16 and will raise an error in the future.&#39;</span>,</div>
<div class="line"><span class="lineno">  213</span>                      FutureWarning, stacklevel=stacklevel)</div>
<div class="line"><span class="lineno">  214</span>        <span class="keywordflow">return</span> ()</div>
<div class="line"><span class="lineno">  215</span>    <span class="keywordflow">return</span> arrays</div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac24abb59a089b237071d03a3b4daf333" name="ac24abb59a089b237071d03a3b4daf333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24abb59a089b237071d03a3b4daf333">&#9670;&#160;</a></span>_atleast_1d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._atleast_1d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   19</span><span class="keyword">def </span>_atleast_1d_dispatcher(*arys):</div>
<div class="line"><span class="lineno">   20</span>    <span class="keywordflow">return</span> arys</div>
<div class="line"><span class="lineno">   21</span> </div>
<div class="line"><span class="lineno">   22</span> </div>
<div class="line"><span class="lineno">   23</span><span class="preprocessor">@array_function_dispatch(_atleast_1d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb8a0c249b1561281ee2e897fefa14b3" name="abb8a0c249b1561281ee2e897fefa14b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8a0c249b1561281ee2e897fefa14b3">&#9670;&#160;</a></span>_atleast_2d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._atleast_2d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   77</span><span class="keyword">def </span>_atleast_2d_dispatcher(*arys):</div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">return</span> arys</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span><span class="preprocessor">@array_function_dispatch(_atleast_2d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a171c724d955502c2e2a72c529e0fcf42" name="a171c724d955502c2e2a72c529e0fcf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171c724d955502c2e2a72c529e0fcf42">&#9670;&#160;</a></span>_atleast_3d_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._atleast_3d_dispatcher </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  135</span><span class="keyword">def </span>_atleast_3d_dispatcher(*arys):</div>
<div class="line"><span class="lineno">  136</span>    <span class="keywordflow">return</span> arys</div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span> </div>
<div class="line"><span class="lineno">  139</span><span class="preprocessor">@array_function_dispatch(_atleast_3d_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa15f7e9d574d0d73e6361ce43fc62f56" name="aa15f7e9d574d0d73e6361ce43fc62f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15f7e9d574d0d73e6361ce43fc62f56">&#9670;&#160;</a></span>_atleast_nd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._atleast_nd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  568</span><span class="keyword">def </span>_atleast_nd(a, ndim):</div>
<div class="line"><span class="lineno">  569</span>    <span class="comment"># Ensures `a` has at least `ndim` dimensions by prepending</span></div>
<div class="line"><span class="lineno">  570</span>    <span class="comment"># ones to `a.shape` as necessary</span></div>
<div class="line"><span class="lineno">  571</span>    <span class="keywordflow">return</span> array(a, ndmin=ndim, copy=<span class="keyword">False</span>, subok=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e51e354091338cbfb426efb09fa6c99" name="a7e51e354091338cbfb426efb09fa6c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e51e354091338cbfb426efb09fa6c99">&#9670;&#160;</a></span>_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result_ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Internal implementation of block based on repeated concatenation.
`arrays` is the argument passed to
block. `max_depth` is the depth of nested lists within `arrays` and
`result_ndim` is the greatest of the dimensions of the arrays in
`arrays` and the depth of the lists in `arrays` (see block docstring
for details).
</pre> <div class="fragment"><div class="line"><span class="lineno">  688</span><span class="keyword">def </span>_block(arrays, max_depth, result_ndim, depth=0):</div>
<div class="line"><span class="lineno">  689</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    Internal implementation of block based on repeated concatenation.</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    `arrays` is the argument passed to</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    block. `max_depth` is the depth of nested lists within `arrays` and</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    `result_ndim` is the greatest of the dimensions of the arrays in</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    `arrays` and the depth of the lists in `arrays` (see block docstring</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    for details).</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  697</span>    <span class="keywordflow">if</span> depth &lt; max_depth:</div>
<div class="line"><span class="lineno">  698</span>        arrs = [_block(arr, max_depth, result_ndim, depth+1)</div>
<div class="line"><span class="lineno">  699</span>                <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays]</div>
<div class="line"><span class="lineno">  700</span>        <span class="keywordflow">return</span> _concatenate(arrs, axis=-(max_depth-depth))</div>
<div class="line"><span class="lineno">  701</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  702</span>        <span class="comment"># We&#39;ve &#39;bottomed out&#39; - arrays is either a scalar or an array</span></div>
<div class="line"><span class="lineno">  703</span>        <span class="comment"># type(arrays) is not list</span></div>
<div class="line"><span class="lineno">  704</span>        <span class="keywordflow">return</span> _atleast_nd(arrays, result_ndim)</div>
<div class="line"><span class="lineno">  705</span> </div>
<div class="line"><span class="lineno">  706</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afc04fcff7e967ef1a48aa2f667416b97" name="afc04fcff7e967ef1a48aa2f667416b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc04fcff7e967ef1a48aa2f667416b97">&#9670;&#160;</a></span>_block_check_depths_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block_check_depths_match </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent_index</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Recursive function checking that the depths of nested lists in `arrays`
all match. Mismatch raises a ValueError as described in the block
docstring below.

The entire index (rather than just the depth) needs to be calculated
for each innermost list, in case an error needs to be raised, so that
the index of the offending list can be printed as part of the error.

Parameters
----------
arrays : nested list of arrays
    The arrays to check
parent_index : list of int
    The full index of `arrays` within the nested lists passed to
    `_block_check_depths_match` at the top of the recursion.

Returns
-------
first_index : list of int
    The full index of an element from the bottom of the nesting in
    `arrays`. If any element at the bottom is an empty list, this will
    refer to it, and the last index along the empty axis will be None.
max_arr_ndim : int
    The maximum of the ndims of the arrays nested in `arrays`.
final_size: int
    The number of elements in the final array. This is used the motivate
    the choice of algorithm used using benchmarking wisdom.</pre> <div class="fragment"><div class="line"><span class="lineno">  492</span><span class="keyword">def </span>_block_check_depths_match(arrays, parent_index=[]):</div>
<div class="line"><span class="lineno">  493</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    Recursive function checking that the depths of nested lists in `arrays`</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    all match. Mismatch raises a ValueError as described in the block</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    docstring below.</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    The entire index (rather than just the depth) needs to be calculated</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    for each innermost list, in case an error needs to be raised, so that</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    the index of the offending list can be printed as part of the error.</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    arrays : nested list of arrays</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        The arrays to check</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    parent_index : list of int</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        The full index of `arrays` within the nested lists passed to</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        `_block_check_depths_match` at the top of the recursion.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    first_index : list of int</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        The full index of an element from the bottom of the nesting in</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        `arrays`. If any element at the bottom is an empty list, this will</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        refer to it, and the last index along the empty axis will be None.</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    max_arr_ndim : int</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        The maximum of the ndims of the arrays nested in `arrays`.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    final_size: int</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        The number of elements in the final array. This is used the motivate</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        the choice of algorithm used using benchmarking wisdom.</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  523</span>    <span class="keywordflow">if</span> type(arrays) <span class="keywordflow">is</span> tuple:</div>
<div class="line"><span class="lineno">  524</span>        <span class="comment"># not strictly necessary, but saves us from:</span></div>
<div class="line"><span class="lineno">  525</span>        <span class="comment">#  - more than one way to do things - no point treating tuples like</span></div>
<div class="line"><span class="lineno">  526</span>        <span class="comment">#    lists</span></div>
<div class="line"><span class="lineno">  527</span>        <span class="comment">#  - horribly confusing behaviour that results when tuples are</span></div>
<div class="line"><span class="lineno">  528</span>        <span class="comment">#    treated like ndarray</span></div>
<div class="line"><span class="lineno">  529</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  530</span>            <span class="stringliteral">&#39;{} is a tuple. &#39;</span></div>
<div class="line"><span class="lineno">  531</span>            <span class="stringliteral">&#39;Only lists can be used to arrange blocks, and np.block does &#39;</span></div>
<div class="line"><span class="lineno">  532</span>            <span class="stringliteral">&#39;not allow implicit conversion from tuple to ndarray.&#39;</span>.format(</div>
<div class="line"><span class="lineno">  533</span>                _block_format_index(parent_index)</div>
<div class="line"><span class="lineno">  534</span>            )</div>
<div class="line"><span class="lineno">  535</span>        )</div>
<div class="line"><span class="lineno">  536</span>    <span class="keywordflow">elif</span> type(arrays) <span class="keywordflow">is</span> list <span class="keywordflow">and</span> len(arrays) &gt; 0:</div>
<div class="line"><span class="lineno">  537</span>        idxs_ndims = (_block_check_depths_match(arr, parent_index + [i])</div>
<div class="line"><span class="lineno">  538</span>                      <span class="keywordflow">for</span> i, arr <span class="keywordflow">in</span> enumerate(arrays))</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>        first_index, max_arr_ndim, final_size = next(idxs_ndims)</div>
<div class="line"><span class="lineno">  541</span>        <span class="keywordflow">for</span> index, ndim, size <span class="keywordflow">in</span> idxs_ndims:</div>
<div class="line"><span class="lineno">  542</span>            final_size += size</div>
<div class="line"><span class="lineno">  543</span>            <span class="keywordflow">if</span> ndim &gt; max_arr_ndim:</div>
<div class="line"><span class="lineno">  544</span>                max_arr_ndim = ndim</div>
<div class="line"><span class="lineno">  545</span>            <span class="keywordflow">if</span> len(index) != len(first_index):</div>
<div class="line"><span class="lineno">  546</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  547</span>                    <span class="stringliteral">&quot;List depths are mismatched. First element was at depth &quot;</span></div>
<div class="line"><span class="lineno">  548</span>                    <span class="stringliteral">&quot;{}, but there is an element at depth {} ({})&quot;</span>.format(</div>
<div class="line"><span class="lineno">  549</span>                        len(first_index),</div>
<div class="line"><span class="lineno">  550</span>                        len(index),</div>
<div class="line"><span class="lineno">  551</span>                        _block_format_index(index)</div>
<div class="line"><span class="lineno">  552</span>                    )</div>
<div class="line"><span class="lineno">  553</span>                )</div>
<div class="line"><span class="lineno">  554</span>            <span class="comment"># propagate our flag that indicates an empty list at the bottom</span></div>
<div class="line"><span class="lineno">  555</span>            <span class="keywordflow">if</span> index[-1] <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  556</span>                first_index = index</div>
<div class="line"><span class="lineno">  557</span> </div>
<div class="line"><span class="lineno">  558</span>        <span class="keywordflow">return</span> first_index, max_arr_ndim, final_size</div>
<div class="line"><span class="lineno">  559</span>    <span class="keywordflow">elif</span> type(arrays) <span class="keywordflow">is</span> list <span class="keywordflow">and</span> len(arrays) == 0:</div>
<div class="line"><span class="lineno">  560</span>        <span class="comment"># We&#39;ve &#39;bottomed out&#39; on an empty list</span></div>
<div class="line"><span class="lineno">  561</span>        <span class="keywordflow">return</span> parent_index + [<span class="keywordtype">None</span>], 0, 0</div>
<div class="line"><span class="lineno">  562</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  563</span>        <span class="comment"># We&#39;ve &#39;bottomed out&#39; - arrays is either a scalar or an array</span></div>
<div class="line"><span class="lineno">  564</span>        size = _size(arrays)</div>
<div class="line"><span class="lineno">  565</span>        <span class="keywordflow">return</span> parent_index, _ndim(arrays), size</div>
<div class="line"><span class="lineno">  566</span> </div>
<div class="line"><span class="lineno">  567</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a99de516e514ffbf926a53c64349905d3" name="a99de516e514ffbf926a53c64349905d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99de516e514ffbf926a53c64349905d3">&#9670;&#160;</a></span>_block_concatenate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block_concatenate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>list_ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result_ndim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  930</span><span class="keyword">def </span>_block_concatenate(arrays, list_ndim, result_ndim):</div>
<div class="line"><span class="lineno">  931</span>    result = _block(arrays, list_ndim, result_ndim)</div>
<div class="line"><span class="lineno">  932</span>    <span class="keywordflow">if</span> list_ndim == 0:</div>
<div class="line"><span class="lineno">  933</span>        <span class="comment"># Catch an edge case where _block returns a view because</span></div>
<div class="line"><span class="lineno">  934</span>        <span class="comment"># `arrays` is a single numpy array and not a list of numpy arrays.</span></div>
<div class="line"><span class="lineno">  935</span>        <span class="comment"># This might copy scalars or lists twice, but this isn&#39;t a likely</span></div>
<div class="line"><span class="lineno">  936</span>        <span class="comment"># usecase for those interested in performance</span></div>
<div class="line"><span class="lineno">  937</span>        result = result.copy()</div>
<div class="line"><span class="lineno">  938</span>    <span class="keywordflow">return</span> result</div>
</div><!-- fragment -->
</div>
</div>
<a id="a90e088c596f2b6c767fa6a3a317ab82a" name="a90e088c596f2b6c767fa6a3a317ab82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e088c596f2b6c767fa6a3a317ab82a">&#9670;&#160;</a></span>_block_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  707</span><span class="keyword">def </span>_block_dispatcher(arrays):</div>
<div class="line"><span class="lineno">  708</span>    <span class="comment"># Use type(...) is list to match the behavior of np.block(), which special</span></div>
<div class="line"><span class="lineno">  709</span>    <span class="comment"># cases list specifically rather than allowing for generic iterables or</span></div>
<div class="line"><span class="lineno">  710</span>    <span class="comment"># tuple. Also, we know that list.__array_function__ will never exist.</span></div>
<div class="line"><span class="lineno">  711</span>    <span class="keywordflow">if</span> type(arrays) <span class="keywordflow">is</span> list:</div>
<div class="line"><span class="lineno">  712</span>        <span class="keywordflow">for</span> subarrays <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno">  713</span>            <span class="keywordflow">yield</span> <span class="keyword">from</span> _block_dispatcher(subarrays)</div>
<div class="line"><span class="lineno">  714</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  715</span>        <span class="keywordflow">yield</span> arrays</div>
<div class="line"><span class="lineno">  716</span> </div>
<div class="line"><span class="lineno">  717</span> </div>
<div class="line"><span class="lineno">  718</span><span class="preprocessor">@array_function_dispatch(_block_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5571456ff00d0df51d026c89f9840ce8" name="a5571456ff00d0df51d026c89f9840ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5571456ff00d0df51d026c89f9840ce8">&#9670;&#160;</a></span>_block_format_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block_format_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a list of indices ``[0, 1, 2]`` into ``"arrays[0][1][2]"``.
</pre> <div class="fragment"><div class="line"><span class="lineno">  484</span><span class="keyword">def </span>_block_format_index(index):</div>
<div class="line"><span class="lineno">  485</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    Convert a list of indices ``[0, 1, 2]`` into ``&quot;arrays[0][1][2]&quot;``.</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  488</span>    idx_str = <span class="stringliteral">&#39;&#39;</span>.join(<span class="stringliteral">&#39;[{}]&#39;</span>.format(i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> index <span class="keywordflow">if</span> i <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  489</span>    <span class="keywordflow">return</span> <span class="stringliteral">&#39;arrays&#39;</span> + idx_str</div>
<div class="line"><span class="lineno">  490</span> </div>
<div class="line"><span class="lineno">  491</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3ab2762d3a51e6e21b3d36db17c5e2f" name="ad3ab2762d3a51e6e21b3d36db17c5e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ab2762d3a51e6e21b3d36db17c5e2f">&#9670;&#160;</a></span>_block_info_recursion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block_info_recursion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result_ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the shape of the final array, along with a list
of slices and a list of arrays that can be used for assignment inside the
new array

Parameters
----------
arrays : nested list of arrays
    The arrays to check
max_depth : list of int
    The number of nested lists
result_ndim : int
    The number of dimensions in thefinal array.

Returns
-------
shape : tuple of int
    The shape that the final array will take on.
slices: list of tuple of slices
    The slices into the full array required for assignment. These are
    required to be prepended with ``(Ellipsis, )`` to obtain to correct
    final index.
arrays: list of ndarray
    The data to assign to each slice of the full array</pre> <div class="fragment"><div class="line"><span class="lineno">  635</span><span class="keyword">def </span>_block_info_recursion(arrays, max_depth, result_ndim, depth=0):</div>
<div class="line"><span class="lineno">  636</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    Returns the shape of the final array, along with a list</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    of slices and a list of arrays that can be used for assignment inside the</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    new array</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    arrays : nested list of arrays</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">        The arrays to check</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    max_depth : list of int</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">        The number of nested lists</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    result_ndim : int</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">        The number of dimensions in thefinal array.</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    shape : tuple of int</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        The shape that the final array will take on.</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    slices: list of tuple of slices</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">        The slices into the full array required for assignment. These are</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        required to be prepended with ``(Ellipsis, )`` to obtain to correct</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">        final index.</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    arrays: list of ndarray</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        The data to assign to each slice of the full array</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  662</span>    <span class="keywordflow">if</span> depth &lt; max_depth:</div>
<div class="line"><span class="lineno">  663</span>        shapes, slices, arrays = zip(</div>
<div class="line"><span class="lineno">  664</span>            *[_block_info_recursion(arr, max_depth, result_ndim, depth+1)</div>
<div class="line"><span class="lineno">  665</span>              <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays])</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span>        axis = result_ndim - max_depth + depth</div>
<div class="line"><span class="lineno">  668</span>        shape, slice_prefixes = _concatenate_shapes(shapes, axis)</div>
<div class="line"><span class="lineno">  669</span> </div>
<div class="line"><span class="lineno">  670</span>        <span class="comment"># Prepend the slice prefix and flatten the slices</span></div>
<div class="line"><span class="lineno">  671</span>        slices = [slice_prefix + the_slice</div>
<div class="line"><span class="lineno">  672</span>                  <span class="keywordflow">for</span> slice_prefix, inner_slices <span class="keywordflow">in</span> zip(slice_prefixes, slices)</div>
<div class="line"><span class="lineno">  673</span>                  <span class="keywordflow">for</span> the_slice <span class="keywordflow">in</span> inner_slices]</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span>        <span class="comment"># Flatten the array list</span></div>
<div class="line"><span class="lineno">  676</span>        arrays = functools.reduce(operator.add, arrays)</div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span>        <span class="keywordflow">return</span> shape, slices, arrays</div>
<div class="line"><span class="lineno">  679</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  680</span>        <span class="comment"># We&#39;ve &#39;bottomed out&#39; - arrays is either a scalar or an array</span></div>
<div class="line"><span class="lineno">  681</span>        <span class="comment"># type(arrays) is not list</span></div>
<div class="line"><span class="lineno">  682</span>        <span class="comment"># Return the slice and the array inside a list to be consistent with</span></div>
<div class="line"><span class="lineno">  683</span>        <span class="comment"># the recursive case.</span></div>
<div class="line"><span class="lineno">  684</span>        arr = _atleast_nd(arrays, result_ndim)</div>
<div class="line"><span class="lineno">  685</span>        <span class="keywordflow">return</span> arr.shape, [()], [arr]</div>
<div class="line"><span class="lineno">  686</span> </div>
<div class="line"><span class="lineno">  687</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e2a9f3e8deed7aabab9b05c901f9aba" name="a3e2a9f3e8deed7aabab9b05c901f9aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2a9f3e8deed7aabab9b05c901f9aba">&#9670;&#160;</a></span>_block_setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block_setup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns
(`arrays`, list_ndim, result_ndim, final_size)
</pre> <div class="fragment"><div class="line"><span class="lineno">  894</span><span class="keyword">def </span>_block_setup(arrays):</div>
<div class="line"><span class="lineno">  895</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    (`arrays`, list_ndim, result_ndim, final_size)</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  899</span>    bottom_index, arr_ndim, final_size = _block_check_depths_match(arrays)</div>
<div class="line"><span class="lineno">  900</span>    list_ndim = len(bottom_index)</div>
<div class="line"><span class="lineno">  901</span>    <span class="keywordflow">if</span> bottom_index <span class="keywordflow">and</span> bottom_index[-1] <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  902</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  903</span>            <span class="stringliteral">&#39;List at {} cannot be empty&#39;</span>.format(</div>
<div class="line"><span class="lineno">  904</span>                _block_format_index(bottom_index)</div>
<div class="line"><span class="lineno">  905</span>            )</div>
<div class="line"><span class="lineno">  906</span>        )</div>
<div class="line"><span class="lineno">  907</span>    result_ndim = max(arr_ndim, list_ndim)</div>
<div class="line"><span class="lineno">  908</span>    <span class="keywordflow">return</span> arrays, list_ndim, result_ndim, final_size</div>
<div class="line"><span class="lineno">  909</span> </div>
<div class="line"><span class="lineno">  910</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b65f06ab88270f1e3292674e4da714c" name="a3b65f06ab88270f1e3292674e4da714c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b65f06ab88270f1e3292674e4da714c">&#9670;&#160;</a></span>_block_slicing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._block_slicing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>list_ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result_ndim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  911</span><span class="keyword">def </span>_block_slicing(arrays, list_ndim, result_ndim):</div>
<div class="line"><span class="lineno">  912</span>    shape, slices, arrays = _block_info_recursion(</div>
<div class="line"><span class="lineno">  913</span>        arrays, list_ndim, result_ndim)</div>
<div class="line"><span class="lineno">  914</span>    dtype = _nx.result_type(*[arr.dtype <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays])</div>
<div class="line"><span class="lineno">  915</span> </div>
<div class="line"><span class="lineno">  916</span>    <span class="comment"># Test preferring F only in the case that all input arrays are F</span></div>
<div class="line"><span class="lineno">  917</span>    F_order = all(arr.flags[<span class="stringliteral">&#39;F_CONTIGUOUS&#39;</span>] <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays)</div>
<div class="line"><span class="lineno">  918</span>    C_order = all(arr.flags[<span class="stringliteral">&#39;C_CONTIGUOUS&#39;</span>] <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays)</div>
<div class="line"><span class="lineno">  919</span>    order = <span class="stringliteral">&#39;F&#39;</span> <span class="keywordflow">if</span> F_order <span class="keywordflow">and</span> <span class="keywordflow">not</span> C_order <span class="keywordflow">else</span> <span class="stringliteral">&#39;C&#39;</span></div>
<div class="line"><span class="lineno">  920</span>    result = _nx.empty(shape=shape, dtype=dtype, order=order)</div>
<div class="line"><span class="lineno">  921</span>    <span class="comment"># Note: In a c implementation, the function</span></div>
<div class="line"><span class="lineno">  922</span>    <span class="comment"># PyArray_CreateMultiSortedStridePerm could be used for more advanced</span></div>
<div class="line"><span class="lineno">  923</span>    <span class="comment"># guessing of the desired order.</span></div>
<div class="line"><span class="lineno">  924</span> </div>
<div class="line"><span class="lineno">  925</span>    <span class="keywordflow">for</span> the_slice, arr <span class="keywordflow">in</span> zip(slices, arrays):</div>
<div class="line"><span class="lineno">  926</span>        result[(Ellipsis,) + the_slice] = arr</div>
<div class="line"><span class="lineno">  927</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  928</span> </div>
<div class="line"><span class="lineno">  929</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a45dfb8ef3c9c2aa8f363bf77347a3ac8" name="a45dfb8ef3c9c2aa8f363bf77347a3ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dfb8ef3c9c2aa8f363bf77347a3ac8">&#9670;&#160;</a></span>_concatenate_shapes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._concatenate_shapes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Given array shapes, return the resulting shape and slices prefixes.

These help in nested concatenation.

Returns
-------
shape: tuple of int
    This tuple satisfies::

        shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)
        shape == concatenate(arrs, axis).shape

slice_prefixes: tuple of (slice(start, end), )
    For a list of arrays being concatenated, this returns the slice
    in the larger array at axis that needs to be sliced into.

    For example, the following holds::

        ret = concatenate([a, b, c], axis)
        _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis)

        ret[(slice(None),) * axis + sl_a] == a
        ret[(slice(None),) * axis + sl_b] == b
        ret[(slice(None),) * axis + sl_c] == c

    These are called slice prefixes since they are used in the recursive
    blocking algorithm to compute the left-most slices during the
    recursion. Therefore, they must be prepended to rest of the slice
    that was computed deeper in the recursion.

    These are returned as tuples to ensure that they can quickly be added
    to existing slice tuple without creating a new tuple every time.</pre> <div class="fragment"><div class="line"><span class="lineno">  578</span><span class="keyword">def </span>_concatenate_shapes(shapes, axis):</div>
<div class="line"><span class="lineno">  579</span>    <span class="stringliteral">&quot;&quot;&quot;Given array shapes, return the resulting shape and slices prefixes.</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    These help in nested concatenation.</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    shape: tuple of int</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        This tuple satisfies::</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">            shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">            shape == concatenate(arrs, axis).shape</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    slice_prefixes: tuple of (slice(start, end), )</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        For a list of arrays being concatenated, this returns the slice</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        in the larger array at axis that needs to be sliced into.</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        For example, the following holds::</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">            ret = concatenate([a, b, c], axis)</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">            _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis)</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">            ret[(slice(None),) * axis + sl_a] == a</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">            ret[(slice(None),) * axis + sl_b] == b</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">            ret[(slice(None),) * axis + sl_c] == c</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        These are called slice prefixes since they are used in the recursive</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        blocking algorithm to compute the left-most slices during the</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        recursion. Therefore, they must be prepended to rest of the slice</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">        that was computed deeper in the recursion.</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">        These are returned as tuples to ensure that they can quickly be added</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">        to existing slice tuple without creating a new tuple every time.</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  613</span>    <span class="comment"># Cache a result that will be reused.</span></div>
<div class="line"><span class="lineno">  614</span>    shape_at_axis = [shape[axis] <span class="keywordflow">for</span> shape <span class="keywordflow">in</span> shapes]</div>
<div class="line"><span class="lineno">  615</span> </div>
<div class="line"><span class="lineno">  616</span>    <span class="comment"># Take a shape, any shape</span></div>
<div class="line"><span class="lineno">  617</span>    first_shape = shapes[0]</div>
<div class="line"><span class="lineno">  618</span>    first_shape_pre = first_shape[:axis]</div>
<div class="line"><span class="lineno">  619</span>    first_shape_post = first_shape[axis+1:]</div>
<div class="line"><span class="lineno">  620</span> </div>
<div class="line"><span class="lineno">  621</span>    <span class="keywordflow">if</span> any(shape[:axis] != first_shape_pre <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  622</span>           shape[axis+1:] != first_shape_post <span class="keywordflow">for</span> shape <span class="keywordflow">in</span> shapes):</div>
<div class="line"><span class="lineno">  623</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  624</span>            <span class="stringliteral">&#39;Mismatched array shapes in block along axis {}.&#39;</span>.format(axis))</div>
<div class="line"><span class="lineno">  625</span> </div>
<div class="line"><span class="lineno">  626</span>    shape = (first_shape_pre + (sum(shape_at_axis),) + first_shape[axis+1:])</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>    offsets_at_axis = _accumulate(shape_at_axis)</div>
<div class="line"><span class="lineno">  629</span>    slice_prefixes = [(slice(start, end),)</div>
<div class="line"><span class="lineno">  630</span>                      <span class="keywordflow">for</span> start, end <span class="keywordflow">in</span> zip([0] + offsets_at_axis,</div>
<div class="line"><span class="lineno">  631</span>                                            offsets_at_axis)]</div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">return</span> shape, slice_prefixes</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4fcc1ef3610bca18582008d8e55944df" name="a4fcc1ef3610bca18582008d8e55944df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcc1ef3610bca18582008d8e55944df">&#9670;&#160;</a></span>_stack_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._stack_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  374</span>                      dtype=<span class="keywordtype">None</span>, casting=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  375</span>    arrays = _arrays_for_stack_dispatcher(arrays, stacklevel=6)</div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  377</span>        <span class="comment"># optimize for the typical case where only arrays is provided</span></div>
<div class="line"><span class="lineno">  378</span>        arrays = list(arrays)</div>
<div class="line"><span class="lineno">  379</span>        arrays.append(out)</div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">return</span> arrays</div>
<div class="line"><span class="lineno">  381</span> </div>
<div class="line"><span class="lineno">  382</span> </div>
<div class="line"><span class="lineno">  383</span><span class="preprocessor">@array_function_dispatch(_stack_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afbb11fa31905335cc1e55ed60455706f" name="afbb11fa31905335cc1e55ed60455706f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb11fa31905335cc1e55ed60455706f">&#9670;&#160;</a></span>_vhstack_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._vhstack_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  219</span>                        dtype=<span class="keywordtype">None</span>, casting=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  220</span>    <span class="keywordflow">return</span> _arrays_for_stack_dispatcher(tup)</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span><span class="preprocessor">@array_function_dispatch(_vhstack_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae705b9a3271089f51809c99a224dcf4b" name="ae705b9a3271089f51809c99a224dcf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae705b9a3271089f51809c99a224dcf4b">&#9670;&#160;</a></span>atleast_1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.atleast_1d </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert inputs to arrays with at least one dimension.

Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.

Parameters
----------
arys1, arys2, ... : array_like
    One or more input arrays.

Returns
-------
ret : ndarray
    An array, or list of arrays, each with ``a.ndim &gt;= 1``.
    Copies are made only if necessary.

See Also
--------
atleast_2d, atleast_3d

Examples
--------
&gt;&gt;&gt; np.atleast_1d(1.0)
array([1.])

&gt;&gt;&gt; x = np.arange(9.0).reshape(3,3)
&gt;&gt;&gt; np.atleast_1d(x)
array([[0., 1., 2.],
       [3., 4., 5.],
       [6., 7., 8.]])
&gt;&gt;&gt; np.atleast_1d(x) is x
True

&gt;&gt;&gt; np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</pre> <div class="fragment"><div class="line"><span class="lineno">   24</span><span class="keyword">def </span>atleast_1d(*arys):</div>
<div class="line"><span class="lineno">   25</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    Convert inputs to arrays with at least one dimension.</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    Scalar inputs are converted to 1-dimensional arrays, whilst</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">    higher-dimensional inputs are preserved.</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    arys1, arys2, ... : array_like</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">        One or more input arrays.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    ret : ndarray</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        An array, or list of arrays, each with ``a.ndim &gt;= 1``.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        Copies are made only if necessary.</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    atleast_2d, atleast_3d</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_1d(1.0)</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    array([1.])</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(9.0).reshape(3,3)</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_1d(x)</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    array([[0., 1., 2.],</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">           [3., 4., 5.],</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">           [6., 7., 8.]])</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_1d(x) is x</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_1d(1, [3, 4])</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    [array([1]), array([3, 4])]</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   63</span>    res = []</div>
<div class="line"><span class="lineno">   64</span>    <span class="keywordflow">for</span> ary <span class="keywordflow">in</span> arys:</div>
<div class="line"><span class="lineno">   65</span>        ary = asanyarray(ary)</div>
<div class="line"><span class="lineno">   66</span>        <span class="keywordflow">if</span> ary.ndim == 0:</div>
<div class="line"><span class="lineno">   67</span>            result = ary.reshape(1)</div>
<div class="line"><span class="lineno">   68</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   69</span>            result = ary</div>
<div class="line"><span class="lineno">   70</span>        res.append(result)</div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">if</span> len(res) == 1:</div>
<div class="line"><span class="lineno">   72</span>        <span class="keywordflow">return</span> res[0]</div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   74</span>        <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">   75</span> </div>
<div class="line"><span class="lineno">   76</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0d9b91150c1c9f9e2a423dc5fd701fc" name="ae0d9b91150c1c9f9e2a423dc5fd701fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d9b91150c1c9f9e2a423dc5fd701fc">&#9670;&#160;</a></span>atleast_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.atleast_2d </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">View inputs as arrays with at least two dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.

Returns
-------
res, res2, ... : ndarray
    An array, or list of arrays, each with ``a.ndim &gt;= 2``.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.

See Also
--------
atleast_1d, atleast_3d

Examples
--------
&gt;&gt;&gt; np.atleast_2d(3.0)
array([[3.]])

&gt;&gt;&gt; x = np.arange(3.0)
&gt;&gt;&gt; np.atleast_2d(x)
array([[0., 1., 2.]])
&gt;&gt;&gt; np.atleast_2d(x).base is x
True

&gt;&gt;&gt; np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]</pre> <div class="fragment"><div class="line"><span class="lineno">   82</span><span class="keyword">def </span>atleast_2d(*arys):</div>
<div class="line"><span class="lineno">   83</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    View inputs as arrays with at least two dimensions.</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    arys1, arys2, ... : array_like</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        One or more array-like sequences.  Non-array inputs are converted</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        to arrays.  Arrays that already have two or more dimensions are</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        preserved.</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    res, res2, ... : ndarray</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        An array, or list of arrays, each with ``a.ndim &gt;= 2``.</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        Copies are avoided where possible, and views with two or more</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        dimensions are returned.</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    atleast_1d, atleast_3d</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_2d(3.0)</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    array([[3.]])</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(3.0)</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_2d(x)</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    array([[0., 1., 2.]])</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_2d(x).base is x</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_2d(1, [1, 2], [[1, 2]])</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    [array([[1]]), array([[1, 2]]), array([[1, 2]])]</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  119</span>    res = []</div>
<div class="line"><span class="lineno">  120</span>    <span class="keywordflow">for</span> ary <span class="keywordflow">in</span> arys:</div>
<div class="line"><span class="lineno">  121</span>        ary = asanyarray(ary)</div>
<div class="line"><span class="lineno">  122</span>        <span class="keywordflow">if</span> ary.ndim == 0:</div>
<div class="line"><span class="lineno">  123</span>            result = ary.reshape(1, 1)</div>
<div class="line"><span class="lineno">  124</span>        <span class="keywordflow">elif</span> ary.ndim == 1:</div>
<div class="line"><span class="lineno">  125</span>            result = ary[_nx.newaxis, :]</div>
<div class="line"><span class="lineno">  126</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  127</span>            result = ary</div>
<div class="line"><span class="lineno">  128</span>        res.append(result)</div>
<div class="line"><span class="lineno">  129</span>    <span class="keywordflow">if</span> len(res) == 1:</div>
<div class="line"><span class="lineno">  130</span>        <span class="keywordflow">return</span> res[0]</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e0cf3b0a03bde8d9c432387e90e2566" name="a9e0cf3b0a03bde8d9c432387e90e2566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0cf3b0a03bde8d9c432387e90e2566">&#9670;&#160;</a></span>atleast_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.atleast_3d </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>arys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">View inputs as arrays with at least three dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted to
    arrays.  Arrays that already have three or more dimensions are
    preserved.

Returns
-------
res1, res2, ... : ndarray
    An array, or list of arrays, each with ``a.ndim &gt;= 3``.  Copies are
    avoided where possible, and views with three or more dimensions are
    returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
    view of shape ``(M, N, 1)``.

See Also
--------
atleast_1d, atleast_2d

Examples
--------
&gt;&gt;&gt; np.atleast_3d(3.0)
array([[[3.]]])

&gt;&gt;&gt; x = np.arange(3.0)
&gt;&gt;&gt; np.atleast_3d(x).shape
(1, 3, 1)

&gt;&gt;&gt; x = np.arange(12.0).reshape(4,3)
&gt;&gt;&gt; np.atleast_3d(x).shape
(4, 3, 1)
&gt;&gt;&gt; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
True

&gt;&gt;&gt; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
...     print(arr, arr.shape) # doctest: +SKIP
...
[[[1]
  [2]]] (1, 2, 1)
[[[1]
  [2]]] (1, 2, 1)
[[[1 2]]] (1, 1, 2)</pre> <div class="fragment"><div class="line"><span class="lineno">  140</span><span class="keyword">def </span>atleast_3d(*arys):</div>
<div class="line"><span class="lineno">  141</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    View inputs as arrays with at least three dimensions.</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    arys1, arys2, ... : array_like</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">        One or more array-like sequences.  Non-array inputs are converted to</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">        arrays.  Arrays that already have three or more dimensions are</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        preserved.</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    res1, res2, ... : ndarray</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        An array, or list of arrays, each with ``a.ndim &gt;= 3``.  Copies are</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        avoided where possible, and views with three or more dimensions are</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        view of shape ``(M, N, 1)``.</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    atleast_1d, atleast_2d</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_3d(3.0)</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    array([[[3.]]])</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(3.0)</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_3d(x).shape</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    (1, 3, 1)</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(12.0).reshape(4,3)</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_3d(x).shape</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    (4, 3, 1)</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    &gt;&gt;&gt; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    &gt;&gt;&gt; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    ...     print(arr, arr.shape) # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    [[[1]</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">      [2]]] (1, 2, 1)</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    [[[1]</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">      [2]]] (1, 2, 1)</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    [[[1 2]]] (1, 1, 2)</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  189</span>    res = []</div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">for</span> ary <span class="keywordflow">in</span> arys:</div>
<div class="line"><span class="lineno">  191</span>        ary = asanyarray(ary)</div>
<div class="line"><span class="lineno">  192</span>        <span class="keywordflow">if</span> ary.ndim == 0:</div>
<div class="line"><span class="lineno">  193</span>            result = ary.reshape(1, 1, 1)</div>
<div class="line"><span class="lineno">  194</span>        <span class="keywordflow">elif</span> ary.ndim == 1:</div>
<div class="line"><span class="lineno">  195</span>            result = ary[_nx.newaxis, :, _nx.newaxis]</div>
<div class="line"><span class="lineno">  196</span>        <span class="keywordflow">elif</span> ary.ndim == 2:</div>
<div class="line"><span class="lineno">  197</span>            result = ary[:, :, _nx.newaxis]</div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  199</span>            result = ary</div>
<div class="line"><span class="lineno">  200</span>        res.append(result)</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">if</span> len(res) == 1:</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">return</span> res[0]</div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  204</span>        <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  205</span> </div>
<div class="line"><span class="lineno">  206</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b892426ce4cdcaceea3908b51dff188" name="a9b892426ce4cdcaceea3908b51dff188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b892426ce4cdcaceea3908b51dff188">&#9670;&#160;</a></span>block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.block </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assemble an nd-array from nested lists of blocks.

Blocks in the innermost lists are concatenated (see `concatenate`) along
the last dimension (-1), then these are concatenated along the
second-last dimension (-2), and so on until the outermost list is reached.

Blocks can be of any dimension, but will not be broadcasted using the normal
rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``
the same for all blocks. This is primarily useful for working with scalars,
and means that code like ``np.block([v, 1])`` is valid, where
``v.ndim == 1``.

When the nested list is two levels deep, this allows block matrices to be
constructed from their components.

.. versionadded:: 1.13.0

Parameters
----------
arrays : nested list of array_like or scalars (but not tuples)
    If passed a single ndarray or scalar (a nested list of depth 0), this
    is returned unmodified (and not copied).

    Elements shapes must match along the appropriate axes (without
    broadcasting), but leading 1s will be prepended to the shape as
    necessary to make the dimensions match.

Returns
-------
block_array : ndarray
    The array assembled from the given blocks.

    The dimensionality of the output is equal to the greatest of:
    * the dimensionality of all the inputs
    * the depth to which the input list is nested

Raises
------
ValueError
    * If list depths are mismatched - for instance, ``[[a, b], c]`` is
      illegal, and should be spelt ``[[a, b], [c]]``
    * If lists are empty - for instance, ``[[a, b], []]``

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
vstack : Stack arrays in sequence vertically (row wise).
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
vsplit : Split an array into multiple sub-arrays vertically (row-wise).

Notes
-----

When called with only scalars, ``np.block`` is equivalent to an ndarray
call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to
``np.array([[1, 2], [3, 4]])``.

This function does not enforce that the blocks lie on a fixed grid.
``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::

    AAAbb
    AAAbb
    cccDD

But is also allowed to produce, for some ``a, b, c, d``::

    AAAbb
    AAAbb
    cDDDD

Since concatenation happens along the last axis first, `block` is _not_
capable of producing the following directly::

    AAAbb
    cccbb
    cccDD

Matlab's "square bracket stacking", ``[A, B, ...; p, q, ...]``, is
equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.

Examples
--------
The most common use of this function is to build a block matrix

&gt;&gt;&gt; A = np.eye(2) * 2
&gt;&gt;&gt; B = np.eye(3) * 3
&gt;&gt;&gt; np.block([
...     [A,               np.zeros((2, 3))],
...     [np.ones((3, 2)), B               ]
... ])
array([[2., 0., 0., 0., 0.],
       [0., 2., 0., 0., 0.],
       [1., 1., 3., 0., 0.],
       [1., 1., 0., 3., 0.],
       [1., 1., 0., 0., 3.]])

With a list of depth 1, `block` can be used as `hstack`

&gt;&gt;&gt; np.block([1, 2, 3])              # hstack([1, 2, 3])
array([1, 2, 3])

&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([4, 5, 6])
&gt;&gt;&gt; np.block([a, b, 10])             # hstack([a, b, 10])
array([ 1,  2,  3,  4,  5,  6, 10])

&gt;&gt;&gt; A = np.ones((2, 2), int)
&gt;&gt;&gt; B = 2 * A
&gt;&gt;&gt; np.block([A, B])                 # hstack([A, B])
array([[1, 1, 2, 2],
       [1, 1, 2, 2]])

With a list of depth 2, `block` can be used in place of `vstack`:

&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([4, 5, 6])
&gt;&gt;&gt; np.block([[a], [b]])             # vstack([a, b])
array([[1, 2, 3],
       [4, 5, 6]])

&gt;&gt;&gt; A = np.ones((2, 2), int)
&gt;&gt;&gt; B = 2 * A
&gt;&gt;&gt; np.block([[A], [B]])             # vstack([A, B])
array([[1, 1],
       [1, 1],
       [2, 2],
       [2, 2]])

It can also be used in places of `atleast_1d` and `atleast_2d`

&gt;&gt;&gt; a = np.array(0)
&gt;&gt;&gt; b = np.array([1])
&gt;&gt;&gt; np.block([a])                    # atleast_1d(a)
array([0])
&gt;&gt;&gt; np.block([b])                    # atleast_1d(b)
array([1])

&gt;&gt;&gt; np.block([[a]])                  # atleast_2d(a)
array([[0]])
&gt;&gt;&gt; np.block([[b]])                  # atleast_2d(b)
array([[1]])</pre> <div class="fragment"><div class="line"><span class="lineno">  719</span><span class="keyword">def </span>block(arrays):</div>
<div class="line"><span class="lineno">  720</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    Assemble an nd-array from nested lists of blocks.</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    Blocks in the innermost lists are concatenated (see `concatenate`) along</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    the last dimension (-1), then these are concatenated along the</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    second-last dimension (-2), and so on until the outermost list is reached.</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    Blocks can be of any dimension, but will not be broadcasted using the normal</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    the same for all blocks. This is primarily useful for working with scalars,</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    and means that code like ``np.block([v, 1])`` is valid, where</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    ``v.ndim == 1``.</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    When the nested list is two levels deep, this allows block matrices to be</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    constructed from their components.</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    .. versionadded:: 1.13.0</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    arrays : nested list of array_like or scalars (but not tuples)</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">        If passed a single ndarray or scalar (a nested list of depth 0), this</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">        is returned unmodified (and not copied).</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        Elements shapes must match along the appropriate axes (without</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        broadcasting), but leading 1s will be prepended to the shape as</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        necessary to make the dimensions match.</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    block_array : ndarray</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        The array assembled from the given blocks.</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        The dimensionality of the output is equal to the greatest of:</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        * the dimensionality of all the inputs</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        * the depth to which the input list is nested</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        * If list depths are mismatched - for instance, ``[[a, b], c]`` is</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">          illegal, and should be spelt ``[[a, b], [c]]``</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        * If lists are empty - for instance, ``[[a, b], []]``</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    concatenate : Join a sequence of arrays along an existing axis.</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    stack : Join a sequence of arrays along a new axis.</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    vstack : Stack arrays in sequence vertically (row wise).</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    hstack : Stack arrays in sequence horizontally (column wise).</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    dstack : Stack arrays in sequence depth wise (along third axis).</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    column_stack : Stack 1-D arrays as columns into a 2-D array.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    vsplit : Split an array into multiple sub-arrays vertically (row-wise).</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    When called with only scalars, ``np.block`` is equivalent to an ndarray</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    ``np.array([[1, 2], [3, 4]])``.</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    This function does not enforce that the blocks lie on a fixed grid.</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    ``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        AAAbb</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        AAAbb</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        cccDD</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">    But is also allowed to produce, for some ``a, b, c, d``::</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">        AAAbb</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">        AAAbb</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        cDDDD</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    Since concatenation happens along the last axis first, `block` is _not_</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    capable of producing the following directly::</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">        AAAbb</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        cccbb</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        cccDD</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    Matlab&#39;s &quot;square bracket stacking&quot;, ``[A, B, ...; p, q, ...]``, is</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    The most common use of this function is to build a block matrix</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    &gt;&gt;&gt; A = np.eye(2) * 2</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    &gt;&gt;&gt; B = np.eye(3) * 3</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    &gt;&gt;&gt; np.block([</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    ...     [A,               np.zeros((2, 3))],</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    ...     [np.ones((3, 2)), B               ]</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    ... ])</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    array([[2., 0., 0., 0., 0.],</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">           [0., 2., 0., 0., 0.],</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">           [1., 1., 3., 0., 0.],</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">           [1., 1., 0., 3., 0.],</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">           [1., 1., 0., 0., 3.]])</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    With a list of depth 1, `block` can be used as `hstack`</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    &gt;&gt;&gt; np.block([1, 2, 3])              # hstack([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([4, 5, 6])</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    &gt;&gt;&gt; np.block([a, b, 10])             # hstack([a, b, 10])</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    array([ 1,  2,  3,  4,  5,  6, 10])</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    &gt;&gt;&gt; A = np.ones((2, 2), int)</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    &gt;&gt;&gt; B = 2 * A</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    &gt;&gt;&gt; np.block([A, B])                 # hstack([A, B])</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    array([[1, 1, 2, 2],</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">           [1, 1, 2, 2]])</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    With a list of depth 2, `block` can be used in place of `vstack`:</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([4, 5, 6])</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    &gt;&gt;&gt; np.block([[a], [b]])             # vstack([a, b])</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">           [4, 5, 6]])</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    &gt;&gt;&gt; A = np.ones((2, 2), int)</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    &gt;&gt;&gt; B = 2 * A</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    &gt;&gt;&gt; np.block([[A], [B]])             # vstack([A, B])</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    array([[1, 1],</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">           [1, 1],</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">           [2, 2],</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">           [2, 2]])</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    It can also be used in places of `atleast_1d` and `atleast_2d`</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array(0)</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([1])</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    &gt;&gt;&gt; np.block([a])                    # atleast_1d(a)</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    array([0])</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    &gt;&gt;&gt; np.block([b])                    # atleast_1d(b)</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    array([1])</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    &gt;&gt;&gt; np.block([[a]])                  # atleast_2d(a)</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    array([[0]])</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    &gt;&gt;&gt; np.block([[b]])                  # atleast_2d(b)</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    array([[1]])</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  868</span>    arrays, list_ndim, result_ndim, final_size = _block_setup(arrays)</div>
<div class="line"><span class="lineno">  869</span> </div>
<div class="line"><span class="lineno">  870</span>    <span class="comment"># It was found through benchmarking that making an array of final size</span></div>
<div class="line"><span class="lineno">  871</span>    <span class="comment"># around 256x256 was faster by straight concatenation on a</span></div>
<div class="line"><span class="lineno">  872</span>    <span class="comment"># i7-7700HQ processor and dual channel ram 2400MHz.</span></div>
<div class="line"><span class="lineno">  873</span>    <span class="comment"># It didn&#39;t seem to matter heavily on the dtype used.</span></div>
<div class="line"><span class="lineno">  874</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  875</span>    <span class="comment"># A 2D array using repeated concatenation requires 2 copies of the array.</span></div>
<div class="line"><span class="lineno">  876</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  877</span>    <span class="comment"># The fastest algorithm will depend on the ratio of CPU power to memory</span></div>
<div class="line"><span class="lineno">  878</span>    <span class="comment"># speed.</span></div>
<div class="line"><span class="lineno">  879</span>    <span class="comment"># One can monitor the results of the benchmark</span></div>
<div class="line"><span class="lineno">  880</span>    <span class="comment"># https://pv.github.io/numpy-bench/#bench_shape_base.Block2D.time_block2d</span></div>
<div class="line"><span class="lineno">  881</span>    <span class="comment"># to tune this parameter until a C version of the `_block_info_recursion`</span></div>
<div class="line"><span class="lineno">  882</span>    <span class="comment"># algorithm is implemented which would likely be faster than the python</span></div>
<div class="line"><span class="lineno">  883</span>    <span class="comment"># version.</span></div>
<div class="line"><span class="lineno">  884</span>    <span class="keywordflow">if</span> list_ndim * final_size &gt; (2 * 512 * 512):</div>
<div class="line"><span class="lineno">  885</span>        <span class="keywordflow">return</span> _block_slicing(arrays, list_ndim, result_ndim)</div>
<div class="line"><span class="lineno">  886</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  887</span>        <span class="keywordflow">return</span> _block_concatenate(arrays, list_ndim, result_ndim)</div>
<div class="line"><span class="lineno">  888</span> </div>
<div class="line"><span class="lineno">  889</span> </div>
<div class="line"><span class="lineno">  890</span><span class="comment"># These helper functions are mostly used for testing.</span></div>
<div class="line"><span class="lineno">  891</span><span class="comment"># They allow us to write tests that directly call `_block_slicing`</span></div>
<div class="line"><span class="lineno">  892</span><span class="comment"># or `_block_concatenate` without blocking large arrays to force the wisdom</span></div>
<div class="line"><span class="lineno">  893</span><span class="comment"># to trigger the desired path.</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abf6a7b2a0881f44ceb6dbb11d16ecee1" name="abf6a7b2a0881f44ceb6dbb11d16ecee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6a7b2a0881f44ceb6dbb11d16ecee1">&#9670;&#160;</a></span>hstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.hstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>&quot;same_kind&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stack arrays in sequence horizontally (column wise).

This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by `hsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of ndarrays
    The arrays must have the same shape along all but the second axis,
    except 1-D arrays which can be any length.

dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

.. versionadded:: 1.24

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

.. versionadded:: 1.24

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
hsplit : Split an array into multiple sub-arrays horizontally (column-wise).

Examples
--------
&gt;&gt;&gt; a = np.array((1,2,3))
&gt;&gt;&gt; b = np.array((4,5,6))
&gt;&gt;&gt; np.hstack((a,b))
array([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; a = np.array([[1],[2],[3]])
&gt;&gt;&gt; b = np.array([[4],[5],[6]])
&gt;&gt;&gt; np.hstack((a,b))
array([[1, 4],
       [2, 5],
       [3, 6]])</pre> <div class="fragment"><div class="line"><span class="lineno">  300</span><span class="keyword">def </span>hstack(tup, *, dtype=None, casting=&quot;same_kind&quot;):</div>
<div class="line"><span class="lineno">  301</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    Stack arrays in sequence horizontally (column wise).</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    This is equivalent to concatenation along the second axis, except for 1-D</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    arrays where it concatenates along the first axis. Rebuilds arrays divided</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    by `hsplit`.</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    This function makes most sense for arrays with up to 3 dimensions. For</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    instance, for pixel-data with a height (first axis), width (second axis),</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    and r/g/b channels (third axis). The functions `concatenate`, `stack` and</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    `block` provide more general stacking and concatenation operations.</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    tup : sequence of ndarrays</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">        The arrays must have the same shape along all but the second axis,</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        except 1-D arrays which can be any length.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    dtype : str or dtype</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">        If provided, the destination array will have this dtype. Cannot be</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        provided together with `out`.</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    .. versionadded:: 1.24</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">        Controls what kind of data casting may occur. Defaults to &#39;same_kind&#39;.</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    .. versionadded:: 1.24</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    stacked : ndarray</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">        The array formed by stacking the given arrays.</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    concatenate : Join a sequence of arrays along an existing axis.</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    stack : Join a sequence of arrays along a new axis.</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    block : Assemble an nd-array from nested lists of blocks.</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    vstack : Stack arrays in sequence vertically (row wise).</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    dstack : Stack arrays in sequence depth wise (along third axis).</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    column_stack : Stack 1-D arrays as columns into a 2-D array.</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    hsplit : Split an array into multiple sub-arrays horizontally (column-wise).</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array((1,2,3))</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array((4,5,6))</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    &gt;&gt;&gt; np.hstack((a,b))</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    array([1, 2, 3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1],[2],[3]])</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[4],[5],[6]])</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    &gt;&gt;&gt; np.hstack((a,b))</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    array([[1, 4],</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">           [2, 5],</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">           [3, 6]])</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  359</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> overrides.ARRAY_FUNCTION_ENABLED:</div>
<div class="line"><span class="lineno">  360</span>        <span class="comment"># raise warning if necessary</span></div>
<div class="line"><span class="lineno">  361</span>        _arrays_for_stack_dispatcher(tup, stacklevel=2)</div>
<div class="line"><span class="lineno">  362</span> </div>
<div class="line"><span class="lineno">  363</span>    arrs = atleast_1d(*tup)</div>
<div class="line"><span class="lineno">  364</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(arrs, list):</div>
<div class="line"><span class="lineno">  365</span>        arrs = [arrs]</div>
<div class="line"><span class="lineno">  366</span>    <span class="comment"># As a special case, dimension 0 of 1-dimensional arrays is &quot;horizontal&quot;</span></div>
<div class="line"><span class="lineno">  367</span>    <span class="keywordflow">if</span> arrs <span class="keywordflow">and</span> arrs[0].ndim == 1:</div>
<div class="line"><span class="lineno">  368</span>        <span class="keywordflow">return</span> _nx.concatenate(arrs, 0, dtype=dtype, casting=casting)</div>
<div class="line"><span class="lineno">  369</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  370</span>        <span class="keywordflow">return</span> _nx.concatenate(arrs, 1, dtype=dtype, casting=casting)</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8092208c70aa6a10dd743aa135b3b581" name="a8092208c70aa6a10dd743aa135b3b581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8092208c70aa6a10dd743aa135b3b581">&#9670;&#160;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.stack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>&quot;same_kind&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Join a sequence of arrays along a new axis.

The ``axis`` parameter specifies the index of the new axis in the
dimensions of the result. For example, if ``axis=0`` it will be the first
dimension and if ``axis=-1`` it will be the last dimension.

.. versionadded:: 1.10.0

Parameters
----------
arrays : sequence of array_like
    Each array must have the same shape.

axis : int, optional
    The axis in the result array along which the input arrays are stacked.

out : ndarray, optional
    If provided, the destination to place the result. The shape must be
    correct, matching that of what stack would have returned if no
    out argument were specified.

dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

    .. versionadded:: 1.24

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

    .. versionadded:: 1.24


Returns
-------
stacked : ndarray
    The stacked array has one more dimension than the input arrays.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
block : Assemble an nd-array from nested lists of blocks.
split : Split array into a list of multiple sub-arrays of equal size.

Examples
--------
&gt;&gt;&gt; arrays = [np.random.randn(3, 4) for _ in range(10)]
&gt;&gt;&gt; np.stack(arrays, axis=0).shape
(10, 3, 4)

&gt;&gt;&gt; np.stack(arrays, axis=1).shape
(3, 10, 4)

&gt;&gt;&gt; np.stack(arrays, axis=2).shape
(3, 4, 10)

&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([4, 5, 6])
&gt;&gt;&gt; np.stack((a, b))
array([[1, 2, 3],
       [4, 5, 6]])

&gt;&gt;&gt; np.stack((a, b), axis=-1)
array([[1, 4],
       [2, 5],
       [3, 6]])</pre> <div class="fragment"><div class="line"><span class="lineno">  384</span><span class="keyword">def </span>stack(arrays, axis=0, out=None, *, dtype=None, casting=&quot;same_kind&quot;):</div>
<div class="line"><span class="lineno">  385</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    Join a sequence of arrays along a new axis.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    The ``axis`` parameter specifies the index of the new axis in the</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    dimensions of the result. For example, if ``axis=0`` it will be the first</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    dimension and if ``axis=-1`` it will be the last dimension.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    arrays : sequence of array_like</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">        Each array must have the same shape.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        The axis in the result array along which the input arrays are stacked.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">        If provided, the destination to place the result. The shape must be</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">        correct, matching that of what stack would have returned if no</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        out argument were specified.</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    dtype : str or dtype</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">        If provided, the destination array will have this dtype. Cannot be</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        provided together with `out`.</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        .. versionadded:: 1.24</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">        Controls what kind of data casting may occur. Defaults to &#39;same_kind&#39;.</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        .. versionadded:: 1.24</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    stacked : ndarray</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        The stacked array has one more dimension than the input arrays.</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    concatenate : Join a sequence of arrays along an existing axis.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    block : Assemble an nd-array from nested lists of blocks.</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    split : Split array into a list of multiple sub-arrays of equal size.</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    &gt;&gt;&gt; arrays = [np.random.randn(3, 4) for _ in range(10)]</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    &gt;&gt;&gt; np.stack(arrays, axis=0).shape</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    (10, 3, 4)</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    &gt;&gt;&gt; np.stack(arrays, axis=1).shape</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    (3, 10, 4)</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    &gt;&gt;&gt; np.stack(arrays, axis=2).shape</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    (3, 4, 10)</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([4, 5, 6])</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    &gt;&gt;&gt; np.stack((a, b))</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">           [4, 5, 6]])</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    &gt;&gt;&gt; np.stack((a, b), axis=-1)</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    array([[1, 4],</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">           [2, 5],</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">           [3, 6]])</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  454</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> overrides.ARRAY_FUNCTION_ENABLED:</div>
<div class="line"><span class="lineno">  455</span>        <span class="comment"># raise warning if necessary</span></div>
<div class="line"><span class="lineno">  456</span>        _arrays_for_stack_dispatcher(arrays, stacklevel=2)</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>    arrays = [asanyarray(arr) <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays]</div>
<div class="line"><span class="lineno">  459</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> arrays:</div>
<div class="line"><span class="lineno">  460</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;need at least one array to stack&#39;</span>)</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span>    shapes = {arr.shape <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays}</div>
<div class="line"><span class="lineno">  463</span>    <span class="keywordflow">if</span> len(shapes) != 1:</div>
<div class="line"><span class="lineno">  464</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;all input arrays must have the same shape&#39;</span>)</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>    result_ndim = arrays[0].ndim + 1</div>
<div class="line"><span class="lineno">  467</span>    axis = normalize_axis_index(axis, result_ndim)</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>    sl = (slice(<span class="keywordtype">None</span>),) * axis + (_nx.newaxis,)</div>
<div class="line"><span class="lineno">  470</span>    expanded_arrays = [arr[sl] <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays]</div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordflow">return</span> _nx.concatenate(expanded_arrays, axis=axis, out=out,</div>
<div class="line"><span class="lineno">  472</span>                           dtype=dtype, casting=casting)</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span><span class="comment"># Internal functions to eliminate the overhead of repeated dispatch in one of</span></div>
<div class="line"><span class="lineno">  476</span><span class="comment"># the two possible paths inside np.block.</span></div>
<div class="line"><span class="lineno">  477</span><span class="comment"># Use getattr to protect against __array_function__ being disabled.</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a468893bd623bab5e8d9e4b2c676713f2" name="a468893bd623bab5e8d9e4b2c676713f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468893bd623bab5e8d9e4b2c676713f2">&#9670;&#160;</a></span>vstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.vstack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>&quot;same_kind&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stack arrays in sequence vertically (row wise).

This is equivalent to concatenation along the first axis after 1-D arrays
of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
`vsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

``np.row_stack`` is an alias for `vstack`. They are the same function.

Parameters
----------
tup : sequence of ndarrays
    The arrays must have the same shape along all but the first axis.
    1-D arrays must have the same length.

dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

.. versionadded:: 1.24

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

.. versionadded:: 1.24

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays, will be at least 2-D.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
vsplit : Split an array into multiple sub-arrays vertically (row-wise).

Examples
--------
&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([4, 5, 6])
&gt;&gt;&gt; np.vstack((a,b))
array([[1, 2, 3],
       [4, 5, 6]])

&gt;&gt;&gt; a = np.array([[1], [2], [3]])
&gt;&gt;&gt; b = np.array([[4], [5], [6]])
&gt;&gt;&gt; np.vstack((a,b))
array([[1],
       [2],
       [3],
       [4],
       [5],
       [6]])</pre> <div class="fragment"><div class="line"><span class="lineno">  224</span><span class="keyword">def </span>vstack(tup, *, dtype=None, casting=&quot;same_kind&quot;):</div>
<div class="line"><span class="lineno">  225</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Stack arrays in sequence vertically (row wise).</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    This is equivalent to concatenation along the first axis after 1-D arrays</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    `vsplit`.</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    This function makes most sense for arrays with up to 3 dimensions. For</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    instance, for pixel-data with a height (first axis), width (second axis),</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    and r/g/b channels (third axis). The functions `concatenate`, `stack` and</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    `block` provide more general stacking and concatenation operations.</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    ``np.row_stack`` is an alias for `vstack`. They are the same function.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    tup : sequence of ndarrays</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        The arrays must have the same shape along all but the first axis.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">        1-D arrays must have the same length.</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    dtype : str or dtype</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">        If provided, the destination array will have this dtype. Cannot be</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        provided together with `out`.</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    .. versionadded:: 1.24</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        Controls what kind of data casting may occur. Defaults to &#39;same_kind&#39;.</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    .. versionadded:: 1.24</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    stacked : ndarray</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        The array formed by stacking the given arrays, will be at least 2-D.</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    concatenate : Join a sequence of arrays along an existing axis.</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    stack : Join a sequence of arrays along a new axis.</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    block : Assemble an nd-array from nested lists of blocks.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    hstack : Stack arrays in sequence horizontally (column wise).</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    dstack : Stack arrays in sequence depth wise (along third axis).</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    column_stack : Stack 1-D arrays as columns into a 2-D array.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    vsplit : Split an array into multiple sub-arrays vertically (row-wise).</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([4, 5, 6])</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    &gt;&gt;&gt; np.vstack((a,b))</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">           [4, 5, 6]])</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1], [2], [3]])</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[4], [5], [6]])</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    &gt;&gt;&gt; np.vstack((a,b))</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    array([[1],</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">           [2],</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">           [3],</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">           [4],</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">           [5],</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">           [6]])</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  290</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> overrides.ARRAY_FUNCTION_ENABLED:</div>
<div class="line"><span class="lineno">  291</span>        <span class="comment"># raise warning if necessary</span></div>
<div class="line"><span class="lineno">  292</span>        _arrays_for_stack_dispatcher(tup, stacklevel=2)</div>
<div class="line"><span class="lineno">  293</span>    arrs = atleast_2d(*tup)</div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(arrs, list):</div>
<div class="line"><span class="lineno">  295</span>        arrs = [arrs]</div>
<div class="line"><span class="lineno">  296</span>    <span class="keywordflow">return</span> _nx.concatenate(arrs, 0, dtype=dtype, casting=casting)</div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span> </div>
<div class="line"><span class="lineno">  299</span><span class="preprocessor">@array_function_dispatch(_vhstack_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acf5eb5150180bd32e4fe7c6a81e8ae95" name="acf5eb5150180bd32e4fe7c6a81e8ae95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5eb5150180bd32e4fe7c6a81e8ae95">&#9670;&#160;</a></span>_concatenate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._concatenate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  getattr(_from_nx.concatenate,</div>
<div class="line"><span class="lineno">    2</span>                       <span class="stringliteral">&#39;__wrapped__&#39;</span>, _from_nx.concatenate)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a46668d1e091199fd7659771cfc24dce4" name="a46668d1e091199fd7659771cfc24dce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46668d1e091199fd7659771cfc24dce4">&#9670;&#160;</a></span>_ndim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._ndim = getattr(_from_nx.ndim, '__wrapped__', _from_nx.ndim)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a69f9d599b839b2b180a5544040033d" name="a0a69f9d599b839b2b180a5544040033d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a69f9d599b839b2b180a5544040033d">&#9670;&#160;</a></span>_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base._size = getattr(_from_nx.size, '__wrapped__', _from_nx.size)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45fc2ea67d94098cb4d63aca7a7ef92c" name="a45fc2ea67d94098cb4d63aca7a7ef92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fc2ea67d94098cb4d63aca7a7ef92c">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.shape_base.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
