<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.optimize._lsq.lsq_linear Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize.html">optimize</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1__lsq.html">_lsq</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1__lsq_1_1lsq__linear.html">lsq_linear</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.optimize._lsq.lsq_linear Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a97d7ff73a5e47fec72eaf2f94e49d7ce" id="r_a97d7ff73a5e47fec72eaf2f94e49d7ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__lsq_1_1lsq__linear.html#a97d7ff73a5e47fec72eaf2f94e49d7ce">prepare_bounds</a> (bounds, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:a97d7ff73a5e47fec72eaf2f94e49d7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f1814cf42d0857225bfa4f19f3294" id="r_a149f1814cf42d0857225bfa4f19f3294"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__lsq_1_1lsq__linear.html#a149f1814cf42d0857225bfa4f19f3294">lsq_linear</a> (A, b, bounds=(-np.inf, np.inf), method='trf', <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-10, lsq_solver=None, lsmr_tol=None, max_iter=None, verbose=0, *lsmr_maxiter=None)</td></tr>
<tr class="separator:a149f1814cf42d0857225bfa4f19f3294"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac0a22c838f2fac60cfd14b54ca6a9ed4" id="r_ac0a22c838f2fac60cfd14b54ca6a9ed4"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__lsq_1_1lsq__linear.html#ac0a22c838f2fac60cfd14b54ca6a9ed4">TERMINATION_MESSAGES</a></td></tr>
<tr class="separator:ac0a22c838f2fac60cfd14b54ca6a9ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Linear least squares with bound constraints on independent variables.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a149f1814cf42d0857225bfa4f19f3294" name="a149f1814cf42d0857225bfa4f19f3294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149f1814cf42d0857225bfa4f19f3294">&#9670;&#160;</a></span>lsq_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._lsq.lsq_linear.lsq_linear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>(-np.inf,&#160;np.inf)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'trf'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lsq_solver</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lsmr_tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>lsmr_maxiter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a linear least-squares problem with bounds on the variables.

    Given a m-by-n design matrix A and a target vector b with m elements,
    `lsq_linear` solves the following optimization problem::

        minimize 0.5 * ||A x - b||**2
        subject to lb &lt;= x &lt;= ub

    This optimization problem is convex, hence a found minimum (if iterations
    have converged) is guaranteed to be global.

    Parameters
    ----------
    A : array_like, sparse matrix of LinearOperator, shape (m, n)
        Design matrix. Can be `scipy.sparse.linalg.LinearOperator`.
    b : array_like, shape (m,)
        Target vector.
    bounds : 2-tuple of array_like, optional
        Lower and upper bounds on independent variables. Defaults to no bounds.
        Each array must have shape (n,) or be a scalar, in the latter
        case a bound will be the same for all variables. Use ``np.inf`` with
        an appropriate sign to disable bounds on all or some variables.
    method : 'trf' or 'bvls', optional
        Method to perform minimization.

            * 'trf' : Trust Region Reflective algorithm adapted for a linear
              least-squares problem. This is an interior-point-like method
              and the required number of iterations is weakly correlated with
              the number of variables.
            * 'bvls' : Bounded-variable least-squares algorithm. This is
              an active set method, which requires the number of iterations
              comparable to the number of variables. Can't be used when `A` is
              sparse or LinearOperator.

        Default is 'trf'.
    tol : float, optional
        Tolerance parameter. The algorithm terminates if a relative change
        of the cost function is less than `tol` on the last iteration.
        Additionally, the first-order optimality measure is considered:

            * ``method='trf'`` terminates if the uniform norm of the gradient,
              scaled to account for the presence of the bounds, is less than
              `tol`.
            * ``method='bvls'`` terminates if Karush-Kuhn-Tucker conditions
              are satisfied within `tol` tolerance.

    lsq_solver : {None, 'exact', 'lsmr'}, optional
        Method of solving unbounded least-squares problems throughout
        iterations:

            * 'exact' : Use dense QR or SVD decomposition approach. Can't be
              used when `A` is sparse or LinearOperator.
            * 'lsmr' : Use `scipy.sparse.linalg.lsmr` iterative procedure
              which requires only matrix-vector product evaluations. Can't
              be used with ``method='bvls'``.

        If None (default), the solver is chosen based on type of `A`.
    lsmr_tol : None, float or 'auto', optional
        Tolerance parameters 'atol' and 'btol' for `scipy.sparse.linalg.lsmr`
        If None (default), it is set to ``1e-2 * tol``. If 'auto', the
        tolerance will be adjusted based on the optimality of the current
        iterate, which can speed up the optimization process, but is not always
        reliable.
    max_iter : None or int, optional
        Maximum number of iterations before termination. If None (default), it
        is set to 100 for ``method='trf'`` or to the number of variables for
        ``method='bvls'`` (not counting iterations for 'bvls' initialization).
    verbose : {0, 1, 2}, optional
        Level of algorithm's verbosity:

            * 0 : work silently (default).
            * 1 : display a termination report.
            * 2 : display progress during iterations.
    lsmr_maxiter : None or int, optional
        Maximum number of iterations for the lsmr least squares solver,
        if it is used (by setting ``lsq_solver='lsmr'``). If None (default), it
        uses lsmr's default of ``min(m, n)`` where ``m`` and ``n`` are the
        number of rows and columns of `A`, respectively. Has no effect if
        ``lsq_solver='exact'``.

    Returns
    -------
    OptimizeResult with the following fields defined:
    x : ndarray, shape (n,)
        Solution found.
    cost : float
        Value of the cost function at the solution.
    fun : ndarray, shape (m,)
        Vector of residuals at the solution.
    optimality : float
        First-order optimality measure. The exact meaning depends on `method`,
        refer to the description of `tol` parameter.
    active_mask : ndarray of int, shape (n,)
        Each component shows whether a corresponding constraint is active
        (that is, whether a variable is at the bound):

            *  0 : a constraint is not active.
            * -1 : a lower bound is active.
            *  1 : an upper bound is active.

        Might be somewhat arbitrary for the `trf` method as it generates a
        sequence of strictly feasible iterates and active_mask is determined
        within a tolerance threshold.
    unbounded_sol : tuple
        Unbounded least squares solution tuple returned by the least squares
        solver (set with `lsq_solver` option). If `lsq_solver` is not set or is
        set to ``'exact'``, the tuple contains an ndarray of shape (n,) with
        the unbounded solution, an ndarray with the sum of squared residuals,
        an int with the rank of `A`, and an ndarray with the singular values
        of `A` (see NumPy's ``linalg.lstsq`` for more information). If
        `lsq_solver` is set to ``'lsmr'``, the tuple contains an ndarray of
        shape (n,) with the unbounded solution, an int with the exit code,
        an int with the number of iterations, and five floats with
        various norms and the condition number of `A` (see SciPy's
        ``sparse.linalg.lsmr`` for more information). This output can be
        useful for determining the convergence of the least squares solver,
        particularly the iterative ``'lsmr'`` solver. The unbounded least
        squares problem is to minimize ``0.5 * ||A x - b||**2``.
    nit : int
        Number of iterations. Zero if the unconstrained solution is optimal.
    status : int
        Reason for algorithm termination:

            * -1 : the algorithm was not able to make progress on the last
              iteration.
            *  0 : the maximum number of iterations is exceeded.
            *  1 : the first-order optimality measure is less than `tol`.
            *  2 : the relative change of the cost function is less than `tol`.
            *  3 : the unconstrained solution is optimal.

    message : str
        Verbal description of the termination reason.
    success : bool
        True if one of the convergence criteria is satisfied (`status` &gt; 0).

    See Also
    --------
    nnls : Linear least squares with non-negativity constraint.
    least_squares : Nonlinear least squares with bounds on the variables.

    Notes
    -----
    The algorithm first computes the unconstrained least-squares solution by
    `numpy.linalg.lstsq` or `scipy.sparse.linalg.lsmr` depending on
    `lsq_solver`. This solution is returned as optimal if it lies within the
    bounds.

    Method 'trf' runs the adaptation of the algorithm described in [STIR]_ for
    a linear least-squares problem. The iterations are essentially the same as
    in the nonlinear least-squares algorithm, but as the quadratic function
    model is always accurate, we don't need to track or modify the radius of
    a trust region. The line search (backtracking) is used as a safety net
    when a selected step does not decrease the cost function. Read more
    detailed description of the algorithm in `scipy.optimize.least_squares`.

    Method 'bvls' runs a Python implementation of the algorithm described in
    [BVLS]_. The algorithm maintains active and free sets of variables, on
    each iteration chooses a new variable to move from the active set to the
    free set and then solves the unconstrained least-squares problem on free
    variables. This algorithm is guaranteed to give an accurate solution
    eventually, but may require up to n iterations for a problem with n
    variables. Additionally, an ad-hoc initialization procedure is
    implemented, that determines which variables to set free or active
    initially. It takes some number of iterations before actual BVLS starts,
    but can significantly reduce the number of further iterations.

    References
    ----------
    .. [STIR] M. A. Branch, T. F. Coleman, and Y. Li, "A Subspace, Interior,
              and Conjugate Gradient Method for Large-Scale Bound-Constrained
              Minimization Problems," SIAM Journal on Scientific Computing,
              Vol. 21, Number 1, pp 1-23, 1999.
    .. [BVLS] P. B. Start and R. L. Parker, "Bounded-Variable Least-Squares:
              an Algorithm and Applications", Computational Statistics, 10,
              129-141, 1995.

    Examples
    --------
    In this example, a problem with a large sparse matrix and bounds on the
    variables is solved.

    &gt;&gt;&gt; from scipy.sparse import rand
    &gt;&gt;&gt; from scipy.optimize import lsq_linear
    &gt;&gt;&gt; rng = np.random.default_rng()
    ...
    &gt;&gt;&gt; m = 20000
    &gt;&gt;&gt; n = 10000
    ...
    &gt;&gt;&gt; A = rand(m, n, density=1e-4, random_state=rng)
    &gt;&gt;&gt; b = rng.standard_normal(m)
    ...
    &gt;&gt;&gt; lb = rng.standard_normal(n)
    &gt;&gt;&gt; ub = lb + 1
    ...
    &gt;&gt;&gt; res = lsq_linear(A, b, bounds=(lb, ub), lsmr_tol='auto', verbose=1)
    # may vary
    The relative change of the cost function is less than `tol`.
    Number of iterations 16, initial cost 1.5039e+04, final cost 1.1112e+04,
    first-order optimality 4.66e-08.</pre> <div class="fragment"><div class="line"><span class="lineno">   36</span>               verbose=0, *, lsmr_maxiter=<span class="keywordtype">None</span>,):</div>
<div class="line"><span class="lineno">   37</span>    <span class="stringliteral">r&quot;&quot;&quot;Solve a linear least-squares problem with bounds on the variables.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    Given a m-by-n design matrix A and a target vector b with m elements,</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    `lsq_linear` solves the following optimization problem::</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        minimize 0.5 * ||A x - b||**2</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        subject to lb &lt;= x &lt;= ub</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    This optimization problem is convex, hence a found minimum (if iterations</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    have converged) is guaranteed to be global.</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    A : array_like, sparse matrix of LinearOperator, shape (m, n)</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        Design matrix. Can be `scipy.sparse.linalg.LinearOperator`.</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    b : array_like, shape (m,)</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        Target vector.</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    bounds : 2-tuple of array_like, optional</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">        Lower and upper bounds on independent variables. Defaults to no bounds.</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">        Each array must have shape (n,) or be a scalar, in the latter</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">        case a bound will be the same for all variables. Use ``np.inf`` with</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        an appropriate sign to disable bounds on all or some variables.</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    method : &#39;trf&#39; or &#39;bvls&#39;, optional</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        Method to perform minimization.</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">            * &#39;trf&#39; : Trust Region Reflective algorithm adapted for a linear</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">              least-squares problem. This is an interior-point-like method</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">              and the required number of iterations is weakly correlated with</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">              the number of variables.</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">            * &#39;bvls&#39; : Bounded-variable least-squares algorithm. This is</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">              an active set method, which requires the number of iterations</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">              comparable to the number of variables. Can&#39;t be used when `A` is</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">              sparse or LinearOperator.</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">        Default is &#39;trf&#39;.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">        Tolerance parameter. The algorithm terminates if a relative change</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">        of the cost function is less than `tol` on the last iteration.</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        Additionally, the first-order optimality measure is considered:</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">            * ``method=&#39;trf&#39;`` terminates if the uniform norm of the gradient,</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">              scaled to account for the presence of the bounds, is less than</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">              `tol`.</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">            * ``method=&#39;bvls&#39;`` terminates if Karush-Kuhn-Tucker conditions</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">              are satisfied within `tol` tolerance.</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    lsq_solver : {None, &#39;exact&#39;, &#39;lsmr&#39;}, optional</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        Method of solving unbounded least-squares problems throughout</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        iterations:</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">            * &#39;exact&#39; : Use dense QR or SVD decomposition approach. Can&#39;t be</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">              used when `A` is sparse or LinearOperator.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">            * &#39;lsmr&#39; : Use `scipy.sparse.linalg.lsmr` iterative procedure</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">              which requires only matrix-vector product evaluations. Can&#39;t</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">              be used with ``method=&#39;bvls&#39;``.</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        If None (default), the solver is chosen based on type of `A`.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    lsmr_tol : None, float or &#39;auto&#39;, optional</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        Tolerance parameters &#39;atol&#39; and &#39;btol&#39; for `scipy.sparse.linalg.lsmr`</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        If None (default), it is set to ``1e-2 * tol``. If &#39;auto&#39;, the</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        tolerance will be adjusted based on the optimality of the current</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        iterate, which can speed up the optimization process, but is not always</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">        reliable.</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    max_iter : None or int, optional</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        Maximum number of iterations before termination. If None (default), it</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        is set to 100 for ``method=&#39;trf&#39;`` or to the number of variables for</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        ``method=&#39;bvls&#39;`` (not counting iterations for &#39;bvls&#39; initialization).</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    verbose : {0, 1, 2}, optional</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        Level of algorithm&#39;s verbosity:</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">            * 0 : work silently (default).</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">            * 1 : display a termination report.</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">            * 2 : display progress during iterations.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    lsmr_maxiter : None or int, optional</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        Maximum number of iterations for the lsmr least squares solver,</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        if it is used (by setting ``lsq_solver=&#39;lsmr&#39;``). If None (default), it</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        uses lsmr&#39;s default of ``min(m, n)`` where ``m`` and ``n`` are the</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        number of rows and columns of `A`, respectively. Has no effect if</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        ``lsq_solver=&#39;exact&#39;``.</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    OptimizeResult with the following fields defined:</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    x : ndarray, shape (n,)</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        Solution found.</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    cost : float</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">        Value of the cost function at the solution.</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    fun : ndarray, shape (m,)</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        Vector of residuals at the solution.</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    optimality : float</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        First-order optimality measure. The exact meaning depends on `method`,</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        refer to the description of `tol` parameter.</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    active_mask : ndarray of int, shape (n,)</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">        Each component shows whether a corresponding constraint is active</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        (that is, whether a variable is at the bound):</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">            *  0 : a constraint is not active.</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">            * -1 : a lower bound is active.</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">            *  1 : an upper bound is active.</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">        Might be somewhat arbitrary for the `trf` method as it generates a</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        sequence of strictly feasible iterates and active_mask is determined</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        within a tolerance threshold.</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    unbounded_sol : tuple</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        Unbounded least squares solution tuple returned by the least squares</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">        solver (set with `lsq_solver` option). If `lsq_solver` is not set or is</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        set to ``&#39;exact&#39;``, the tuple contains an ndarray of shape (n,) with</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        the unbounded solution, an ndarray with the sum of squared residuals,</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">        an int with the rank of `A`, and an ndarray with the singular values</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">        of `A` (see NumPy&#39;s ``linalg.lstsq`` for more information). If</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">        `lsq_solver` is set to ``&#39;lsmr&#39;``, the tuple contains an ndarray of</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">        shape (n,) with the unbounded solution, an int with the exit code,</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        an int with the number of iterations, and five floats with</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">        various norms and the condition number of `A` (see SciPy&#39;s</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        ``sparse.linalg.lsmr`` for more information). This output can be</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        useful for determining the convergence of the least squares solver,</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        particularly the iterative ``&#39;lsmr&#39;`` solver. The unbounded least</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        squares problem is to minimize ``0.5 * ||A x - b||**2``.</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    nit : int</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">        Number of iterations. Zero if the unconstrained solution is optimal.</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    status : int</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        Reason for algorithm termination:</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">            * -1 : the algorithm was not able to make progress on the last</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">              iteration.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">            *  0 : the maximum number of iterations is exceeded.</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">            *  1 : the first-order optimality measure is less than `tol`.</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">            *  2 : the relative change of the cost function is less than `tol`.</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">            *  3 : the unconstrained solution is optimal.</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    message : str</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        Verbal description of the termination reason.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    success : bool</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        True if one of the convergence criteria is satisfied (`status` &gt; 0).</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    nnls : Linear least squares with non-negativity constraint.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    least_squares : Nonlinear least squares with bounds on the variables.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    The algorithm first computes the unconstrained least-squares solution by</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    `numpy.linalg.lstsq` or `scipy.sparse.linalg.lsmr` depending on</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    `lsq_solver`. This solution is returned as optimal if it lies within the</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    bounds.</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    Method &#39;trf&#39; runs the adaptation of the algorithm described in [STIR]_ for</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    a linear least-squares problem. The iterations are essentially the same as</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    in the nonlinear least-squares algorithm, but as the quadratic function</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    model is always accurate, we don&#39;t need to track or modify the radius of</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    a trust region. The line search (backtracking) is used as a safety net</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    when a selected step does not decrease the cost function. Read more</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    detailed description of the algorithm in `scipy.optimize.least_squares`.</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    Method &#39;bvls&#39; runs a Python implementation of the algorithm described in</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    [BVLS]_. The algorithm maintains active and free sets of variables, on</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    each iteration chooses a new variable to move from the active set to the</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    free set and then solves the unconstrained least-squares problem on free</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    variables. This algorithm is guaranteed to give an accurate solution</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    eventually, but may require up to n iterations for a problem with n</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    variables. Additionally, an ad-hoc initialization procedure is</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    implemented, that determines which variables to set free or active</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    initially. It takes some number of iterations before actual BVLS starts,</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    but can significantly reduce the number of further iterations.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    .. [STIR] M. A. Branch, T. F. Coleman, and Y. Li, &quot;A Subspace, Interior,</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">              and Conjugate Gradient Method for Large-Scale Bound-Constrained</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">              Minimization Problems,&quot; SIAM Journal on Scientific Computing,</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">              Vol. 21, Number 1, pp 1-23, 1999.</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    .. [BVLS] P. B. Start and R. L. Parker, &quot;Bounded-Variable Least-Squares:</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">              an Algorithm and Applications&quot;, Computational Statistics, 10,</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">              129-141, 1995.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    In this example, a problem with a large sparse matrix and bounds on the</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    variables is solved.</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import rand</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.optimize import lsq_linear</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &gt;&gt;&gt; m = 20000</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    &gt;&gt;&gt; n = 10000</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    &gt;&gt;&gt; A = rand(m, n, density=1e-4, random_state=rng)</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    &gt;&gt;&gt; b = rng.standard_normal(m)</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    &gt;&gt;&gt; lb = rng.standard_normal(n)</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; ub = lb + 1</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    &gt;&gt;&gt; res = lsq_linear(A, b, bounds=(lb, ub), lsmr_tol=&#39;auto&#39;, verbose=1)</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    # may vary</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    The relative change of the cost function is less than `tol`.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Number of iterations 16, initial cost 1.5039e+04, final cost 1.1112e+04,</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    first-order optimality 4.66e-08.</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  237</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;trf&#39;</span>, <span class="stringliteral">&#39;bvls&#39;</span>]:</div>
<div class="line"><span class="lineno">  238</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`method` must be &#39;trf&#39; or &#39;bvls&#39;&quot;</span>)</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>    <span class="keywordflow">if</span> lsq_solver <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="keywordtype">None</span>, <span class="stringliteral">&#39;exact&#39;</span>, <span class="stringliteral">&#39;lsmr&#39;</span>]:</div>
<div class="line"><span class="lineno">  241</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`solver` must be None, &#39;exact&#39; or &#39;lsmr&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordflow">if</span> verbose <span class="keywordflow">not</span> <span class="keywordflow">in</span> [0, 1, 2]:</div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`verbose` must be in [0, 1, 2].&quot;</span>)</div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span>    <span class="keywordflow">if</span> issparse(A):</div>
<div class="line"><span class="lineno">  247</span>        A = csr_matrix(A)</div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(A, LinearOperator):</div>
<div class="line"><span class="lineno">  249</span>        A = np.atleast_2d(np.asarray(A))</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;bvls&#39;</span>:</div>
<div class="line"><span class="lineno">  252</span>        <span class="keywordflow">if</span> lsq_solver == <span class="stringliteral">&#39;lsmr&#39;</span>:</div>
<div class="line"><span class="lineno">  253</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;method=&#39;bvls&#39; can&#39;t be used with &quot;</span></div>
<div class="line"><span class="lineno">  254</span>                             <span class="stringliteral">&quot;lsq_solver=&#39;lsmr&#39;&quot;</span>)</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(A, np.ndarray):</div>
<div class="line"><span class="lineno">  257</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;method=&#39;bvls&#39; can&#39;t be used with `A` being &quot;</span></div>
<div class="line"><span class="lineno">  258</span>                             <span class="stringliteral">&quot;sparse or LinearOperator.&quot;</span>)</div>
<div class="line"><span class="lineno">  259</span> </div>
<div class="line"><span class="lineno">  260</span>    <span class="keywordflow">if</span> lsq_solver <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  261</span>        <span class="keywordflow">if</span> isinstance(A, np.ndarray):</div>
<div class="line"><span class="lineno">  262</span>            lsq_solver = <span class="stringliteral">&#39;exact&#39;</span></div>
<div class="line"><span class="lineno">  263</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  264</span>            lsq_solver = <span class="stringliteral">&#39;lsmr&#39;</span></div>
<div class="line"><span class="lineno">  265</span>    <span class="keywordflow">elif</span> lsq_solver == <span class="stringliteral">&#39;exact&#39;</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(A, np.ndarray):</div>
<div class="line"><span class="lineno">  266</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`exact` solver can&#39;t be used when `A` is &quot;</span></div>
<div class="line"><span class="lineno">  267</span>                         <span class="stringliteral">&quot;sparse or LinearOperator.&quot;</span>)</div>
<div class="line"><span class="lineno">  268</span> </div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordflow">if</span> len(A.shape) != 2:  <span class="comment"># No ndim for LinearOperator.</span></div>
<div class="line"><span class="lineno">  270</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`A` must have at most 2 dimensions.&quot;</span>)</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span>    <span class="keywordflow">if</span> len(bounds) != 2:</div>
<div class="line"><span class="lineno">  273</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`bounds` must contain 2 elements.&quot;</span>)</div>
<div class="line"><span class="lineno">  274</span> </div>
<div class="line"><span class="lineno">  275</span>    <span class="keywordflow">if</span> max_iter <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> max_iter &lt;= 0:</div>
<div class="line"><span class="lineno">  276</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`max_iter` must be None or positive integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>    m, n = A.shape</div>
<div class="line"><span class="lineno">  279</span> </div>
<div class="line"><span class="lineno">  280</span>    b = np.atleast_1d(b)</div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">if</span> b.ndim != 1:</div>
<div class="line"><span class="lineno">  282</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`b` must have at most 1 dimension.&quot;</span>)</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">if</span> b.size != m:</div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Inconsistent shapes between `A` and `b`.&quot;</span>)</div>
<div class="line"><span class="lineno">  286</span> </div>
<div class="line"><span class="lineno">  287</span>    lb, ub = prepare_bounds(bounds, n)</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span>    <span class="keywordflow">if</span> lb.shape != (n,) <span class="keywordflow">and</span> ub.shape != (n,):</div>
<div class="line"><span class="lineno">  290</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Bounds have wrong shape.&quot;</span>)</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>    <span class="keywordflow">if</span> np.any(lb &gt;= ub):</div>
<div class="line"><span class="lineno">  293</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Each lower bound must be strictly less than each &quot;</span></div>
<div class="line"><span class="lineno">  294</span>                         <span class="stringliteral">&quot;upper bound.&quot;</span>)</div>
<div class="line"><span class="lineno">  295</span> </div>
<div class="line"><span class="lineno">  296</span>    <span class="keywordflow">if</span> lsmr_maxiter <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> lsmr_maxiter &lt; 1:</div>
<div class="line"><span class="lineno">  297</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`lsmr_maxiter` must be None or positive integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  298</span> </div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> ((isinstance(lsmr_tol, float) <span class="keywordflow">and</span> lsmr_tol &gt; 0) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  300</span>            lsmr_tol <span class="keywordflow">in</span> (<span class="stringliteral">&#39;auto&#39;</span>, <span class="keywordtype">None</span>)):</div>
<div class="line"><span class="lineno">  301</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`lsmr_tol` must be None, &#39;auto&#39;, or positive float.&quot;</span>)</div>
<div class="line"><span class="lineno">  302</span> </div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">if</span> lsq_solver == <span class="stringliteral">&#39;exact&#39;</span>:</div>
<div class="line"><span class="lineno">  304</span>        unbd_lsq = np.linalg.lstsq(A, b, rcond=-1)</div>
<div class="line"><span class="lineno">  305</span>    <span class="keywordflow">elif</span> lsq_solver == <span class="stringliteral">&#39;lsmr&#39;</span>:</div>
<div class="line"><span class="lineno">  306</span>        first_lsmr_tol = lsmr_tol  <span class="comment"># tol of first call to lsmr</span></div>
<div class="line"><span class="lineno">  307</span>        <span class="keywordflow">if</span> lsmr_tol <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> lsmr_tol == <span class="stringliteral">&#39;auto&#39;</span>:</div>
<div class="line"><span class="lineno">  308</span>            first_lsmr_tol = 1e-2 * tol  <span class="comment"># default if lsmr_tol not defined</span></div>
<div class="line"><span class="lineno">  309</span>        unbd_lsq = lsmr(A, b, maxiter=lsmr_maxiter,</div>
<div class="line"><span class="lineno">  310</span>                        atol=first_lsmr_tol, btol=first_lsmr_tol)</div>
<div class="line"><span class="lineno">  311</span>    x_lsq = unbd_lsq[0]  <span class="comment"># extract the solution from the least squares solver</span></div>
<div class="line"><span class="lineno">  312</span> </div>
<div class="line"><span class="lineno">  313</span>    <span class="keywordflow">if</span> in_bounds(x_lsq, lb, ub):</div>
<div class="line"><span class="lineno">  314</span>        r = A @ x_lsq - b</div>
<div class="line"><span class="lineno">  315</span>        cost = 0.5 * np.dot(r, r)</div>
<div class="line"><span class="lineno">  316</span>        termination_status = 3</div>
<div class="line"><span class="lineno">  317</span>        termination_message = TERMINATION_MESSAGES[termination_status]</div>
<div class="line"><span class="lineno">  318</span>        g = compute_grad(A, r)</div>
<div class="line"><span class="lineno">  319</span>        g_norm = norm(g, ord=np.inf)</div>
<div class="line"><span class="lineno">  320</span> </div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">if</span> verbose &gt; 0:</div>
<div class="line"><span class="lineno">  322</span>            print(termination_message)</div>
<div class="line"><span class="lineno">  323</span>            print(<span class="stringliteral">&quot;Final cost {0:.4e}, first-order optimality {1:.2e}&quot;</span></div>
<div class="line"><span class="lineno">  324</span>                  .format(cost, g_norm))</div>
<div class="line"><span class="lineno">  325</span> </div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordflow">return</span> OptimizeResult(</div>
<div class="line"><span class="lineno">  327</span>            x=x_lsq, fun=r, cost=cost, optimality=g_norm,</div>
<div class="line"><span class="lineno">  328</span>            active_mask=np.zeros(n), unbounded_sol=unbd_lsq,</div>
<div class="line"><span class="lineno">  329</span>            nit=0, status=termination_status,</div>
<div class="line"><span class="lineno">  330</span>            message=termination_message, success=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  331</span> </div>
<div class="line"><span class="lineno">  332</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;trf&#39;</span>:</div>
<div class="line"><span class="lineno">  333</span>        res = trf_linear(A, b, x_lsq, lb, ub, tol, lsq_solver, lsmr_tol,</div>
<div class="line"><span class="lineno">  334</span>                         max_iter, verbose, lsmr_maxiter=lsmr_maxiter)</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;bvls&#39;</span>:</div>
<div class="line"><span class="lineno">  336</span>        res = bvls(A, b, x_lsq, lb, ub, tol, max_iter, verbose)</div>
<div class="line"><span class="lineno">  337</span> </div>
<div class="line"><span class="lineno">  338</span>    res.unbounded_sol = unbd_lsq</div>
<div class="line"><span class="lineno">  339</span>    res.message = TERMINATION_MESSAGES[res.status]</div>
<div class="line"><span class="lineno">  340</span>    res.success = res.status &gt; 0</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>    <span class="keywordflow">if</span> verbose &gt; 0:</div>
<div class="line"><span class="lineno">  343</span>        print(res.message)</div>
<div class="line"><span class="lineno">  344</span>        print(<span class="stringliteral">&quot;Number of iterations {0}, initial cost {1:.4e}, &quot;</span></div>
<div class="line"><span class="lineno">  345</span>              <span class="stringliteral">&quot;final cost {2:.4e}, first-order optimality {3:.2e}.&quot;</span></div>
<div class="line"><span class="lineno">  346</span>              .format(res.nit, res.initial_cost, res.cost, res.optimality))</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>    del res.initial_cost</div>
<div class="line"><span class="lineno">  349</span> </div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">return</span> res</div>
</div><!-- fragment -->
</div>
</div>
<a id="a97d7ff73a5e47fec72eaf2f94e49d7ce" name="a97d7ff73a5e47fec72eaf2f94e49d7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d7ff73a5e47fec72eaf2f94e49d7ce">&#9670;&#160;</a></span>prepare_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._lsq.lsq_linear.prepare_bounds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   13</span><span class="keyword">def </span>prepare_bounds(bounds, n):</div>
<div class="line"><span class="lineno">   14</span>    lb, ub = [np.asarray(b, dtype=float) <span class="keywordflow">for</span> b <span class="keywordflow">in</span> bounds]</div>
<div class="line"><span class="lineno">   15</span> </div>
<div class="line"><span class="lineno">   16</span>    <span class="keywordflow">if</span> lb.ndim == 0:</div>
<div class="line"><span class="lineno">   17</span>        lb = np.resize(lb, n)</div>
<div class="line"><span class="lineno">   18</span> </div>
<div class="line"><span class="lineno">   19</span>    <span class="keywordflow">if</span> ub.ndim == 0:</div>
<div class="line"><span class="lineno">   20</span>        ub = np.resize(ub, n)</div>
<div class="line"><span class="lineno">   21</span> </div>
<div class="line"><span class="lineno">   22</span>    <span class="keywordflow">return</span> lb, ub</div>
<div class="line"><span class="lineno">   23</span> </div>
<div class="line"><span class="lineno">   24</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac0a22c838f2fac60cfd14b54ca6a9ed4" name="ac0a22c838f2fac60cfd14b54ca6a9ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a22c838f2fac60cfd14b54ca6a9ed4">&#9670;&#160;</a></span>TERMINATION_MESSAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.optimize._lsq.lsq_linear.TERMINATION_MESSAGES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    -1: <span class="stringliteral">&quot;The algorithm was not able to make progress on the last iteration.&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    0: <span class="stringliteral">&quot;The maximum number of iterations is exceeded.&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    1: <span class="stringliteral">&quot;The first-order optimality measure is less than `tol`.&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    2: <span class="stringliteral">&quot;The relative change of the cost function is less than `tol`.&quot;</span>,</div>
<div class="line"><span class="lineno">    6</span>    3: <span class="stringliteral">&quot;The unconstrained solution is optimal.&quot;</span></div>
<div class="line"><span class="lineno">    7</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
