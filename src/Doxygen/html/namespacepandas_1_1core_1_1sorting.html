<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.sorting Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1sorting.html">sorting</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.sorting Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae3424d37a346a18dfef5aab847c60965" id="r_ae3424d37a346a18dfef5aab847c60965"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#ae3424d37a346a18dfef5aab847c60965">get_indexer_indexer</a> (<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, Level|list[Level]|None level, Sequence[bool]|bool ascending, SortKind kind, NaPosition na_position, bool sort_remaining, IndexKeyFunc key)</td></tr>
<tr class="separator:ae3424d37a346a18dfef5aab847c60965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcaea4c69033b757e68fb6f8ed6105c" id="r_adbcaea4c69033b757e68fb6f8ed6105c"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.int64]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#adbcaea4c69033b757e68fb6f8ed6105c">get_group_index</a> (labels, Shape shape, bool sort, bool xnull)</td></tr>
<tr class="separator:adbcaea4c69033b757e68fb6f8ed6105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958d45b3afb39502d01b014cccbb7401" id="r_a958d45b3afb39502d01b014cccbb7401"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.int64]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a958d45b3afb39502d01b014cccbb7401">get_compressed_ids</a> (labels, Shape sizes)</td></tr>
<tr class="separator:a958d45b3afb39502d01b014cccbb7401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae8cf75c93f330b36b0d473c588b747" id="r_a6ae8cf75c93f330b36b0d473c588b747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a6ae8cf75c93f330b36b0d473c588b747">is_int64_overflow_possible</a> (Shape shape)</td></tr>
<tr class="separator:a6ae8cf75c93f330b36b0d473c588b747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea88f88f2c88a1a2966dd2406e7f06ab" id="r_aea88f88f2c88a1a2966dd2406e7f06ab"><td class="memItemLeft" align="right" valign="top">list[npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#aea88f88f2c88a1a2966dd2406e7f06ab">_decons_group_index</a> (npt.NDArray[np.intp] comp_labels, Shape shape)</td></tr>
<tr class="separator:aea88f88f2c88a1a2966dd2406e7f06ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47f9cd7d5058c4fcd4f6f5830bb1b84" id="r_ae47f9cd7d5058c4fcd4f6f5830bb1b84"><td class="memItemLeft" align="right" valign="top">list[npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#ae47f9cd7d5058c4fcd4f6f5830bb1b84">decons_obs_group_ids</a> (npt.NDArray[np.intp] comp_ids, npt.NDArray[np.intp] obs_ids, Shape shape, Sequence[npt.NDArray[np.signedinteger]] labels, bool xnull)</td></tr>
<tr class="separator:ae47f9cd7d5058c4fcd4f6f5830bb1b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7f8188ef6a62e80a052e3445e2fd19" id="r_a0d7f8188ef6a62e80a052e3445e2fd19"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a0d7f8188ef6a62e80a052e3445e2fd19">indexer_from_factorized</a> (labels, Shape shape, bool compress=True)</td></tr>
<tr class="separator:a0d7f8188ef6a62e80a052e3445e2fd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6801743601e486a192101694a3a834ba" id="r_a6801743601e486a192101694a3a834ba"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a6801743601e486a192101694a3a834ba">lexsort_indexer</a> (keys, orders=None, str na_position=&quot;last&quot;, Callable|None key=None)</td></tr>
<tr class="separator:a6801743601e486a192101694a3a834ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d3437fe85222478566b66ea51babc6" id="r_a30d3437fe85222478566b66ea51babc6"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a30d3437fe85222478566b66ea51babc6">nargsort</a> (items, str kind=&quot;quicksort&quot;, bool ascending=True, str na_position=&quot;last&quot;, Callable|None key=None, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a30d3437fe85222478566b66ea51babc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af2dae46e98b69a841f7ef358b3b16d" id="r_a5af2dae46e98b69a841f7ef358b3b16d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a5af2dae46e98b69a841f7ef358b3b16d">nargminmax</a> (<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> values, str method, int axis=0)</td></tr>
<tr class="separator:a5af2dae46e98b69a841f7ef358b3b16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e3a92a42103c4b3e5ff927d4c908b6" id="r_a98e3a92a42103c4b3e5ff927d4c908b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a98e3a92a42103c4b3e5ff927d4c908b6">_nanargminmax</a> (np.ndarray values, npt.NDArray[np.bool_] mask, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>)</td></tr>
<tr class="separator:a98e3a92a42103c4b3e5ff927d4c908b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40672fba282049a52ada719678ec5baf" id="r_a40672fba282049a52ada719678ec5baf"><td class="memItemLeft" align="right" valign="top">MultiIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a40672fba282049a52ada719678ec5baf">_ensure_key_mapped_multiindex</a> (MultiIndex index, Callable key, level=None)</td></tr>
<tr class="separator:a40672fba282049a52ada719678ec5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc81a6539cacd22b20b292267cb34d7" id="r_afcc81a6539cacd22b20b292267cb34d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#afcc81a6539cacd22b20b292267cb34d7">ensure_key_mapped</a> (values, Callable|None key, levels=None)</td></tr>
<tr class="separator:afcc81a6539cacd22b20b292267cb34d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4b09b6dcedc57a6e7d13733b54e395" id="r_aeb4b09b6dcedc57a6e7d13733b54e395"><td class="memItemLeft" align="right" valign="top">list[tuple]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#aeb4b09b6dcedc57a6e7d13733b54e395">get_flattened_list</a> (npt.NDArray[np.intp] comp_ids, int ngroups, Iterable[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>] levels, Iterable[np.ndarray] labels)</td></tr>
<tr class="separator:aeb4b09b6dcedc57a6e7d13733b54e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f9b61304768d12c21ff05d08e6f739" id="r_ac2f9b61304768d12c21ff05d08e6f739"><td class="memItemLeft" align="right" valign="top">dict[Hashable, npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#ac2f9b61304768d12c21ff05d08e6f739">get_indexer_dict</a> (list[np.ndarray] label_list, list[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>] keys)</td></tr>
<tr class="separator:ac2f9b61304768d12c21ff05d08e6f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508c4e5b564f2354194bf7a44b6df8e7" id="r_a508c4e5b564f2354194bf7a44b6df8e7"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a508c4e5b564f2354194bf7a44b6df8e7">get_group_index_sorter</a> (npt.NDArray[np.intp] group_index, int|None ngroups=None)</td></tr>
<tr class="separator:a508c4e5b564f2354194bf7a44b6df8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4671f23853e5550b2dce6fcaaa13e00b" id="r_a4671f23853e5550b2dce6fcaaa13e00b"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a4671f23853e5550b2dce6fcaaa13e00b">compress_group_index</a> (npt.NDArray[np.int64] group_index, bool sort=True)</td></tr>
<tr class="separator:a4671f23853e5550b2dce6fcaaa13e00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed5723f0a2dffd444d6b22afe32692" id="r_a6fed5723f0a2dffd444d6b22afe32692"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.int64], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1sorting.html#a6fed5723f0a2dffd444d6b22afe32692">_reorder_by_uniques</a> (npt.NDArray[np.int64] uniques, npt.NDArray[np.intp] labels)</td></tr>
<tr class="separator:a6fed5723f0a2dffd444d6b22afe32692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment"> miscellaneous sorting / groupby utilities </pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aea88f88f2c88a1a2966dd2406e7f06ab" name="aea88f88f2c88a1a2966dd2406e7f06ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea88f88f2c88a1a2966dd2406e7f06ab">&#9670;&#160;</a></span>_decons_group_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[npt.NDArray[np.intp]] pandas.core.sorting._decons_group_index </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>comp_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape
&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  237</span>) -&gt; list[npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno">  238</span>    <span class="comment"># reconstruct labels</span></div>
<div class="line"><span class="lineno">  239</span>    <span class="keywordflow">if</span> is_int64_overflow_possible(shape):</div>
<div class="line"><span class="lineno">  240</span>        <span class="comment"># at some point group indices are factorized,</span></div>
<div class="line"><span class="lineno">  241</span>        <span class="comment"># and may not be deconstructed here! wrong path!</span></div>
<div class="line"><span class="lineno">  242</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot deconstruct factorized group indices!&quot;</span>)</div>
<div class="line"><span class="lineno">  243</span> </div>
<div class="line"><span class="lineno">  244</span>    label_list = []</div>
<div class="line"><span class="lineno">  245</span>    factor = 1</div>
<div class="line"><span class="lineno">  246</span>    y = np.array(0)</div>
<div class="line"><span class="lineno">  247</span>    x = comp_labels</div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> reversed(range(len(shape))):</div>
<div class="line"><span class="lineno">  249</span>        labels = (x - y) % (factor * shape[i]) // factor</div>
<div class="line"><span class="lineno">  250</span>        np.putmask(labels, comp_labels &lt; 0, -1)</div>
<div class="line"><span class="lineno">  251</span>        label_list.append(labels)</div>
<div class="line"><span class="lineno">  252</span>        y = labels * factor</div>
<div class="line"><span class="lineno">  253</span>        factor *= shape[i]</div>
<div class="line"><span class="lineno">  254</span>    <span class="keywordflow">return</span> label_list[::-1]</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40672fba282049a52ada719678ec5baf" name="a40672fba282049a52ada719678ec5baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40672fba282049a52ada719678ec5baf">&#9670;&#160;</a></span>_ensure_key_mapped_multiindex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> MultiIndex pandas.core.sorting._ensure_key_mapped_multiindex </td>
          <td>(</td>
          <td class="paramtype">MultiIndex&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns a new MultiIndex in which key has been applied
to all levels specified in level (or all levels if level
is None). Used for key sorting for MultiIndex.

Parameters
----------
index : MultiIndex
    Index to which to apply the key function on the
    specified levels.
key : Callable
    Function that takes an Index and returns an Index of
    the same shape. This key is applied to each level
    separately. The name of the level can be used to
    distinguish different levels for application.
level : list-like, int or str, default None
    Level or list of levels to apply the key function to.
    If None, key function is applied to all levels. Other
    levels are left unchanged.

Returns
-------
labels : MultiIndex
    Resulting MultiIndex with modified levels.
</pre> <div class="fragment"><div class="line"><span class="lineno">  498</span>) -&gt; MultiIndex:</div>
<div class="line"><span class="lineno">  499</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    Returns a new MultiIndex in which key has been applied</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    to all levels specified in level (or all levels if level</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    is None). Used for key sorting for MultiIndex.</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    index : MultiIndex</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        Index to which to apply the key function on the</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">        specified levels.</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    key : Callable</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        Function that takes an Index and returns an Index of</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        the same shape. This key is applied to each level</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        separately. The name of the level can be used to</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        distinguish different levels for application.</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    level : list-like, int or str, default None</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        Level or list of levels to apply the key function to.</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        If None, key function is applied to all levels. Other</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        levels are left unchanged.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    labels : MultiIndex</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        Resulting MultiIndex with modified levels.</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span>    <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  526</span>        <span class="keywordflow">if</span> isinstance(level, (str, int)):</div>
<div class="line"><span class="lineno">  527</span>            sort_levels = [level]</div>
<div class="line"><span class="lineno">  528</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  529</span>            sort_levels = level</div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span>        sort_levels = [index._get_level_number(lev) <span class="keywordflow">for</span> lev <span class="keywordflow">in</span> sort_levels]</div>
<div class="line"><span class="lineno">  532</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  533</span>        sort_levels = list(range(index.nlevels))  <span class="comment"># satisfies mypy</span></div>
<div class="line"><span class="lineno">  534</span> </div>
<div class="line"><span class="lineno">  535</span>    mapped = [</div>
<div class="line"><span class="lineno">  536</span>        ensure_key_mapped(index._get_level_values(level), key)</div>
<div class="line"><span class="lineno">  537</span>        <span class="keywordflow">if</span> level <span class="keywordflow">in</span> sort_levels</div>
<div class="line"><span class="lineno">  538</span>        <span class="keywordflow">else</span> index._get_level_values(level)</div>
<div class="line"><span class="lineno">  539</span>        <span class="keywordflow">for</span> level <span class="keywordflow">in</span> range(index.nlevels)</div>
<div class="line"><span class="lineno">  540</span>    ]</div>
<div class="line"><span class="lineno">  541</span> </div>
<div class="line"><span class="lineno">  542</span>    <span class="keywordflow">return</span> type(index).from_arrays(mapped)</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  544</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a98e3a92a42103c4b3e5ff927d4c908b6" name="a98e3a92a42103c4b3e5ff927d4c908b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e3a92a42103c4b3e5ff927d4c908b6">&#9670;&#160;</a></span>_nanargminmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.sorting._nanargminmax </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_]&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">See nanargminmax.__doc__.
</pre> <div class="fragment"><div class="line"><span class="lineno">  485</span><span class="keyword">def </span>_nanargminmax(values: np.ndarray, mask: npt.NDArray[np.bool_], func) -&gt; int:</div>
<div class="line"><span class="lineno">  486</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    See nanargminmax.__doc__.</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  489</span>    idx = np.arange(values.shape[0])</div>
<div class="line"><span class="lineno">  490</span>    non_nans = values[~mask]</div>
<div class="line"><span class="lineno">  491</span>    non_nan_idx = idx[~mask]</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>    <span class="keywordflow">return</span> non_nan_idx[<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(non_nans)]</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6fed5723f0a2dffd444d6b22afe32692" name="a6fed5723f0a2dffd444d6b22afe32692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed5723f0a2dffd444d6b22afe32692">&#9670;&#160;</a></span>_reorder_by_uniques()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.int64], npt.NDArray[np.intp]] pandas.core.sorting._reorder_by_uniques </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.int64]&#160;</td>
          <td class="paramname"><em>uniques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]
&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
uniques : np.ndarray[np.int64]
labels : np.ndarray[np.intp]

Returns
-------
np.ndarray[np.int64]
np.ndarray[np.intp]
</pre> <div class="fragment"><div class="line"><span class="lineno">  706</span>) -&gt; tuple[npt.NDArray[np.int64], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno">  707</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    uniques : np.ndarray[np.int64]</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    labels : np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    np.ndarray[np.int64]</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  718</span>    <span class="comment"># sorter is index where elements ought to go</span></div>
<div class="line"><span class="lineno">  719</span>    sorter = uniques.argsort()</div>
<div class="line"><span class="lineno">  720</span> </div>
<div class="line"><span class="lineno">  721</span>    <span class="comment"># reverse_indexer is where elements came from</span></div>
<div class="line"><span class="lineno">  722</span>    reverse_indexer = np.empty(len(sorter), dtype=np.intp)</div>
<div class="line"><span class="lineno">  723</span>    reverse_indexer.put(sorter, np.arange(len(sorter)))</div>
<div class="line"><span class="lineno">  724</span> </div>
<div class="line"><span class="lineno">  725</span>    mask = labels &lt; 0</div>
<div class="line"><span class="lineno">  726</span> </div>
<div class="line"><span class="lineno">  727</span>    <span class="comment"># move labels to right locations (ie, unsort ascending labels)</span></div>
<div class="line"><span class="lineno">  728</span>    labels = reverse_indexer.take(labels)</div>
<div class="line"><span class="lineno">  729</span>    np.putmask(labels, mask, -1)</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span>    <span class="comment"># sort observed ids</span></div>
<div class="line"><span class="lineno">  732</span>    uniques = uniques.take(sorter)</div>
<div class="line"><span class="lineno">  733</span> </div>
<div class="line"><span class="lineno">  734</span>    <span class="keywordflow">return</span> uniques, labels</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4671f23853e5550b2dce6fcaaa13e00b" name="a4671f23853e5550b2dce6fcaaa13e00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4671f23853e5550b2dce6fcaaa13e00b">&#9670;&#160;</a></span>compress_group_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]] pandas.core.sorting.compress_group_index </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.int64]&#160;</td>
          <td class="paramname"><em>group_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Group_index is offsets into cartesian product of all possible labels. This
space can be huge, so this function compresses it, by computing offsets
(comp_ids) into the list of unique labels (obs_group_ids).
</pre> <div class="fragment"><div class="line"><span class="lineno">  684</span>) -&gt; tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]:</div>
<div class="line"><span class="lineno">  685</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    Group_index is offsets into cartesian product of all possible labels. This</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    space can be huge, so this function compresses it, by computing offsets</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    (comp_ids) into the list of unique labels (obs_group_ids).</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  690</span>    size_hint = len(group_index)</div>
<div class="line"><span class="lineno">  691</span>    table = hashtable.Int64HashTable(size_hint)</div>
<div class="line"><span class="lineno">  692</span> </div>
<div class="line"><span class="lineno">  693</span>    group_index = ensure_int64(group_index)</div>
<div class="line"><span class="lineno">  694</span> </div>
<div class="line"><span class="lineno">  695</span>    <span class="comment"># note, group labels come out ascending (ie, 1,2,3 etc)</span></div>
<div class="line"><span class="lineno">  696</span>    comp_ids, obs_group_ids = table.get_labels_groupby(group_index)</div>
<div class="line"><span class="lineno">  697</span> </div>
<div class="line"><span class="lineno">  698</span>    <span class="keywordflow">if</span> sort <span class="keywordflow">and</span> len(obs_group_ids) &gt; 0:</div>
<div class="line"><span class="lineno">  699</span>        obs_group_ids, comp_ids = _reorder_by_uniques(obs_group_ids, comp_ids)</div>
<div class="line"><span class="lineno">  700</span> </div>
<div class="line"><span class="lineno">  701</span>    <span class="keywordflow">return</span> ensure_int64(comp_ids), ensure_int64(obs_group_ids)</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae47f9cd7d5058c4fcd4f6f5830bb1b84" name="ae47f9cd7d5058c4fcd4f6f5830bb1b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47f9cd7d5058c4fcd4f6f5830bb1b84">&#9670;&#160;</a></span>decons_obs_group_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[npt.NDArray[np.intp]] pandas.core.sorting.decons_obs_group_ids </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>comp_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>obs_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[npt.NDArray[np.signedinteger]]&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>xnull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct labels from observed group ids.

Parameters
----------
comp_ids : np.ndarray[np.intp]
obs_ids: np.ndarray[np.intp]
shape : tuple[int]
labels : Sequence[np.ndarray[np.signedinteger]]
xnull : bool
    If nulls are excluded; i.e. -1 labels are passed through.
</pre> <div class="fragment"><div class="line"><span class="lineno">  263</span>) -&gt; list[npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno">  264</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    Reconstruct labels from observed group ids.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    comp_ids : np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    obs_ids: np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    shape : tuple[int]</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    labels : Sequence[np.ndarray[np.signedinteger]]</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    xnull : bool</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        If nulls are excluded; i.e. -1 labels are passed through.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  276</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> xnull:</div>
<div class="line"><span class="lineno">  277</span>        lift = np.fromiter(((a == -1).any() <span class="keywordflow">for</span> a <span class="keywordflow">in</span> labels), dtype=np.intp)</div>
<div class="line"><span class="lineno">  278</span>        arr_shape = np.asarray(shape, dtype=np.intp) + lift</div>
<div class="line"><span class="lineno">  279</span>        shape = tuple(arr_shape)</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_int64_overflow_possible(shape):</div>
<div class="line"><span class="lineno">  282</span>        <span class="comment"># obs ids are deconstructable! take the fast route!</span></div>
<div class="line"><span class="lineno">  283</span>        out = _decons_group_index(obs_ids, shape)</div>
<div class="line"><span class="lineno">  284</span>        <span class="keywordflow">return</span> out <span class="keywordflow">if</span> xnull <span class="keywordflow">or</span> <span class="keywordflow">not</span> lift.any() <span class="keywordflow">else</span> [x - y <span class="keywordflow">for</span> x, y <span class="keywordflow">in</span> zip(out, lift)]</div>
<div class="line"><span class="lineno">  285</span> </div>
<div class="line"><span class="lineno">  286</span>    indexer = unique_label_indices(comp_ids)</div>
<div class="line"><span class="lineno">  287</span>    <span class="keywordflow">return</span> [lab[indexer].astype(np.intp, subok=<span class="keyword">False</span>, copy=<span class="keyword">True</span>) <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> labels]</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afcc81a6539cacd22b20b292267cb34d7" name="afcc81a6539cacd22b20b292267cb34d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc81a6539cacd22b20b292267cb34d7">&#9670;&#160;</a></span>ensure_key_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.sorting.ensure_key_mapped </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>levels</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Applies a callable key function to the values function and checks
that the resulting value has the same shape. Can be called on Index
subclasses, Series, DataFrames, or ndarrays.

Parameters
----------
values : Series, DataFrame, Index subclass, or ndarray
key : Optional[Callable], key to be called on the values array
levels : Optional[List], if values is a MultiIndex, list of levels to
apply the key to.
</pre> <div class="fragment"><div class="line"><span class="lineno">  545</span><span class="keyword">def </span>ensure_key_mapped(values, key: Callable | <span class="keywordtype">None</span>, levels=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  546</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    Applies a callable key function to the values function and checks</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    that the resulting value has the same shape. Can be called on Index</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    subclasses, Series, DataFrames, or ndarrays.</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    values : Series, DataFrame, Index subclass, or ndarray</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    key : Optional[Callable], key to be called on the values array</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    levels : Optional[List], if values is a MultiIndex, list of levels to</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    apply the key to.</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  558</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1api.html">pandas.core.indexes.api</a> <span class="keyword">import</span> Index</div>
<div class="line"><span class="lineno">  559</span> </div>
<div class="line"><span class="lineno">  560</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> key:</div>
<div class="line"><span class="lineno">  561</span>        <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno">  562</span> </div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">if</span> isinstance(values, ABCMultiIndex):</div>
<div class="line"><span class="lineno">  564</span>        <span class="keywordflow">return</span> _ensure_key_mapped_multiindex(values, key, level=levels)</div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span>    result = key(values.copy())</div>
<div class="line"><span class="lineno">  567</span>    <span class="keywordflow">if</span> len(result) != len(values):</div>
<div class="line"><span class="lineno">  568</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  569</span>            <span class="stringliteral">&quot;User-provided `key` function must not change the shape of the array.&quot;</span></div>
<div class="line"><span class="lineno">  570</span>        )</div>
<div class="line"><span class="lineno">  571</span> </div>
<div class="line"><span class="lineno">  572</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  573</span>        <span class="keywordflow">if</span> isinstance(</div>
<div class="line"><span class="lineno">  574</span>            values, Index</div>
<div class="line"><span class="lineno">  575</span>        ):  <span class="comment"># convert to a new Index subclass, not necessarily the same</span></div>
<div class="line"><span class="lineno">  576</span>            result = Index(result)</div>
<div class="line"><span class="lineno">  577</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  578</span>            type_of_values = type(values)</div>
<div class="line"><span class="lineno">  579</span>            result = type_of_values(result)  <span class="comment"># try to revert to original type otherwise</span></div>
<div class="line"><span class="lineno">  580</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  581</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  582</span>            f<span class="stringliteral">&quot;User-provided `key` function returned an invalid type {type(result)} \</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">            which could not be converted to {type(values)}.&quot;</span></div>
<div class="line"><span class="lineno">  584</span>        )</div>
<div class="line"><span class="lineno">  585</span> </div>
<div class="line"><span class="lineno">  586</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  587</span> </div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1indexes_1_1api_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1indexes_1_1api.html">pandas.core.indexes.api</a></div><div class="ttdef"><b>Definition</b> api.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a958d45b3afb39502d01b014cccbb7401" name="a958d45b3afb39502d01b014cccbb7401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958d45b3afb39502d01b014cccbb7401">&#9670;&#160;</a></span>get_compressed_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.int64]] pandas.core.sorting.get_compressed_ids </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape
&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Group_index is offsets into cartesian product of all possible labels. This
space can be huge, so this function compresses it, by computing offsets
(comp_ids) into the list of unique labels (obs_group_ids).

Parameters
----------
labels : list of label arrays
sizes : tuple[int] of size of the levels

Returns
-------
np.ndarray[np.intp]
    comp_ids
np.ndarray[np.int64]
    obs_group_ids
</pre> <div class="fragment"><div class="line"><span class="lineno">  205</span>) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.int64]]:</div>
<div class="line"><span class="lineno">  206</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    Group_index is offsets into cartesian product of all possible labels. This</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    space can be huge, so this function compresses it, by computing offsets</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    (comp_ids) into the list of unique labels (obs_group_ids).</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    labels : list of label arrays</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    sizes : tuple[int] of size of the levels</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        comp_ids</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    np.ndarray[np.int64]</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">        obs_group_ids</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  223</span>    ids = get_group_index(labels, sizes, sort=<span class="keyword">True</span>, xnull=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  224</span>    <span class="keywordflow">return</span> compress_group_index(ids, sort=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  225</span> </div>
<div class="line"><span class="lineno">  226</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb4b09b6dcedc57a6e7d13733b54e395" name="aeb4b09b6dcedc57a6e7d13733b54e395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4b09b6dcedc57a6e7d13733b54e395">&#9670;&#160;</a></span>get_flattened_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[tuple] pandas.core.sorting.get_flattened_list </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>comp_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ngroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>]&#160;</td>
          <td class="paramname"><em>levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[np.ndarray]&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Map compressed group id -&gt; key tuple.</pre> <div class="fragment"><div class="line"><span class="lineno">  594</span>) -&gt; list[tuple]:</div>
<div class="line"><span class="lineno">  595</span>    <span class="stringliteral">&quot;&quot;&quot;Map compressed group id -&gt; key tuple.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  596</span>    comp_ids = comp_ids.astype(np.int64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  597</span>    arrays: DefaultDict[int, list[int]] = defaultdict(list)</div>
<div class="line"><span class="lineno">  598</span>    <span class="keywordflow">for</span> labs, level <span class="keywordflow">in</span> zip(labels, levels):</div>
<div class="line"><span class="lineno">  599</span>        table = hashtable.Int64HashTable(ngroups)</div>
<div class="line"><span class="lineno">  600</span>        table.map_keys_to_values(comp_ids, labs.astype(np.int64, copy=<span class="keyword">False</span>))</div>
<div class="line"><span class="lineno">  601</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(ngroups):</div>
<div class="line"><span class="lineno">  602</span>            arrays[i].append(level[table.get_item(i)])</div>
<div class="line"><span class="lineno">  603</span>    <span class="keywordflow">return</span> [tuple(array) <span class="keywordflow">for</span> array <span class="keywordflow">in</span> arrays.values()]</div>
<div class="line"><span class="lineno">  604</span> </div>
<div class="line"><span class="lineno">  605</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adbcaea4c69033b757e68fb6f8ed6105c" name="adbcaea4c69033b757e68fb6f8ed6105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcaea4c69033b757e68fb6f8ed6105c">&#9670;&#160;</a></span>get_group_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.int64] pandas.core.sorting.get_group_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>xnull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For the particular label_list, gets the offsets into the hypothetical list
representing the totally ordered cartesian product of all possible label
combinations, *as long as* this space fits within int64 bounds;
otherwise, though group indices identify unique combinations of
labels, they cannot be deconstructed.
- If `sort`, rank of returned ids preserve lexical ranks of labels.
  i.e. returned id's can be used to do lexical sort on labels;
- If `xnull` nulls (-1 labels) are passed through.

Parameters
----------
labels : sequence of arrays
    Integers identifying levels at each location
shape : tuple[int, ...]
    Number of unique levels at each location
sort : bool
    If the ranks of returned ids should match lexical ranks of labels
xnull : bool
    If true nulls are excluded. i.e. -1 values in the labels are
    passed through.

Returns
-------
An array of type int64 where two elements are equal if their corresponding
labels are equal at all location.

Notes
-----
The length of `labels` and `shape` must be identical.
</pre> <div class="fragment"><div class="line"><span class="lineno">  111</span>) -&gt; npt.NDArray[np.int64]:</div>
<div class="line"><span class="lineno">  112</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    For the particular label_list, gets the offsets into the hypothetical list</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    representing the totally ordered cartesian product of all possible label</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    combinations, *as long as* this space fits within int64 bounds;</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    otherwise, though group indices identify unique combinations of</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    labels, they cannot be deconstructed.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    - If `sort`, rank of returned ids preserve lexical ranks of labels.</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">      i.e. returned id&#39;s can be used to do lexical sort on labels;</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    - If `xnull` nulls (-1 labels) are passed through.</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    labels : sequence of arrays</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        Integers identifying levels at each location</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    shape : tuple[int, ...]</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        Number of unique levels at each location</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    sort : bool</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">        If the ranks of returned ids should match lexical ranks of labels</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    xnull : bool</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        If true nulls are excluded. i.e. -1 values in the labels are</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">        passed through.</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    An array of type int64 where two elements are equal if their corresponding</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    labels are equal at all location.</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    The length of `labels` and `shape` must be identical.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>    <span class="keyword">def </span>_int64_cut_off(shape) -&gt; int:</div>
<div class="line"><span class="lineno">  145</span>        acc = 1</div>
<div class="line"><span class="lineno">  146</span>        <span class="keywordflow">for</span> i, mul <span class="keywordflow">in</span> enumerate(shape):</div>
<div class="line"><span class="lineno">  147</span>            acc *= int(mul)</div>
<div class="line"><span class="lineno">  148</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> acc &lt; lib.i8max:</div>
<div class="line"><span class="lineno">  149</span>                <span class="keywordflow">return</span> i</div>
<div class="line"><span class="lineno">  150</span>        <span class="keywordflow">return</span> len(shape)</div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span>    <span class="keyword">def </span>maybe_lift(lab, size) -&gt; tuple[np.ndarray, int]:</div>
<div class="line"><span class="lineno">  153</span>        <span class="comment"># promote nan values (assigned -1 label in lab array)</span></div>
<div class="line"><span class="lineno">  154</span>        <span class="comment"># so that all output values are non-negative</span></div>
<div class="line"><span class="lineno">  155</span>        <span class="keywordflow">return</span> (lab + 1, size + 1) <span class="keywordflow">if</span> (lab == -1).any() <span class="keywordflow">else</span> (lab, size)</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>    labels = [ensure_int64(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> labels]</div>
<div class="line"><span class="lineno">  158</span>    lshape = list(shape)</div>
<div class="line"><span class="lineno">  159</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> xnull:</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">for</span> i, (lab, size) <span class="keywordflow">in</span> enumerate(zip(labels, shape)):</div>
<div class="line"><span class="lineno">  161</span>            lab, size = maybe_lift(lab, size)</div>
<div class="line"><span class="lineno">  162</span>            labels[i] = lab</div>
<div class="line"><span class="lineno">  163</span>            lshape[i] = size</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    labels = list(labels)</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>    <span class="comment"># Iteratively process all the labels in chunks sized so less</span></div>
<div class="line"><span class="lineno">  168</span>    <span class="comment"># than lib.i8max unique int ids will be required for each chunk</span></div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  170</span>        <span class="comment"># how many levels can be done without overflow:</span></div>
<div class="line"><span class="lineno">  171</span>        nlev = _int64_cut_off(lshape)</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>        <span class="comment"># compute flat ids for the first `nlev` levels</span></div>
<div class="line"><span class="lineno">  174</span>        stride = np.prod(lshape[1:nlev], dtype=<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno">  175</span>        out = stride * labels[0].astype(<span class="stringliteral">&quot;i8&quot;</span>, subok=<span class="keyword">False</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, nlev):</div>
<div class="line"><span class="lineno">  178</span>            <span class="keywordflow">if</span> lshape[i] == 0:</div>
<div class="line"><span class="lineno">  179</span>                stride = np.int64(0)</div>
<div class="line"><span class="lineno">  180</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  181</span>                stride //= lshape[i]</div>
<div class="line"><span class="lineno">  182</span>            out += labels[i] * stride</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>        <span class="keywordflow">if</span> xnull:  <span class="comment"># exclude nulls</span></div>
<div class="line"><span class="lineno">  185</span>            mask = labels[0] == -1</div>
<div class="line"><span class="lineno">  186</span>            <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> labels[1:nlev]:</div>
<div class="line"><span class="lineno">  187</span>                mask |= lab == -1</div>
<div class="line"><span class="lineno">  188</span>            out[mask] = -1</div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="line"><span class="lineno">  190</span>        <span class="keywordflow">if</span> nlev == len(lshape):  <span class="comment"># all levels done!</span></div>
<div class="line"><span class="lineno">  191</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span>        <span class="comment"># compress what has been done so far in order to avoid overflow</span></div>
<div class="line"><span class="lineno">  194</span>        <span class="comment"># to retain lexical ranks, obs_ids should be sorted</span></div>
<div class="line"><span class="lineno">  195</span>        comp_ids, obs_ids = compress_group_index(out, sort=sort)</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span>        labels = [comp_ids] + labels[nlev:]</div>
<div class="line"><span class="lineno">  198</span>        lshape = [len(obs_ids)] + lshape[nlev:]</div>
<div class="line"><span class="lineno">  199</span> </div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  201</span> </div>
<div class="line"><span class="lineno">  202</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a508c4e5b564f2354194bf7a44b6df8e7" name="a508c4e5b564f2354194bf7a44b6df8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508c4e5b564f2354194bf7a44b6df8e7">&#9670;&#160;</a></span>get_group_index_sorter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.sorting.get_group_index_sorter </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>group_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>ngroups</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">algos.groupsort_indexer implements `counting sort` and it is at least
O(ngroups), where
    ngroups = prod(shape)
    shape = map(len, keys)
that is, linear in the number of combinations (cartesian product) of unique
values of groupby keys. This can be huge when doing multi-key groupby.
np.argsort(kind='mergesort') is O(count x log(count)) where count is the
length of the data-frame;
Both algorithms are `stable` sort and that is necessary for correctness of
groupby operations. e.g. consider:
    df.groupby(key)[col].transform('first')

Parameters
----------
group_index : np.ndarray[np.intp]
    signed integer dtype
ngroups : int or None, default None

Returns
-------
np.ndarray[np.intp]
</pre> <div class="fragment"><div class="line"><span class="lineno">  641</span>) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno">  642</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    algos.groupsort_indexer implements `counting sort` and it is at least</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    O(ngroups), where</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        ngroups = prod(shape)</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">        shape = map(len, keys)</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    that is, linear in the number of combinations (cartesian product) of unique</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    values of groupby keys. This can be huge when doing multi-key groupby.</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    np.argsort(kind=&#39;mergesort&#39;) is O(count x log(count)) where count is the</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    length of the data-frame;</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    Both algorithms are `stable` sort and that is necessary for correctness of</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    groupby operations. e.g. consider:</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        df.groupby(key)[col].transform(&#39;first&#39;)</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    group_index : np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        signed integer dtype</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    ngroups : int or None, default None</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">if</span> ngroups <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  666</span>        ngroups = 1 + group_index.max()</div>
<div class="line"><span class="lineno">  667</span>    count = len(group_index)</div>
<div class="line"><span class="lineno">  668</span>    alpha = 0.0  <span class="comment"># taking complexities literally; there may be</span></div>
<div class="line"><span class="lineno">  669</span>    beta = 1.0  <span class="comment"># some room for fine-tuning these parameters</span></div>
<div class="line"><span class="lineno">  670</span>    do_groupsort = count &gt; 0 <span class="keywordflow">and</span> ((alpha + beta * ngroups) &lt; (count * np.log(count)))</div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">if</span> do_groupsort:</div>
<div class="line"><span class="lineno">  672</span>        sorter, _ = algos.groupsort_indexer(</div>
<div class="line"><span class="lineno">  673</span>            ensure_platform_int(group_index),</div>
<div class="line"><span class="lineno">  674</span>            ngroups,</div>
<div class="line"><span class="lineno">  675</span>        )</div>
<div class="line"><span class="lineno">  676</span>        <span class="comment"># sorter _should_ already be intp, but mypy is not yet able to verify</span></div>
<div class="line"><span class="lineno">  677</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  678</span>        sorter = group_index.argsort(kind=<span class="stringliteral">&quot;mergesort&quot;</span>)</div>
<div class="line"><span class="lineno">  679</span>    <span class="keywordflow">return</span> ensure_platform_int(sorter)</div>
<div class="line"><span class="lineno">  680</span> </div>
<div class="line"><span class="lineno">  681</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2f9b61304768d12c21ff05d08e6f739" name="ac2f9b61304768d12c21ff05d08e6f739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f9b61304768d12c21ff05d08e6f739">&#9670;&#160;</a></span>get_indexer_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[Hashable, npt.NDArray[np.intp]] pandas.core.sorting.get_indexer_dict </td>
          <td>(</td>
          <td class="paramtype">list[np.ndarray]&#160;</td>
          <td class="paramname"><em>label_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>]
&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns
-------
dict:
    Labels mapped to indexers.
</pre> <div class="fragment"><div class="line"><span class="lineno">  608</span>) -&gt; dict[Hashable, npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno">  609</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    dict:</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">        Labels mapped to indexers.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  615</span>    shape = tuple(len(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> keys)</div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span>    group_index = get_group_index(label_list, shape, sort=<span class="keyword">True</span>, xnull=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  618</span>    <span class="keywordflow">if</span> np.all(group_index == -1):</div>
<div class="line"><span class="lineno">  619</span>        <span class="comment"># Short-circuit, lib.indices_fast will return the same</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">return</span> {}</div>
<div class="line"><span class="lineno">  621</span>    ngroups = (</div>
<div class="line"><span class="lineno">  622</span>        ((group_index.size <span class="keywordflow">and</span> group_index.max()) + 1)</div>
<div class="line"><span class="lineno">  623</span>        <span class="keywordflow">if</span> is_int64_overflow_possible(shape)</div>
<div class="line"><span class="lineno">  624</span>        <span class="keywordflow">else</span> np.prod(shape, dtype=<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno">  625</span>    )</div>
<div class="line"><span class="lineno">  626</span> </div>
<div class="line"><span class="lineno">  627</span>    sorter = get_group_index_sorter(group_index, ngroups)</div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="line"><span class="lineno">  629</span>    sorted_labels = [lab.take(sorter) <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> label_list]</div>
<div class="line"><span class="lineno">  630</span>    group_index = group_index.take(sorter)</div>
<div class="line"><span class="lineno">  631</span> </div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">return</span> lib.indices_fast(sorter, group_index, keys, sorted_labels)</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span><span class="comment"># ----------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno">  636</span><span class="comment"># sorting levels...cleverly?</span></div>
<div class="line"><span class="lineno">  637</span> </div>
<div class="line"><span class="lineno">  638</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3424d37a346a18dfef5aab847c60965" name="ae3424d37a346a18dfef5aab847c60965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3424d37a346a18dfef5aab847c60965">&#9670;&#160;</a></span>get_indexer_indexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] | None pandas.core.sorting.get_indexer_indexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Level | list[Level] | None&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[bool] | bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortKind&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NaPosition&#160;</td>
          <td class="paramname"><em>na_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexKeyFunc&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper method that return the indexer according to input parameters for
the sort_index method of DataFrame and Series.

Parameters
----------
target : Index
level : int or level name or list of ints or list of level names
ascending : bool or list of bools, default True
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort'
na_position : {'first', 'last'}, default 'last'
sort_remaining : bool, default True
key : callable, optional

Returns
-------
Optional[ndarray[intp]]
    The indexer for the new index.
</pre> <div class="fragment"><div class="line"><span class="lineno">   60</span>) -&gt; npt.NDArray[np.intp] | <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   61</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    Helper method that return the indexer according to input parameters for</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    the sort_index method of DataFrame and Series.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    target : Index</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    level : int or level name or list of ints or list of level names</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    ascending : bool or list of bools, default True</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, default &#39;quicksort&#39;</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    sort_remaining : bool, default True</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    key : callable, optional</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    Optional[ndarray[intp]]</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">        The indexer for the new index.</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>    target = ensure_key_mapped(target, key, levels=level)</div>
<div class="line"><span class="lineno">   82</span>    target = target._sort_levels_monotonic()</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>    <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   85</span>        _, indexer = target.sortlevel(</div>
<div class="line"><span class="lineno">   86</span>            level, ascending=ascending, sort_remaining=sort_remaining</div>
<div class="line"><span class="lineno">   87</span>        )</div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordflow">elif</span> isinstance(target, ABCMultiIndex):</div>
<div class="line"><span class="lineno">   89</span>        indexer = lexsort_indexer(</div>
<div class="line"><span class="lineno">   90</span>            target._get_codes_for_sorting(), orders=ascending, na_position=na_position</div>
<div class="line"><span class="lineno">   91</span>        )</div>
<div class="line"><span class="lineno">   92</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   93</span>        <span class="comment"># Check monotonic-ness before sort an index (GH 11080)</span></div>
<div class="line"><span class="lineno">   94</span>        <span class="keywordflow">if</span> (ascending <span class="keywordflow">and</span> target.is_monotonic_increasing) <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno">   95</span>            <span class="keywordflow">not</span> ascending <span class="keywordflow">and</span> target.is_monotonic_decreasing</div>
<div class="line"><span class="lineno">   96</span>        ):</div>
<div class="line"><span class="lineno">   97</span>            <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">   98</span> </div>
<div class="line"><span class="lineno">   99</span>        <span class="comment"># ascending can only be a Sequence for MultiIndex</span></div>
<div class="line"><span class="lineno">  100</span>        indexer = nargsort(</div>
<div class="line"><span class="lineno">  101</span>            target,</div>
<div class="line"><span class="lineno">  102</span>            kind=kind,</div>
<div class="line"><span class="lineno">  103</span>            ascending=cast(bool, ascending),</div>
<div class="line"><span class="lineno">  104</span>            na_position=na_position,</div>
<div class="line"><span class="lineno">  105</span>        )</div>
<div class="line"><span class="lineno">  106</span>    <span class="keywordflow">return</span> indexer</div>
<div class="line"><span class="lineno">  107</span> </div>
<div class="line"><span class="lineno">  108</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d7f8188ef6a62e80a052e3445e2fd19" name="a0d7f8188ef6a62e80a052e3445e2fd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7f8188ef6a62e80a052e3445e2fd19">&#9670;&#160;</a></span>indexer_from_factorized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.sorting.indexer_from_factorized </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>compress</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  292</span>) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno">  293</span>    ids = get_group_index(labels, shape, sort=<span class="keyword">True</span>, xnull=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> compress:</div>
<div class="line"><span class="lineno">  296</span>        ngroups = (ids.size <span class="keywordflow">and</span> ids.max()) + 1</div>
<div class="line"><span class="lineno">  297</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  298</span>        ids, obs = compress_group_index(ids, sort=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  299</span>        ngroups = len(obs)</div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>    <span class="keywordflow">return</span> get_group_index_sorter(ids, ngroups)</div>
<div class="line"><span class="lineno">  302</span> </div>
<div class="line"><span class="lineno">  303</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ae8cf75c93f330b36b0d473c588b747" name="a6ae8cf75c93f330b36b0d473c588b747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae8cf75c93f330b36b0d473c588b747">&#9670;&#160;</a></span>is_int64_overflow_possible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.sorting.is_int64_overflow_possible </td>
          <td>(</td>
          <td class="paramtype">Shape&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  227</span><span class="keyword">def </span>is_int64_overflow_possible(shape: Shape) -&gt; bool:</div>
<div class="line"><span class="lineno">  228</span>    the_prod = 1</div>
<div class="line"><span class="lineno">  229</span>    <span class="keywordflow">for</span> x <span class="keywordflow">in</span> shape:</div>
<div class="line"><span class="lineno">  230</span>        the_prod *= int(x)</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">return</span> the_prod &gt;= lib.i8max</div>
<div class="line"><span class="lineno">  233</span> </div>
<div class="line"><span class="lineno">  234</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6801743601e486a192101694a3a834ba" name="a6801743601e486a192101694a3a834ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6801743601e486a192101694a3a834ba">&#9670;&#160;</a></span>lexsort_indexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.sorting.lexsort_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orders</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>na_position</em> = <code>&quot;last&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None &#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs lexical sorting on a set of keys

Parameters
----------
keys : sequence of arrays
    Sequence of ndarrays to be sorted by the indexer
orders : bool or list of booleans, optional
    Determines the sorting order for each element in keys. If a list,
    it must be the same length as keys. This determines whether the
    corresponding element in keys should be sorted in ascending
    (True) or descending (False) order. if bool, applied to all
    elements as above. if None, defaults to True.
na_position : {'first', 'last'}, default 'last'
    Determines placement of NA elements in the sorted list ("last" or "first")
key : Callable, optional
    Callable key function applied to every element in keys before sorting

    .. versionadded:: 1.0.0

Returns
-------
np.ndarray[np.intp]
</pre> <div class="fragment"><div class="line"><span class="lineno">  306</span>) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno">  307</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    Performs lexical sorting on a set of keys</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    keys : sequence of arrays</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        Sequence of ndarrays to be sorted by the indexer</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    orders : bool or list of booleans, optional</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        Determines the sorting order for each element in keys. If a list,</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">        it must be the same length as keys. This determines whether the</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        corresponding element in keys should be sorted in ascending</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        (True) or descending (False) order. if bool, applied to all</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        elements as above. if None, defaults to True.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        Determines placement of NA elements in the sorted list (&quot;last&quot; or &quot;first&quot;)</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    key : Callable, optional</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">        Callable key function applied to every element in keys before sorting</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        .. versionadded:: 1.0.0</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  331</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a> <span class="keyword">import</span> Categorical</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>    labels = []</div>
<div class="line"><span class="lineno">  334</span>    shape = []</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">if</span> isinstance(orders, bool):</div>
<div class="line"><span class="lineno">  336</span>        orders = [orders] * len(keys)</div>
<div class="line"><span class="lineno">  337</span>    <span class="keywordflow">elif</span> orders <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  338</span>        orders = [<span class="keyword">True</span>] * len(keys)</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>    keys = [ensure_key_mapped(k, key) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> keys]</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>    <span class="keywordflow">for</span> k, order <span class="keywordflow">in</span> zip(keys, orders):</div>
<div class="line"><span class="lineno">  343</span>        <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno">  344</span>            <span class="comment"># TODO(2.0): unnecessary once deprecation is enforced</span></div>
<div class="line"><span class="lineno">  345</span>            <span class="comment"># GH#45618 don&#39;t issue warning user can&#39;t do anything about</span></div>
<div class="line"><span class="lineno">  346</span>            warnings.filterwarnings(</div>
<div class="line"><span class="lineno">  347</span>                <span class="stringliteral">&quot;ignore&quot;</span>, <span class="stringliteral">&quot;.*(SparseArray|SparseDtype).*&quot;</span>, category=FutureWarning</div>
<div class="line"><span class="lineno">  348</span>            )</div>
<div class="line"><span class="lineno">  349</span> </div>
<div class="line"><span class="lineno">  350</span>            cat = Categorical(k, ordered=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>        <span class="keywordflow">if</span> na_position <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;last&quot;</span>, <span class="stringliteral">&quot;first&quot;</span>]:</div>
<div class="line"><span class="lineno">  353</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;invalid na_position: {na_position}&quot;</span>)</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>        n = len(cat.categories)</div>
<div class="line"><span class="lineno">  356</span>        codes = cat.codes.copy()</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>        mask = cat.codes == -1</div>
<div class="line"><span class="lineno">  359</span>        <span class="keywordflow">if</span> order:  <span class="comment"># ascending</span></div>
<div class="line"><span class="lineno">  360</span>            <span class="keywordflow">if</span> na_position == <span class="stringliteral">&quot;last&quot;</span>:</div>
<div class="line"><span class="lineno">  361</span>                codes = np.where(mask, n, codes)</div>
<div class="line"><span class="lineno">  362</span>            <span class="keywordflow">elif</span> na_position == <span class="stringliteral">&quot;first&quot;</span>:</div>
<div class="line"><span class="lineno">  363</span>                codes += 1</div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">else</span>:  <span class="comment"># not order means descending</span></div>
<div class="line"><span class="lineno">  365</span>            <span class="keywordflow">if</span> na_position == <span class="stringliteral">&quot;last&quot;</span>:</div>
<div class="line"><span class="lineno">  366</span>                codes = np.where(mask, n, n - codes - 1)</div>
<div class="line"><span class="lineno">  367</span>            <span class="keywordflow">elif</span> na_position == <span class="stringliteral">&quot;first&quot;</span>:</div>
<div class="line"><span class="lineno">  368</span>                codes = np.where(mask, 0, n - codes)</div>
<div class="line"><span class="lineno">  369</span>        <span class="keywordflow">if</span> mask.any():</div>
<div class="line"><span class="lineno">  370</span>            n += 1</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span>        shape.append(n)</div>
<div class="line"><span class="lineno">  373</span>        labels.append(codes)</div>
<div class="line"><span class="lineno">  374</span> </div>
<div class="line"><span class="lineno">  375</span>    <span class="keywordflow">return</span> indexer_from_factorized(labels, tuple(shape))</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5af2dae46e98b69a841f7ef358b3b16d" name="a5af2dae46e98b69a841f7ef358b3b16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af2dae46e98b69a841f7ef358b3b16d">&#9670;&#160;</a></span>nargminmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.sorting.nargminmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Implementation of np.argmin/argmax but for ExtensionArray and which
handles missing values.

Parameters
----------
values : ExtensionArray
method : {"argmax", "argmin"}
axis : int, default 0

Returns
-------
int
</pre> <div class="fragment"><div class="line"><span class="lineno">  452</span><span class="keyword">def </span>nargminmax(values: ExtensionArray, method: str, axis: int = 0):</div>
<div class="line"><span class="lineno">  453</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    Implementation of np.argmin/argmax but for ExtensionArray and which</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    handles missing values.</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    values : ExtensionArray</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    method : {&quot;argmax&quot;, &quot;argmin&quot;}</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    axis : int, default 0</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    int</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  467</span>    <span class="keyword">assert</span> method <span class="keywordflow">in</span> {<span class="stringliteral">&quot;argmax&quot;</span>, <span class="stringliteral">&quot;argmin&quot;</span>}</div>
<div class="line"><span class="lineno">  468</span>    func = np.argmax <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;argmax&quot;</span> <span class="keywordflow">else</span> np.argmin</div>
<div class="line"><span class="lineno">  469</span> </div>
<div class="line"><span class="lineno">  470</span>    mask = np.asarray(isna(values))</div>
<div class="line"><span class="lineno">  471</span>    arr_values = values._values_for_argsort()</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordflow">if</span> arr_values.ndim &gt; 1:</div>
<div class="line"><span class="lineno">  474</span>        <span class="keywordflow">if</span> mask.any():</div>
<div class="line"><span class="lineno">  475</span>            <span class="keywordflow">if</span> axis == 1:</div>
<div class="line"><span class="lineno">  476</span>                zipped = zip(arr_values, mask)</div>
<div class="line"><span class="lineno">  477</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  478</span>                zipped = zip(arr_values.T, mask.T)</div>
<div class="line"><span class="lineno">  479</span>            <span class="keywordflow">return</span> np.array([_nanargminmax(v, m, func) <span class="keywordflow">for</span> v, m <span class="keywordflow">in</span> zipped])</div>
<div class="line"><span class="lineno">  480</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(arr_values, axis=axis)</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span>    <span class="keywordflow">return</span> _nanargminmax(arr_values, mask, func)</div>
<div class="line"><span class="lineno">  483</span> </div>
<div class="line"><span class="lineno">  484</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a30d3437fe85222478566b66ea51babc6" name="a30d3437fe85222478566b66ea51babc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d3437fe85222478566b66ea51babc6">&#9670;&#160;</a></span>nargsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.sorting.nargsort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>kind</em> = <code>&quot;quicksort&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>na_position</em> = <code>&quot;last&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None &#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intended to be a drop-in replacement for np.argsort which handles NaNs.

Adds ascending, na_position, and key parameters.

(GH #6399, #5231, #27237)

Parameters
----------
kind : str, default 'quicksort'
ascending : bool, default True
na_position : {'first', 'last'}, default 'last'
key : Optional[Callable], default None
mask : Optional[np.ndarray[bool]], default None
    Passed when called by ExtensionArray.argsort.

Returns
-------
np.ndarray[np.intp]
</pre> <div class="fragment"><div class="line"><span class="lineno">  385</span>) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno">  386</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    Intended to be a drop-in replacement for np.argsort which handles NaNs.</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    Adds ascending, na_position, and key parameters.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    (GH #6399, #5231, #27237)</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    kind : str, default &#39;quicksort&#39;</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    ascending : bool, default True</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    key : Optional[Callable], default None</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    mask : Optional[np.ndarray[bool]], default None</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        Passed when called by ExtensionArray.argsort.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  406</span> </div>
<div class="line"><span class="lineno">  407</span>    <span class="keywordflow">if</span> key <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  408</span>        items = ensure_key_mapped(items, key)</div>
<div class="line"><span class="lineno">  409</span>        <span class="keywordflow">return</span> nargsort(</div>
<div class="line"><span class="lineno">  410</span>            items,</div>
<div class="line"><span class="lineno">  411</span>            kind=kind,</div>
<div class="line"><span class="lineno">  412</span>            ascending=ascending,</div>
<div class="line"><span class="lineno">  413</span>            na_position=na_position,</div>
<div class="line"><span class="lineno">  414</span>            key=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  415</span>            mask=mask,</div>
<div class="line"><span class="lineno">  416</span>        )</div>
<div class="line"><span class="lineno">  417</span> </div>
<div class="line"><span class="lineno">  418</span>    <span class="keywordflow">if</span> isinstance(items, ABCRangeIndex):</div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">return</span> items.argsort(ascending=ascending)  <span class="comment"># TODO: test coverage with key?</span></div>
<div class="line"><span class="lineno">  420</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(items, ABCMultiIndex):</div>
<div class="line"><span class="lineno">  421</span>        items = extract_array(items)</div>
<div class="line"><span class="lineno">  422</span>    <span class="keywordflow">if</span> mask <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  423</span>        mask = np.asarray(isna(items))  <span class="comment"># TODO: does this exclude MultiIndex too?</span></div>
<div class="line"><span class="lineno">  424</span> </div>
<div class="line"><span class="lineno">  425</span>    <span class="keywordflow">if</span> is_extension_array_dtype(items):</div>
<div class="line"><span class="lineno">  426</span>        <span class="keywordflow">return</span> items.argsort(ascending=ascending, kind=kind, na_position=na_position)</div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  428</span>        items = np.asanyarray(items)</div>
<div class="line"><span class="lineno">  429</span> </div>
<div class="line"><span class="lineno">  430</span>    idx = np.arange(len(items))</div>
<div class="line"><span class="lineno">  431</span>    non_nans = items[~mask]</div>
<div class="line"><span class="lineno">  432</span>    non_nan_idx = idx[~mask]</div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>    nan_idx = np.nonzero(mask)[0]</div>
<div class="line"><span class="lineno">  435</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> ascending:</div>
<div class="line"><span class="lineno">  436</span>        non_nans = non_nans[::-1]</div>
<div class="line"><span class="lineno">  437</span>        non_nan_idx = non_nan_idx[::-1]</div>
<div class="line"><span class="lineno">  438</span>    indexer = non_nan_idx[non_nans.argsort(kind=kind)]</div>
<div class="line"><span class="lineno">  439</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> ascending:</div>
<div class="line"><span class="lineno">  440</span>        indexer = indexer[::-1]</div>
<div class="line"><span class="lineno">  441</span>    <span class="comment"># Finally, place the NaNs at the end or the beginning according to</span></div>
<div class="line"><span class="lineno">  442</span>    <span class="comment"># na_position</span></div>
<div class="line"><span class="lineno">  443</span>    <span class="keywordflow">if</span> na_position == <span class="stringliteral">&quot;last&quot;</span>:</div>
<div class="line"><span class="lineno">  444</span>        indexer = np.concatenate([indexer, nan_idx])</div>
<div class="line"><span class="lineno">  445</span>    <span class="keywordflow">elif</span> na_position == <span class="stringliteral">&quot;first&quot;</span>:</div>
<div class="line"><span class="lineno">  446</span>        indexer = np.concatenate([nan_idx, indexer])</div>
<div class="line"><span class="lineno">  447</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  448</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;invalid na_position: {na_position}&quot;</span>)</div>
<div class="line"><span class="lineno">  449</span>    <span class="keywordflow">return</span> ensure_platform_int(indexer)</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
