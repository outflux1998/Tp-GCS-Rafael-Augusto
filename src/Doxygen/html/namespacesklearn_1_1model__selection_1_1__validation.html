<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.model_selection._validation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1model__selection.html">model_selection</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html">_validation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.model_selection._validation Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa742d74376d80abd1cb43c2ab86dd39e" id="r_aa742d74376d80abd1cb43c2ab86dd39e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#aa742d74376d80abd1cb43c2ab86dd39e">cross_validate</a> (estimator, X, y=None, *groups=None, scoring=None, cv=None, n_jobs=None, verbose=0, fit_params=None, pre_dispatch=&quot;2*n_jobs&quot;, return_train_score=False, return_estimator=False, error_score=np.nan)</td></tr>
<tr class="separator:aa742d74376d80abd1cb43c2ab86dd39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb095e3fc436fbe882f7d5f58dea3777" id="r_afb095e3fc436fbe882f7d5f58dea3777"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#afb095e3fc436fbe882f7d5f58dea3777">_insert_error_scores</a> (results, error_score)</td></tr>
<tr class="separator:afb095e3fc436fbe882f7d5f58dea3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b53705a88d7217c3361b4463b272f2" id="r_ac6b53705a88d7217c3361b4463b272f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#ac6b53705a88d7217c3361b4463b272f2">_normalize_score_results</a> (scores, scaler_score_key=&quot;score&quot;)</td></tr>
<tr class="separator:ac6b53705a88d7217c3361b4463b272f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8db1f680a2824ad71a404d074b3014" id="r_aea8db1f680a2824ad71a404d074b3014"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#aea8db1f680a2824ad71a404d074b3014">_warn_or_raise_about_fit_failures</a> (results, error_score)</td></tr>
<tr class="separator:aea8db1f680a2824ad71a404d074b3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d327fc818f8db201e49936c7befa3b" id="r_af5d327fc818f8db201e49936c7befa3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#af5d327fc818f8db201e49936c7befa3b">cross_val_score</a> (estimator, X, y=None, *groups=None, scoring=None, cv=None, n_jobs=None, verbose=0, fit_params=None, pre_dispatch=&quot;2*n_jobs&quot;, error_score=np.nan)</td></tr>
<tr class="separator:af5d327fc818f8db201e49936c7befa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88729dece2b104fb07abc76766ecb988" id="r_a88729dece2b104fb07abc76766ecb988"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#a88729dece2b104fb07abc76766ecb988">_fit_and_score</a> (estimator, X, y, scorer, train, test, verbose, parameters, fit_params, return_train_score=False, return_parameters=False, return_n_test_samples=False, return_times=False, return_estimator=False, split_progress=None, candidate_progress=None, error_score=np.nan)</td></tr>
<tr class="separator:a88729dece2b104fb07abc76766ecb988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcfbf8bfae37e3a0d59fadf3b348edf" id="r_adfcfbf8bfae37e3a0d59fadf3b348edf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#adfcfbf8bfae37e3a0d59fadf3b348edf">_score</a> (estimator, X_test, y_test, scorer, error_score=&quot;raise&quot;)</td></tr>
<tr class="separator:adfcfbf8bfae37e3a0d59fadf3b348edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a785340cb33fd1f7bfa89f4900a9de" id="r_a66a785340cb33fd1f7bfa89f4900a9de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#a66a785340cb33fd1f7bfa89f4900a9de">cross_val_predict</a> (estimator, X, y=None, *groups=None, cv=None, n_jobs=None, verbose=0, fit_params=None, pre_dispatch=&quot;2*n_jobs&quot;, method=&quot;predict&quot;)</td></tr>
<tr class="separator:a66a785340cb33fd1f7bfa89f4900a9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad185f0bd5f58abe88a188a2934ff5c86" id="r_ad185f0bd5f58abe88a188a2934ff5c86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#ad185f0bd5f58abe88a188a2934ff5c86">_fit_and_predict</a> (estimator, X, y, train, test, verbose, fit_params, method)</td></tr>
<tr class="separator:ad185f0bd5f58abe88a188a2934ff5c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dad997de888c9b75367c1811edde5f" id="r_ab4dad997de888c9b75367c1811edde5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#ab4dad997de888c9b75367c1811edde5f">_enforce_prediction_order</a> (classes, predictions, n_classes, method)</td></tr>
<tr class="separator:ab4dad997de888c9b75367c1811edde5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d7a0f7b368c77188df1b2c1bac143" id="r_ab18d7a0f7b368c77188df1b2c1bac143"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#ab18d7a0f7b368c77188df1b2c1bac143">_check_is_permutation</a> (indices, n_samples)</td></tr>
<tr class="separator:ab18d7a0f7b368c77188df1b2c1bac143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eb6157ce60419759508751e5491ad0" id="r_a76eb6157ce60419759508751e5491ad0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#a76eb6157ce60419759508751e5491ad0">permutation_test_score</a> (estimator, X, y, *groups=None, cv=None, n_permutations=100, n_jobs=None, random_state=0, verbose=0, scoring=None, fit_params=None)</td></tr>
<tr class="separator:a76eb6157ce60419759508751e5491ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e89c59a15e73159abda6d3b1231d396" id="r_a7e89c59a15e73159abda6d3b1231d396"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#a7e89c59a15e73159abda6d3b1231d396">_permutation_test_score</a> (estimator, X, y, groups, cv, scorer, fit_params)</td></tr>
<tr class="separator:a7e89c59a15e73159abda6d3b1231d396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7587f06b6fe652b5aed5965f1ab58e" id="r_aac7587f06b6fe652b5aed5965f1ab58e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#aac7587f06b6fe652b5aed5965f1ab58e">_shuffle</a> (y, groups, random_state)</td></tr>
<tr class="separator:aac7587f06b6fe652b5aed5965f1ab58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa260a7af36af950ca21d45d53d9c6a40" id="r_aa260a7af36af950ca21d45d53d9c6a40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#aa260a7af36af950ca21d45d53d9c6a40">learning_curve</a> (estimator, X, y, *groups=None, train_sizes=np.linspace(0.1, 1.0, 5), cv=None, scoring=None, exploit_incremental_learning=False, n_jobs=None, pre_dispatch=&quot;all&quot;, verbose=0, shuffle=False, random_state=None, error_score=np.nan, return_times=False, fit_params=None)</td></tr>
<tr class="separator:aa260a7af36af950ca21d45d53d9c6a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1d0424033b9fae7c4c661d594f32c3" id="r_a7a1d0424033b9fae7c4c661d594f32c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#a7a1d0424033b9fae7c4c661d594f32c3">_translate_train_sizes</a> (train_sizes, n_max_training_samples)</td></tr>
<tr class="separator:a7a1d0424033b9fae7c4c661d594f32c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10a0b1fc7555f4e723522194f5700ae" id="r_af10a0b1fc7555f4e723522194f5700ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#af10a0b1fc7555f4e723522194f5700ae">_incremental_fit_estimator</a> (estimator, X, y, classes, train, test, train_sizes, scorer, verbose, return_times, error_score, fit_params)</td></tr>
<tr class="separator:af10a0b1fc7555f4e723522194f5700ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6249c5f667d0d4a04f281013a9cc8b35" id="r_a6249c5f667d0d4a04f281013a9cc8b35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#a6249c5f667d0d4a04f281013a9cc8b35">validation_curve</a> (estimator, X, y, *param_name, param_range, groups=None, cv=None, scoring=None, n_jobs=None, pre_dispatch=&quot;all&quot;, verbose=0, error_score=np.nan, fit_params=None)</td></tr>
<tr class="separator:a6249c5f667d0d4a04f281013a9cc8b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7374b604b129763978eb18b1ac2b1c9c" id="r_a7374b604b129763978eb18b1ac2b1c9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1model__selection_1_1__validation.html#a7374b604b129763978eb18b1ac2b1c9c">_aggregate_score_dicts</a> (scores)</td></tr>
<tr class="separator:a7374b604b129763978eb18b1ac2b1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The :mod:`sklearn.model_selection._validation` module includes classes and
functions to validate the model.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a7374b604b129763978eb18b1ac2b1c9c" name="a7374b604b129763978eb18b1ac2b1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7374b604b129763978eb18b1ac2b1c9c">&#9670;&#160;</a></span>_aggregate_score_dicts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._aggregate_score_dicts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scores</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Aggregate the list of dict to dict of np ndarray

The aggregated output of _aggregate_score_dicts will be a list of dict
of form [{'prec': 0.1, 'acc':1.0}, {'prec': 0.1, 'acc':1.0}, ...]
Convert it to a dict of array {'prec': np.array([0.1 ...]), ...}

Parameters
----------

scores : list of dict
    List of dicts of the scores for all scorers. This is a flat list,
    assumed originally to be of row major order.

Example
-------

&gt;&gt;&gt; scores = [{'a': 1, 'b':10}, {'a': 2, 'b':2}, {'a': 3, 'b':3},
...           {'a': 10, 'b': 10}]                         # doctest: +SKIP
&gt;&gt;&gt; _aggregate_score_dicts(scores)                        # doctest: +SKIP
{'a': array([1, 2, 3, 10]),
 'b': array([10, 2, 3, 10])}
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1885</span><span class="keyword">def </span>_aggregate_score_dicts(scores):</div>
<div class="line"><span class="lineno"> 1886</span>    <span class="stringliteral">&quot;&quot;&quot;Aggregate the list of dict to dict of np ndarray</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">    The aggregated output of _aggregate_score_dicts will be a list of dict</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral">    of form [{&#39;prec&#39;: 0.1, &#39;acc&#39;:1.0}, {&#39;prec&#39;: 0.1, &#39;acc&#39;:1.0}, ...]</span></div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">    Convert it to a dict of array {&#39;prec&#39;: np.array([0.1 ...]), ...}</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    scores : list of dict</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">        List of dicts of the scores for all scorers. This is a flat list,</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">        assumed originally to be of row major order.</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">    Example</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">    &gt;&gt;&gt; scores = [{&#39;a&#39;: 1, &#39;b&#39;:10}, {&#39;a&#39;: 2, &#39;b&#39;:2}, {&#39;a&#39;: 3, &#39;b&#39;:3},</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">    ...           {&#39;a&#39;: 10, &#39;b&#39;: 10}]                         # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">    &gt;&gt;&gt; _aggregate_score_dicts(scores)                        # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral">    {&#39;a&#39;: array([1, 2, 3, 10]),</span></div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">     &#39;b&#39;: array([10, 2, 3, 10])}</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1908</span>    <span class="keywordflow">return</span> {</div>
<div class="line"><span class="lineno"> 1909</span>        key: np.asarray([score[key] <span class="keywordflow">for</span> score <span class="keywordflow">in</span> scores])</div>
<div class="line"><span class="lineno"> 1910</span>        <span class="keywordflow">if</span> isinstance(scores[0][key], numbers.Number)</div>
<div class="line"><span class="lineno"> 1911</span>        <span class="keywordflow">else</span> [score[key] <span class="keywordflow">for</span> score <span class="keywordflow">in</span> scores]</div>
<div class="line"><span class="lineno"> 1912</span>        <span class="keywordflow">for</span> key <span class="keywordflow">in</span> scores[0]</div>
<div class="line"><span class="lineno"> 1913</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab18d7a0f7b368c77188df1b2c1bac143" name="ab18d7a0f7b368c77188df1b2c1bac143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18d7a0f7b368c77188df1b2c1bac143">&#9670;&#160;</a></span>_check_is_permutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._check_is_permutation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check whether indices is a reordering of the array np.arange(n_samples)

Parameters
----------
indices : ndarray
    int array to test
n_samples : int
    number of expected elements

Returns
-------
is_partition : bool
    True iff sorted(indices) is np.arange(n)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1145</span><span class="keyword">def </span>_check_is_permutation(indices, n_samples):</div>
<div class="line"><span class="lineno"> 1146</span>    <span class="stringliteral">&quot;&quot;&quot;Check whether indices is a reordering of the array np.arange(n_samples)</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    indices : ndarray</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">        int array to test</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    n_samples : int</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">        number of expected elements</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    is_partition : bool</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">        True iff sorted(indices) is np.arange(n)</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1160</span>    <span class="keywordflow">if</span> len(indices) != n_samples:</div>
<div class="line"><span class="lineno"> 1161</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1162</span>    hit = np.zeros(n_samples, dtype=bool)</div>
<div class="line"><span class="lineno"> 1163</span>    hit[indices] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1164</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.all(hit):</div>
<div class="line"><span class="lineno"> 1165</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1166</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1167</span> </div>
<div class="line"><span class="lineno"> 1168</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4dad997de888c9b75367c1811edde5f" name="ab4dad997de888c9b75367c1811edde5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4dad997de888c9b75367c1811edde5f">&#9670;&#160;</a></span>_enforce_prediction_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._enforce_prediction_order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure that prediction arrays have correct column order

When doing cross-validation, if one or more classes are
not present in the subset of data used for training,
then the output prediction array might not have the same
columns as other folds. Use the list of class names
(assumed to be ints) to enforce the correct column order.

Note that `classes` is the list of classes in this fold
(a subset of the classes in the full training set)
and `n_classes` is the number of classes in the full training set.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1079</span><span class="keyword">def </span>_enforce_prediction_order(classes, predictions, n_classes, method):</div>
<div class="line"><span class="lineno"> 1080</span>    <span class="stringliteral">&quot;&quot;&quot;Ensure that prediction arrays have correct column order</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    When doing cross-validation, if one or more classes are</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">    not present in the subset of data used for training,</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    then the output prediction array might not have the same</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">    columns as other folds. Use the list of class names</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    (assumed to be ints) to enforce the correct column order.</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">    Note that `classes` is the list of classes in this fold</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    (a subset of the classes in the full training set)</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    and `n_classes` is the number of classes in the full training set.</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1092</span>    <span class="keywordflow">if</span> n_classes != len(classes):</div>
<div class="line"><span class="lineno"> 1093</span>        recommendation = (</div>
<div class="line"><span class="lineno"> 1094</span>            <span class="stringliteral">&quot;To fix this, use a cross-validation &quot;</span></div>
<div class="line"><span class="lineno"> 1095</span>            <span class="stringliteral">&quot;technique resulting in properly &quot;</span></div>
<div class="line"><span class="lineno"> 1096</span>            <span class="stringliteral">&quot;stratified folds&quot;</span></div>
<div class="line"><span class="lineno"> 1097</span>        )</div>
<div class="line"><span class="lineno"> 1098</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1099</span>            <span class="stringliteral">&quot;Number of classes in training fold ({}) does &quot;</span></div>
<div class="line"><span class="lineno"> 1100</span>            <span class="stringliteral">&quot;not match total number of classes ({}). &quot;</span></div>
<div class="line"><span class="lineno"> 1101</span>            <span class="stringliteral">&quot;Results may not be appropriate for your use case. &quot;</span></div>
<div class="line"><span class="lineno"> 1102</span>            <span class="stringliteral">&quot;{}&quot;</span>.format(len(classes), n_classes, recommendation),</div>
<div class="line"><span class="lineno"> 1103</span>            RuntimeWarning,</div>
<div class="line"><span class="lineno"> 1104</span>        )</div>
<div class="line"><span class="lineno"> 1105</span>        <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;decision_function&quot;</span>:</div>
<div class="line"><span class="lineno"> 1106</span>            <span class="keywordflow">if</span> predictions.ndim == 2 <span class="keywordflow">and</span> predictions.shape[1] != len(classes):</div>
<div class="line"><span class="lineno"> 1107</span>                <span class="comment"># This handles the case when the shape of predictions</span></div>
<div class="line"><span class="lineno"> 1108</span>                <span class="comment"># does not match the number of classes used to train</span></div>
<div class="line"><span class="lineno"> 1109</span>                <span class="comment"># it with. This case is found when sklearn.svm.SVC is</span></div>
<div class="line"><span class="lineno"> 1110</span>                <span class="comment"># set to `decision_function_shape=&#39;ovo&#39;`.</span></div>
<div class="line"><span class="lineno"> 1111</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1112</span>                    <span class="stringliteral">&quot;Output shape {} of {} does not match &quot;</span></div>
<div class="line"><span class="lineno"> 1113</span>                    <span class="stringliteral">&quot;number of classes ({}) in fold. &quot;</span></div>
<div class="line"><span class="lineno"> 1114</span>                    <span class="stringliteral">&quot;Irregular decision_function outputs &quot;</span></div>
<div class="line"><span class="lineno"> 1115</span>                    <span class="stringliteral">&quot;are not currently supported by &quot;</span></div>
<div class="line"><span class="lineno"> 1116</span>                    <span class="stringliteral">&quot;cross_val_predict&quot;</span>.format(predictions.shape, method, len(classes))</div>
<div class="line"><span class="lineno"> 1117</span>                )</div>
<div class="line"><span class="lineno"> 1118</span>            <span class="keywordflow">if</span> len(classes) &lt;= 2:</div>
<div class="line"><span class="lineno"> 1119</span>                <span class="comment"># In this special case, `predictions` contains a 1D array.</span></div>
<div class="line"><span class="lineno"> 1120</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1121</span>                    <span class="stringliteral">&quot;Only {} class/es in training fold, but {} &quot;</span></div>
<div class="line"><span class="lineno"> 1122</span>                    <span class="stringliteral">&quot;in overall dataset. This &quot;</span></div>
<div class="line"><span class="lineno"> 1123</span>                    <span class="stringliteral">&quot;is not supported for decision_function &quot;</span></div>
<div class="line"><span class="lineno"> 1124</span>                    <span class="stringliteral">&quot;with imbalanced folds. {}&quot;</span>.format(</div>
<div class="line"><span class="lineno"> 1125</span>                        len(classes), n_classes, recommendation</div>
<div class="line"><span class="lineno"> 1126</span>                    )</div>
<div class="line"><span class="lineno"> 1127</span>                )</div>
<div class="line"><span class="lineno"> 1128</span> </div>
<div class="line"><span class="lineno"> 1129</span>        float_min = np.finfo(predictions.dtype).min</div>
<div class="line"><span class="lineno"> 1130</span>        default_values = {</div>
<div class="line"><span class="lineno"> 1131</span>            <span class="stringliteral">&quot;decision_function&quot;</span>: float_min,</div>
<div class="line"><span class="lineno"> 1132</span>            <span class="stringliteral">&quot;predict_log_proba&quot;</span>: float_min,</div>
<div class="line"><span class="lineno"> 1133</span>            <span class="stringliteral">&quot;predict_proba&quot;</span>: 0,</div>
<div class="line"><span class="lineno"> 1134</span>        }</div>
<div class="line"><span class="lineno"> 1135</span>        predictions_for_all_classes = np.full(</div>
<div class="line"><span class="lineno"> 1136</span>            (_num_samples(predictions), n_classes),</div>
<div class="line"><span class="lineno"> 1137</span>            default_values[method],</div>
<div class="line"><span class="lineno"> 1138</span>            dtype=predictions.dtype,</div>
<div class="line"><span class="lineno"> 1139</span>        )</div>
<div class="line"><span class="lineno"> 1140</span>        predictions_for_all_classes[:, classes] = predictions</div>
<div class="line"><span class="lineno"> 1141</span>        predictions = predictions_for_all_classes</div>
<div class="line"><span class="lineno"> 1142</span>    <span class="keywordflow">return</span> predictions</div>
<div class="line"><span class="lineno"> 1143</span> </div>
<div class="line"><span class="lineno"> 1144</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad185f0bd5f58abe88a188a2934ff5c86" name="ad185f0bd5f58abe88a188a2934ff5c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad185f0bd5f58abe88a188a2934ff5c86">&#9670;&#160;</a></span>_fit_and_predict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._fit_and_predict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>train</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Fit estimator and predict values for a given dataset split.

Read more in the :ref:`User Guide &lt;cross_validation&gt;`.

Parameters
----------
estimator : estimator object implementing 'fit' and 'predict'
    The object to use to fit the data.

X : array-like of shape (n_samples, n_features)
    The data to fit.

    .. versionchanged:: 0.20
        X is only required to be an object with finite length or shape now

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    The target variable to try to predict in the case of
    supervised learning.

train : array-like of shape (n_train_samples,)
    Indices of training samples.

test : array-like of shape (n_test_samples,)
    Indices of test samples.

verbose : int
    The verbosity level.

fit_params : dict or None
    Parameters that will be passed to ``estimator.fit``.

method : str
    Invokes the passed method name of the passed estimator.

Returns
-------
predictions : sequence
    Result of calling 'estimator.method'
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1000</span><span class="keyword">def </span>_fit_and_predict(estimator, X, y, train, test, verbose, fit_params, method):</div>
<div class="line"><span class="lineno"> 1001</span>    <span class="stringliteral">&quot;&quot;&quot;Fit estimator and predict values for a given dataset split.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;cross_validation&gt;`.</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    estimator : estimator object implementing &#39;fit&#39; and &#39;predict&#39;</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">        The object to use to fit the data.</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">        The data to fit.</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">        .. versionchanged:: 0.20</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">            X is only required to be an object with finite length or shape now</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        The target variable to try to predict in the case of</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">        supervised learning.</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    train : array-like of shape (n_train_samples,)</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">        Indices of training samples.</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    test : array-like of shape (n_test_samples,)</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">        Indices of test samples.</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    verbose : int</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">        The verbosity level.</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    fit_params : dict or None</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">        Parameters that will be passed to ``estimator.fit``.</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    method : str</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">        Invokes the passed method name of the passed estimator.</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    predictions : sequence</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">        Result of calling &#39;estimator.method&#39;</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1040</span>    <span class="comment"># Adjust length of sample weights</span></div>
<div class="line"><span class="lineno"> 1041</span>    fit_params = fit_params <span class="keywordflow">if</span> fit_params <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> {}</div>
<div class="line"><span class="lineno"> 1042</span>    fit_params = _check_fit_params(X, fit_params, train)</div>
<div class="line"><span class="lineno"> 1043</span> </div>
<div class="line"><span class="lineno"> 1044</span>    X_train, y_train = _safe_split(estimator, X, y, train)</div>
<div class="line"><span class="lineno"> 1045</span>    X_test, _ = _safe_split(estimator, X, y, test, train)</div>
<div class="line"><span class="lineno"> 1046</span> </div>
<div class="line"><span class="lineno"> 1047</span>    <span class="keywordflow">if</span> y_train <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1048</span>        estimator.fit(X_train, **fit_params)</div>
<div class="line"><span class="lineno"> 1049</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1050</span>        estimator.fit(X_train, y_train, **fit_params)</div>
<div class="line"><span class="lineno"> 1051</span>    func = getattr(estimator, method)</div>
<div class="line"><span class="lineno"> 1052</span>    predictions = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(X_test)</div>
<div class="line"><span class="lineno"> 1053</span> </div>
<div class="line"><span class="lineno"> 1054</span>    encode = (</div>
<div class="line"><span class="lineno"> 1055</span>        method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;decision_function&quot;</span>, <span class="stringliteral">&quot;predict_proba&quot;</span>, <span class="stringliteral">&quot;predict_log_proba&quot;</span>]</div>
<div class="line"><span class="lineno"> 1056</span>        <span class="keywordflow">and</span> y <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1057</span>    )</div>
<div class="line"><span class="lineno"> 1058</span> </div>
<div class="line"><span class="lineno"> 1059</span>    <span class="keywordflow">if</span> encode:</div>
<div class="line"><span class="lineno"> 1060</span>        <span class="keywordflow">if</span> isinstance(predictions, list):</div>
<div class="line"><span class="lineno"> 1061</span>            predictions = [</div>
<div class="line"><span class="lineno"> 1062</span>                _enforce_prediction_order(</div>
<div class="line"><span class="lineno"> 1063</span>                    estimator.classes_[i_label],</div>
<div class="line"><span class="lineno"> 1064</span>                    predictions[i_label],</div>
<div class="line"><span class="lineno"> 1065</span>                    n_classes=len(set(y[:, i_label])),</div>
<div class="line"><span class="lineno"> 1066</span>                    method=method,</div>
<div class="line"><span class="lineno"> 1067</span>                )</div>
<div class="line"><span class="lineno"> 1068</span>                <span class="keywordflow">for</span> i_label <span class="keywordflow">in</span> range(len(predictions))</div>
<div class="line"><span class="lineno"> 1069</span>            ]</div>
<div class="line"><span class="lineno"> 1070</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1071</span>            <span class="comment"># A 2D y array should be a binary label indicator matrix</span></div>
<div class="line"><span class="lineno"> 1072</span>            n_classes = len(set(y)) <span class="keywordflow">if</span> y.ndim == 1 <span class="keywordflow">else</span> y.shape[1]</div>
<div class="line"><span class="lineno"> 1073</span>            predictions = _enforce_prediction_order(</div>
<div class="line"><span class="lineno"> 1074</span>                estimator.classes_, predictions, n_classes, method</div>
<div class="line"><span class="lineno"> 1075</span>            )</div>
<div class="line"><span class="lineno"> 1076</span>    <span class="keywordflow">return</span> predictions</div>
<div class="line"><span class="lineno"> 1077</span> </div>
<div class="line"><span class="lineno"> 1078</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a88729dece2b104fb07abc76766ecb988" name="a88729dece2b104fb07abc76766ecb988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88729dece2b104fb07abc76766ecb988">&#9670;&#160;</a></span>_fit_and_score()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._fit_and_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scorer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>train</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_train_score</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_parameters</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_n_test_samples</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_times</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_estimator</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>split_progress</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>candidate_progress</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em> = <code>np.nan</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Fit estimator and compute scores for a given dataset split.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : array-like of shape (n_samples, n_features)
    The data to fit.

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    The target variable to try to predict in the case of
    supervised learning.

scorer : A single callable or dict mapping scorer name to the callable
    If it is a single callable, the return value for ``train_scores`` and
    ``test_scores`` is a single float.

    For a dict, it should be one mapping the scorer name to the scorer
    callable object / function.

    The callable object / fn should have signature
    ``scorer(estimator, X, y)``.

train : array-like of shape (n_train_samples,)
    Indices of training samples.

test : array-like of shape (n_test_samples,)
    Indices of test samples.

verbose : int
    The verbosity level.

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

parameters : dict or None
    Parameters to be set on the estimator.

fit_params : dict or None
    Parameters that will be passed to ``estimator.fit``.

return_train_score : bool, default=False
    Compute and return score on training set.

return_parameters : bool, default=False
    Return parameters that has been used for the estimator.

split_progress : {list, tuple} of int, default=None
    A list or tuple of format (&lt;current_split_id&gt;, &lt;total_num_of_splits&gt;).

candidate_progress : {list, tuple} of int, default=None
    A list or tuple of format
    (&lt;current_candidate_id&gt;, &lt;total_number_of_candidates&gt;).

return_n_test_samples : bool, default=False
    Whether to return the ``n_test_samples``.

return_times : bool, default=False
    Whether to return the fit/score times.

return_estimator : bool, default=False
    Whether to return the fitted estimator.

Returns
-------
result : dict with the following attributes
    train_scores : dict of scorer name -&gt; float
        Score on training set (for all the scorers),
        returned only if `return_train_score` is `True`.
    test_scores : dict of scorer name -&gt; float
        Score on testing set (for all the scorers).
    n_test_samples : int
        Number of test samples.
    fit_time : float
        Time spent for fitting in seconds.
    score_time : float
        Time spent for scoring in seconds.
    parameters : dict or None
        The parameters that have been evaluated.
    estimator : estimator object
        The fitted estimator.
    fit_error : str or None
        Traceback str if the fit failed, None if the fit succeeded.
</pre> <div class="fragment"><div class="line"><span class="lineno">  549</span>):</div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>    <span class="stringliteral">&quot;&quot;&quot;Fit estimator and compute scores for a given dataset split.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    estimator : estimator object implementing &#39;fit&#39;</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">        The object to use to fit the data.</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        The data to fit.</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">        The target variable to try to predict in the case of</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">        supervised learning.</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    scorer : A single callable or dict mapping scorer name to the callable</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">        If it is a single callable, the return value for ``train_scores`` and</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        ``test_scores`` is a single float.</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        For a dict, it should be one mapping the scorer name to the scorer</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        callable object / function.</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        The callable object / fn should have signature</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        ``scorer(estimator, X, y)``.</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    train : array-like of shape (n_train_samples,)</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        Indices of training samples.</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    test : array-like of shape (n_test_samples,)</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        Indices of test samples.</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    verbose : int</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        The verbosity level.</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    error_score : &#39;raise&#39; or numeric, default=np.nan</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        Value to assign to the score if an error occurs in estimator fitting.</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        If set to &#39;raise&#39;, the error is raised.</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        If a numeric value is given, FitFailedWarning is raised.</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    parameters : dict or None</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">        Parameters to be set on the estimator.</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    fit_params : dict or None</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        Parameters that will be passed to ``estimator.fit``.</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    return_train_score : bool, default=False</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        Compute and return score on training set.</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    return_parameters : bool, default=False</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        Return parameters that has been used for the estimator.</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    split_progress : {list, tuple} of int, default=None</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        A list or tuple of format (&lt;current_split_id&gt;, &lt;total_num_of_splits&gt;).</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    candidate_progress : {list, tuple} of int, default=None</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        A list or tuple of format</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        (&lt;current_candidate_id&gt;, &lt;total_number_of_candidates&gt;).</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    return_n_test_samples : bool, default=False</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">        Whether to return the ``n_test_samples``.</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    return_times : bool, default=False</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">        Whether to return the fit/score times.</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    return_estimator : bool, default=False</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        Whether to return the fitted estimator.</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    result : dict with the following attributes</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">        train_scores : dict of scorer name -&gt; float</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">            Score on training set (for all the scorers),</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">            returned only if `return_train_score` is `True`.</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">        test_scores : dict of scorer name -&gt; float</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">            Score on testing set (for all the scorers).</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        n_test_samples : int</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">            Number of test samples.</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">        fit_time : float</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">            Time spent for fitting in seconds.</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">        score_time : float</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">            Time spent for scoring in seconds.</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        parameters : dict or None</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">            The parameters that have been evaluated.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">        estimator : estimator object</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">            The fitted estimator.</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">        fit_error : str or None</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">            Traceback str if the fit failed, None if the fit succeeded.</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  638</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(error_score, numbers.Number) <span class="keywordflow">and</span> error_score != <span class="stringliteral">&quot;raise&quot;</span>:</div>
<div class="line"><span class="lineno">  639</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  640</span>            <span class="stringliteral">&quot;error_score must be the string &#39;raise&#39; or a numeric value. &quot;</span></div>
<div class="line"><span class="lineno">  641</span>            <span class="stringliteral">&quot;(Hint: if using &#39;raise&#39;, please make sure that it has been &quot;</span></div>
<div class="line"><span class="lineno">  642</span>            <span class="stringliteral">&quot;spelled correctly.)&quot;</span></div>
<div class="line"><span class="lineno">  643</span>        )</div>
<div class="line"><span class="lineno">  644</span> </div>
<div class="line"><span class="lineno">  645</span>    progress_msg = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  646</span>    <span class="keywordflow">if</span> verbose &gt; 2:</div>
<div class="line"><span class="lineno">  647</span>        <span class="keywordflow">if</span> split_progress <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  648</span>            progress_msg = f<span class="stringliteral">&quot; {split_progress[0]+1}/{split_progress[1]}&quot;</span></div>
<div class="line"><span class="lineno">  649</span>        <span class="keywordflow">if</span> candidate_progress <span class="keywordflow">and</span> verbose &gt; 9:</div>
<div class="line"><span class="lineno">  650</span>            progress_msg += f<span class="stringliteral">&quot;; {candidate_progress[0]+1}/{candidate_progress[1]}&quot;</span></div>
<div class="line"><span class="lineno">  651</span> </div>
<div class="line"><span class="lineno">  652</span>    <span class="keywordflow">if</span> verbose &gt; 1:</div>
<div class="line"><span class="lineno">  653</span>        <span class="keywordflow">if</span> parameters <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  654</span>            params_msg = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  655</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  656</span>            sorted_keys = sorted(parameters)  <span class="comment"># Ensure deterministic o/p</span></div>
<div class="line"><span class="lineno">  657</span>            params_msg = <span class="stringliteral">&quot;, &quot;</span>.join(f<span class="stringliteral">&quot;{k}={parameters[k]}&quot;</span> <span class="keywordflow">for</span> k <span class="keywordflow">in</span> sorted_keys)</div>
<div class="line"><span class="lineno">  658</span>    <span class="keywordflow">if</span> verbose &gt; 9:</div>
<div class="line"><span class="lineno">  659</span>        start_msg = f<span class="stringliteral">&quot;[CV{progress_msg}] START {params_msg}&quot;</span></div>
<div class="line"><span class="lineno">  660</span>        print(f<span class="stringliteral">&quot;{start_msg}{(80 - len(start_msg)) * &#39;.&#39;}&quot;</span>)</div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span>    <span class="comment"># Adjust length of sample weights</span></div>
<div class="line"><span class="lineno">  663</span>    fit_params = fit_params <span class="keywordflow">if</span> fit_params <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> {}</div>
<div class="line"><span class="lineno">  664</span>    fit_params = _check_fit_params(X, fit_params, train)</div>
<div class="line"><span class="lineno">  665</span> </div>
<div class="line"><span class="lineno">  666</span>    <span class="keywordflow">if</span> parameters <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  667</span>        <span class="comment"># clone after setting parameters in case any parameters</span></div>
<div class="line"><span class="lineno">  668</span>        <span class="comment"># are estimators (like pipeline steps)</span></div>
<div class="line"><span class="lineno">  669</span>        <span class="comment"># because pipeline doesn&#39;t clone steps in fit</span></div>
<div class="line"><span class="lineno">  670</span>        cloned_parameters = {}</div>
<div class="line"><span class="lineno">  671</span>        <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> parameters.items():</div>
<div class="line"><span class="lineno">  672</span>            cloned_parameters[k] = clone(v, safe=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  673</span> </div>
<div class="line"><span class="lineno">  674</span>        estimator = estimator.set_params(**cloned_parameters)</div>
<div class="line"><span class="lineno">  675</span> </div>
<div class="line"><span class="lineno">  676</span>    start_time = time.time()</div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span>    X_train, y_train = _safe_split(estimator, X, y, train)</div>
<div class="line"><span class="lineno">  679</span>    X_test, y_test = _safe_split(estimator, X, y, test, train)</div>
<div class="line"><span class="lineno">  680</span> </div>
<div class="line"><span class="lineno">  681</span>    result = {}</div>
<div class="line"><span class="lineno">  682</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  683</span>        <span class="keywordflow">if</span> y_train <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  684</span>            estimator.fit(X_train, **fit_params)</div>
<div class="line"><span class="lineno">  685</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  686</span>            estimator.fit(X_train, y_train, **fit_params)</div>
<div class="line"><span class="lineno">  687</span> </div>
<div class="line"><span class="lineno">  688</span>    <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  689</span>        <span class="comment"># Note fit time as time until error</span></div>
<div class="line"><span class="lineno">  690</span>        fit_time = time.time() - start_time</div>
<div class="line"><span class="lineno">  691</span>        score_time = 0.0</div>
<div class="line"><span class="lineno">  692</span>        <span class="keywordflow">if</span> error_score == <span class="stringliteral">&quot;raise&quot;</span>:</div>
<div class="line"><span class="lineno">  693</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  694</span>        <span class="keywordflow">elif</span> isinstance(error_score, numbers.Number):</div>
<div class="line"><span class="lineno">  695</span>            <span class="keywordflow">if</span> isinstance(scorer, dict):</div>
<div class="line"><span class="lineno">  696</span>                test_scores = {name: error_score <span class="keywordflow">for</span> name <span class="keywordflow">in</span> scorer}</div>
<div class="line"><span class="lineno">  697</span>                <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  698</span>                    train_scores = test_scores.copy()</div>
<div class="line"><span class="lineno">  699</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  700</span>                test_scores = error_score</div>
<div class="line"><span class="lineno">  701</span>                <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  702</span>                    train_scores = error_score</div>
<div class="line"><span class="lineno">  703</span>        result[<span class="stringliteral">&quot;fit_error&quot;</span>] = format_exc()</div>
<div class="line"><span class="lineno">  704</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  705</span>        result[<span class="stringliteral">&quot;fit_error&quot;</span>] = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  706</span> </div>
<div class="line"><span class="lineno">  707</span>        fit_time = time.time() - start_time</div>
<div class="line"><span class="lineno">  708</span>        test_scores = _score(estimator, X_test, y_test, scorer, error_score)</div>
<div class="line"><span class="lineno">  709</span>        score_time = time.time() - start_time - fit_time</div>
<div class="line"><span class="lineno">  710</span>        <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  711</span>            train_scores = _score(estimator, X_train, y_train, scorer, error_score)</div>
<div class="line"><span class="lineno">  712</span> </div>
<div class="line"><span class="lineno">  713</span>    <span class="keywordflow">if</span> verbose &gt; 1:</div>
<div class="line"><span class="lineno">  714</span>        total_time = score_time + fit_time</div>
<div class="line"><span class="lineno">  715</span>        end_msg = f<span class="stringliteral">&quot;[CV{progress_msg}] END &quot;</span></div>
<div class="line"><span class="lineno">  716</span>        result_msg = params_msg + (<span class="stringliteral">&quot;;&quot;</span> <span class="keywordflow">if</span> params_msg <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  717</span>        <span class="keywordflow">if</span> verbose &gt; 2:</div>
<div class="line"><span class="lineno">  718</span>            <span class="keywordflow">if</span> isinstance(test_scores, dict):</div>
<div class="line"><span class="lineno">  719</span>                <span class="keywordflow">for</span> scorer_name <span class="keywordflow">in</span> sorted(test_scores):</div>
<div class="line"><span class="lineno">  720</span>                    result_msg += f<span class="stringliteral">&quot; {scorer_name}: (&quot;</span></div>
<div class="line"><span class="lineno">  721</span>                    <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  722</span>                        scorer_scores = train_scores[scorer_name]</div>
<div class="line"><span class="lineno">  723</span>                        result_msg += f<span class="stringliteral">&quot;train={scorer_scores:.3f}, &quot;</span></div>
<div class="line"><span class="lineno">  724</span>                    result_msg += f<span class="stringliteral">&quot;test={test_scores[scorer_name]:.3f})&quot;</span></div>
<div class="line"><span class="lineno">  725</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  726</span>                result_msg += <span class="stringliteral">&quot;, score=&quot;</span></div>
<div class="line"><span class="lineno">  727</span>                <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  728</span>                    result_msg += f<span class="stringliteral">&quot;(train={train_scores:.3f}, test={test_scores:.3f})&quot;</span></div>
<div class="line"><span class="lineno">  729</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  730</span>                    result_msg += f<span class="stringliteral">&quot;{test_scores:.3f}&quot;</span></div>
<div class="line"><span class="lineno">  731</span>        result_msg += f<span class="stringliteral">&quot; total time={logger.short_format_time(total_time)}&quot;</span></div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="line"><span class="lineno">  733</span>        <span class="comment"># Right align the result_msg</span></div>
<div class="line"><span class="lineno">  734</span>        end_msg += <span class="stringliteral">&quot;.&quot;</span> * (80 - len(end_msg) - len(result_msg))</div>
<div class="line"><span class="lineno">  735</span>        end_msg += result_msg</div>
<div class="line"><span class="lineno">  736</span>        print(end_msg)</div>
<div class="line"><span class="lineno">  737</span> </div>
<div class="line"><span class="lineno">  738</span>    result[<span class="stringliteral">&quot;test_scores&quot;</span>] = test_scores</div>
<div class="line"><span class="lineno">  739</span>    <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  740</span>        result[<span class="stringliteral">&quot;train_scores&quot;</span>] = train_scores</div>
<div class="line"><span class="lineno">  741</span>    <span class="keywordflow">if</span> return_n_test_samples:</div>
<div class="line"><span class="lineno">  742</span>        result[<span class="stringliteral">&quot;n_test_samples&quot;</span>] = _num_samples(X_test)</div>
<div class="line"><span class="lineno">  743</span>    <span class="keywordflow">if</span> return_times:</div>
<div class="line"><span class="lineno">  744</span>        result[<span class="stringliteral">&quot;fit_time&quot;</span>] = fit_time</div>
<div class="line"><span class="lineno">  745</span>        result[<span class="stringliteral">&quot;score_time&quot;</span>] = score_time</div>
<div class="line"><span class="lineno">  746</span>    <span class="keywordflow">if</span> return_parameters:</div>
<div class="line"><span class="lineno">  747</span>        result[<span class="stringliteral">&quot;parameters&quot;</span>] = parameters</div>
<div class="line"><span class="lineno">  748</span>    <span class="keywordflow">if</span> return_estimator:</div>
<div class="line"><span class="lineno">  749</span>        result[<span class="stringliteral">&quot;estimator&quot;</span>] = estimator</div>
<div class="line"><span class="lineno">  750</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  751</span> </div>
<div class="line"><span class="lineno">  752</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af10a0b1fc7555f4e723522194f5700ae" name="af10a0b1fc7555f4e723522194f5700ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10a0b1fc7555f4e723522194f5700ae">&#9670;&#160;</a></span>_incremental_fit_estimator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._incremental_fit_estimator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>train</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>train_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scorer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Train estimator on training subsets incrementally and compute scores.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1695</span>):</div>
<div class="line"><span class="lineno"> 1696</span>    <span class="stringliteral">&quot;&quot;&quot;Train estimator on training subsets incrementally and compute scores.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1697</span>    train_scores, test_scores, fit_times, score_times = [], [], [], []</div>
<div class="line"><span class="lineno"> 1698</span>    partitions = zip(train_sizes, np.split(train, train_sizes)[:-1])</div>
<div class="line"><span class="lineno"> 1699</span>    <span class="keywordflow">if</span> fit_params <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1700</span>        fit_params = {}</div>
<div class="line"><span class="lineno"> 1701</span>    <span class="keywordflow">if</span> classes <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1702</span>        partial_fit_func = partial(estimator.partial_fit, **fit_params)</div>
<div class="line"><span class="lineno"> 1703</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1704</span>        partial_fit_func = partial(estimator.partial_fit, classes=classes, **fit_params)</div>
<div class="line"><span class="lineno"> 1705</span> </div>
<div class="line"><span class="lineno"> 1706</span>    <span class="keywordflow">for</span> n_train_samples, partial_train <span class="keywordflow">in</span> partitions:</div>
<div class="line"><span class="lineno"> 1707</span>        train_subset = train[:n_train_samples]</div>
<div class="line"><span class="lineno"> 1708</span>        X_train, y_train = _safe_split(estimator, X, y, train_subset)</div>
<div class="line"><span class="lineno"> 1709</span>        X_partial_train, y_partial_train = _safe_split(estimator, X, y, partial_train)</div>
<div class="line"><span class="lineno"> 1710</span>        X_test, y_test = _safe_split(estimator, X, y, test, train_subset)</div>
<div class="line"><span class="lineno"> 1711</span>        start_fit = time.time()</div>
<div class="line"><span class="lineno"> 1712</span>        <span class="keywordflow">if</span> y_partial_train <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1713</span>            partial_fit_func(X_partial_train)</div>
<div class="line"><span class="lineno"> 1714</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1715</span>            partial_fit_func(X_partial_train, y_partial_train)</div>
<div class="line"><span class="lineno"> 1716</span>        fit_time = time.time() - start_fit</div>
<div class="line"><span class="lineno"> 1717</span>        fit_times.append(fit_time)</div>
<div class="line"><span class="lineno"> 1718</span> </div>
<div class="line"><span class="lineno"> 1719</span>        start_score = time.time()</div>
<div class="line"><span class="lineno"> 1720</span> </div>
<div class="line"><span class="lineno"> 1721</span>        test_scores.append(_score(estimator, X_test, y_test, scorer, error_score))</div>
<div class="line"><span class="lineno"> 1722</span>        train_scores.append(_score(estimator, X_train, y_train, scorer, error_score))</div>
<div class="line"><span class="lineno"> 1723</span> </div>
<div class="line"><span class="lineno"> 1724</span>        score_time = time.time() - start_score</div>
<div class="line"><span class="lineno"> 1725</span>        score_times.append(score_time)</div>
<div class="line"><span class="lineno"> 1726</span> </div>
<div class="line"><span class="lineno"> 1727</span>    ret = (</div>
<div class="line"><span class="lineno"> 1728</span>        (train_scores, test_scores, fit_times, score_times)</div>
<div class="line"><span class="lineno"> 1729</span>        <span class="keywordflow">if</span> return_times</div>
<div class="line"><span class="lineno"> 1730</span>        <span class="keywordflow">else</span> (train_scores, test_scores)</div>
<div class="line"><span class="lineno"> 1731</span>    )</div>
<div class="line"><span class="lineno"> 1732</span> </div>
<div class="line"><span class="lineno"> 1733</span>    <span class="keywordflow">return</span> np.array(ret).T</div>
<div class="line"><span class="lineno"> 1734</span> </div>
<div class="line"><span class="lineno"> 1735</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afb095e3fc436fbe882f7d5f58dea3777" name="afb095e3fc436fbe882f7d5f58dea3777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb095e3fc436fbe882f7d5f58dea3777">&#9670;&#160;</a></span>_insert_error_scores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._insert_error_scores </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Insert error in `results` by replacing them inplace with `error_score`.

This only applies to multimetric scores because `_fit_and_score` will
handle the single metric case.
</pre> <div class="fragment"><div class="line"><span class="lineno">  315</span><span class="keyword">def </span>_insert_error_scores(results, error_score):</div>
<div class="line"><span class="lineno">  316</span>    <span class="stringliteral">&quot;&quot;&quot;Insert error in `results` by replacing them inplace with `error_score`.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    This only applies to multimetric scores because `_fit_and_score` will</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    handle the single metric case.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  321</span>    successful_score = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  322</span>    failed_indices = []</div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">for</span> i, result <span class="keywordflow">in</span> enumerate(results):</div>
<div class="line"><span class="lineno">  324</span>        <span class="keywordflow">if</span> result[<span class="stringliteral">&quot;fit_error&quot;</span>] <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  325</span>            failed_indices.append(i)</div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordflow">elif</span> successful_score <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  327</span>            successful_score = result[<span class="stringliteral">&quot;test_scores&quot;</span>]</div>
<div class="line"><span class="lineno">  328</span> </div>
<div class="line"><span class="lineno">  329</span>    <span class="keywordflow">if</span> isinstance(successful_score, dict):</div>
<div class="line"><span class="lineno">  330</span>        formatted_error = {name: error_score <span class="keywordflow">for</span> name <span class="keywordflow">in</span> successful_score}</div>
<div class="line"><span class="lineno">  331</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> failed_indices:</div>
<div class="line"><span class="lineno">  332</span>            results[i][<span class="stringliteral">&quot;test_scores&quot;</span>] = formatted_error.copy()</div>
<div class="line"><span class="lineno">  333</span>            <span class="keywordflow">if</span> <span class="stringliteral">&quot;train_scores&quot;</span> <span class="keywordflow">in</span> results[i]:</div>
<div class="line"><span class="lineno">  334</span>                results[i][<span class="stringliteral">&quot;train_scores&quot;</span>] = formatted_error.copy()</div>
<div class="line"><span class="lineno">  335</span> </div>
<div class="line"><span class="lineno">  336</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6b53705a88d7217c3361b4463b272f2" name="ac6b53705a88d7217c3361b4463b272f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b53705a88d7217c3361b4463b272f2">&#9670;&#160;</a></span>_normalize_score_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._normalize_score_results </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scaler_score_key</em> = <code>&quot;score&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Creates a scoring dictionary based on the type of `scores`</pre> <div class="fragment"><div class="line"><span class="lineno">  337</span><span class="keyword">def </span>_normalize_score_results(scores, scaler_score_key=&quot;score&quot;):</div>
<div class="line"><span class="lineno">  338</span>    <span class="stringliteral">&quot;&quot;&quot;Creates a scoring dictionary based on the type of `scores`&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  339</span>    <span class="keywordflow">if</span> isinstance(scores[0], dict):</div>
<div class="line"><span class="lineno">  340</span>        <span class="comment"># multimetric scoring</span></div>
<div class="line"><span class="lineno">  341</span>        <span class="keywordflow">return</span> _aggregate_score_dicts(scores)</div>
<div class="line"><span class="lineno">  342</span>    <span class="comment"># scaler</span></div>
<div class="line"><span class="lineno">  343</span>    <span class="keywordflow">return</span> {scaler_score_key: scores}</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e89c59a15e73159abda6d3b1231d396" name="a7e89c59a15e73159abda6d3b1231d396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e89c59a15e73159abda6d3b1231d396">&#9670;&#160;</a></span>_permutation_test_score()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._permutation_test_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scorer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Auxiliary function for permutation_test_score</pre> <div class="fragment"><div class="line"><span class="lineno"> 1324</span><span class="keyword">def </span>_permutation_test_score(estimator, X, y, groups, cv, scorer, fit_params):</div>
<div class="line"><span class="lineno"> 1325</span>    <span class="stringliteral">&quot;&quot;&quot;Auxiliary function for permutation_test_score&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1326</span>    <span class="comment"># Adjust length of sample weights</span></div>
<div class="line"><span class="lineno"> 1327</span>    fit_params = fit_params <span class="keywordflow">if</span> fit_params <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> {}</div>
<div class="line"><span class="lineno"> 1328</span>    avg_score = []</div>
<div class="line"><span class="lineno"> 1329</span>    <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> cv.split(X, y, groups):</div>
<div class="line"><span class="lineno"> 1330</span>        X_train, y_train = _safe_split(estimator, X, y, train)</div>
<div class="line"><span class="lineno"> 1331</span>        X_test, y_test = _safe_split(estimator, X, y, test, train)</div>
<div class="line"><span class="lineno"> 1332</span>        fit_params = _check_fit_params(X, fit_params, train)</div>
<div class="line"><span class="lineno"> 1333</span>        estimator.fit(X_train, y_train, **fit_params)</div>
<div class="line"><span class="lineno"> 1334</span>        avg_score.append(scorer(estimator, X_test, y_test))</div>
<div class="line"><span class="lineno"> 1335</span>    <span class="keywordflow">return</span> np.mean(avg_score)</div>
<div class="line"><span class="lineno"> 1336</span> </div>
<div class="line"><span class="lineno"> 1337</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adfcfbf8bfae37e3a0d59fadf3b348edf" name="adfcfbf8bfae37e3a0d59fadf3b348edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcfbf8bfae37e3a0d59fadf3b348edf">&#9670;&#160;</a></span>_score()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scorer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em> = <code>&quot;raise&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the score(s) of an estimator on a given test set.

Will return a dict of floats if `scorer` is a dict, otherwise a single
float is returned.
</pre> <div class="fragment"><div class="line"><span class="lineno">  753</span><span class="keyword">def </span>_score(estimator, X_test, y_test, scorer, error_score=&quot;raise&quot;):</div>
<div class="line"><span class="lineno">  754</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the score(s) of an estimator on a given test set.</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    Will return a dict of floats if `scorer` is a dict, otherwise a single</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    float is returned.</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  759</span>    <span class="keywordflow">if</span> isinstance(scorer, dict):</div>
<div class="line"><span class="lineno">  760</span>        <span class="comment"># will cache method calls if needed. scorer() returns a dict</span></div>
<div class="line"><span class="lineno">  761</span>        scorer = _MultimetricScorer(**scorer)</div>
<div class="line"><span class="lineno">  762</span> </div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  764</span>        <span class="keywordflow">if</span> y_test <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  765</span>            scores = scorer(estimator, X_test)</div>
<div class="line"><span class="lineno">  766</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  767</span>            scores = scorer(estimator, X_test, y_test)</div>
<div class="line"><span class="lineno">  768</span>    <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  769</span>        <span class="keywordflow">if</span> error_score == <span class="stringliteral">&quot;raise&quot;</span>:</div>
<div class="line"><span class="lineno">  770</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  771</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  772</span>            <span class="keywordflow">if</span> isinstance(scorer, _MultimetricScorer):</div>
<div class="line"><span class="lineno">  773</span>                scores = {name: error_score <span class="keywordflow">for</span> name <span class="keywordflow">in</span> scorer._scorers}</div>
<div class="line"><span class="lineno">  774</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  775</span>                scores = error_score</div>
<div class="line"><span class="lineno">  776</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  777</span>                <span class="stringliteral">&quot;Scoring failed. The score on this train-test partition for &quot;</span></div>
<div class="line"><span class="lineno">  778</span>                f<span class="stringliteral">&quot;these parameters will be set to {error_score}. Details: \n&quot;</span></div>
<div class="line"><span class="lineno">  779</span>                f<span class="stringliteral">&quot;{format_exc()}&quot;</span>,</div>
<div class="line"><span class="lineno">  780</span>                UserWarning,</div>
<div class="line"><span class="lineno">  781</span>            )</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>    error_msg = <span class="stringliteral">&quot;scoring must return a number, got %s (%s) instead. (scorer=%s)&quot;</span></div>
<div class="line"><span class="lineno">  784</span>    <span class="keywordflow">if</span> isinstance(scores, dict):</div>
<div class="line"><span class="lineno">  785</span>        <span class="keywordflow">for</span> name, score <span class="keywordflow">in</span> scores.items():</div>
<div class="line"><span class="lineno">  786</span>            <span class="keywordflow">if</span> hasattr(score, <span class="stringliteral">&quot;item&quot;</span>):</div>
<div class="line"><span class="lineno">  787</span>                <span class="keyword">with</span> suppress(ValueError):</div>
<div class="line"><span class="lineno">  788</span>                    <span class="comment"># e.g. unwrap memmapped scalars</span></div>
<div class="line"><span class="lineno">  789</span>                    score = score.item()</div>
<div class="line"><span class="lineno">  790</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(score, numbers.Number):</div>
<div class="line"><span class="lineno">  791</span>                <span class="keywordflow">raise</span> ValueError(error_msg % (score, type(score), name))</div>
<div class="line"><span class="lineno">  792</span>            scores[name] = score</div>
<div class="line"><span class="lineno">  793</span>    <span class="keywordflow">else</span>:  <span class="comment"># scalar</span></div>
<div class="line"><span class="lineno">  794</span>        <span class="keywordflow">if</span> hasattr(scores, <span class="stringliteral">&quot;item&quot;</span>):</div>
<div class="line"><span class="lineno">  795</span>            <span class="keyword">with</span> suppress(ValueError):</div>
<div class="line"><span class="lineno">  796</span>                <span class="comment"># e.g. unwrap memmapped scalars</span></div>
<div class="line"><span class="lineno">  797</span>                scores = scores.item()</div>
<div class="line"><span class="lineno">  798</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(scores, numbers.Number):</div>
<div class="line"><span class="lineno">  799</span>            <span class="keywordflow">raise</span> ValueError(error_msg % (scores, type(scores), scorer))</div>
<div class="line"><span class="lineno">  800</span>    <span class="keywordflow">return</span> scores</div>
<div class="line"><span class="lineno">  801</span> </div>
<div class="line"><span class="lineno">  802</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aac7587f06b6fe652b5aed5965f1ab58e" name="aac7587f06b6fe652b5aed5965f1ab58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7587f06b6fe652b5aed5965f1ab58e">&#9670;&#160;</a></span>_shuffle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._shuffle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a shuffled copy of y eventually shuffle among same groups.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1338</span><span class="keyword">def </span>_shuffle(y, groups, random_state):</div>
<div class="line"><span class="lineno"> 1339</span>    <span class="stringliteral">&quot;&quot;&quot;Return a shuffled copy of y eventually shuffle among same groups.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1340</span>    <span class="keywordflow">if</span> groups <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1341</span>        indices = random_state.permutation(len(y))</div>
<div class="line"><span class="lineno"> 1342</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1343</span>        indices = np.arange(len(groups))</div>
<div class="line"><span class="lineno"> 1344</span>        <span class="keywordflow">for</span> group <span class="keywordflow">in</span> np.unique(groups):</div>
<div class="line"><span class="lineno"> 1345</span>            this_mask = groups == group</div>
<div class="line"><span class="lineno"> 1346</span>            indices[this_mask] = random_state.permutation(indices[this_mask])</div>
<div class="line"><span class="lineno"> 1347</span>    <span class="keywordflow">return</span> _safe_indexing(y, indices)</div>
<div class="line"><span class="lineno"> 1348</span> </div>
<div class="line"><span class="lineno"> 1349</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a1d0424033b9fae7c4c661d594f32c3" name="a7a1d0424033b9fae7c4c661d594f32c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1d0424033b9fae7c4c661d594f32c3">&#9670;&#160;</a></span>_translate_train_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._translate_train_sizes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>train_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_max_training_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Determine absolute sizes of training subsets and validate 'train_sizes'.

Examples:
    _translate_train_sizes([0.5, 1.0], 10) -&gt; [5, 10]
    _translate_train_sizes([5, 10], 10) -&gt; [5, 10]

Parameters
----------
train_sizes : array-like of shape (n_ticks,)
    Numbers of training examples that will be used to generate the
    learning curve. If the dtype is float, it is regarded as a
    fraction of 'n_max_training_samples', i.e. it has to be within (0, 1].

n_max_training_samples : int
    Maximum number of training samples (upper bound of 'train_sizes').

Returns
-------
train_sizes_abs : array of shape (n_unique_ticks,)
    Numbers of training examples that will be used to generate the
    learning curve. Note that the number of ticks might be less
    than n_ticks because duplicate entries will be removed.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1614</span><span class="keyword">def </span>_translate_train_sizes(train_sizes, n_max_training_samples):</div>
<div class="line"><span class="lineno"> 1615</span>    <span class="stringliteral">&quot;&quot;&quot;Determine absolute sizes of training subsets and validate &#39;train_sizes&#39;.</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">    Examples:</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">        _translate_train_sizes([0.5, 1.0], 10) -&gt; [5, 10]</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">        _translate_train_sizes([5, 10], 10) -&gt; [5, 10]</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    train_sizes : array-like of shape (n_ticks,)</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">        Numbers of training examples that will be used to generate the</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">        learning curve. If the dtype is float, it is regarded as a</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">        fraction of &#39;n_max_training_samples&#39;, i.e. it has to be within (0, 1].</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    n_max_training_samples : int</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">        Maximum number of training samples (upper bound of &#39;train_sizes&#39;).</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">    train_sizes_abs : array of shape (n_unique_ticks,)</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">        Numbers of training examples that will be used to generate the</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">        learning curve. Note that the number of ticks might be less</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">        than n_ticks because duplicate entries will be removed.</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1638</span>    train_sizes_abs = np.asarray(train_sizes)</div>
<div class="line"><span class="lineno"> 1639</span>    n_ticks = train_sizes_abs.shape[0]</div>
<div class="line"><span class="lineno"> 1640</span>    n_min_required_samples = np.min(train_sizes_abs)</div>
<div class="line"><span class="lineno"> 1641</span>    n_max_required_samples = np.max(train_sizes_abs)</div>
<div class="line"><span class="lineno"> 1642</span>    <span class="keywordflow">if</span> np.issubdtype(train_sizes_abs.dtype, np.floating):</div>
<div class="line"><span class="lineno"> 1643</span>        <span class="keywordflow">if</span> n_min_required_samples &lt;= 0.0 <span class="keywordflow">or</span> n_max_required_samples &gt; 1.0:</div>
<div class="line"><span class="lineno"> 1644</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1645</span>                <span class="stringliteral">&quot;train_sizes has been interpreted as fractions &quot;</span></div>
<div class="line"><span class="lineno"> 1646</span>                <span class="stringliteral">&quot;of the maximum number of training samples and &quot;</span></div>
<div class="line"><span class="lineno"> 1647</span>                <span class="stringliteral">&quot;must be within (0, 1], but is within [%f, %f].&quot;</span></div>
<div class="line"><span class="lineno"> 1648</span>                % (n_min_required_samples, n_max_required_samples)</div>
<div class="line"><span class="lineno"> 1649</span>            )</div>
<div class="line"><span class="lineno"> 1650</span>        train_sizes_abs = (train_sizes_abs * n_max_training_samples).astype(</div>
<div class="line"><span class="lineno"> 1651</span>            dtype=int, copy=<span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1652</span>        )</div>
<div class="line"><span class="lineno"> 1653</span>        train_sizes_abs = np.clip(train_sizes_abs, 1, n_max_training_samples)</div>
<div class="line"><span class="lineno"> 1654</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1655</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1656</span>            n_min_required_samples &lt;= 0</div>
<div class="line"><span class="lineno"> 1657</span>            <span class="keywordflow">or</span> n_max_required_samples &gt; n_max_training_samples</div>
<div class="line"><span class="lineno"> 1658</span>        ):</div>
<div class="line"><span class="lineno"> 1659</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1660</span>                <span class="stringliteral">&quot;train_sizes has been interpreted as absolute &quot;</span></div>
<div class="line"><span class="lineno"> 1661</span>                <span class="stringliteral">&quot;numbers of training samples and must be within &quot;</span></div>
<div class="line"><span class="lineno"> 1662</span>                <span class="stringliteral">&quot;(0, %d], but is within [%d, %d].&quot;</span></div>
<div class="line"><span class="lineno"> 1663</span>                % (</div>
<div class="line"><span class="lineno"> 1664</span>                    n_max_training_samples,</div>
<div class="line"><span class="lineno"> 1665</span>                    n_min_required_samples,</div>
<div class="line"><span class="lineno"> 1666</span>                    n_max_required_samples,</div>
<div class="line"><span class="lineno"> 1667</span>                )</div>
<div class="line"><span class="lineno"> 1668</span>            )</div>
<div class="line"><span class="lineno"> 1669</span> </div>
<div class="line"><span class="lineno"> 1670</span>    train_sizes_abs = np.unique(train_sizes_abs)</div>
<div class="line"><span class="lineno"> 1671</span>    <span class="keywordflow">if</span> n_ticks &gt; train_sizes_abs.shape[0]:</div>
<div class="line"><span class="lineno"> 1672</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1673</span>            <span class="stringliteral">&quot;Removed duplicate entries from &#39;train_sizes&#39;. Number &quot;</span></div>
<div class="line"><span class="lineno"> 1674</span>            <span class="stringliteral">&quot;of ticks will be less than the size of &quot;</span></div>
<div class="line"><span class="lineno"> 1675</span>            <span class="stringliteral">&quot;&#39;train_sizes&#39;: %d instead of %d.&quot;</span> % (train_sizes_abs.shape[0], n_ticks),</div>
<div class="line"><span class="lineno"> 1676</span>            RuntimeWarning,</div>
<div class="line"><span class="lineno"> 1677</span>        )</div>
<div class="line"><span class="lineno"> 1678</span> </div>
<div class="line"><span class="lineno"> 1679</span>    <span class="keywordflow">return</span> train_sizes_abs</div>
<div class="line"><span class="lineno"> 1680</span> </div>
<div class="line"><span class="lineno"> 1681</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aea8db1f680a2824ad71a404d074b3014" name="aea8db1f680a2824ad71a404d074b3014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8db1f680a2824ad71a404d074b3014">&#9670;&#160;</a></span>_warn_or_raise_about_fit_failures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation._warn_or_raise_about_fit_failures </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  346</span><span class="keyword">def </span>_warn_or_raise_about_fit_failures(results, error_score):</div>
<div class="line"><span class="lineno">  347</span>    fit_errors = [</div>
<div class="line"><span class="lineno">  348</span>        result[<span class="stringliteral">&quot;fit_error&quot;</span>] <span class="keywordflow">for</span> result <span class="keywordflow">in</span> results <span class="keywordflow">if</span> result[<span class="stringliteral">&quot;fit_error&quot;</span>] <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  349</span>    ]</div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">if</span> fit_errors:</div>
<div class="line"><span class="lineno">  351</span>        num_failed_fits = len(fit_errors)</div>
<div class="line"><span class="lineno">  352</span>        num_fits = len(results)</div>
<div class="line"><span class="lineno">  353</span>        fit_errors_counter = Counter(fit_errors)</div>
<div class="line"><span class="lineno">  354</span>        delimiter = <span class="stringliteral">&quot;-&quot;</span> * 80 + <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line"><span class="lineno">  355</span>        fit_errors_summary = <span class="stringliteral">&quot;\n&quot;</span>.join(</div>
<div class="line"><span class="lineno">  356</span>            f<span class="stringliteral">&quot;{delimiter}{n} fits failed with the following error:\n{error}&quot;</span></div>
<div class="line"><span class="lineno">  357</span>            <span class="keywordflow">for</span> error, n <span class="keywordflow">in</span> fit_errors_counter.items()</div>
<div class="line"><span class="lineno">  358</span>        )</div>
<div class="line"><span class="lineno">  359</span> </div>
<div class="line"><span class="lineno">  360</span>        <span class="keywordflow">if</span> num_failed_fits == num_fits:</div>
<div class="line"><span class="lineno">  361</span>            all_fits_failed_message = (</div>
<div class="line"><span class="lineno">  362</span>                f<span class="stringliteral">&quot;\nAll the {num_fits} fits failed.\n&quot;</span></div>
<div class="line"><span class="lineno">  363</span>                <span class="stringliteral">&quot;It is very likely that your model is misconfigured.\n&quot;</span></div>
<div class="line"><span class="lineno">  364</span>                <span class="stringliteral">&quot;You can try to debug the error by setting error_score=&#39;raise&#39;.\n\n&quot;</span></div>
<div class="line"><span class="lineno">  365</span>                f<span class="stringliteral">&quot;Below are more details about the failures:\n{fit_errors_summary}&quot;</span></div>
<div class="line"><span class="lineno">  366</span>            )</div>
<div class="line"><span class="lineno">  367</span>            <span class="keywordflow">raise</span> ValueError(all_fits_failed_message)</div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  370</span>            some_fits_failed_message = (</div>
<div class="line"><span class="lineno">  371</span>                f<span class="stringliteral">&quot;\n{num_failed_fits} fits failed out of a total of {num_fits}.\n&quot;</span></div>
<div class="line"><span class="lineno">  372</span>                <span class="stringliteral">&quot;The score on these train-test partitions for these parameters&quot;</span></div>
<div class="line"><span class="lineno">  373</span>                f<span class="stringliteral">&quot; will be set to {error_score}.\n&quot;</span></div>
<div class="line"><span class="lineno">  374</span>                <span class="stringliteral">&quot;If these failures are not expected, you can try to debug them &quot;</span></div>
<div class="line"><span class="lineno">  375</span>                <span class="stringliteral">&quot;by setting error_score=&#39;raise&#39;.\n\n&quot;</span></div>
<div class="line"><span class="lineno">  376</span>                f<span class="stringliteral">&quot;Below are more details about the failures:\n{fit_errors_summary}&quot;</span></div>
<div class="line"><span class="lineno">  377</span>            )</div>
<div class="line"><span class="lineno">  378</span>            warnings.warn(some_fits_failed_message, FitFailedWarning)</div>
<div class="line"><span class="lineno">  379</span> </div>
<div class="line"><span class="lineno">  380</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a66a785340cb33fd1f7bfa89f4900a9de" name="a66a785340cb33fd1f7bfa89f4900a9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a785340cb33fd1f7bfa89f4900a9de">&#9670;&#160;</a></span>cross_val_predict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation.cross_val_predict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>groups</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cv</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pre_dispatch</em> = <code>&quot;2*n_jobs&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;predict&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate cross-validated estimates for each input data point.

The data is split according to the cv parameter. Each sample belongs
to exactly one test set, and its prediction is computed with an
estimator fitted on the corresponding training set.

Passing these predictions into an evaluation metric may not be a valid
way to measure generalization performance. Results can differ from
:func:`cross_validate` and :func:`cross_val_score` unless all tests sets
have equal size and the metric decomposes over samples.

Read more in the :ref:`User Guide &lt;cross_validation&gt;`.

Parameters
----------
estimator : estimator object implementing 'fit' and 'predict'
    The object to use to fit the data.

X : array-like of shape (n_samples, n_features)
    The data to fit. Can be, for example a list, or an array at least 2d.

y : array-like of shape (n_samples,) or (n_samples, n_outputs), \
        default=None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable that generates (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and
    predicting are parallelized over the cross-validation splits.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

verbose : int, default=0
    The verbosity level.

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

pre_dispatch : int or str, default='2*n_jobs'
    Controls the number of jobs that get dispatched during parallel
    execution. Reducing this number can be useful to avoid an
    explosion of memory consumption when more jobs get dispatched
    than CPUs can process. This parameter can be:

        - None, in which case all the jobs are immediately
          created and spawned. Use this for lightweight and
          fast-running jobs, to avoid delays due to on-demand
          spawning of the jobs

        - An int, giving the exact number of total jobs that are
          spawned

        - A str, giving an expression as a function of n_jobs,
          as in '2*n_jobs'

method : {'predict', 'predict_proba', 'predict_log_proba', \
          'decision_function'}, default='predict'
    The method to be invoked by `estimator`.

Returns
-------
predictions : ndarray
    This is the result of calling `method`. Shape:

        - When `method` is 'predict' and in special case where `method` is
          'decision_function' and the target is binary: (n_samples,)
        - When `method` is one of {'predict_proba', 'predict_log_proba',
          'decision_function'} (unless special case above):
          (n_samples, n_classes)
        - If `estimator` is :term:`multioutput`, an extra dimension
          'n_outputs' is added to the end of each shape above.

See Also
--------
cross_val_score : Calculate score for each CV split.
cross_validate : Calculate one or more scores and timings for each CV
    split.

Notes
-----
In the case that one or more classes are absent in a training portion, a
default score needs to be assigned to all instances for that class if
``method`` produces columns per class, as in {'decision_function',
'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is
0.  In order to ensure finite output, we approximate negative infinity by
the minimum finite float value for the dtype in other cases.

Examples
--------
&gt;&gt;&gt; from sklearn import datasets, linear_model
&gt;&gt;&gt; from sklearn.model_selection import cross_val_predict
&gt;&gt;&gt; diabetes = datasets.load_diabetes()
&gt;&gt;&gt; X = diabetes.data[:150]
&gt;&gt;&gt; y = diabetes.target[:150]
&gt;&gt;&gt; lasso = linear_model.Lasso()
&gt;&gt;&gt; y_pred = cross_val_predict(lasso, X, y, cv=3)
</pre> <div class="fragment"><div class="line"><span class="lineno">  815</span>):</div>
<div class="line"><span class="lineno">  816</span>    <span class="stringliteral">&quot;&quot;&quot;Generate cross-validated estimates for each input data point.</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    The data is split according to the cv parameter. Each sample belongs</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    to exactly one test set, and its prediction is computed with an</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    estimator fitted on the corresponding training set.</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    Passing these predictions into an evaluation metric may not be a valid</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    way to measure generalization performance. Results can differ from</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    :func:`cross_validate` and :func:`cross_val_score` unless all tests sets</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    have equal size and the metric decomposes over samples.</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;cross_validation&gt;`.</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    estimator : estimator object implementing &#39;fit&#39; and &#39;predict&#39;</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">        The object to use to fit the data.</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">        The data to fit. Can be, for example a list, or an array at least 2d.</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs), \</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">            default=None</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        The target variable to try to predict in the case of</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        supervised learning.</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    groups : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        Group labels for the samples used while splitting the dataset into</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv`</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        instance (e.g., :class:`GroupKFold`).</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    cv : int, cross-validation generator or an iterable, default=None</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">        Determines the cross-validation splitting strategy.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">        Possible inputs for cv are:</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">        - None, to use the default 5-fold cross validation,</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">        - int, to specify the number of folds in a `(Stratified)KFold`,</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">        - :term:`CV splitter`,</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">        - An iterable that generates (train, test) splits as arrays of indices.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">        For int/None inputs, if the estimator is a classifier and ``y`` is</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">        either binary or multiclass, :class:`StratifiedKFold` is used. In all</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">        other cases, :class:`KFold` is used. These splitters are instantiated</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">        with `shuffle=False` so the splits will be the same across calls.</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">        cross-validation strategies that can be used here.</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">            ``cv`` default value if None changed from 3-fold to 5-fold.</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">        Number of jobs to run in parallel. Training the estimator and</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">        predicting are parallelized over the cross-validation splits.</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    verbose : int, default=0</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        The verbosity level.</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    fit_params : dict, default=None</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">        Parameters to pass to the fit method of the estimator.</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    pre_dispatch : int or str, default=&#39;2*n_jobs&#39;</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">        Controls the number of jobs that get dispatched during parallel</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        execution. Reducing this number can be useful to avoid an</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">        explosion of memory consumption when more jobs get dispatched</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">        than CPUs can process. This parameter can be:</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">            - None, in which case all the jobs are immediately</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">              created and spawned. Use this for lightweight and</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">              fast-running jobs, to avoid delays due to on-demand</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">              spawning of the jobs</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">            - An int, giving the exact number of total jobs that are</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">              spawned</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">            - A str, giving an expression as a function of n_jobs,</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">              as in &#39;2*n_jobs&#39;</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    method : {&#39;predict&#39;, &#39;predict_proba&#39;, &#39;predict_log_proba&#39;, \</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">              &#39;decision_function&#39;}, default=&#39;predict&#39;</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">        The method to be invoked by `estimator`.</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    predictions : ndarray</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">        This is the result of calling `method`. Shape:</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">            - When `method` is &#39;predict&#39; and in special case where `method` is</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">              &#39;decision_function&#39; and the target is binary: (n_samples,)</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">            - When `method` is one of {&#39;predict_proba&#39;, &#39;predict_log_proba&#39;,</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">              &#39;decision_function&#39;} (unless special case above):</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">              (n_samples, n_classes)</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">            - If `estimator` is :term:`multioutput`, an extra dimension</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">              &#39;n_outputs&#39; is added to the end of each shape above.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    cross_val_score : Calculate score for each CV split.</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    cross_validate : Calculate one or more scores and timings for each CV</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">        split.</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    In the case that one or more classes are absent in a training portion, a</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    default score needs to be assigned to all instances for that class if</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    ``method`` produces columns per class, as in {&#39;decision_function&#39;,</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    &#39;predict_proba&#39;, &#39;predict_log_proba&#39;}.  For ``predict_proba`` this value is</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    0.  In order to ensure finite output, we approximate negative infinity by</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    the minimum finite float value for the dtype in other cases.</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn import datasets, linear_model</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.model_selection import cross_val_predict</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    &gt;&gt;&gt; diabetes = datasets.load_diabetes()</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    &gt;&gt;&gt; X = diabetes.data[:150]</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    &gt;&gt;&gt; y = diabetes.target[:150]</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    &gt;&gt;&gt; lasso = linear_model.Lasso()</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    &gt;&gt;&gt; y_pred = cross_val_predict(lasso, X, y, cv=3)</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  939</span>    X, y, groups = indexable(X, y, groups)</div>
<div class="line"><span class="lineno">  940</span> </div>
<div class="line"><span class="lineno">  941</span>    cv = check_cv(cv, y, classifier=is_classifier(estimator))</div>
<div class="line"><span class="lineno">  942</span>    splits = list(cv.split(X, y, groups))</div>
<div class="line"><span class="lineno">  943</span> </div>
<div class="line"><span class="lineno">  944</span>    test_indices = np.concatenate([test <span class="keywordflow">for</span> _, test <span class="keywordflow">in</span> splits])</div>
<div class="line"><span class="lineno">  945</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _check_is_permutation(test_indices, _num_samples(X)):</div>
<div class="line"><span class="lineno">  946</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cross_val_predict only works for partitions&quot;</span>)</div>
<div class="line"><span class="lineno">  947</span> </div>
<div class="line"><span class="lineno">  948</span>    <span class="comment"># If classification methods produce multiple columns of output,</span></div>
<div class="line"><span class="lineno">  949</span>    <span class="comment"># we need to manually encode classes to ensure consistent column ordering.</span></div>
<div class="line"><span class="lineno">  950</span>    encode = (</div>
<div class="line"><span class="lineno">  951</span>        method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;decision_function&quot;</span>, <span class="stringliteral">&quot;predict_proba&quot;</span>, <span class="stringliteral">&quot;predict_log_proba&quot;</span>]</div>
<div class="line"><span class="lineno">  952</span>        <span class="keywordflow">and</span> y <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  953</span>    )</div>
<div class="line"><span class="lineno">  954</span>    <span class="keywordflow">if</span> encode:</div>
<div class="line"><span class="lineno">  955</span>        y = np.asarray(y)</div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordflow">if</span> y.ndim == 1:</div>
<div class="line"><span class="lineno">  957</span>            le = LabelEncoder()</div>
<div class="line"><span class="lineno">  958</span>            y = le.fit_transform(y)</div>
<div class="line"><span class="lineno">  959</span>        <span class="keywordflow">elif</span> y.ndim == 2:</div>
<div class="line"><span class="lineno">  960</span>            y_enc = np.zeros_like(y, dtype=int)</div>
<div class="line"><span class="lineno">  961</span>            <span class="keywordflow">for</span> i_label <span class="keywordflow">in</span> range(y.shape[1]):</div>
<div class="line"><span class="lineno">  962</span>                y_enc[:, i_label] = LabelEncoder().fit_transform(y[:, i_label])</div>
<div class="line"><span class="lineno">  963</span>            y = y_enc</div>
<div class="line"><span class="lineno">  964</span> </div>
<div class="line"><span class="lineno">  965</span>    <span class="comment"># We clone the estimator to make sure that all the folds are</span></div>
<div class="line"><span class="lineno">  966</span>    <span class="comment"># independent, and that it is pickle-able.</span></div>
<div class="line"><span class="lineno">  967</span>    parallel = Parallel(n_jobs=n_jobs, verbose=verbose, pre_dispatch=pre_dispatch)</div>
<div class="line"><span class="lineno">  968</span>    predictions = parallel(</div>
<div class="line"><span class="lineno">  969</span>        delayed(_fit_and_predict)(</div>
<div class="line"><span class="lineno">  970</span>            clone(estimator), X, y, train, test, verbose, fit_params, method</div>
<div class="line"><span class="lineno">  971</span>        )</div>
<div class="line"><span class="lineno">  972</span>        <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> splits</div>
<div class="line"><span class="lineno">  973</span>    )</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>    inv_test_indices = np.empty(len(test_indices), dtype=int)</div>
<div class="line"><span class="lineno">  976</span>    inv_test_indices[test_indices] = np.arange(len(test_indices))</div>
<div class="line"><span class="lineno">  977</span> </div>
<div class="line"><span class="lineno">  978</span>    <span class="keywordflow">if</span> sp.issparse(predictions[0]):</div>
<div class="line"><span class="lineno">  979</span>        predictions = sp.vstack(predictions, format=predictions[0].format)</div>
<div class="line"><span class="lineno">  980</span>    <span class="keywordflow">elif</span> encode <span class="keywordflow">and</span> isinstance(predictions[0], list):</div>
<div class="line"><span class="lineno">  981</span>        <span class="comment"># `predictions` is a list of method outputs from each fold.</span></div>
<div class="line"><span class="lineno">  982</span>        <span class="comment"># If each of those is also a list, then treat this as a</span></div>
<div class="line"><span class="lineno">  983</span>        <span class="comment"># multioutput-multiclass task. We need to separately concatenate</span></div>
<div class="line"><span class="lineno">  984</span>        <span class="comment"># the method outputs for each label into an `n_labels` long list.</span></div>
<div class="line"><span class="lineno">  985</span>        n_labels = y.shape[1]</div>
<div class="line"><span class="lineno">  986</span>        concat_pred = []</div>
<div class="line"><span class="lineno">  987</span>        <span class="keywordflow">for</span> i_label <span class="keywordflow">in</span> range(n_labels):</div>
<div class="line"><span class="lineno">  988</span>            label_preds = np.concatenate([p[i_label] <span class="keywordflow">for</span> p <span class="keywordflow">in</span> predictions])</div>
<div class="line"><span class="lineno">  989</span>            concat_pred.append(label_preds)</div>
<div class="line"><span class="lineno">  990</span>        predictions = concat_pred</div>
<div class="line"><span class="lineno">  991</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  992</span>        predictions = np.concatenate(predictions)</div>
<div class="line"><span class="lineno">  993</span> </div>
<div class="line"><span class="lineno">  994</span>    <span class="keywordflow">if</span> isinstance(predictions, list):</div>
<div class="line"><span class="lineno">  995</span>        <span class="keywordflow">return</span> [p[inv_test_indices] <span class="keywordflow">for</span> p <span class="keywordflow">in</span> predictions]</div>
<div class="line"><span class="lineno">  996</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  997</span>        <span class="keywordflow">return</span> predictions[inv_test_indices]</div>
<div class="line"><span class="lineno">  998</span> </div>
<div class="line"><span class="lineno">  999</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af5d327fc818f8db201e49936c7befa3b" name="af5d327fc818f8db201e49936c7befa3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d327fc818f8db201e49936c7befa3b">&#9670;&#160;</a></span>cross_val_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation.cross_val_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>groups</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scoring</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cv</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pre_dispatch</em> = <code>&quot;2*n_jobs&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em> = <code>np.nan</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a score by cross-validation.

Read more in the :ref:`User Guide &lt;cross_validation&gt;`.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : array-like of shape (n_samples, n_features)
    The data to fit. Can be for example a list, or an array.

y : array-like of shape (n_samples,) or (n_samples, n_outputs), \
        default=None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

scoring : str or callable, default=None
    A str (see model evaluation documentation) or
    a scorer callable object / function with signature
    ``scorer(estimator, X, y)`` which should return only
    a single value.

    Similar to :func:`cross_validate`
    but only a single metric is permitted.

    If `None`, the estimator's default scorer (if available) is used.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - `None`, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable that generates (train, test) splits as arrays of indices.

    For `int`/`None` inputs, if the estimator is a classifier and `y` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        `cv` default value if `None` changed from 3-fold to 5-fold.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the cross-validation splits.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

verbose : int, default=0
    The verbosity level.

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

pre_dispatch : int or str, default='2*n_jobs'
    Controls the number of jobs that get dispatched during parallel
    execution. Reducing this number can be useful to avoid an
    explosion of memory consumption when more jobs get dispatched
    than CPUs can process. This parameter can be:

        - ``None``, in which case all the jobs are immediately
          created and spawned. Use this for lightweight and
          fast-running jobs, to avoid delays due to on-demand
          spawning of the jobs

        - An int, giving the exact number of total jobs that are
          spawned

        - A str, giving an expression as a function of n_jobs,
          as in '2*n_jobs'

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

Returns
-------
scores : ndarray of float of shape=(len(list(cv)),)
    Array of scores of the estimator for each run of the cross validation.

See Also
--------
cross_validate : To run cross-validation on multiple metrics and also to
    return train scores, fit times and score times.

cross_val_predict : Get predictions from each split of cross-validation for
    diagnostic purposes.

sklearn.metrics.make_scorer : Make a scorer from a performance metric or
    loss function.

Examples
--------
&gt;&gt;&gt; from sklearn import datasets, linear_model
&gt;&gt;&gt; from sklearn.model_selection import cross_val_score
&gt;&gt;&gt; diabetes = datasets.load_diabetes()
&gt;&gt;&gt; X = diabetes.data[:150]
&gt;&gt;&gt; y = diabetes.target[:150]
&gt;&gt;&gt; lasso = linear_model.Lasso()
&gt;&gt;&gt; print(cross_val_score(lasso, X, y, cv=3))
[0.3315057  0.08022103 0.03531816]
</pre> <div class="fragment"><div class="line"><span class="lineno">  394</span>):</div>
<div class="line"><span class="lineno">  395</span>    <span class="stringliteral">&quot;&quot;&quot;Evaluate a score by cross-validation.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;cross_validation&gt;`.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    estimator : estimator object implementing &#39;fit&#39;</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">        The object to use to fit the data.</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        The data to fit. Can be for example a list, or an array.</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs), \</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">            default=None</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        The target variable to try to predict in the case of</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        supervised learning.</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    groups : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        Group labels for the samples used while splitting the dataset into</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv`</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">        instance (e.g., :class:`GroupKFold`).</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    scoring : str or callable, default=None</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">        A str (see model evaluation documentation) or</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        a scorer callable object / function with signature</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">        ``scorer(estimator, X, y)`` which should return only</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">        a single value.</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">        Similar to :func:`cross_validate`</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        but only a single metric is permitted.</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">        If `None`, the estimator&#39;s default scorer (if available) is used.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    cv : int, cross-validation generator or an iterable, default=None</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">        Determines the cross-validation splitting strategy.</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        Possible inputs for cv are:</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        - `None`, to use the default 5-fold cross validation,</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        - int, to specify the number of folds in a `(Stratified)KFold`,</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        - :term:`CV splitter`,</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        - An iterable that generates (train, test) splits as arrays of indices.</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">        For `int`/`None` inputs, if the estimator is a classifier and `y` is</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        either binary or multiclass, :class:`StratifiedKFold` is used. In all</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        other cases, :class:`KFold` is used. These splitters are instantiated</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        with `shuffle=False` so the splits will be the same across calls.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        cross-validation strategies that can be used here.</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">            `cv` default value if `None` changed from 3-fold to 5-fold.</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        Number of jobs to run in parallel. Training the estimator and computing</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        the score are parallelized over the cross-validation splits.</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    verbose : int, default=0</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">        The verbosity level.</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    fit_params : dict, default=None</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        Parameters to pass to the fit method of the estimator.</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    pre_dispatch : int or str, default=&#39;2*n_jobs&#39;</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        Controls the number of jobs that get dispatched during parallel</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        execution. Reducing this number can be useful to avoid an</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        explosion of memory consumption when more jobs get dispatched</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">        than CPUs can process. This parameter can be:</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">            - ``None``, in which case all the jobs are immediately</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">              created and spawned. Use this for lightweight and</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">              fast-running jobs, to avoid delays due to on-demand</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">              spawning of the jobs</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">            - An int, giving the exact number of total jobs that are</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">              spawned</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">            - A str, giving an expression as a function of n_jobs,</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">              as in &#39;2*n_jobs&#39;</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    error_score : &#39;raise&#39; or numeric, default=np.nan</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        Value to assign to the score if an error occurs in estimator fitting.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        If set to &#39;raise&#39;, the error is raised.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        If a numeric value is given, FitFailedWarning is raised.</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    scores : ndarray of float of shape=(len(list(cv)),)</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        Array of scores of the estimator for each run of the cross validation.</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    cross_validate : To run cross-validation on multiple metrics and also to</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        return train scores, fit times and score times.</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    cross_val_predict : Get predictions from each split of cross-validation for</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        diagnostic purposes.</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    sklearn.metrics.make_scorer : Make a scorer from a performance metric or</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        loss function.</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn import datasets, linear_model</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.model_selection import cross_val_score</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    &gt;&gt;&gt; diabetes = datasets.load_diabetes()</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    &gt;&gt;&gt; X = diabetes.data[:150]</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    &gt;&gt;&gt; y = diabetes.target[:150]</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    &gt;&gt;&gt; lasso = linear_model.Lasso()</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &gt;&gt;&gt; print(cross_val_score(lasso, X, y, cv=3))</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    [0.3315057  0.08022103 0.03531816]</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  512</span>    <span class="comment"># To ensure multimetric format is not supported</span></div>
<div class="line"><span class="lineno">  513</span>    scorer = check_scoring(estimator, scoring=scoring)</div>
<div class="line"><span class="lineno">  514</span> </div>
<div class="line"><span class="lineno">  515</span>    cv_results = cross_validate(</div>
<div class="line"><span class="lineno">  516</span>        estimator=estimator,</div>
<div class="line"><span class="lineno">  517</span>        X=X,</div>
<div class="line"><span class="lineno">  518</span>        y=y,</div>
<div class="line"><span class="lineno">  519</span>        groups=groups,</div>
<div class="line"><span class="lineno">  520</span>        scoring={<span class="stringliteral">&quot;score&quot;</span>: scorer},</div>
<div class="line"><span class="lineno">  521</span>        cv=cv,</div>
<div class="line"><span class="lineno">  522</span>        n_jobs=n_jobs,</div>
<div class="line"><span class="lineno">  523</span>        verbose=verbose,</div>
<div class="line"><span class="lineno">  524</span>        fit_params=fit_params,</div>
<div class="line"><span class="lineno">  525</span>        pre_dispatch=pre_dispatch,</div>
<div class="line"><span class="lineno">  526</span>        error_score=error_score,</div>
<div class="line"><span class="lineno">  527</span>    )</div>
<div class="line"><span class="lineno">  528</span>    <span class="keywordflow">return</span> cv_results[<span class="stringliteral">&quot;test_score&quot;</span>]</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa742d74376d80abd1cb43c2ab86dd39e" name="aa742d74376d80abd1cb43c2ab86dd39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa742d74376d80abd1cb43c2ab86dd39e">&#9670;&#160;</a></span>cross_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation.cross_validate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>groups</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scoring</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cv</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pre_dispatch</em> = <code>&quot;2*n_jobs&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_train_score</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_estimator</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em> = <code>np.nan</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate metric(s) by cross-validation and also record fit/score times.

Read more in the :ref:`User Guide &lt;multimetric_cross_validation&gt;`.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : array-like of shape (n_samples, n_features)
    The data to fit. Can be for example a list, or an array.

y : array-like of shape (n_samples,) or (n_samples, n_outputs), default=None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

scoring : str, callable, list, tuple, or dict, default=None
    Strategy to evaluate the performance of the cross-validated model on
    the test set.

    If `scoring` represents a single score, one can use:

    - a single string (see :ref:`scoring_parameter`);
    - a callable (see :ref:`scoring`) that returns a single value.

    If `scoring` represents multiple scores, one can use:

    - a list or tuple of unique strings;
    - a callable returning a dictionary where the keys are the metric
      names and the values are the metric scores;
    - a dictionary with metric names as keys and callables a values.

    See :ref:`multimetric_grid_search` for an example.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`.Fold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the cross-validation splits.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

verbose : int, default=0
    The verbosity level.

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

pre_dispatch : int or str, default='2*n_jobs'
    Controls the number of jobs that get dispatched during parallel
    execution. Reducing this number can be useful to avoid an
    explosion of memory consumption when more jobs get dispatched
    than CPUs can process. This parameter can be:

        - None, in which case all the jobs are immediately
          created and spawned. Use this for lightweight and
          fast-running jobs, to avoid delays due to on-demand
          spawning of the jobs

        - An int, giving the exact number of total jobs that are
          spawned

        - A str, giving an expression as a function of n_jobs,
          as in '2*n_jobs'

return_train_score : bool, default=False
    Whether to include train scores.
    Computing training scores is used to get insights on how different
    parameter settings impact the overfitting/underfitting trade-off.
    However computing the scores on the training set can be computationally
    expensive and is not strictly required to select the parameters that
    yield the best generalization performance.

    .. versionadded:: 0.19

    .. versionchanged:: 0.21
        Default value was changed from ``True`` to ``False``

return_estimator : bool, default=False
    Whether to return the estimators fitted on each split.

    .. versionadded:: 0.20

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

Returns
-------
scores : dict of float arrays of shape (n_splits,)
    Array of scores of the estimator for each run of the cross validation.

    A dict of arrays containing the score/time arrays for each scorer is
    returned. The possible keys for this ``dict`` are:

        ``test_score``
            The score array for test scores on each cv split.
            Suffix ``_score`` in ``test_score`` changes to a specific
            metric like ``test_r2`` or ``test_auc`` if there are
            multiple scoring metrics in the scoring parameter.
        ``train_score``
            The score array for train scores on each cv split.
            Suffix ``_score`` in ``train_score`` changes to a specific
            metric like ``train_r2`` or ``train_auc`` if there are
            multiple scoring metrics in the scoring parameter.
            This is available only if ``return_train_score`` parameter
            is ``True``.
        ``fit_time``
            The time for fitting the estimator on the train
            set for each cv split.
        ``score_time``
            The time for scoring the estimator on the test set for each
            cv split. (Note time for scoring on the train set is not
            included even if ``return_train_score`` is set to ``True``
        ``estimator``
            The estimator objects for each cv split.
            This is available only if ``return_estimator`` parameter
            is set to ``True``.

See Also
--------
cross_val_score : Run cross-validation for single metric evaluation.

cross_val_predict : Get predictions from each split of cross-validation for
    diagnostic purposes.

sklearn.metrics.make_scorer : Make a scorer from a performance metric or
    loss function.

Examples
--------
&gt;&gt;&gt; from sklearn import datasets, linear_model
&gt;&gt;&gt; from sklearn.model_selection import cross_validate
&gt;&gt;&gt; from sklearn.metrics import make_scorer
&gt;&gt;&gt; from sklearn.metrics import confusion_matrix
&gt;&gt;&gt; from sklearn.svm import LinearSVC
&gt;&gt;&gt; diabetes = datasets.load_diabetes()
&gt;&gt;&gt; X = diabetes.data[:150]
&gt;&gt;&gt; y = diabetes.target[:150]
&gt;&gt;&gt; lasso = linear_model.Lasso()

Single metric evaluation using ``cross_validate``

&gt;&gt;&gt; cv_results = cross_validate(lasso, X, y, cv=3)
&gt;&gt;&gt; sorted(cv_results.keys())
['fit_time', 'score_time', 'test_score']
&gt;&gt;&gt; cv_results['test_score']
array([0.3315057 , 0.08022103, 0.03531816])

Multiple metric evaluation using ``cross_validate``
(please refer the ``scoring`` parameter doc for more information)

&gt;&gt;&gt; scores = cross_validate(lasso, X, y, cv=3,
...                         scoring=('r2', 'neg_mean_squared_error'),
...                         return_train_score=True)
&gt;&gt;&gt; print(scores['test_neg_mean_squared_error'])
[-3635.5... -3573.3... -6114.7...]
&gt;&gt;&gt; print(scores['train_r2'])
[0.28009951 0.3908844  0.22784907]
</pre> <div class="fragment"><div class="line"><span class="lineno">   64</span>):</div>
<div class="line"><span class="lineno">   65</span>    <span class="stringliteral">&quot;&quot;&quot;Evaluate metric(s) by cross-validation and also record fit/score times.</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;multimetric_cross_validation&gt;`.</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    estimator : estimator object implementing &#39;fit&#39;</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">        The object to use to fit the data.</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        The data to fit. Can be for example a list, or an array.</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs), default=None</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">        The target variable to try to predict in the case of</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        supervised learning.</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    groups : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        Group labels for the samples used while splitting the dataset into</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv`</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        instance (e.g., :class:`GroupKFold`).</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    scoring : str, callable, list, tuple, or dict, default=None</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        Strategy to evaluate the performance of the cross-validated model on</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        the test set.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        If `scoring` represents a single score, one can use:</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        - a single string (see :ref:`scoring_parameter`);</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        - a callable (see :ref:`scoring`) that returns a single value.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        If `scoring` represents multiple scores, one can use:</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        - a list or tuple of unique strings;</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        - a callable returning a dictionary where the keys are the metric</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">          names and the values are the metric scores;</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        - a dictionary with metric names as keys and callables a values.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        See :ref:`multimetric_grid_search` for an example.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    cv : int, cross-validation generator or an iterable, default=None</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        Determines the cross-validation splitting strategy.</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        Possible inputs for cv are:</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        - None, to use the default 5-fold cross validation,</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        - int, to specify the number of folds in a `(Stratified)KFold`,</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">        - :term:`CV splitter`,</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        - An iterable yielding (train, test) splits as arrays of indices.</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        For int/None inputs, if the estimator is a classifier and ``y`` is</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">        either binary or multiclass, :class:`StratifiedKFold` is used. In all</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        other cases, :class:`.Fold` is used. These splitters are instantiated</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">        with `shuffle=False` so the splits will be the same across calls.</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        cross-validation strategies that can be used here.</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">            ``cv`` default value if None changed from 3-fold to 5-fold.</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        Number of jobs to run in parallel. Training the estimator and computing</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        the score are parallelized over the cross-validation splits.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    verbose : int, default=0</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">        The verbosity level.</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    fit_params : dict, default=None</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">        Parameters to pass to the fit method of the estimator.</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    pre_dispatch : int or str, default=&#39;2*n_jobs&#39;</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        Controls the number of jobs that get dispatched during parallel</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">        execution. Reducing this number can be useful to avoid an</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        explosion of memory consumption when more jobs get dispatched</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        than CPUs can process. This parameter can be:</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">            - None, in which case all the jobs are immediately</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">              created and spawned. Use this for lightweight and</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">              fast-running jobs, to avoid delays due to on-demand</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">              spawning of the jobs</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">            - An int, giving the exact number of total jobs that are</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">              spawned</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">            - A str, giving an expression as a function of n_jobs,</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">              as in &#39;2*n_jobs&#39;</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    return_train_score : bool, default=False</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        Whether to include train scores.</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">        Computing training scores is used to get insights on how different</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">        parameter settings impact the overfitting/underfitting trade-off.</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        However computing the scores on the training set can be computationally</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">        expensive and is not strictly required to select the parameters that</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        yield the best generalization performance.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        .. versionadded:: 0.19</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">        .. versionchanged:: 0.21</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">            Default value was changed from ``True`` to ``False``</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    return_estimator : bool, default=False</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        Whether to return the estimators fitted on each split.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    error_score : &#39;raise&#39; or numeric, default=np.nan</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        Value to assign to the score if an error occurs in estimator fitting.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        If set to &#39;raise&#39;, the error is raised.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        If a numeric value is given, FitFailedWarning is raised.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    scores : dict of float arrays of shape (n_splits,)</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        Array of scores of the estimator for each run of the cross validation.</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        A dict of arrays containing the score/time arrays for each scorer is</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        returned. The possible keys for this ``dict`` are:</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">            ``test_score``</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">                The score array for test scores on each cv split.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">                Suffix ``_score`` in ``test_score`` changes to a specific</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">                metric like ``test_r2`` or ``test_auc`` if there are</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">                multiple scoring metrics in the scoring parameter.</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">            ``train_score``</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">                The score array for train scores on each cv split.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">                Suffix ``_score`` in ``train_score`` changes to a specific</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">                metric like ``train_r2`` or ``train_auc`` if there are</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">                multiple scoring metrics in the scoring parameter.</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">                This is available only if ``return_train_score`` parameter</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">                is ``True``.</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">            ``fit_time``</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">                The time for fitting the estimator on the train</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">                set for each cv split.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">            ``score_time``</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">                The time for scoring the estimator on the test set for each</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">                cv split. (Note time for scoring on the train set is not</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">                included even if ``return_train_score`` is set to ``True``</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">            ``estimator``</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">                The estimator objects for each cv split.</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">                This is available only if ``return_estimator`` parameter</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">                is set to ``True``.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    cross_val_score : Run cross-validation for single metric evaluation.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    cross_val_predict : Get predictions from each split of cross-validation for</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        diagnostic purposes.</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    sklearn.metrics.make_scorer : Make a scorer from a performance metric or</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        loss function.</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn import datasets, linear_model</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.model_selection import cross_validate</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics import make_scorer</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.metrics import confusion_matrix</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.svm import LinearSVC</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    &gt;&gt;&gt; diabetes = datasets.load_diabetes()</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; X = diabetes.data[:150]</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &gt;&gt;&gt; y = diabetes.target[:150]</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    &gt;&gt;&gt; lasso = linear_model.Lasso()</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    Single metric evaluation using ``cross_validate``</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    &gt;&gt;&gt; cv_results = cross_validate(lasso, X, y, cv=3)</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    &gt;&gt;&gt; sorted(cv_results.keys())</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    [&#39;fit_time&#39;, &#39;score_time&#39;, &#39;test_score&#39;]</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    &gt;&gt;&gt; cv_results[&#39;test_score&#39;]</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    array([0.3315057 , 0.08022103, 0.03531816])</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    Multiple metric evaluation using ``cross_validate``</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    (please refer the ``scoring`` parameter doc for more information)</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    &gt;&gt;&gt; scores = cross_validate(lasso, X, y, cv=3,</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    ...                         scoring=(&#39;r2&#39;, &#39;neg_mean_squared_error&#39;),</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    ...                         return_train_score=True)</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    &gt;&gt;&gt; print(scores[&#39;test_neg_mean_squared_error&#39;])</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    [-3635.5... -3573.3... -6114.7...]</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    &gt;&gt;&gt; print(scores[&#39;train_r2&#39;])</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    [0.28009951 0.3908844  0.22784907]</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  252</span>    X, y, groups = indexable(X, y, groups)</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>    cv = check_cv(cv, y, classifier=is_classifier(estimator))</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span>    <span class="keywordflow">if</span> callable(scoring):</div>
<div class="line"><span class="lineno">  257</span>        scorers = scoring</div>
<div class="line"><span class="lineno">  258</span>    <span class="keywordflow">elif</span> scoring <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> isinstance(scoring, str):</div>
<div class="line"><span class="lineno">  259</span>        scorers = check_scoring(estimator, scoring)</div>
<div class="line"><span class="lineno">  260</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  261</span>        scorers = _check_multimetric_scoring(estimator, scoring)</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span>    <span class="comment"># We clone the estimator to make sure that all the folds are</span></div>
<div class="line"><span class="lineno">  264</span>    <span class="comment"># independent, and that it is pickle-able.</span></div>
<div class="line"><span class="lineno">  265</span>    parallel = Parallel(n_jobs=n_jobs, verbose=verbose, pre_dispatch=pre_dispatch)</div>
<div class="line"><span class="lineno">  266</span>    results = parallel(</div>
<div class="line"><span class="lineno">  267</span>        delayed(_fit_and_score)(</div>
<div class="line"><span class="lineno">  268</span>            clone(estimator),</div>
<div class="line"><span class="lineno">  269</span>            X,</div>
<div class="line"><span class="lineno">  270</span>            y,</div>
<div class="line"><span class="lineno">  271</span>            scorers,</div>
<div class="line"><span class="lineno">  272</span>            train,</div>
<div class="line"><span class="lineno">  273</span>            test,</div>
<div class="line"><span class="lineno">  274</span>            verbose,</div>
<div class="line"><span class="lineno">  275</span>            <span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  276</span>            fit_params,</div>
<div class="line"><span class="lineno">  277</span>            return_train_score=return_train_score,</div>
<div class="line"><span class="lineno">  278</span>            return_times=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  279</span>            return_estimator=return_estimator,</div>
<div class="line"><span class="lineno">  280</span>            error_score=error_score,</div>
<div class="line"><span class="lineno">  281</span>        )</div>
<div class="line"><span class="lineno">  282</span>        <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> cv.split(X, y, groups)</div>
<div class="line"><span class="lineno">  283</span>    )</div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>    _warn_or_raise_about_fit_failures(results, error_score)</div>
<div class="line"><span class="lineno">  286</span> </div>
<div class="line"><span class="lineno">  287</span>    <span class="comment"># For callabe scoring, the return type is only know after calling. If the</span></div>
<div class="line"><span class="lineno">  288</span>    <span class="comment"># return type is a dictionary, the error scores can now be inserted with</span></div>
<div class="line"><span class="lineno">  289</span>    <span class="comment"># the correct key.</span></div>
<div class="line"><span class="lineno">  290</span>    <span class="keywordflow">if</span> callable(scoring):</div>
<div class="line"><span class="lineno">  291</span>        _insert_error_scores(results, error_score)</div>
<div class="line"><span class="lineno">  292</span> </div>
<div class="line"><span class="lineno">  293</span>    results = _aggregate_score_dicts(results)</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>    ret = {}</div>
<div class="line"><span class="lineno">  296</span>    ret[<span class="stringliteral">&quot;fit_time&quot;</span>] = results[<span class="stringliteral">&quot;fit_time&quot;</span>]</div>
<div class="line"><span class="lineno">  297</span>    ret[<span class="stringliteral">&quot;score_time&quot;</span>] = results[<span class="stringliteral">&quot;score_time&quot;</span>]</div>
<div class="line"><span class="lineno">  298</span> </div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">if</span> return_estimator:</div>
<div class="line"><span class="lineno">  300</span>        ret[<span class="stringliteral">&quot;estimator&quot;</span>] = results[<span class="stringliteral">&quot;estimator&quot;</span>]</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>    test_scores_dict = _normalize_score_results(results[<span class="stringliteral">&quot;test_scores&quot;</span>])</div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  304</span>        train_scores_dict = _normalize_score_results(results[<span class="stringliteral">&quot;train_scores&quot;</span>])</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span>    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> test_scores_dict:</div>
<div class="line"><span class="lineno">  307</span>        ret[<span class="stringliteral">&quot;test_%s&quot;</span> % name] = test_scores_dict[name]</div>
<div class="line"><span class="lineno">  308</span>        <span class="keywordflow">if</span> return_train_score:</div>
<div class="line"><span class="lineno">  309</span>            key = <span class="stringliteral">&quot;train_%s&quot;</span> % name</div>
<div class="line"><span class="lineno">  310</span>            ret[key] = train_scores_dict[name]</div>
<div class="line"><span class="lineno">  311</span> </div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa260a7af36af950ca21d45d53d9c6a40" name="aa260a7af36af950ca21d45d53d9c6a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa260a7af36af950ca21d45d53d9c6a40">&#9670;&#160;</a></span>learning_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation.learning_curve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>groups</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>train_sizes</em> = <code>np.linspace(0.1,&#160;1.0,&#160;5)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cv</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scoring</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exploit_incremental_learning</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pre_dispatch</em> = <code>&quot;all&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shuffle</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em> = <code>np.nan</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_times</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Learning curve.

Determines cross-validated training and test scores for different training
set sizes.

A cross-validation generator splits the whole dataset k times in training
and test data. Subsets of the training set with varying sizes will be used
to train the estimator and a score for each training subset size and the
test set will be computed. Afterwards, the scores will be averaged over
all k runs for each training subset size.

Read more in the :ref:`User Guide &lt;learning_curve&gt;`.

Parameters
----------
estimator : object type that implements the "fit" and "predict" methods
    An object of that type which is cloned for each validation.

X : array-like of shape (n_samples, n_features)
    Training vector, where `n_samples` is the number of samples and
    `n_features` is the number of features.

y : array-like of shape (n_samples,) or (n_samples, n_outputs)
    Target relative to X for classification or regression;
    None for unsupervised learning.

groups : array-like of  shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

train_sizes : array-like of shape (n_ticks,), \
        default=np.linspace(0.1, 1.0, 5)
    Relative or absolute numbers of training examples that will be used to
    generate the learning curve. If the dtype is float, it is regarded as a
    fraction of the maximum size of the training set (that is determined
    by the selected validation method), i.e. it has to be within (0, 1].
    Otherwise it is interpreted as absolute sizes of the training sets.
    Note that for classification the number of samples usually have to
    be big enough to contain at least one sample from each class.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

scoring : str or callable, default=None
    A str (see model evaluation documentation) or
    a scorer callable object / function with signature
    ``scorer(estimator, X, y)``.

exploit_incremental_learning : bool, default=False
    If the estimator supports incremental learning, this will be
    used to speed up fitting for different training set sizes.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the different training and test sets.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

pre_dispatch : int or str, default='all'
    Number of predispatched jobs for parallel execution (default is
    all). The option can reduce the allocated memory. The str can
    be an expression like '2*n_jobs'.

verbose : int, default=0
    Controls the verbosity: the higher, the more messages.

shuffle : bool, default=False
    Whether to shuffle training data before taking prefixes of it
    based on``train_sizes``.

random_state : int, RandomState instance or None, default=None
    Used when ``shuffle`` is True. Pass an int for reproducible
    output across multiple function calls.
    See :term:`Glossary &lt;random_state&gt;`.

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

return_times : bool, default=False
    Whether to return the fit and score times.

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

    .. versionadded:: 0.24

Returns
-------
train_sizes_abs : array of shape (n_unique_ticks,)
    Numbers of training examples that has been used to generate the
    learning curve. Note that the number of ticks might be less
    than n_ticks because duplicate entries will be removed.

train_scores : array of shape (n_ticks, n_cv_folds)
    Scores on training sets.

test_scores : array of shape (n_ticks, n_cv_folds)
    Scores on test set.

fit_times : array of shape (n_ticks, n_cv_folds)
    Times spent for fitting in seconds. Only present if ``return_times``
    is True.

score_times : array of shape (n_ticks, n_cv_folds)
    Times spent for scoring in seconds. Only present if ``return_times``
    is True.

Examples
--------
&gt;&gt;&gt; from sklearn.datasets import make_classification
&gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier
&gt;&gt;&gt; from sklearn.model_selection import learning_curve
&gt;&gt;&gt; X, y = make_classification(n_samples=100, n_features=10, random_state=42)
&gt;&gt;&gt; tree = DecisionTreeClassifier(max_depth=4, random_state=42)
&gt;&gt;&gt; train_size_abs, train_scores, test_scores = learning_curve(
...     tree, X, y, train_sizes=[0.3, 0.6, 0.9]
... )
&gt;&gt;&gt; for train_size, cv_train_scores, cv_test_scores in zip(
...     train_size_abs, train_scores, test_scores
... ):
...     print(f"{train_size} samples were used to train the model")
...     print(f"The average train accuracy is {cv_train_scores.mean():.2f}")
...     print(f"The average test accuracy is {cv_test_scores.mean():.2f}")
24 samples were used to train the model
The average train accuracy is 1.00
The average test accuracy is 0.85
48 samples were used to train the model
The average train accuracy is 1.00
The average test accuracy is 0.90
72 samples were used to train the model
The average train accuracy is 1.00
The average test accuracy is 0.93
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1368</span>):</div>
<div class="line"><span class="lineno"> 1369</span>    <span class="stringliteral">&quot;&quot;&quot;Learning curve.</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    Determines cross-validated training and test scores for different training</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    set sizes.</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    A cross-validation generator splits the whole dataset k times in training</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    and test data. Subsets of the training set with varying sizes will be used</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    to train the estimator and a score for each training subset size and the</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">    test set will be computed. Afterwards, the scores will be averaged over</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">    all k runs for each training subset size.</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;learning_curve&gt;`.</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">    estimator : object type that implements the &quot;fit&quot; and &quot;predict&quot; methods</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">        An object of that type which is cloned for each validation.</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">        Training vector, where `n_samples` is the number of samples and</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">        `n_features` is the number of features.</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs)</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">        Target relative to X for classification or regression;</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">        None for unsupervised learning.</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    groups : array-like of  shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">        Group labels for the samples used while splitting the dataset into</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv`</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">        instance (e.g., :class:`GroupKFold`).</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    train_sizes : array-like of shape (n_ticks,), \</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">            default=np.linspace(0.1, 1.0, 5)</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">        Relative or absolute numbers of training examples that will be used to</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">        generate the learning curve. If the dtype is float, it is regarded as a</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">        fraction of the maximum size of the training set (that is determined</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">        by the selected validation method), i.e. it has to be within (0, 1].</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral">        Otherwise it is interpreted as absolute sizes of the training sets.</span></div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">        Note that for classification the number of samples usually have to</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">        be big enough to contain at least one sample from each class.</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    cv : int, cross-validation generator or an iterable, default=None</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">        Determines the cross-validation splitting strategy.</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">        Possible inputs for cv are:</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">        - None, to use the default 5-fold cross validation,</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">        - int, to specify the number of folds in a `(Stratified)KFold`,</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">        - :term:`CV splitter`,</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">        - An iterable yielding (train, test) splits as arrays of indices.</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">        For int/None inputs, if the estimator is a classifier and ``y`` is</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">        either binary or multiclass, :class:`StratifiedKFold` is used. In all</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">        other cases, :class:`KFold` is used. These splitters are instantiated</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">        with `shuffle=False` so the splits will be the same across calls.</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">        cross-validation strategies that can be used here.</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">            ``cv`` default value if None changed from 3-fold to 5-fold.</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    scoring : str or callable, default=None</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">        A str (see model evaluation documentation) or</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">        a scorer callable object / function with signature</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">        ``scorer(estimator, X, y)``.</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    exploit_incremental_learning : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">        If the estimator supports incremental learning, this will be</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">        used to speed up fitting for different training set sizes.</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">        Number of jobs to run in parallel. Training the estimator and computing</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">        the score are parallelized over the different training and test sets.</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    pre_dispatch : int or str, default=&#39;all&#39;</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">        Number of predispatched jobs for parallel execution (default is</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">        all). The option can reduce the allocated memory. The str can</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">        be an expression like &#39;2*n_jobs&#39;.</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">    verbose : int, default=0</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">        Controls the verbosity: the higher, the more messages.</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">    shuffle : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">        Whether to shuffle training data before taking prefixes of it</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">        based on``train_sizes``.</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">    random_state : int, RandomState instance or None, default=None</span></div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">        Used when ``shuffle`` is True. Pass an int for reproducible</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">        output across multiple function calls.</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">        See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">    error_score : &#39;raise&#39; or numeric, default=np.nan</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">        Value to assign to the score if an error occurs in estimator fitting.</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">        If set to &#39;raise&#39;, the error is raised.</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">        If a numeric value is given, FitFailedWarning is raised.</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">    return_times : bool, default=False</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">        Whether to return the fit and score times.</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">    fit_params : dict, default=None</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">        Parameters to pass to the fit method of the estimator.</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">        .. versionadded:: 0.24</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">    train_sizes_abs : array of shape (n_unique_ticks,)</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">        Numbers of training examples that has been used to generate the</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">        learning curve. Note that the number of ticks might be less</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">        than n_ticks because duplicate entries will be removed.</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">    train_scores : array of shape (n_ticks, n_cv_folds)</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">        Scores on training sets.</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">    test_scores : array of shape (n_ticks, n_cv_folds)</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">        Scores on test set.</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">    fit_times : array of shape (n_ticks, n_cv_folds)</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">        Times spent for fitting in seconds. Only present if ``return_times``</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">        is True.</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">    score_times : array of shape (n_ticks, n_cv_folds)</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">        Times spent for scoring in seconds. Only present if ``return_times``</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">        is True.</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.datasets import make_classification</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    &gt;&gt;&gt; from sklearn.model_selection import learning_curve</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    &gt;&gt;&gt; X, y = make_classification(n_samples=100, n_features=10, random_state=42)</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    &gt;&gt;&gt; tree = DecisionTreeClassifier(max_depth=4, random_state=42)</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">    &gt;&gt;&gt; train_size_abs, train_scores, test_scores = learning_curve(</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    ...     tree, X, y, train_sizes=[0.3, 0.6, 0.9]</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    &gt;&gt;&gt; for train_size, cv_train_scores, cv_test_scores in zip(</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    ...     train_size_abs, train_scores, test_scores</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    ... ):</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">    ...     print(f&quot;{train_size} samples were used to train the model&quot;)</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    ...     print(f&quot;The average train accuracy is {cv_train_scores.mean():.2f}&quot;)</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">    ...     print(f&quot;The average test accuracy is {cv_test_scores.mean():.2f}&quot;)</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">    24 samples were used to train the model</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">    The average train accuracy is 1.00</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    The average test accuracy is 0.85</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">    48 samples were used to train the model</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">    The average train accuracy is 1.00</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    The average test accuracy is 0.90</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    72 samples were used to train the model</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    The average train accuracy is 1.00</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">    The average test accuracy is 0.93</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1525</span>    <span class="keywordflow">if</span> exploit_incremental_learning <span class="keywordflow">and</span> <span class="keywordflow">not</span> hasattr(estimator, <span class="stringliteral">&quot;partial_fit&quot;</span>):</div>
<div class="line"><span class="lineno"> 1526</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1527</span>            <span class="stringliteral">&quot;An estimator must support the partial_fit interface &quot;</span></div>
<div class="line"><span class="lineno"> 1528</span>            <span class="stringliteral">&quot;to exploit incremental learning&quot;</span></div>
<div class="line"><span class="lineno"> 1529</span>        )</div>
<div class="line"><span class="lineno"> 1530</span>    X, y, groups = indexable(X, y, groups)</div>
<div class="line"><span class="lineno"> 1531</span> </div>
<div class="line"><span class="lineno"> 1532</span>    cv = check_cv(cv, y, classifier=is_classifier(estimator))</div>
<div class="line"><span class="lineno"> 1533</span>    <span class="comment"># Store it as list as we will be iterating over the list multiple times</span></div>
<div class="line"><span class="lineno"> 1534</span>    cv_iter = list(cv.split(X, y, groups))</div>
<div class="line"><span class="lineno"> 1535</span> </div>
<div class="line"><span class="lineno"> 1536</span>    scorer = check_scoring(estimator, scoring=scoring)</div>
<div class="line"><span class="lineno"> 1537</span> </div>
<div class="line"><span class="lineno"> 1538</span>    n_max_training_samples = len(cv_iter[0][0])</div>
<div class="line"><span class="lineno"> 1539</span>    <span class="comment"># Because the lengths of folds can be significantly different, it is</span></div>
<div class="line"><span class="lineno"> 1540</span>    <span class="comment"># not guaranteed that we use all of the available training data when we</span></div>
<div class="line"><span class="lineno"> 1541</span>    <span class="comment"># use the first &#39;n_max_training_samples&#39; samples.</span></div>
<div class="line"><span class="lineno"> 1542</span>    train_sizes_abs = _translate_train_sizes(train_sizes, n_max_training_samples)</div>
<div class="line"><span class="lineno"> 1543</span>    n_unique_ticks = train_sizes_abs.shape[0]</div>
<div class="line"><span class="lineno"> 1544</span>    <span class="keywordflow">if</span> verbose &gt; 0:</div>
<div class="line"><span class="lineno"> 1545</span>        print(<span class="stringliteral">&quot;[learning_curve] Training set sizes: &quot;</span> + str(train_sizes_abs))</div>
<div class="line"><span class="lineno"> 1546</span> </div>
<div class="line"><span class="lineno"> 1547</span>    parallel = Parallel(n_jobs=n_jobs, pre_dispatch=pre_dispatch, verbose=verbose)</div>
<div class="line"><span class="lineno"> 1548</span> </div>
<div class="line"><span class="lineno"> 1549</span>    <span class="keywordflow">if</span> shuffle:</div>
<div class="line"><span class="lineno"> 1550</span>        rng = check_random_state(random_state)</div>
<div class="line"><span class="lineno"> 1551</span>        cv_iter = ((rng.permutation(train), test) <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> cv_iter)</div>
<div class="line"><span class="lineno"> 1552</span> </div>
<div class="line"><span class="lineno"> 1553</span>    <span class="keywordflow">if</span> exploit_incremental_learning:</div>
<div class="line"><span class="lineno"> 1554</span>        classes = np.unique(y) <span class="keywordflow">if</span> is_classifier(estimator) <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1555</span>        out = parallel(</div>
<div class="line"><span class="lineno"> 1556</span>            delayed(_incremental_fit_estimator)(</div>
<div class="line"><span class="lineno"> 1557</span>                clone(estimator),</div>
<div class="line"><span class="lineno"> 1558</span>                X,</div>
<div class="line"><span class="lineno"> 1559</span>                y,</div>
<div class="line"><span class="lineno"> 1560</span>                classes,</div>
<div class="line"><span class="lineno"> 1561</span>                train,</div>
<div class="line"><span class="lineno"> 1562</span>                test,</div>
<div class="line"><span class="lineno"> 1563</span>                train_sizes_abs,</div>
<div class="line"><span class="lineno"> 1564</span>                scorer,</div>
<div class="line"><span class="lineno"> 1565</span>                verbose,</div>
<div class="line"><span class="lineno"> 1566</span>                return_times,</div>
<div class="line"><span class="lineno"> 1567</span>                error_score=error_score,</div>
<div class="line"><span class="lineno"> 1568</span>                fit_params=fit_params,</div>
<div class="line"><span class="lineno"> 1569</span>            )</div>
<div class="line"><span class="lineno"> 1570</span>            <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> cv_iter</div>
<div class="line"><span class="lineno"> 1571</span>        )</div>
<div class="line"><span class="lineno"> 1572</span>        out = np.asarray(out).transpose((2, 1, 0))</div>
<div class="line"><span class="lineno"> 1573</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1574</span>        train_test_proportions = []</div>
<div class="line"><span class="lineno"> 1575</span>        <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> cv_iter:</div>
<div class="line"><span class="lineno"> 1576</span>            <span class="keywordflow">for</span> n_train_samples <span class="keywordflow">in</span> train_sizes_abs:</div>
<div class="line"><span class="lineno"> 1577</span>                train_test_proportions.append((train[:n_train_samples], test))</div>
<div class="line"><span class="lineno"> 1578</span> </div>
<div class="line"><span class="lineno"> 1579</span>        results = parallel(</div>
<div class="line"><span class="lineno"> 1580</span>            delayed(_fit_and_score)(</div>
<div class="line"><span class="lineno"> 1581</span>                clone(estimator),</div>
<div class="line"><span class="lineno"> 1582</span>                X,</div>
<div class="line"><span class="lineno"> 1583</span>                y,</div>
<div class="line"><span class="lineno"> 1584</span>                scorer,</div>
<div class="line"><span class="lineno"> 1585</span>                train,</div>
<div class="line"><span class="lineno"> 1586</span>                test,</div>
<div class="line"><span class="lineno"> 1587</span>                verbose,</div>
<div class="line"><span class="lineno"> 1588</span>                parameters=<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno"> 1589</span>                fit_params=fit_params,</div>
<div class="line"><span class="lineno"> 1590</span>                return_train_score=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 1591</span>                error_score=error_score,</div>
<div class="line"><span class="lineno"> 1592</span>                return_times=return_times,</div>
<div class="line"><span class="lineno"> 1593</span>            )</div>
<div class="line"><span class="lineno"> 1594</span>            <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> train_test_proportions</div>
<div class="line"><span class="lineno"> 1595</span>        )</div>
<div class="line"><span class="lineno"> 1596</span>        results = _aggregate_score_dicts(results)</div>
<div class="line"><span class="lineno"> 1597</span>        train_scores = results[<span class="stringliteral">&quot;train_scores&quot;</span>].reshape(-1, n_unique_ticks).T</div>
<div class="line"><span class="lineno"> 1598</span>        test_scores = results[<span class="stringliteral">&quot;test_scores&quot;</span>].reshape(-1, n_unique_ticks).T</div>
<div class="line"><span class="lineno"> 1599</span>        out = [train_scores, test_scores]</div>
<div class="line"><span class="lineno"> 1600</span> </div>
<div class="line"><span class="lineno"> 1601</span>        <span class="keywordflow">if</span> return_times:</div>
<div class="line"><span class="lineno"> 1602</span>            fit_times = results[<span class="stringliteral">&quot;fit_time&quot;</span>].reshape(-1, n_unique_ticks).T</div>
<div class="line"><span class="lineno"> 1603</span>            score_times = results[<span class="stringliteral">&quot;score_time&quot;</span>].reshape(-1, n_unique_ticks).T</div>
<div class="line"><span class="lineno"> 1604</span>            out.extend([fit_times, score_times])</div>
<div class="line"><span class="lineno"> 1605</span> </div>
<div class="line"><span class="lineno"> 1606</span>    ret = train_sizes_abs, out[0], out[1]</div>
<div class="line"><span class="lineno"> 1607</span> </div>
<div class="line"><span class="lineno"> 1608</span>    <span class="keywordflow">if</span> return_times:</div>
<div class="line"><span class="lineno"> 1609</span>        ret = ret + (out[2], out[3])</div>
<div class="line"><span class="lineno"> 1610</span> </div>
<div class="line"><span class="lineno"> 1611</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 1612</span> </div>
<div class="line"><span class="lineno"> 1613</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a76eb6157ce60419759508751e5491ad0" name="a76eb6157ce60419759508751e5491ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76eb6157ce60419759508751e5491ad0">&#9670;&#160;</a></span>permutation_test_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation.permutation_test_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>groups</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cv</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_permutations</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scoring</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate the significance of a cross-validated score with permutations.

Permutes targets to generate 'randomized data' and compute the empirical
p-value against the null hypothesis that features and targets are
independent.

The p-value represents the fraction of randomized data sets where the
estimator performed as well or better than in the original data. A small
p-value suggests that there is a real dependency between features and
targets which has been used by the estimator to give good predictions.
A large p-value may be due to lack of real dependency between features
and targets or the estimator was not able to use the dependency to
give good predictions.

Read more in the :ref:`User Guide &lt;permutation_test_score&gt;`.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : array-like of shape at least 2D
    The data to fit.

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Labels to constrain permutation within groups, i.e. ``y`` values
    are permuted among samples with the same group identifier.
    When not specified, ``y`` values are permuted among all samples.

    When a grouped cross-validator is used, the group labels are
    also passed on to the ``split`` method of the cross-validator. The
    cross-validator uses them for grouping the samples  while splitting
    the dataset into train/test set.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - `None`, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For `int`/`None` inputs, if the estimator is a classifier and `y` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        `cv` default value if `None` changed from 3-fold to 5-fold.

n_permutations : int, default=100
    Number of times to permute ``y``.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the cross-validated score are parallelized over the permutations.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

random_state : int, RandomState instance or None, default=0
    Pass an int for reproducible output for permutation of
    ``y`` values among samples. See :term:`Glossary &lt;random_state&gt;`.

verbose : int, default=0
    The verbosity level.

scoring : str or callable, default=None
    A single str (see :ref:`scoring_parameter`) or a callable
    (see :ref:`scoring`) to evaluate the predictions on the test set.

    If `None` the estimator's score method is used.

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

    .. versionadded:: 0.24

Returns
-------
score : float
    The true score without permuting targets.

permutation_scores : array of shape (n_permutations,)
    The scores obtained for each permutations.

pvalue : float
    The p-value, which approximates the probability that the score would
    be obtained by chance. This is calculated as:

    `(C + 1) / (n_permutations + 1)`

    Where C is the number of permutations whose score &gt;= the true score.

    The best possible p-value is 1/(n_permutations + 1), the worst is 1.0.

Notes
-----
This function implements Test 1 in:

    Ojala and Garriga. `Permutation Tests for Studying Classifier
    Performance
    &lt;http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf&gt;`_. The
    Journal of Machine Learning Research (2010) vol. 11
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1182</span>):</div>
<div class="line"><span class="lineno"> 1183</span>    <span class="stringliteral">&quot;&quot;&quot;Evaluate the significance of a cross-validated score with permutations.</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    Permutes targets to generate &#39;randomized data&#39; and compute the empirical</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    p-value against the null hypothesis that features and targets are</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    independent.</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    The p-value represents the fraction of randomized data sets where the</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    estimator performed as well or better than in the original data. A small</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    p-value suggests that there is a real dependency between features and</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    targets which has been used by the estimator to give good predictions.</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    A large p-value may be due to lack of real dependency between features</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    and targets or the estimator was not able to use the dependency to</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    give good predictions.</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;permutation_test_score&gt;`.</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    estimator : estimator object implementing &#39;fit&#39;</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">        The object to use to fit the data.</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    X : array-like of shape at least 2D</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">        The data to fit.</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">        The target variable to try to predict in the case of</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">        supervised learning.</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    groups : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">        Labels to constrain permutation within groups, i.e. ``y`` values</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">        are permuted among samples with the same group identifier.</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">        When not specified, ``y`` values are permuted among all samples.</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">        When a grouped cross-validator is used, the group labels are</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">        also passed on to the ``split`` method of the cross-validator. The</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">        cross-validator uses them for grouping the samples  while splitting</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">        the dataset into train/test set.</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">    cv : int, cross-validation generator or an iterable, default=None</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">        Determines the cross-validation splitting strategy.</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">        Possible inputs for cv are:</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">        - `None`, to use the default 5-fold cross validation,</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">        - int, to specify the number of folds in a `(Stratified)KFold`,</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">        - :term:`CV splitter`,</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">        - An iterable yielding (train, test) splits as arrays of indices.</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">        For `int`/`None` inputs, if the estimator is a classifier and `y` is</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">        either binary or multiclass, :class:`StratifiedKFold` is used. In all</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">        other cases, :class:`KFold` is used. These splitters are instantiated</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">        with `shuffle=False` so the splits will be the same across calls.</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">        cross-validation strategies that can be used here.</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">            `cv` default value if `None` changed from 3-fold to 5-fold.</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    n_permutations : int, default=100</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">        Number of times to permute ``y``.</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">        Number of jobs to run in parallel. Training the estimator and computing</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">        the cross-validated score are parallelized over the permutations.</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">    random_state : int, RandomState instance or None, default=0</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">        Pass an int for reproducible output for permutation of</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">        ``y`` values among samples. See :term:`Glossary &lt;random_state&gt;`.</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    verbose : int, default=0</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">        The verbosity level.</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    scoring : str or callable, default=None</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">        A single str (see :ref:`scoring_parameter`) or a callable</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">        (see :ref:`scoring`) to evaluate the predictions on the test set.</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">        If `None` the estimator&#39;s score method is used.</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    fit_params : dict, default=None</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">        Parameters to pass to the fit method of the estimator.</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">        .. versionadded:: 0.24</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    score : float</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">        The true score without permuting targets.</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    permutation_scores : array of shape (n_permutations,)</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">        The scores obtained for each permutations.</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">        The p-value, which approximates the probability that the score would</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">        be obtained by chance. This is calculated as:</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">        `(C + 1) / (n_permutations + 1)`</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">        Where C is the number of permutations whose score &gt;= the true score.</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        The best possible p-value is 1/(n_permutations + 1), the worst is 1.0.</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    This function implements Test 1 in:</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">        Ojala and Garriga. `Permutation Tests for Studying Classifier</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">        Performance</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">        &lt;http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf&gt;`_. The</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">        Journal of Machine Learning Research (2010) vol. 11</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1296</span>    X, y, groups = indexable(X, y, groups)</div>
<div class="line"><span class="lineno"> 1297</span> </div>
<div class="line"><span class="lineno"> 1298</span>    cv = check_cv(cv, y, classifier=is_classifier(estimator))</div>
<div class="line"><span class="lineno"> 1299</span>    scorer = check_scoring(estimator, scoring=scoring)</div>
<div class="line"><span class="lineno"> 1300</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno"> 1301</span> </div>
<div class="line"><span class="lineno"> 1302</span>    <span class="comment"># We clone the estimator to make sure that all the folds are</span></div>
<div class="line"><span class="lineno"> 1303</span>    <span class="comment"># independent, and that it is pickle-able.</span></div>
<div class="line"><span class="lineno"> 1304</span>    score = _permutation_test_score(</div>
<div class="line"><span class="lineno"> 1305</span>        clone(estimator), X, y, groups, cv, scorer, fit_params=fit_params</div>
<div class="line"><span class="lineno"> 1306</span>    )</div>
<div class="line"><span class="lineno"> 1307</span>    permutation_scores = Parallel(n_jobs=n_jobs, verbose=verbose)(</div>
<div class="line"><span class="lineno"> 1308</span>        delayed(_permutation_test_score)(</div>
<div class="line"><span class="lineno"> 1309</span>            clone(estimator),</div>
<div class="line"><span class="lineno"> 1310</span>            X,</div>
<div class="line"><span class="lineno"> 1311</span>            _shuffle(y, groups, random_state),</div>
<div class="line"><span class="lineno"> 1312</span>            groups,</div>
<div class="line"><span class="lineno"> 1313</span>            cv,</div>
<div class="line"><span class="lineno"> 1314</span>            scorer,</div>
<div class="line"><span class="lineno"> 1315</span>            fit_params=fit_params,</div>
<div class="line"><span class="lineno"> 1316</span>        )</div>
<div class="line"><span class="lineno"> 1317</span>        <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(n_permutations)</div>
<div class="line"><span class="lineno"> 1318</span>    )</div>
<div class="line"><span class="lineno"> 1319</span>    permutation_scores = np.array(permutation_scores)</div>
<div class="line"><span class="lineno"> 1320</span>    pvalue = (np.sum(permutation_scores &gt;= score) + 1.0) / (n_permutations + 1)</div>
<div class="line"><span class="lineno"> 1321</span>    <span class="keywordflow">return</span> score, permutation_scores, pvalue</div>
<div class="line"><span class="lineno"> 1322</span> </div>
<div class="line"><span class="lineno"> 1323</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6249c5f667d0d4a04f281013a9cc8b35" name="a6249c5f667d0d4a04f281013a9cc8b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6249c5f667d0d4a04f281013a9cc8b35">&#9670;&#160;</a></span>validation_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.model_selection._validation.validation_curve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>estimator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>groups</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cv</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scoring</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_jobs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pre_dispatch</em> = <code>&quot;all&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_score</em> = <code>np.nan</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fit_params</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Validation curve.

Determine training and test scores for varying parameter values.

Compute scores for an estimator with different values of a specified
parameter. This is similar to grid search with one parameter. However, this
will also compute training scores and is merely a utility for plotting the
results.

Read more in the :ref:`User Guide &lt;validation_curve&gt;`.

Parameters
----------
estimator : object type that implements the "fit" and "predict" methods
    An object of that type which is cloned for each validation.

X : array-like of shape (n_samples, n_features)
    Training vector, where `n_samples` is the number of samples and
    `n_features` is the number of features.

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    Target relative to X for classification or regression;
    None for unsupervised learning.

param_name : str
    Name of the parameter that will be varied.

param_range : array-like of shape (n_values,)
    The values of the parameter that will be evaluated.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

scoring : str or callable, default=None
    A str (see model evaluation documentation) or
    a scorer callable object / function with signature
    ``scorer(estimator, X, y)``.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the combinations of each parameter
    value and each cross-validation split.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

pre_dispatch : int or str, default='all'
    Number of predispatched jobs for parallel execution (default is
    all). The option can reduce the allocated memory. The str can
    be an expression like '2*n_jobs'.

verbose : int, default=0
    Controls the verbosity: the higher, the more messages.

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

    .. versionadded:: 0.24

Returns
-------
train_scores : array of shape (n_ticks, n_cv_folds)
    Scores on training sets.

test_scores : array of shape (n_ticks, n_cv_folds)
    Scores on test set.

Notes
-----
See :ref:`sphx_glr_auto_examples_model_selection_plot_validation_curve.py`
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1751</span>):</div>
<div class="line"><span class="lineno"> 1752</span>    <span class="stringliteral">&quot;&quot;&quot;Validation curve.</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">    Determine training and test scores for varying parameter values.</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral">    Compute scores for an estimator with different values of a specified</span></div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">    parameter. This is similar to grid search with one parameter. However, this</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">    will also compute training scores and is merely a utility for plotting the</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">    results.</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;validation_curve&gt;`.</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    estimator : object type that implements the &quot;fit&quot; and &quot;predict&quot; methods</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">        An object of that type which is cloned for each validation.</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">    X : array-like of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">        Training vector, where `n_samples` is the number of samples and</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral">        `n_features` is the number of features.</span></div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">        Target relative to X for classification or regression;</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">        None for unsupervised learning.</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">    param_name : str</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">        Name of the parameter that will be varied.</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">    param_range : array-like of shape (n_values,)</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">        The values of the parameter that will be evaluated.</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">    groups : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">        Group labels for the samples used while splitting the dataset into</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv`</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">        instance (e.g., :class:`GroupKFold`).</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">    cv : int, cross-validation generator or an iterable, default=None</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">        Determines the cross-validation splitting strategy.</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">        Possible inputs for cv are:</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">        - None, to use the default 5-fold cross validation,</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">        - int, to specify the number of folds in a `(Stratified)KFold`,</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">        - :term:`CV splitter`,</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">        - An iterable yielding (train, test) splits as arrays of indices.</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">        For int/None inputs, if the estimator is a classifier and ``y`` is</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">        either binary or multiclass, :class:`StratifiedKFold` is used. In all</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">        other cases, :class:`KFold` is used. These splitters are instantiated</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">        with `shuffle=False` so the splits will be the same across calls.</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        cross-validation strategies that can be used here.</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">        .. versionchanged:: 0.22</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">            ``cv`` default value if None changed from 3-fold to 5-fold.</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">    scoring : str or callable, default=None</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">        A str (see model evaluation documentation) or</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">        a scorer callable object / function with signature</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">        ``scorer(estimator, X, y)``.</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">    n_jobs : int, default=None</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">        Number of jobs to run in parallel. Training the estimator and computing</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">        the score are parallelized over the combinations of each parameter</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">        value and each cross-validation split.</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">        for more details.</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">    pre_dispatch : int or str, default=&#39;all&#39;</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">        Number of predispatched jobs for parallel execution (default is</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">        all). The option can reduce the allocated memory. The str can</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">        be an expression like &#39;2*n_jobs&#39;.</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    verbose : int, default=0</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">        Controls the verbosity: the higher, the more messages.</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    error_score : &#39;raise&#39; or numeric, default=np.nan</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        Value to assign to the score if an error occurs in estimator fitting.</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">        If set to &#39;raise&#39;, the error is raised.</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">        If a numeric value is given, FitFailedWarning is raised.</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">        .. versionadded:: 0.20</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    fit_params : dict, default=None</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">        Parameters to pass to the fit method of the estimator.</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">        .. versionadded:: 0.24</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">    train_scores : array of shape (n_ticks, n_cv_folds)</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">        Scores on training sets.</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">    test_scores : array of shape (n_ticks, n_cv_folds)</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">        Scores on test set.</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">    See :ref:`sphx_glr_auto_examples_model_selection_plot_validation_curve.py`</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1852</span>    X, y, groups = indexable(X, y, groups)</div>
<div class="line"><span class="lineno"> 1853</span> </div>
<div class="line"><span class="lineno"> 1854</span>    cv = check_cv(cv, y, classifier=is_classifier(estimator))</div>
<div class="line"><span class="lineno"> 1855</span>    scorer = check_scoring(estimator, scoring=scoring)</div>
<div class="line"><span class="lineno"> 1856</span> </div>
<div class="line"><span class="lineno"> 1857</span>    parallel = Parallel(n_jobs=n_jobs, pre_dispatch=pre_dispatch, verbose=verbose)</div>
<div class="line"><span class="lineno"> 1858</span>    results = parallel(</div>
<div class="line"><span class="lineno"> 1859</span>        delayed(_fit_and_score)(</div>
<div class="line"><span class="lineno"> 1860</span>            clone(estimator),</div>
<div class="line"><span class="lineno"> 1861</span>            X,</div>
<div class="line"><span class="lineno"> 1862</span>            y,</div>
<div class="line"><span class="lineno"> 1863</span>            scorer,</div>
<div class="line"><span class="lineno"> 1864</span>            train,</div>
<div class="line"><span class="lineno"> 1865</span>            test,</div>
<div class="line"><span class="lineno"> 1866</span>            verbose,</div>
<div class="line"><span class="lineno"> 1867</span>            parameters={param_name: v},</div>
<div class="line"><span class="lineno"> 1868</span>            fit_params=fit_params,</div>
<div class="line"><span class="lineno"> 1869</span>            return_train_score=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 1870</span>            error_score=error_score,</div>
<div class="line"><span class="lineno"> 1871</span>        )</div>
<div class="line"><span class="lineno"> 1872</span>        <span class="comment"># NOTE do not change order of iteration to allow one time cv splitters</span></div>
<div class="line"><span class="lineno"> 1873</span>        <span class="keywordflow">for</span> train, test <span class="keywordflow">in</span> cv.split(X, y, groups)</div>
<div class="line"><span class="lineno"> 1874</span>        <span class="keywordflow">for</span> v <span class="keywordflow">in</span> param_range</div>
<div class="line"><span class="lineno"> 1875</span>    )</div>
<div class="line"><span class="lineno"> 1876</span>    n_params = len(param_range)</div>
<div class="line"><span class="lineno"> 1877</span> </div>
<div class="line"><span class="lineno"> 1878</span>    results = _aggregate_score_dicts(results)</div>
<div class="line"><span class="lineno"> 1879</span>    train_scores = results[<span class="stringliteral">&quot;train_scores&quot;</span>].reshape(-1, n_params).T</div>
<div class="line"><span class="lineno"> 1880</span>    test_scores = results[<span class="stringliteral">&quot;test_scores&quot;</span>].reshape(-1, n_params).T</div>
<div class="line"><span class="lineno"> 1881</span> </div>
<div class="line"><span class="lineno"> 1882</span>    <span class="keywordflow">return</span> train_scores, test_scores</div>
<div class="line"><span class="lineno"> 1883</span> </div>
<div class="line"><span class="lineno"> 1884</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
