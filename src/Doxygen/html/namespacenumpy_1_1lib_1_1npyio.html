<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.npyio Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html">npyio</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.npyio Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1lib_1_1npyio_1_1_bag_obj.html">BagObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1lib_1_1npyio_1_1_npz_file.html">NpzFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40420dd827063c921cca501813d960f6" id="r_a40420dd827063c921cca501813d960f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a40420dd827063c921cca501813d960f6">zipfile_factory</a> (file, *args, **kwargs)</td></tr>
<tr class="separator:a40420dd827063c921cca501813d960f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b918dfbdf50ada7534496b983f6c2" id="r_aa81b918dfbdf50ada7534496b983f6c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#aa81b918dfbdf50ada7534496b983f6c2">load</a> (file, mmap_mode=None, allow_pickle=False, fix_imports=True, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>='ASCII', *max_header_size=<a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">format._MAX_HEADER_SIZE</a>)</td></tr>
<tr class="separator:aa81b918dfbdf50ada7534496b983f6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa772f19271f00ccb8ea23fbe10d4d032" id="r_aa772f19271f00ccb8ea23fbe10d4d032"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#aa772f19271f00ccb8ea23fbe10d4d032">_save_dispatcher</a> (file, arr, allow_pickle=None, fix_imports=None)</td></tr>
<tr class="separator:aa772f19271f00ccb8ea23fbe10d4d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b07013f27d7c0c9ba0271793142e96" id="r_ab4b07013f27d7c0c9ba0271793142e96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ab4b07013f27d7c0c9ba0271793142e96">save</a> (file, arr, allow_pickle=True, fix_imports=True)</td></tr>
<tr class="separator:ab4b07013f27d7c0c9ba0271793142e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60ab9e4383891290d66eeb4617078fc" id="r_ae60ab9e4383891290d66eeb4617078fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ae60ab9e4383891290d66eeb4617078fc">_savez_dispatcher</a> (file, *args, **kwds)</td></tr>
<tr class="separator:ae60ab9e4383891290d66eeb4617078fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c3515e60a095b2ad9fd4fc0c409bc2" id="r_a39c3515e60a095b2ad9fd4fc0c409bc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a39c3515e60a095b2ad9fd4fc0c409bc2">savez</a> (file, *args, **kwds)</td></tr>
<tr class="separator:a39c3515e60a095b2ad9fd4fc0c409bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686790f99dbf41e7752d70c660b6713" id="r_aa686790f99dbf41e7752d70c660b6713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#aa686790f99dbf41e7752d70c660b6713">_savez_compressed_dispatcher</a> (file, *args, **kwds)</td></tr>
<tr class="separator:aa686790f99dbf41e7752d70c660b6713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91da72dd133a0f84bf45d7dab5f1027" id="r_ac91da72dd133a0f84bf45d7dab5f1027"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ac91da72dd133a0f84bf45d7dab5f1027">savez_compressed</a> (file, *args, **kwds)</td></tr>
<tr class="separator:ac91da72dd133a0f84bf45d7dab5f1027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a3e1c8b264a24c94f7b9675f2e6fc" id="r_aa54a3e1c8b264a24c94f7b9675f2e6fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#aa54a3e1c8b264a24c94f7b9675f2e6fc">_savez</a> (file, args, kwds, <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a98e05aec90fc741f3919465d12b01193">compress</a>, allow_pickle=True, pickle_kwargs=None)</td></tr>
<tr class="separator:aa54a3e1c8b264a24c94f7b9675f2e6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44b424a5a604ed2cd99a2d04c6e53ff" id="r_ad44b424a5a604ed2cd99a2d04c6e53ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ad44b424a5a604ed2cd99a2d04c6e53ff">_ensure_ndmin_ndarray_check_param</a> (ndmin)</td></tr>
<tr class="separator:ad44b424a5a604ed2cd99a2d04c6e53ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5339e17afdf65e3e6f4767a979a23eb7" id="r_a5339e17afdf65e3e6f4767a979a23eb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a5339e17afdf65e3e6f4767a979a23eb7">_ensure_ndmin_ndarray</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, *int ndmin)</td></tr>
<tr class="separator:a5339e17afdf65e3e6f4767a979a23eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625aa65b5e47af9c6623cdc7ea7c214c" id="r_a625aa65b5e47af9c6623cdc7ea7c214c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a625aa65b5e47af9c6623cdc7ea7c214c">_loadtxt_dispatcher</a> (fname, dtype=None, comments=None, delimiter=None, converters=None, skiprows=None, usecols=None, unpack=None, ndmin=None, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>=None, max_rows=None, *like=None)</td></tr>
<tr class="separator:a625aa65b5e47af9c6623cdc7ea7c214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6962a7b6cb3e2b2f30861720f2669e3f" id="r_a6962a7b6cb3e2b2f30861720f2669e3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a6962a7b6cb3e2b2f30861720f2669e3f">_check_nonneg_int</a> (value, name=&quot;argument&quot;)</td></tr>
<tr class="separator:a6962a7b6cb3e2b2f30861720f2669e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2837737f330c3463197b6eec1c8b38" id="r_a8c2837737f330c3463197b6eec1c8b38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a8c2837737f330c3463197b6eec1c8b38">_preprocess_comments</a> (<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a531c572a52ebfaba6055e1d1b7c88ba2">iterable</a>, comments, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>)</td></tr>
<tr class="separator:a8c2837737f330c3463197b6eec1c8b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f1b3f82f05185e21e74428c8bc7c71" id="r_a58f1b3f82f05185e21e74428c8bc7c71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a58f1b3f82f05185e21e74428c8bc7c71">_read</a> (fname, *delimiter=',', comment='#', quote='&quot;',  imaginary_unit='<a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>',  usecols=None,  skiplines=0,  max_rows=None,  converters=None,  ndmin=None,  unpack=False,  dtype=np.float64,  <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>=&quot;bytes&quot;)</td></tr>
<tr class="separator:a58f1b3f82f05185e21e74428c8bc7c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1e1456f92798a1f66ace63eb6d15fe" id="r_abd1e1456f92798a1f66ace63eb6d15fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#abd1e1456f92798a1f66ace63eb6d15fe">loadtxt</a> (fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>='bytes', max_rows=None, *quotechar=None, like=None)</td></tr>
<tr class="separator:abd1e1456f92798a1f66ace63eb6d15fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac365d2221051f2d12d9a367fd37098b1" id="r_ac365d2221051f2d12d9a367fd37098b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ac365d2221051f2d12d9a367fd37098b1">_savetxt_dispatcher</a> (fname, X, fmt=None, delimiter=None, newline=None, header=None, footer=None, comments=None, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>=None)</td></tr>
<tr class="separator:ac365d2221051f2d12d9a367fd37098b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8a27ef9c03f4b55b953ed7fa392da5" id="r_a1e8a27ef9c03f4b55b953ed7fa392da5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a1e8a27ef9c03f4b55b953ed7fa392da5">savetxt</a> (fname, X, fmt='%.18e', delimiter=' ', newline='\<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>', header='', footer='', comments='# ', <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>=None)</td></tr>
<tr class="separator:a1e8a27ef9c03f4b55b953ed7fa392da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba7e0fde42aaae27092d97b2d260c90" id="r_adba7e0fde42aaae27092d97b2d260c90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#adba7e0fde42aaae27092d97b2d260c90">fromregex</a> (file, regexp, dtype, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>=None)</td></tr>
<tr class="separator:adba7e0fde42aaae27092d97b2d260c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0813bf6cba181c68ce24ed0c8cf7b64" id="r_ae0813bf6cba181c68ce24ed0c8cf7b64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ae0813bf6cba181c68ce24ed0c8cf7b64">_genfromtxt_dispatcher</a> (fname, dtype=None, comments=None, delimiter=None, skip_header=None, skip_footer=None, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space=None, autostrip=None, case_sensitive=None, defaultfmt=None, unpack=None, usemask=None, loose=None, invalid_raise=None, max_rows=None, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>=None, *ndmin=None, like=None)</td></tr>
<tr class="separator:ae0813bf6cba181c68ce24ed0c8cf7b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5208dfeb60eefd2703a34cba439f39e6" id="r_a5208dfeb60eefd2703a34cba439f39e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a5208dfeb60eefd2703a34cba439f39e6">genfromtxt</a> (fname, dtype=float, comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=''.join(sorted(<a class="el" href="classnumpy_1_1lib_1_1__iotools_1_1_name_validator.html#a25e444d6c4ace7882608a9217f475c34">NameValidator.defaultdeletechars</a>)), replace_space='_', autostrip=False, case_sensitive=True, defaultfmt=&quot;f%i&quot;, unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None, <a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a>='bytes', *ndmin=0, like=None)</td></tr>
<tr class="separator:a5208dfeb60eefd2703a34cba439f39e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318bbaf6cd6c026e209aaa78157b2464" id="r_a318bbaf6cd6c026e209aaa78157b2464"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a318bbaf6cd6c026e209aaa78157b2464">recfromtxt</a> (fname, **kwargs)</td></tr>
<tr class="separator:a318bbaf6cd6c026e209aaa78157b2464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e9c91952b27de66a0f62f8ca6fc026" id="r_ae8e9c91952b27de66a0f62f8ca6fc026"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ae8e9c91952b27de66a0f62f8ca6fc026">recfromcsv</a> (fname, **kwargs)</td></tr>
<tr class="separator:ae8e9c91952b27de66a0f62f8ca6fc026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5174822613aa364cc4c0d25861c3fb3b" id="r_a5174822613aa364cc4c0d25861c3fb3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a5174822613aa364cc4c0d25861c3fb3b">array_function_dispatch</a></td></tr>
<tr class="separator:a5174822613aa364cc4c0d25861c3fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64728e8461fb25723c4779fcb4d9b68" id="r_ae64728e8461fb25723c4779fcb4d9b68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ae64728e8461fb25723c4779fcb4d9b68">_loadtxt_chunksize</a> = 50000</td></tr>
<tr class="separator:ae64728e8461fb25723c4779fcb4d9b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1605893e27d747512d3e617922ace93c" id="r_a1605893e27d747512d3e617922ace93c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a1605893e27d747512d3e617922ace93c">_loadtxt_with_like</a></td></tr>
<tr class="separator:a1605893e27d747512d3e617922ace93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5e39be76c8ae50195fabfabdaffc3" id="r_a9fb5e39be76c8ae50195fabfabdaffc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a9fb5e39be76c8ae50195fabfabdaffc3">_genfromtxt_with_like</a></td></tr>
<tr class="separator:a9fb5e39be76c8ae50195fabfabdaffc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4991d480ceeeb43e7c9258e78a31fb77" id="r_a4991d480ceeeb43e7c9258e78a31fb77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a4991d480ceeeb43e7c9258e78a31fb77">fh</a></td></tr>
<tr class="separator:a4991d480ceeeb43e7c9258e78a31fb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fe0d72d445b9775f02fe100396d2b7" id="r_a24fe0d72d445b9775f02fe100396d2b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#a24fe0d72d445b9775f02fe100396d2b7">encoding</a></td></tr>
<tr class="separator:a24fe0d72d445b9775f02fe100396d2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa307ef1d7a07340aede9aac1f80265bd" id="r_aa307ef1d7a07340aede9aac1f80265bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#aa307ef1d7a07340aede9aac1f80265bd">do_write</a></td></tr>
<tr class="separator:aa307ef1d7a07340aede9aac1f80265bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac540394a5e912ec17785248cebb76e41" id="r_ac540394a5e912ec17785248cebb76e41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1npyio.html#ac540394a5e912ec17785248cebb76e41">write</a></td></tr>
<tr class="separator:ac540394a5e912ec17785248cebb76e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6962a7b6cb3e2b2f30861720f2669e3f" name="a6962a7b6cb3e2b2f30861720f2669e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6962a7b6cb3e2b2f30861720f2669e3f">&#9670;&#160;</a></span>_check_nonneg_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._check_nonneg_int </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;argument&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  770</span><span class="keyword">def </span>_check_nonneg_int(value, name=&quot;argument&quot;):</div>
<div class="line"><span class="lineno">  771</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  772</span>        operator.index(value)</div>
<div class="line"><span class="lineno">  773</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  774</span>        <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;{name} must be an integer&quot;</span>) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  775</span>    <span class="keywordflow">if</span> value &lt; 0:</div>
<div class="line"><span class="lineno">  776</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;{name} must be nonnegative&quot;</span>)</div>
<div class="line"><span class="lineno">  777</span> </div>
<div class="line"><span class="lineno">  778</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5339e17afdf65e3e6f4767a979a23eb7" name="a5339e17afdf65e3e6f4767a979a23eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5339e17afdf65e3e6f4767a979a23eb7">&#9670;&#160;</a></span>_ensure_ndmin_ndarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._ensure_ndmin_ndarray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int&#160;</td>
          <td class="paramname"><em>ndmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">This is a helper function of loadtxt and genfromtxt to ensure
    proper minimum dimension as requested

    ndim : int. Supported values 1, 2, 3
                ^^ whenever this changes, keep in sync with
                   _ensure_ndmin_ndarray_check_param
</pre> <div class="fragment"><div class="line"><span class="lineno">  736</span><span class="keyword">def </span>_ensure_ndmin_ndarray(a, *, ndmin: int):</div>
<div class="line"><span class="lineno">  737</span>    <span class="stringliteral">&quot;&quot;&quot;This is a helper function of loadtxt and genfromtxt to ensure</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">        proper minimum dimension as requested</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        ndim : int. Supported values 1, 2, 3</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">                    ^^ whenever this changes, keep in sync with</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">                       _ensure_ndmin_ndarray_check_param</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  744</span>    <span class="comment"># Verify that the array has at least dimensions `ndmin`.</span></div>
<div class="line"><span class="lineno">  745</span>    <span class="comment"># Tweak the size and shape of the arrays - remove extraneous dimensions</span></div>
<div class="line"><span class="lineno">  746</span>    <span class="keywordflow">if</span> a.ndim &gt; ndmin:</div>
<div class="line"><span class="lineno">  747</span>        a = np.squeeze(a)</div>
<div class="line"><span class="lineno">  748</span>    <span class="comment"># and ensure we have the minimum number of dimensions asked for</span></div>
<div class="line"><span class="lineno">  749</span>    <span class="comment"># - has to be in this order for the odd case ndmin=1, a.squeeze().ndim=0</span></div>
<div class="line"><span class="lineno">  750</span>    <span class="keywordflow">if</span> a.ndim &lt; ndmin:</div>
<div class="line"><span class="lineno">  751</span>        <span class="keywordflow">if</span> ndmin == 1:</div>
<div class="line"><span class="lineno">  752</span>            a = np.atleast_1d(a)</div>
<div class="line"><span class="lineno">  753</span>        <span class="keywordflow">elif</span> ndmin == 2:</div>
<div class="line"><span class="lineno">  754</span>            a = np.atleast_2d(a).T</div>
<div class="line"><span class="lineno">  755</span> </div>
<div class="line"><span class="lineno">  756</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  757</span> </div>
<div class="line"><span class="lineno">  758</span> </div>
<div class="line"><span class="lineno">  759</span><span class="comment"># amount of lines loadtxt reads in one chunk, can be overridden for testing</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad44b424a5a604ed2cd99a2d04c6e53ff" name="ad44b424a5a604ed2cd99a2d04c6e53ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44b424a5a604ed2cd99a2d04c6e53ff">&#9670;&#160;</a></span>_ensure_ndmin_ndarray_check_param()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._ensure_ndmin_ndarray_check_param </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndmin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Just checks if the param ndmin is supported on
    _ensure_ndmin_ndarray. It is intended to be used as
    verification before running anything expensive.
    e.g. loadtxt, genfromtxt
</pre> <div class="fragment"><div class="line"><span class="lineno">  726</span><span class="keyword">def </span>_ensure_ndmin_ndarray_check_param(ndmin):</div>
<div class="line"><span class="lineno">  727</span>    <span class="stringliteral">&quot;&quot;&quot;Just checks if the param ndmin is supported on</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        _ensure_ndmin_ndarray. It is intended to be used as</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">        verification before running anything expensive.</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">        e.g. loadtxt, genfromtxt</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  732</span>    <span class="comment"># Check correctness of the values of `ndmin`</span></div>
<div class="line"><span class="lineno">  733</span>    <span class="keywordflow">if</span> ndmin <span class="keywordflow">not</span> <span class="keywordflow">in</span> [0, 1, 2]:</div>
<div class="line"><span class="lineno">  734</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Illegal value of ndmin keyword: {ndmin}&quot;</span>)</div>
<div class="line"><span class="lineno">  735</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0813bf6cba181c68ce24ed0c8cf7b64" name="ae0813bf6cba181c68ce24ed0c8cf7b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0813bf6cba181c68ce24ed0c8cf7b64">&#9670;&#160;</a></span>_genfromtxt_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._genfromtxt_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skip_header</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skip_footer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>converters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>missing_values</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filling_values</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usecols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>excludelist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deletechars</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>replace_space</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>autostrip</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>case_sensitive</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaultfmt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpack</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loose</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invalid_raise</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_rows</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>ndmin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr  />
 <h2><a class="anchor" id="autotoc_md24"></a>
-— — ASCII functions —</h2>
<div class="fragment"><div class="line"><span class="lineno"> 1726</span>                           *, ndmin=<span class="keywordtype">None</span>, like=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1727</span>    <span class="keywordflow">return</span> (like,)</div>
<div class="line"><span class="lineno"> 1728</span> </div>
<div class="line"><span class="lineno"> 1729</span> </div>
<div class="line"><span class="lineno"> 1730</span><span class="preprocessor">@set_array_function_like_doc</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a625aa65b5e47af9c6623cdc7ea7c214c" name="a625aa65b5e47af9c6623cdc7ea7c214c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625aa65b5e47af9c6623cdc7ea7c214c">&#9670;&#160;</a></span>_loadtxt_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._loadtxt_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>converters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skiprows</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usecols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpack</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndmin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_rows</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  766</span>        ndmin=<span class="keywordtype">None</span>, encoding=<span class="keywordtype">None</span>, max_rows=<span class="keywordtype">None</span>, *, like=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  767</span>    <span class="keywordflow">return</span> (like,)</div>
<div class="line"><span class="lineno">  768</span> </div>
<div class="line"><span class="lineno">  769</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c2837737f330c3463197b6eec1c8b38" name="a8c2837737f330c3463197b6eec1c8b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2837737f330c3463197b6eec1c8b38">&#9670;&#160;</a></span>_preprocess_comments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._preprocess_comments </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generator that consumes a line iterated iterable and strips out the
multiple (or multi-character) comments from lines.
This is a pre-processing step to achieve feature parity with loadtxt
(we assume that this feature is a nieche feature).
</pre> <div class="fragment"><div class="line"><span class="lineno">  779</span><span class="keyword">def </span>_preprocess_comments(iterable, comments, encoding):</div>
<div class="line"><span class="lineno">  780</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    Generator that consumes a line iterated iterable and strips out the</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    multiple (or multi-character) comments from lines.</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    This is a pre-processing step to achieve feature parity with loadtxt</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    (we assume that this feature is a nieche feature).</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  786</span>    <span class="keywordflow">for</span> line <span class="keywordflow">in</span> iterable:</div>
<div class="line"><span class="lineno">  787</span>        <span class="keywordflow">if</span> isinstance(line, bytes):</div>
<div class="line"><span class="lineno">  788</span>            <span class="comment"># Need to handle conversion here, or the splitting would fail</span></div>
<div class="line"><span class="lineno">  789</span>            line = line.decode(encoding)</div>
<div class="line"><span class="lineno">  790</span> </div>
<div class="line"><span class="lineno">  791</span>        <span class="keywordflow">for</span> c <span class="keywordflow">in</span> comments:</div>
<div class="line"><span class="lineno">  792</span>            line = line.split(c, 1)[0]</div>
<div class="line"><span class="lineno">  793</span> </div>
<div class="line"><span class="lineno">  794</span>        <span class="keywordflow">yield</span> line</div>
<div class="line"><span class="lineno">  795</span> </div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span><span class="comment"># The number of rows we read in one go if confronted with a parametric dtype</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a58f1b3f82f05185e21e74428c8bc7c71" name="a58f1b3f82f05185e21e74428c8bc7c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f1b3f82f05185e21e74428c8bc7c71">&#9670;&#160;</a></span>_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comment</em> = <code>'#'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>quote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>imaginary_unit</em> = <code>'<a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usecols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skiplines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_rows</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>converters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndmin</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpack</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>np.float64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>&quot;bytes&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Read a NumPy array from a text file.

Parameters
----------
fname : str or file object
The filename or the file to be read.
delimiter : str, optional
Field delimiter of the fields in line of the file.
Default is a comma, ','.  If None any sequence of whitespace is
considered a delimiter.
comment : str or sequence of str or None, optional
Character that begins a comment.  All text from the comment
character to the end of the line is ignored.
Multiple comments or multiple-character comment strings are supported,
but may be slower and `quote` must be empty if used.
Use None to disable all use of comments.
quote : str or None, optional
Character that is used to quote string fields. Default is '"'
(a double quote). Use None to disable quote support.
imaginary_unit : str, optional
Character that represent the imaginay unit `sqrt(-1)`.
Default is 'j'.
usecols : array_like, optional
A one-dimensional array of integer column numbers.  These are the
columns from the file to be included in the array.  If this value
is not given, all the columns are used.
skiplines : int, optional
Number of lines to skip before interpreting the data in the file.
max_rows : int, optional
Maximum number of rows of data to read.  Default is to read the
entire file.
converters : dict or callable, optional
A function to parse all columns strings into the desired value, or
a dictionary mapping column number to a parser function.
E.g. if column 0 is a date string: ``converters = {0: datestr2num}``.
Converters can also be used to provide a default value for missing
data, e.g. ``converters = lambda s: float(s.strip() or 0)`` will
convert empty fields to 0.
Default: None
ndmin : int, optional
Minimum dimension of the array returned.
Allowed values are 0, 1 or 2.  Default is 0.
unpack : bool, optional
If True, the returned array is transposed, so that arguments may be
unpacked using ``x, y, z = read(...)``.  When used with a structured
data-type, arrays are returned for each field.  Default is False.
dtype : numpy data type
A NumPy dtype instance, can be a structured dtype to map to the
columns of the file.
encoding : str, optional
Encoding used to decode the inputfile. The special value 'bytes'
(the default) enables backwards-compatible behavior for `converters`,
ensuring that inputs to the converter functions are encoded
bytes objects. The special value 'bytes' has no additional effect if
``converters=None``. If encoding is ``'bytes'`` or ``None``, the
default system encoding is used.

Returns
-------
ndarray
NumPy array.

Examples
--------
First we create a file for the example.

&gt;&gt;&gt; s1 = '1.0,2.0,3.0\n4.0,5.0,6.0\n'
&gt;&gt;&gt; with open('example1.csv', 'w') as f:
...     f.write(s1)
&gt;&gt;&gt; a1 = read_from_filename('example1.csv')
&gt;&gt;&gt; a1
array([[1., 2., 3.],
[4., 5., 6.]])

The second example has columns with different data types, so a
one-dimensional array with a structured data type is returned.
The tab character is used as the field delimiter.

&gt;&gt;&gt; s2 = '1.0\t10\talpha\n2.3\t25\tbeta\n4.5\t16\tgamma\n'
&gt;&gt;&gt; with open('example2.tsv', 'w') as f:
...     f.write(s2)
&gt;&gt;&gt; a2 = read_from_filename('example2.tsv', delimiter='\t')
&gt;&gt;&gt; a2
array([(1. , 10, b'alpha'), (2.3, 25, b'beta'), (4.5, 16, b'gamma')],
dtype=[('f0', '&lt;f8'), ('f1', 'u1'), ('f2', 'S5')])
</pre> <div class="fragment"><div class="line"><span class="lineno">  804</span>          dtype=np.float64, encoding=<span class="stringliteral">&quot;bytes&quot;</span>):</div>
<div class="line"><span class="lineno">  805</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    Read a NumPy array from a text file.</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    fname : str or file object</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        The filename or the file to be read.</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    delimiter : str, optional</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">        Field delimiter of the fields in line of the file.</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">        Default is a comma, &#39;,&#39;.  If None any sequence of whitespace is</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">        considered a delimiter.</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    comment : str or sequence of str or None, optional</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        Character that begins a comment.  All text from the comment</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">        character to the end of the line is ignored.</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        Multiple comments or multiple-character comment strings are supported,</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">        but may be slower and `quote` must be empty if used.</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        Use None to disable all use of comments.</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    quote : str or None, optional</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">        Character that is used to quote string fields. Default is &#39;&quot;&#39;</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        (a double quote). Use None to disable quote support.</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    imaginary_unit : str, optional</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        Character that represent the imaginay unit `sqrt(-1)`.</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">        Default is &#39;j&#39;.</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    usecols : array_like, optional</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">        A one-dimensional array of integer column numbers.  These are the</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">        columns from the file to be included in the array.  If this value</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">        is not given, all the columns are used.</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    skiplines : int, optional</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">        Number of lines to skip before interpreting the data in the file.</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    max_rows : int, optional</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">        Maximum number of rows of data to read.  Default is to read the</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">        entire file.</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    converters : dict or callable, optional</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">        A function to parse all columns strings into the desired value, or</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">        a dictionary mapping column number to a parser function.</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        E.g. if column 0 is a date string: ``converters = {0: datestr2num}``.</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">        Converters can also be used to provide a default value for missing</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">        data, e.g. ``converters = lambda s: float(s.strip() or 0)`` will</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        convert empty fields to 0.</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">        Default: None</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    ndmin : int, optional</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">        Minimum dimension of the array returned.</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        Allowed values are 0, 1 or 2.  Default is 0.</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    unpack : bool, optional</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">        If True, the returned array is transposed, so that arguments may be</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">        unpacked using ``x, y, z = read(...)``.  When used with a structured</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">        data-type, arrays are returned for each field.  Default is False.</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    dtype : numpy data type</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">        A NumPy dtype instance, can be a structured dtype to map to the</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">        columns of the file.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    encoding : str, optional</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">        Encoding used to decode the inputfile. The special value &#39;bytes&#39;</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">        (the default) enables backwards-compatible behavior for `converters`,</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">        ensuring that inputs to the converter functions are encoded</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">        bytes objects. The special value &#39;bytes&#39; has no additional effect if</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">        ``converters=None``. If encoding is ``&#39;bytes&#39;`` or ``None``, the</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">        default system encoding is used.</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    ndarray</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">        NumPy array.</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    First we create a file for the example.</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    &gt;&gt;&gt; s1 = &#39;1.0,2.0,3.0\n4.0,5.0,6.0\n&#39;</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    &gt;&gt;&gt; with open(&#39;example1.csv&#39;, &#39;w&#39;) as f:</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    ...     f.write(s1)</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    &gt;&gt;&gt; a1 = read_from_filename(&#39;example1.csv&#39;)</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    &gt;&gt;&gt; a1</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    array([[1., 2., 3.],</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">           [4., 5., 6.]])</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    The second example has columns with different data types, so a</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    one-dimensional array with a structured data type is returned.</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    The tab character is used as the field delimiter.</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    &gt;&gt;&gt; s2 = &#39;1.0\t10\talpha\n2.3\t25\tbeta\n4.5\t16\tgamma\n&#39;</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    &gt;&gt;&gt; with open(&#39;example2.tsv&#39;, &#39;w&#39;) as f:</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    ...     f.write(s2)</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    &gt;&gt;&gt; a2 = read_from_filename(&#39;example2.tsv&#39;, delimiter=&#39;\t&#39;)</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    &gt;&gt;&gt; a2</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    array([(1. , 10, b&#39;alpha&#39;), (2.3, 25, b&#39;beta&#39;), (4.5, 16, b&#39;gamma&#39;)],</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">          dtype=[(&#39;f0&#39;, &#39;&lt;f8&#39;), (&#39;f1&#39;, &#39;u1&#39;), (&#39;f2&#39;, &#39;S5&#39;)])</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  892</span>    <span class="comment"># Handle special &#39;bytes&#39; keyword for encoding</span></div>
<div class="line"><span class="lineno">  893</span>    byte_converters = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  894</span>    <span class="keywordflow">if</span> encoding == <span class="stringliteral">&#39;bytes&#39;</span>:</div>
<div class="line"><span class="lineno">  895</span>        encoding = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  896</span>        byte_converters = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  897</span> </div>
<div class="line"><span class="lineno">  898</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  899</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;a dtype must be provided.&quot;</span>)</div>
<div class="line"><span class="lineno">  900</span>    dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno">  901</span> </div>
<div class="line"><span class="lineno">  902</span>    read_dtype_via_object_chunks = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  903</span>    <span class="keywordflow">if</span> dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&#39;SUM&#39;</span> <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno">  904</span>            dtype == <span class="stringliteral">&quot;S0&quot;</span> <span class="keywordflow">or</span> dtype == <span class="stringliteral">&quot;U0&quot;</span> <span class="keywordflow">or</span> dtype == <span class="stringliteral">&quot;M8&quot;</span> <span class="keywordflow">or</span> dtype == <span class="stringliteral">&#39;m8&#39;</span>):</div>
<div class="line"><span class="lineno">  905</span>        <span class="comment"># This is a legacy &quot;flexible&quot; dtype.  We do not truly support</span></div>
<div class="line"><span class="lineno">  906</span>        <span class="comment"># parametric dtypes currently (no dtype discovery step in the core),</span></div>
<div class="line"><span class="lineno">  907</span>        <span class="comment"># but have to support these for backward compatibility.</span></div>
<div class="line"><span class="lineno">  908</span>        read_dtype_via_object_chunks = dtype</div>
<div class="line"><span class="lineno">  909</span>        dtype = np.dtype(object)</div>
<div class="line"><span class="lineno">  910</span> </div>
<div class="line"><span class="lineno">  911</span>    <span class="keywordflow">if</span> usecols <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  912</span>        <span class="comment"># Allow usecols to be a single int or a sequence of ints, the C-code</span></div>
<div class="line"><span class="lineno">  913</span>        <span class="comment"># handles the rest</span></div>
<div class="line"><span class="lineno">  914</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  915</span>            usecols = list(usecols)</div>
<div class="line"><span class="lineno">  916</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  917</span>            usecols = [usecols]</div>
<div class="line"><span class="lineno">  918</span> </div>
<div class="line"><span class="lineno">  919</span>    _ensure_ndmin_ndarray_check_param(ndmin)</div>
<div class="line"><span class="lineno">  920</span> </div>
<div class="line"><span class="lineno">  921</span>    <span class="keywordflow">if</span> comment <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  922</span>        comments = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  923</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  924</span>        <span class="comment"># assume comments are a sequence of strings</span></div>
<div class="line"><span class="lineno">  925</span>        <span class="keywordflow">if</span> <span class="stringliteral">&quot;&quot;</span> <span class="keywordflow">in</span> comment:</div>
<div class="line"><span class="lineno">  926</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  927</span>                <span class="stringliteral">&quot;comments cannot be an empty string. Use comments=None to &quot;</span></div>
<div class="line"><span class="lineno">  928</span>                <span class="stringliteral">&quot;disable comments.&quot;</span></div>
<div class="line"><span class="lineno">  929</span>            )</div>
<div class="line"><span class="lineno">  930</span>        comments = tuple(comment)</div>
<div class="line"><span class="lineno">  931</span>        comment = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  932</span>        <span class="keywordflow">if</span> len(comments) == 0:</div>
<div class="line"><span class="lineno">  933</span>            comments = <span class="keywordtype">None</span>  <span class="comment"># No comments at all</span></div>
<div class="line"><span class="lineno">  934</span>        <span class="keywordflow">elif</span> len(comments) == 1:</div>
<div class="line"><span class="lineno">  935</span>            <span class="comment"># If there is only one comment, and that comment has one character,</span></div>
<div class="line"><span class="lineno">  936</span>            <span class="comment"># the normal parsing can deal with it just fine.</span></div>
<div class="line"><span class="lineno">  937</span>            <span class="keywordflow">if</span> isinstance(comments[0], str) <span class="keywordflow">and</span> len(comments[0]) == 1:</div>
<div class="line"><span class="lineno">  938</span>                comment = comments[0]</div>
<div class="line"><span class="lineno">  939</span>                comments = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  940</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  941</span>            <span class="comment"># Input validation if there are multiple comment characters</span></div>
<div class="line"><span class="lineno">  942</span>            <span class="keywordflow">if</span> delimiter <span class="keywordflow">in</span> comments:</div>
<div class="line"><span class="lineno">  943</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  944</span>                    f<span class="stringliteral">&quot;Comment characters &#39;{comments}&#39; cannot include the &quot;</span></div>
<div class="line"><span class="lineno">  945</span>                    f<span class="stringliteral">&quot;delimiter &#39;{delimiter}&#39;&quot;</span></div>
<div class="line"><span class="lineno">  946</span>                )</div>
<div class="line"><span class="lineno">  947</span> </div>
<div class="line"><span class="lineno">  948</span>    <span class="comment"># comment is now either a 1 or 0 character string or a tuple:</span></div>
<div class="line"><span class="lineno">  949</span>    <span class="keywordflow">if</span> comments <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  950</span>        <span class="comment"># Note: An earlier version support two character comments (and could</span></div>
<div class="line"><span class="lineno">  951</span>        <span class="comment">#       have been extended to multiple characters, we assume this is</span></div>
<div class="line"><span class="lineno">  952</span>        <span class="comment">#       rare enough to not optimize for.</span></div>
<div class="line"><span class="lineno">  953</span>        <span class="keywordflow">if</span> quote <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  954</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  955</span>                <span class="stringliteral">&quot;when multiple comments or a multi-character comment is &quot;</span></div>
<div class="line"><span class="lineno">  956</span>                <span class="stringliteral">&quot;given, quotes are not supported.  In this case quotechar &quot;</span></div>
<div class="line"><span class="lineno">  957</span>                <span class="stringliteral">&quot;must be set to None.&quot;</span>)</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span>    <span class="keywordflow">if</span> len(imaginary_unit) != 1:</div>
<div class="line"><span class="lineno">  960</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;len(imaginary_unit) must be 1.&#39;</span>)</div>
<div class="line"><span class="lineno">  961</span> </div>
<div class="line"><span class="lineno">  962</span>    _check_nonneg_int(skiplines)</div>
<div class="line"><span class="lineno">  963</span>    <span class="keywordflow">if</span> max_rows <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  964</span>        _check_nonneg_int(max_rows)</div>
<div class="line"><span class="lineno">  965</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  966</span>        <span class="comment"># Passing -1 to the C code means &quot;read the entire file&quot;.</span></div>
<div class="line"><span class="lineno">  967</span>        max_rows = -1</div>
<div class="line"><span class="lineno">  968</span> </div>
<div class="line"><span class="lineno">  969</span>    fh_closing_ctx = contextlib.nullcontext()</div>
<div class="line"><span class="lineno">  970</span>    filelike = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  971</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  972</span>        <span class="keywordflow">if</span> isinstance(fname, os.PathLike):</div>
<div class="line"><span class="lineno">  973</span>            fname = os.fspath(fname)</div>
<div class="line"><span class="lineno">  974</span>        <span class="keywordflow">if</span> isinstance(fname, str):</div>
<div class="line"><span class="lineno">  975</span>            fh = np.lib._datasource.open(fname, <span class="stringliteral">&#39;rt&#39;</span>, encoding=encoding)</div>
<div class="line"><span class="lineno">  976</span>            <span class="keywordflow">if</span> encoding <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  977</span>                encoding = getattr(fh, <span class="stringliteral">&#39;encoding&#39;</span>, <span class="stringliteral">&#39;latin1&#39;</span>)</div>
<div class="line"><span class="lineno">  978</span> </div>
<div class="line"><span class="lineno">  979</span>            fh_closing_ctx = contextlib.closing(fh)</div>
<div class="line"><span class="lineno">  980</span>            data = fh</div>
<div class="line"><span class="lineno">  981</span>            filelike = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  982</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  983</span>            <span class="keywordflow">if</span> encoding <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  984</span>                encoding = getattr(fname, <span class="stringliteral">&#39;encoding&#39;</span>, <span class="stringliteral">&#39;latin1&#39;</span>)</div>
<div class="line"><span class="lineno">  985</span>            data = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(fname)</div>
<div class="line"><span class="lineno">  986</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  987</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  988</span>            f<span class="stringliteral">&quot;fname must be a string, filehandle, list of strings,\n&quot;</span></div>
<div class="line"><span class="lineno">  989</span>            f<span class="stringliteral">&quot;or generator. Got {type(fname)} instead.&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  990</span> </div>
<div class="line"><span class="lineno">  991</span>    <span class="keyword">with</span> fh_closing_ctx:</div>
<div class="line"><span class="lineno">  992</span>        <span class="keywordflow">if</span> comments <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  993</span>            <span class="keywordflow">if</span> filelike:</div>
<div class="line"><span class="lineno">  994</span>                data = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(data)</div>
<div class="line"><span class="lineno">  995</span>                filelike = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  996</span>            data = _preprocess_comments(data, comments, encoding)</div>
<div class="line"><span class="lineno">  997</span> </div>
<div class="line"><span class="lineno">  998</span>        <span class="keywordflow">if</span> read_dtype_via_object_chunks <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  999</span>            arr = _load_from_filelike(</div>
<div class="line"><span class="lineno"> 1000</span>                data, delimiter=delimiter, comment=comment, quote=quote,</div>
<div class="line"><span class="lineno"> 1001</span>                imaginary_unit=imaginary_unit,</div>
<div class="line"><span class="lineno"> 1002</span>                usecols=usecols, skiplines=skiplines, max_rows=max_rows,</div>
<div class="line"><span class="lineno"> 1003</span>                converters=converters, dtype=dtype,</div>
<div class="line"><span class="lineno"> 1004</span>                encoding=encoding, filelike=filelike,</div>
<div class="line"><span class="lineno"> 1005</span>                byte_converters=byte_converters)</div>
<div class="line"><span class="lineno"> 1006</span> </div>
<div class="line"><span class="lineno"> 1007</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1008</span>            <span class="comment"># This branch reads the file into chunks of object arrays and then</span></div>
<div class="line"><span class="lineno"> 1009</span>            <span class="comment"># casts them to the desired actual dtype.  This ensures correct</span></div>
<div class="line"><span class="lineno"> 1010</span>            <span class="comment"># string-length and datetime-unit discovery (like `arr.astype()`).</span></div>
<div class="line"><span class="lineno"> 1011</span>            <span class="comment"># Due to chunking, certain error reports are less clear, currently.</span></div>
<div class="line"><span class="lineno"> 1012</span>            <span class="keywordflow">if</span> filelike:</div>
<div class="line"><span class="lineno"> 1013</span>                data = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(data)  <span class="comment"># cannot chunk when reading from file</span></div>
<div class="line"><span class="lineno"> 1014</span> </div>
<div class="line"><span class="lineno"> 1015</span>            c_byte_converters = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1016</span>            <span class="keywordflow">if</span> read_dtype_via_object_chunks == <span class="stringliteral">&quot;S&quot;</span>:</div>
<div class="line"><span class="lineno"> 1017</span>                c_byte_converters = <span class="keyword">True</span>  <span class="comment"># Use latin1 rather than ascii</span></div>
<div class="line"><span class="lineno"> 1018</span> </div>
<div class="line"><span class="lineno"> 1019</span>            chunks = []</div>
<div class="line"><span class="lineno"> 1020</span>            <span class="keywordflow">while</span> max_rows != 0:</div>
<div class="line"><span class="lineno"> 1021</span>                <span class="keywordflow">if</span> max_rows &lt; 0:</div>
<div class="line"><span class="lineno"> 1022</span>                    chunk_size = _loadtxt_chunksize</div>
<div class="line"><span class="lineno"> 1023</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1024</span>                    chunk_size = min(_loadtxt_chunksize, max_rows)</div>
<div class="line"><span class="lineno"> 1025</span> </div>
<div class="line"><span class="lineno"> 1026</span>                next_arr = _load_from_filelike(</div>
<div class="line"><span class="lineno"> 1027</span>                    data, delimiter=delimiter, comment=comment, quote=quote,</div>
<div class="line"><span class="lineno"> 1028</span>                    imaginary_unit=imaginary_unit,</div>
<div class="line"><span class="lineno"> 1029</span>                    usecols=usecols, skiplines=skiplines, max_rows=max_rows,</div>
<div class="line"><span class="lineno"> 1030</span>                    converters=converters, dtype=dtype,</div>
<div class="line"><span class="lineno"> 1031</span>                    encoding=encoding, filelike=filelike,</div>
<div class="line"><span class="lineno"> 1032</span>                    byte_converters=byte_converters,</div>
<div class="line"><span class="lineno"> 1033</span>                    c_byte_converters=c_byte_converters)</div>
<div class="line"><span class="lineno"> 1034</span>                <span class="comment"># Cast here already.  We hope that this is better even for</span></div>
<div class="line"><span class="lineno"> 1035</span>                <span class="comment"># large files because the storage is more compact.  It could</span></div>
<div class="line"><span class="lineno"> 1036</span>                <span class="comment"># be adapted (in principle the concatenate could cast).</span></div>
<div class="line"><span class="lineno"> 1037</span>                chunks.append(next_arr.astype(read_dtype_via_object_chunks))</div>
<div class="line"><span class="lineno"> 1038</span> </div>
<div class="line"><span class="lineno"> 1039</span>                skiprows = 0  <span class="comment"># Only have to skip for first chunk</span></div>
<div class="line"><span class="lineno"> 1040</span>                <span class="keywordflow">if</span> max_rows &gt;= 0:</div>
<div class="line"><span class="lineno"> 1041</span>                    max_rows -= chunk_size</div>
<div class="line"><span class="lineno"> 1042</span>                <span class="keywordflow">if</span> len(next_arr) &lt; chunk_size:</div>
<div class="line"><span class="lineno"> 1043</span>                    <span class="comment"># There was less data than requested, so we are done.</span></div>
<div class="line"><span class="lineno"> 1044</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1045</span> </div>
<div class="line"><span class="lineno"> 1046</span>            <span class="comment"># Need at least one chunk, but if empty, the last one may have</span></div>
<div class="line"><span class="lineno"> 1047</span>            <span class="comment"># the wrong shape.</span></div>
<div class="line"><span class="lineno"> 1048</span>            <span class="keywordflow">if</span> len(chunks) &gt; 1 <span class="keywordflow">and</span> len(chunks[-1]) == 0:</div>
<div class="line"><span class="lineno"> 1049</span>                del chunks[-1]</div>
<div class="line"><span class="lineno"> 1050</span>            <span class="keywordflow">if</span> len(chunks) == 1:</div>
<div class="line"><span class="lineno"> 1051</span>                arr = chunks[0]</div>
<div class="line"><span class="lineno"> 1052</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1053</span>                arr = np.concatenate(chunks, axis=0)</div>
<div class="line"><span class="lineno"> 1054</span> </div>
<div class="line"><span class="lineno"> 1055</span>    <span class="comment"># NOTE: ndmin works as advertised for structured dtypes, but normally</span></div>
<div class="line"><span class="lineno"> 1056</span>    <span class="comment">#       these would return a 1D result plus the structured dimension,</span></div>
<div class="line"><span class="lineno"> 1057</span>    <span class="comment">#       so ndmin=2 adds a third dimension even when no squeezing occurs.</span></div>
<div class="line"><span class="lineno"> 1058</span>    <span class="comment">#       A `squeeze=False` could be a better solution (pandas uses squeeze).</span></div>
<div class="line"><span class="lineno"> 1059</span>    arr = _ensure_ndmin_ndarray(arr, ndmin=ndmin)</div>
<div class="line"><span class="lineno"> 1060</span> </div>
<div class="line"><span class="lineno"> 1061</span>    <span class="keywordflow">if</span> arr.shape:</div>
<div class="line"><span class="lineno"> 1062</span>        <span class="keywordflow">if</span> arr.shape[0] == 0:</div>
<div class="line"><span class="lineno"> 1063</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1064</span>                f<span class="stringliteral">&#39;loadtxt: input contained no data: &quot;{fname}&quot;&#39;</span>,</div>
<div class="line"><span class="lineno"> 1065</span>                category=UserWarning,</div>
<div class="line"><span class="lineno"> 1066</span>                stacklevel=3</div>
<div class="line"><span class="lineno"> 1067</span>            )</div>
<div class="line"><span class="lineno"> 1068</span> </div>
<div class="line"><span class="lineno"> 1069</span>    <span class="keywordflow">if</span> unpack:</div>
<div class="line"><span class="lineno"> 1070</span>        <span class="comment"># Unpack structured dtypes if requested:</span></div>
<div class="line"><span class="lineno"> 1071</span>        dt = arr.dtype</div>
<div class="line"><span class="lineno"> 1072</span>        <span class="keywordflow">if</span> dt.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1073</span>            <span class="comment"># For structured arrays, return an array for each field.</span></div>
<div class="line"><span class="lineno"> 1074</span>            <span class="keywordflow">return</span> [arr[field] <span class="keywordflow">for</span> field <span class="keywordflow">in</span> dt.names]</div>
<div class="line"><span class="lineno"> 1075</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1076</span>            <span class="keywordflow">return</span> arr.T</div>
<div class="line"><span class="lineno"> 1077</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1078</span>        <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno"> 1079</span> </div>
<div class="line"><span class="lineno"> 1080</span> </div>
<div class="line"><span class="lineno"> 1081</span><span class="preprocessor">@set_array_function_like_doc</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa772f19271f00ccb8ea23fbe10d4d032" name="aa772f19271f00ccb8ea23fbe10d4d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa772f19271f00ccb8ea23fbe10d4d032">&#9670;&#160;</a></span>_save_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._save_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_pickle</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fix_imports</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  447</span><span class="keyword">def </span>_save_dispatcher(file, arr, allow_pickle=None, fix_imports=None):</div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">return</span> (arr,)</div>
<div class="line"><span class="lineno">  449</span> </div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span><span class="preprocessor">@array_function_dispatch(_save_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac365d2221051f2d12d9a367fd37098b1" name="ac365d2221051f2d12d9a367fd37098b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac365d2221051f2d12d9a367fd37098b1">&#9670;&#160;</a></span>_savetxt_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._savetxt_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newline</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>header</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comments</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1363</span>                        encoding=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1364</span>    <span class="keywordflow">return</span> (X,)</div>
<div class="line"><span class="lineno"> 1365</span> </div>
<div class="line"><span class="lineno"> 1366</span> </div>
<div class="line"><span class="lineno"> 1367</span><span class="preprocessor">@array_function_dispatch(_savetxt_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa54a3e1c8b264a24c94f7b9675f2e6fc" name="aa54a3e1c8b264a24c94f7b9675f2e6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54a3e1c8b264a24c94f7b9675f2e6fc">&#9670;&#160;</a></span>_savez()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._savez </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_pickle</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pickle_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  689</span><span class="keyword">def </span>_savez(file, args, kwds, compress, allow_pickle=True, pickle_kwargs=None):</div>
<div class="line"><span class="lineno">  690</span>    <span class="comment"># Import is postponed to here since zipfile depends on gzip, an optional</span></div>
<div class="line"><span class="lineno">  691</span>    <span class="comment"># component of the so-called standard library.</span></div>
<div class="line"><span class="lineno">  692</span>    <span class="keyword">import</span> zipfile</div>
<div class="line"><span class="lineno">  693</span> </div>
<div class="line"><span class="lineno">  694</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(file, <span class="stringliteral">&#39;write&#39;</span>):</div>
<div class="line"><span class="lineno">  695</span>        file = os_fspath(file)</div>
<div class="line"><span class="lineno">  696</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> file.endswith(<span class="stringliteral">&#39;.npz&#39;</span>):</div>
<div class="line"><span class="lineno">  697</span>            file = file + <span class="stringliteral">&#39;.npz&#39;</span></div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>    namedict = kwds</div>
<div class="line"><span class="lineno">  700</span>    <span class="keywordflow">for</span> i, val <span class="keywordflow">in</span> enumerate(args):</div>
<div class="line"><span class="lineno">  701</span>        key = <span class="stringliteral">&#39;arr_%d&#39;</span> % i</div>
<div class="line"><span class="lineno">  702</span>        <span class="keywordflow">if</span> key <span class="keywordflow">in</span> namedict.keys():</div>
<div class="line"><span class="lineno">  703</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  704</span>                <span class="stringliteral">&quot;Cannot use un-named variables and keyword %s&quot;</span> % key)</div>
<div class="line"><span class="lineno">  705</span>        namedict[key] = val</div>
<div class="line"><span class="lineno">  706</span> </div>
<div class="line"><span class="lineno">  707</span>    <span class="keywordflow">if</span> compress:</div>
<div class="line"><span class="lineno">  708</span>        compression = zipfile.ZIP_DEFLATED</div>
<div class="line"><span class="lineno">  709</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  710</span>        compression = zipfile.ZIP_STORED</div>
<div class="line"><span class="lineno">  711</span> </div>
<div class="line"><span class="lineno">  712</span>    zipf = zipfile_factory(file, mode=<span class="stringliteral">&quot;w&quot;</span>, compression=compression)</div>
<div class="line"><span class="lineno">  713</span> </div>
<div class="line"><span class="lineno">  714</span>    <span class="keywordflow">for</span> key, val <span class="keywordflow">in</span> namedict.items():</div>
<div class="line"><span class="lineno">  715</span>        fname = key + <span class="stringliteral">&#39;.npy&#39;</span></div>
<div class="line"><span class="lineno">  716</span>        val = np.asanyarray(val)</div>
<div class="line"><span class="lineno">  717</span>        <span class="comment"># always force zip64, gh-10776</span></div>
<div class="line"><span class="lineno">  718</span>        <span class="keyword">with</span> zipf.open(fname, <span class="stringliteral">&#39;w&#39;</span>, force_zip64=<span class="keyword">True</span>) <span class="keyword">as</span> fid:</div>
<div class="line"><span class="lineno">  719</span>            format.write_array(fid, val,</div>
<div class="line"><span class="lineno">  720</span>                               allow_pickle=allow_pickle,</div>
<div class="line"><span class="lineno">  721</span>                               pickle_kwargs=pickle_kwargs)</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span>    zipf.close()</div>
<div class="line"><span class="lineno">  724</span> </div>
<div class="line"><span class="lineno">  725</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa686790f99dbf41e7752d70c660b6713" name="aa686790f99dbf41e7752d70c660b6713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa686790f99dbf41e7752d70c660b6713">&#9670;&#160;</a></span>_savez_compressed_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._savez_compressed_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  618</span><span class="keyword">def </span>_savez_compressed_dispatcher(file, *args, **kwds):</div>
<div class="line"><span class="lineno">  619</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> args</div>
<div class="line"><span class="lineno">  620</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> kwds.values()</div>
<div class="line"><span class="lineno">  621</span> </div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span><span class="preprocessor">@array_function_dispatch(_savez_compressed_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae60ab9e4383891290d66eeb4617078fc" name="ae60ab9e4383891290d66eeb4617078fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60ab9e4383891290d66eeb4617078fc">&#9670;&#160;</a></span>_savez_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._savez_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  526</span><span class="keyword">def </span>_savez_dispatcher(file, *args, **kwds):</div>
<div class="line"><span class="lineno">  527</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> args</div>
<div class="line"><span class="lineno">  528</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> kwds.values()</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span><span class="preprocessor">@array_function_dispatch(_savez_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="adba7e0fde42aaae27092d97b2d260c90" name="adba7e0fde42aaae27092d97b2d260c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba7e0fde42aaae27092d97b2d260c90">&#9670;&#160;</a></span>fromregex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.fromregex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct an array from a text file, using regular expression parsing.

The returned array is always a structured array, and is constructed from
all matches of the regular expression in the file. Groups in the regular
expression are converted to fields of the structured array.

Parameters
----------
file : path or file
Filename or file object to read.

.. versionchanged:: 1.22.0
Now accepts `os.PathLike` implementations.
regexp : str or regexp
Regular expression used to parse the file.
Groups in the regular expression correspond to fields in the dtype.
dtype : dtype or list of dtypes
Dtype for the structured array; must be a structured datatype.
encoding : str, optional
Encoding used to decode the inputfile. Does not apply to input streams.

.. versionadded:: 1.14.0

Returns
-------
output : ndarray
The output array, containing the part of the content of `file` that
was matched by `regexp`. `output` is always a structured array.

Raises
------
TypeError
When `dtype` is not a valid dtype for a structured array.

See Also
--------
fromstring, loadtxt

Notes
-----
Dtypes for structured arrays can be specified in several forms, but all
forms specify at least the data type and field name. For details see
`basics.rec`.

Examples
--------
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; text = StringIO("1312 foo\n1534  bar\n444   qux")

&gt;&gt;&gt; regexp = r"(\d+)\s+(...)"  # match [digits, whitespace, anything]
&gt;&gt;&gt; output = np.fromregex(text, regexp,
...                       [('num', np.int64), ('key', 'S3')])
&gt;&gt;&gt; output
array([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],
dtype=[('num', '&lt;i8'), ('key', 'S3')])
&gt;&gt;&gt; output['num']
array([1312, 1534,  444])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1616</span><span class="keyword">def </span>fromregex(file, regexp, dtype, encoding=None):</div>
<div class="line"><span class="lineno"> 1617</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">    Construct an array from a text file, using regular expression parsing.</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">    The returned array is always a structured array, and is constructed from</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">    all matches of the regular expression in the file. Groups in the regular</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    expression are converted to fields of the structured array.</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">    file : path or file</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">        Filename or file object to read.</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">        .. versionchanged:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">            Now accepts `os.PathLike` implementations.</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    regexp : str or regexp</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">        Regular expression used to parse the file.</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">        Groups in the regular expression correspond to fields in the dtype.</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    dtype : dtype or list of dtypes</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">        Dtype for the structured array; must be a structured datatype.</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    encoding : str, optional</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">        Encoding used to decode the inputfile. Does not apply to input streams.</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">        .. versionadded:: 1.14.0</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">        The output array, containing the part of the content of `file` that</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">        was matched by `regexp`. `output` is always a structured array.</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">        When `dtype` is not a valid dtype for a structured array.</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral">    fromstring, loadtxt</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">    Dtypes for structured arrays can be specified in several forms, but all</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">    forms specify at least the data type and field name. For details see</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral">    `basics.rec`.</span></div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">    &gt;&gt;&gt; from io import StringIO</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">    &gt;&gt;&gt; text = StringIO(&quot;1312 foo\n1534  bar\n444   qux&quot;)</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">    &gt;&gt;&gt; regexp = r&quot;(\d+)\s+(...)&quot;  # match [digits, whitespace, anything]</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    &gt;&gt;&gt; output = np.fromregex(text, regexp,</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    ...                       [(&#39;num&#39;, np.int64), (&#39;key&#39;, &#39;S3&#39;)])</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">    &gt;&gt;&gt; output</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    array([(1312, b&#39;foo&#39;), (1534, b&#39;bar&#39;), ( 444, b&#39;qux&#39;)],</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">          dtype=[(&#39;num&#39;, &#39;&lt;i8&#39;), (&#39;key&#39;, &#39;S3&#39;)])</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    &gt;&gt;&gt; output[&#39;num&#39;]</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">    array([1312, 1534,  444])</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1677</span>    own_fh = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1678</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(file, <span class="stringliteral">&quot;read&quot;</span>):</div>
<div class="line"><span class="lineno"> 1679</span>        file = os.fspath(file)</div>
<div class="line"><span class="lineno"> 1680</span>        file = np.lib._datasource.open(file, <span class="stringliteral">&#39;rt&#39;</span>, encoding=encoding)</div>
<div class="line"><span class="lineno"> 1681</span>        own_fh = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1682</span> </div>
<div class="line"><span class="lineno"> 1683</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1684</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(dtype, np.dtype):</div>
<div class="line"><span class="lineno"> 1685</span>            dtype = np.dtype(dtype)</div>
<div class="line"><span class="lineno"> 1686</span>        <span class="keywordflow">if</span> dtype.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1687</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;dtype must be a structured datatype.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1688</span> </div>
<div class="line"><span class="lineno"> 1689</span>        content = file.read()</div>
<div class="line"><span class="lineno"> 1690</span>        <span class="keywordflow">if</span> isinstance(content, bytes) <span class="keywordflow">and</span> isinstance(regexp, str):</div>
<div class="line"><span class="lineno"> 1691</span>            regexp = asbytes(regexp)</div>
<div class="line"><span class="lineno"> 1692</span>        <span class="keywordflow">elif</span> isinstance(content, str) <span class="keywordflow">and</span> isinstance(regexp, bytes):</div>
<div class="line"><span class="lineno"> 1693</span>            regexp = asstr(regexp)</div>
<div class="line"><span class="lineno"> 1694</span> </div>
<div class="line"><span class="lineno"> 1695</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(regexp, <span class="stringliteral">&#39;match&#39;</span>):</div>
<div class="line"><span class="lineno"> 1696</span>            regexp = re.compile(regexp)</div>
<div class="line"><span class="lineno"> 1697</span>        seq = regexp.findall(content)</div>
<div class="line"><span class="lineno"> 1698</span>        <span class="keywordflow">if</span> seq <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(seq[0], tuple):</div>
<div class="line"><span class="lineno"> 1699</span>            <span class="comment"># Only one group is in the regexp.</span></div>
<div class="line"><span class="lineno"> 1700</span>            <span class="comment"># Create the new array as a single data-type and then</span></div>
<div class="line"><span class="lineno"> 1701</span>            <span class="comment">#   re-interpret as a single-field structured array.</span></div>
<div class="line"><span class="lineno"> 1702</span>            newdtype = np.dtype(dtype[dtype.names[0]])</div>
<div class="line"><span class="lineno"> 1703</span>            output = np.array(seq, dtype=newdtype)</div>
<div class="line"><span class="lineno"> 1704</span>            output.dtype = dtype</div>
<div class="line"><span class="lineno"> 1705</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1706</span>            output = np.array(seq, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1707</span> </div>
<div class="line"><span class="lineno"> 1708</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 1709</span>    <span class="keywordflow">finally</span>:</div>
<div class="line"><span class="lineno"> 1710</span>        <span class="keywordflow">if</span> own_fh:</div>
<div class="line"><span class="lineno"> 1711</span>            file.close()</div>
<div class="line"><span class="lineno"> 1712</span> </div>
<div class="line"><span class="lineno"> 1713</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5208dfeb60eefd2703a34cba439f39e6" name="a5208dfeb60eefd2703a34cba439f39e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5208dfeb60eefd2703a34cba439f39e6">&#9670;&#160;</a></span>genfromtxt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.genfromtxt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comments</em> = <code>'#'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skip_header</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skip_footer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>converters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>missing_values</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filling_values</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usecols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>excludelist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deletechars</em> = <code>''.join(sorted(<a class="el" href="classnumpy_1_1lib_1_1__iotools_1_1_name_validator.html#a25e444d6c4ace7882608a9217f475c34">NameValidator.defaultdeletechars</a>))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>replace_space</em> = <code>'_'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>autostrip</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>case_sensitive</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaultfmt</em> = <code>&quot;f%i&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpack</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loose</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invalid_raise</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_rows</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>'bytes'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>ndmin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load data from a text file, with missing values handled as specified.

Each line past the first `skip_header` lines is split at the `delimiter`
character, and characters following the `comments` character are discarded.

Parameters
----------
fname : file, str, pathlib.Path, list of str, generator
    File, filename, list, or generator to read.  If the filename
    extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note
    that generators must return bytes or strings. The strings
    in a list or produced by a generator are treated as lines.
dtype : dtype, optional
    Data type of the resulting array.
    If None, the dtypes will be determined by the contents of each
    column, individually.
comments : str, optional
    The character used to indicate the start of a comment.
    All the characters occurring on a line after a comment are discarded.
delimiter : str, int, or sequence, optional
    The string used to separate values.  By default, any consecutive
    whitespaces act as delimiter.  An integer or sequence of integers
    can also be provided as width(s) of each field.
skiprows : int, optional
    `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.
skip_header : int, optional
    The number of lines to skip at the beginning of the file.
skip_footer : int, optional
    The number of lines to skip at the end of the file.
converters : variable, optional
    The set of functions that convert the data of a column to a value.
    The converters can also be used to provide a default value
    for missing data: ``converters = {3: lambda s: float(s or 0)}``.
missing : variable, optional
    `missing` was removed in numpy 1.10. Please use `missing_values`
    instead.
missing_values : variable, optional
    The set of strings corresponding to missing data.
filling_values : variable, optional
    The set of values to be used as default when the data are missing.
usecols : sequence, optional
    Which columns to read, with 0 being the first.  For example,
    ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.
names : {None, True, str, sequence}, optional
    If `names` is True, the field names are read from the first line after
    the first `skip_header` lines. This line can optionally be preceded
    by a comment delimiter. If `names` is a sequence or a single-string of
    comma-separated names, the names will be used to define the field names
    in a structured dtype. If `names` is None, the names of the dtype
    fields will be used, if any.
excludelist : sequence, optional
    A list of names to exclude. This list is appended to the default list
    ['return','file','print']. Excluded names are appended with an
    underscore: for example, `file` would become `file_`.
deletechars : str, optional
    A string combining invalid characters that must be deleted from the
    names.
defaultfmt : str, optional
    A format used to define default field names, such as "f%i" or "f_%02i".
autostrip : bool, optional
    Whether to automatically strip white spaces from the variables.
replace_space : char, optional
    Character(s) used in replacement of white spaces in the variable
    names. By default, use a '_'.
case_sensitive : {True, False, 'upper', 'lower'}, optional
    If True, field names are case sensitive.
    If False or 'upper', field names are converted to upper case.
    If 'lower', field names are converted to lower case.
unpack : bool, optional
    If True, the returned array is transposed, so that arguments may be
    unpacked using ``x, y, z = genfromtxt(...)``.  When used with a
    structured data-type, arrays are returned for each field.
    Default is False.
usemask : bool, optional
    If True, return a masked array.
    If False, return a regular array.
loose : bool, optional
    If True, do not raise errors for invalid values.
invalid_raise : bool, optional
    If True, an exception is raised if an inconsistency is detected in the
    number of columns.
    If False, a warning is emitted and the offending lines are skipped.
max_rows : int,  optional
    The maximum number of rows to read. Must not be used with skip_footer
    at the same time.  If given, the value must be at least 1. Default is
    to read the entire file.

    .. versionadded:: 1.10.0
encoding : str, optional
    Encoding used to decode the inputfile. Does not apply when `fname` is
    a file object.  The special value 'bytes' enables backward compatibility
    workarounds that ensure that you receive byte arrays when possible
    and passes latin1 encoded strings to converters. Override this value to
    receive unicode arrays and pass strings as input to converters.  If set
    to None the system default is used. The default value is 'bytes'.

    .. versionadded:: 1.14.0
ndmin : int, optional
    Same parameter as `loadtxt`

    .. versionadded:: 1.23.0
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
out : ndarray
    Data read from the text file. If `usemask` is True, this is a
    masked array.

See Also
--------
numpy.loadtxt : equivalent function when no data is missing.

Notes
-----
* When spaces are used as delimiters, or when no delimiter has been given
  as input, there should not be any missing data between two fields.
* When the variables are named (either by a flexible dtype or with `names`),
  there must not be any header in the file (else a ValueError
  exception is raised).
* Individual values are not stripped of spaces by default.
  When using a custom converter, make sure the function does remove spaces.

References
----------
.. [1] NumPy User Guide, section `I/O with NumPy
       &lt;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&gt;`_.

Examples
--------
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; import numpy as np

Comma delimited file with mixed dtype

&gt;&gt;&gt; s = StringIO(u"1,1.3,abcde")
&gt;&gt;&gt; data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),
... ('mystring','S5')], delimiter=",")
&gt;&gt;&gt; data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])

Using dtype = None

&gt;&gt;&gt; _ = s.seek(0) # needed for StringIO example only
&gt;&gt;&gt; data = np.genfromtxt(s, dtype=None,
... names = ['myint','myfloat','mystring'], delimiter=",")
&gt;&gt;&gt; data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])

Specifying dtype and names

&gt;&gt;&gt; _ = s.seek(0)
&gt;&gt;&gt; data = np.genfromtxt(s, dtype="i8,f8,S5",
... names=['myint','myfloat','mystring'], delimiter=",")
&gt;&gt;&gt; data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])

An example with fixed-width columns

&gt;&gt;&gt; s = StringIO(u"11.3abcde")
&gt;&gt;&gt; data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],
...     delimiter=[1,3,5])
&gt;&gt;&gt; data
array((1, 1.3, b'abcde'),
      dtype=[('intvar', '&lt;i8'), ('fltvar', '&lt;f8'), ('strvar', 'S5')])

An example to show comments

&gt;&gt;&gt; f = StringIO('''
... text,# of chars
... hello world,11
... numpy,5''')
&gt;&gt;&gt; np.genfromtxt(f, dtype='S12,S12', delimiter=',')
array([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],
  dtype=[('f0', 'S12'), ('f1', 'S12')])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1740</span>               *, ndmin=0, like=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1741</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">    Load data from a text file, with missing values handled as specified.</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral">    Each line past the first `skip_header` lines is split at the `delimiter`</span></div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">    character, and characters following the `comments` character are discarded.</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral">    fname : file, str, pathlib.Path, list of str, generator</span></div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">        File, filename, list, or generator to read.  If the filename</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral">        extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note</span></div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">        that generators must return bytes or strings. The strings</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">        in a list or produced by a generator are treated as lines.</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">        Data type of the resulting array.</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral">        If None, the dtypes will be determined by the contents of each</span></div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">        column, individually.</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">    comments : str, optional</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">        The character used to indicate the start of a comment.</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">        All the characters occurring on a line after a comment are discarded.</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">    delimiter : str, int, or sequence, optional</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">        The string used to separate values.  By default, any consecutive</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">        whitespaces act as delimiter.  An integer or sequence of integers</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">        can also be provided as width(s) of each field.</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    skiprows : int, optional</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">        `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">    skip_header : int, optional</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">        The number of lines to skip at the beginning of the file.</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">    skip_footer : int, optional</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral">        The number of lines to skip at the end of the file.</span></div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    converters : variable, optional</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">        The set of functions that convert the data of a column to a value.</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">        The converters can also be used to provide a default value</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">        for missing data: ``converters = {3: lambda s: float(s or 0)}``.</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">    missing : variable, optional</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">        `missing` was removed in numpy 1.10. Please use `missing_values`</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">        instead.</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">    missing_values : variable, optional</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">        The set of strings corresponding to missing data.</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    filling_values : variable, optional</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">        The set of values to be used as default when the data are missing.</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">    usecols : sequence, optional</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">        Which columns to read, with 0 being the first.  For example,</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral">    names : {None, True, str, sequence}, optional</span></div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">        If `names` is True, the field names are read from the first line after</span></div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">        the first `skip_header` lines. This line can optionally be preceded</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">        by a comment delimiter. If `names` is a sequence or a single-string of</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">        comma-separated names, the names will be used to define the field names</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">        in a structured dtype. If `names` is None, the names of the dtype</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">        fields will be used, if any.</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    excludelist : sequence, optional</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">        A list of names to exclude. This list is appended to the default list</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">        [&#39;return&#39;,&#39;file&#39;,&#39;print&#39;]. Excluded names are appended with an</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">        underscore: for example, `file` would become `file_`.</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">    deletechars : str, optional</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">        A string combining invalid characters that must be deleted from the</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">        names.</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">    defaultfmt : str, optional</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        A format used to define default field names, such as &quot;f%i&quot; or &quot;f_%02i&quot;.</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">    autostrip : bool, optional</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">        Whether to automatically strip white spaces from the variables.</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">    replace_space : char, optional</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral">        Character(s) used in replacement of white spaces in the variable</span></div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">        names. By default, use a &#39;_&#39;.</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    case_sensitive : {True, False, &#39;upper&#39;, &#39;lower&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">        If True, field names are case sensitive.</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">        If False or &#39;upper&#39;, field names are converted to upper case.</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">        If &#39;lower&#39;, field names are converted to lower case.</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">    unpack : bool, optional</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">        If True, the returned array is transposed, so that arguments may be</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">        unpacked using ``x, y, z = genfromtxt(...)``.  When used with a</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">        structured data-type, arrays are returned for each field.</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">        Default is False.</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">    usemask : bool, optional</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">        If True, return a masked array.</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">        If False, return a regular array.</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">    loose : bool, optional</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        If True, do not raise errors for invalid values.</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">    invalid_raise : bool, optional</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">        If True, an exception is raised if an inconsistency is detected in the</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">        number of columns.</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">        If False, a warning is emitted and the offending lines are skipped.</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    max_rows : int,  optional</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">        The maximum number of rows to read. Must not be used with skip_footer</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">        at the same time.  If given, the value must be at least 1. Default is</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">        to read the entire file.</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    encoding : str, optional</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">        Encoding used to decode the inputfile. Does not apply when `fname` is</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">        a file object.  The special value &#39;bytes&#39; enables backward compatibility</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">        workarounds that ensure that you receive byte arrays when possible</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">        and passes latin1 encoded strings to converters. Override this value to</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">        receive unicode arrays and pass strings as input to converters.  If set</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">        to None the system default is used. The default value is &#39;bytes&#39;.</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">        .. versionadded:: 1.14.0</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">    ndmin : int, optional</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral">        Same parameter as `loadtxt`</span></div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">        .. versionadded:: 1.23.0</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">    ${ARRAY_FUNCTION_LIKE}</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">        Data read from the text file. If `usemask` is True, this is a</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">        masked array.</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    numpy.loadtxt : equivalent function when no data is missing.</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    * When spaces are used as delimiters, or when no delimiter has been given</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral">      as input, there should not be any missing data between two fields.</span></div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">    * When the variables are named (either by a flexible dtype or with `names`),</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">      there must not be any header in the file (else a ValueError</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">      exception is raised).</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">    * Individual values are not stripped of spaces by default.</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">      When using a custom converter, make sure the function does remove spaces.</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">    .. [1] NumPy User Guide, section `I/O with NumPy</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">           &lt;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&gt;`_.</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral">    &gt;&gt;&gt; from io import StringIO</span></div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    Comma delimited file with mixed dtype</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(u&quot;1,1.3,abcde&quot;)</span></div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=[(&#39;myint&#39;,&#39;i8&#39;),(&#39;myfloat&#39;,&#39;f8&#39;),</span></div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">    ... (&#39;mystring&#39;,&#39;S5&#39;)], delimiter=&quot;,&quot;)</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral">    &gt;&gt;&gt; data</span></div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral">    array((1, 1.3, b&#39;abcde&#39;),</span></div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">          dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;S5&#39;)])</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    Using dtype = None</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">    &gt;&gt;&gt; _ = s.seek(0) # needed for StringIO example only</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=None,</span></div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">    ... names = [&#39;myint&#39;,&#39;myfloat&#39;,&#39;mystring&#39;], delimiter=&quot;,&quot;)</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">    &gt;&gt;&gt; data</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral">    array((1, 1.3, b&#39;abcde&#39;),</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">          dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;S5&#39;)])</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    Specifying dtype and names</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    &gt;&gt;&gt; _ = s.seek(0)</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=&quot;i8,f8,S5&quot;,</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">    ... names=[&#39;myint&#39;,&#39;myfloat&#39;,&#39;mystring&#39;], delimiter=&quot;,&quot;)</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    &gt;&gt;&gt; data</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">    array((1, 1.3, b&#39;abcde&#39;),</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">          dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;S5&#39;)])</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">    An example with fixed-width columns</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(u&quot;11.3abcde&quot;)</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=None, names=[&#39;intvar&#39;,&#39;fltvar&#39;,&#39;strvar&#39;],</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">    ...     delimiter=[1,3,5])</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">    &gt;&gt;&gt; data</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">    array((1, 1.3, b&#39;abcde&#39;),</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">          dtype=[(&#39;intvar&#39;, &#39;&lt;i8&#39;), (&#39;fltvar&#39;, &#39;&lt;f8&#39;), (&#39;strvar&#39;, &#39;S5&#39;)])</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">    An example to show comments</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">    &gt;&gt;&gt; f = StringIO(&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    ... text,# of chars</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">    ... hello world,11</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral">    ... numpy,5&#39;&#39;&#39;)</span></div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">    &gt;&gt;&gt; np.genfromtxt(f, dtype=&#39;S12,S12&#39;, delimiter=&#39;,&#39;)</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">    array([(b&#39;text&#39;, b&#39;&#39;), (b&#39;hello world&#39;, b&#39;11&#39;), (b&#39;numpy&#39;, b&#39;5&#39;)],</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">      dtype=[(&#39;f0&#39;, &#39;S12&#39;), (&#39;f1&#39;, &#39;S12&#39;)])</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1924</span> </div>
<div class="line"><span class="lineno"> 1925</span>    <span class="keywordflow">if</span> like <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1926</span>        <span class="keywordflow">return</span> _genfromtxt_with_like(</div>
<div class="line"><span class="lineno"> 1927</span>            fname, dtype=dtype, comments=comments, delimiter=delimiter,</div>
<div class="line"><span class="lineno"> 1928</span>            skip_header=skip_header, skip_footer=skip_footer,</div>
<div class="line"><span class="lineno"> 1929</span>            converters=converters, missing_values=missing_values,</div>
<div class="line"><span class="lineno"> 1930</span>            filling_values=filling_values, usecols=usecols, names=names,</div>
<div class="line"><span class="lineno"> 1931</span>            excludelist=excludelist, deletechars=deletechars,</div>
<div class="line"><span class="lineno"> 1932</span>            replace_space=replace_space, autostrip=autostrip,</div>
<div class="line"><span class="lineno"> 1933</span>            case_sensitive=case_sensitive, defaultfmt=defaultfmt,</div>
<div class="line"><span class="lineno"> 1934</span>            unpack=unpack, usemask=usemask, loose=loose,</div>
<div class="line"><span class="lineno"> 1935</span>            invalid_raise=invalid_raise, max_rows=max_rows, encoding=encoding,</div>
<div class="line"><span class="lineno"> 1936</span>            ndmin=ndmin,</div>
<div class="line"><span class="lineno"> 1937</span>            like=like</div>
<div class="line"><span class="lineno"> 1938</span>        )</div>
<div class="line"><span class="lineno"> 1939</span> </div>
<div class="line"><span class="lineno"> 1940</span>    _ensure_ndmin_ndarray_check_param(ndmin)</div>
<div class="line"><span class="lineno"> 1941</span> </div>
<div class="line"><span class="lineno"> 1942</span>    <span class="keywordflow">if</span> max_rows <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1943</span>        <span class="keywordflow">if</span> skip_footer:</div>
<div class="line"><span class="lineno"> 1944</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1945</span>                    <span class="stringliteral">&quot;The keywords &#39;skip_footer&#39; and &#39;max_rows&#39; can not be &quot;</span></div>
<div class="line"><span class="lineno"> 1946</span>                    <span class="stringliteral">&quot;specified at the same time.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1947</span>        <span class="keywordflow">if</span> max_rows &lt; 1:</div>
<div class="line"><span class="lineno"> 1948</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;max_rows&#39; must be at least 1.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1949</span> </div>
<div class="line"><span class="lineno"> 1950</span>    <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 1951</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacenumpy_1_1ma.html">numpy.ma</a> <span class="keyword">import</span> MaskedArray, make_mask_descr</div>
<div class="line"><span class="lineno"> 1952</span>    <span class="comment"># Check the input dictionary of converters</span></div>
<div class="line"><span class="lineno"> 1953</span>    user_converters = converters <span class="keywordflow">or</span> {}</div>
<div class="line"><span class="lineno"> 1954</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(user_converters, dict):</div>
<div class="line"><span class="lineno"> 1955</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1956</span>            <span class="stringliteral">&quot;The input argument &#39;converter&#39; should be a valid dictionary &quot;</span></div>
<div class="line"><span class="lineno"> 1957</span>            <span class="stringliteral">&quot;(got &#39;%s&#39; instead)&quot;</span> % type(user_converters))</div>
<div class="line"><span class="lineno"> 1958</span> </div>
<div class="line"><span class="lineno"> 1959</span>    <span class="keywordflow">if</span> encoding == <span class="stringliteral">&#39;bytes&#39;</span>:</div>
<div class="line"><span class="lineno"> 1960</span>        encoding = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1961</span>        byte_converters = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1962</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1963</span>        byte_converters = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1964</span> </div>
<div class="line"><span class="lineno"> 1965</span>    <span class="comment"># Initialize the filehandle, the LineSplitter and the NameValidator</span></div>
<div class="line"><span class="lineno"> 1966</span>    <span class="keywordflow">if</span> isinstance(fname, os_PathLike):</div>
<div class="line"><span class="lineno"> 1967</span>        fname = os_fspath(fname)</div>
<div class="line"><span class="lineno"> 1968</span>    <span class="keywordflow">if</span> isinstance(fname, str):</div>
<div class="line"><span class="lineno"> 1969</span>        fid = np.lib._datasource.open(fname, <span class="stringliteral">&#39;rt&#39;</span>, encoding=encoding)</div>
<div class="line"><span class="lineno"> 1970</span>        fid_ctx = contextlib.closing(fid)</div>
<div class="line"><span class="lineno"> 1971</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1972</span>        fid = fname</div>
<div class="line"><span class="lineno"> 1973</span>        fid_ctx = contextlib.nullcontext(fid)</div>
<div class="line"><span class="lineno"> 1974</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1975</span>        fhd = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(fid)</div>
<div class="line"><span class="lineno"> 1976</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 1977</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1978</span>            <span class="stringliteral">&quot;fname must be a string, a filehandle, a sequence of strings,\n&quot;</span></div>
<div class="line"><span class="lineno"> 1979</span>            f<span class="stringliteral">&quot;or an iterator of strings. Got {type(fname)} instead.&quot;</span></div>
<div class="line"><span class="lineno"> 1980</span>        ) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 1981</span>    <span class="keyword">with</span> fid_ctx:</div>
<div class="line"><span class="lineno"> 1982</span>        split_line = LineSplitter(delimiter=delimiter, comments=comments,</div>
<div class="line"><span class="lineno"> 1983</span>                                  autostrip=autostrip, encoding=encoding)</div>
<div class="line"><span class="lineno"> 1984</span>        validate_names = NameValidator(excludelist=excludelist,</div>
<div class="line"><span class="lineno"> 1985</span>                                       deletechars=deletechars,</div>
<div class="line"><span class="lineno"> 1986</span>                                       case_sensitive=case_sensitive,</div>
<div class="line"><span class="lineno"> 1987</span>                                       replace_space=replace_space)</div>
<div class="line"><span class="lineno"> 1988</span> </div>
<div class="line"><span class="lineno"> 1989</span>        <span class="comment"># Skip the first `skip_header` rows</span></div>
<div class="line"><span class="lineno"> 1990</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1991</span>            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(skip_header):</div>
<div class="line"><span class="lineno"> 1992</span>                next(fhd)</div>
<div class="line"><span class="lineno"> 1993</span> </div>
<div class="line"><span class="lineno"> 1994</span>            <span class="comment"># Keep on until we find the first valid values</span></div>
<div class="line"><span class="lineno"> 1995</span>            first_values = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1996</span> </div>
<div class="line"><span class="lineno"> 1997</span>            <span class="keywordflow">while</span> <span class="keywordflow">not</span> first_values:</div>
<div class="line"><span class="lineno"> 1998</span>                first_line = _decode_line(next(fhd), encoding)</div>
<div class="line"><span class="lineno"> 1999</span>                <span class="keywordflow">if</span> (names <span class="keywordflow">is</span> <span class="keyword">True</span>) <span class="keywordflow">and</span> (comments <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2000</span>                    <span class="keywordflow">if</span> comments <span class="keywordflow">in</span> first_line:</div>
<div class="line"><span class="lineno"> 2001</span>                        first_line = (</div>
<div class="line"><span class="lineno"> 2002</span>                            <span class="stringliteral">&#39;&#39;</span>.join(first_line.split(comments)[1:]))</div>
<div class="line"><span class="lineno"> 2003</span>                first_values = split_line(first_line)</div>
<div class="line"><span class="lineno"> 2004</span>        <span class="keywordflow">except</span> StopIteration:</div>
<div class="line"><span class="lineno"> 2005</span>            <span class="comment"># return an empty array if the datafile is empty</span></div>
<div class="line"><span class="lineno"> 2006</span>            first_line = <span class="stringliteral">&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 2007</span>            first_values = []</div>
<div class="line"><span class="lineno"> 2008</span>            warnings.warn(<span class="stringliteral">&#39;genfromtxt: Empty input file: &quot;%s&quot;&#39;</span> % fname, stacklevel=2)</div>
<div class="line"><span class="lineno"> 2009</span> </div>
<div class="line"><span class="lineno"> 2010</span>        <span class="comment"># Should we take the first values as names ?</span></div>
<div class="line"><span class="lineno"> 2011</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno"> 2012</span>            fval = first_values[0].strip()</div>
<div class="line"><span class="lineno"> 2013</span>            <span class="keywordflow">if</span> comments <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2014</span>                <span class="keywordflow">if</span> fval <span class="keywordflow">in</span> comments:</div>
<div class="line"><span class="lineno"> 2015</span>                    del first_values[0]</div>
<div class="line"><span class="lineno"> 2016</span> </div>
<div class="line"><span class="lineno"> 2017</span>        <span class="comment"># Check the columns to use: make sure `usecols` is a list</span></div>
<div class="line"><span class="lineno"> 2018</span>        <span class="keywordflow">if</span> usecols <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2019</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2020</span>                usecols = [_.strip() <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> usecols.split(<span class="stringliteral">&quot;,&quot;</span>)]</div>
<div class="line"><span class="lineno"> 2021</span>            <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 2022</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2023</span>                    usecols = list(usecols)</div>
<div class="line"><span class="lineno"> 2024</span>                <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 2025</span>                    usecols = [usecols, ]</div>
<div class="line"><span class="lineno"> 2026</span>        nbcols = len(usecols <span class="keywordflow">or</span> first_values)</div>
<div class="line"><span class="lineno"> 2027</span> </div>
<div class="line"><span class="lineno"> 2028</span>        <span class="comment"># Check the names and overwrite the dtype.names if needed</span></div>
<div class="line"><span class="lineno"> 2029</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno"> 2030</span>            names = validate_names([str(_.strip()) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> first_values])</div>
<div class="line"><span class="lineno"> 2031</span>            first_line = <span class="stringliteral">&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 2032</span>        <span class="keywordflow">elif</span> _is_string_like(names):</div>
<div class="line"><span class="lineno"> 2033</span>            names = validate_names([_.strip() <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> names.split(<span class="stringliteral">&#39;,&#39;</span>)])</div>
<div class="line"><span class="lineno"> 2034</span>        <span class="keywordflow">elif</span> names:</div>
<div class="line"><span class="lineno"> 2035</span>            names = validate_names(names)</div>
<div class="line"><span class="lineno"> 2036</span>        <span class="comment"># Get the dtype</span></div>
<div class="line"><span class="lineno"> 2037</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2038</span>            dtype = easy_dtype(dtype, defaultfmt=defaultfmt, names=names,</div>
<div class="line"><span class="lineno"> 2039</span>                               excludelist=excludelist,</div>
<div class="line"><span class="lineno"> 2040</span>                               deletechars=deletechars,</div>
<div class="line"><span class="lineno"> 2041</span>                               case_sensitive=case_sensitive,</div>
<div class="line"><span class="lineno"> 2042</span>                               replace_space=replace_space)</div>
<div class="line"><span class="lineno"> 2043</span>        <span class="comment"># Make sure the names is a list (for 2.5)</span></div>
<div class="line"><span class="lineno"> 2044</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2045</span>            names = list(names)</div>
<div class="line"><span class="lineno"> 2046</span> </div>
<div class="line"><span class="lineno"> 2047</span>        <span class="keywordflow">if</span> usecols:</div>
<div class="line"><span class="lineno"> 2048</span>            <span class="keywordflow">for</span> (i, current) <span class="keywordflow">in</span> enumerate(usecols):</div>
<div class="line"><span class="lineno"> 2049</span>                <span class="comment"># if usecols is a list of names, convert to a list of indices</span></div>
<div class="line"><span class="lineno"> 2050</span>                <span class="keywordflow">if</span> _is_string_like(current):</div>
<div class="line"><span class="lineno"> 2051</span>                    usecols[i] = names.index(current)</div>
<div class="line"><span class="lineno"> 2052</span>                <span class="keywordflow">elif</span> current &lt; 0:</div>
<div class="line"><span class="lineno"> 2053</span>                    usecols[i] = current + len(first_values)</div>
<div class="line"><span class="lineno"> 2054</span>            <span class="comment"># If the dtype is not None, make sure we update it</span></div>
<div class="line"><span class="lineno"> 2055</span>            <span class="keywordflow">if</span> (dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (len(dtype) &gt; nbcols):</div>
<div class="line"><span class="lineno"> 2056</span>                descr = dtype.descr</div>
<div class="line"><span class="lineno"> 2057</span>                dtype = np.dtype([descr[_] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> usecols])</div>
<div class="line"><span class="lineno"> 2058</span>                names = list(dtype.names)</div>
<div class="line"><span class="lineno"> 2059</span>            <span class="comment"># If `names` is not None, update the names</span></div>
<div class="line"><span class="lineno"> 2060</span>            <span class="keywordflow">elif</span> (names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (len(names) &gt; nbcols):</div>
<div class="line"><span class="lineno"> 2061</span>                names = [names[_] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> usecols]</div>
<div class="line"><span class="lineno"> 2062</span>        <span class="keywordflow">elif</span> (names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2063</span>            names = list(dtype.names)</div>
<div class="line"><span class="lineno"> 2064</span> </div>
<div class="line"><span class="lineno"> 2065</span>        <span class="comment"># Process the missing values ...............................</span></div>
<div class="line"><span class="lineno"> 2066</span>        <span class="comment"># Rename missing_values for convenience</span></div>
<div class="line"><span class="lineno"> 2067</span>        user_missing_values = missing_values <span class="keywordflow">or</span> ()</div>
<div class="line"><span class="lineno"> 2068</span>        <span class="keywordflow">if</span> isinstance(user_missing_values, bytes):</div>
<div class="line"><span class="lineno"> 2069</span>            user_missing_values = user_missing_values.decode(<span class="stringliteral">&#39;latin1&#39;</span>)</div>
<div class="line"><span class="lineno"> 2070</span> </div>
<div class="line"><span class="lineno"> 2071</span>        <span class="comment"># Define the list of missing_values (one column: one list)</span></div>
<div class="line"><span class="lineno"> 2072</span>        missing_values = [list([<span class="stringliteral">&#39;&#39;</span>]) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(nbcols)]</div>
<div class="line"><span class="lineno"> 2073</span> </div>
<div class="line"><span class="lineno"> 2074</span>        <span class="comment"># We have a dictionary: process it field by field</span></div>
<div class="line"><span class="lineno"> 2075</span>        <span class="keywordflow">if</span> isinstance(user_missing_values, dict):</div>
<div class="line"><span class="lineno"> 2076</span>            <span class="comment"># Loop on the items</span></div>
<div class="line"><span class="lineno"> 2077</span>            <span class="keywordflow">for</span> (key, val) <span class="keywordflow">in</span> user_missing_values.items():</div>
<div class="line"><span class="lineno"> 2078</span>                <span class="comment"># Is the key a string ?</span></div>
<div class="line"><span class="lineno"> 2079</span>                <span class="keywordflow">if</span> _is_string_like(key):</div>
<div class="line"><span class="lineno"> 2080</span>                    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2081</span>                        <span class="comment"># Transform it into an integer</span></div>
<div class="line"><span class="lineno"> 2082</span>                        key = names.index(key)</div>
<div class="line"><span class="lineno"> 2083</span>                    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 2084</span>                        <span class="comment"># We couldn&#39;t find it: the name must have been dropped</span></div>
<div class="line"><span class="lineno"> 2085</span>                        <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2086</span>                <span class="comment"># Redefine the key as needed if it&#39;s a column number</span></div>
<div class="line"><span class="lineno"> 2087</span>                <span class="keywordflow">if</span> usecols:</div>
<div class="line"><span class="lineno"> 2088</span>                    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2089</span>                        key = usecols.index(key)</div>
<div class="line"><span class="lineno"> 2090</span>                    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 2091</span>                        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 2092</span>                <span class="comment"># Transform the value as a list of string</span></div>
<div class="line"><span class="lineno"> 2093</span>                <span class="keywordflow">if</span> isinstance(val, (list, tuple)):</div>
<div class="line"><span class="lineno"> 2094</span>                    val = [str(_) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> val]</div>
<div class="line"><span class="lineno"> 2095</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2096</span>                    val = [str(val), ]</div>
<div class="line"><span class="lineno"> 2097</span>                <span class="comment"># Add the value(s) to the current list of missing</span></div>
<div class="line"><span class="lineno"> 2098</span>                <span class="keywordflow">if</span> key <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2099</span>                    <span class="comment"># None acts as default</span></div>
<div class="line"><span class="lineno"> 2100</span>                    <span class="keywordflow">for</span> miss <span class="keywordflow">in</span> missing_values:</div>
<div class="line"><span class="lineno"> 2101</span>                        miss.extend(val)</div>
<div class="line"><span class="lineno"> 2102</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2103</span>                    missing_values[key].extend(val)</div>
<div class="line"><span class="lineno"> 2104</span>        <span class="comment"># We have a sequence : each item matches a column</span></div>
<div class="line"><span class="lineno"> 2105</span>        <span class="keywordflow">elif</span> isinstance(user_missing_values, (list, tuple)):</div>
<div class="line"><span class="lineno"> 2106</span>            <span class="keywordflow">for</span> (value, entry) <span class="keywordflow">in</span> zip(user_missing_values, missing_values):</div>
<div class="line"><span class="lineno"> 2107</span>                value = str(value)</div>
<div class="line"><span class="lineno"> 2108</span>                <span class="keywordflow">if</span> value <span class="keywordflow">not</span> <span class="keywordflow">in</span> entry:</div>
<div class="line"><span class="lineno"> 2109</span>                    entry.append(value)</div>
<div class="line"><span class="lineno"> 2110</span>        <span class="comment"># We have a string : apply it to all entries</span></div>
<div class="line"><span class="lineno"> 2111</span>        <span class="keywordflow">elif</span> isinstance(user_missing_values, str):</div>
<div class="line"><span class="lineno"> 2112</span>            user_value = user_missing_values.split(<span class="stringliteral">&quot;,&quot;</span>)</div>
<div class="line"><span class="lineno"> 2113</span>            <span class="keywordflow">for</span> entry <span class="keywordflow">in</span> missing_values:</div>
<div class="line"><span class="lineno"> 2114</span>                entry.extend(user_value)</div>
<div class="line"><span class="lineno"> 2115</span>        <span class="comment"># We have something else: apply it to all entries</span></div>
<div class="line"><span class="lineno"> 2116</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2117</span>            <span class="keywordflow">for</span> entry <span class="keywordflow">in</span> missing_values:</div>
<div class="line"><span class="lineno"> 2118</span>                entry.extend([str(user_missing_values)])</div>
<div class="line"><span class="lineno"> 2119</span> </div>
<div class="line"><span class="lineno"> 2120</span>        <span class="comment"># Process the filling_values ...............................</span></div>
<div class="line"><span class="lineno"> 2121</span>        <span class="comment"># Rename the input for convenience</span></div>
<div class="line"><span class="lineno"> 2122</span>        user_filling_values = filling_values</div>
<div class="line"><span class="lineno"> 2123</span>        <span class="keywordflow">if</span> user_filling_values <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2124</span>            user_filling_values = []</div>
<div class="line"><span class="lineno"> 2125</span>        <span class="comment"># Define the default</span></div>
<div class="line"><span class="lineno"> 2126</span>        filling_values = [<span class="keywordtype">None</span>] * nbcols</div>
<div class="line"><span class="lineno"> 2127</span>        <span class="comment"># We have a dictionary : update each entry individually</span></div>
<div class="line"><span class="lineno"> 2128</span>        <span class="keywordflow">if</span> isinstance(user_filling_values, dict):</div>
<div class="line"><span class="lineno"> 2129</span>            <span class="keywordflow">for</span> (key, val) <span class="keywordflow">in</span> user_filling_values.items():</div>
<div class="line"><span class="lineno"> 2130</span>                <span class="keywordflow">if</span> _is_string_like(key):</div>
<div class="line"><span class="lineno"> 2131</span>                    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2132</span>                        <span class="comment"># Transform it into an integer</span></div>
<div class="line"><span class="lineno"> 2133</span>                        key = names.index(key)</div>
<div class="line"><span class="lineno"> 2134</span>                    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 2135</span>                        <span class="comment"># We couldn&#39;t find it: the name must have been dropped,</span></div>
<div class="line"><span class="lineno"> 2136</span>                        <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2137</span>                <span class="comment"># Redefine the key if it&#39;s a column number and usecols is defined</span></div>
<div class="line"><span class="lineno"> 2138</span>                <span class="keywordflow">if</span> usecols:</div>
<div class="line"><span class="lineno"> 2139</span>                    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2140</span>                        key = usecols.index(key)</div>
<div class="line"><span class="lineno"> 2141</span>                    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 2142</span>                        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 2143</span>                <span class="comment"># Add the value to the list</span></div>
<div class="line"><span class="lineno"> 2144</span>                filling_values[key] = val</div>
<div class="line"><span class="lineno"> 2145</span>        <span class="comment"># We have a sequence : update on a one-to-one basis</span></div>
<div class="line"><span class="lineno"> 2146</span>        <span class="keywordflow">elif</span> isinstance(user_filling_values, (list, tuple)):</div>
<div class="line"><span class="lineno"> 2147</span>            n = len(user_filling_values)</div>
<div class="line"><span class="lineno"> 2148</span>            <span class="keywordflow">if</span> (n &lt;= nbcols):</div>
<div class="line"><span class="lineno"> 2149</span>                filling_values[:n] = user_filling_values</div>
<div class="line"><span class="lineno"> 2150</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2151</span>                filling_values = user_filling_values[:nbcols]</div>
<div class="line"><span class="lineno"> 2152</span>        <span class="comment"># We have something else : use it for all entries</span></div>
<div class="line"><span class="lineno"> 2153</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2154</span>            filling_values = [user_filling_values] * nbcols</div>
<div class="line"><span class="lineno"> 2155</span> </div>
<div class="line"><span class="lineno"> 2156</span>        <span class="comment"># Initialize the converters ................................</span></div>
<div class="line"><span class="lineno"> 2157</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2158</span>            <span class="comment"># Note: we can&#39;t use a [...]*nbcols, as we would have 3 times the same</span></div>
<div class="line"><span class="lineno"> 2159</span>            <span class="comment"># ... converter, instead of 3 different converters.</span></div>
<div class="line"><span class="lineno"> 2160</span>            converters = [StringConverter(<span class="keywordtype">None</span>, missing_values=miss, default=fill)</div>
<div class="line"><span class="lineno"> 2161</span>                          <span class="keywordflow">for</span> (miss, fill) <span class="keywordflow">in</span> zip(missing_values, filling_values)]</div>
<div class="line"><span class="lineno"> 2162</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2163</span>            dtype_flat = flatten_dtype(dtype, flatten_base=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2164</span>            <span class="comment"># Initialize the converters</span></div>
<div class="line"><span class="lineno"> 2165</span>            <span class="keywordflow">if</span> len(dtype_flat) &gt; 1:</div>
<div class="line"><span class="lineno"> 2166</span>                <span class="comment"># Flexible type : get a converter from each dtype</span></div>
<div class="line"><span class="lineno"> 2167</span>                zipit = zip(dtype_flat, missing_values, filling_values)</div>
<div class="line"><span class="lineno"> 2168</span>                converters = [StringConverter(dt, locked=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 2169</span>                                              missing_values=miss, default=fill)</div>
<div class="line"><span class="lineno"> 2170</span>                              <span class="keywordflow">for</span> (dt, miss, fill) <span class="keywordflow">in</span> zipit]</div>
<div class="line"><span class="lineno"> 2171</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2172</span>                <span class="comment"># Set to a default converter (but w/ different missing values)</span></div>
<div class="line"><span class="lineno"> 2173</span>                zipit = zip(missing_values, filling_values)</div>
<div class="line"><span class="lineno"> 2174</span>                converters = [StringConverter(dtype, locked=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 2175</span>                                              missing_values=miss, default=fill)</div>
<div class="line"><span class="lineno"> 2176</span>                              <span class="keywordflow">for</span> (miss, fill) <span class="keywordflow">in</span> zipit]</div>
<div class="line"><span class="lineno"> 2177</span>        <span class="comment"># Update the converters to use the user-defined ones</span></div>
<div class="line"><span class="lineno"> 2178</span>        uc_update = []</div>
<div class="line"><span class="lineno"> 2179</span>        <span class="keywordflow">for</span> (j, conv) <span class="keywordflow">in</span> user_converters.items():</div>
<div class="line"><span class="lineno"> 2180</span>            <span class="comment"># If the converter is specified by column names, use the index instead</span></div>
<div class="line"><span class="lineno"> 2181</span>            <span class="keywordflow">if</span> _is_string_like(j):</div>
<div class="line"><span class="lineno"> 2182</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2183</span>                    j = names.index(j)</div>
<div class="line"><span class="lineno"> 2184</span>                    i = j</div>
<div class="line"><span class="lineno"> 2185</span>                <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 2186</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2187</span>            <span class="keywordflow">elif</span> usecols:</div>
<div class="line"><span class="lineno"> 2188</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2189</span>                    i = usecols.index(j)</div>
<div class="line"><span class="lineno"> 2190</span>                <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 2191</span>                    <span class="comment"># Unused converter specified</span></div>
<div class="line"><span class="lineno"> 2192</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2193</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2194</span>                i = j</div>
<div class="line"><span class="lineno"> 2195</span>            <span class="comment"># Find the value to test - first_line is not filtered by usecols:</span></div>
<div class="line"><span class="lineno"> 2196</span>            <span class="keywordflow">if</span> len(first_line):</div>
<div class="line"><span class="lineno"> 2197</span>                testing_value = first_values[j]</div>
<div class="line"><span class="lineno"> 2198</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2199</span>                testing_value = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2200</span>            <span class="keywordflow">if</span> conv <span class="keywordflow">is</span> bytes:</div>
<div class="line"><span class="lineno"> 2201</span>                user_conv = asbytes</div>
<div class="line"><span class="lineno"> 2202</span>            <span class="keywordflow">elif</span> byte_converters:</div>
<div class="line"><span class="lineno"> 2203</span>                <span class="comment"># converters may use decode to workaround numpy&#39;s old behaviour,</span></div>
<div class="line"><span class="lineno"> 2204</span>                <span class="comment"># so encode the string again before passing to the user converter</span></div>
<div class="line"><span class="lineno"> 2205</span>                <span class="keyword">def </span>tobytes_first(x, conv):</div>
<div class="line"><span class="lineno"> 2206</span>                    <span class="keywordflow">if</span> type(x) <span class="keywordflow">is</span> bytes:</div>
<div class="line"><span class="lineno"> 2207</span>                        <span class="keywordflow">return</span> conv(x)</div>
<div class="line"><span class="lineno"> 2208</span>                    <span class="keywordflow">return</span> conv(x.encode(<span class="stringliteral">&quot;latin1&quot;</span>))</div>
<div class="line"><span class="lineno"> 2209</span>                user_conv = functools.partial(tobytes_first, conv=conv)</div>
<div class="line"><span class="lineno"> 2210</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2211</span>                user_conv = conv</div>
<div class="line"><span class="lineno"> 2212</span>            converters[i].update(user_conv, locked=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 2213</span>                                 testing_value=testing_value,</div>
<div class="line"><span class="lineno"> 2214</span>                                 default=filling_values[i],</div>
<div class="line"><span class="lineno"> 2215</span>                                 missing_values=missing_values[i],)</div>
<div class="line"><span class="lineno"> 2216</span>            uc_update.append((i, user_conv))</div>
<div class="line"><span class="lineno"> 2217</span>        <span class="comment"># Make sure we have the corrected keys in user_converters...</span></div>
<div class="line"><span class="lineno"> 2218</span>        user_converters.update(uc_update)</div>
<div class="line"><span class="lineno"> 2219</span> </div>
<div class="line"><span class="lineno"> 2220</span>        <span class="comment"># Fixme: possible error as following variable never used.</span></div>
<div class="line"><span class="lineno"> 2221</span>        <span class="comment"># miss_chars = [_.missing_values for _ in converters]</span></div>
<div class="line"><span class="lineno"> 2222</span> </div>
<div class="line"><span class="lineno"> 2223</span>        <span class="comment"># Initialize the output lists ...</span></div>
<div class="line"><span class="lineno"> 2224</span>        <span class="comment"># ... rows</span></div>
<div class="line"><span class="lineno"> 2225</span>        rows = []</div>
<div class="line"><span class="lineno"> 2226</span>        append_to_rows = rows.append</div>
<div class="line"><span class="lineno"> 2227</span>        <span class="comment"># ... masks</span></div>
<div class="line"><span class="lineno"> 2228</span>        <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2229</span>            masks = []</div>
<div class="line"><span class="lineno"> 2230</span>            append_to_masks = masks.append</div>
<div class="line"><span class="lineno"> 2231</span>        <span class="comment"># ... invalid</span></div>
<div class="line"><span class="lineno"> 2232</span>        invalid = []</div>
<div class="line"><span class="lineno"> 2233</span>        append_to_invalid = invalid.append</div>
<div class="line"><span class="lineno"> 2234</span> </div>
<div class="line"><span class="lineno"> 2235</span>        <span class="comment"># Parse each line</span></div>
<div class="line"><span class="lineno"> 2236</span>        <span class="keywordflow">for</span> (i, line) <span class="keywordflow">in</span> enumerate(itertools.chain([first_line, ], fhd)):</div>
<div class="line"><span class="lineno"> 2237</span>            values = split_line(line)</div>
<div class="line"><span class="lineno"> 2238</span>            nbvalues = len(values)</div>
<div class="line"><span class="lineno"> 2239</span>            <span class="comment"># Skip an empty line</span></div>
<div class="line"><span class="lineno"> 2240</span>            <span class="keywordflow">if</span> nbvalues == 0:</div>
<div class="line"><span class="lineno"> 2241</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2242</span>            <span class="keywordflow">if</span> usecols:</div>
<div class="line"><span class="lineno"> 2243</span>                <span class="comment"># Select only the columns we need</span></div>
<div class="line"><span class="lineno"> 2244</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2245</span>                    values = [values[_] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> usecols]</div>
<div class="line"><span class="lineno"> 2246</span>                <span class="keywordflow">except</span> IndexError:</div>
<div class="line"><span class="lineno"> 2247</span>                    append_to_invalid((i + skip_header + 1, nbvalues))</div>
<div class="line"><span class="lineno"> 2248</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2249</span>            <span class="keywordflow">elif</span> nbvalues != nbcols:</div>
<div class="line"><span class="lineno"> 2250</span>                append_to_invalid((i + skip_header + 1, nbvalues))</div>
<div class="line"><span class="lineno"> 2251</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2252</span>            <span class="comment"># Store the values</span></div>
<div class="line"><span class="lineno"> 2253</span>            append_to_rows(tuple(values))</div>
<div class="line"><span class="lineno"> 2254</span>            <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2255</span>                append_to_masks(tuple([v.strip() <span class="keywordflow">in</span> m</div>
<div class="line"><span class="lineno"> 2256</span>                                       <span class="keywordflow">for</span> (v, m) <span class="keywordflow">in</span> zip(values,</div>
<div class="line"><span class="lineno"> 2257</span>                                                         missing_values)]))</div>
<div class="line"><span class="lineno"> 2258</span>            <span class="keywordflow">if</span> len(rows) == max_rows:</div>
<div class="line"><span class="lineno"> 2259</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 2260</span> </div>
<div class="line"><span class="lineno"> 2261</span>    <span class="comment"># Upgrade the converters (if needed)</span></div>
<div class="line"><span class="lineno"> 2262</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2263</span>        <span class="keywordflow">for</span> (i, converter) <span class="keywordflow">in</span> enumerate(converters):</div>
<div class="line"><span class="lineno"> 2264</span>            current_column = [itemgetter(i)(_m) <span class="keywordflow">for</span> _m <span class="keywordflow">in</span> rows]</div>
<div class="line"><span class="lineno"> 2265</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2266</span>                converter.iterupgrade(current_column)</div>
<div class="line"><span class="lineno"> 2267</span>            <span class="keywordflow">except</span> ConverterLockError:</div>
<div class="line"><span class="lineno"> 2268</span>                errmsg = <span class="stringliteral">&quot;Converter #%i is locked and cannot be upgraded: &quot;</span> % i</div>
<div class="line"><span class="lineno"> 2269</span>                current_column = map(itemgetter(i), rows)</div>
<div class="line"><span class="lineno"> 2270</span>                <span class="keywordflow">for</span> (j, value) <span class="keywordflow">in</span> enumerate(current_column):</div>
<div class="line"><span class="lineno"> 2271</span>                    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2272</span>                        converter.upgrade(value)</div>
<div class="line"><span class="lineno"> 2273</span>                    <span class="keywordflow">except</span> (ConverterError, ValueError):</div>
<div class="line"><span class="lineno"> 2274</span>                        errmsg += <span class="stringliteral">&quot;(occurred line #%i for value &#39;%s&#39;)&quot;</span></div>
<div class="line"><span class="lineno"> 2275</span>                        errmsg %= (j + 1 + skip_header, value)</div>
<div class="line"><span class="lineno"> 2276</span>                        <span class="keywordflow">raise</span> ConverterError(errmsg)</div>
<div class="line"><span class="lineno"> 2277</span> </div>
<div class="line"><span class="lineno"> 2278</span>    <span class="comment"># Check that we don&#39;t have invalid values</span></div>
<div class="line"><span class="lineno"> 2279</span>    nbinvalid = len(invalid)</div>
<div class="line"><span class="lineno"> 2280</span>    <span class="keywordflow">if</span> nbinvalid &gt; 0:</div>
<div class="line"><span class="lineno"> 2281</span>        nbrows = len(rows) + nbinvalid - skip_footer</div>
<div class="line"><span class="lineno"> 2282</span>        <span class="comment"># Construct the error message</span></div>
<div class="line"><span class="lineno"> 2283</span>        template = <span class="stringliteral">&quot;    Line #%%i (got %%i columns instead of %i)&quot;</span> % nbcols</div>
<div class="line"><span class="lineno"> 2284</span>        <span class="keywordflow">if</span> skip_footer &gt; 0:</div>
<div class="line"><span class="lineno"> 2285</span>            nbinvalid_skipped = len([_ <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> invalid</div>
<div class="line"><span class="lineno"> 2286</span>                                     <span class="keywordflow">if</span> _[0] &gt; nbrows + skip_header])</div>
<div class="line"><span class="lineno"> 2287</span>            invalid = invalid[:nbinvalid - nbinvalid_skipped]</div>
<div class="line"><span class="lineno"> 2288</span>            skip_footer -= nbinvalid_skipped</div>
<div class="line"><span class="lineno"> 2289</span><span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2290</span><span class="comment">#            nbrows -= skip_footer</span></div>
<div class="line"><span class="lineno"> 2291</span><span class="comment">#            errmsg = [template % (i, nb)</span></div>
<div class="line"><span class="lineno"> 2292</span><span class="comment">#                      for (i, nb) in invalid if i &lt; nbrows]</span></div>
<div class="line"><span class="lineno"> 2293</span><span class="comment">#        else:</span></div>
<div class="line"><span class="lineno"> 2294</span>        errmsg = [template % (i, nb)</div>
<div class="line"><span class="lineno"> 2295</span>                  <span class="keywordflow">for</span> (i, nb) <span class="keywordflow">in</span> invalid]</div>
<div class="line"><span class="lineno"> 2296</span>        <span class="keywordflow">if</span> len(errmsg):</div>
<div class="line"><span class="lineno"> 2297</span>            errmsg.insert(0, <span class="stringliteral">&quot;Some errors were detected !&quot;</span>)</div>
<div class="line"><span class="lineno"> 2298</span>            errmsg = <span class="stringliteral">&quot;\n&quot;</span>.join(errmsg)</div>
<div class="line"><span class="lineno"> 2299</span>            <span class="comment"># Raise an exception ?</span></div>
<div class="line"><span class="lineno"> 2300</span>            <span class="keywordflow">if</span> invalid_raise:</div>
<div class="line"><span class="lineno"> 2301</span>                <span class="keywordflow">raise</span> ValueError(errmsg)</div>
<div class="line"><span class="lineno"> 2302</span>            <span class="comment"># Issue a warning ?</span></div>
<div class="line"><span class="lineno"> 2303</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2304</span>                warnings.warn(errmsg, ConversionWarning, stacklevel=2)</div>
<div class="line"><span class="lineno"> 2305</span> </div>
<div class="line"><span class="lineno"> 2306</span>    <span class="comment"># Strip the last skip_footer data</span></div>
<div class="line"><span class="lineno"> 2307</span>    <span class="keywordflow">if</span> skip_footer &gt; 0:</div>
<div class="line"><span class="lineno"> 2308</span>        rows = rows[:-skip_footer]</div>
<div class="line"><span class="lineno"> 2309</span>        <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2310</span>            masks = masks[:-skip_footer]</div>
<div class="line"><span class="lineno"> 2311</span> </div>
<div class="line"><span class="lineno"> 2312</span>    <span class="comment"># Convert each value according to the converter:</span></div>
<div class="line"><span class="lineno"> 2313</span>    <span class="comment"># We want to modify the list in place to avoid creating a new one...</span></div>
<div class="line"><span class="lineno"> 2314</span>    <span class="keywordflow">if</span> loose:</div>
<div class="line"><span class="lineno"> 2315</span>        rows = list(</div>
<div class="line"><span class="lineno"> 2316</span>            zip(*[[conv._loose_call(_r) <span class="keywordflow">for</span> _r <span class="keywordflow">in</span> map(itemgetter(i), rows)]</div>
<div class="line"><span class="lineno"> 2317</span>                  <span class="keywordflow">for</span> (i, conv) <span class="keywordflow">in</span> enumerate(converters)]))</div>
<div class="line"><span class="lineno"> 2318</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2319</span>        rows = list(</div>
<div class="line"><span class="lineno"> 2320</span>            zip(*[[conv._strict_call(_r) <span class="keywordflow">for</span> _r <span class="keywordflow">in</span> map(itemgetter(i), rows)]</div>
<div class="line"><span class="lineno"> 2321</span>                  <span class="keywordflow">for</span> (i, conv) <span class="keywordflow">in</span> enumerate(converters)]))</div>
<div class="line"><span class="lineno"> 2322</span> </div>
<div class="line"><span class="lineno"> 2323</span>    <span class="comment"># Reset the dtype</span></div>
<div class="line"><span class="lineno"> 2324</span>    data = rows</div>
<div class="line"><span class="lineno"> 2325</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2326</span>        <span class="comment"># Get the dtypes from the types of the converters</span></div>
<div class="line"><span class="lineno"> 2327</span>        column_types = [conv.type <span class="keywordflow">for</span> conv <span class="keywordflow">in</span> converters]</div>
<div class="line"><span class="lineno"> 2328</span>        <span class="comment"># Find the columns with strings...</span></div>
<div class="line"><span class="lineno"> 2329</span>        strcolidx = [i <span class="keywordflow">for</span> (i, v) <span class="keywordflow">in</span> enumerate(column_types)</div>
<div class="line"><span class="lineno"> 2330</span>                     <span class="keywordflow">if</span> v == np.unicode_]</div>
<div class="line"><span class="lineno"> 2331</span> </div>
<div class="line"><span class="lineno"> 2332</span>        <span class="keywordflow">if</span> byte_converters <span class="keywordflow">and</span> strcolidx:</div>
<div class="line"><span class="lineno"> 2333</span>            <span class="comment"># convert strings back to bytes for backward compatibility</span></div>
<div class="line"><span class="lineno"> 2334</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 2335</span>                <span class="stringliteral">&quot;Reading unicode strings without specifying the encoding &quot;</span></div>
<div class="line"><span class="lineno"> 2336</span>                <span class="stringliteral">&quot;argument is deprecated. Set the encoding, use None for the &quot;</span></div>
<div class="line"><span class="lineno"> 2337</span>                <span class="stringliteral">&quot;system default.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2338</span>                np.VisibleDeprecationWarning, stacklevel=2)</div>
<div class="line"><span class="lineno"> 2339</span>            <span class="keyword">def </span>encode_unicode_cols(row_tup):</div>
<div class="line"><span class="lineno"> 2340</span>                row = list(row_tup)</div>
<div class="line"><span class="lineno"> 2341</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> strcolidx:</div>
<div class="line"><span class="lineno"> 2342</span>                    row[i] = row[i].encode(<span class="stringliteral">&#39;latin1&#39;</span>)</div>
<div class="line"><span class="lineno"> 2343</span>                <span class="keywordflow">return</span> tuple(row)</div>
<div class="line"><span class="lineno"> 2344</span> </div>
<div class="line"><span class="lineno"> 2345</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2346</span>                data = [encode_unicode_cols(r) <span class="keywordflow">for</span> r <span class="keywordflow">in</span> data]</div>
<div class="line"><span class="lineno"> 2347</span>            <span class="keywordflow">except</span> UnicodeEncodeError:</div>
<div class="line"><span class="lineno"> 2348</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 2349</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2350</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> strcolidx:</div>
<div class="line"><span class="lineno"> 2351</span>                    column_types[i] = np.bytes_</div>
<div class="line"><span class="lineno"> 2352</span> </div>
<div class="line"><span class="lineno"> 2353</span>        <span class="comment"># Update string types to be the right length</span></div>
<div class="line"><span class="lineno"> 2354</span>        sized_column_types = column_types[:]</div>
<div class="line"><span class="lineno"> 2355</span>        <span class="keywordflow">for</span> i, col_type <span class="keywordflow">in</span> enumerate(column_types):</div>
<div class="line"><span class="lineno"> 2356</span>            <span class="keywordflow">if</span> np.issubdtype(col_type, np.character):</div>
<div class="line"><span class="lineno"> 2357</span>                n_chars = max(len(row[i]) <span class="keywordflow">for</span> row <span class="keywordflow">in</span> data)</div>
<div class="line"><span class="lineno"> 2358</span>                sized_column_types[i] = (col_type, n_chars)</div>
<div class="line"><span class="lineno"> 2359</span> </div>
<div class="line"><span class="lineno"> 2360</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2361</span>            <span class="comment"># If the dtype is uniform (before sizing strings)</span></div>
<div class="line"><span class="lineno"> 2362</span>            base = {</div>
<div class="line"><span class="lineno"> 2363</span>                c_type</div>
<div class="line"><span class="lineno"> 2364</span>                <span class="keywordflow">for</span> c, c_type <span class="keywordflow">in</span> zip(converters, column_types)</div>
<div class="line"><span class="lineno"> 2365</span>                <span class="keywordflow">if</span> c._checked}</div>
<div class="line"><span class="lineno"> 2366</span>            <span class="keywordflow">if</span> len(base) == 1:</div>
<div class="line"><span class="lineno"> 2367</span>                uniform_type, = base</div>
<div class="line"><span class="lineno"> 2368</span>                (ddtype, mdtype) = (uniform_type, bool)</div>
<div class="line"><span class="lineno"> 2369</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2370</span>                ddtype = [(defaultfmt % i, dt)</div>
<div class="line"><span class="lineno"> 2371</span>                          <span class="keywordflow">for</span> (i, dt) <span class="keywordflow">in</span> enumerate(sized_column_types)]</div>
<div class="line"><span class="lineno"> 2372</span>                <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2373</span>                    mdtype = [(defaultfmt % i, bool)</div>
<div class="line"><span class="lineno"> 2374</span>                              <span class="keywordflow">for</span> (i, dt) <span class="keywordflow">in</span> enumerate(sized_column_types)]</div>
<div class="line"><span class="lineno"> 2375</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2376</span>            ddtype = list(zip(names, sized_column_types))</div>
<div class="line"><span class="lineno"> 2377</span>            mdtype = list(zip(names, [bool] * len(sized_column_types)))</div>
<div class="line"><span class="lineno"> 2378</span>        output = np.array(data, dtype=ddtype)</div>
<div class="line"><span class="lineno"> 2379</span>        <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2380</span>            outputmask = np.array(masks, dtype=mdtype)</div>
<div class="line"><span class="lineno"> 2381</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2382</span>        <span class="comment"># Overwrite the initial dtype names if needed</span></div>
<div class="line"><span class="lineno"> 2383</span>        <span class="keywordflow">if</span> names <span class="keywordflow">and</span> dtype.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2384</span>            dtype.names = names</div>
<div class="line"><span class="lineno"> 2385</span>        <span class="comment"># Case 1. We have a structured type</span></div>
<div class="line"><span class="lineno"> 2386</span>        <span class="keywordflow">if</span> len(dtype_flat) &gt; 1:</div>
<div class="line"><span class="lineno"> 2387</span>            <span class="comment"># Nested dtype, eg [(&#39;a&#39;, int), (&#39;b&#39;, [(&#39;b0&#39;, int), (&#39;b1&#39;, &#39;f4&#39;)])]</span></div>
<div class="line"><span class="lineno"> 2388</span>            <span class="comment"># First, create the array using a flattened dtype:</span></div>
<div class="line"><span class="lineno"> 2389</span>            <span class="comment"># [(&#39;a&#39;, int), (&#39;b1&#39;, int), (&#39;b2&#39;, float)]</span></div>
<div class="line"><span class="lineno"> 2390</span>            <span class="comment"># Then, view the array using the specified dtype.</span></div>
<div class="line"><span class="lineno"> 2391</span>            <span class="keywordflow">if</span> <span class="stringliteral">&#39;O&#39;</span> <span class="keywordflow">in</span> (_.char <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> dtype_flat):</div>
<div class="line"><span class="lineno"> 2392</span>                <span class="keywordflow">if</span> has_nested_fields(dtype):</div>
<div class="line"><span class="lineno"> 2393</span>                    <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 2394</span>                        <span class="stringliteral">&quot;Nested fields involving objects are not supported...&quot;</span>)</div>
<div class="line"><span class="lineno"> 2395</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2396</span>                    output = np.array(data, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2397</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2398</span>                rows = np.array(data, dtype=[(<span class="stringliteral">&#39;&#39;</span>, _) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> dtype_flat])</div>
<div class="line"><span class="lineno"> 2399</span>                output = rows.view(dtype)</div>
<div class="line"><span class="lineno"> 2400</span>            <span class="comment"># Now, process the rowmasks the same way</span></div>
<div class="line"><span class="lineno"> 2401</span>            <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2402</span>                rowmasks = np.array(</div>
<div class="line"><span class="lineno"> 2403</span>                    masks, dtype=np.dtype([(<span class="stringliteral">&#39;&#39;</span>, bool) <span class="keywordflow">for</span> t <span class="keywordflow">in</span> dtype_flat]))</div>
<div class="line"><span class="lineno"> 2404</span>                <span class="comment"># Construct the new dtype</span></div>
<div class="line"><span class="lineno"> 2405</span>                mdtype = make_mask_descr(dtype)</div>
<div class="line"><span class="lineno"> 2406</span>                outputmask = rowmasks.view(mdtype)</div>
<div class="line"><span class="lineno"> 2407</span>        <span class="comment"># Case #2. We have a basic dtype</span></div>
<div class="line"><span class="lineno"> 2408</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2409</span>            <span class="comment"># We used some user-defined converters</span></div>
<div class="line"><span class="lineno"> 2410</span>            <span class="keywordflow">if</span> user_converters:</div>
<div class="line"><span class="lineno"> 2411</span>                ishomogeneous = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2412</span>                descr = []</div>
<div class="line"><span class="lineno"> 2413</span>                <span class="keywordflow">for</span> i, ttype <span class="keywordflow">in</span> enumerate([conv.type <span class="keywordflow">for</span> conv <span class="keywordflow">in</span> converters]):</div>
<div class="line"><span class="lineno"> 2414</span>                    <span class="comment"># Keep the dtype of the current converter</span></div>
<div class="line"><span class="lineno"> 2415</span>                    <span class="keywordflow">if</span> i <span class="keywordflow">in</span> user_converters:</div>
<div class="line"><span class="lineno"> 2416</span>                        ishomogeneous &amp;= (ttype == dtype.type)</div>
<div class="line"><span class="lineno"> 2417</span>                        <span class="keywordflow">if</span> np.issubdtype(ttype, np.character):</div>
<div class="line"><span class="lineno"> 2418</span>                            ttype = (ttype, max(len(row[i]) <span class="keywordflow">for</span> row <span class="keywordflow">in</span> data))</div>
<div class="line"><span class="lineno"> 2419</span>                        descr.append((<span class="stringliteral">&#39;&#39;</span>, ttype))</div>
<div class="line"><span class="lineno"> 2420</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2421</span>                        descr.append((<span class="stringliteral">&#39;&#39;</span>, dtype))</div>
<div class="line"><span class="lineno"> 2422</span>                <span class="comment"># So we changed the dtype ?</span></div>
<div class="line"><span class="lineno"> 2423</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> ishomogeneous:</div>
<div class="line"><span class="lineno"> 2424</span>                    <span class="comment"># We have more than one field</span></div>
<div class="line"><span class="lineno"> 2425</span>                    <span class="keywordflow">if</span> len(descr) &gt; 1:</div>
<div class="line"><span class="lineno"> 2426</span>                        dtype = np.dtype(descr)</div>
<div class="line"><span class="lineno"> 2427</span>                    <span class="comment"># We have only one field: drop the name if not needed.</span></div>
<div class="line"><span class="lineno"> 2428</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2429</span>                        dtype = np.dtype(ttype)</div>
<div class="line"><span class="lineno"> 2430</span>            <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 2431</span>            output = np.array(data, dtype)</div>
<div class="line"><span class="lineno"> 2432</span>            <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2433</span>                <span class="keywordflow">if</span> dtype.names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2434</span>                    mdtype = [(_, bool) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> dtype.names]</div>
<div class="line"><span class="lineno"> 2435</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2436</span>                    mdtype = bool</div>
<div class="line"><span class="lineno"> 2437</span>                outputmask = np.array(masks, dtype=mdtype)</div>
<div class="line"><span class="lineno"> 2438</span>    <span class="comment"># Try to take care of the missing data we missed</span></div>
<div class="line"><span class="lineno"> 2439</span>    names = output.dtype.names</div>
<div class="line"><span class="lineno"> 2440</span>    <span class="keywordflow">if</span> usemask <span class="keywordflow">and</span> names:</div>
<div class="line"><span class="lineno"> 2441</span>        <span class="keywordflow">for</span> (name, conv) <span class="keywordflow">in</span> zip(names, converters):</div>
<div class="line"><span class="lineno"> 2442</span>            missing_values = [conv(_) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> conv.missing_values</div>
<div class="line"><span class="lineno"> 2443</span>                              <span class="keywordflow">if</span> _ != <span class="stringliteral">&#39;&#39;</span>]</div>
<div class="line"><span class="lineno"> 2444</span>            <span class="keywordflow">for</span> mval <span class="keywordflow">in</span> missing_values:</div>
<div class="line"><span class="lineno"> 2445</span>                outputmask[name] |= (output[name] == mval)</div>
<div class="line"><span class="lineno"> 2446</span>    <span class="comment"># Construct the final array</span></div>
<div class="line"><span class="lineno"> 2447</span>    <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2448</span>        output = output.view(MaskedArray)</div>
<div class="line"><span class="lineno"> 2449</span>        output._mask = outputmask</div>
<div class="line"><span class="lineno"> 2450</span> </div>
<div class="line"><span class="lineno"> 2451</span>    output = _ensure_ndmin_ndarray(output, ndmin=ndmin)</div>
<div class="line"><span class="lineno"> 2452</span> </div>
<div class="line"><span class="lineno"> 2453</span>    <span class="keywordflow">if</span> unpack:</div>
<div class="line"><span class="lineno"> 2454</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2455</span>            <span class="keywordflow">return</span> output.T</div>
<div class="line"><span class="lineno"> 2456</span>        <span class="keywordflow">elif</span> len(names) == 1:</div>
<div class="line"><span class="lineno"> 2457</span>            <span class="comment"># squeeze single-name dtypes too</span></div>
<div class="line"><span class="lineno"> 2458</span>            <span class="keywordflow">return</span> output[names[0]]</div>
<div class="line"><span class="lineno"> 2459</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2460</span>            <span class="comment"># For structured arrays with multiple fields,</span></div>
<div class="line"><span class="lineno"> 2461</span>            <span class="comment"># return an array for each field.</span></div>
<div class="line"><span class="lineno"> 2462</span>            <span class="keywordflow">return</span> [output[field] <span class="keywordflow">for</span> field <span class="keywordflow">in</span> names]</div>
<div class="line"><span class="lineno"> 2463</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 2464</span> </div>
<div class="line"><span class="lineno"> 2465</span> </div>
<div class="ttc" id="anamespacenumpy_1_1ma_html"><div class="ttname"><a href="namespacenumpy_1_1ma.html">numpy.ma</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa81b918dfbdf50ada7534496b983f6c2" name="aa81b918dfbdf50ada7534496b983f6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81b918dfbdf50ada7534496b983f6c2">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.load </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mmap_mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_pickle</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fix_imports</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>'ASCII'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>max_header_size</em> = <code><a class="el" href="namespacenumpy_1_1lib_1_1format.html#ab2f49de29655c78cd4a4126b2090f22b">format._MAX_HEADER_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.

.. warning:: Loading files that contain object arrays uses the ``pickle``
             module, which is not secure against erroneous or maliciously
             constructed data. Consider passing ``allow_pickle=False`` to
             load data that is known not to contain object arrays for the
             safer handling of untrusted sources.

Parameters
----------
file : file-like object, string, or pathlib.Path
    The file to read. File-like objects must support the
    ``seek()`` and ``read()`` methods and must always
    be opened in binary mode.  Pickled files require that the
    file-like object support the ``readline()`` method as well.
mmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional
    If not None, then memory-map the file, using the given mode (see
    `numpy.memmap` for a detailed description of the modes).  A
    memory-mapped array is kept on disk. However, it can be accessed
    and sliced like any ndarray.  Memory mapping is especially useful
    for accessing small fragments of large files without reading the
    entire file into memory.
allow_pickle : bool, optional
    Allow loading pickled object arrays stored in npy files. Reasons for
    disallowing pickles include security, as loading pickled data can
    execute arbitrary code. If pickles are disallowed, loading object
    arrays will fail. Default: False

    .. versionchanged:: 1.16.3
        Made default False in response to CVE-2019-6446.

fix_imports : bool, optional
    Only useful when loading Python 2 generated pickled files on Python 3,
    which includes npy/npz files containing object arrays. If `fix_imports`
    is True, pickle will try to map the old Python 2 names to the new names
    used in Python 3.
encoding : str, optional
    What encoding to use when reading Python 2 strings. Only useful when
    loading Python 2 generated pickled files in Python 3, which includes
    npy/npz files containing object arrays. Values other than 'latin1',
    'ASCII', and 'bytes' are not allowed, as they can corrupt numerical
    data. Default: 'ASCII'
max_header_size : int, optional
    Maximum allowed size of the header.  Large headers may not be safe
    to load securely and thus require explicitly passing a larger value.
    See :py:meth:`ast.literal_eval()` for details.
    This option is ignored when `allow_pickle` is passed.  In that case
    the file is by definition trusted and the limit is unnecessary.

Returns
-------
result : array, tuple, dict, etc.
    Data stored in the file. For ``.npz`` files, the returned instance
    of NpzFile class must be closed to avoid leaking file descriptors.

Raises
------
OSError
    If the input file does not exist or cannot be read.
UnpicklingError
    If ``allow_pickle=True``, but the file cannot be loaded as a pickle.
ValueError
    The file contains an object array, but ``allow_pickle=False`` given.

See Also
--------
save, savez, savez_compressed, loadtxt
memmap : Create a memory-map to an array stored in a file on disk.
lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.

Notes
-----
- If the file contains pickle data, then whatever object is stored
  in the pickle is returned.
- If the file is a ``.npy`` file, then a single array is returned.
- If the file is a ``.npz`` file, then a dictionary-like object is
  returned, containing ``{filename: array}`` key-value pairs, one for
  each file in the archive.
- If the file is a ``.npz`` file, the returned value supports the
  context manager protocol in a similar fashion to the open function::

    with load('foo.npz') as data:
        a = data['a']

  The underlying file descriptor is closed when exiting the 'with'
  block.

Examples
--------
Store data to disk, and load it again:

&gt;&gt;&gt; np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))
&gt;&gt;&gt; np.load('/tmp/123.npy')
array([[1, 2, 3],
       [4, 5, 6]])

Store compressed data to disk, and load it again:

&gt;&gt;&gt; a=np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; b=np.array([1, 2])
&gt;&gt;&gt; np.savez('/tmp/123.npz', a=a, b=b)
&gt;&gt;&gt; data = np.load('/tmp/123.npz')
&gt;&gt;&gt; data['a']
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; data['b']
array([1, 2])
&gt;&gt;&gt; data.close()

Mem-map the stored array, and then access the second row
directly from disk:

&gt;&gt;&gt; X = np.load('/tmp/123.npy', mmap_mode='r')
&gt;&gt;&gt; X[1, :]
memmap([4, 5, 6])</pre> <div class="fragment"><div class="line"><span class="lineno">  265</span>         encoding=<span class="stringliteral">&#39;ASCII&#39;</span>, *, max_header_size=format._MAX_HEADER_SIZE):</div>
<div class="line"><span class="lineno">  266</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    .. warning:: Loading files that contain object arrays uses the ``pickle``</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">                 module, which is not secure against erroneous or maliciously</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">                 constructed data. Consider passing ``allow_pickle=False`` to</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">                 load data that is known not to contain object arrays for the</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">                 safer handling of untrusted sources.</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    file : file-like object, string, or pathlib.Path</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        The file to read. File-like objects must support the</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        ``seek()`` and ``read()`` methods and must always</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        be opened in binary mode.  Pickled files require that the</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        file-like object support the ``readline()`` method as well.</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    mmap_mode : {None, &#39;r+&#39;, &#39;r&#39;, &#39;w+&#39;, &#39;c&#39;}, optional</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        If not None, then memory-map the file, using the given mode (see</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        `numpy.memmap` for a detailed description of the modes).  A</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        memory-mapped array is kept on disk. However, it can be accessed</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        and sliced like any ndarray.  Memory mapping is especially useful</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">        for accessing small fragments of large files without reading the</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        entire file into memory.</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    allow_pickle : bool, optional</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">        Allow loading pickled object arrays stored in npy files. Reasons for</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        disallowing pickles include security, as loading pickled data can</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        execute arbitrary code. If pickles are disallowed, loading object</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        arrays will fail. Default: False</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        .. versionchanged:: 1.16.3</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">            Made default False in response to CVE-2019-6446.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    fix_imports : bool, optional</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        Only useful when loading Python 2 generated pickled files on Python 3,</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        which includes npy/npz files containing object arrays. If `fix_imports`</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        is True, pickle will try to map the old Python 2 names to the new names</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">        used in Python 3.</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    encoding : str, optional</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        What encoding to use when reading Python 2 strings. Only useful when</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        loading Python 2 generated pickled files in Python 3, which includes</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">        npy/npz files containing object arrays. Values other than &#39;latin1&#39;,</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        &#39;ASCII&#39;, and &#39;bytes&#39; are not allowed, as they can corrupt numerical</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">        data. Default: &#39;ASCII&#39;</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    max_header_size : int, optional</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        Maximum allowed size of the header.  Large headers may not be safe</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        to load securely and thus require explicitly passing a larger value.</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        See :py:meth:`ast.literal_eval()` for details.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        This option is ignored when `allow_pickle` is passed.  In that case</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">        the file is by definition trusted and the limit is unnecessary.</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    result : array, tuple, dict, etc.</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        Data stored in the file. For ``.npz`` files, the returned instance</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">        of NpzFile class must be closed to avoid leaking file descriptors.</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    OSError</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        If the input file does not exist or cannot be read.</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    UnpicklingError</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        If ``allow_pickle=True``, but the file cannot be loaded as a pickle.</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        The file contains an object array, but ``allow_pickle=False`` given.</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    save, savez, savez_compressed, loadtxt</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    memmap : Create a memory-map to an array stored in a file on disk.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    - If the file contains pickle data, then whatever object is stored</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">      in the pickle is returned.</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    - If the file is a ``.npy`` file, then a single array is returned.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    - If the file is a ``.npz`` file, then a dictionary-like object is</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">      returned, containing ``{filename: array}`` key-value pairs, one for</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">      each file in the archive.</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    - If the file is a ``.npz`` file, the returned value supports the</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">      context manager protocol in a similar fashion to the open function::</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        with load(&#39;foo.npz&#39;) as data:</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">            a = data[&#39;a&#39;]</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">      The underlying file descriptor is closed when exiting the &#39;with&#39;</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">      block.</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    Store data to disk, and load it again:</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    &gt;&gt;&gt; np.save(&#39;/tmp/123&#39;, np.array([[1, 2, 3], [4, 5, 6]]))</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    &gt;&gt;&gt; np.load(&#39;/tmp/123.npy&#39;)</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">           [4, 5, 6]])</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    Store compressed data to disk, and load it again:</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    &gt;&gt;&gt; a=np.array([[1, 2, 3], [4, 5, 6]])</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    &gt;&gt;&gt; b=np.array([1, 2])</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    &gt;&gt;&gt; np.savez(&#39;/tmp/123.npz&#39;, a=a, b=b)</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    &gt;&gt;&gt; data = np.load(&#39;/tmp/123.npz&#39;)</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    &gt;&gt;&gt; data[&#39;a&#39;]</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">           [4, 5, 6]])</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    &gt;&gt;&gt; data[&#39;b&#39;]</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    array([1, 2])</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    &gt;&gt;&gt; data.close()</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    Mem-map the stored array, and then access the second row</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    directly from disk:</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    &gt;&gt;&gt; X = np.load(&#39;/tmp/123.npy&#39;, mmap_mode=&#39;r&#39;)</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    &gt;&gt;&gt; X[1, :]</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    memmap([4, 5, 6])</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  384</span>    <span class="keywordflow">if</span> encoding <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;ASCII&#39;</span>, <span class="stringliteral">&#39;latin1&#39;</span>, <span class="stringliteral">&#39;bytes&#39;</span>):</div>
<div class="line"><span class="lineno">  385</span>        <span class="comment"># The &#39;encoding&#39; value for pickle also affects what encoding</span></div>
<div class="line"><span class="lineno">  386</span>        <span class="comment"># the serialized binary data of NumPy arrays is loaded</span></div>
<div class="line"><span class="lineno">  387</span>        <span class="comment"># in. Pickle does not pass on the encoding information to</span></div>
<div class="line"><span class="lineno">  388</span>        <span class="comment"># NumPy. The unpickling code in numpy.core.multiarray is</span></div>
<div class="line"><span class="lineno">  389</span>        <span class="comment"># written to assume that unicode data appearing where binary</span></div>
<div class="line"><span class="lineno">  390</span>        <span class="comment"># should be is in &#39;latin1&#39;. &#39;bytes&#39; is also safe, as is &#39;ASCII&#39;.</span></div>
<div class="line"><span class="lineno">  391</span>        <span class="comment">#</span></div>
<div class="line"><span class="lineno">  392</span>        <span class="comment"># Other encoding values can corrupt binary data, and we</span></div>
<div class="line"><span class="lineno">  393</span>        <span class="comment"># purposefully disallow them. For the same reason, the errors=</span></div>
<div class="line"><span class="lineno">  394</span>        <span class="comment"># argument is not exposed, as values other than &#39;strict&#39;</span></div>
<div class="line"><span class="lineno">  395</span>        <span class="comment"># result can similarly silently corrupt numerical data.</span></div>
<div class="line"><span class="lineno">  396</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;encoding must be &#39;ASCII&#39;, &#39;latin1&#39;, or &#39;bytes&#39;&quot;</span>)</div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span>    pickle_kwargs = dict(encoding=encoding, fix_imports=fix_imports)</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>    <span class="keyword">with</span> contextlib.ExitStack() <span class="keyword">as</span> stack:</div>
<div class="line"><span class="lineno">  401</span>        <span class="keywordflow">if</span> hasattr(file, <span class="stringliteral">&#39;read&#39;</span>):</div>
<div class="line"><span class="lineno">  402</span>            fid = file</div>
<div class="line"><span class="lineno">  403</span>            own_fid = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  404</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  405</span>            fid = stack.enter_context(open(os_fspath(file), <span class="stringliteral">&quot;rb&quot;</span>))</div>
<div class="line"><span class="lineno">  406</span>            own_fid = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span>        <span class="comment"># Code to distinguish from NumPy binary files and pickles.</span></div>
<div class="line"><span class="lineno">  409</span>        _ZIP_PREFIX = b<span class="stringliteral">&#39;PK\x03\x04&#39;</span></div>
<div class="line"><span class="lineno">  410</span>        _ZIP_SUFFIX = b<span class="stringliteral">&#39;PK\x05\x06&#39;</span> <span class="comment"># empty zip files start with this</span></div>
<div class="line"><span class="lineno">  411</span>        N = len(format.MAGIC_PREFIX)</div>
<div class="line"><span class="lineno">  412</span>        magic = fid.read(N)</div>
<div class="line"><span class="lineno">  413</span>        <span class="comment"># If the file size is less than N, we need to make sure not</span></div>
<div class="line"><span class="lineno">  414</span>        <span class="comment"># to seek past the beginning of the file</span></div>
<div class="line"><span class="lineno">  415</span>        fid.seek(-min(N, len(magic)), 1)  <span class="comment"># back-up</span></div>
<div class="line"><span class="lineno">  416</span>        <span class="keywordflow">if</span> magic.startswith(_ZIP_PREFIX) <span class="keywordflow">or</span> magic.startswith(_ZIP_SUFFIX):</div>
<div class="line"><span class="lineno">  417</span>            <span class="comment"># zip-file (assume .npz)</span></div>
<div class="line"><span class="lineno">  418</span>            <span class="comment"># Potentially transfer file ownership to NpzFile</span></div>
<div class="line"><span class="lineno">  419</span>            stack.pop_all()</div>
<div class="line"><span class="lineno">  420</span>            ret = NpzFile(fid, own_fid=own_fid, allow_pickle=allow_pickle,</div>
<div class="line"><span class="lineno">  421</span>                          pickle_kwargs=pickle_kwargs,</div>
<div class="line"><span class="lineno">  422</span>                          max_header_size=max_header_size)</div>
<div class="line"><span class="lineno">  423</span>            <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  424</span>        <span class="keywordflow">elif</span> magic == format.MAGIC_PREFIX:</div>
<div class="line"><span class="lineno">  425</span>            <span class="comment"># .npy file</span></div>
<div class="line"><span class="lineno">  426</span>            <span class="keywordflow">if</span> mmap_mode:</div>
<div class="line"><span class="lineno">  427</span>                <span class="keywordflow">if</span> allow_pickle:</div>
<div class="line"><span class="lineno">  428</span>                    max_header_size = 2**64</div>
<div class="line"><span class="lineno">  429</span>                <span class="keywordflow">return</span> format.open_memmap(file, mode=mmap_mode,</div>
<div class="line"><span class="lineno">  430</span>                                          max_header_size=max_header_size)</div>
<div class="line"><span class="lineno">  431</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  432</span>                <span class="keywordflow">return</span> format.read_array(fid, allow_pickle=allow_pickle,</div>
<div class="line"><span class="lineno">  433</span>                                         pickle_kwargs=pickle_kwargs,</div>
<div class="line"><span class="lineno">  434</span>                                         max_header_size=max_header_size)</div>
<div class="line"><span class="lineno">  435</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  436</span>            <span class="comment"># Try a pickle</span></div>
<div class="line"><span class="lineno">  437</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> allow_pickle:</div>
<div class="line"><span class="lineno">  438</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Cannot load file containing pickled data &quot;</span></div>
<div class="line"><span class="lineno">  439</span>                                 <span class="stringliteral">&quot;when allow_pickle=False&quot;</span>)</div>
<div class="line"><span class="lineno">  440</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  441</span>                <span class="keywordflow">return</span> pickle.load(fid, **pickle_kwargs)</div>
<div class="line"><span class="lineno">  442</span>            <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  443</span>                <span class="keywordflow">raise</span> pickle.UnpicklingError(</div>
<div class="line"><span class="lineno">  444</span>                    f<span class="stringliteral">&quot;Failed to interpret file {file!r} as a pickle&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  445</span> </div>
<div class="line"><span class="lineno">  446</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abd1e1456f92798a1f66ace63eb6d15fe" name="abd1e1456f92798a1f66ace63eb6d15fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1e1456f92798a1f66ace63eb6d15fe">&#9670;&#160;</a></span>loadtxt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.loadtxt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comments</em> = <code>'#'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>converters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skiprows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usecols</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unpack</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndmin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>'bytes'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_rows</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>quotechar</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load data from a text file.

Parameters
----------
fname : file, str, pathlib.Path, list of str, generator
File, filename, list, or generator to read.  If the filename
extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note
that generators must return bytes or strings. The strings
in a list or produced by a generator are treated as lines.
dtype : data-type, optional
Data-type of the resulting array; default: float.  If this is a
structured data-type, the resulting array will be 1-dimensional, and
each row will be interpreted as an element of the array.  In this
case, the number of columns used must match the number of fields in
the data-type.
comments : str or sequence of str or None, optional
The characters or list of characters used to indicate the start of a
comment. None implies no comments. For backwards compatibility, byte
strings will be decoded as 'latin1'. The default is '#'.
delimiter : str, optional
The character used to separate the values. For backwards compatibility,
byte strings will be decoded as 'latin1'. The default is whitespace.

.. versionchanged:: 1.23.0
Only single character delimiters are supported. Newline characters
cannot be used as the delimiter.

converters : dict or callable, optional
Converter functions to customize value parsing. If `converters` is
callable, the function is applied to all columns, else it must be a
dict that maps column number to a parser function.
See examples for further details.
Default: None.

.. versionchanged:: 1.23.0
The ability to pass a single callable to be applied to all columns
was added.

skiprows : int, optional
Skip the first `skiprows` lines, including comments; default: 0.
usecols : int or sequence, optional
Which columns to read, with 0 being the first. For example,
``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.
The default, None, results in all columns being read.

.. versionchanged:: 1.11.0
When a single column has to be read it is possible to use
an integer instead of a tuple. E.g ``usecols = 3`` reads the
fourth column the same way as ``usecols = (3,)`` would.
unpack : bool, optional
If True, the returned array is transposed, so that arguments may be
unpacked using ``x, y, z = loadtxt(...)``.  When used with a
structured data-type, arrays are returned for each field.
Default is False.
ndmin : int, optional
The returned array will have at least `ndmin` dimensions.
Otherwise mono-dimensional axes will be squeezed.
Legal values: 0 (default), 1 or 2.

.. versionadded:: 1.6.0
encoding : str, optional
Encoding used to decode the inputfile. Does not apply to input streams.
The special value 'bytes' enables backward compatibility workarounds
that ensures you receive byte arrays as results if possible and passes
'latin1' encoded strings to converters. Override this value to receive
unicode arrays and pass strings as input to converters.  If set to None
the system default is used. The default value is 'bytes'.

.. versionadded:: 1.14.0
max_rows : int, optional
Read `max_rows` rows of content after `skiprows` lines. The default is
to read all the rows. Note that empty rows containing no data such as
empty lines and comment lines are not counted towards `max_rows`,
while such lines are counted in `skiprows`.

.. versionadded:: 1.16.0

.. versionchanged:: 1.23.0
Lines containing no data, including comment lines (e.g., lines 
starting with '#' or as specified via `comments`) are not counted 
towards `max_rows`.
quotechar : unicode character or None, optional
The character used to denote the start and end of a quoted item.
Occurrences of the delimiter or comment characters are ignored within
a quoted item. The default value is ``quotechar=None``, which means
quoting support is disabled.

If two consecutive instances of `quotechar` are found within a quoted
field, the first is treated as an escape character. See examples.

.. versionadded:: 1.23.0
${ARRAY_FUNCTION_LIKE}

.. versionadded:: 1.20.0

Returns
-------
out : ndarray
Data read from the text file.

See Also
--------
load, fromstring, fromregex
genfromtxt : Load data with missing values handled as specified.
scipy.io.loadmat : reads MATLAB data files

Notes
-----
This function aims to be a fast reader for simply formatted files.  The
`genfromtxt` function provides more sophisticated handling of, e.g.,
lines with missing values.

Each row in the input text file must have the same number of values to be
able to read all values. If all rows do not have same number of values, a
subset of up to n columns (where n is the least number of values present
in all rows) can be read by specifying the columns via `usecols`.

.. versionadded:: 1.10.0

The strings produced by the Python float.hex method can be used as
input for floats.

Examples
--------
&gt;&gt;&gt; from io import StringIO   # StringIO behaves like a file object
&gt;&gt;&gt; c = StringIO("0 1\n2 3")
&gt;&gt;&gt; np.loadtxt(c)
array([[0., 1.],
[2., 3.]])

&gt;&gt;&gt; d = StringIO("M 21 72\nF 35 58")
&gt;&gt;&gt; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
...                      'formats': ('S1', 'i4', 'f4')})
array([(b'M', 21, 72.), (b'F', 35, 58.)],
dtype=[('gender', 'S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])

&gt;&gt;&gt; c = StringIO("1,0,2\n3,0,4")
&gt;&gt;&gt; x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)
&gt;&gt;&gt; x
array([1., 3.])
&gt;&gt;&gt; y
array([2., 4.])

The `converters` argument is used to specify functions to preprocess the
text prior to parsing. `converters` can be a dictionary that maps
preprocessing functions to each column:

&gt;&gt;&gt; s = StringIO("1.618, 2.296\n3.141, 4.669\n")
&gt;&gt;&gt; conv = {
...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0
...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1
... }
&gt;&gt;&gt; np.loadtxt(s, delimiter=",", converters=conv)
array([[1., 3.],
[3., 5.]])

`converters` can be a callable instead of a dictionary, in which case it
is applied to all columns:

&gt;&gt;&gt; s = StringIO("0xDE 0xAD\n0xC0 0xDE")
&gt;&gt;&gt; import functools
&gt;&gt;&gt; conv = functools.partial(int, base=16)
&gt;&gt;&gt; np.loadtxt(s, converters=conv)
array([[222., 173.],
[192., 222.]])

This example shows how `converters` can be used to convert a field
with a trailing minus sign into a negative number.

&gt;&gt;&gt; s = StringIO('10.01 31.25-\n19.22 64.31\n17.57- 63.94')
&gt;&gt;&gt; def conv(fld):
...     return -float(fld[:-1]) if fld.endswith(b'-') else float(fld)
...
&gt;&gt;&gt; np.loadtxt(s, converters=conv)
array([[ 10.01, -31.25],
[ 19.22,  64.31],
[-17.57,  63.94]])

Using a callable as the converter can be particularly useful for handling
values with different formatting, e.g. floats with underscores:

&gt;&gt;&gt; s = StringIO("1 2.7 100_000")
&gt;&gt;&gt; np.loadtxt(s, converters=float)
array([1.e+00, 2.7e+00, 1.e+05])

This idea can be extended to automatically handle values specified in
many different formats:

&gt;&gt;&gt; def conv(val):
...     try:
...         return float(val)
...     except ValueError:
...         return float.fromhex(val)
&gt;&gt;&gt; s = StringIO("1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2")
&gt;&gt;&gt; np.loadtxt(s, delimiter=",", converters=conv, encoding=None)
array([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])

Note that with the default ``encoding="bytes"``, the inputs to the
converter function are latin-1 encoded byte strings. To deactivate the
implicit encoding prior to conversion, use ``encoding=None``

&gt;&gt;&gt; s = StringIO('10.01 31.25-\n19.22 64.31\n17.57- 63.94')
&gt;&gt;&gt; conv = lambda x: -float(x[:-1]) if x.endswith('-') else float(x)
&gt;&gt;&gt; np.loadtxt(s, converters=conv, encoding=None)
array([[ 10.01, -31.25],
[ 19.22,  64.31],
[-17.57,  63.94]])

Support for quoted fields is enabled with the `quotechar` parameter.
Comment and delimiter characters are ignored when they appear within a
quoted item delineated by `quotechar`:

&gt;&gt;&gt; s = StringIO('"alpha, #42", 10.0\n"beta, #64", 2.0\n')
&gt;&gt;&gt; dtype = np.dtype([("label", "U12"), ("value", float)])
&gt;&gt;&gt; np.loadtxt(s, dtype=dtype, delimiter=",", quotechar='"')
array([('alpha, #42', 10.), ('beta, #64',  2.)],
dtype=[('label', '&lt;U12'), ('value', '&lt;f8')])

Two consecutive quote characters within a quoted field are treated as a
single escaped character:

&gt;&gt;&gt; s = StringIO('"Hello, my name is ""Monty""!"')
&gt;&gt;&gt; np.loadtxt(s, dtype="U", delimiter=",", quotechar='"')
array('Hello, my name is "Monty"!', dtype='&lt;U26')

Read subset of columns when all rows do not contain equal number of values:

&gt;&gt;&gt; d = StringIO("1 2\n2 4\n3 9 12\n4 16 20")
&gt;&gt;&gt; np.loadtxt(d, usecols=(0, 1))
array([[ 1.,  2.],
[ 2.,  4.],
[ 3.,  9.],
[ 4., 16.]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1086</span>            like=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1087</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">    Load data from a text file.</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    fname : file, str, pathlib.Path, list of str, generator</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">        File, filename, list, or generator to read.  If the filename</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">        that generators must return bytes or strings. The strings</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">        in a list or produced by a generator are treated as lines.</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">        Data-type of the resulting array; default: float.  If this is a</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">        structured data-type, the resulting array will be 1-dimensional, and</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">        each row will be interpreted as an element of the array.  In this</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">        case, the number of columns used must match the number of fields in</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">        the data-type.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    comments : str or sequence of str or None, optional</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">        The characters or list of characters used to indicate the start of a</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">        comment. None implies no comments. For backwards compatibility, byte</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">        strings will be decoded as &#39;latin1&#39;. The default is &#39;#&#39;.</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">    delimiter : str, optional</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">        The character used to separate the values. For backwards compatibility,</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">        byte strings will be decoded as &#39;latin1&#39;. The default is whitespace.</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">        .. versionchanged:: 1.23.0</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">           Only single character delimiters are supported. Newline characters</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">           cannot be used as the delimiter.</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    converters : dict or callable, optional</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">        Converter functions to customize value parsing. If `converters` is</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">        callable, the function is applied to all columns, else it must be a</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">        dict that maps column number to a parser function.</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">        See examples for further details.</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">        Default: None.</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">        .. versionchanged:: 1.23.0</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">           The ability to pass a single callable to be applied to all columns</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">           was added.</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    skiprows : int, optional</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">        Skip the first `skiprows` lines, including comments; default: 0.</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    usecols : int or sequence, optional</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">        Which columns to read, with 0 being the first. For example,</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">        The default, None, results in all columns being read.</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">        .. versionchanged:: 1.11.0</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">            When a single column has to be read it is possible to use</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">            an integer instead of a tuple. E.g ``usecols = 3`` reads the</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">            fourth column the same way as ``usecols = (3,)`` would.</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">    unpack : bool, optional</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">        If True, the returned array is transposed, so that arguments may be</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">        unpacked using ``x, y, z = loadtxt(...)``.  When used with a</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">        structured data-type, arrays are returned for each field.</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">        Default is False.</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    ndmin : int, optional</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">        The returned array will have at least `ndmin` dimensions.</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">        Otherwise mono-dimensional axes will be squeezed.</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">        Legal values: 0 (default), 1 or 2.</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    encoding : str, optional</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">        Encoding used to decode the inputfile. Does not apply to input streams.</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">        The special value &#39;bytes&#39; enables backward compatibility workarounds</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">        that ensures you receive byte arrays as results if possible and passes</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">        &#39;latin1&#39; encoded strings to converters. Override this value to receive</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">        unicode arrays and pass strings as input to converters.  If set to None</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">        the system default is used. The default value is &#39;bytes&#39;.</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">        .. versionadded:: 1.14.0</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    max_rows : int, optional</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">        Read `max_rows` rows of content after `skiprows` lines. The default is</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">        to read all the rows. Note that empty rows containing no data such as</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">        empty lines and comment lines are not counted towards `max_rows`,</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">        while such lines are counted in `skiprows`.</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">        .. versionadded:: 1.16.0</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">        </span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">        .. versionchanged:: 1.23.0</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">            Lines containing no data, including comment lines (e.g., lines </span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">            starting with &#39;#&#39; or as specified via `comments`) are not counted </span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">            towards `max_rows`.</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    quotechar : unicode character or None, optional</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">        The character used to denote the start and end of a quoted item.</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">        Occurrences of the delimiter or comment characters are ignored within</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">        a quoted item. The default value is ``quotechar=None``, which means</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">        quoting support is disabled.</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">        If two consecutive instances of `quotechar` are found within a quoted</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">        field, the first is treated as an escape character. See examples.</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">        .. versionadded:: 1.23.0</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    ${ARRAY_FUNCTION_LIKE}</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">        .. versionadded:: 1.20.0</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">        Data read from the text file.</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    load, fromstring, fromregex</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    genfromtxt : Load data with missing values handled as specified.</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    scipy.io.loadmat : reads MATLAB data files</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    This function aims to be a fast reader for simply formatted files.  The</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    `genfromtxt` function provides more sophisticated handling of, e.g.,</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    lines with missing values.</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    Each row in the input text file must have the same number of values to be</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    able to read all values. If all rows do not have same number of values, a</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    subset of up to n columns (where n is the least number of values present</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    in all rows) can be read by specifying the columns via `usecols`.</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">    The strings produced by the Python float.hex method can be used as</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    input for floats.</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    &gt;&gt;&gt; from io import StringIO   # StringIO behaves like a file object</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    &gt;&gt;&gt; c = StringIO(&quot;0 1\n2 3&quot;)</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(c)</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    array([[0., 1.],</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">           [2., 3.]])</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    &gt;&gt;&gt; d = StringIO(&quot;M 21 72\nF 35 58&quot;)</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(d, dtype={&#39;names&#39;: (&#39;gender&#39;, &#39;age&#39;, &#39;weight&#39;),</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    ...                      &#39;formats&#39;: (&#39;S1&#39;, &#39;i4&#39;, &#39;f4&#39;)})</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">    array([(b&#39;M&#39;, 21, 72.), (b&#39;F&#39;, 35, 58.)],</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">          dtype=[(&#39;gender&#39;, &#39;S1&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f4&#39;)])</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">    &gt;&gt;&gt; c = StringIO(&quot;1,0,2\n3,0,4&quot;)</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">    &gt;&gt;&gt; x, y = np.loadtxt(c, delimiter=&#39;,&#39;, usecols=(0, 2), unpack=True)</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    array([1., 3.])</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">    &gt;&gt;&gt; y</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    array([2., 4.])</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">    The `converters` argument is used to specify functions to preprocess the</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    text prior to parsing. `converters` can be a dictionary that maps</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">    preprocessing functions to each column:</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&quot;1.618, 2.296\n3.141, 4.669\n&quot;)</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    &gt;&gt;&gt; conv = {</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">    ...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    ...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">    ... }</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, delimiter=&quot;,&quot;, converters=conv)</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    array([[1., 3.],</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">           [3., 5.]])</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    `converters` can be a callable instead of a dictionary, in which case it</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    is applied to all columns:</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&quot;0xDE 0xAD\n0xC0 0xDE&quot;)</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">    &gt;&gt;&gt; import functools</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    &gt;&gt;&gt; conv = functools.partial(int, base=16)</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, converters=conv)</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">    array([[222., 173.],</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">           [192., 222.]])</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    This example shows how `converters` can be used to convert a field</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    with a trailing minus sign into a negative number.</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&#39;10.01 31.25-\n19.22 64.31\n17.57- 63.94&#39;)</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    &gt;&gt;&gt; def conv(fld):</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    ...     return -float(fld[:-1]) if fld.endswith(b&#39;-&#39;) else float(fld)</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, converters=conv)</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">    array([[ 10.01, -31.25],</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">           [ 19.22,  64.31],</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">           [-17.57,  63.94]])</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">    Using a callable as the converter can be particularly useful for handling</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">    values with different formatting, e.g. floats with underscores:</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&quot;1 2.7 100_000&quot;)</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, converters=float)</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    array([1.e+00, 2.7e+00, 1.e+05])</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    This idea can be extended to automatically handle values specified in</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    many different formats:</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">    &gt;&gt;&gt; def conv(val):</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">    ...     try:</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    ...         return float(val)</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    ...     except ValueError:</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    ...         return float.fromhex(val)</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&quot;1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2&quot;)</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, delimiter=&quot;,&quot;, converters=conv, encoding=None)</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">    array([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">    Note that with the default ``encoding=&quot;bytes&quot;``, the inputs to the</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">    converter function are latin-1 encoded byte strings. To deactivate the</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    implicit encoding prior to conversion, use ``encoding=None``</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&#39;10.01 31.25-\n19.22 64.31\n17.57- 63.94&#39;)</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    &gt;&gt;&gt; conv = lambda x: -float(x[:-1]) if x.endswith(&#39;-&#39;) else float(x)</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, converters=conv, encoding=None)</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    array([[ 10.01, -31.25],</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">           [ 19.22,  64.31],</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">           [-17.57,  63.94]])</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    Support for quoted fields is enabled with the `quotechar` parameter.</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    Comment and delimiter characters are ignored when they appear within a</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    quoted item delineated by `quotechar`:</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&#39;&quot;alpha, #42&quot;, 10.0\n&quot;beta, #64&quot;, 2.0\n&#39;)</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    &gt;&gt;&gt; dtype = np.dtype([(&quot;label&quot;, &quot;U12&quot;), (&quot;value&quot;, float)])</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, dtype=dtype, delimiter=&quot;,&quot;, quotechar=&#39;&quot;&#39;)</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    array([(&#39;alpha, #42&#39;, 10.), (&#39;beta, #64&#39;,  2.)],</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">          dtype=[(&#39;label&#39;, &#39;&lt;U12&#39;), (&#39;value&#39;, &#39;&lt;f8&#39;)])</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">    Two consecutive quote characters within a quoted field are treated as a</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    single escaped character:</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">    &gt;&gt;&gt; s = StringIO(&#39;&quot;Hello, my name is &quot;&quot;Monty&quot;&quot;!&quot;&#39;)</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(s, dtype=&quot;U&quot;, delimiter=&quot;,&quot;, quotechar=&#39;&quot;&#39;)</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    array(&#39;Hello, my name is &quot;Monty&quot;!&#39;, dtype=&#39;&lt;U26&#39;)</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    Read subset of columns when all rows do not contain equal number of values:</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    &gt;&gt;&gt; d = StringIO(&quot;1 2\n2 4\n3 9 12\n4 16 20&quot;)</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    &gt;&gt;&gt; np.loadtxt(d, usecols=(0, 1))</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    array([[ 1.,  2.],</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">           [ 2.,  4.],</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">           [ 3.,  9.],</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">           [ 4., 16.]])</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1323</span> </div>
<div class="line"><span class="lineno"> 1324</span>    <span class="keywordflow">if</span> like <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1325</span>        <span class="keywordflow">return</span> _loadtxt_with_like(</div>
<div class="line"><span class="lineno"> 1326</span>            fname, dtype=dtype, comments=comments, delimiter=delimiter,</div>
<div class="line"><span class="lineno"> 1327</span>            converters=converters, skiprows=skiprows, usecols=usecols,</div>
<div class="line"><span class="lineno"> 1328</span>            unpack=unpack, ndmin=ndmin, encoding=encoding,</div>
<div class="line"><span class="lineno"> 1329</span>            max_rows=max_rows, like=like</div>
<div class="line"><span class="lineno"> 1330</span>        )</div>
<div class="line"><span class="lineno"> 1331</span> </div>
<div class="line"><span class="lineno"> 1332</span>    <span class="keywordflow">if</span> isinstance(delimiter, bytes):</div>
<div class="line"><span class="lineno"> 1333</span>        delimiter.decode(<span class="stringliteral">&quot;latin1&quot;</span>)</div>
<div class="line"><span class="lineno"> 1334</span> </div>
<div class="line"><span class="lineno"> 1335</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1336</span>        dtype = np.float64</div>
<div class="line"><span class="lineno"> 1337</span> </div>
<div class="line"><span class="lineno"> 1338</span>    comment = comments</div>
<div class="line"><span class="lineno"> 1339</span>    <span class="comment"># Control character type conversions for Py3 convenience</span></div>
<div class="line"><span class="lineno"> 1340</span>    <span class="keywordflow">if</span> comment <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1341</span>        <span class="keywordflow">if</span> isinstance(comment, (str, bytes)):</div>
<div class="line"><span class="lineno"> 1342</span>            comment = [comment]</div>
<div class="line"><span class="lineno"> 1343</span>        comment = [</div>
<div class="line"><span class="lineno"> 1344</span>            x.decode(<span class="stringliteral">&#39;latin1&#39;</span>) <span class="keywordflow">if</span> isinstance(x, bytes) <span class="keywordflow">else</span> x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> comment]</div>
<div class="line"><span class="lineno"> 1345</span>    <span class="keywordflow">if</span> isinstance(delimiter, bytes):</div>
<div class="line"><span class="lineno"> 1346</span>        delimiter = delimiter.decode(<span class="stringliteral">&#39;latin1&#39;</span>)</div>
<div class="line"><span class="lineno"> 1347</span> </div>
<div class="line"><span class="lineno"> 1348</span>    arr = _read(fname, dtype=dtype, comment=comment, delimiter=delimiter,</div>
<div class="line"><span class="lineno"> 1349</span>                converters=converters, skiplines=skiprows, usecols=usecols,</div>
<div class="line"><span class="lineno"> 1350</span>                unpack=unpack, ndmin=ndmin, encoding=encoding,</div>
<div class="line"><span class="lineno"> 1351</span>                max_rows=max_rows, quote=quotechar)</div>
<div class="line"><span class="lineno"> 1352</span> </div>
<div class="line"><span class="lineno"> 1353</span>    <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno"> 1354</span> </div>
<div class="line"><span class="lineno"> 1355</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8e9c91952b27de66a0f62f8ca6fc026" name="ae8e9c91952b27de66a0f62f8ca6fc026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e9c91952b27de66a0f62f8ca6fc026">&#9670;&#160;</a></span>recfromcsv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.recfromcsv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load ASCII data stored in a comma-separated file.

The returned array is a record array (if ``usemask=False``, see
`recarray`) or a masked record array (if ``usemask=True``,
see `ma.mrecords.MaskedRecords`).

Parameters
----------
fname, kwargs : For a description of input parameters, see `genfromtxt`.

See Also
--------
numpy.genfromtxt : generic function to load ASCII data.

Notes
-----
By default, `dtype` is None, which means that the data-type of the output
array will be determined from the data.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2503</span><span class="keyword">def </span>recfromcsv(fname, **kwargs):</div>
<div class="line"><span class="lineno"> 2504</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral">    Load ASCII data stored in a comma-separated file.</span></div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral">    The returned array is a record array (if ``usemask=False``, see</span></div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral">    `recarray`) or a masked record array (if ``usemask=True``,</span></div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral">    see `ma.mrecords.MaskedRecords`).</span></div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">    fname, kwargs : For a description of input parameters, see `genfromtxt`.</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2515</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral">    numpy.genfromtxt : generic function to load ASCII data.</span></div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral">    By default, `dtype` is None, which means that the data-type of the output</span></div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">    array will be determined from the data.</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2525</span>    <span class="comment"># Set default kwargs for genfromtxt as relevant to csv import.</span></div>
<div class="line"><span class="lineno"> 2526</span>    kwargs.setdefault(<span class="stringliteral">&quot;case_sensitive&quot;</span>, <span class="stringliteral">&quot;lower&quot;</span>)</div>
<div class="line"><span class="lineno"> 2527</span>    kwargs.setdefault(<span class="stringliteral">&quot;names&quot;</span>, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2528</span>    kwargs.setdefault(<span class="stringliteral">&quot;delimiter&quot;</span>, <span class="stringliteral">&quot;,&quot;</span>)</div>
<div class="line"><span class="lineno"> 2529</span>    kwargs.setdefault(<span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 2530</span>    output = genfromtxt(fname, **kwargs)</div>
<div class="line"><span class="lineno"> 2531</span> </div>
<div class="line"><span class="lineno"> 2532</span>    usemask = kwargs.get(<span class="stringliteral">&quot;usemask&quot;</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2533</span>    <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2534</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacenumpy_1_1ma_1_1mrecords.html">numpy.ma.mrecords</a> <span class="keyword">import</span> MaskedRecords</div>
<div class="line"><span class="lineno"> 2535</span>        output = output.view(MaskedRecords)</div>
<div class="line"><span class="lineno"> 2536</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2537</span>        output = output.view(np.recarray)</div>
<div class="line"><span class="lineno"> 2538</span>    <span class="keywordflow">return</span> output</div>
<div class="ttc" id="anamespacenumpy_1_1ma_1_1mrecords_html"><div class="ttname"><a href="namespacenumpy_1_1ma_1_1mrecords.html">numpy.ma.mrecords</a></div><div class="ttdef"><b>Definition</b> mrecords.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a318bbaf6cd6c026e209aaa78157b2464" name="a318bbaf6cd6c026e209aaa78157b2464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318bbaf6cd6c026e209aaa78157b2464">&#9670;&#160;</a></span>recfromtxt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.recfromtxt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load ASCII data from a file and return it in a record array.

If ``usemask=False`` a standard `recarray` is returned,
if ``usemask=True`` a MaskedRecords array is returned.

Parameters
----------
fname, kwargs : For a description of input parameters, see `genfromtxt`.

See Also
--------
numpy.genfromtxt : generic function

Notes
-----
By default, `dtype` is None, which means that the data-type of the output
array will be determined from the data.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2471</span><span class="keyword">def </span>recfromtxt(fname, **kwargs):</div>
<div class="line"><span class="lineno"> 2472</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">    Load ASCII data from a file and return it in a record array.</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">    If ``usemask=False`` a standard `recarray` is returned,</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">    if ``usemask=True`` a MaskedRecords array is returned.</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral">    fname, kwargs : For a description of input parameters, see `genfromtxt`.</span></div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">    numpy.genfromtxt : generic function</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">    By default, `dtype` is None, which means that the data-type of the output</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">    array will be determined from the data.</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2492</span>    kwargs.setdefault(<span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 2493</span>    usemask = kwargs.get(<span class="stringliteral">&#39;usemask&#39;</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2494</span>    output = genfromtxt(fname, **kwargs)</div>
<div class="line"><span class="lineno"> 2495</span>    <span class="keywordflow">if</span> usemask:</div>
<div class="line"><span class="lineno"> 2496</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacenumpy_1_1ma_1_1mrecords.html">numpy.ma.mrecords</a> <span class="keyword">import</span> MaskedRecords</div>
<div class="line"><span class="lineno"> 2497</span>        output = output.view(MaskedRecords)</div>
<div class="line"><span class="lineno"> 2498</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2499</span>        output = output.view(np.recarray)</div>
<div class="line"><span class="lineno"> 2500</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 2501</span> </div>
<div class="line"><span class="lineno"> 2502</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4b07013f27d7c0c9ba0271793142e96" name="ab4b07013f27d7c0c9ba0271793142e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b07013f27d7c0c9ba0271793142e96">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.save </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_pickle</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fix_imports</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save an array to a binary file in NumPy ``.npy`` format.

Parameters
----------
file : file, str, or pathlib.Path
    File or filename to which the data is saved.  If file is a file-object,
    then the filename is unchanged.  If file is a string or Path, a ``.npy``
    extension will be appended to the filename if it does not already
    have one.
arr : array_like
    Array data to be saved.
allow_pickle : bool, optional
    Allow saving object arrays using Python pickles. Reasons for disallowing
    pickles include security (loading pickled data can execute arbitrary
    code) and portability (pickled objects may not be loadable on different
    Python installations, for example if the stored objects require libraries
    that are not available, and not all pickled data is compatible between
    Python 2 and Python 3).
    Default: True
fix_imports : bool, optional
    Only useful in forcing objects in object arrays on Python 3 to be
    pickled in a Python 2 compatible way. If `fix_imports` is True, pickle
    will try to map the new Python 3 names to the old module names used in
    Python 2, so that the pickle data stream is readable with Python 2.

See Also
--------
savez : Save several arrays into a ``.npz`` archive
savetxt, load

Notes
-----
For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.

Any data saved to the file is appended to the end of the file.

Examples
--------
&gt;&gt;&gt; from tempfile import TemporaryFile
&gt;&gt;&gt; outfile = TemporaryFile()

&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; np.save(outfile, x)

&gt;&gt;&gt; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file
&gt;&gt;&gt; np.load(outfile)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])


&gt;&gt;&gt; with open('test.npy', 'wb') as f:
...     np.save(f, np.array([1, 2]))
...     np.save(f, np.array([1, 3]))
&gt;&gt;&gt; with open('test.npy', 'rb') as f:
...     a = np.load(f)
...     b = np.load(f)
&gt;&gt;&gt; print(a, b)
# [1 2] [1 3]
</pre> <div class="fragment"><div class="line"><span class="lineno">  452</span><span class="keyword">def </span>save(file, arr, allow_pickle=True, fix_imports=True):</div>
<div class="line"><span class="lineno">  453</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    Save an array to a binary file in NumPy ``.npy`` format.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    file : file, str, or pathlib.Path</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        File or filename to which the data is saved.  If file is a file-object,</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        then the filename is unchanged.  If file is a string or Path, a ``.npy``</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">        extension will be appended to the filename if it does not already</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        have one.</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    arr : array_like</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        Array data to be saved.</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    allow_pickle : bool, optional</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">        Allow saving object arrays using Python pickles. Reasons for disallowing</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">        pickles include security (loading pickled data can execute arbitrary</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        code) and portability (pickled objects may not be loadable on different</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        Python installations, for example if the stored objects require libraries</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        that are not available, and not all pickled data is compatible between</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">        Python 2 and Python 3).</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        Default: True</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    fix_imports : bool, optional</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        Only useful in forcing objects in object arrays on Python 3 to be</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        pickled in a Python 2 compatible way. If `fix_imports` is True, pickle</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        will try to map the new Python 3 names to the old module names used in</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        Python 2, so that the pickle data stream is readable with Python 2.</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    savez : Save several arrays into a ``.npz`` archive</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    savetxt, load</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    Any data saved to the file is appended to the end of the file.</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    &gt;&gt;&gt; from tempfile import TemporaryFile</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    &gt;&gt;&gt; outfile = TemporaryFile()</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(10)</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    &gt;&gt;&gt; np.save(outfile, x)</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    &gt;&gt;&gt; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    &gt;&gt;&gt; np.load(outfile)</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    &gt;&gt;&gt; with open(&#39;test.npy&#39;, &#39;wb&#39;) as f:</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    ...     np.save(f, np.array([1, 2]))</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    ...     np.save(f, np.array([1, 3]))</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    &gt;&gt;&gt; with open(&#39;test.npy&#39;, &#39;rb&#39;) as f:</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    ...     a = np.load(f)</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    ...     b = np.load(f)</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &gt;&gt;&gt; print(a, b)</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">    # [1 2] [1 3]</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  512</span>    <span class="keywordflow">if</span> hasattr(file, <span class="stringliteral">&#39;write&#39;</span>):</div>
<div class="line"><span class="lineno">  513</span>        file_ctx = contextlib.nullcontext(file)</div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  515</span>        file = os_fspath(file)</div>
<div class="line"><span class="lineno">  516</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> file.endswith(<span class="stringliteral">&#39;.npy&#39;</span>):</div>
<div class="line"><span class="lineno">  517</span>            file = file + <span class="stringliteral">&#39;.npy&#39;</span></div>
<div class="line"><span class="lineno">  518</span>        file_ctx = open(file, <span class="stringliteral">&quot;wb&quot;</span>)</div>
<div class="line"><span class="lineno">  519</span> </div>
<div class="line"><span class="lineno">  520</span>    <span class="keyword">with</span> file_ctx <span class="keyword">as</span> fid:</div>
<div class="line"><span class="lineno">  521</span>        arr = np.asanyarray(arr)</div>
<div class="line"><span class="lineno">  522</span>        format.write_array(fid, arr, allow_pickle=allow_pickle,</div>
<div class="line"><span class="lineno">  523</span>                           pickle_kwargs=dict(fix_imports=fix_imports))</div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e8a27ef9c03f4b55b953ed7fa392da5" name="a1e8a27ef9c03f4b55b953ed7fa392da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8a27ef9c03f4b55b953ed7fa392da5">&#9670;&#160;</a></span>savetxt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.savetxt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fmt</em> = <code>'%.18e'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newline</em> = <code>'\<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>header</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footer</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comments</em> = <code>'#&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save an array to a text file.

Parameters
----------
fname : filename or file handle
    If the filename ends in ``.gz``, the file is automatically saved in
    compressed gzip format.  `loadtxt` understands gzipped files
    transparently.
X : 1D or 2D array_like
    Data to be saved to a text file.
fmt : str or sequence of strs, optional
    A single format (%10.5f), a sequence of formats, or a
    multi-format string, e.g. 'Iteration %d -- %10.5f', in which
    case `delimiter` is ignored. For complex `X`, the legal options
    for `fmt` are:

    * a single specifier, `fmt='%.4e'`, resulting in numbers formatted
      like `' (%s+%sj)' % (fmt, fmt)`
    * a full string specifying every real and imaginary part, e.g.
      `' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'` for 3 columns
    * a list of specifiers, one per column - in this case, the real
      and imaginary part must have separate specifiers,
      e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns
delimiter : str, optional
    String or character separating columns.
newline : str, optional
    String or character separating lines.

    .. versionadded:: 1.5.0
header : str, optional
    String that will be written at the beginning of the file.

    .. versionadded:: 1.7.0
footer : str, optional
    String that will be written at the end of the file.

    .. versionadded:: 1.7.0
comments : str, optional
    String that will be prepended to the ``header`` and ``footer`` strings,
    to mark them as comments. Default: '# ',  as expected by e.g.
    ``numpy.loadtxt``.

    .. versionadded:: 1.7.0
encoding : {None, str}, optional
    Encoding used to encode the outputfile. Does not apply to output
    streams. If the encoding is something other than 'bytes' or 'latin1'
    you will not be able to load the file in NumPy versions &lt; 1.14. Default
    is 'latin1'.

    .. versionadded:: 1.14.0


See Also
--------
save : Save an array to a binary file in NumPy ``.npy`` format
savez : Save several arrays into an uncompressed ``.npz`` archive
savez_compressed : Save several arrays into a compressed ``.npz`` archive

Notes
-----
Further explanation of the `fmt` parameter
(``%[flag]width[.precision]specifier``):

flags:
    ``-`` : left justify

    ``+`` : Forces to precede result with + or -.

    ``0`` : Left pad the number with zeros instead of space (see width).

width:
    Minimum number of characters to be printed. The value is not truncated
    if it has more characters.

precision:
    - For integer specifiers (eg. ``d,i,o,x``), the minimum number of
      digits.
    - For ``e, E`` and ``f`` specifiers, the number of digits to print
      after the decimal point.
    - For ``g`` and ``G``, the maximum number of significant digits.
    - For ``s``, the maximum number of characters.

specifiers:
    ``c`` : character

    ``d`` or ``i`` : signed decimal integer

    ``e`` or ``E`` : scientific notation with ``e`` or ``E``.

    ``f`` : decimal floating point

    ``g,G`` : use the shorter of ``e,E`` or ``f``

    ``o`` : signed octal

    ``s`` : string of characters

    ``u`` : unsigned decimal integer

    ``x,X`` : unsigned hexadecimal integer

This explanation of ``fmt`` is not complete, for an exhaustive
specification see [1]_.

References
----------
.. [1] `Format Specification Mini-Language
       &lt;https://docs.python.org/library/string.html#format-specification-mini-language&gt;`_,
       Python Documentation.

Examples
--------
&gt;&gt;&gt; x = y = z = np.arange(0.0,5.0,1.0)
&gt;&gt;&gt; np.savetxt('test.out', x, delimiter=',')   # X is an array
&gt;&gt;&gt; np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays
&gt;&gt;&gt; np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation</pre> <div class="fragment"><div class="line"><span class="lineno"> 1369</span>            footer=<span class="stringliteral">&#39;&#39;</span>, comments=<span class="stringliteral">&#39;# &#39;</span>, encoding=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1370</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    Save an array to a text file.</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    fname : filename or file handle</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">        If the filename ends in ``.gz``, the file is automatically saved in</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">        compressed gzip format.  `loadtxt` understands gzipped files</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">        transparently.</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    X : 1D or 2D array_like</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">        Data to be saved to a text file.</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    fmt : str or sequence of strs, optional</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">        A single format (%10.5f), a sequence of formats, or a</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">        multi-format string, e.g. &#39;Iteration %d -- %10.5f&#39;, in which</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">        case `delimiter` is ignored. For complex `X`, the legal options</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">        for `fmt` are:</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">        * a single specifier, `fmt=&#39;%.4e&#39;`, resulting in numbers formatted</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">          like `&#39; (%s+%sj)&#39; % (fmt, fmt)`</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">        * a full string specifying every real and imaginary part, e.g.</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">          `&#39; %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej&#39;` for 3 columns</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">        * a list of specifiers, one per column - in this case, the real</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">          and imaginary part must have separate specifiers,</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">          e.g. `[&#39;%.3e + %.3ej&#39;, &#39;(%.15e%+.15ej)&#39;]` for 2 columns</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    delimiter : str, optional</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">        String or character separating columns.</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">    newline : str, optional</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">        String or character separating lines.</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">        .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    header : str, optional</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">        String that will be written at the beginning of the file.</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    footer : str, optional</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">        String that will be written at the end of the file.</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    comments : str, optional</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">        String that will be prepended to the ``header`` and ``footer`` strings,</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">        to mark them as comments. Default: &#39;# &#39;,  as expected by e.g.</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">        ``numpy.loadtxt``.</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    encoding : {None, str}, optional</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">        Encoding used to encode the outputfile. Does not apply to output</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">        streams. If the encoding is something other than &#39;bytes&#39; or &#39;latin1&#39;</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">        you will not be able to load the file in NumPy versions &lt; 1.14. Default</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">        is &#39;latin1&#39;.</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">        .. versionadded:: 1.14.0</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">    save : Save an array to a binary file in NumPy ``.npy`` format</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    savez : Save several arrays into an uncompressed ``.npz`` archive</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    savez_compressed : Save several arrays into a compressed ``.npz`` archive</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">    Further explanation of the `fmt` parameter</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">    (``%[flag]width[.precision]specifier``):</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    flags:</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">        ``-`` : left justify</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">        ``+`` : Forces to precede result with + or -.</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">        ``0`` : Left pad the number with zeros instead of space (see width).</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    width:</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">        Minimum number of characters to be printed. The value is not truncated</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">        if it has more characters.</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    precision:</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">          digits.</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">        - For ``e, E`` and ``f`` specifiers, the number of digits to print</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">          after the decimal point.</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">        - For ``g`` and ``G``, the maximum number of significant digits.</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">        - For ``s``, the maximum number of characters.</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    specifiers:</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">        ``c`` : character</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">        ``d`` or ``i`` : signed decimal integer</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.</span></div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">        ``f`` : decimal floating point</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">        ``g,G`` : use the shorter of ``e,E`` or ``f``</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">        ``o`` : signed octal</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">        ``s`` : string of characters</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">        ``u`` : unsigned decimal integer</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">        ``x,X`` : unsigned hexadecimal integer</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">    This explanation of ``fmt`` is not complete, for an exhaustive</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">    specification see [1]_.</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">    .. [1] `Format Specification Mini-Language</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">           &lt;https://docs.python.org/library/string.html#format-specification-mini-language&gt;`_,</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">           Python Documentation.</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">    &gt;&gt;&gt; x = y = z = np.arange(0.0,5.0,1.0)</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">    &gt;&gt;&gt; np.savetxt(&#39;test.out&#39;, x, delimiter=&#39;,&#39;)   # X is an array</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">    &gt;&gt;&gt; np.savetxt(&#39;test.out&#39;, (x,y,z))   # x,y,z equal sized 1D arrays</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">    &gt;&gt;&gt; np.savetxt(&#39;test.out&#39;, x, fmt=&#39;%1.4e&#39;)   # use exponential notation</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1489</span> </div>
<div class="line"><span class="lineno"> 1490</span>    <span class="comment"># Py3 conversions first</span></div>
<div class="line"><span class="lineno"> 1491</span>    <span class="keywordflow">if</span> isinstance(fmt, bytes):</div>
<div class="line"><span class="lineno"> 1492</span>        fmt = asstr(fmt)</div>
<div class="line"><span class="lineno"> 1493</span>    delimiter = asstr(delimiter)</div>
<div class="line"><span class="lineno"> 1494</span> </div>
<div class="line"><span class="lineno"> 1495</span>    <span class="keyword">class </span>WriteWrap:</div>
<div class="line"><span class="lineno"> 1496</span>        <span class="stringliteral">&quot;&quot;&quot;Convert to bytes on bytestream inputs.</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1499</span>        <span class="keyword">def </span>__init__(self, fh, encoding):</div>
<div class="line"><span class="lineno"> 1500</span>            self.fh = fh</div>
<div class="line"><span class="lineno"> 1501</span>            self.encoding = encoding</div>
<div class="line"><span class="lineno"> 1502</span>            self.do_write = self.first_write</div>
<div class="line"><span class="lineno"> 1503</span> </div>
<div class="line"><span class="lineno"> 1504</span>        <span class="keyword">def </span>close(self):</div>
<div class="line"><span class="lineno"> 1505</span>            self.fh.close()</div>
<div class="line"><span class="lineno"> 1506</span> </div>
<div class="line"><span class="lineno"> 1507</span>        <span class="keyword">def </span>write(self, v):</div>
<div class="line"><span class="lineno"> 1508</span>            self.do_write(v)</div>
<div class="line"><span class="lineno"> 1509</span> </div>
<div class="line"><span class="lineno"> 1510</span>        <span class="keyword">def </span>write_bytes(self, v):</div>
<div class="line"><span class="lineno"> 1511</span>            <span class="keywordflow">if</span> isinstance(v, bytes):</div>
<div class="line"><span class="lineno"> 1512</span>                self.fh.write(v)</div>
<div class="line"><span class="lineno"> 1513</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1514</span>                self.fh.write(v.encode(self.encoding))</div>
<div class="line"><span class="lineno"> 1515</span> </div>
<div class="line"><span class="lineno"> 1516</span>        <span class="keyword">def </span>write_normal(self, v):</div>
<div class="line"><span class="lineno"> 1517</span>            self.fh.write(asunicode(v))</div>
<div class="line"><span class="lineno"> 1518</span> </div>
<div class="line"><span class="lineno"> 1519</span>        <span class="keyword">def </span>first_write(self, v):</div>
<div class="line"><span class="lineno"> 1520</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1521</span>                self.write_normal(v)</div>
<div class="line"><span class="lineno"> 1522</span>                self.write = self.write_normal</div>
<div class="line"><span class="lineno"> 1523</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1524</span>                <span class="comment"># input is probably a bytestream</span></div>
<div class="line"><span class="lineno"> 1525</span>                self.write_bytes(v)</div>
<div class="line"><span class="lineno"> 1526</span>                self.write = self.write_bytes</div>
<div class="line"><span class="lineno"> 1527</span> </div>
<div class="line"><span class="lineno"> 1528</span>    own_fh = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1529</span>    <span class="keywordflow">if</span> isinstance(fname, os_PathLike):</div>
<div class="line"><span class="lineno"> 1530</span>        fname = os_fspath(fname)</div>
<div class="line"><span class="lineno"> 1531</span>    <span class="keywordflow">if</span> _is_string_like(fname):</div>
<div class="line"><span class="lineno"> 1532</span>        <span class="comment"># datasource doesn&#39;t support creating a new file ...</span></div>
<div class="line"><span class="lineno"> 1533</span>        open(fname, <span class="stringliteral">&#39;wt&#39;</span>).close()</div>
<div class="line"><span class="lineno"> 1534</span>        fh = np.lib._datasource.open(fname, <span class="stringliteral">&#39;wt&#39;</span>, encoding=encoding)</div>
<div class="line"><span class="lineno"> 1535</span>        own_fh = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1536</span>    <span class="keywordflow">elif</span> hasattr(fname, <span class="stringliteral">&#39;write&#39;</span>):</div>
<div class="line"><span class="lineno"> 1537</span>        <span class="comment"># wrap to handle byte output streams</span></div>
<div class="line"><span class="lineno"> 1538</span>        fh = WriteWrap(fname, encoding <span class="keywordflow">or</span> <span class="stringliteral">&#39;latin1&#39;</span>)</div>
<div class="line"><span class="lineno"> 1539</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1540</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;fname must be a string or file handle&#39;</span>)</div>
<div class="line"><span class="lineno"> 1541</span> </div>
<div class="line"><span class="lineno"> 1542</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1543</span>        X = np.asarray(X)</div>
<div class="line"><span class="lineno"> 1544</span> </div>
<div class="line"><span class="lineno"> 1545</span>        <span class="comment"># Handle 1-dimensional arrays</span></div>
<div class="line"><span class="lineno"> 1546</span>        <span class="keywordflow">if</span> X.ndim == 0 <span class="keywordflow">or</span> X.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 1547</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1548</span>                <span class="stringliteral">&quot;Expected 1D or 2D array, got %dD array instead&quot;</span> % X.ndim)</div>
<div class="line"><span class="lineno"> 1549</span>        <span class="keywordflow">elif</span> X.ndim == 1:</div>
<div class="line"><span class="lineno"> 1550</span>            <span class="comment"># Common case -- 1d array of numbers</span></div>
<div class="line"><span class="lineno"> 1551</span>            <span class="keywordflow">if</span> X.dtype.names <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1552</span>                X = np.atleast_2d(X).T</div>
<div class="line"><span class="lineno"> 1553</span>                ncol = 1</div>
<div class="line"><span class="lineno"> 1554</span> </div>
<div class="line"><span class="lineno"> 1555</span>            <span class="comment"># Complex dtype -- each field indicates a separate column</span></div>
<div class="line"><span class="lineno"> 1556</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1557</span>                ncol = len(X.dtype.names)</div>
<div class="line"><span class="lineno"> 1558</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1559</span>            ncol = X.shape[1]</div>
<div class="line"><span class="lineno"> 1560</span> </div>
<div class="line"><span class="lineno"> 1561</span>        iscomplex_X = np.iscomplexobj(X)</div>
<div class="line"><span class="lineno"> 1562</span>        <span class="comment"># `fmt` can be a string with multiple insertion points or a</span></div>
<div class="line"><span class="lineno"> 1563</span>        <span class="comment"># list of formats.  E.g. &#39;%10.5f\t%10d&#39; or (&#39;%10.5f&#39;, &#39;$10d&#39;)</span></div>
<div class="line"><span class="lineno"> 1564</span>        <span class="keywordflow">if</span> type(fmt) <span class="keywordflow">in</span> (list, tuple):</div>
<div class="line"><span class="lineno"> 1565</span>            <span class="keywordflow">if</span> len(fmt) != ncol:</div>
<div class="line"><span class="lineno"> 1566</span>                <span class="keywordflow">raise</span> AttributeError(<span class="stringliteral">&#39;fmt has wrong shape.  %s&#39;</span> % str(fmt))</div>
<div class="line"><span class="lineno"> 1567</span>            format = asstr(delimiter).join(map(asstr, fmt))</div>
<div class="line"><span class="lineno"> 1568</span>        <span class="keywordflow">elif</span> isinstance(fmt, str):</div>
<div class="line"><span class="lineno"> 1569</span>            n_fmt_chars = fmt.count(<span class="stringliteral">&#39;%&#39;</span>)</div>
<div class="line"><span class="lineno"> 1570</span>            error = ValueError(<span class="stringliteral">&#39;fmt has wrong number of %% formats:  %s&#39;</span> % fmt)</div>
<div class="line"><span class="lineno"> 1571</span>            <span class="keywordflow">if</span> n_fmt_chars == 1:</div>
<div class="line"><span class="lineno"> 1572</span>                <span class="keywordflow">if</span> iscomplex_X:</div>
<div class="line"><span class="lineno"> 1573</span>                    fmt = [<span class="stringliteral">&#39; (%s+%sj)&#39;</span> % (fmt, fmt), ] * ncol</div>
<div class="line"><span class="lineno"> 1574</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1575</span>                    fmt = [fmt, ] * ncol</div>
<div class="line"><span class="lineno"> 1576</span>                format = delimiter.join(fmt)</div>
<div class="line"><span class="lineno"> 1577</span>            <span class="keywordflow">elif</span> iscomplex_X <span class="keywordflow">and</span> n_fmt_chars != (2 * ncol):</div>
<div class="line"><span class="lineno"> 1578</span>                <span class="keywordflow">raise</span> error</div>
<div class="line"><span class="lineno"> 1579</span>            <span class="keywordflow">elif</span> ((<span class="keywordflow">not</span> iscomplex_X) <span class="keywordflow">and</span> n_fmt_chars != ncol):</div>
<div class="line"><span class="lineno"> 1580</span>                <span class="keywordflow">raise</span> error</div>
<div class="line"><span class="lineno"> 1581</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1582</span>                format = fmt</div>
<div class="line"><span class="lineno"> 1583</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1584</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;invalid fmt: %r&#39;</span> % (fmt,))</div>
<div class="line"><span class="lineno"> 1585</span> </div>
<div class="line"><span class="lineno"> 1586</span>        <span class="keywordflow">if</span> len(header) &gt; 0:</div>
<div class="line"><span class="lineno"> 1587</span>            header = header.replace(<span class="stringliteral">&#39;\n&#39;</span>, <span class="stringliteral">&#39;\n&#39;</span> + comments)</div>
<div class="line"><span class="lineno"> 1588</span>            fh.write(comments + header + newline)</div>
<div class="line"><span class="lineno"> 1589</span>        <span class="keywordflow">if</span> iscomplex_X:</div>
<div class="line"><span class="lineno"> 1590</span>            <span class="keywordflow">for</span> row <span class="keywordflow">in</span> X:</div>
<div class="line"><span class="lineno"> 1591</span>                row2 = []</div>
<div class="line"><span class="lineno"> 1592</span>                <span class="keywordflow">for</span> number <span class="keywordflow">in</span> row:</div>
<div class="line"><span class="lineno"> 1593</span>                    row2.append(number.real)</div>
<div class="line"><span class="lineno"> 1594</span>                    row2.append(number.imag)</div>
<div class="line"><span class="lineno"> 1595</span>                s = format % tuple(row2) + newline</div>
<div class="line"><span class="lineno"> 1596</span>                fh.write(s.replace(<span class="stringliteral">&#39;+-&#39;</span>, <span class="stringliteral">&#39;-&#39;</span>))</div>
<div class="line"><span class="lineno"> 1597</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1598</span>            <span class="keywordflow">for</span> row <span class="keywordflow">in</span> X:</div>
<div class="line"><span class="lineno"> 1599</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1600</span>                    v = format % tuple(row) + newline</div>
<div class="line"><span class="lineno"> 1601</span>                <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 1602</span>                    <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Mismatch between array dtype (&#39;%s&#39;) and &quot;</span></div>
<div class="line"><span class="lineno"> 1603</span>                                    <span class="stringliteral">&quot;format specifier (&#39;%s&#39;)&quot;</span></div>
<div class="line"><span class="lineno"> 1604</span>                                    % (str(X.dtype), format)) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 1605</span>                fh.write(v)</div>
<div class="line"><span class="lineno"> 1606</span> </div>
<div class="line"><span class="lineno"> 1607</span>        <span class="keywordflow">if</span> len(footer) &gt; 0:</div>
<div class="line"><span class="lineno"> 1608</span>            footer = footer.replace(<span class="stringliteral">&#39;\n&#39;</span>, <span class="stringliteral">&#39;\n&#39;</span> + comments)</div>
<div class="line"><span class="lineno"> 1609</span>            fh.write(comments + footer + newline)</div>
<div class="line"><span class="lineno"> 1610</span>    <span class="keywordflow">finally</span>:</div>
<div class="line"><span class="lineno"> 1611</span>        <span class="keywordflow">if</span> own_fh:</div>
<div class="line"><span class="lineno"> 1612</span>            fh.close()</div>
<div class="line"><span class="lineno"> 1613</span> </div>
<div class="line"><span class="lineno"> 1614</span> </div>
<div class="line"><span class="lineno"> 1615</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a39c3515e60a095b2ad9fd4fc0c409bc2" name="a39c3515e60a095b2ad9fd4fc0c409bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c3515e60a095b2ad9fd4fc0c409bc2">&#9670;&#160;</a></span>savez()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.savez </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save several arrays into a single file in uncompressed ``.npz`` format.

Provide arrays as keyword arguments to store them under the
corresponding name in the output file: ``savez(fn, x=x, y=y)``.

If arrays are specified as positional arguments, i.e., ``savez(fn,
x, y)``, their names will be `arr_0`, `arr_1`, etc.

Parameters
----------
file : str or file
    Either the filename (string) or an open file (file-like object)
    where the data will be saved. If file is a string or a Path, the
    ``.npz`` extension will be appended to the filename if it is not
    already there.
args : Arguments, optional
    Arrays to save to the file. Please use keyword arguments (see
    `kwds` below) to assign names to arrays.  Arrays specified as
    args will be named "arr_0", "arr_1", and so on.
kwds : Keyword arguments, optional
    Arrays to save to the file. Each array will be saved to the
    output file with its corresponding keyword name.

Returns
-------
None

See Also
--------
save : Save a single array to a binary file in NumPy format.
savetxt : Save an array to a file as plain text.
savez_compressed : Save several arrays into a compressed ``.npz`` archive

Notes
-----
The ``.npz`` file format is a zipped archive of files named after the
variables they contain.  The archive is not compressed and each file
in the archive contains one variable in ``.npy`` format. For a
description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.

When opening the saved ``.npz`` file with `load` a `NpzFile` object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the ``.files`` attribute), and for the arrays
themselves.

Keys passed in `kwds` are used as filenames inside the ZIP archive.
Therefore, keys should be valid filenames; e.g., avoid keys that begin with
``/`` or contain ``.``.

When naming variables with keyword arguments, it is not possible to name a
variable ``file``, as this would cause the ``file`` argument to be defined
twice in the call to ``savez``.

Examples
--------
&gt;&gt;&gt; from tempfile import TemporaryFile
&gt;&gt;&gt; outfile = TemporaryFile()
&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; y = np.sin(x)

Using `savez` with \\*args, the arrays are saved with default names.

&gt;&gt;&gt; np.savez(outfile, x, y)
&gt;&gt;&gt; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file
&gt;&gt;&gt; npzfile = np.load(outfile)
&gt;&gt;&gt; npzfile.files
['arr_0', 'arr_1']
&gt;&gt;&gt; npzfile['arr_0']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

Using `savez` with \\**kwds, the arrays are saved with the keyword names.

&gt;&gt;&gt; outfile = TemporaryFile()
&gt;&gt;&gt; np.savez(outfile, x=x, y=y)
&gt;&gt;&gt; _ = outfile.seek(0)
&gt;&gt;&gt; npzfile = np.load(outfile)
&gt;&gt;&gt; sorted(npzfile.files)
['x', 'y']
&gt;&gt;&gt; npzfile['x']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</pre> <div class="fragment"><div class="line"><span class="lineno">  532</span><span class="keyword">def </span>savez(file, *args, **kwds):</div>
<div class="line"><span class="lineno">  533</span>    <span class="stringliteral">&quot;&quot;&quot;Save several arrays into a single file in uncompressed ``.npz`` format.</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    Provide arrays as keyword arguments to store them under the</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    corresponding name in the output file: ``savez(fn, x=x, y=y)``.</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    If arrays are specified as positional arguments, i.e., ``savez(fn,</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    x, y)``, their names will be `arr_0`, `arr_1`, etc.</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    file : str or file</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        Either the filename (string) or an open file (file-like object)</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        where the data will be saved. If file is a string or a Path, the</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">        ``.npz`` extension will be appended to the filename if it is not</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">        already there.</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    args : Arguments, optional</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        Arrays to save to the file. Please use keyword arguments (see</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        `kwds` below) to assign names to arrays.  Arrays specified as</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        args will be named &quot;arr_0&quot;, &quot;arr_1&quot;, and so on.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    kwds : Keyword arguments, optional</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        Arrays to save to the file. Each array will be saved to the</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">        output file with its corresponding keyword name.</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    None</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    save : Save a single array to a binary file in NumPy format.</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    savetxt : Save an array to a file as plain text.</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    savez_compressed : Save several arrays into a compressed ``.npz`` archive</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    The ``.npz`` file format is a zipped archive of files named after the</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    variables they contain.  The archive is not compressed and each file</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    in the archive contains one variable in ``.npy`` format. For a</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    When opening the saved ``.npz`` file with `load` a `NpzFile` object is</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    returned. This is a dictionary-like object which can be queried for</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    its list of arrays (with the ``.files`` attribute), and for the arrays</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    themselves.</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    Keys passed in `kwds` are used as filenames inside the ZIP archive.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    Therefore, keys should be valid filenames; e.g., avoid keys that begin with</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    ``/`` or contain ``.``.</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    When naming variables with keyword arguments, it is not possible to name a</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    variable ``file``, as this would cause the ``file`` argument to be defined</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    twice in the call to ``savez``.</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    &gt;&gt;&gt; from tempfile import TemporaryFile</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    &gt;&gt;&gt; outfile = TemporaryFile()</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(10)</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    &gt;&gt;&gt; y = np.sin(x)</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    Using `savez` with \\*args, the arrays are saved with default names.</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    &gt;&gt;&gt; np.savez(outfile, x, y)</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    &gt;&gt;&gt; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    &gt;&gt;&gt; npzfile = np.load(outfile)</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    &gt;&gt;&gt; npzfile.files</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    [&#39;arr_0&#39;, &#39;arr_1&#39;]</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    &gt;&gt;&gt; npzfile[&#39;arr_0&#39;]</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    Using `savez` with \\**kwds, the arrays are saved with the keyword names.</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    &gt;&gt;&gt; outfile = TemporaryFile()</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    &gt;&gt;&gt; np.savez(outfile, x=x, y=y)</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    &gt;&gt;&gt; _ = outfile.seek(0)</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    &gt;&gt;&gt; npzfile = np.load(outfile)</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    &gt;&gt;&gt; sorted(npzfile.files)</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    [&#39;x&#39;, &#39;y&#39;]</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    &gt;&gt;&gt; npzfile[&#39;x&#39;]</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  615</span>    _savez(file, args, kwds, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac91da72dd133a0f84bf45d7dab5f1027" name="ac91da72dd133a0f84bf45d7dab5f1027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91da72dd133a0f84bf45d7dab5f1027">&#9670;&#160;</a></span>savez_compressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.savez_compressed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Save several arrays into a single file in compressed ``.npz`` format.

Provide arrays as keyword arguments to store them under the
corresponding name in the output file: ``savez(fn, x=x, y=y)``.

If arrays are specified as positional arguments, i.e., ``savez(fn,
x, y)``, their names will be `arr_0`, `arr_1`, etc.

Parameters
----------
file : str or file
    Either the filename (string) or an open file (file-like object)
    where the data will be saved. If file is a string or a Path, the
    ``.npz`` extension will be appended to the filename if it is not
    already there.
args : Arguments, optional
    Arrays to save to the file. Please use keyword arguments (see
    `kwds` below) to assign names to arrays.  Arrays specified as
    args will be named "arr_0", "arr_1", and so on.
kwds : Keyword arguments, optional
    Arrays to save to the file. Each array will be saved to the
    output file with its corresponding keyword name.

Returns
-------
None

See Also
--------
numpy.save : Save a single array to a binary file in NumPy format.
numpy.savetxt : Save an array to a file as plain text.
numpy.savez : Save several arrays into an uncompressed ``.npz`` file format
numpy.load : Load the files created by savez_compressed.

Notes
-----
The ``.npz`` file format is a zipped archive of files named after the
variables they contain.  The archive is compressed with
``zipfile.ZIP_DEFLATED`` and each file in the archive contains one variable
in ``.npy`` format. For a description of the ``.npy`` format, see
:py:mod:`numpy.lib.format`.


When opening the saved ``.npz`` file with `load` a `NpzFile` object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the ``.files`` attribute), and for the arrays
themselves.

Examples
--------
&gt;&gt;&gt; test_array = np.random.rand(3, 2)
&gt;&gt;&gt; test_vector = np.random.rand(4)
&gt;&gt;&gt; np.savez_compressed('/tmp/123', a=test_array, b=test_vector)
&gt;&gt;&gt; loaded = np.load('/tmp/123.npz')
&gt;&gt;&gt; print(np.array_equal(test_array, loaded['a']))
True
&gt;&gt;&gt; print(np.array_equal(test_vector, loaded['b']))
True</pre> <div class="fragment"><div class="line"><span class="lineno">  624</span><span class="keyword">def </span>savez_compressed(file, *args, **kwds):</div>
<div class="line"><span class="lineno">  625</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    Save several arrays into a single file in compressed ``.npz`` format.</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    Provide arrays as keyword arguments to store them under the</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    corresponding name in the output file: ``savez(fn, x=x, y=y)``.</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    If arrays are specified as positional arguments, i.e., ``savez(fn,</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    x, y)``, their names will be `arr_0`, `arr_1`, etc.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    file : str or file</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        Either the filename (string) or an open file (file-like object)</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">        where the data will be saved. If file is a string or a Path, the</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">        ``.npz`` extension will be appended to the filename if it is not</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">        already there.</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    args : Arguments, optional</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">        Arrays to save to the file. Please use keyword arguments (see</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">        `kwds` below) to assign names to arrays.  Arrays specified as</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">        args will be named &quot;arr_0&quot;, &quot;arr_1&quot;, and so on.</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    kwds : Keyword arguments, optional</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">        Arrays to save to the file. Each array will be saved to the</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        output file with its corresponding keyword name.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    None</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    numpy.save : Save a single array to a binary file in NumPy format.</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    numpy.savetxt : Save an array to a file as plain text.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    numpy.savez : Save several arrays into an uncompressed ``.npz`` file format</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    numpy.load : Load the files created by savez_compressed.</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    The ``.npz`` file format is a zipped archive of files named after the</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    variables they contain.  The archive is compressed with</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    ``zipfile.ZIP_DEFLATED`` and each file in the archive contains one variable</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    in ``.npy`` format. For a description of the ``.npy`` format, see</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    :py:mod:`numpy.lib.format`.</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    When opening the saved ``.npz`` file with `load` a `NpzFile` object is</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    returned. This is a dictionary-like object which can be queried for</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    its list of arrays (with the ``.files`` attribute), and for the arrays</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    themselves.</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    &gt;&gt;&gt; test_array = np.random.rand(3, 2)</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    &gt;&gt;&gt; test_vector = np.random.rand(4)</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    &gt;&gt;&gt; np.savez_compressed(&#39;/tmp/123&#39;, a=test_array, b=test_vector)</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    &gt;&gt;&gt; loaded = np.load(&#39;/tmp/123.npz&#39;)</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    &gt;&gt;&gt; print(np.array_equal(test_array, loaded[&#39;a&#39;]))</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    &gt;&gt;&gt; print(np.array_equal(test_vector, loaded[&#39;b&#39;]))</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  686</span>    _savez(file, args, kwds, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  687</span> </div>
<div class="line"><span class="lineno">  688</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40420dd827063c921cca501813d960f6" name="a40420dd827063c921cca501813d960f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40420dd827063c921cca501813d960f6">&#9670;&#160;</a></span>zipfile_factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.zipfile_factory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a ZipFile.

Allows for Zip64, and the `file` argument can accept file, str, or
pathlib.Path objects. `args` and `kwargs` are passed to the zipfile.ZipFile
constructor.
</pre> <div class="fragment"><div class="line"><span class="lineno">   91</span><span class="keyword">def </span>zipfile_factory(file, *args, **kwargs):</div>
<div class="line"><span class="lineno">   92</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    Create a ZipFile.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    Allows for Zip64, and the `file` argument can accept file, str, or</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    pathlib.Path objects. `args` and `kwargs` are passed to the zipfile.ZipFile</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    constructor.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   99</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(file, <span class="stringliteral">&#39;read&#39;</span>):</div>
<div class="line"><span class="lineno">  100</span>        file = os_fspath(file)</div>
<div class="line"><span class="lineno">  101</span>    <span class="keyword">import</span> zipfile</div>
<div class="line"><span class="lineno">  102</span>    kwargs[<span class="stringliteral">&#39;allowZip64&#39;</span>] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">return</span> zipfile.ZipFile(file, *args, **kwargs)</div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9fb5e39be76c8ae50195fabfabdaffc3" name="a9fb5e39be76c8ae50195fabfabdaffc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb5e39be76c8ae50195fabfabdaffc3">&#9670;&#160;</a></span>_genfromtxt_with_like</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._genfromtxt_with_like</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  array_function_dispatch(</div>
<div class="line"><span class="lineno">    2</span>    _genfromtxt_dispatcher</div>
<div class="line"><span class="lineno">    3</span>)(genfromtxt)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae64728e8461fb25723c4779fcb4d9b68" name="ae64728e8461fb25723c4779fcb4d9b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64728e8461fb25723c4779fcb4d9b68">&#9670;&#160;</a></span>_loadtxt_chunksize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int numpy.lib.npyio._loadtxt_chunksize = 50000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1605893e27d747512d3e617922ace93c" name="a1605893e27d747512d3e617922ace93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1605893e27d747512d3e617922ace93c">&#9670;&#160;</a></span>_loadtxt_with_like</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio._loadtxt_with_like</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  array_function_dispatch(</div>
<div class="line"><span class="lineno">    2</span>    _loadtxt_dispatcher</div>
<div class="line"><span class="lineno">    3</span>)(loadtxt)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5174822613aa364cc4c0d25861c3fb3b" name="a5174822613aa364cc4c0d25861c3fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5174822613aa364cc4c0d25861c3fb3b">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa307ef1d7a07340aede9aac1f80265bd" name="aa307ef1d7a07340aede9aac1f80265bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa307ef1d7a07340aede9aac1f80265bd">&#9670;&#160;</a></span>do_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.do_write</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24fe0d72d445b9775f02fe100396d2b7" name="a24fe0d72d445b9775f02fe100396d2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fe0d72d445b9775f02fe100396d2b7">&#9670;&#160;</a></span>encoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.encoding</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4991d480ceeeb43e7c9258e78a31fb77" name="a4991d480ceeeb43e7c9258e78a31fb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4991d480ceeeb43e7c9258e78a31fb77">&#9670;&#160;</a></span>fh</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.fh</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac540394a5e912ec17785248cebb76e41" name="ac540394a5e912ec17785248cebb76e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac540394a5e912ec17785248cebb76e41">&#9670;&#160;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.npyio.write</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
