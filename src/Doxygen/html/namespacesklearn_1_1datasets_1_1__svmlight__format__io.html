<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.datasets._svmlight_format_io Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1datasets.html">datasets</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html">_svmlight_format_io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.datasets._svmlight_format_io Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adecd56c48f860df0cb70add2208dbebc" id="r_adecd56c48f860df0cb70add2208dbebc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html#adecd56c48f860df0cb70add2208dbebc">_load_svmlight_file</a> (*args, **kwargs)</td></tr>
<tr class="separator:adecd56c48f860df0cb70add2208dbebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201930f96f238a51aea6261cfe5ccd6b" id="r_a201930f96f238a51aea6261cfe5ccd6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html#a201930f96f238a51aea6261cfe5ccd6b">load_svmlight_file</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, *n_features=None, dtype=np.float64, multilabel=False, zero_based=&quot;auto&quot;, query_id=False, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0, length=-1)</td></tr>
<tr class="separator:a201930f96f238a51aea6261cfe5ccd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767d9b9bcb2c6ae557bc38e25f9e433f" id="r_a767d9b9bcb2c6ae557bc38e25f9e433f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html#a767d9b9bcb2c6ae557bc38e25f9e433f">_gen_open</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>)</td></tr>
<tr class="separator:a767d9b9bcb2c6ae557bc38e25f9e433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e6af19d3b8237af17dd1dbf2bc7372" id="r_ad4e6af19d3b8237af17dd1dbf2bc7372"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html#ad4e6af19d3b8237af17dd1dbf2bc7372">_open_and_load</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, dtype, multilabel, zero_based, query_id, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0, length=-1)</td></tr>
<tr class="separator:ad4e6af19d3b8237af17dd1dbf2bc7372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faffdf6bbe6e455caefa3b15e3eb167" id="r_a9faffdf6bbe6e455caefa3b15e3eb167"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html#a9faffdf6bbe6e455caefa3b15e3eb167">load_svmlight_files</a> (files, *n_features=None, dtype=np.float64, multilabel=False, zero_based=&quot;auto&quot;, query_id=False, <a class="el" href="__lapack__subroutines_8h.html#ac5c1dfc0f77d6570b83bf10cfe850d4e">offset</a>=0, length=-1)</td></tr>
<tr class="separator:a9faffdf6bbe6e455caefa3b15e3eb167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a334a480a2865f58f4251f3e6696722" id="r_a6a334a480a2865f58f4251f3e6696722"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html#a6a334a480a2865f58f4251f3e6696722">_dump_svmlight</a> (X, y, <a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, multilabel, one_based, comment, query_id)</td></tr>
<tr class="separator:a6a334a480a2865f58f4251f3e6696722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2544b31f40986a2f856b07fccda8cfb" id="r_ab2544b31f40986a2f856b07fccda8cfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1datasets_1_1__svmlight__format__io.html#ab2544b31f40986a2f856b07fccda8cfb">dump_svmlight_file</a> (X, y, <a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, *zero_based=True, comment=None, query_id=None, multilabel=False)</td></tr>
<tr class="separator:ab2544b31f40986a2f856b07fccda8cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module implements a loader and dumper for the svmlight format

This format is a text-based format, with one sample per line. It does
not store zero valued features hence is suitable for sparse dataset.

The first element of each line can be used to store a target variable to
predict.

This format is used as the default format for both svmlight and the
libsvm command line programs.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6a334a480a2865f58f4251f3e6696722" name="a6a334a480a2865f58f4251f3e6696722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a334a480a2865f58f4251f3e6696722">&#9670;&#160;</a></span>_dump_svmlight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.datasets._svmlight_format_io._dump_svmlight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multilabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>one_based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  378</span><span class="keyword">def </span>_dump_svmlight(X, y, f, multilabel, one_based, comment, query_id):</div>
<div class="line"><span class="lineno">  379</span>    <span class="keywordflow">if</span> comment:</div>
<div class="line"><span class="lineno">  380</span>        f.write(</div>
<div class="line"><span class="lineno">  381</span>            (</div>
<div class="line"><span class="lineno">  382</span>                <span class="stringliteral">&quot;# Generated by dump_svmlight_file from scikit-learn %s\n&quot;</span> % __version__</div>
<div class="line"><span class="lineno">  383</span>            ).encode()</div>
<div class="line"><span class="lineno">  384</span>        )</div>
<div class="line"><span class="lineno">  385</span>        f.write(</div>
<div class="line"><span class="lineno">  386</span>            (<span class="stringliteral">&quot;# Column indices are %s-based\n&quot;</span> % [<span class="stringliteral">&quot;zero&quot;</span>, <span class="stringliteral">&quot;one&quot;</span>][one_based]).encode()</div>
<div class="line"><span class="lineno">  387</span>        )</div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>        f.write(b<span class="stringliteral">&quot;#\n&quot;</span>)</div>
<div class="line"><span class="lineno">  390</span>        f.writelines(b<span class="stringliteral">&quot;# %s\n&quot;</span> % line <span class="keywordflow">for</span> line <span class="keywordflow">in</span> comment.splitlines())</div>
<div class="line"><span class="lineno">  391</span>    X_is_sp = sp.issparse(X)</div>
<div class="line"><span class="lineno">  392</span>    y_is_sp = sp.issparse(y)</div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> multilabel <span class="keywordflow">and</span> <span class="keywordflow">not</span> y_is_sp:</div>
<div class="line"><span class="lineno">  394</span>        y = y[:, np.newaxis]</div>
<div class="line"><span class="lineno">  395</span>    _dump_svmlight_file(</div>
<div class="line"><span class="lineno">  396</span>        X,</div>
<div class="line"><span class="lineno">  397</span>        y,</div>
<div class="line"><span class="lineno">  398</span>        f,</div>
<div class="line"><span class="lineno">  399</span>        multilabel,</div>
<div class="line"><span class="lineno">  400</span>        one_based,</div>
<div class="line"><span class="lineno">  401</span>        query_id,</div>
<div class="line"><span class="lineno">  402</span>        X_is_sp,</div>
<div class="line"><span class="lineno">  403</span>        y_is_sp,</div>
<div class="line"><span class="lineno">  404</span>    )</div>
<div class="line"><span class="lineno">  405</span> </div>
<div class="line"><span class="lineno">  406</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a767d9b9bcb2c6ae557bc38e25f9e433f" name="a767d9b9bcb2c6ae557bc38e25f9e433f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767d9b9bcb2c6ae557bc38e25f9e433f">&#9670;&#160;</a></span>_gen_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.datasets._svmlight_format_io._gen_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  185</span><span class="keyword">def </span>_gen_open(f):</div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">if</span> isinstance(f, int):  <span class="comment"># file descriptor</span></div>
<div class="line"><span class="lineno">  187</span>        <span class="keywordflow">return</span> io.open(f, <span class="stringliteral">&quot;rb&quot;</span>, closefd=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">elif</span> isinstance(f, os.PathLike):</div>
<div class="line"><span class="lineno">  189</span>        f = os.fspath(f)</div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(f, str):</div>
<div class="line"><span class="lineno">  191</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;expected {str, int, path-like, file-like}, got %s&quot;</span> % type(f))</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span>    _, ext = os.path.splitext(f)</div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">if</span> ext == <span class="stringliteral">&quot;.gz&quot;</span>:</div>
<div class="line"><span class="lineno">  195</span>        <span class="keyword">import</span> gzip</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span>        <span class="keywordflow">return</span> gzip.open(f, <span class="stringliteral">&quot;rb&quot;</span>)</div>
<div class="line"><span class="lineno">  198</span>    <span class="keywordflow">elif</span> ext == <span class="stringliteral">&quot;.bz2&quot;</span>:</div>
<div class="line"><span class="lineno">  199</span>        <span class="keyword">from</span> bz2 <span class="keyword">import</span> BZ2File</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span>        <span class="keywordflow">return</span> BZ2File(f, <span class="stringliteral">&quot;rb&quot;</span>)</div>
<div class="line"><span class="lineno">  202</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  203</span>        <span class="keywordflow">return</span> open(f, <span class="stringliteral">&quot;rb&quot;</span>)</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adecd56c48f860df0cb70add2208dbebc" name="adecd56c48f860df0cb70add2208dbebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecd56c48f860df0cb70add2208dbebc">&#9670;&#160;</a></span>_load_svmlight_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.datasets._svmlight_format_io._load_svmlight_file </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   36</span>    <span class="keyword">def </span>_load_svmlight_file(*args, **kwargs):</div>
<div class="line"><span class="lineno">   37</span>        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno">   38</span>            <span class="stringliteral">&quot;load_svmlight_file is currently not &quot;</span></div>
<div class="line"><span class="lineno">   39</span>            <span class="stringliteral">&quot;compatible with PyPy (see &quot;</span></div>
<div class="line"><span class="lineno">   40</span>            <span class="stringliteral">&quot;https://github.com/scikit-learn/scikit-learn/issues/11543 &quot;</span></div>
<div class="line"><span class="lineno">   41</span>            <span class="stringliteral">&quot;for the status updates).&quot;</span></div>
<div class="line"><span class="lineno">   42</span>        )</div>
<div class="line"><span class="lineno">   43</span> </div>
<div class="line"><span class="lineno">   44</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4e6af19d3b8237af17dd1dbf2bc7372" name="ad4e6af19d3b8237af17dd1dbf2bc7372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e6af19d3b8237af17dd1dbf2bc7372">&#9670;&#160;</a></span>_open_and_load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.datasets._svmlight_format_io._open_and_load </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multilabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zero_based</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  206</span><span class="keyword">def </span>_open_and_load(f, dtype, multilabel, zero_based, query_id, offset=0, length=-1):</div>
<div class="line"><span class="lineno">  207</span>    <span class="keywordflow">if</span> hasattr(f, <span class="stringliteral">&quot;read&quot;</span>):</div>
<div class="line"><span class="lineno">  208</span>        actual_dtype, data, ind, indptr, labels, query = _load_svmlight_file(</div>
<div class="line"><span class="lineno">  209</span>            f, dtype, multilabel, zero_based, query_id, offset, length</div>
<div class="line"><span class="lineno">  210</span>        )</div>
<div class="line"><span class="lineno">  211</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  212</span>        <span class="keyword">with</span> closing(_gen_open(f)) <span class="keyword">as</span> f:</div>
<div class="line"><span class="lineno">  213</span>            actual_dtype, data, ind, indptr, labels, query = _load_svmlight_file(</div>
<div class="line"><span class="lineno">  214</span>                f, dtype, multilabel, zero_based, query_id, offset, length</div>
<div class="line"><span class="lineno">  215</span>            )</div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span>    <span class="comment"># convert from array.array, give data the right dtype</span></div>
<div class="line"><span class="lineno">  218</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> multilabel:</div>
<div class="line"><span class="lineno">  219</span>        labels = np.frombuffer(labels, np.float64)</div>
<div class="line"><span class="lineno">  220</span>    data = np.frombuffer(data, actual_dtype)</div>
<div class="line"><span class="lineno">  221</span>    indices = np.frombuffer(ind, np.longlong)</div>
<div class="line"><span class="lineno">  222</span>    indptr = np.frombuffer(indptr, dtype=np.longlong)  <span class="comment"># never empty</span></div>
<div class="line"><span class="lineno">  223</span>    query = np.frombuffer(query, np.int64)</div>
<div class="line"><span class="lineno">  224</span> </div>
<div class="line"><span class="lineno">  225</span>    data = np.asarray(data, dtype=dtype)  <span class="comment"># no-op for float{32,64}</span></div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">return</span> data, indices, indptr, labels, query</div>
<div class="line"><span class="lineno">  227</span> </div>
<div class="line"><span class="lineno">  228</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2544b31f40986a2f856b07fccda8cfb" name="ab2544b31f40986a2f856b07fccda8cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2544b31f40986a2f856b07fccda8cfb">&#9670;&#160;</a></span>dump_svmlight_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.datasets._svmlight_format_io.dump_svmlight_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>zero_based</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comment</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query_id</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multilabel</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dump the dataset in svmlight / libsvm file format.

This format is a text-based format, with one sample per line. It does
not store zero valued features hence is suitable for sparse dataset.

The first element of each line can be used to store a target variable
to predict.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training vectors, where `n_samples` is the number of samples and
    `n_features` is the number of features.

y : {array-like, sparse matrix}, shape = [n_samples (, n_labels)]
    Target values. Class labels must be an
    integer or float, or array-like objects of integer or float for
    multilabel classifications.

f : str or file-like in binary mode
    If string, specifies the path that will contain the data.
    If file-like, data will be written to f. f should be opened in binary
    mode.

zero_based : bool, default=True
    Whether column indices should be written zero-based (True) or one-based
    (False).

comment : str, default=None
    Comment to insert at the top of the file. This should be either a
    Unicode string, which will be encoded as UTF-8, or an ASCII byte
    string.
    If a comment is given, then it will be preceded by one that identifies
    the file as having been dumped by scikit-learn. Note that not all
    tools grok comments in SVMlight files.

query_id : array-like of shape (n_samples,), default=None
    Array containing pairwise preference constraints (qid in svmlight
    format).

multilabel : bool, default=False
    Samples may have several labels each (see
    https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html).

    .. versionadded:: 0.17
       parameter *multilabel* to support multilabel datasets.
</pre> <div class="fragment"><div class="line"><span class="lineno">  416</span>):</div>
<div class="line"><span class="lineno">  417</span>    <span class="stringliteral">&quot;&quot;&quot;Dump the dataset in svmlight / libsvm file format.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    This format is a text-based format, with one sample per line. It does</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    not store zero valued features hence is suitable for sparse dataset.</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    The first element of each line can be used to store a target variable</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    to predict.</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    X : {array-like, sparse matrix} of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">        Training vectors, where `n_samples` is the number of samples and</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">        `n_features` is the number of features.</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    y : {array-like, sparse matrix}, shape = [n_samples (, n_labels)]</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        Target values. Class labels must be an</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        integer or float, or array-like objects of integer or float for</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        multilabel classifications.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    f : str or file-like in binary mode</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">        If string, specifies the path that will contain the data.</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        If file-like, data will be written to f. f should be opened in binary</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        mode.</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    zero_based : bool, default=True</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        Whether column indices should be written zero-based (True) or one-based</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">        (False).</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    comment : str, default=None</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        Comment to insert at the top of the file. This should be either a</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        Unicode string, which will be encoded as UTF-8, or an ASCII byte</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        string.</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        If a comment is given, then it will be preceded by one that identifies</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        the file as having been dumped by scikit-learn. Note that not all</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        tools grok comments in SVMlight files.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    query_id : array-like of shape (n_samples,), default=None</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">        Array containing pairwise preference constraints (qid in svmlight</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">        format).</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    multilabel : bool, default=False</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">        Samples may have several labels each (see</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html).</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">        .. versionadded:: 0.17</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">           parameter *multilabel* to support multilabel datasets.</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  464</span>    <span class="keywordflow">if</span> comment <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  465</span>        <span class="comment"># Convert comment string to list of lines in UTF-8.</span></div>
<div class="line"><span class="lineno">  466</span>        <span class="comment"># If a byte string is passed, then check whether it&#39;s ASCII;</span></div>
<div class="line"><span class="lineno">  467</span>        <span class="comment"># if a user wants to get fancy, they&#39;ll have to decode themselves.</span></div>
<div class="line"><span class="lineno">  468</span>        <span class="keywordflow">if</span> isinstance(comment, bytes):</div>
<div class="line"><span class="lineno">  469</span>            comment.decode(<span class="stringliteral">&quot;ascii&quot;</span>)  <span class="comment"># just for the exception</span></div>
<div class="line"><span class="lineno">  470</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  471</span>            comment = comment.encode(<span class="stringliteral">&quot;utf-8&quot;</span>)</div>
<div class="line"><span class="lineno">  472</span>        <span class="keywordflow">if</span> b<span class="stringliteral">&quot;\0&quot;</span> <span class="keywordflow">in</span> comment:</div>
<div class="line"><span class="lineno">  473</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;comment string contains NUL byte&quot;</span>)</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span>    yval = check_array(y, accept_sparse=<span class="stringliteral">&quot;csr&quot;</span>, ensure_2d=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">if</span> sp.issparse(yval):</div>
<div class="line"><span class="lineno">  477</span>        <span class="keywordflow">if</span> yval.shape[1] != 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> multilabel:</div>
<div class="line"><span class="lineno">  478</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  479</span>                <span class="stringliteral">&quot;expected y of shape (n_samples, 1), got %r&quot;</span> % (yval.shape,)</div>
<div class="line"><span class="lineno">  480</span>            )</div>
<div class="line"><span class="lineno">  481</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  482</span>        <span class="keywordflow">if</span> yval.ndim != 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> multilabel:</div>
<div class="line"><span class="lineno">  483</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;expected y of shape (n_samples,), got %r&quot;</span> % (yval.shape,))</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span>    Xval = check_array(X, accept_sparse=<span class="stringliteral">&quot;csr&quot;</span>)</div>
<div class="line"><span class="lineno">  486</span>    <span class="keywordflow">if</span> Xval.shape[0] != yval.shape[0]:</div>
<div class="line"><span class="lineno">  487</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  488</span>            <span class="stringliteral">&quot;X.shape[0] and y.shape[0] should be the same, got %r and %r instead.&quot;</span></div>
<div class="line"><span class="lineno">  489</span>            % (Xval.shape[0], yval.shape[0])</div>
<div class="line"><span class="lineno">  490</span>        )</div>
<div class="line"><span class="lineno">  491</span> </div>
<div class="line"><span class="lineno">  492</span>    <span class="comment"># We had some issues with CSR matrices with unsorted indices (e.g. #1501),</span></div>
<div class="line"><span class="lineno">  493</span>    <span class="comment"># so sort them here, but first make sure we don&#39;t modify the user&#39;s X.</span></div>
<div class="line"><span class="lineno">  494</span>    <span class="comment"># TODO We can do this cheaper; sorted_indices copies the whole matrix.</span></div>
<div class="line"><span class="lineno">  495</span>    <span class="keywordflow">if</span> yval <span class="keywordflow">is</span> y <span class="keywordflow">and</span> hasattr(yval, <span class="stringliteral">&quot;sorted_indices&quot;</span>):</div>
<div class="line"><span class="lineno">  496</span>        y = yval.sorted_indices()</div>
<div class="line"><span class="lineno">  497</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  498</span>        y = yval</div>
<div class="line"><span class="lineno">  499</span>        <span class="keywordflow">if</span> hasattr(y, <span class="stringliteral">&quot;sort_indices&quot;</span>):</div>
<div class="line"><span class="lineno">  500</span>            y.sort_indices()</div>
<div class="line"><span class="lineno">  501</span> </div>
<div class="line"><span class="lineno">  502</span>    <span class="keywordflow">if</span> Xval <span class="keywordflow">is</span> X <span class="keywordflow">and</span> hasattr(Xval, <span class="stringliteral">&quot;sorted_indices&quot;</span>):</div>
<div class="line"><span class="lineno">  503</span>        X = Xval.sorted_indices()</div>
<div class="line"><span class="lineno">  504</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  505</span>        X = Xval</div>
<div class="line"><span class="lineno">  506</span>        <span class="keywordflow">if</span> hasattr(X, <span class="stringliteral">&quot;sort_indices&quot;</span>):</div>
<div class="line"><span class="lineno">  507</span>            X.sort_indices()</div>
<div class="line"><span class="lineno">  508</span> </div>
<div class="line"><span class="lineno">  509</span>    <span class="keywordflow">if</span> query_id <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  510</span>        query_id = np.asarray(query_id)</div>
<div class="line"><span class="lineno">  511</span>        <span class="keywordflow">if</span> query_id.shape[0] != y.shape[0]:</div>
<div class="line"><span class="lineno">  512</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  513</span>                <span class="stringliteral">&quot;expected query_id of shape (n_samples,), got %r&quot;</span> % (query_id.shape,)</div>
<div class="line"><span class="lineno">  514</span>            )</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span>    one_based = <span class="keywordflow">not</span> zero_based</div>
<div class="line"><span class="lineno">  517</span> </div>
<div class="line"><span class="lineno">  518</span>    <span class="keywordflow">if</span> hasattr(f, <span class="stringliteral">&quot;write&quot;</span>):</div>
<div class="line"><span class="lineno">  519</span>        _dump_svmlight(X, y, f, multilabel, one_based, comment, query_id)</div>
<div class="line"><span class="lineno">  520</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  521</span>        <span class="keyword">with</span> open(f, <span class="stringliteral">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</div>
<div class="line"><span class="lineno">  522</span>            _dump_svmlight(X, y, f, multilabel, one_based, comment, query_id)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a201930f96f238a51aea6261cfe5ccd6b" name="a201930f96f238a51aea6261cfe5ccd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201930f96f238a51aea6261cfe5ccd6b">&#9670;&#160;</a></span>load_svmlight_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.datasets._svmlight_format_io.load_svmlight_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>n_features</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>np.float64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multilabel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zero_based</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query_id</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load datasets in the svmlight / libsvm format into sparse CSR matrix.

This format is a text-based format, with one sample per line. It does
not store zero valued features hence is suitable for sparse dataset.

The first element of each line can be used to store a target variable
to predict.

This format is used as the default format for both svmlight and the
libsvm command line programs.

Parsing a text based source can be expensive. When repeatedly
working on the same dataset, it is recommended to wrap this
loader with joblib.Memory.cache to store a memmapped backup of the
CSR results of the first call and benefit from the near instantaneous
loading of memmapped structures for the subsequent calls.

In case the file contains a pairwise preference constraint (known
as "qid" in the svmlight format) these are ignored unless the
query_id parameter is set to True. These pairwise preference
constraints can be used to constraint the combination of samples
when using pairwise loss functions (as is the case in some
learning to rank problems) so that only pairs with the same
query_id value are considered.

This implementation is written in Cython and is reasonably fast.
However, a faster API-compatible loader is also available at:

  https://github.com/mblondel/svmlight-loader

Parameters
----------
f : str, path-like, file-like or int
    (Path to) a file to load. If a path ends in ".gz" or ".bz2", it will
    be uncompressed on the fly. If an integer is passed, it is assumed to
    be a file descriptor. A file-like or file descriptor will not be closed
    by this function. A file-like object must be opened in binary mode.

    .. versionchanged:: 1.2
       Path-like objects are now accepted.

n_features : int, default=None
    The number of features to use. If None, it will be inferred. This
    argument is useful to load several files that are subsets of a
    bigger sliced dataset: each subset might not have examples of
    every feature, hence the inferred shape might vary from one
    slice to another.
    n_features is only required if ``offset`` or ``length`` are passed a
    non-default value.

dtype : numpy data type, default=np.float64
    Data type of dataset to be loaded. This will be the data type of the
    output numpy arrays ``X`` and ``y``.

multilabel : bool, default=False
    Samples may have several labels each (see
    https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html).

zero_based : bool or "auto", default="auto"
    Whether column indices in f are zero-based (True) or one-based
    (False). If column indices are one-based, they are transformed to
    zero-based to match Python/NumPy conventions.
    If set to "auto", a heuristic check is applied to determine this from
    the file contents. Both kinds of files occur "in the wild", but they
    are unfortunately not self-identifying. Using "auto" or True should
    always be safe when no ``offset`` or ``length`` is passed.
    If ``offset`` or ``length`` are passed, the "auto" mode falls back
    to ``zero_based=True`` to avoid having the heuristic check yield
    inconsistent results on different segments of the file.

query_id : bool, default=False
    If True, will return the query_id array for each file.

offset : int, default=0
    Ignore the offset first bytes by seeking forward, then
    discarding the following bytes up until the next new line
    character.

length : int, default=-1
    If strictly positive, stop reading any new line of data once the
    position in the file has reached the (offset + length) bytes threshold.

Returns
-------
X : scipy.sparse matrix of shape (n_samples, n_features)
    The data matrix.

y : ndarray of shape (n_samples,), or a list of tuples of length n_samples
    The target. It is a list of tuples when ``multilabel=True``, else a
    ndarray.

query_id : array of shape (n_samples,)
   The query_id for each sample. Only returned when query_id is set to
   True.

See Also
--------
load_svmlight_files : Similar function for loading multiple files in this
    format, enforcing the same number of features/columns on all of them.

Examples
--------
To use joblib.Memory to cache the svmlight file::

    from joblib import Memory
    from .datasets import load_svmlight_file
    mem = Memory("./mycache")

    @mem.cache
    def get_data():
        data = load_svmlight_file("mysvmlightfile")
        return data[0], data[1]

    X, y = get_data()
</pre> <div class="fragment"><div class="line"><span class="lineno">   55</span>):</div>
<div class="line"><span class="lineno">   56</span>    <span class="stringliteral">&quot;&quot;&quot;Load datasets in the svmlight / libsvm format into sparse CSR matrix.</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    This format is a text-based format, with one sample per line. It does</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    not store zero valued features hence is suitable for sparse dataset.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    The first element of each line can be used to store a target variable</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    to predict.</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    This format is used as the default format for both svmlight and the</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    libsvm command line programs.</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    Parsing a text based source can be expensive. When repeatedly</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    working on the same dataset, it is recommended to wrap this</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    loader with joblib.Memory.cache to store a memmapped backup of the</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    CSR results of the first call and benefit from the near instantaneous</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">    loading of memmapped structures for the subsequent calls.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    In case the file contains a pairwise preference constraint (known</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    as &quot;qid&quot; in the svmlight format) these are ignored unless the</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    query_id parameter is set to True. These pairwise preference</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    constraints can be used to constraint the combination of samples</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    when using pairwise loss functions (as is the case in some</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    learning to rank problems) so that only pairs with the same</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    query_id value are considered.</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    This implementation is written in Cython and is reasonably fast.</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    However, a faster API-compatible loader is also available at:</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">      https://github.com/mblondel/svmlight-loader</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    f : str, path-like, file-like or int</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        (Path to) a file to load. If a path ends in &quot;.gz&quot; or &quot;.bz2&quot;, it will</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        be uncompressed on the fly. If an integer is passed, it is assumed to</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        be a file descriptor. A file-like or file descriptor will not be closed</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        by this function. A file-like object must be opened in binary mode.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        .. versionchanged:: 1.2</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">           Path-like objects are now accepted.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    n_features : int, default=None</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        The number of features to use. If None, it will be inferred. This</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">        argument is useful to load several files that are subsets of a</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        bigger sliced dataset: each subset might not have examples of</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        every feature, hence the inferred shape might vary from one</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        slice to another.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        n_features is only required if ``offset`` or ``length`` are passed a</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        non-default value.</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    dtype : numpy data type, default=np.float64</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        Data type of dataset to be loaded. This will be the data type of the</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        output numpy arrays ``X`` and ``y``.</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    multilabel : bool, default=False</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        Samples may have several labels each (see</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html).</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    zero_based : bool or &quot;auto&quot;, default=&quot;auto&quot;</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        Whether column indices in f are zero-based (True) or one-based</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">        (False). If column indices are one-based, they are transformed to</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">        zero-based to match Python/NumPy conventions.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        If set to &quot;auto&quot;, a heuristic check is applied to determine this from</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        the file contents. Both kinds of files occur &quot;in the wild&quot;, but they</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        are unfortunately not self-identifying. Using &quot;auto&quot; or True should</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">        always be safe when no ``offset`` or ``length`` is passed.</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        If ``offset`` or ``length`` are passed, the &quot;auto&quot; mode falls back</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">        to ``zero_based=True`` to avoid having the heuristic check yield</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">        inconsistent results on different segments of the file.</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    query_id : bool, default=False</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        If True, will return the query_id array for each file.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    offset : int, default=0</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">        Ignore the offset first bytes by seeking forward, then</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        discarding the following bytes up until the next new line</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">        character.</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    length : int, default=-1</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">        If strictly positive, stop reading any new line of data once the</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        position in the file has reached the (offset + length) bytes threshold.</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    X : scipy.sparse matrix of shape (n_samples, n_features)</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        The data matrix.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    y : ndarray of shape (n_samples,), or a list of tuples of length n_samples</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        The target. It is a list of tuples when ``multilabel=True``, else a</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">        ndarray.</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    query_id : array of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">       The query_id for each sample. Only returned when query_id is set to</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">       True.</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    load_svmlight_files : Similar function for loading multiple files in this</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        format, enforcing the same number of features/columns on all of them.</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    To use joblib.Memory to cache the svmlight file::</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        from joblib import Memory</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        from .datasets import load_svmlight_file</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        mem = Memory(&quot;./mycache&quot;)</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">        @mem.cache</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        def get_data():</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">            data = load_svmlight_file(&quot;mysvmlightfile&quot;)</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">            return data[0], data[1]</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">        X, y = get_data()</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  171</span>    <span class="keywordflow">return</span> tuple(</div>
<div class="line"><span class="lineno">  172</span>        load_svmlight_files(</div>
<div class="line"><span class="lineno">  173</span>            [f],</div>
<div class="line"><span class="lineno">  174</span>            n_features=n_features,</div>
<div class="line"><span class="lineno">  175</span>            dtype=dtype,</div>
<div class="line"><span class="lineno">  176</span>            multilabel=multilabel,</div>
<div class="line"><span class="lineno">  177</span>            zero_based=zero_based,</div>
<div class="line"><span class="lineno">  178</span>            query_id=query_id,</div>
<div class="line"><span class="lineno">  179</span>            offset=offset,</div>
<div class="line"><span class="lineno">  180</span>            length=length,</div>
<div class="line"><span class="lineno">  181</span>        )</div>
<div class="line"><span class="lineno">  182</span>    )</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9faffdf6bbe6e455caefa3b15e3eb167" name="a9faffdf6bbe6e455caefa3b15e3eb167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faffdf6bbe6e455caefa3b15e3eb167">&#9670;&#160;</a></span>load_svmlight_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.datasets._svmlight_format_io.load_svmlight_files </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>n_features</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>np.float64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multilabel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zero_based</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>query_id</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load dataset from multiple files in SVMlight format.

This function is equivalent to mapping load_svmlight_file over a list of
files, except that the results are concatenated into a single, flat list
and the samples vectors are constrained to all have the same number of
features.

In case the file contains a pairwise preference constraint (known
as "qid" in the svmlight format) these are ignored unless the
query_id parameter is set to True. These pairwise preference
constraints can be used to constraint the combination of samples
when using pairwise loss functions (as is the case in some
learning to rank problems) so that only pairs with the same
query_id value are considered.

Parameters
----------
files : array-like, dtype=str, path-like, file-like or int
    (Paths of) files to load. If a path ends in ".gz" or ".bz2", it will
    be uncompressed on the fly. If an integer is passed, it is assumed to
    be a file descriptor. File-likes and file descriptors will not be
    closed by this function. File-like objects must be opened in binary
    mode.

    .. versionchanged:: 1.2
       Path-like objects are now accepted.

n_features : int, default=None
    The number of features to use. If None, it will be inferred from the
    maximum column index occurring in any of the files.

    This can be set to a higher value than the actual number of features
    in any of the input files, but setting it to a lower value will cause
    an exception to be raised.

dtype : numpy data type, default=np.float64
    Data type of dataset to be loaded. This will be the data type of the
    output numpy arrays ``X`` and ``y``.

multilabel : bool, default=False
    Samples may have several labels each (see
    https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html).

zero_based : bool or "auto", default="auto"
    Whether column indices in f are zero-based (True) or one-based
    (False). If column indices are one-based, they are transformed to
    zero-based to match Python/NumPy conventions.
    If set to "auto", a heuristic check is applied to determine this from
    the file contents. Both kinds of files occur "in the wild", but they
    are unfortunately not self-identifying. Using "auto" or True should
    always be safe when no offset or length is passed.
    If offset or length are passed, the "auto" mode falls back
    to zero_based=True to avoid having the heuristic check yield
    inconsistent results on different segments of the file.

query_id : bool, default=False
    If True, will return the query_id array for each file.

offset : int, default=0
    Ignore the offset first bytes by seeking forward, then
    discarding the following bytes up until the next new line
    character.

length : int, default=-1
    If strictly positive, stop reading any new line of data once the
    position in the file has reached the (offset + length) bytes threshold.

Returns
-------
[X1, y1, ..., Xn, yn] or [X1, y1, q1, ..., Xn, yn, qn]: list of arrays
    Each (Xi, yi) pair is the result from load_svmlight_file(files[i]).
    If query_id is set to True, this will return instead (Xi, yi, qi)
    triplets.

See Also
--------
load_svmlight_file: Similar function for loading a single file in this
    format.

Notes
-----
When fitting a model to a matrix X_train and evaluating it against a
matrix X_test, it is essential that X_train and X_test have the same
number of features (X_train.shape[1] == X_test.shape[1]). This may not
be the case if you load the files individually with load_svmlight_file.
</pre> <div class="fragment"><div class="line"><span class="lineno">  239</span>):</div>
<div class="line"><span class="lineno">  240</span>    <span class="stringliteral">&quot;&quot;&quot;Load dataset from multiple files in SVMlight format.</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    This function is equivalent to mapping load_svmlight_file over a list of</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    files, except that the results are concatenated into a single, flat list</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    and the samples vectors are constrained to all have the same number of</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    features.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    In case the file contains a pairwise preference constraint (known</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    as &quot;qid&quot; in the svmlight format) these are ignored unless the</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    query_id parameter is set to True. These pairwise preference</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    constraints can be used to constraint the combination of samples</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    when using pairwise loss functions (as is the case in some</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    learning to rank problems) so that only pairs with the same</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    query_id value are considered.</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    files : array-like, dtype=str, path-like, file-like or int</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">        (Paths of) files to load. If a path ends in &quot;.gz&quot; or &quot;.bz2&quot;, it will</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        be uncompressed on the fly. If an integer is passed, it is assumed to</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        be a file descriptor. File-likes and file descriptors will not be</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        closed by this function. File-like objects must be opened in binary</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">        mode.</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">        .. versionchanged:: 1.2</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">           Path-like objects are now accepted.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    n_features : int, default=None</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        The number of features to use. If None, it will be inferred from the</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">        maximum column index occurring in any of the files.</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        This can be set to a higher value than the actual number of features</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        in any of the input files, but setting it to a lower value will cause</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">        an exception to be raised.</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    dtype : numpy data type, default=np.float64</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        Data type of dataset to be loaded. This will be the data type of the</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        output numpy arrays ``X`` and ``y``.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    multilabel : bool, default=False</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        Samples may have several labels each (see</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html).</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    zero_based : bool or &quot;auto&quot;, default=&quot;auto&quot;</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        Whether column indices in f are zero-based (True) or one-based</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        (False). If column indices are one-based, they are transformed to</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        zero-based to match Python/NumPy conventions.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">        If set to &quot;auto&quot;, a heuristic check is applied to determine this from</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        the file contents. Both kinds of files occur &quot;in the wild&quot;, but they</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">        are unfortunately not self-identifying. Using &quot;auto&quot; or True should</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">        always be safe when no offset or length is passed.</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        If offset or length are passed, the &quot;auto&quot; mode falls back</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        to zero_based=True to avoid having the heuristic check yield</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        inconsistent results on different segments of the file.</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    query_id : bool, default=False</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        If True, will return the query_id array for each file.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    offset : int, default=0</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        Ignore the offset first bytes by seeking forward, then</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        discarding the following bytes up until the next new line</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        character.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    length : int, default=-1</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        If strictly positive, stop reading any new line of data once the</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        position in the file has reached the (offset + length) bytes threshold.</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    [X1, y1, ..., Xn, yn] or [X1, y1, q1, ..., Xn, yn, qn]: list of arrays</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        Each (Xi, yi) pair is the result from load_svmlight_file(files[i]).</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        If query_id is set to True, this will return instead (Xi, yi, qi)</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        triplets.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    load_svmlight_file: Similar function for loading a single file in this</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        format.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    When fitting a model to a matrix X_train and evaluating it against a</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    matrix X_test, it is essential that X_train and X_test have the same</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    number of features (X_train.shape[1] == X_test.shape[1]). This may not</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    be the case if you load the files individually with load_svmlight_file.</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  326</span>    <span class="keywordflow">if</span> (offset != 0 <span class="keywordflow">or</span> length &gt; 0) <span class="keywordflow">and</span> zero_based == <span class="stringliteral">&quot;auto&quot;</span>:</div>
<div class="line"><span class="lineno">  327</span>        <span class="comment"># disable heuristic search to avoid getting inconsistent results on</span></div>
<div class="line"><span class="lineno">  328</span>        <span class="comment"># different segments of the file</span></div>
<div class="line"><span class="lineno">  329</span>        zero_based = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  330</span> </div>
<div class="line"><span class="lineno">  331</span>    <span class="keywordflow">if</span> (offset != 0 <span class="keywordflow">or</span> length &gt; 0) <span class="keywordflow">and</span> n_features <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  332</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;n_features is required when offset or length is specified.&quot;</span>)</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>    r = [</div>
<div class="line"><span class="lineno">  335</span>        _open_and_load(</div>
<div class="line"><span class="lineno">  336</span>            f,</div>
<div class="line"><span class="lineno">  337</span>            dtype,</div>
<div class="line"><span class="lineno">  338</span>            multilabel,</div>
<div class="line"><span class="lineno">  339</span>            bool(zero_based),</div>
<div class="line"><span class="lineno">  340</span>            bool(query_id),</div>
<div class="line"><span class="lineno">  341</span>            offset=offset,</div>
<div class="line"><span class="lineno">  342</span>            length=length,</div>
<div class="line"><span class="lineno">  343</span>        )</div>
<div class="line"><span class="lineno">  344</span>        <span class="keywordflow">for</span> f <span class="keywordflow">in</span> files</div>
<div class="line"><span class="lineno">  345</span>    ]</div>
<div class="line"><span class="lineno">  346</span> </div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  348</span>        zero_based <span class="keywordflow">is</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  349</span>        <span class="keywordflow">or</span> zero_based == <span class="stringliteral">&quot;auto&quot;</span></div>
<div class="line"><span class="lineno">  350</span>        <span class="keywordflow">and</span> all(len(tmp[1]) <span class="keywordflow">and</span> np.min(tmp[1]) &gt; 0 <span class="keywordflow">for</span> tmp <span class="keywordflow">in</span> r)</div>
<div class="line"><span class="lineno">  351</span>    ):</div>
<div class="line"><span class="lineno">  352</span>        <span class="keywordflow">for</span> _, indices, _, _, _ <span class="keywordflow">in</span> r:</div>
<div class="line"><span class="lineno">  353</span>            indices -= 1</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>    n_f = max(ind[1].max() <span class="keywordflow">if</span> len(ind[1]) <span class="keywordflow">else</span> 0 <span class="keywordflow">for</span> ind <span class="keywordflow">in</span> r) + 1</div>
<div class="line"><span class="lineno">  356</span> </div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">if</span> n_features <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  358</span>        n_features = n_f</div>
<div class="line"><span class="lineno">  359</span>    <span class="keywordflow">elif</span> n_features &lt; n_f:</div>
<div class="line"><span class="lineno">  360</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  361</span>            <span class="stringliteral">&quot;n_features was set to {}, but input file contains {} features&quot;</span>.format(</div>
<div class="line"><span class="lineno">  362</span>                n_features, n_f</div>
<div class="line"><span class="lineno">  363</span>            )</div>
<div class="line"><span class="lineno">  364</span>        )</div>
<div class="line"><span class="lineno">  365</span> </div>
<div class="line"><span class="lineno">  366</span>    result = []</div>
<div class="line"><span class="lineno">  367</span>    <span class="keywordflow">for</span> data, indices, indptr, y, query_values <span class="keywordflow">in</span> r:</div>
<div class="line"><span class="lineno">  368</span>        shape = (indptr.shape[0] - 1, n_features)</div>
<div class="line"><span class="lineno">  369</span>        X = sp.csr_matrix((data, indices, indptr), shape)</div>
<div class="line"><span class="lineno">  370</span>        X.sort_indices()</div>
<div class="line"><span class="lineno">  371</span>        result += X, y</div>
<div class="line"><span class="lineno">  372</span>        <span class="keywordflow">if</span> query_id:</div>
<div class="line"><span class="lineno">  373</span>            result.append(query_values)</div>
<div class="line"><span class="lineno">  374</span> </div>
<div class="line"><span class="lineno">  375</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
