<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.core.tests.test_casting_unittests.TestCasting Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1tests.html">tests</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1tests_1_1test__casting__unittests.html">test_casting_unittests</a></li><li class="navelem"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html">TestCasting</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">numpy.core.tests.test_casting_unittests.TestCasting Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88b3143942e9f01f69e9cf4529ed1c5f" id="r_a88b3143942e9f01f69e9cf4529ed1c5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a88b3143942e9f01f69e9cf4529ed1c5f">get_data</a> (self, dtype1, dtype2)</td></tr>
<tr class="separator:a88b3143942e9f01f69e9cf4529ed1c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa77f6716d638680f4669bf7c167767" id="r_a1aa77f6716d638680f4669bf7c167767"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a1aa77f6716d638680f4669bf7c167767">get_data_variation</a> (self, arr1, arr2, aligned=True, contig=True)</td></tr>
<tr class="separator:a1aa77f6716d638680f4669bf7c167767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeecf0057ab35955d42b65614841247" id="r_abfeecf0057ab35955d42b65614841247"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#abfeecf0057ab35955d42b65614841247">test_simple_cancast</a> (self, from_Dt)</td></tr>
<tr class="separator:abfeecf0057ab35955d42b65614841247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27361215fe10f56be28d1ee51bb65002" id="r_a27361215fe10f56be28d1ee51bb65002"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a27361215fe10f56be28d1ee51bb65002">test_simple_direct_casts</a> (self, <a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a931ad95ca9c8ceb0138fc57c6ab95051">from_dt</a>)</td></tr>
<tr class="separator:a27361215fe10f56be28d1ee51bb65002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abfaba5133bdf1a0f824b0500559eff" id="r_a8abfaba5133bdf1a0f824b0500559eff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a8abfaba5133bdf1a0f824b0500559eff">test_numeric_to_times</a> (self, from_Dt)</td></tr>
<tr class="separator:a8abfaba5133bdf1a0f824b0500559eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6ca1ff7a23358e5dc1f837d320ed2c" id="r_a3d6ca1ff7a23358e5dc1f837d320ed2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a3d6ca1ff7a23358e5dc1f837d320ed2c">test_time_to_time</a> (self, <a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a931ad95ca9c8ceb0138fc57c6ab95051">from_dt</a>, <a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a504bb21474ec2fd02e0c553d7be86c4b">to_dt</a>, expected_casting, expected_view_off, nom, denom)</td></tr>
<tr class="separator:a3d6ca1ff7a23358e5dc1f837d320ed2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42237a3d8ba1a589c6901453baf4ca9" id="r_ab42237a3d8ba1a589c6901453baf4ca9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#ab42237a3d8ba1a589c6901453baf4ca9">string_with_modified_length</a> (self, dtype, change_length)</td></tr>
<tr class="separator:ab42237a3d8ba1a589c6901453baf4ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80417d647907e5e05a93624523a797b3" id="r_a80417d647907e5e05a93624523a797b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a80417d647907e5e05a93624523a797b3">test_string_cancast</a> (self, other_DT, string_char)</td></tr>
<tr class="separator:a80417d647907e5e05a93624523a797b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef56d707bcc0eba3d9a051ca3714b8" id="r_ae4ef56d707bcc0eba3d9a051ca3714b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#ae4ef56d707bcc0eba3d9a051ca3714b8">test_simple_string_casts_roundtrip</a> (self, other_dt, string_char)</td></tr>
<tr class="separator:ae4ef56d707bcc0eba3d9a051ca3714b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdcb07222c3f64d4b21871ee81d2929" id="r_a4fdcb07222c3f64d4b21871ee81d2929"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a4fdcb07222c3f64d4b21871ee81d2929">test_string_to_string_cancast</a> (self, other_dt, string_char)</td></tr>
<tr class="separator:a4fdcb07222c3f64d4b21871ee81d2929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02281ad2110a80dd0b8b5d36e38b4b2b" id="r_a02281ad2110a80dd0b8b5d36e38b4b2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a02281ad2110a80dd0b8b5d36e38b4b2b">test_unicode_byteswapped_cast</a> (self, order1, order2)</td></tr>
<tr class="separator:a02281ad2110a80dd0b8b5d36e38b4b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8f21d19bb93f98052d94e9ff304b51" id="r_afa8f21d19bb93f98052d94e9ff304b51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#afa8f21d19bb93f98052d94e9ff304b51">test_void_to_string_special_case</a> (self)</td></tr>
<tr class="separator:afa8f21d19bb93f98052d94e9ff304b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bd86ab67b72557f658b0ad2d769e4e" id="r_ae8bd86ab67b72557f658b0ad2d769e4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#ae8bd86ab67b72557f658b0ad2d769e4e">test_object_to_parametric_internal_error</a> (self)</td></tr>
<tr class="separator:ae8bd86ab67b72557f658b0ad2d769e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acef0dd3b06a5da8d41132e95fbb38f" id="r_a2acef0dd3b06a5da8d41132e95fbb38f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a2acef0dd3b06a5da8d41132e95fbb38f">test_object_and_simple_resolution</a> (self, dtype)</td></tr>
<tr class="separator:a2acef0dd3b06a5da8d41132e95fbb38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f3d9aac2c94e371c03bc4e9aa412a2" id="r_a85f3d9aac2c94e371c03bc4e9aa412a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a85f3d9aac2c94e371c03bc4e9aa412a2">test_simple_to_object_resolution</a> (self, dtype)</td></tr>
<tr class="separator:a85f3d9aac2c94e371c03bc4e9aa412a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ef9039f0273c38861b7006530b4774" id="r_a84ef9039f0273c38861b7006530b4774"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a84ef9039f0273c38861b7006530b4774">test_void_and_structured_with_subarray</a> (self, casting)</td></tr>
<tr class="separator:a84ef9039f0273c38861b7006530b4774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ad0ae6e934cd25cddb2828311f27e3" id="r_a28ad0ae6e934cd25cddb2828311f27e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a28ad0ae6e934cd25cddb2828311f27e3">test_structured_field_offsets</a> (self, <a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a504bb21474ec2fd02e0c553d7be86c4b">to_dt</a>, expected_off)</td></tr>
<tr class="separator:a28ad0ae6e934cd25cddb2828311f27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1906272c9804b82ee09fc8263315e4b2" id="r_a1906272c9804b82ee09fc8263315e4b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a1906272c9804b82ee09fc8263315e4b2">test_object_casts_NULL_None_equivalence</a> (self, dtype)</td></tr>
<tr class="separator:a1906272c9804b82ee09fc8263315e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103ab1c83f4e77b1b3d9df7000414f00" id="r_a103ab1c83f4e77b1b3d9df7000414f00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a103ab1c83f4e77b1b3d9df7000414f00">test_nonstandard_bool_to_other</a> (self, dtype)</td></tr>
<tr class="separator:a103ab1c83f4e77b1b3d9df7000414f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af7017d6f18f4694804ed44147414db69" id="r_af7017d6f18f4694804ed44147414db69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#af7017d6f18f4694804ed44147414db69">size</a> = 1500</td></tr>
<tr class="separator:af7017d6f18f4694804ed44147414db69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931ad95ca9c8ceb0138fc57c6ab95051" id="r_a931ad95ca9c8ceb0138fc57c6ab95051"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a931ad95ca9c8ceb0138fc57c6ab95051">from_dt</a> = np.dtype(from_dt)</td></tr>
<tr class="separator:a931ad95ca9c8ceb0138fc57c6ab95051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504bb21474ec2fd02e0c553d7be86c4b" id="r_a504bb21474ec2fd02e0c553d7be86c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a504bb21474ec2fd02e0c553d7be86c4b">to_dt</a> = np.dtype(to_dt)</td></tr>
<tr class="separator:a504bb21474ec2fd02e0c553d7be86c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc48638ce62033d6695d26f453631f4" id="r_a1fc48638ce62033d6695d26f453631f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a1fc48638ce62033d6695d26f453631f4">cast</a> = get_castingimpl(type(<a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a931ad95ca9c8ceb0138fc57c6ab95051">from_dt</a>), type(<a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a504bb21474ec2fd02e0c553d7be86c4b">to_dt</a>))</td></tr>
<tr class="separator:a1fc48638ce62033d6695d26f453631f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df0f5dd70447f7a957d18186a1695ff" id="r_a4df0f5dd70447f7a957d18186a1695ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a4df0f5dd70447f7a957d18186a1695ff">view_off</a></td></tr>
<tr class="separator:a4df0f5dd70447f7a957d18186a1695ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aeb80b346a4e5648c3099ba62e92aa4d8" id="r_aeb80b346a4e5648c3099ba62e92aa4d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#aeb80b346a4e5648c3099ba62e92aa4d8">_</a></td></tr>
<tr class="separator:aeb80b346a4e5648c3099ba62e92aa4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88b3143942e9f01f69e9cf4529ed1c5f" name="a88b3143942e9f01f69e9cf4529ed1c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b3143942e9f01f69e9cf4529ed1c5f">&#9670;&#160;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.get_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  157</span>    <span class="keyword">def </span>get_data(self, dtype1, dtype2):</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">if</span> dtype2 <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> dtype1.itemsize &gt;= dtype2.itemsize:</div>
<div class="line"><span class="lineno">  159</span>            length = self.size // dtype1.itemsize</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  161</span>            length = self.size // dtype2.itemsize</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>        <span class="comment"># Assume that the base array is well enough aligned for all inputs.</span></div>
<div class="line"><span class="lineno">  164</span>        arr1 = np.empty(length, dtype=dtype1)</div>
<div class="line"><span class="lineno">  165</span>        <span class="keyword">assert</span> arr1.flags.c_contiguous</div>
<div class="line"><span class="lineno">  166</span>        <span class="keyword">assert</span> arr1.flags.aligned</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span>        values = [random.randrange(-128, 128) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(length)]</div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordflow">for</span> i, value <span class="keywordflow">in</span> enumerate(values):</div>
<div class="line"><span class="lineno">  171</span>            <span class="comment"># Use item assignment to ensure this is not using casting:</span></div>
<div class="line"><span class="lineno">  172</span>            <span class="keywordflow">if</span> value &lt; 0 <span class="keywordflow">and</span> dtype1.kind == <span class="stringliteral">&quot;u&quot;</span>:</div>
<div class="line"><span class="lineno">  173</span>                <span class="comment"># Manually rollover unsigned integers (-1 -&gt; int.max)</span></div>
<div class="line"><span class="lineno">  174</span>                value = value + np.iinfo(dtype1).max + 1</div>
<div class="line"><span class="lineno">  175</span>            arr1[i] = value</div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">if</span> dtype2 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  178</span>            <span class="keywordflow">if</span> dtype1.char == <span class="stringliteral">&quot;?&quot;</span>:</div>
<div class="line"><span class="lineno">  179</span>                values = [bool(v) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> values]</div>
<div class="line"><span class="lineno">  180</span>            <span class="keywordflow">return</span> arr1, values</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>        <span class="keywordflow">if</span> dtype2.char == <span class="stringliteral">&quot;?&quot;</span>:</div>
<div class="line"><span class="lineno">  183</span>            values = [bool(v) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> values]</div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span>        arr2 = np.empty(length, dtype=dtype2)</div>
<div class="line"><span class="lineno">  186</span>        <span class="keyword">assert</span> arr2.flags.c_contiguous</div>
<div class="line"><span class="lineno">  187</span>        <span class="keyword">assert</span> arr2.flags.aligned</div>
<div class="line"><span class="lineno">  188</span> </div>
<div class="line"><span class="lineno">  189</span>        <span class="keywordflow">for</span> i, value <span class="keywordflow">in</span> enumerate(values):</div>
<div class="line"><span class="lineno">  190</span>            <span class="comment"># Use item assignment to ensure this is not using casting:</span></div>
<div class="line"><span class="lineno">  191</span>            <span class="keywordflow">if</span> value &lt; 0 <span class="keywordflow">and</span> dtype2.kind == <span class="stringliteral">&quot;u&quot;</span>:</div>
<div class="line"><span class="lineno">  192</span>                <span class="comment"># Manually rollover unsigned integers (-1 -&gt; int.max)</span></div>
<div class="line"><span class="lineno">  193</span>                value = value + np.iinfo(dtype2).max + 1</div>
<div class="line"><span class="lineno">  194</span>            arr2[i] = value</div>
<div class="line"><span class="lineno">  195</span> </div>
<div class="line"><span class="lineno">  196</span>        <span class="keywordflow">return</span> arr1, arr2, values</div>
<div class="line"><span class="lineno">  197</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1aa77f6716d638680f4669bf7c167767" name="a1aa77f6716d638680f4669bf7c167767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa77f6716d638680f4669bf7c167767">&#9670;&#160;</a></span>get_data_variation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.get_data_variation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aligned</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contig</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a copy of arr1 that may be non-contiguous or unaligned, and a
matching array for arr2 (although not a copy).
</pre> <div class="fragment"><div class="line"><span class="lineno">  198</span>    <span class="keyword">def </span>get_data_variation(self, arr1, arr2, aligned=True, contig=True):</div>
<div class="line"><span class="lineno">  199</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        Returns a copy of arr1 that may be non-contiguous or unaligned, and a</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        matching array for arr2 (although not a copy).</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  203</span>        <span class="keywordflow">if</span> contig:</div>
<div class="line"><span class="lineno">  204</span>            stride1 = arr1.dtype.itemsize</div>
<div class="line"><span class="lineno">  205</span>            stride2 = arr2.dtype.itemsize</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">elif</span> aligned:</div>
<div class="line"><span class="lineno">  207</span>            stride1 = 2 * arr1.dtype.itemsize</div>
<div class="line"><span class="lineno">  208</span>            stride2 = 2 * arr2.dtype.itemsize</div>
<div class="line"><span class="lineno">  209</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  210</span>            stride1 = arr1.dtype.itemsize + 1</div>
<div class="line"><span class="lineno">  211</span>            stride2 = arr2.dtype.itemsize + 1</div>
<div class="line"><span class="lineno">  212</span> </div>
<div class="line"><span class="lineno">  213</span>        max_size1 = len(arr1) * 3 * arr1.dtype.itemsize + 1</div>
<div class="line"><span class="lineno">  214</span>        max_size2 = len(arr2) * 3 * arr2.dtype.itemsize + 1</div>
<div class="line"><span class="lineno">  215</span>        from_bytes = np.zeros(max_size1, dtype=np.uint8)</div>
<div class="line"><span class="lineno">  216</span>        to_bytes = np.zeros(max_size2, dtype=np.uint8)</div>
<div class="line"><span class="lineno">  217</span> </div>
<div class="line"><span class="lineno">  218</span>        <span class="comment"># Sanity check that the above is large enough:</span></div>
<div class="line"><span class="lineno">  219</span>        <span class="keyword">assert</span> stride1 * len(arr1) &lt;= from_bytes.nbytes</div>
<div class="line"><span class="lineno">  220</span>        <span class="keyword">assert</span> stride2 * len(arr2) &lt;= to_bytes.nbytes</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span>        <span class="keywordflow">if</span> aligned:</div>
<div class="line"><span class="lineno">  223</span>            new1 = as_strided(from_bytes[:-1].view(arr1.dtype),</div>
<div class="line"><span class="lineno">  224</span>                              arr1.shape, (stride1,))</div>
<div class="line"><span class="lineno">  225</span>            new2 = as_strided(to_bytes[:-1].view(arr2.dtype),</div>
<div class="line"><span class="lineno">  226</span>                              arr2.shape, (stride2,))</div>
<div class="line"><span class="lineno">  227</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  228</span>            new1 = as_strided(from_bytes[1:].view(arr1.dtype),</div>
<div class="line"><span class="lineno">  229</span>                              arr1.shape, (stride1,))</div>
<div class="line"><span class="lineno">  230</span>            new2 = as_strided(to_bytes[1:].view(arr2.dtype),</div>
<div class="line"><span class="lineno">  231</span>                              arr2.shape, (stride2,))</div>
<div class="line"><span class="lineno">  232</span> </div>
<div class="line"><span class="lineno">  233</span>        new1[...] = arr1</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> contig:</div>
<div class="line"><span class="lineno">  236</span>            <span class="comment"># Ensure we did not overwrite bytes that should not be written:</span></div>
<div class="line"><span class="lineno">  237</span>            offset = arr1.dtype.itemsize <span class="keywordflow">if</span> aligned <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno">  238</span>            buf = from_bytes[offset::stride1].tobytes()</div>
<div class="line"><span class="lineno">  239</span>            <span class="keyword">assert</span> buf.count(b<span class="stringliteral">&quot;\0&quot;</span>) == len(buf)</div>
<div class="line"><span class="lineno">  240</span> </div>
<div class="line"><span class="lineno">  241</span>        <span class="keywordflow">if</span> contig:</div>
<div class="line"><span class="lineno">  242</span>            <span class="keyword">assert</span> new1.flags.c_contiguous</div>
<div class="line"><span class="lineno">  243</span>            <span class="keyword">assert</span> new2.flags.c_contiguous</div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  245</span>            <span class="keyword">assert</span> <span class="keywordflow">not</span> new1.flags.c_contiguous</div>
<div class="line"><span class="lineno">  246</span>            <span class="keyword">assert</span> <span class="keywordflow">not</span> new2.flags.c_contiguous</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span>        <span class="keywordflow">if</span> aligned:</div>
<div class="line"><span class="lineno">  249</span>            <span class="keyword">assert</span> new1.flags.aligned</div>
<div class="line"><span class="lineno">  250</span>            <span class="keyword">assert</span> new2.flags.aligned</div>
<div class="line"><span class="lineno">  251</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  252</span>            <span class="keyword">assert</span> <span class="keywordflow">not</span> new1.flags.aligned <span class="keywordflow">or</span> new1.dtype.alignment == 1</div>
<div class="line"><span class="lineno">  253</span>            <span class="keyword">assert</span> <span class="keywordflow">not</span> new2.flags.aligned <span class="keywordflow">or</span> new2.dtype.alignment == 1</div>
<div class="line"><span class="lineno">  254</span> </div>
<div class="line"><span class="lineno">  255</span>        <span class="keywordflow">return</span> new1, new2</div>
<div class="line"><span class="lineno">  256</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab42237a3d8ba1a589c6901453baf4ca9" name="ab42237a3d8ba1a589c6901453baf4ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42237a3d8ba1a589c6901453baf4ca9">&#9670;&#160;</a></span>string_with_modified_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.string_with_modified_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>change_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  477</span>    <span class="keyword">def </span>string_with_modified_length(self, dtype, change_length):</div>
<div class="line"><span class="lineno">  478</span>        fact = 1 <span class="keywordflow">if</span> dtype.char == <span class="stringliteral">&quot;S&quot;</span> <span class="keywordflow">else</span> 4</div>
<div class="line"><span class="lineno">  479</span>        length = dtype.itemsize // fact + change_length</div>
<div class="line"><span class="lineno">  480</span>        <span class="keywordflow">return</span> np.dtype(f<span class="stringliteral">&quot;{dtype.byteorder}{dtype.char}{length}&quot;</span>)</div>
<div class="line"><span class="lineno">  481</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a103ab1c83f4e77b1b3d9df7000414f00" name="a103ab1c83f4e77b1b3d9df7000414f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103ab1c83f4e77b1b3d9df7000414f00">&#9670;&#160;</a></span>test_nonstandard_bool_to_other()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_nonstandard_bool_to_other </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  811</span>    <span class="keyword">def </span>test_nonstandard_bool_to_other(self, dtype):</div>
<div class="line"><span class="lineno">  812</span>        <span class="comment"># simple test for casting bool_ to numeric types, which should not</span></div>
<div class="line"><span class="lineno">  813</span>        <span class="comment"># expose the detail that NumPy bools can sometimes take values other</span></div>
<div class="line"><span class="lineno">  814</span>        <span class="comment"># than 0 and 1.  See also gh-19514.</span></div>
<div class="line"><span class="lineno">  815</span>        nonstandard_bools = np.array([0, 3, -7], dtype=np.int8).view(bool)</div>
<div class="line"><span class="lineno">  816</span>        res = nonstandard_bools.astype(dtype)</div>
<div class="line"><span class="lineno">  817</span>        expected = [0, 1, 1]</div>
<div class="line"><span class="lineno">  818</span>        assert_array_equal(res, expected)</div>
<div class="line"><span class="lineno">  819</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8abfaba5133bdf1a0f824b0500559eff" name="a8abfaba5133bdf1a0f824b0500559eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abfaba5133bdf1a0f824b0500559eff">&#9670;&#160;</a></span>test_numeric_to_times()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_numeric_to_times </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>from_Dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  354</span>    <span class="keyword">def </span>test_numeric_to_times(self, from_Dt):</div>
<div class="line"><span class="lineno">  355</span>        <span class="comment"># We currently only implement contiguous loops, so only need to</span></div>
<div class="line"><span class="lineno">  356</span>        <span class="comment"># test those.</span></div>
<div class="line"><span class="lineno">  357</span>        from_dt = from_Dt()</div>
<div class="line"><span class="lineno">  358</span> </div>
<div class="line"><span class="lineno">  359</span>        time_dtypes = [np.dtype(<span class="stringliteral">&quot;M8&quot;</span>), np.dtype(<span class="stringliteral">&quot;M8[ms]&quot;</span>), np.dtype(<span class="stringliteral">&quot;M8[4D]&quot;</span>),</div>
<div class="line"><span class="lineno">  360</span>                       np.dtype(<span class="stringliteral">&quot;m8&quot;</span>), np.dtype(<span class="stringliteral">&quot;m8[ms]&quot;</span>), np.dtype(<span class="stringliteral">&quot;m8[4D]&quot;</span>)]</div>
<div class="line"><span class="lineno">  361</span>        <span class="keywordflow">for</span> time_dt <span class="keywordflow">in</span> time_dtypes:</div>
<div class="line"><span class="lineno">  362</span>            cast = get_castingimpl(type(from_dt), type(time_dt))</div>
<div class="line"><span class="lineno">  363</span> </div>
<div class="line"><span class="lineno">  364</span>            casting, (from_res, to_res), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  365</span>                (from_dt, time_dt))</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span>            <span class="keyword">assert</span> from_res <span class="keywordflow">is</span> from_dt</div>
<div class="line"><span class="lineno">  368</span>            <span class="keyword">assert</span> to_res <span class="keywordflow">is</span> time_dt</div>
<div class="line"><span class="lineno">  369</span>            del from_res, to_res</div>
<div class="line"><span class="lineno">  370</span> </div>
<div class="line"><span class="lineno">  371</span>            <span class="keyword">assert</span> casting &amp; CAST_TABLE[from_Dt][type(time_dt)]</div>
<div class="line"><span class="lineno">  372</span>            <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>            int64_dt = np.dtype(np.int64)</div>
<div class="line"><span class="lineno">  375</span>            arr1, arr2, values = self.get_data(from_dt, int64_dt)</div>
<div class="line"><span class="lineno">  376</span>            arr2 = arr2.view(time_dt)</div>
<div class="line"><span class="lineno">  377</span>            arr2[...] = np.datetime64(<span class="stringliteral">&quot;NaT&quot;</span>)</div>
<div class="line"><span class="lineno">  378</span> </div>
<div class="line"><span class="lineno">  379</span>            <span class="keywordflow">if</span> time_dt == np.dtype(<span class="stringliteral">&quot;M8&quot;</span>):</div>
<div class="line"><span class="lineno">  380</span>                <span class="comment"># This is a bit of a strange path, and could probably be removed</span></div>
<div class="line"><span class="lineno">  381</span>                arr1[-1] = 0  <span class="comment"># ensure at least one value is not NaT</span></div>
<div class="line"><span class="lineno">  382</span> </div>
<div class="line"><span class="lineno">  383</span>                <span class="comment"># The cast currently succeeds, but the values are invalid:</span></div>
<div class="line"><span class="lineno">  384</span>                cast._simple_strided_call((arr1, arr2))</div>
<div class="line"><span class="lineno">  385</span>                <span class="keyword">with</span> pytest.raises(ValueError):</div>
<div class="line"><span class="lineno">  386</span>                    str(arr2[-1])  <span class="comment"># e.g. conversion to string fails</span></div>
<div class="line"><span class="lineno">  387</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>            cast._simple_strided_call((arr1, arr2))</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span>            <span class="keyword">assert</span> [int(v) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> arr2.tolist()] == values</div>
<div class="line"><span class="lineno">  392</span> </div>
<div class="line"><span class="lineno">  393</span>            <span class="comment"># Check that the same results are achieved for strided loops</span></div>
<div class="line"><span class="lineno">  394</span>            arr1_o, arr2_o = self.get_data_variation(arr1, arr2, <span class="keyword">True</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  395</span>            cast._simple_strided_call((arr1_o, arr2_o))</div>
<div class="line"><span class="lineno">  396</span> </div>
<div class="line"><span class="lineno">  397</span>            assert_array_equal(arr2_o, arr2)</div>
<div class="line"><span class="lineno">  398</span>            <span class="keyword">assert</span> arr2_o.tobytes() == arr2.tobytes()</div>
<div class="line"><span class="lineno">  399</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2acef0dd3b06a5da8d41132e95fbb38f" name="a2acef0dd3b06a5da8d41132e95fbb38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acef0dd3b06a5da8d41132e95fbb38f">&#9670;&#160;</a></span>test_object_and_simple_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_object_and_simple_resolution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  685</span>    <span class="keyword">def </span>test_object_and_simple_resolution(self, dtype):</div>
<div class="line"><span class="lineno">  686</span>        <span class="comment"># Simple test to exercise the cast when no instance is specified</span></div>
<div class="line"><span class="lineno">  687</span>        object_dtype = type(np.dtype(object))</div>
<div class="line"><span class="lineno">  688</span>        cast = get_castingimpl(object_dtype, type(dtype))</div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span>        safety, (_, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  691</span>                (np.dtype(<span class="stringliteral">&quot;O&quot;</span>), dtype))</div>
<div class="line"><span class="lineno">  692</span>        <span class="keyword">assert</span> safety == Casting.unsafe</div>
<div class="line"><span class="lineno">  693</span>        <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  694</span>        <span class="keyword">assert</span> res_dt <span class="keywordflow">is</span> dtype</div>
<div class="line"><span class="lineno">  695</span> </div>
<div class="line"><span class="lineno">  696</span>        safety, (_, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  697</span>                (np.dtype(<span class="stringliteral">&quot;O&quot;</span>), <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  698</span>        <span class="keyword">assert</span> safety == Casting.unsafe</div>
<div class="line"><span class="lineno">  699</span>        <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  700</span>        <span class="keyword">assert</span> res_dt == dtype.newbyteorder(<span class="stringliteral">&quot;=&quot;</span>)</div>
<div class="line"><span class="lineno">  701</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1906272c9804b82ee09fc8263315e4b2" name="a1906272c9804b82ee09fc8263315e4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1906272c9804b82ee09fc8263315e4b2">&#9670;&#160;</a></span>test_object_casts_NULL_None_equivalence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_object_casts_NULL_None_equivalence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  792</span>    <span class="keyword">def </span>test_object_casts_NULL_None_equivalence(self, dtype):</div>
<div class="line"><span class="lineno">  793</span>        <span class="comment"># None to &lt;other&gt; casts may succeed or fail, but a NULL&#39;ed array must</span></div>
<div class="line"><span class="lineno">  794</span>        <span class="comment"># behave the same as one filled with None&#39;s.</span></div>
<div class="line"><span class="lineno">  795</span>        arr_normal = np.array([<span class="keywordtype">None</span>] * 5)</div>
<div class="line"><span class="lineno">  796</span>        arr_NULLs = np.empty_like(arr_normal)</div>
<div class="line"><span class="lineno">  797</span>        ctypes.memset(arr_NULLs.ctypes.data, 0, arr_NULLs.nbytes)</div>
<div class="line"><span class="lineno">  798</span>        <span class="comment"># If the check fails (maybe it should) the test would lose its purpose:</span></div>
<div class="line"><span class="lineno">  799</span>        <span class="keyword">assert</span> arr_NULLs.tobytes() == b<span class="stringliteral">&quot;\x00&quot;</span> * arr_NULLs.nbytes</div>
<div class="line"><span class="lineno">  800</span> </div>
<div class="line"><span class="lineno">  801</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  802</span>            expected = arr_normal.astype(dtype)</div>
<div class="line"><span class="lineno">  803</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  804</span>            <span class="keyword">with</span> pytest.raises(TypeError):</div>
<div class="line"><span class="lineno">  805</span>                arr_NULLs.astype(dtype),</div>
<div class="line"><span class="lineno">  806</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  807</span>            assert_array_equal(expected, arr_NULLs.astype(dtype))</div>
<div class="line"><span class="lineno">  808</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8bd86ab67b72557f658b0ad2d769e4e" name="ae8bd86ab67b72557f658b0ad2d769e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bd86ab67b72557f658b0ad2d769e4e">&#9670;&#160;</a></span>test_object_to_parametric_internal_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_object_to_parametric_internal_error </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  674</span>    <span class="keyword">def </span>test_object_to_parametric_internal_error(self):</div>
<div class="line"><span class="lineno">  675</span>        <span class="comment"># We reject casting from object to a parametric type, without</span></div>
<div class="line"><span class="lineno">  676</span>        <span class="comment"># figuring out the correct instance first.</span></div>
<div class="line"><span class="lineno">  677</span>        object_dtype = type(np.dtype(object))</div>
<div class="line"><span class="lineno">  678</span>        other_dtype = type(np.dtype(str))</div>
<div class="line"><span class="lineno">  679</span>        cast = get_castingimpl(object_dtype, other_dtype)</div>
<div class="line"><span class="lineno">  680</span>        <span class="keyword">with</span> pytest.raises(TypeError,</div>
<div class="line"><span class="lineno">  681</span>                    match=<span class="stringliteral">&quot;casting from object to the parametric DType&quot;</span>):</div>
<div class="line"><span class="lineno">  682</span>            cast._resolve_descriptors((np.dtype(<span class="stringliteral">&quot;O&quot;</span>), <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  683</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abfeecf0057ab35955d42b65614841247" name="abfeecf0057ab35955d42b65614841247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfeecf0057ab35955d42b65614841247">&#9670;&#160;</a></span>test_simple_cancast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_simple_cancast </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>from_Dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  258</span>    <span class="keyword">def </span>test_simple_cancast(self, from_Dt):</div>
<div class="line"><span class="lineno">  259</span>        <span class="keywordflow">for</span> to_Dt <span class="keywordflow">in</span> simple_dtypes:</div>
<div class="line"><span class="lineno">  260</span>            cast = get_castingimpl(from_Dt, to_Dt)</div>
<div class="line"><span class="lineno">  261</span> </div>
<div class="line"><span class="lineno">  262</span>            <span class="keywordflow">for</span> from_dt <span class="keywordflow">in</span> [from_Dt(), from_Dt().newbyteorder()]:</div>
<div class="line"><span class="lineno">  263</span>                default = cast._resolve_descriptors((from_dt, <span class="keywordtype">None</span>))[1][1]</div>
<div class="line"><span class="lineno">  264</span>                <span class="keyword">assert</span> default == to_Dt()</div>
<div class="line"><span class="lineno">  265</span>                del default</div>
<div class="line"><span class="lineno">  266</span> </div>
<div class="line"><span class="lineno">  267</span>                <span class="keywordflow">for</span> to_dt <span class="keywordflow">in</span> [to_Dt(), to_Dt().newbyteorder()]:</div>
<div class="line"><span class="lineno">  268</span>                    casting, (from_res, to_res), view_off = (</div>
<div class="line"><span class="lineno">  269</span>                            cast._resolve_descriptors((from_dt, to_dt)))</div>
<div class="line"><span class="lineno">  270</span>                    assert(type(from_res) == from_Dt)</div>
<div class="line"><span class="lineno">  271</span>                    assert(type(to_res) == to_Dt)</div>
<div class="line"><span class="lineno">  272</span>                    <span class="keywordflow">if</span> view_off <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  273</span>                        <span class="comment"># If a view is acceptable, this is &quot;no&quot; casting</span></div>
<div class="line"><span class="lineno">  274</span>                        <span class="comment"># and byte order must be matching.</span></div>
<div class="line"><span class="lineno">  275</span>                        <span class="keyword">assert</span> casting == Casting.no</div>
<div class="line"><span class="lineno">  276</span>                        <span class="comment"># The above table lists this as &quot;equivalent&quot;</span></div>
<div class="line"><span class="lineno">  277</span>                        <span class="keyword">assert</span> Casting.equiv == CAST_TABLE[from_Dt][to_Dt]</div>
<div class="line"><span class="lineno">  278</span>                        <span class="comment"># Note that to_res may not be the same as from_dt</span></div>
<div class="line"><span class="lineno">  279</span>                        <span class="keyword">assert</span> from_res.isnative == to_res.isnative</div>
<div class="line"><span class="lineno">  280</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  281</span>                        <span class="keywordflow">if</span> from_Dt == to_Dt:</div>
<div class="line"><span class="lineno">  282</span>                            <span class="comment"># Note that to_res may not be the same as from_dt</span></div>
<div class="line"><span class="lineno">  283</span>                            <span class="keyword">assert</span> from_res.isnative != to_res.isnative</div>
<div class="line"><span class="lineno">  284</span>                        <span class="keyword">assert</span> casting == CAST_TABLE[from_Dt][to_Dt]</div>
<div class="line"><span class="lineno">  285</span> </div>
<div class="line"><span class="lineno">  286</span>                    <span class="keywordflow">if</span> from_Dt <span class="keywordflow">is</span> to_Dt:</div>
<div class="line"><span class="lineno">  287</span>                        assert(from_dt <span class="keywordflow">is</span> from_res)</div>
<div class="line"><span class="lineno">  288</span>                        assert(to_dt <span class="keywordflow">is</span> to_res)</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a27361215fe10f56be28d1ee51bb65002" name="a27361215fe10f56be28d1ee51bb65002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27361215fe10f56be28d1ee51bb65002">&#9670;&#160;</a></span>test_simple_direct_casts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_simple_direct_casts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>from_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This test checks numeric direct casts for dtypes supported also by the
struct module (plus complex).  It tries to be test a wide range of
inputs, but skips over possibly undefined behaviour (e.g. int rollover).
Longdouble and CLongdouble are tested, but only using double precision.

If this test creates issues, it should possibly just be simplified
or even removed (checking whether unaligned/non-contiguous casts give
the same results is useful, though).
</pre> <div class="fragment"><div class="line"><span class="lineno">  293</span>    <span class="keyword">def </span>test_simple_direct_casts(self, from_dt):</div>
<div class="line"><span class="lineno">  294</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        This test checks numeric direct casts for dtypes supported also by the</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        struct module (plus complex).  It tries to be test a wide range of</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        inputs, but skips over possibly undefined behaviour (e.g. int rollover).</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        Longdouble and CLongdouble are tested, but only using double precision.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        If this test creates issues, it should possibly just be simplified</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        or even removed (checking whether unaligned/non-contiguous casts give</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">        the same results is useful, though).</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  304</span>        <span class="keywordflow">for</span> to_dt <span class="keywordflow">in</span> simple_dtype_instances():</div>
<div class="line"><span class="lineno">  305</span>            to_dt = to_dt.values[0]</div>
<div class="line"><span class="lineno">  306</span>            cast = get_castingimpl(type(from_dt), type(to_dt))</div>
<div class="line"><span class="lineno">  307</span> </div>
<div class="line"><span class="lineno">  308</span>            casting, (from_res, to_res), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  309</span>                (from_dt, to_dt))</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>            <span class="keywordflow">if</span> from_res <span class="keywordflow">is</span> <span class="keywordflow">not</span> from_dt <span class="keywordflow">or</span> to_res <span class="keywordflow">is</span> <span class="keywordflow">not</span> to_dt:</div>
<div class="line"><span class="lineno">  312</span>                <span class="comment"># Do not test this case, it is handled in multiple steps,</span></div>
<div class="line"><span class="lineno">  313</span>                <span class="comment"># each of which should is tested individually.</span></div>
<div class="line"><span class="lineno">  314</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span>            safe = casting &lt;= Casting.safe</div>
<div class="line"><span class="lineno">  317</span>            del from_res, to_res, casting</div>
<div class="line"><span class="lineno">  318</span> </div>
<div class="line"><span class="lineno">  319</span>            arr1, arr2, values = self.get_data(from_dt, to_dt)</div>
<div class="line"><span class="lineno">  320</span> </div>
<div class="line"><span class="lineno">  321</span>            cast._simple_strided_call((arr1, arr2))</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>            <span class="comment"># Check via python list</span></div>
<div class="line"><span class="lineno">  324</span>            <span class="keyword">assert</span> arr2.tolist() == values</div>
<div class="line"><span class="lineno">  325</span> </div>
<div class="line"><span class="lineno">  326</span>            <span class="comment"># Check that the same results are achieved for strided loops</span></div>
<div class="line"><span class="lineno">  327</span>            arr1_o, arr2_o = self.get_data_variation(arr1, arr2, <span class="keyword">True</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  328</span>            cast._simple_strided_call((arr1_o, arr2_o))</div>
<div class="line"><span class="lineno">  329</span> </div>
<div class="line"><span class="lineno">  330</span>            assert_array_equal(arr2_o, arr2)</div>
<div class="line"><span class="lineno">  331</span>            <span class="keyword">assert</span> arr2_o.tobytes() == arr2.tobytes()</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>            <span class="comment"># Check if alignment makes a difference, but only if supported</span></div>
<div class="line"><span class="lineno">  334</span>            <span class="comment"># and only if the alignment can be wrong</span></div>
<div class="line"><span class="lineno">  335</span>            <span class="keywordflow">if</span> ((from_dt.alignment == 1 <span class="keywordflow">and</span> to_dt.alignment == 1) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  336</span>                    <span class="keywordflow">not</span> cast._supports_unaligned):</div>
<div class="line"><span class="lineno">  337</span>                <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  338</span> </div>
<div class="line"><span class="lineno">  339</span>            arr1_o, arr2_o = self.get_data_variation(arr1, arr2, <span class="keyword">False</span>, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  340</span>            cast._simple_strided_call((arr1_o, arr2_o))</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>            assert_array_equal(arr2_o, arr2)</div>
<div class="line"><span class="lineno">  343</span>            <span class="keyword">assert</span> arr2_o.tobytes() == arr2.tobytes()</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span>            arr1_o, arr2_o = self.get_data_variation(arr1, arr2, <span class="keyword">False</span>, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  346</span>            cast._simple_strided_call((arr1_o, arr2_o))</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>            assert_array_equal(arr2_o, arr2)</div>
<div class="line"><span class="lineno">  349</span>            <span class="keyword">assert</span> arr2_o.tobytes() == arr2.tobytes()</div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>            del arr1_o, arr2_o, cast</div>
<div class="line"><span class="lineno">  352</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4ef56d707bcc0eba3d9a051ca3714b8" name="ae4ef56d707bcc0eba3d9a051ca3714b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef56d707bcc0eba3d9a051ca3714b8">&#9670;&#160;</a></span>test_simple_string_casts_roundtrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_simple_string_casts_roundtrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tests casts from and to string by checking the roundtripping property.

The test also covers some string to string casts (but not all).

If this test creates issues, it should possibly just be simplified
or even removed (checking whether unaligned/non-contiguous casts give
the same results is useful, though).
</pre> <div class="fragment"><div class="line"><span class="lineno">  532</span>    <span class="keyword">def </span>test_simple_string_casts_roundtrip(self, other_dt, string_char):</div>
<div class="line"><span class="lineno">  533</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        Tests casts from and to string by checking the roundtripping property.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">        The test also covers some string to string casts (but not all).</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">        If this test creates issues, it should possibly just be simplified</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">        or even removed (checking whether unaligned/non-contiguous casts give</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">        the same results is useful, though).</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  542</span>        string_DT = type(np.dtype(string_char))</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  544</span>        cast = get_castingimpl(type(other_dt), string_DT)</div>
<div class="line"><span class="lineno">  545</span>        cast_back = get_castingimpl(string_DT, type(other_dt))</div>
<div class="line"><span class="lineno">  546</span>        _, (res_other_dt, string_dt), _ = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  547</span>                (other_dt, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  548</span> </div>
<div class="line"><span class="lineno">  549</span>        <span class="keywordflow">if</span> res_other_dt <span class="keywordflow">is</span> <span class="keywordflow">not</span> other_dt:</div>
<div class="line"><span class="lineno">  550</span>            <span class="comment"># do not support non-native byteorder, skip test in that case</span></div>
<div class="line"><span class="lineno">  551</span>            <span class="keyword">assert</span> other_dt.byteorder != res_other_dt.byteorder</div>
<div class="line"><span class="lineno">  552</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  553</span> </div>
<div class="line"><span class="lineno">  554</span>        orig_arr, values = self.get_data(other_dt, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  555</span>        str_arr = np.zeros(len(orig_arr), dtype=string_dt)</div>
<div class="line"><span class="lineno">  556</span>        string_dt_short = self.string_with_modified_length(string_dt, -1)</div>
<div class="line"><span class="lineno">  557</span>        str_arr_short = np.zeros(len(orig_arr), dtype=string_dt_short)</div>
<div class="line"><span class="lineno">  558</span>        string_dt_long = self.string_with_modified_length(string_dt, 1)</div>
<div class="line"><span class="lineno">  559</span>        str_arr_long = np.zeros(len(orig_arr), dtype=string_dt_long)</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>        <span class="keyword">assert</span> <span class="keywordflow">not</span> cast._supports_unaligned  <span class="comment"># if support is added, should test</span></div>
<div class="line"><span class="lineno">  562</span>        <span class="keyword">assert</span> <span class="keywordflow">not</span> cast_back._supports_unaligned</div>
<div class="line"><span class="lineno">  563</span> </div>
<div class="line"><span class="lineno">  564</span>        <span class="keywordflow">for</span> contig <span class="keywordflow">in</span> [<span class="keyword">True</span>, <span class="keyword">False</span>]:</div>
<div class="line"><span class="lineno">  565</span>            other_arr, str_arr = self.get_data_variation(</div>
<div class="line"><span class="lineno">  566</span>                orig_arr, str_arr, <span class="keyword">True</span>, contig)</div>
<div class="line"><span class="lineno">  567</span>            _, str_arr_short = self.get_data_variation(</div>
<div class="line"><span class="lineno">  568</span>                orig_arr, str_arr_short.copy(), <span class="keyword">True</span>, contig)</div>
<div class="line"><span class="lineno">  569</span>            _, str_arr_long = self.get_data_variation(</div>
<div class="line"><span class="lineno">  570</span>                orig_arr, str_arr_long, <span class="keyword">True</span>, contig)</div>
<div class="line"><span class="lineno">  571</span> </div>
<div class="line"><span class="lineno">  572</span>            cast._simple_strided_call((other_arr, str_arr))</div>
<div class="line"><span class="lineno">  573</span> </div>
<div class="line"><span class="lineno">  574</span>            cast._simple_strided_call((other_arr, str_arr_short))</div>
<div class="line"><span class="lineno">  575</span>            assert_array_equal(str_arr.astype(string_dt_short), str_arr_short)</div>
<div class="line"><span class="lineno">  576</span> </div>
<div class="line"><span class="lineno">  577</span>            cast._simple_strided_call((other_arr, str_arr_long))</div>
<div class="line"><span class="lineno">  578</span>            assert_array_equal(str_arr, str_arr_long)</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span>            <span class="keywordflow">if</span> other_dt.kind == <span class="stringliteral">&quot;b&quot;</span>:</div>
<div class="line"><span class="lineno">  581</span>                <span class="comment"># Booleans do not roundtrip</span></div>
<div class="line"><span class="lineno">  582</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  583</span> </div>
<div class="line"><span class="lineno">  584</span>            other_arr[...] = 0</div>
<div class="line"><span class="lineno">  585</span>            cast_back._simple_strided_call((str_arr, other_arr))</div>
<div class="line"><span class="lineno">  586</span>            assert_array_equal(orig_arr, other_arr)</div>
<div class="line"><span class="lineno">  587</span> </div>
<div class="line"><span class="lineno">  588</span>            other_arr[...] = 0</div>
<div class="line"><span class="lineno">  589</span>            cast_back._simple_strided_call((str_arr_long, other_arr))</div>
<div class="line"><span class="lineno">  590</span>            assert_array_equal(orig_arr, other_arr)</div>
<div class="line"><span class="lineno">  591</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a85f3d9aac2c94e371c03bc4e9aa412a2" name="a85f3d9aac2c94e371c03bc4e9aa412a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f3d9aac2c94e371c03bc4e9aa412a2">&#9670;&#160;</a></span>test_simple_to_object_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_simple_to_object_resolution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  703</span>    <span class="keyword">def </span>test_simple_to_object_resolution(self, dtype):</div>
<div class="line"><span class="lineno">  704</span>        <span class="comment"># Simple test to exercise the cast when no instance is specified</span></div>
<div class="line"><span class="lineno">  705</span>        object_dtype = type(np.dtype(object))</div>
<div class="line"><span class="lineno">  706</span>        cast = get_castingimpl(type(dtype), object_dtype)</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span>        safety, (_, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  709</span>                (dtype, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  710</span>        <span class="keyword">assert</span> safety == Casting.safe</div>
<div class="line"><span class="lineno">  711</span>        <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  712</span>        <span class="keyword">assert</span> res_dt <span class="keywordflow">is</span> np.dtype(<span class="stringliteral">&quot;O&quot;</span>)</div>
<div class="line"><span class="lineno">  713</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a80417d647907e5e05a93624523a797b3" name="a80417d647907e5e05a93624523a797b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80417d647907e5e05a93624523a797b3">&#9670;&#160;</a></span>test_string_cancast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_string_cancast </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_DT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  484</span>    <span class="keyword">def </span>test_string_cancast(self, other_DT, string_char):</div>
<div class="line"><span class="lineno">  485</span>        fact = 1 <span class="keywordflow">if</span> string_char == <span class="stringliteral">&quot;S&quot;</span> <span class="keywordflow">else</span> 4</div>
<div class="line"><span class="lineno">  486</span> </div>
<div class="line"><span class="lineno">  487</span>        string_DT = type(np.dtype(string_char))</div>
<div class="line"><span class="lineno">  488</span>        cast = get_castingimpl(other_DT, string_DT)</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>        other_dt = other_DT()</div>
<div class="line"><span class="lineno">  491</span>        expected_length = get_expected_stringlength(other_dt)</div>
<div class="line"><span class="lineno">  492</span>        string_dt = np.dtype(f<span class="stringliteral">&quot;{string_char}{expected_length}&quot;</span>)</div>
<div class="line"><span class="lineno">  493</span> </div>
<div class="line"><span class="lineno">  494</span>        safety, (res_other_dt, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  495</span>                (other_dt, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  496</span>        <span class="keyword">assert</span> res_dt.itemsize == expected_length * fact</div>
<div class="line"><span class="lineno">  497</span>        <span class="keyword">assert</span> safety == Casting.safe  <span class="comment"># we consider to string casts &quot;safe&quot;</span></div>
<div class="line"><span class="lineno">  498</span>        <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  499</span>        <span class="keyword">assert</span> isinstance(res_dt, string_DT)</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span>        <span class="comment"># These casts currently implement changing the string length, so</span></div>
<div class="line"><span class="lineno">  502</span>        <span class="comment"># check the cast-safety for too long/fixed string lengths:</span></div>
<div class="line"><span class="lineno">  503</span>        <span class="keywordflow">for</span> change_length <span class="keywordflow">in</span> [-1, 0, 1]:</div>
<div class="line"><span class="lineno">  504</span>            <span class="keywordflow">if</span> change_length &gt;= 0:</div>
<div class="line"><span class="lineno">  505</span>                expected_safety = Casting.safe</div>
<div class="line"><span class="lineno">  506</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  507</span>                expected_safety = Casting.same_kind</div>
<div class="line"><span class="lineno">  508</span> </div>
<div class="line"><span class="lineno">  509</span>            to_dt = self.string_with_modified_length(string_dt, change_length)</div>
<div class="line"><span class="lineno">  510</span>            safety, (_, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  511</span>                    (other_dt, to_dt))</div>
<div class="line"><span class="lineno">  512</span>            <span class="keyword">assert</span> res_dt <span class="keywordflow">is</span> to_dt</div>
<div class="line"><span class="lineno">  513</span>            <span class="keyword">assert</span> safety == expected_safety</div>
<div class="line"><span class="lineno">  514</span>            <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span>        <span class="comment"># The opposite direction is always considered unsafe:</span></div>
<div class="line"><span class="lineno">  517</span>        cast = get_castingimpl(string_DT, other_DT)</div>
<div class="line"><span class="lineno">  518</span> </div>
<div class="line"><span class="lineno">  519</span>        safety, _, view_off = cast._resolve_descriptors((string_dt, other_dt))</div>
<div class="line"><span class="lineno">  520</span>        <span class="keyword">assert</span> safety == Casting.unsafe</div>
<div class="line"><span class="lineno">  521</span>        <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span>        cast = get_castingimpl(string_DT, other_DT)</div>
<div class="line"><span class="lineno">  524</span>        safety, (_, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  525</span>            (string_dt, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  526</span>        <span class="keyword">assert</span> safety == Casting.unsafe</div>
<div class="line"><span class="lineno">  527</span>        <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  528</span>        <span class="keyword">assert</span> other_dt <span class="keywordflow">is</span> res_dt  <span class="comment"># returns the singleton for simple dtypes</span></div>
<div class="line"><span class="lineno">  529</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4fdcb07222c3f64d4b21871ee81d2929" name="a4fdcb07222c3f64d4b21871ee81d2929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdcb07222c3f64d4b21871ee81d2929">&#9670;&#160;</a></span>test_string_to_string_cancast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_string_to_string_cancast </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  594</span>    <span class="keyword">def </span>test_string_to_string_cancast(self, other_dt, string_char):</div>
<div class="line"><span class="lineno">  595</span>        other_dt = np.dtype(other_dt)</div>
<div class="line"><span class="lineno">  596</span> </div>
<div class="line"><span class="lineno">  597</span>        fact = 1 <span class="keywordflow">if</span> string_char == <span class="stringliteral">&quot;S&quot;</span> <span class="keywordflow">else</span> 4</div>
<div class="line"><span class="lineno">  598</span>        div = 1 <span class="keywordflow">if</span> other_dt.char == <span class="stringliteral">&quot;S&quot;</span> <span class="keywordflow">else</span> 4</div>
<div class="line"><span class="lineno">  599</span> </div>
<div class="line"><span class="lineno">  600</span>        string_DT = type(np.dtype(string_char))</div>
<div class="line"><span class="lineno">  601</span>        cast = get_castingimpl(type(other_dt), string_DT)</div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>        expected_length = other_dt.itemsize // div</div>
<div class="line"><span class="lineno">  604</span>        string_dt = np.dtype(f<span class="stringliteral">&quot;{string_char}{expected_length}&quot;</span>)</div>
<div class="line"><span class="lineno">  605</span> </div>
<div class="line"><span class="lineno">  606</span>        safety, (res_other_dt, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  607</span>                (other_dt, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  608</span>        <span class="keyword">assert</span> res_dt.itemsize == expected_length * fact</div>
<div class="line"><span class="lineno">  609</span>        <span class="keyword">assert</span> isinstance(res_dt, string_DT)</div>
<div class="line"><span class="lineno">  610</span> </div>
<div class="line"><span class="lineno">  611</span>        expected_view_off = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  612</span>        <span class="keywordflow">if</span> other_dt.char == string_char:</div>
<div class="line"><span class="lineno">  613</span>            <span class="keywordflow">if</span> other_dt.isnative:</div>
<div class="line"><span class="lineno">  614</span>                expected_safety = Casting.no</div>
<div class="line"><span class="lineno">  615</span>                expected_view_off = 0</div>
<div class="line"><span class="lineno">  616</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  617</span>                expected_safety = Casting.equiv</div>
<div class="line"><span class="lineno">  618</span>        <span class="keywordflow">elif</span> string_char == <span class="stringliteral">&quot;U&quot;</span>:</div>
<div class="line"><span class="lineno">  619</span>            expected_safety = Casting.safe</div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  621</span>            expected_safety = Casting.unsafe</div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span>        <span class="keyword">assert</span> view_off == expected_view_off</div>
<div class="line"><span class="lineno">  624</span>        <span class="keyword">assert</span> expected_safety == safety</div>
<div class="line"><span class="lineno">  625</span> </div>
<div class="line"><span class="lineno">  626</span>        <span class="keywordflow">for</span> change_length <span class="keywordflow">in</span> [-1, 0, 1]:</div>
<div class="line"><span class="lineno">  627</span>            to_dt = self.string_with_modified_length(string_dt, change_length)</div>
<div class="line"><span class="lineno">  628</span>            safety, (_, res_dt), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  629</span>                    (other_dt, to_dt))</div>
<div class="line"><span class="lineno">  630</span> </div>
<div class="line"><span class="lineno">  631</span>            <span class="keyword">assert</span> res_dt <span class="keywordflow">is</span> to_dt</div>
<div class="line"><span class="lineno">  632</span>            <span class="keywordflow">if</span> change_length &lt;= 0:</div>
<div class="line"><span class="lineno">  633</span>                <span class="keyword">assert</span> view_off == expected_view_off</div>
<div class="line"><span class="lineno">  634</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  635</span>                <span class="keyword">assert</span> view_off <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  636</span>            <span class="keywordflow">if</span> expected_safety == Casting.unsafe:</div>
<div class="line"><span class="lineno">  637</span>                <span class="keyword">assert</span> safety == expected_safety</div>
<div class="line"><span class="lineno">  638</span>            <span class="keywordflow">elif</span> change_length &lt; 0:</div>
<div class="line"><span class="lineno">  639</span>                <span class="keyword">assert</span> safety == Casting.same_kind</div>
<div class="line"><span class="lineno">  640</span>            <span class="keywordflow">elif</span> change_length == 0:</div>
<div class="line"><span class="lineno">  641</span>                <span class="keyword">assert</span> safety == expected_safety</div>
<div class="line"><span class="lineno">  642</span>            <span class="keywordflow">elif</span> change_length &gt; 0:</div>
<div class="line"><span class="lineno">  643</span>                <span class="keyword">assert</span> safety == Casting.safe</div>
<div class="line"><span class="lineno">  644</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a28ad0ae6e934cd25cddb2828311f27e3" name="a28ad0ae6e934cd25cddb2828311f27e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ad0ae6e934cd25cddb2828311f27e3">&#9670;&#160;</a></span>test_structured_field_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_structured_field_offsets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expected_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  732</span>    <span class="keyword">def </span>test_structured_field_offsets(self, to_dt, expected_off):</div>
<div class="line"><span class="lineno">  733</span>        <span class="comment"># This checks the cast-safety and view offset for swapped and &quot;shifted&quot;</span></div>
<div class="line"><span class="lineno">  734</span>        <span class="comment"># fields which are viewable</span></div>
<div class="line"><span class="lineno">  735</span>        from_dt = np.dtype({<span class="stringliteral">&quot;names&quot;</span>: [<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>],</div>
<div class="line"><span class="lineno">  736</span>                            <span class="stringliteral">&quot;formats&quot;</span>: [<span class="stringliteral">&quot;i4&quot;</span>, <span class="stringliteral">&quot;f4&quot;</span>],</div>
<div class="line"><span class="lineno">  737</span>                            <span class="stringliteral">&quot;offsets&quot;</span>: [2, 6]})</div>
<div class="line"><span class="lineno">  738</span>        cast = get_castingimpl(type(from_dt), type(to_dt))</div>
<div class="line"><span class="lineno">  739</span>        safety, _, view_off = cast._resolve_descriptors((from_dt, to_dt))</div>
<div class="line"><span class="lineno">  740</span>        <span class="keywordflow">if</span> from_dt.names == to_dt.names:</div>
<div class="line"><span class="lineno">  741</span>            <span class="keyword">assert</span> safety == Casting.equiv</div>
<div class="line"><span class="lineno">  742</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  743</span>            <span class="keyword">assert</span> safety == Casting.safe</div>
<div class="line"><span class="lineno">  744</span>        <span class="comment"># Shifting the original data pointer by -2 will align both by</span></div>
<div class="line"><span class="lineno">  745</span>        <span class="comment"># effectively adding 2 bytes of spacing before `from_dt`.</span></div>
<div class="line"><span class="lineno">  746</span>        <span class="keyword">assert</span> view_off == expected_off</div>
<div class="line"><span class="lineno">  747</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d6ca1ff7a23358e5dc1f837d320ed2c" name="a3d6ca1ff7a23358e5dc1f837d320ed2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6ca1ff7a23358e5dc1f837d320ed2c">&#9670;&#160;</a></span>test_time_to_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_time_to_time </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>from_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expected_casting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expected_view_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  431</span>                          nom, denom):</div>
<div class="line"><span class="lineno">  432</span>        from_dt = np.dtype(from_dt)</div>
<div class="line"><span class="lineno">  433</span>        <span class="keywordflow">if</span> to_dt <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  434</span>            to_dt = np.dtype(to_dt)</div>
<div class="line"><span class="lineno">  435</span> </div>
<div class="line"><span class="lineno">  436</span>        <span class="comment"># Test a few values for casting (results generated with NumPy 1.19)</span></div>
<div class="line"><span class="lineno">  437</span>        values = np.array([-2**63, 1, 2**63-1, 10000, -10000, 2**32])</div>
<div class="line"><span class="lineno">  438</span>        values = values.astype(np.dtype(<span class="stringliteral">&quot;int64&quot;</span>).newbyteorder(from_dt.byteorder))</div>
<div class="line"><span class="lineno">  439</span>        <span class="keyword">assert</span> values.dtype.byteorder == from_dt.byteorder</div>
<div class="line"><span class="lineno">  440</span>        <span class="keyword">assert</span> np.isnat(values.view(from_dt)[0])</div>
<div class="line"><span class="lineno">  441</span> </div>
<div class="line"><span class="lineno">  442</span>        DType = type(from_dt)</div>
<div class="line"><span class="lineno">  443</span>        cast = get_castingimpl(DType, DType)</div>
<div class="line"><span class="lineno">  444</span>        casting, (from_res, to_res), view_off = cast._resolve_descriptors(</div>
<div class="line"><span class="lineno">  445</span>                (from_dt, to_dt))</div>
<div class="line"><span class="lineno">  446</span>        <span class="keyword">assert</span> from_res <span class="keywordflow">is</span> from_dt</div>
<div class="line"><span class="lineno">  447</span>        <span class="keyword">assert</span> to_res <span class="keywordflow">is</span> to_dt <span class="keywordflow">or</span> to_dt <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  448</span>        <span class="keyword">assert</span> casting == expected_casting</div>
<div class="line"><span class="lineno">  449</span>        <span class="keyword">assert</span> view_off == expected_view_off</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span>        <span class="keywordflow">if</span> nom <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  452</span>            expected_out = (values * nom // denom).view(to_res)</div>
<div class="line"><span class="lineno">  453</span>            expected_out[0] = <span class="stringliteral">&quot;NaT&quot;</span></div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  455</span>            expected_out = np.empty_like(values)</div>
<div class="line"><span class="lineno">  456</span>            expected_out[...] = denom</div>
<div class="line"><span class="lineno">  457</span>            expected_out = expected_out.view(to_dt)</div>
<div class="line"><span class="lineno">  458</span> </div>
<div class="line"><span class="lineno">  459</span>        orig_arr = values.view(from_dt)</div>
<div class="line"><span class="lineno">  460</span>        orig_out = np.empty_like(expected_out)</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span>        <span class="keywordflow">if</span> casting == Casting.unsafe <span class="keywordflow">and</span> (to_dt == <span class="stringliteral">&quot;m8&quot;</span> <span class="keywordflow">or</span> to_dt == <span class="stringliteral">&quot;M8&quot;</span>):</div>
<div class="line"><span class="lineno">  463</span>            <span class="comment"># Casting from non-generic to generic units is an error and should</span></div>
<div class="line"><span class="lineno">  464</span>            <span class="comment"># probably be reported as an invalid cast earlier.</span></div>
<div class="line"><span class="lineno">  465</span>            <span class="keyword">with</span> pytest.raises(ValueError):</div>
<div class="line"><span class="lineno">  466</span>                cast._simple_strided_call((orig_arr, orig_out))</div>
<div class="line"><span class="lineno">  467</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>        <span class="keywordflow">for</span> aligned <span class="keywordflow">in</span> [<span class="keyword">True</span>, <span class="keyword">True</span>]:</div>
<div class="line"><span class="lineno">  470</span>            <span class="keywordflow">for</span> contig <span class="keywordflow">in</span> [<span class="keyword">True</span>, <span class="keyword">True</span>]:</div>
<div class="line"><span class="lineno">  471</span>                arr, out = self.get_data_variation(</div>
<div class="line"><span class="lineno">  472</span>                        orig_arr, orig_out, aligned, contig)</div>
<div class="line"><span class="lineno">  473</span>                out[...] = 0</div>
<div class="line"><span class="lineno">  474</span>                cast._simple_strided_call((arr, out))</div>
<div class="line"><span class="lineno">  475</span>                assert_array_equal(out.view(<span class="stringliteral">&quot;int64&quot;</span>), expected_out.view(<span class="stringliteral">&quot;int64&quot;</span>))</div>
<div class="line"><span class="lineno">  476</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02281ad2110a80dd0b8b5d36e38b4b2b" name="a02281ad2110a80dd0b8b5d36e38b4b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02281ad2110a80dd0b8b5d36e38b4b2b">&#9670;&#160;</a></span>test_unicode_byteswapped_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_unicode_byteswapped_cast </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  647</span>    <span class="keyword">def </span>test_unicode_byteswapped_cast(self, order1, order2):</div>
<div class="line"><span class="lineno">  648</span>        <span class="comment"># Very specific tests (not using the castingimpl directly)</span></div>
<div class="line"><span class="lineno">  649</span>        <span class="comment"># that tests unicode bytedwaps including for unaligned array data.</span></div>
<div class="line"><span class="lineno">  650</span>        dtype1 = np.dtype(f<span class="stringliteral">&quot;{order1}U30&quot;</span>)</div>
<div class="line"><span class="lineno">  651</span>        dtype2 = np.dtype(f<span class="stringliteral">&quot;{order2}U30&quot;</span>)</div>
<div class="line"><span class="lineno">  652</span>        data1 = np.empty(30 * 4 + 1, dtype=np.uint8)[1:].view(dtype1)</div>
<div class="line"><span class="lineno">  653</span>        data2 = np.empty(30 * 4 + 1, dtype=np.uint8)[1:].view(dtype2)</div>
<div class="line"><span class="lineno">  654</span>        <span class="keywordflow">if</span> dtype1.alignment != 1:</div>
<div class="line"><span class="lineno">  655</span>            <span class="comment"># alignment should always be &gt;1, but skip the check if not</span></div>
<div class="line"><span class="lineno">  656</span>            <span class="keyword">assert</span> <span class="keywordflow">not</span> data1.flags.aligned</div>
<div class="line"><span class="lineno">  657</span>            <span class="keyword">assert</span> <span class="keywordflow">not</span> data2.flags.aligned</div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span>        element = <span class="stringliteral">&quot;this is a ünicode string‽&quot;</span></div>
<div class="line"><span class="lineno">  660</span>        data1[()] = element</div>
<div class="line"><span class="lineno">  661</span>        <span class="comment"># Test both `data1` and `data1.copy()`  (which should be aligned)</span></div>
<div class="line"><span class="lineno">  662</span>        <span class="keywordflow">for</span> data <span class="keywordflow">in</span> [data1, data1.copy()]:</div>
<div class="line"><span class="lineno">  663</span>            data2[...] = data1</div>
<div class="line"><span class="lineno">  664</span>            <span class="keyword">assert</span> data2[()] == element</div>
<div class="line"><span class="lineno">  665</span>            <span class="keyword">assert</span> data2.copy()[()] == element</div>
<div class="line"><span class="lineno">  666</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a84ef9039f0273c38861b7006530b4774" name="a84ef9039f0273c38861b7006530b4774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ef9039f0273c38861b7006530b4774">&#9670;&#160;</a></span>test_void_and_structured_with_subarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_void_and_structured_with_subarray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  715</span>    <span class="keyword">def </span>test_void_and_structured_with_subarray(self, casting):</div>
<div class="line"><span class="lineno">  716</span>        <span class="comment"># test case corresponding to gh-19325</span></div>
<div class="line"><span class="lineno">  717</span>        dtype = np.dtype([(<span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;&lt;f4&quot;</span>, (3, 2))])</div>
<div class="line"><span class="lineno">  718</span>        expected = casting == <span class="stringliteral">&quot;unsafe&quot;</span></div>
<div class="line"><span class="lineno">  719</span>        <span class="keyword">assert</span> np.can_cast(<span class="stringliteral">&quot;V4&quot;</span>, dtype, casting=casting) == expected</div>
<div class="line"><span class="lineno">  720</span>        <span class="keyword">assert</span> np.can_cast(dtype, <span class="stringliteral">&quot;V4&quot;</span>, casting=casting) == expected</div>
<div class="line"><span class="lineno">  721</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afa8f21d19bb93f98052d94e9ff304b51" name="afa8f21d19bb93f98052d94e9ff304b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8f21d19bb93f98052d94e9ff304b51">&#9670;&#160;</a></span>test_void_to_string_special_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.test_void_to_string_special_case </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  667</span>    <span class="keyword">def </span>test_void_to_string_special_case(self):</div>
<div class="line"><span class="lineno">  668</span>        <span class="comment"># Cover a small special case in void to string casting that could</span></div>
<div class="line"><span class="lineno">  669</span>        <span class="comment"># probably just as well be turned into an error (compare</span></div>
<div class="line"><span class="lineno">  670</span>        <span class="comment"># `test_object_to_parametric_internal_error` below).</span></div>
<div class="line"><span class="lineno">  671</span>        <span class="keyword">assert</span> np.array([], dtype=<span class="stringliteral">&quot;V5&quot;</span>).astype(<span class="stringliteral">&quot;S&quot;</span>).dtype.itemsize == 5</div>
<div class="line"><span class="lineno">  672</span>        <span class="keyword">assert</span> np.array([], dtype=<span class="stringliteral">&quot;V5&quot;</span>).astype(<span class="stringliteral">&quot;U&quot;</span>).dtype.itemsize == 4 * 5</div>
<div class="line"><span class="lineno">  673</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aeb80b346a4e5648c3099ba62e92aa4d8" name="aeb80b346a4e5648c3099ba62e92aa4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb80b346a4e5648c3099ba62e92aa4d8">&#9670;&#160;</a></span>_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting._</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fc48638ce62033d6695d26f453631f4" name="a1fc48638ce62033d6695d26f453631f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc48638ce62033d6695d26f453631f4">&#9670;&#160;</a></span>cast</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.cast = get_castingimpl(type(<a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a931ad95ca9c8ceb0138fc57c6ab95051">from_dt</a>), type(<a class="el" href="classnumpy_1_1core_1_1tests_1_1test__casting__unittests_1_1_test_casting.html#a504bb21474ec2fd02e0c553d7be86c4b">to_dt</a>))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a931ad95ca9c8ceb0138fc57c6ab95051" name="a931ad95ca9c8ceb0138fc57c6ab95051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931ad95ca9c8ceb0138fc57c6ab95051">&#9670;&#160;</a></span>from_dt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.from_dt = np.dtype(from_dt)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7017d6f18f4694804ed44147414db69" name="af7017d6f18f4694804ed44147414db69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7017d6f18f4694804ed44147414db69">&#9670;&#160;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int numpy.core.tests.test_casting_unittests.TestCasting.size = 1500</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a504bb21474ec2fd02e0c553d7be86c4b" name="a504bb21474ec2fd02e0c553d7be86c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504bb21474ec2fd02e0c553d7be86c4b">&#9670;&#160;</a></span>to_dt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.to_dt = np.dtype(to_dt)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4df0f5dd70447f7a957d18186a1695ff" name="a4df0f5dd70447f7a957d18186a1695ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df0f5dd70447f7a957d18186a1695ff">&#9670;&#160;</a></span>view_off</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_casting_unittests.TestCasting.view_off</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/numpy/core/tests/<a class="el" href="test__casting__unittests_8py.html">test_casting_unittests.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
