<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.signal._signaltools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal.html">signal</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html">_signaltools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.signal._signaltools Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a641a8d36f14647c20438c1ace63a0a22" id="r_a641a8d36f14647c20438c1ace63a0a22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a641a8d36f14647c20438c1ace63a0a22">_valfrommode</a> (mode)</td></tr>
<tr class="separator:a641a8d36f14647c20438c1ace63a0a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9135e147844856870d2fa2bf7a8b5c7" id="r_aa9135e147844856870d2fa2bf7a8b5c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aa9135e147844856870d2fa2bf7a8b5c7">_bvalfromboundary</a> (boundary)</td></tr>
<tr class="separator:aa9135e147844856870d2fa2bf7a8b5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f50fb87dabfe93262fabb34950918ca" id="r_a3f50fb87dabfe93262fabb34950918ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a3f50fb87dabfe93262fabb34950918ca">_inputs_swap_needed</a> (mode, shape1, shape2, axes=None)</td></tr>
<tr class="separator:a3f50fb87dabfe93262fabb34950918ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3e49bb19062176206c9e57bf210674" id="r_aef3e49bb19062176206c9e57bf210674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aef3e49bb19062176206c9e57bf210674">correlate</a> (in1, in2, mode='full', method='auto')</td></tr>
<tr class="separator:aef3e49bb19062176206c9e57bf210674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef90bf80f1495a7830b961b1af081b3d" id="r_aef90bf80f1495a7830b961b1af081b3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aef90bf80f1495a7830b961b1af081b3d">correlation_lags</a> (in1_len, in2_len, mode='full')</td></tr>
<tr class="separator:aef90bf80f1495a7830b961b1af081b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9657fa397ab9947a3c9469c87d7286e" id="r_ab9657fa397ab9947a3c9469c87d7286e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ab9657fa397ab9947a3c9469c87d7286e">_centered</a> (arr, newshape)</td></tr>
<tr class="separator:ab9657fa397ab9947a3c9469c87d7286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46476448bd1330985ec891d96be762f" id="r_af46476448bd1330985ec891d96be762f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#af46476448bd1330985ec891d96be762f">_init_freq_conv_axes</a> (in1, in2, mode, axes, sorted_axes=False)</td></tr>
<tr class="separator:af46476448bd1330985ec891d96be762f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8646a8cac7a184c7a4325f319cf1eac3" id="r_a8646a8cac7a184c7a4325f319cf1eac3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a8646a8cac7a184c7a4325f319cf1eac3">_freq_domain_conv</a> (in1, in2, axes, shape, calc_fast_len=False)</td></tr>
<tr class="separator:a8646a8cac7a184c7a4325f319cf1eac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004f73ecf0729f60957ac05f5d928399" id="r_a004f73ecf0729f60957ac05f5d928399"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a004f73ecf0729f60957ac05f5d928399">_apply_conv_mode</a> (ret, <a class="el" href="__lapack__subroutines_8h.html#a3e33b655dd89d6c2d63a122b1175127b">s1</a>, <a class="el" href="__lapack__subroutines_8h.html#a3fb989b8a3df2958b399572ae00bf04f">s2</a>, mode, axes)</td></tr>
<tr class="separator:a004f73ecf0729f60957ac05f5d928399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341b357e73256ed5eaeaacdf148114a5" id="r_a341b357e73256ed5eaeaacdf148114a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a341b357e73256ed5eaeaacdf148114a5">fftconvolve</a> (in1, in2, mode=&quot;full&quot;, axes=None)</td></tr>
<tr class="separator:a341b357e73256ed5eaeaacdf148114a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc64add2d84172585d305fda44f634a9" id="r_abc64add2d84172585d305fda44f634a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#abc64add2d84172585d305fda44f634a9">_calc_oa_lens</a> (<a class="el" href="__lapack__subroutines_8h.html#a3e33b655dd89d6c2d63a122b1175127b">s1</a>, <a class="el" href="__lapack__subroutines_8h.html#a3fb989b8a3df2958b399572ae00bf04f">s2</a>)</td></tr>
<tr class="separator:abc64add2d84172585d305fda44f634a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1fb2e0af80cc502a8e8b140ca459e0" id="r_a3d1fb2e0af80cc502a8e8b140ca459e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a3d1fb2e0af80cc502a8e8b140ca459e0">oaconvolve</a> (in1, in2, mode=&quot;full&quot;, axes=None)</td></tr>
<tr class="separator:a3d1fb2e0af80cc502a8e8b140ca459e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c8d1303a1a85d0867cb7ea296de026" id="r_a64c8d1303a1a85d0867cb7ea296de026"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a64c8d1303a1a85d0867cb7ea296de026">_numeric_arrays</a> (arrays, kinds='buifc')</td></tr>
<tr class="separator:a64c8d1303a1a85d0867cb7ea296de026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0d41452ad99bc2af99b8f653dd208c" id="r_a8a0d41452ad99bc2af99b8f653dd208c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a8a0d41452ad99bc2af99b8f653dd208c">_conv_ops</a> (x_shape, h_shape, mode)</td></tr>
<tr class="separator:a8a0d41452ad99bc2af99b8f653dd208c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499a36bc1ac5be449f1337902573c6fb" id="r_a499a36bc1ac5be449f1337902573c6fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a499a36bc1ac5be449f1337902573c6fb">_fftconv_faster</a> (x, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>, mode)</td></tr>
<tr class="separator:a499a36bc1ac5be449f1337902573c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0027f7137b0079b191f19c7845815c" id="r_aab0027f7137b0079b191f19c7845815c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aab0027f7137b0079b191f19c7845815c">_reverse_and_conj</a> (x)</td></tr>
<tr class="separator:aab0027f7137b0079b191f19c7845815c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc50e7b376d22864d7fdc3a627c4bd00" id="r_acc50e7b376d22864d7fdc3a627c4bd00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#acc50e7b376d22864d7fdc3a627c4bd00">_np_conv_ok</a> (volume, kernel, mode)</td></tr>
<tr class="separator:acc50e7b376d22864d7fdc3a627c4bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc76422dfb7336d1c120bc18287df11" id="r_a1bc76422dfb7336d1c120bc18287df11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a1bc76422dfb7336d1c120bc18287df11">_timeit_fast</a> (stmt=&quot;pass&quot;, setup=&quot;pass&quot;, repeat=3)</td></tr>
<tr class="separator:a1bc76422dfb7336d1c120bc18287df11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff23f43a31650ce89a8557db33c5d802" id="r_aff23f43a31650ce89a8557db33c5d802"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aff23f43a31650ce89a8557db33c5d802">choose_conv_method</a> (in1, in2, mode='full', measure=False)</td></tr>
<tr class="separator:aff23f43a31650ce89a8557db33c5d802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f693a6fea3f35c68bc6bea917167994" id="r_a1f693a6fea3f35c68bc6bea917167994"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a1f693a6fea3f35c68bc6bea917167994">convolve</a> (in1, in2, mode='full', method='auto')</td></tr>
<tr class="separator:a1f693a6fea3f35c68bc6bea917167994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84afe356beb04c096364fde83c7d8620" id="r_a84afe356beb04c096364fde83c7d8620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a84afe356beb04c096364fde83c7d8620">order_filter</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, domain, rank)</td></tr>
<tr class="separator:a84afe356beb04c096364fde83c7d8620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca78832b1bb44de7b1128139b51c600" id="r_a3ca78832b1bb44de7b1128139b51c600"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a3ca78832b1bb44de7b1128139b51c600">medfilt</a> (volume, kernel_size=None)</td></tr>
<tr class="separator:a3ca78832b1bb44de7b1128139b51c600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0476eca003c6c8287ec76e76a593f81" id="r_ad0476eca003c6c8287ec76e76a593f81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ad0476eca003c6c8287ec76e76a593f81">wiener</a> (im, mysize=None, noise=None)</td></tr>
<tr class="separator:ad0476eca003c6c8287ec76e76a593f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce2d3c83c57b7830f4e4c0d5b9f1268" id="r_acce2d3c83c57b7830f4e4c0d5b9f1268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#acce2d3c83c57b7830f4e4c0d5b9f1268">convolve2d</a> (in1, in2, mode='full', boundary='fill', fillvalue=0)</td></tr>
<tr class="separator:acce2d3c83c57b7830f4e4c0d5b9f1268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d836cbe09788ce68bc6ea9d582125d6" id="r_a4d836cbe09788ce68bc6ea9d582125d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a4d836cbe09788ce68bc6ea9d582125d6">correlate2d</a> (in1, in2, mode='full', boundary='fill', fillvalue=0)</td></tr>
<tr class="separator:a4d836cbe09788ce68bc6ea9d582125d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe423fd48568605c095ae8bec922a11c" id="r_abe423fd48568605c095ae8bec922a11c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#abe423fd48568605c095ae8bec922a11c">medfilt2d</a> (input, kernel_size=3)</td></tr>
<tr class="separator:abe423fd48568605c095ae8bec922a11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281ea82fa1b515b6fbdef0001e6fbdee" id="r_a281ea82fa1b515b6fbdef0001e6fbdee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a281ea82fa1b515b6fbdef0001e6fbdee">lfilter</a> (b, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, x, axis=-1, zi=None)</td></tr>
<tr class="separator:a281ea82fa1b515b6fbdef0001e6fbdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171d5cc1c314b8ae733afdbafc3b73b1" id="r_a171d5cc1c314b8ae733afdbafc3b73b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a171d5cc1c314b8ae733afdbafc3b73b1">lfiltic</a> (b, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, y, x=None)</td></tr>
<tr class="separator:a171d5cc1c314b8ae733afdbafc3b73b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226467ed8bc6dbfb08eea5e1e1285d6b" id="r_a226467ed8bc6dbfb08eea5e1e1285d6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a226467ed8bc6dbfb08eea5e1e1285d6b">deconvolve</a> (signal, divisor)</td></tr>
<tr class="separator:a226467ed8bc6dbfb08eea5e1e1285d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855107b383ce065fb67295d5bb0c7dae" id="r_a855107b383ce065fb67295d5bb0c7dae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a855107b383ce065fb67295d5bb0c7dae">hilbert</a> (x, N=None, axis=-1)</td></tr>
<tr class="separator:a855107b383ce065fb67295d5bb0c7dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f6f43cfe12ce0d267487ff8f520b90" id="r_a02f6f43cfe12ce0d267487ff8f520b90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a02f6f43cfe12ce0d267487ff8f520b90">hilbert2</a> (x, N=None)</td></tr>
<tr class="separator:a02f6f43cfe12ce0d267487ff8f520b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276770e9aefe62a7295acb1737465510" id="r_a276770e9aefe62a7295acb1737465510"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a276770e9aefe62a7295acb1737465510">cmplx_sort</a> (p)</td></tr>
<tr class="separator:a276770e9aefe62a7295acb1737465510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a57e100adbc7af239e487a8f22a2bd" id="r_a51a57e100adbc7af239e487a8f22a2bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a51a57e100adbc7af239e487a8f22a2bd">unique_roots</a> (p, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-3, rtype='min')</td></tr>
<tr class="separator:a51a57e100adbc7af239e487a8f22a2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc39c1bf004b27d9d064deb3a6c6ef22" id="r_adc39c1bf004b27d9d064deb3a6c6ef22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#adc39c1bf004b27d9d064deb3a6c6ef22">invres</a> (<a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, p, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-3, rtype='avg')</td></tr>
<tr class="separator:adc39c1bf004b27d9d064deb3a6c6ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8122fab46fd231d319141a6fe6e89c91" id="r_a8122fab46fd231d319141a6fe6e89c91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a8122fab46fd231d319141a6fe6e89c91">_compute_factors</a> (roots, multiplicity, include_powers=False)</td></tr>
<tr class="separator:a8122fab46fd231d319141a6fe6e89c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e07da4632146265b7aa412c79ecf82" id="r_a13e07da4632146265b7aa412c79ecf82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a13e07da4632146265b7aa412c79ecf82">_compute_residues</a> (<a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>, multiplicity, numerator)</td></tr>
<tr class="separator:a13e07da4632146265b7aa412c79ecf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4286911a4ce17dcee1288cdcaf873d" id="r_a8c4286911a4ce17dcee1288cdcaf873d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a8c4286911a4ce17dcee1288cdcaf873d">residue</a> (b, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-3, rtype='avg')</td></tr>
<tr class="separator:a8c4286911a4ce17dcee1288cdcaf873d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86de701cb1667df120fbb8c8cab0deda" id="r_a86de701cb1667df120fbb8c8cab0deda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a86de701cb1667df120fbb8c8cab0deda">residuez</a> (b, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-3, rtype='avg')</td></tr>
<tr class="separator:a86de701cb1667df120fbb8c8cab0deda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a741c5ce9696b31934388c7391f78f0" id="r_a5a741c5ce9696b31934388c7391f78f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a5a741c5ce9696b31934388c7391f78f0">_group_poles</a> (<a class="el" href="__lapack__subroutines_8h.html#a8b878edb617ee8c049d6566afaa7d9f7">poles</a>, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>, rtype)</td></tr>
<tr class="separator:a5a741c5ce9696b31934388c7391f78f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d5f11397e42a0fa2ec7499a8ee9a99" id="r_af3d5f11397e42a0fa2ec7499a8ee9a99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#af3d5f11397e42a0fa2ec7499a8ee9a99">invresz</a> (<a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, p, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-3, rtype='avg')</td></tr>
<tr class="separator:af3d5f11397e42a0fa2ec7499a8ee9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf97912d53105ef880c3f6bdf44396" id="r_af3cf97912d53105ef880c3f6bdf44396"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#af3cf97912d53105ef880c3f6bdf44396">resample</a> (x, num, t=None, axis=0, window=None, domain='time')</td></tr>
<tr class="separator:af3cf97912d53105ef880c3f6bdf44396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c8fd225e6045b551653f623aa6ae1c" id="r_af7c8fd225e6045b551653f623aa6ae1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#af7c8fd225e6045b551653f623aa6ae1c">resample_poly</a> (x, up, down, axis=0, window=('kaiser', 5.0), padtype='constant', cval=None)</td></tr>
<tr class="separator:af7c8fd225e6045b551653f623aa6ae1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79923863872e25bc09509a9255d46250" id="r_a79923863872e25bc09509a9255d46250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a79923863872e25bc09509a9255d46250">vectorstrength</a> (events, period)</td></tr>
<tr class="separator:a79923863872e25bc09509a9255d46250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d71cde110198d9f3fb485301d42aa7" id="r_ac2d71cde110198d9f3fb485301d42aa7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a> (data, axis=-1, type='linear', <a class="el" href="__lapack__subroutines_8h.html#a408f6b40c17f54fa6cdce84d9b09deec">bp</a>=0, overwrite_data=False)</td></tr>
<tr class="separator:ac2d71cde110198d9f3fb485301d42aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca181b2c9b4293e589a8cc8ca5992e4d" id="r_aca181b2c9b4293e589a8cc8ca5992e4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aca181b2c9b4293e589a8cc8ca5992e4d">lfilter_zi</a> (b, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:aca181b2c9b4293e589a8cc8ca5992e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17f7e5a5e127ec7e05820383db98847" id="r_aa17f7e5a5e127ec7e05820383db98847"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aa17f7e5a5e127ec7e05820383db98847">sosfilt_zi</a> (sos)</td></tr>
<tr class="separator:aa17f7e5a5e127ec7e05820383db98847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3b6596e838e1fcedda88dfe1cb7991" id="r_a1e3b6596e838e1fcedda88dfe1cb7991"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a1e3b6596e838e1fcedda88dfe1cb7991">_filtfilt_gust</a> (b, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, x, axis=-1, irlen=None)</td></tr>
<tr class="separator:a1e3b6596e838e1fcedda88dfe1cb7991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d5f7aec84133cbe6e52468d23c5e1f" id="r_ad5d5f7aec84133cbe6e52468d23c5e1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ad5d5f7aec84133cbe6e52468d23c5e1f">filtfilt</a> (b, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, x, axis=-1, padtype='odd', padlen=None, method='pad', irlen=None)</td></tr>
<tr class="separator:ad5d5f7aec84133cbe6e52468d23c5e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae68840e64243ec742a4867e7394e03" id="r_a5ae68840e64243ec742a4867e7394e03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a5ae68840e64243ec742a4867e7394e03">_validate_pad</a> (padtype, padlen, x, axis, ntaps)</td></tr>
<tr class="separator:a5ae68840e64243ec742a4867e7394e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b69f12c02e5d1278ee04311753a587" id="r_ac6b69f12c02e5d1278ee04311753a587"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#ac6b69f12c02e5d1278ee04311753a587">_validate_x</a> (x)</td></tr>
<tr class="separator:ac6b69f12c02e5d1278ee04311753a587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dc9f97985577063e15be92871e7d2d" id="r_a40dc9f97985577063e15be92871e7d2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a40dc9f97985577063e15be92871e7d2d">sosfilt</a> (sos, x, axis=-1, zi=None)</td></tr>
<tr class="separator:a40dc9f97985577063e15be92871e7d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b62559ed41c43b059b669a2da526c4" id="r_aa3b62559ed41c43b059b669a2da526c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#aa3b62559ed41c43b059b669a2da526c4">sosfiltfilt</a> (sos, x, axis=-1, padtype='odd', padlen=None)</td></tr>
<tr class="separator:aa3b62559ed41c43b059b669a2da526c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bc89ac2894b85d89c68fb3ae2b346c" id="r_a64bc89ac2894b85d89c68fb3ae2b346c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a64bc89ac2894b85d89c68fb3ae2b346c">decimate</a> (x, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, ftype='iir', axis=-1, zero_phase=True)</td></tr>
<tr class="separator:a64bc89ac2894b85d89c68fb3ae2b346c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a69b1e186f46823dbde0944345c69e2e9" id="r_a69b1e186f46823dbde0944345c69e2e9"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a69b1e186f46823dbde0944345c69e2e9">_modedict</a> = {'valid': 0, 'same': 1, 'full': 2}</td></tr>
<tr class="separator:a69b1e186f46823dbde0944345c69e2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8b8d1a93c3a15e771f42a2a5b5bfe4" id="r_a3c8b8d1a93c3a15e771f42a2a5b5bfe4"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__signaltools.html#a3c8b8d1a93c3a15e771f42a2a5b5bfe4">_boundarydict</a></td></tr>
<tr class="separator:a3c8b8d1a93c3a15e771f42a2a5b5bfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a004f73ecf0729f60957ac05f5d928399" name="a004f73ecf0729f60957ac05f5d928399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004f73ecf0729f60957ac05f5d928399">&#9670;&#160;</a></span>_apply_conv_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._apply_conv_mode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate the convolution result shape based on the `mode` argument.

Returns the result sliced to the correct size for the given mode.

Parameters
----------
ret : array
    The result array, with the appropriate shape for the 'full' mode.
s1 : list of int
    The shape of the first input.
s2 : list of int
    The shape of the second input.
mode : str {'full', 'valid', 'same'}
    A string indicating the size of the output.
    See the documentation `fftconvolve` for more information.
axes : list of ints
    Axes over which to compute the convolution.

Returns
-------
ret : array
    A copy of `res`, sliced to the correct size for the given `mode`.</pre> <div class="fragment"><div class="line"><span class="lineno">  517</span><span class="keyword">def </span>_apply_conv_mode(ret, s1, s2, mode, axes):</div>
<div class="line"><span class="lineno">  518</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the convolution result shape based on the `mode` argument.</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    Returns the result sliced to the correct size for the given mode.</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    ret : array</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">        The result array, with the appropriate shape for the &#39;full&#39; mode.</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    s1 : list of int</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        The shape of the first input.</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    s2 : list of int</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        The shape of the second input.</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        A string indicating the size of the output.</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        See the documentation `fftconvolve` for more information.</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    axes : list of ints</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        Axes over which to compute the convolution.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    ret : array</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">        A copy of `res`, sliced to the correct size for the given `mode`.</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  542</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;full&quot;</span>:</div>
<div class="line"><span class="lineno">  543</span>        <span class="keywordflow">return</span> ret.copy()</div>
<div class="line"><span class="lineno">  544</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;same&quot;</span>:</div>
<div class="line"><span class="lineno">  545</span>        <span class="keywordflow">return</span> _centered(ret, s1).copy()</div>
<div class="line"><span class="lineno">  546</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;valid&quot;</span>:</div>
<div class="line"><span class="lineno">  547</span>        shape_valid = [ret.shape[a] <span class="keywordflow">if</span> a <span class="keywordflow">not</span> <span class="keywordflow">in</span> axes <span class="keywordflow">else</span> s1[a] - s2[a] + 1</div>
<div class="line"><span class="lineno">  548</span>                       <span class="keywordflow">for</span> a <span class="keywordflow">in</span> range(ret.ndim)]</div>
<div class="line"><span class="lineno">  549</span>        <span class="keywordflow">return</span> _centered(ret, shape_valid).copy()</div>
<div class="line"><span class="lineno">  550</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  551</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;acceptable mode flags are &#39;valid&#39;,&quot;</span></div>
<div class="line"><span class="lineno">  552</span>                         <span class="stringliteral">&quot; &#39;same&#39;, or &#39;full&#39;&quot;</span>)</div>
<div class="line"><span class="lineno">  553</span> </div>
<div class="line"><span class="lineno">  554</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9135e147844856870d2fa2bf7a8b5c7" name="aa9135e147844856870d2fa2bf7a8b5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9135e147844856870d2fa2bf7a8b5c7">&#9670;&#160;</a></span>_bvalfromboundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._bvalfromboundary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>boundary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   48</span><span class="keyword">def </span>_bvalfromboundary(boundary):</div>
<div class="line"><span class="lineno">   49</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   50</span>        <span class="keywordflow">return</span> _boundarydict[boundary] &lt;&lt; 2</div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordflow">except</span> KeyError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">   52</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Acceptable boundary flags are &#39;fill&#39;, &#39;circular&#39; &quot;</span></div>
<div class="line"><span class="lineno">   53</span>                         <span class="stringliteral">&quot;(or &#39;wrap&#39;), and &#39;symmetric&#39; (or &#39;symm&#39;).&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abc64add2d84172585d305fda44f634a9" name="abc64add2d84172585d305fda44f634a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc64add2d84172585d305fda44f634a9">&#9670;&#160;</a></span>_calc_oa_lens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._calc_oa_lens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate the optimal FFT lengths for overlapp-add convolution.

The calculation is done for a single dimension.

Parameters
----------
s1 : int
    Size of the dimension for the first array.
s2 : int
    Size of the dimension for the second array.

Returns
-------
block_size : int
    The size of the FFT blocks.
overlap : int
    The amount of overlap between two blocks.
in1_step : int
    The size of each step for the first array.
in2_step : int
    The size of each step for the first array.</pre> <div class="fragment"><div class="line"><span class="lineno">  672</span><span class="keyword">def </span>_calc_oa_lens(s1, s2):</div>
<div class="line"><span class="lineno">  673</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the optimal FFT lengths for overlapp-add convolution.</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    The calculation is done for a single dimension.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    s1 : int</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">        Size of the dimension for the first array.</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    s2 : int</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">        Size of the dimension for the second array.</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    block_size : int</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        The size of the FFT blocks.</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    overlap : int</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">        The amount of overlap between two blocks.</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    in1_step : int</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">        The size of each step for the first array.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    in2_step : int</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">        The size of each step for the first array.</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  696</span>    <span class="comment"># Set up the arguments for the conventional FFT approach.</span></div>
<div class="line"><span class="lineno">  697</span>    fallback = (s1+s2-1, <span class="keywordtype">None</span>, s1, s2)</div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>    <span class="comment"># Use conventional FFT convolve if sizes are same.</span></div>
<div class="line"><span class="lineno">  700</span>    <span class="keywordflow">if</span> s1 == s2 <span class="keywordflow">or</span> s1 == 1 <span class="keywordflow">or</span> s2 == 1:</div>
<div class="line"><span class="lineno">  701</span>        <span class="keywordflow">return</span> fallback</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <span class="keywordflow">if</span> s2 &gt; s1:</div>
<div class="line"><span class="lineno">  704</span>        s1, s2 = s2, s1</div>
<div class="line"><span class="lineno">  705</span>        swapped = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  706</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  707</span>        swapped = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  708</span> </div>
<div class="line"><span class="lineno">  709</span>    <span class="comment"># There cannot be a useful block size if s2 is more than half of s1.</span></div>
<div class="line"><span class="lineno">  710</span>    <span class="keywordflow">if</span> s2 &gt;= s1/2:</div>
<div class="line"><span class="lineno">  711</span>        <span class="keywordflow">return</span> fallback</div>
<div class="line"><span class="lineno">  712</span> </div>
<div class="line"><span class="lineno">  713</span>    <span class="comment"># Derivation of optimal block length</span></div>
<div class="line"><span class="lineno">  714</span>    <span class="comment"># For original formula see:</span></div>
<div class="line"><span class="lineno">  715</span>    <span class="comment"># https://en.wikipedia.org/wiki/Overlap-add_method</span></div>
<div class="line"><span class="lineno">  716</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  717</span>    <span class="comment"># Formula:</span></div>
<div class="line"><span class="lineno">  718</span>    <span class="comment"># K = overlap = s2-1</span></div>
<div class="line"><span class="lineno">  719</span>    <span class="comment"># N = block_size</span></div>
<div class="line"><span class="lineno">  720</span>    <span class="comment"># C = complexity</span></div>
<div class="line"><span class="lineno">  721</span>    <span class="comment"># e = exponential, exp(1)</span></div>
<div class="line"><span class="lineno">  722</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  723</span>    <span class="comment"># C = (N*(log2(N)+1))/(N-K)</span></div>
<div class="line"><span class="lineno">  724</span>    <span class="comment"># C = (N*log2(2N))/(N-K)</span></div>
<div class="line"><span class="lineno">  725</span>    <span class="comment"># C = N/(N-K) * log2(2N)</span></div>
<div class="line"><span class="lineno">  726</span>    <span class="comment"># C1 = N/(N-K)</span></div>
<div class="line"><span class="lineno">  727</span>    <span class="comment"># C2 = log2(2N) = ln(2N)/ln(2)</span></div>
<div class="line"><span class="lineno">  728</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  729</span>    <span class="comment"># dC1/dN = (1*(N-K)-N)/(N-K)^2 = -K/(N-K)^2</span></div>
<div class="line"><span class="lineno">  730</span>    <span class="comment"># dC2/dN = 2/(2*N*ln(2)) = 1/(N*ln(2))</span></div>
<div class="line"><span class="lineno">  731</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  732</span>    <span class="comment"># dC/dN = dC1/dN*C2 + dC2/dN*C1</span></div>
<div class="line"><span class="lineno">  733</span>    <span class="comment"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + N/(N*ln(2)*(N-K))</span></div>
<div class="line"><span class="lineno">  734</span>    <span class="comment"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + 1/(ln(2)*(N-K))</span></div>
<div class="line"><span class="lineno">  735</span>    <span class="comment"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + (N-K)/(ln(2)*(N-K)^2)</span></div>
<div class="line"><span class="lineno">  736</span>    <span class="comment"># dC/dN = (-K*ln(2N) + (N-K)/(ln(2)*(N-K)^2)</span></div>
<div class="line"><span class="lineno">  737</span>    <span class="comment"># dC/dN = (N - K*ln(2N) - K)/(ln(2)*(N-K)^2)</span></div>
<div class="line"><span class="lineno">  738</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  739</span>    <span class="comment"># Solve for minimum, where dC/dN = 0</span></div>
<div class="line"><span class="lineno">  740</span>    <span class="comment"># 0 = (N - K*ln(2N) - K)/(ln(2)*(N-K)^2)</span></div>
<div class="line"><span class="lineno">  741</span>    <span class="comment"># 0 * ln(2)*(N-K)^2 = N - K*ln(2N) - K</span></div>
<div class="line"><span class="lineno">  742</span>    <span class="comment"># 0 = N - K*ln(2N) - K</span></div>
<div class="line"><span class="lineno">  743</span>    <span class="comment"># 0 = N - K*(ln(2N) + 1)</span></div>
<div class="line"><span class="lineno">  744</span>    <span class="comment"># 0 = N - K*ln(2Ne)</span></div>
<div class="line"><span class="lineno">  745</span>    <span class="comment"># N = K*ln(2Ne)</span></div>
<div class="line"><span class="lineno">  746</span>    <span class="comment"># N/K = ln(2Ne)</span></div>
<div class="line"><span class="lineno">  747</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  748</span>    <span class="comment"># e^(N/K) = e^ln(2Ne)</span></div>
<div class="line"><span class="lineno">  749</span>    <span class="comment"># e^(N/K) = 2Ne</span></div>
<div class="line"><span class="lineno">  750</span>    <span class="comment"># 1/e^(N/K) = 1/(2*N*e)</span></div>
<div class="line"><span class="lineno">  751</span>    <span class="comment"># e^(N/-K) = 1/(2*N*e)</span></div>
<div class="line"><span class="lineno">  752</span>    <span class="comment"># e^(N/-K) = K/N*1/(2*K*e)</span></div>
<div class="line"><span class="lineno">  753</span>    <span class="comment"># N/K*e^(N/-K) = 1/(2*e*K)</span></div>
<div class="line"><span class="lineno">  754</span>    <span class="comment"># N/-K*e^(N/-K) = -1/(2*e*K)</span></div>
<div class="line"><span class="lineno">  755</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  756</span>    <span class="comment"># Using Lambert W function</span></div>
<div class="line"><span class="lineno">  757</span>    <span class="comment"># https://en.wikipedia.org/wiki/Lambert_W_function</span></div>
<div class="line"><span class="lineno">  758</span>    <span class="comment"># x = W(y) It is the solution to y = x*e^x</span></div>
<div class="line"><span class="lineno">  759</span>    <span class="comment"># x = N/-K</span></div>
<div class="line"><span class="lineno">  760</span>    <span class="comment"># y = -1/(2*e*K)</span></div>
<div class="line"><span class="lineno">  761</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  762</span>    <span class="comment"># N/-K = W(-1/(2*e*K))</span></div>
<div class="line"><span class="lineno">  763</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno">  764</span>    <span class="comment"># N = -K*W(-1/(2*e*K))</span></div>
<div class="line"><span class="lineno">  765</span>    overlap = s2-1</div>
<div class="line"><span class="lineno">  766</span>    opt_size = -overlap*lambertw(-1/(2*math.e*overlap), k=-1).real</div>
<div class="line"><span class="lineno">  767</span>    block_size = sp_fft.next_fast_len(math.ceil(opt_size))</div>
<div class="line"><span class="lineno">  768</span> </div>
<div class="line"><span class="lineno">  769</span>    <span class="comment"># Use conventional FFT convolve if there is only going to be one block.</span></div>
<div class="line"><span class="lineno">  770</span>    <span class="keywordflow">if</span> block_size &gt;= s1:</div>
<div class="line"><span class="lineno">  771</span>        <span class="keywordflow">return</span> fallback</div>
<div class="line"><span class="lineno">  772</span> </div>
<div class="line"><span class="lineno">  773</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> swapped:</div>
<div class="line"><span class="lineno">  774</span>        in1_step = block_size-s2+1</div>
<div class="line"><span class="lineno">  775</span>        in2_step = s2</div>
<div class="line"><span class="lineno">  776</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  777</span>        in1_step = s2</div>
<div class="line"><span class="lineno">  778</span>        in2_step = block_size-s2+1</div>
<div class="line"><span class="lineno">  779</span> </div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">return</span> block_size, overlap, in1_step, in2_step</div>
<div class="line"><span class="lineno">  781</span> </div>
<div class="line"><span class="lineno">  782</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9657fa397ab9947a3c9469c87d7286e" name="ab9657fa397ab9947a3c9469c87d7286e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9657fa397ab9947a3c9469c87d7286e">&#9670;&#160;</a></span>_centered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._centered </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  386</span><span class="keyword">def </span>_centered(arr, newshape):</div>
<div class="line"><span class="lineno">  387</span>    <span class="comment"># Return the center newshape portion of the array.</span></div>
<div class="line"><span class="lineno">  388</span>    newshape = np.asarray(newshape)</div>
<div class="line"><span class="lineno">  389</span>    currshape = np.array(arr.shape)</div>
<div class="line"><span class="lineno">  390</span>    startind = (currshape - newshape) // 2</div>
<div class="line"><span class="lineno">  391</span>    endind = startind + newshape</div>
<div class="line"><span class="lineno">  392</span>    myslice = [slice(startind[k], endind[k]) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(len(endind))]</div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">return</span> arr[tuple(myslice)]</div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8122fab46fd231d319141a6fe6e89c91" name="a8122fab46fd231d319141a6fe6e89c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8122fab46fd231d319141a6fe6e89c91">&#9670;&#160;</a></span>_compute_factors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._compute_factors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>include_powers</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the total polynomial divided by factors for each root.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2574</span><span class="keyword">def </span>_compute_factors(roots, multiplicity, include_powers=False):</div>
<div class="line"><span class="lineno"> 2575</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the total polynomial divided by factors for each root.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2576</span>    current = np.array([1])</div>
<div class="line"><span class="lineno"> 2577</span>    suffixes = [current]</div>
<div class="line"><span class="lineno"> 2578</span>    <span class="keywordflow">for</span> pole, mult <span class="keywordflow">in</span> zip(roots[-1:0:-1], multiplicity[-1:0:-1]):</div>
<div class="line"><span class="lineno"> 2579</span>        monomial = np.array([1, -pole])</div>
<div class="line"><span class="lineno"> 2580</span>        <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(mult):</div>
<div class="line"><span class="lineno"> 2581</span>            current = np.polymul(current, monomial)</div>
<div class="line"><span class="lineno"> 2582</span>        suffixes.append(current)</div>
<div class="line"><span class="lineno"> 2583</span>    suffixes = suffixes[::-1]</div>
<div class="line"><span class="lineno"> 2584</span> </div>
<div class="line"><span class="lineno"> 2585</span>    factors = []</div>
<div class="line"><span class="lineno"> 2586</span>    current = np.array([1])</div>
<div class="line"><span class="lineno"> 2587</span>    <span class="keywordflow">for</span> pole, mult, suffix <span class="keywordflow">in</span> zip(roots, multiplicity, suffixes):</div>
<div class="line"><span class="lineno"> 2588</span>        monomial = np.array([1, -pole])</div>
<div class="line"><span class="lineno"> 2589</span>        block = []</div>
<div class="line"><span class="lineno"> 2590</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(mult):</div>
<div class="line"><span class="lineno"> 2591</span>            <span class="keywordflow">if</span> i == 0 <span class="keywordflow">or</span> include_powers:</div>
<div class="line"><span class="lineno"> 2592</span>                block.append(np.polymul(current, suffix))</div>
<div class="line"><span class="lineno"> 2593</span>            current = np.polymul(current, monomial)</div>
<div class="line"><span class="lineno"> 2594</span>        factors.extend(reversed(block))</div>
<div class="line"><span class="lineno"> 2595</span> </div>
<div class="line"><span class="lineno"> 2596</span>    <span class="keywordflow">return</span> factors, current</div>
<div class="line"><span class="lineno"> 2597</span> </div>
<div class="line"><span class="lineno"> 2598</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a13e07da4632146265b7aa412c79ecf82" name="a13e07da4632146265b7aa412c79ecf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e07da4632146265b7aa412c79ecf82">&#9670;&#160;</a></span>_compute_residues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._compute_residues </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiplicity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numerator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2599</span><span class="keyword">def </span>_compute_residues(poles, multiplicity, numerator):</div>
<div class="line"><span class="lineno"> 2600</span>    denominator_factors, _ = _compute_factors(poles, multiplicity)</div>
<div class="line"><span class="lineno"> 2601</span>    numerator = numerator.astype(poles.dtype)</div>
<div class="line"><span class="lineno"> 2602</span> </div>
<div class="line"><span class="lineno"> 2603</span>    residues = []</div>
<div class="line"><span class="lineno"> 2604</span>    <span class="keywordflow">for</span> pole, mult, factor <span class="keywordflow">in</span> zip(poles, multiplicity,</div>
<div class="line"><span class="lineno"> 2605</span>                                  denominator_factors):</div>
<div class="line"><span class="lineno"> 2606</span>        <span class="keywordflow">if</span> mult == 1:</div>
<div class="line"><span class="lineno"> 2607</span>            residues.append(np.polyval(numerator, pole) /</div>
<div class="line"><span class="lineno"> 2608</span>                            np.polyval(factor, pole))</div>
<div class="line"><span class="lineno"> 2609</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2610</span>            numer = numerator.copy()</div>
<div class="line"><span class="lineno"> 2611</span>            monomial = np.array([1, -pole])</div>
<div class="line"><span class="lineno"> 2612</span>            factor, d = np.polydiv(factor, monomial)</div>
<div class="line"><span class="lineno"> 2613</span> </div>
<div class="line"><span class="lineno"> 2614</span>            block = []</div>
<div class="line"><span class="lineno"> 2615</span>            <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(mult):</div>
<div class="line"><span class="lineno"> 2616</span>                numer, n = np.polydiv(numer, monomial)</div>
<div class="line"><span class="lineno"> 2617</span>                r = n[0] / d[0]</div>
<div class="line"><span class="lineno"> 2618</span>                numer = np.polysub(numer, r * factor)</div>
<div class="line"><span class="lineno"> 2619</span>                block.append(r)</div>
<div class="line"><span class="lineno"> 2620</span> </div>
<div class="line"><span class="lineno"> 2621</span>            residues.extend(reversed(block))</div>
<div class="line"><span class="lineno"> 2622</span> </div>
<div class="line"><span class="lineno"> 2623</span>    <span class="keywordflow">return</span> np.asarray(residues)</div>
<div class="line"><span class="lineno"> 2624</span> </div>
<div class="line"><span class="lineno"> 2625</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a0d41452ad99bc2af99b8f653dd208c" name="a8a0d41452ad99bc2af99b8f653dd208c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0d41452ad99bc2af99b8f653dd208c">&#9670;&#160;</a></span>_conv_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._conv_ops </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Find the number of operations required for direct/fft methods of
convolution. The direct operations were recorded by making a dummy class to
record the number of operations by overriding ``__mul__`` and ``__add__``.
The FFT operations rely on the (well-known) computational complexity of the
FFT (and the implementation of ``_freq_domain_conv``).</pre> <div class="fragment"><div class="line"><span class="lineno"> 1011</span><span class="keyword">def </span>_conv_ops(x_shape, h_shape, mode):</div>
<div class="line"><span class="lineno"> 1012</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    Find the number of operations required for direct/fft methods of</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    convolution. The direct operations were recorded by making a dummy class to</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    record the number of operations by overriding ``__mul__`` and ``__add__``.</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    The FFT operations rely on the (well-known) computational complexity of the</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    FFT (and the implementation of ``_freq_domain_conv``).</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1020</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;full&quot;</span>:</div>
<div class="line"><span class="lineno"> 1021</span>        out_shape = [n + k - 1 <span class="keywordflow">for</span> n, k <span class="keywordflow">in</span> zip(x_shape, h_shape)]</div>
<div class="line"><span class="lineno"> 1022</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;valid&quot;</span>:</div>
<div class="line"><span class="lineno"> 1023</span>        out_shape = [abs(n - k) + 1 <span class="keywordflow">for</span> n, k <span class="keywordflow">in</span> zip(x_shape, h_shape)]</div>
<div class="line"><span class="lineno"> 1024</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;same&quot;</span>:</div>
<div class="line"><span class="lineno"> 1025</span>        out_shape = x_shape</div>
<div class="line"><span class="lineno"> 1026</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1027</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span></div>
<div class="line"><span class="lineno"> 1028</span>                         <span class="stringliteral">&quot; &#39;same&#39;, or &#39;full&#39;, not mode={}&quot;</span>.format(mode))</div>
<div class="line"><span class="lineno"> 1029</span> </div>
<div class="line"><span class="lineno"> 1030</span>    s1, s2 = x_shape, h_shape</div>
<div class="line"><span class="lineno"> 1031</span>    <span class="keywordflow">if</span> len(x_shape) == 1:</div>
<div class="line"><span class="lineno"> 1032</span>        s1, s2 = s1[0], s2[0]</div>
<div class="line"><span class="lineno"> 1033</span>        <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;full&quot;</span>:</div>
<div class="line"><span class="lineno"> 1034</span>            direct_ops = s1 * s2</div>
<div class="line"><span class="lineno"> 1035</span>        <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;valid&quot;</span>:</div>
<div class="line"><span class="lineno"> 1036</span>            direct_ops = (s2 - s1 + 1) * s1 <span class="keywordflow">if</span> s2 &gt;= s1 <span class="keywordflow">else</span> (s1 - s2 + 1) * s2</div>
<div class="line"><span class="lineno"> 1037</span>        <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;same&quot;</span>:</div>
<div class="line"><span class="lineno"> 1038</span>            direct_ops = (s1 * s2 <span class="keywordflow">if</span> s1 &lt; s2 <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1039</span>                          s1 * s2 - (s2 // 2) * ((s2 + 1) // 2))</div>
<div class="line"><span class="lineno"> 1040</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1041</span>        <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;full&quot;</span>:</div>
<div class="line"><span class="lineno"> 1042</span>            direct_ops = min(_prod(s1), _prod(s2)) * _prod(out_shape)</div>
<div class="line"><span class="lineno"> 1043</span>        <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;valid&quot;</span>:</div>
<div class="line"><span class="lineno"> 1044</span>            direct_ops = min(_prod(s1), _prod(s2)) * _prod(out_shape)</div>
<div class="line"><span class="lineno"> 1045</span>        <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;same&quot;</span>:</div>
<div class="line"><span class="lineno"> 1046</span>            direct_ops = _prod(s1) * _prod(s2)</div>
<div class="line"><span class="lineno"> 1047</span> </div>
<div class="line"><span class="lineno"> 1048</span>    full_out_shape = [n + k - 1 <span class="keywordflow">for</span> n, k <span class="keywordflow">in</span> zip(x_shape, h_shape)]</div>
<div class="line"><span class="lineno"> 1049</span>    N = _prod(full_out_shape)</div>
<div class="line"><span class="lineno"> 1050</span>    fft_ops = 3 * N * np.log(N)  <span class="comment"># 3 separate FFTs of size full_out_shape</span></div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">return</span> fft_ops, direct_ops</div>
<div class="line"><span class="lineno"> 1052</span> </div>
<div class="line"><span class="lineno"> 1053</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a499a36bc1ac5be449f1337902573c6fb" name="a499a36bc1ac5be449f1337902573c6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499a36bc1ac5be449f1337902573c6fb">&#9670;&#160;</a></span>_fftconv_faster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._fftconv_faster </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">See if using fftconvolve or convolve is faster.

Parameters
----------
x : np.ndarray
    Signal
h : np.ndarray
    Kernel
mode : str
    Mode passed to convolve

Returns
-------
fft_faster : bool

Notes
-----
See docstring of `choose_conv_method` for details on tuning hardware.

See pull request 11031 for more detail:
https://github.com/scipy/scipy/pull/11031.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1054</span><span class="keyword">def </span>_fftconv_faster(x, h, mode):</div>
<div class="line"><span class="lineno"> 1055</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">    See if using fftconvolve or convolve is faster.</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    x : np.ndarray</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">        Signal</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    h : np.ndarray</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">        Kernel</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">    mode : str</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">        Mode passed to convolve</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    fft_faster : bool</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    See docstring of `choose_conv_method` for details on tuning hardware.</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    See pull request 11031 for more detail:</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">    https://github.com/scipy/scipy/pull/11031.</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1079</span>    fft_ops, direct_ops = _conv_ops(x.shape, h.shape, mode)</div>
<div class="line"><span class="lineno"> 1080</span>    offset = -1e-3 <span class="keywordflow">if</span> x.ndim == 1 <span class="keywordflow">else</span> -1e-4</div>
<div class="line"><span class="lineno"> 1081</span>    constants = {</div>
<div class="line"><span class="lineno"> 1082</span>            <span class="stringliteral">&quot;valid&quot;</span>: (1.89095737e-9, 2.1364985e-10, offset),</div>
<div class="line"><span class="lineno"> 1083</span>            <span class="stringliteral">&quot;full&quot;</span>: (1.7649070e-9, 2.1414831e-10, offset),</div>
<div class="line"><span class="lineno"> 1084</span>            <span class="stringliteral">&quot;same&quot;</span>: (3.2646654e-9, 2.8478277e-10, offset)</div>
<div class="line"><span class="lineno"> 1085</span>            <span class="keywordflow">if</span> h.size &lt;= x.size</div>
<div class="line"><span class="lineno"> 1086</span>            <span class="keywordflow">else</span> (3.21635404e-9, 1.1773253e-8, -1e-5),</div>
<div class="line"><span class="lineno"> 1087</span>    } <span class="keywordflow">if</span> x.ndim == 1 <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1088</span>            <span class="stringliteral">&quot;valid&quot;</span>: (1.85927e-9, 2.11242e-8, offset),</div>
<div class="line"><span class="lineno"> 1089</span>            <span class="stringliteral">&quot;full&quot;</span>: (1.99817e-9, 1.66174e-8, offset),</div>
<div class="line"><span class="lineno"> 1090</span>            <span class="stringliteral">&quot;same&quot;</span>: (2.04735e-9, 1.55367e-8, offset),</div>
<div class="line"><span class="lineno"> 1091</span>    }</div>
<div class="line"><span class="lineno"> 1092</span>    O_fft, O_direct, O_offset = constants[mode]</div>
<div class="line"><span class="lineno"> 1093</span>    <span class="keywordflow">return</span> O_fft * fft_ops &lt; O_direct * direct_ops + O_offset</div>
<div class="line"><span class="lineno"> 1094</span> </div>
<div class="line"><span class="lineno"> 1095</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e3b6596e838e1fcedda88dfe1cb7991" name="a1e3b6596e838e1fcedda88dfe1cb7991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3b6596e838e1fcedda88dfe1cb7991">&#9670;&#160;</a></span>_filtfilt_gust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._filtfilt_gust </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>irlen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Forward-backward IIR filter that uses Gustafsson's method.

Apply the IIR filter defined by `(b,a)` to `x` twice, first forward
then backward, using Gustafsson's initial conditions [1]_.

Let ``y_fb`` be the result of filtering first forward and then backward,
and let ``y_bf`` be the result of filtering first backward then forward.
Gustafsson's method is to compute initial conditions for the forward
pass and the backward pass such that ``y_fb == y_bf``.

Parameters
----------
b : scalar or 1-D ndarray
    Numerator coefficients of the filter.
a : scalar or 1-D ndarray
    Denominator coefficients of the filter.
x : ndarray
    Data to be filtered.
axis : int, optional
    Axis of `x` to be filtered.  Default is -1.
irlen : int or None, optional
    The length of the nonnegligible part of the impulse response.
    If `irlen` is None, or if the length of the signal is less than
    ``2 * irlen``, then no part of the impulse response is ignored.

Returns
-------
y : ndarray
    The filtered data.
x0 : ndarray
    Initial condition for the forward filter.
x1 : ndarray
    Initial condition for the backward filter.

Notes
-----
Typically the return values `x0` and `x1` are not needed by the
caller.  The intended use of these return values is in unit tests.

References
----------
.. [1] F. Gustaffson. Determining the initial states in forward-backward
       filtering. Transactions on Signal Processing, 46(4):988-992, 1996.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3725</span><span class="keyword">def </span>_filtfilt_gust(b, a, x, axis=-1, irlen=None):</div>
<div class="line"><span class="lineno"> 3726</span>    <span class="stringliteral">&quot;&quot;&quot;Forward-backward IIR filter that uses Gustafsson&#39;s method.</span></div>
<div class="line"><span class="lineno"> 3727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3728</span><span class="stringliteral">    Apply the IIR filter defined by `(b,a)` to `x` twice, first forward</span></div>
<div class="line"><span class="lineno"> 3729</span><span class="stringliteral">    then backward, using Gustafsson&#39;s initial conditions [1]_.</span></div>
<div class="line"><span class="lineno"> 3730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3731</span><span class="stringliteral">    Let ``y_fb`` be the result of filtering first forward and then backward,</span></div>
<div class="line"><span class="lineno"> 3732</span><span class="stringliteral">    and let ``y_bf`` be the result of filtering first backward then forward.</span></div>
<div class="line"><span class="lineno"> 3733</span><span class="stringliteral">    Gustafsson&#39;s method is to compute initial conditions for the forward</span></div>
<div class="line"><span class="lineno"> 3734</span><span class="stringliteral">    pass and the backward pass such that ``y_fb == y_bf``.</span></div>
<div class="line"><span class="lineno"> 3735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3736</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3737</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3738</span><span class="stringliteral">    b : scalar or 1-D ndarray</span></div>
<div class="line"><span class="lineno"> 3739</span><span class="stringliteral">        Numerator coefficients of the filter.</span></div>
<div class="line"><span class="lineno"> 3740</span><span class="stringliteral">    a : scalar or 1-D ndarray</span></div>
<div class="line"><span class="lineno"> 3741</span><span class="stringliteral">        Denominator coefficients of the filter.</span></div>
<div class="line"><span class="lineno"> 3742</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno"> 3743</span><span class="stringliteral">        Data to be filtered.</span></div>
<div class="line"><span class="lineno"> 3744</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3745</span><span class="stringliteral">        Axis of `x` to be filtered.  Default is -1.</span></div>
<div class="line"><span class="lineno"> 3746</span><span class="stringliteral">    irlen : int or None, optional</span></div>
<div class="line"><span class="lineno"> 3747</span><span class="stringliteral">        The length of the nonnegligible part of the impulse response.</span></div>
<div class="line"><span class="lineno"> 3748</span><span class="stringliteral">        If `irlen` is None, or if the length of the signal is less than</span></div>
<div class="line"><span class="lineno"> 3749</span><span class="stringliteral">        ``2 * irlen``, then no part of the impulse response is ignored.</span></div>
<div class="line"><span class="lineno"> 3750</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3751</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3752</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3753</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 3754</span><span class="stringliteral">        The filtered data.</span></div>
<div class="line"><span class="lineno"> 3755</span><span class="stringliteral">    x0 : ndarray</span></div>
<div class="line"><span class="lineno"> 3756</span><span class="stringliteral">        Initial condition for the forward filter.</span></div>
<div class="line"><span class="lineno"> 3757</span><span class="stringliteral">    x1 : ndarray</span></div>
<div class="line"><span class="lineno"> 3758</span><span class="stringliteral">        Initial condition for the backward filter.</span></div>
<div class="line"><span class="lineno"> 3759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3760</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3761</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3762</span><span class="stringliteral">    Typically the return values `x0` and `x1` are not needed by the</span></div>
<div class="line"><span class="lineno"> 3763</span><span class="stringliteral">    caller.  The intended use of these return values is in unit tests.</span></div>
<div class="line"><span class="lineno"> 3764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3765</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3766</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3767</span><span class="stringliteral">    .. [1] F. Gustaffson. Determining the initial states in forward-backward</span></div>
<div class="line"><span class="lineno"> 3768</span><span class="stringliteral">           filtering. Transactions on Signal Processing, 46(4):988-992, 1996.</span></div>
<div class="line"><span class="lineno"> 3769</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3770</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3771</span>    <span class="comment"># In the comments, &quot;Gustafsson&#39;s paper&quot; and [1] refer to the</span></div>
<div class="line"><span class="lineno"> 3772</span>    <span class="comment"># paper referenced in the docstring.</span></div>
<div class="line"><span class="lineno"> 3773</span> </div>
<div class="line"><span class="lineno"> 3774</span>    b = np.atleast_1d(b)</div>
<div class="line"><span class="lineno"> 3775</span>    a = np.atleast_1d(a)</div>
<div class="line"><span class="lineno"> 3776</span> </div>
<div class="line"><span class="lineno"> 3777</span>    order = max(len(b), len(a)) - 1</div>
<div class="line"><span class="lineno"> 3778</span>    <span class="keywordflow">if</span> order == 0:</div>
<div class="line"><span class="lineno"> 3779</span>        <span class="comment"># The filter is just scalar multiplication, with no state.</span></div>
<div class="line"><span class="lineno"> 3780</span>        scale = (b[0] / a[0])**2</div>
<div class="line"><span class="lineno"> 3781</span>        y = scale * x</div>
<div class="line"><span class="lineno"> 3782</span>        <span class="keywordflow">return</span> y, np.array([]), np.array([])</div>
<div class="line"><span class="lineno"> 3783</span> </div>
<div class="line"><span class="lineno"> 3784</span>    <span class="keywordflow">if</span> axis != -1 <span class="keywordflow">or</span> axis != x.ndim - 1:</div>
<div class="line"><span class="lineno"> 3785</span>        <span class="comment"># Move the axis containing the data to the end.</span></div>
<div class="line"><span class="lineno"> 3786</span>        x = np.swapaxes(x, axis, x.ndim - 1)</div>
<div class="line"><span class="lineno"> 3787</span> </div>
<div class="line"><span class="lineno"> 3788</span>    <span class="comment"># n is the number of samples in the data to be filtered.</span></div>
<div class="line"><span class="lineno"> 3789</span>    n = x.shape[-1]</div>
<div class="line"><span class="lineno"> 3790</span> </div>
<div class="line"><span class="lineno"> 3791</span>    <span class="keywordflow">if</span> irlen <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> n &lt;= 2*irlen:</div>
<div class="line"><span class="lineno"> 3792</span>        m = n</div>
<div class="line"><span class="lineno"> 3793</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3794</span>        m = irlen</div>
<div class="line"><span class="lineno"> 3795</span> </div>
<div class="line"><span class="lineno"> 3796</span>    <span class="comment"># Create Obs, the observability matrix (called O in the paper).</span></div>
<div class="line"><span class="lineno"> 3797</span>    <span class="comment"># This matrix can be interpreted as the operator that propagates</span></div>
<div class="line"><span class="lineno"> 3798</span>    <span class="comment"># an arbitrary initial state to the output, assuming the input is</span></div>
<div class="line"><span class="lineno"> 3799</span>    <span class="comment"># zero.</span></div>
<div class="line"><span class="lineno"> 3800</span>    <span class="comment"># In Gustafsson&#39;s paper, the forward and backward filters are not</span></div>
<div class="line"><span class="lineno"> 3801</span>    <span class="comment"># necessarily the same, so he has both O_f and O_b.  We use the same</span></div>
<div class="line"><span class="lineno"> 3802</span>    <span class="comment"># filter in both directions, so we only need O. The same comment</span></div>
<div class="line"><span class="lineno"> 3803</span>    <span class="comment"># applies to S below.</span></div>
<div class="line"><span class="lineno"> 3804</span>    Obs = np.zeros((m, order))</div>
<div class="line"><span class="lineno"> 3805</span>    zi = np.zeros(order)</div>
<div class="line"><span class="lineno"> 3806</span>    zi[0] = 1</div>
<div class="line"><span class="lineno"> 3807</span>    Obs[:, 0] = lfilter(b, a, np.zeros(m), zi=zi)[0]</div>
<div class="line"><span class="lineno"> 3808</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(1, order):</div>
<div class="line"><span class="lineno"> 3809</span>        Obs[k:, k] = Obs[:-k, 0]</div>
<div class="line"><span class="lineno"> 3810</span> </div>
<div class="line"><span class="lineno"> 3811</span>    <span class="comment"># Obsr is O^R (Gustafsson&#39;s notation for row-reversed O)</span></div>
<div class="line"><span class="lineno"> 3812</span>    Obsr = Obs[::-1]</div>
<div class="line"><span class="lineno"> 3813</span> </div>
<div class="line"><span class="lineno"> 3814</span>    <span class="comment"># Create S.  S is the matrix that applies the filter to the reversed</span></div>
<div class="line"><span class="lineno"> 3815</span>    <span class="comment"># propagated initial conditions.  That is,</span></div>
<div class="line"><span class="lineno"> 3816</span>    <span class="comment">#     out = S.dot(zi)</span></div>
<div class="line"><span class="lineno"> 3817</span>    <span class="comment"># is the same as</span></div>
<div class="line"><span class="lineno"> 3818</span>    <span class="comment">#     tmp, _ = lfilter(b, a, zeros(), zi=zi)  # Propagate ICs.</span></div>
<div class="line"><span class="lineno"> 3819</span>    <span class="comment">#     out = lfilter(b, a, tmp[::-1])          # Reverse and filter.</span></div>
<div class="line"><span class="lineno"> 3820</span> </div>
<div class="line"><span class="lineno"> 3821</span>    <span class="comment"># Equations (5) &amp; (6) of [1]</span></div>
<div class="line"><span class="lineno"> 3822</span>    S = lfilter(b, a, Obs[::-1], axis=0)</div>
<div class="line"><span class="lineno"> 3823</span> </div>
<div class="line"><span class="lineno"> 3824</span>    <span class="comment"># Sr is S^R (row-reversed S)</span></div>
<div class="line"><span class="lineno"> 3825</span>    Sr = S[::-1]</div>
<div class="line"><span class="lineno"> 3826</span> </div>
<div class="line"><span class="lineno"> 3827</span>    <span class="comment"># M is [(S^R - O), (O^R - S)]</span></div>
<div class="line"><span class="lineno"> 3828</span>    <span class="keywordflow">if</span> m == n:</div>
<div class="line"><span class="lineno"> 3829</span>        M = np.hstack((Sr - Obs, Obsr - S))</div>
<div class="line"><span class="lineno"> 3830</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3831</span>        <span class="comment"># Matrix described in section IV of [1].</span></div>
<div class="line"><span class="lineno"> 3832</span>        M = np.zeros((2*m, 2*order))</div>
<div class="line"><span class="lineno"> 3833</span>        M[:m, :order] = Sr - Obs</div>
<div class="line"><span class="lineno"> 3834</span>        M[m:, order:] = Obsr - S</div>
<div class="line"><span class="lineno"> 3835</span> </div>
<div class="line"><span class="lineno"> 3836</span>    <span class="comment"># Naive forward-backward and backward-forward filters.</span></div>
<div class="line"><span class="lineno"> 3837</span>    <span class="comment"># These have large transients because the filters use zero initial</span></div>
<div class="line"><span class="lineno"> 3838</span>    <span class="comment"># conditions.</span></div>
<div class="line"><span class="lineno"> 3839</span>    y_f = lfilter(b, a, x)</div>
<div class="line"><span class="lineno"> 3840</span>    y_fb = lfilter(b, a, y_f[..., ::-1])[..., ::-1]</div>
<div class="line"><span class="lineno"> 3841</span> </div>
<div class="line"><span class="lineno"> 3842</span>    y_b = lfilter(b, a, x[..., ::-1])[..., ::-1]</div>
<div class="line"><span class="lineno"> 3843</span>    y_bf = lfilter(b, a, y_b)</div>
<div class="line"><span class="lineno"> 3844</span> </div>
<div class="line"><span class="lineno"> 3845</span>    delta_y_bf_fb = y_bf - y_fb</div>
<div class="line"><span class="lineno"> 3846</span>    <span class="keywordflow">if</span> m == n:</div>
<div class="line"><span class="lineno"> 3847</span>        delta = delta_y_bf_fb</div>
<div class="line"><span class="lineno"> 3848</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3849</span>        start_m = delta_y_bf_fb[..., :m]</div>
<div class="line"><span class="lineno"> 3850</span>        end_m = delta_y_bf_fb[..., -m:]</div>
<div class="line"><span class="lineno"> 3851</span>        delta = np.concatenate((start_m, end_m), axis=-1)</div>
<div class="line"><span class="lineno"> 3852</span> </div>
<div class="line"><span class="lineno"> 3853</span>    <span class="comment"># ic_opt holds the &quot;optimal&quot; initial conditions.</span></div>
<div class="line"><span class="lineno"> 3854</span>    <span class="comment"># The following code computes the result shown in the formula</span></div>
<div class="line"><span class="lineno"> 3855</span>    <span class="comment"># of the paper between equations (6) and (7).</span></div>
<div class="line"><span class="lineno"> 3856</span>    <span class="keywordflow">if</span> delta.ndim == 1:</div>
<div class="line"><span class="lineno"> 3857</span>        ic_opt = linalg.lstsq(M, delta)[0]</div>
<div class="line"><span class="lineno"> 3858</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3859</span>        <span class="comment"># Reshape delta so it can be used as an array of multiple</span></div>
<div class="line"><span class="lineno"> 3860</span>        <span class="comment"># right-hand-sides in linalg.lstsq.</span></div>
<div class="line"><span class="lineno"> 3861</span>        delta2d = delta.reshape(-1, delta.shape[-1]).T</div>
<div class="line"><span class="lineno"> 3862</span>        ic_opt0 = linalg.lstsq(M, delta2d)[0].T</div>
<div class="line"><span class="lineno"> 3863</span>        ic_opt = ic_opt0.reshape(delta.shape[:-1] + (M.shape[-1],))</div>
<div class="line"><span class="lineno"> 3864</span> </div>
<div class="line"><span class="lineno"> 3865</span>    <span class="comment"># Now compute the filtered signal using equation (7) of [1].</span></div>
<div class="line"><span class="lineno"> 3866</span>    <span class="comment"># First, form [S^R, O^R] and call it W.</span></div>
<div class="line"><span class="lineno"> 3867</span>    <span class="keywordflow">if</span> m == n:</div>
<div class="line"><span class="lineno"> 3868</span>        W = np.hstack((Sr, Obsr))</div>
<div class="line"><span class="lineno"> 3869</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3870</span>        W = np.zeros((2*m, 2*order))</div>
<div class="line"><span class="lineno"> 3871</span>        W[:m, :order] = Sr</div>
<div class="line"><span class="lineno"> 3872</span>        W[m:, order:] = Obsr</div>
<div class="line"><span class="lineno"> 3873</span> </div>
<div class="line"><span class="lineno"> 3874</span>    <span class="comment"># Equation (7) of [1] says</span></div>
<div class="line"><span class="lineno"> 3875</span>    <span class="comment">#     Y_fb^opt = Y_fb^0 + W * [x_0^opt; x_{N-1}^opt]</span></div>
<div class="line"><span class="lineno"> 3876</span>    <span class="comment"># `wic` is (almost) the product on the right.</span></div>
<div class="line"><span class="lineno"> 3877</span>    <span class="comment"># W has shape (m, 2*order), and ic_opt has shape (..., 2*order),</span></div>
<div class="line"><span class="lineno"> 3878</span>    <span class="comment"># so we can&#39;t use W.dot(ic_opt).  Instead, we dot ic_opt with W.T,</span></div>
<div class="line"><span class="lineno"> 3879</span>    <span class="comment"># so wic has shape (..., m).</span></div>
<div class="line"><span class="lineno"> 3880</span>    wic = ic_opt.dot(W.T)</div>
<div class="line"><span class="lineno"> 3881</span> </div>
<div class="line"><span class="lineno"> 3882</span>    <span class="comment"># `wic` is &quot;almost&quot; the product of W and the optimal ICs in equation</span></div>
<div class="line"><span class="lineno"> 3883</span>    <span class="comment"># (7)--if we&#39;re using a truncated impulse response (m &lt; n), `wic`</span></div>
<div class="line"><span class="lineno"> 3884</span>    <span class="comment"># contains only the adjustments required for the ends of the signal.</span></div>
<div class="line"><span class="lineno"> 3885</span>    <span class="comment"># Here we form y_opt, taking this into account if necessary.</span></div>
<div class="line"><span class="lineno"> 3886</span>    y_opt = y_fb</div>
<div class="line"><span class="lineno"> 3887</span>    <span class="keywordflow">if</span> m == n:</div>
<div class="line"><span class="lineno"> 3888</span>        y_opt += wic</div>
<div class="line"><span class="lineno"> 3889</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3890</span>        y_opt[..., :m] += wic[..., :m]</div>
<div class="line"><span class="lineno"> 3891</span>        y_opt[..., -m:] += wic[..., -m:]</div>
<div class="line"><span class="lineno"> 3892</span> </div>
<div class="line"><span class="lineno"> 3893</span>    x0 = ic_opt[..., :order]</div>
<div class="line"><span class="lineno"> 3894</span>    x1 = ic_opt[..., -order:]</div>
<div class="line"><span class="lineno"> 3895</span>    <span class="keywordflow">if</span> axis != -1 <span class="keywordflow">or</span> axis != x.ndim - 1:</div>
<div class="line"><span class="lineno"> 3896</span>        <span class="comment"># Restore the data axis to its original position.</span></div>
<div class="line"><span class="lineno"> 3897</span>        x0 = np.swapaxes(x0, axis, x.ndim - 1)</div>
<div class="line"><span class="lineno"> 3898</span>        x1 = np.swapaxes(x1, axis, x.ndim - 1)</div>
<div class="line"><span class="lineno"> 3899</span>        y_opt = np.swapaxes(y_opt, axis, x.ndim - 1)</div>
<div class="line"><span class="lineno"> 3900</span> </div>
<div class="line"><span class="lineno"> 3901</span>    <span class="keywordflow">return</span> y_opt, x0, x1</div>
<div class="line"><span class="lineno"> 3902</span> </div>
<div class="line"><span class="lineno"> 3903</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8646a8cac7a184c7a4325f319cf1eac3" name="a8646a8cac7a184c7a4325f319cf1eac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8646a8cac7a184c7a4325f319cf1eac3">&#9670;&#160;</a></span>_freq_domain_conv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._freq_domain_conv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>calc_fast_len</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convolve two arrays in the frequency domain.

This function implements only base the FFT-related operations.
Specifically, it converts the signals to the frequency domain, multiplies
them, then converts them back to the time domain.  Calculations of axes,
shapes, convolution mode, etc. are implemented in higher level-functions,
such as `fftconvolve` and `oaconvolve`.  Those functions should be used
instead of this one.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`.
axes : array_like of ints
    Axes over which to compute the FFTs.
shape : array_like of ints
    The sizes of the FFTs.
calc_fast_len : bool, optional
    If `True`, set each value of `shape` to the next fast FFT length.
    Default is `False`, use `axes` as-is.

Returns
-------
out : array
    An N-dimensional array containing the discrete linear convolution of
    `in1` with `in2`.</pre> <div class="fragment"><div class="line"><span class="lineno">  457</span><span class="keyword">def </span>_freq_domain_conv(in1, in2, axes, shape, calc_fast_len=False):</div>
<div class="line"><span class="lineno">  458</span>    <span class="stringliteral">&quot;&quot;&quot;Convolve two arrays in the frequency domain.</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    This function implements only base the FFT-related operations.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    Specifically, it converts the signals to the frequency domain, multiplies</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    them, then converts them back to the time domain.  Calculations of axes,</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    shapes, convolution mode, etc. are implemented in higher level-functions,</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    such as `fftconvolve` and `oaconvolve`.  Those functions should be used</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    instead of this one.</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        Second input. Should have the same number of dimensions as `in1`.</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    axes : array_like of ints</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        Axes over which to compute the FFTs.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    shape : array_like of ints</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        The sizes of the FFTs.</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    calc_fast_len : bool, optional</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        If `True`, set each value of `shape` to the next fast FFT length.</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        Default is `False`, use `axes` as-is.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    out : array</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">        An N-dimensional array containing the discrete linear convolution of</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        `in1` with `in2`.</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  488</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(axes):</div>
<div class="line"><span class="lineno">  489</span>        <span class="keywordflow">return</span> in1 * in2</div>
<div class="line"><span class="lineno">  490</span> </div>
<div class="line"><span class="lineno">  491</span>    complex_result = (in1.dtype.kind == <span class="stringliteral">&#39;c&#39;</span> <span class="keywordflow">or</span> in2.dtype.kind == <span class="stringliteral">&#39;c&#39;</span>)</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>    <span class="keywordflow">if</span> calc_fast_len:</div>
<div class="line"><span class="lineno">  494</span>        <span class="comment"># Speed up FFT by padding to optimal size.</span></div>
<div class="line"><span class="lineno">  495</span>        fshape = [</div>
<div class="line"><span class="lineno">  496</span>            sp_fft.next_fast_len(shape[a], <span class="keywordflow">not</span> complex_result) <span class="keywordflow">for</span> a <span class="keywordflow">in</span> axes]</div>
<div class="line"><span class="lineno">  497</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  498</span>        fshape = shape</div>
<div class="line"><span class="lineno">  499</span> </div>
<div class="line"><span class="lineno">  500</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> complex_result:</div>
<div class="line"><span class="lineno">  501</span>        fft, ifft = sp_fft.rfftn, sp_fft.irfftn</div>
<div class="line"><span class="lineno">  502</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  503</span>        fft, ifft = sp_fft.fftn, sp_fft.ifftn</div>
<div class="line"><span class="lineno">  504</span> </div>
<div class="line"><span class="lineno">  505</span>    sp1 = fft(in1, fshape, axes=axes)</div>
<div class="line"><span class="lineno">  506</span>    sp2 = fft(in2, fshape, axes=axes)</div>
<div class="line"><span class="lineno">  507</span> </div>
<div class="line"><span class="lineno">  508</span>    ret = ifft(sp1 * sp2, fshape, axes=axes)</div>
<div class="line"><span class="lineno">  509</span> </div>
<div class="line"><span class="lineno">  510</span>    <span class="keywordflow">if</span> calc_fast_len:</div>
<div class="line"><span class="lineno">  511</span>        fslice = tuple([slice(sz) <span class="keywordflow">for</span> sz <span class="keywordflow">in</span> shape])</div>
<div class="line"><span class="lineno">  512</span>        ret = ret[fslice]</div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a741c5ce9696b31934388c7391f78f0" name="a5a741c5ce9696b31934388c7391f78f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a741c5ce9696b31934388c7391f78f0">&#9670;&#160;</a></span>_group_poles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._group_poles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2846</span><span class="keyword">def </span>_group_poles(poles, tol, rtype):</div>
<div class="line"><span class="lineno"> 2847</span>    <span class="keywordflow">if</span> rtype <span class="keywordflow">in</span> [<span class="stringliteral">&#39;max&#39;</span>, <span class="stringliteral">&#39;maximum&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2848</span>        reduce = np.max</div>
<div class="line"><span class="lineno"> 2849</span>    <span class="keywordflow">elif</span> rtype <span class="keywordflow">in</span> [<span class="stringliteral">&#39;min&#39;</span>, <span class="stringliteral">&#39;minimum&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2850</span>        reduce = np.min</div>
<div class="line"><span class="lineno"> 2851</span>    <span class="keywordflow">elif</span> rtype <span class="keywordflow">in</span> [<span class="stringliteral">&#39;avg&#39;</span>, <span class="stringliteral">&#39;mean&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2852</span>        reduce = np.mean</div>
<div class="line"><span class="lineno"> 2853</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2854</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`rtype` must be one of &quot;</span></div>
<div class="line"><span class="lineno"> 2855</span>                         <span class="stringliteral">&quot;{&#39;max&#39;, &#39;maximum&#39;, &#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;mean&#39;}&quot;</span>)</div>
<div class="line"><span class="lineno"> 2856</span> </div>
<div class="line"><span class="lineno"> 2857</span>    unique = []</div>
<div class="line"><span class="lineno"> 2858</span>    multiplicity = []</div>
<div class="line"><span class="lineno"> 2859</span> </div>
<div class="line"><span class="lineno"> 2860</span>    pole = poles[0]</div>
<div class="line"><span class="lineno"> 2861</span>    block = [pole]</div>
<div class="line"><span class="lineno"> 2862</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, len(poles)):</div>
<div class="line"><span class="lineno"> 2863</span>        <span class="keywordflow">if</span> abs(poles[i] - pole) &lt;= tol:</div>
<div class="line"><span class="lineno"> 2864</span>            block.append(pole)</div>
<div class="line"><span class="lineno"> 2865</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2866</span>            unique.append(reduce(block))</div>
<div class="line"><span class="lineno"> 2867</span>            multiplicity.append(len(block))</div>
<div class="line"><span class="lineno"> 2868</span>            pole = poles[i]</div>
<div class="line"><span class="lineno"> 2869</span>            block = [pole]</div>
<div class="line"><span class="lineno"> 2870</span> </div>
<div class="line"><span class="lineno"> 2871</span>    unique.append(reduce(block))</div>
<div class="line"><span class="lineno"> 2872</span>    multiplicity.append(len(block))</div>
<div class="line"><span class="lineno"> 2873</span> </div>
<div class="line"><span class="lineno"> 2874</span>    <span class="keywordflow">return</span> np.asarray(unique), np.asarray(multiplicity)</div>
<div class="line"><span class="lineno"> 2875</span> </div>
<div class="line"><span class="lineno"> 2876</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af46476448bd1330985ec891d96be762f" name="af46476448bd1330985ec891d96be762f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46476448bd1330985ec891d96be762f">&#9670;&#160;</a></span>_init_freq_conv_axes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._init_freq_conv_axes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sorted_axes</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Handle the axes argument for frequency-domain convolution.

Returns the inputs and axes in a standard form, eliminating redundant axes,
swapping the inputs if necessary, and checking for various potential
errors.

Parameters
----------
in1 : array
    First input.
in2 : array
    Second input.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output.
    See the documentation `fftconvolve` for more information.
axes : list of ints
    Axes over which to compute the FFTs.
sorted_axes : bool, optional
    If `True`, sort the axes.
    Default is `False`, do not sort.

Returns
-------
in1 : array
    The first input, possible swapped with the second input.
in2 : array
    The second input, possible swapped with the first input.
axes : list of ints
    Axes over which to compute the FFTs.</pre> <div class="fragment"><div class="line"><span class="lineno">  396</span><span class="keyword">def </span>_init_freq_conv_axes(in1, in2, mode, axes, sorted_axes=False):</div>
<div class="line"><span class="lineno">  397</span>    <span class="stringliteral">&quot;&quot;&quot;Handle the axes argument for frequency-domain convolution.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    Returns the inputs and axes in a standard form, eliminating redundant axes,</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    swapping the inputs if necessary, and checking for various potential</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    errors.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    in1 : array</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    in2 : array</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">        Second input.</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        A string indicating the size of the output.</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">        See the documentation `fftconvolve` for more information.</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    axes : list of ints</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">        Axes over which to compute the FFTs.</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    sorted_axes : bool, optional</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">        If `True`, sort the axes.</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        Default is `False`, do not sort.</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    in1 : array</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">        The first input, possible swapped with the second input.</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    in2 : array</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">        The second input, possible swapped with the first input.</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    axes : list of ints</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">        Axes over which to compute the FFTs.</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  428</span>    s1 = in1.shape</div>
<div class="line"><span class="lineno">  429</span>    s2 = in2.shape</div>
<div class="line"><span class="lineno">  430</span>    noaxes = axes <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  431</span> </div>
<div class="line"><span class="lineno">  432</span>    _, axes = _init_nd_shape_and_axes(in1, shape=<span class="keywordtype">None</span>, axes=axes)</div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> noaxes <span class="keywordflow">and</span> <span class="keywordflow">not</span> len(axes):</div>
<div class="line"><span class="lineno">  435</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;when provided, axes cannot be empty&quot;</span>)</div>
<div class="line"><span class="lineno">  436</span> </div>
<div class="line"><span class="lineno">  437</span>    <span class="comment"># Axes of length 1 can rely on broadcasting rules for multipy,</span></div>
<div class="line"><span class="lineno">  438</span>    <span class="comment"># no fft needed.</span></div>
<div class="line"><span class="lineno">  439</span>    axes = [a <span class="keywordflow">for</span> a <span class="keywordflow">in</span> axes <span class="keywordflow">if</span> s1[a] != 1 <span class="keywordflow">and</span> s2[a] != 1]</div>
<div class="line"><span class="lineno">  440</span> </div>
<div class="line"><span class="lineno">  441</span>    <span class="keywordflow">if</span> sorted_axes:</div>
<div class="line"><span class="lineno">  442</span>        axes.sort()</div>
<div class="line"><span class="lineno">  443</span> </div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> all(s1[a] == s2[a] <span class="keywordflow">or</span> s1[a] == 1 <span class="keywordflow">or</span> s2[a] == 1</div>
<div class="line"><span class="lineno">  445</span>               <span class="keywordflow">for</span> a <span class="keywordflow">in</span> range(in1.ndim) <span class="keywordflow">if</span> a <span class="keywordflow">not</span> <span class="keywordflow">in</span> axes):</div>
<div class="line"><span class="lineno">  446</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;incompatible shapes for in1 and in2:&quot;</span></div>
<div class="line"><span class="lineno">  447</span>                         <span class="stringliteral">&quot; {0} and {1}&quot;</span>.format(s1, s2))</div>
<div class="line"><span class="lineno">  448</span> </div>
<div class="line"><span class="lineno">  449</span>    <span class="comment"># Check that input sizes are compatible with &#39;valid&#39; mode.</span></div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordflow">if</span> _inputs_swap_needed(mode, s1, s2, axes=axes):</div>
<div class="line"><span class="lineno">  451</span>        <span class="comment"># Convolution is commutative; order doesn&#39;t have any effect on output.</span></div>
<div class="line"><span class="lineno">  452</span>        in1, in2 = in2, in1</div>
<div class="line"><span class="lineno">  453</span> </div>
<div class="line"><span class="lineno">  454</span>    <span class="keywordflow">return</span> in1, in2, axes</div>
<div class="line"><span class="lineno">  455</span> </div>
<div class="line"><span class="lineno">  456</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f50fb87dabfe93262fabb34950918ca" name="a3f50fb87dabfe93262fabb34950918ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f50fb87dabfe93262fabb34950918ca">&#9670;&#160;</a></span>_inputs_swap_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._inputs_swap_needed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Determine if inputs arrays need to be swapped in `"valid"` mode.

If in `"valid"` mode, returns whether or not the input arrays need to be
swapped depending on whether `shape1` is at least as large as `shape2` in
every calculated dimension.

This is important for some of the correlation and convolution
implementations in this module, where the larger array input needs to come
before the smaller array input when operating in this mode.

Note that if the mode provided is not 'valid', False is immediately
returned.</pre> <div class="fragment"><div class="line"><span class="lineno">   56</span><span class="keyword">def </span>_inputs_swap_needed(mode, shape1, shape2, axes=None):</div>
<div class="line"><span class="lineno">   57</span>    <span class="stringliteral">&quot;&quot;&quot;Determine if inputs arrays need to be swapped in `&quot;valid&quot;` mode.</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    If in `&quot;valid&quot;` mode, returns whether or not the input arrays need to be</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    swapped depending on whether `shape1` is at least as large as `shape2` in</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    every calculated dimension.</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    This is important for some of the correlation and convolution</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    implementations in this module, where the larger array input needs to come</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    before the smaller array input when operating in this mode.</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    Note that if the mode provided is not &#39;valid&#39;, False is immediately</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    returned.</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">if</span> mode != <span class="stringliteral">&#39;valid&#39;</span>:</div>
<div class="line"><span class="lineno">   72</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   73</span> </div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> shape1:</div>
<div class="line"><span class="lineno">   75</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   76</span> </div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">if</span> axes <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   78</span>        axes = range(len(shape1))</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>    ok1 = all(shape1[i] &gt;= shape2[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> axes)</div>
<div class="line"><span class="lineno">   81</span>    ok2 = all(shape2[i] &gt;= shape1[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> axes)</div>
<div class="line"><span class="lineno">   82</span> </div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (ok1 <span class="keywordflow">or</span> ok2):</div>
<div class="line"><span class="lineno">   84</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;For &#39;valid&#39; mode, one must be at least &quot;</span></div>
<div class="line"><span class="lineno">   85</span>                         <span class="stringliteral">&quot;as large as the other in every dimension&quot;</span>)</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">return</span> <span class="keywordflow">not</span> ok1</div>
<div class="line"><span class="lineno">   88</span> </div>
<div class="line"><span class="lineno">   89</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acc50e7b376d22864d7fdc3a627c4bd00" name="acc50e7b376d22864d7fdc3a627c4bd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc50e7b376d22864d7fdc3a627c4bd00">&#9670;&#160;</a></span>_np_conv_ok()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._np_conv_ok </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">See if numpy supports convolution of `volume` and `kernel` (i.e. both are
1D ndarrays and of the appropriate shape).  NumPy's 'same' mode uses the
size of the larger input, while SciPy's uses the size of the first input.

Invalid mode strings will return False and be caught by the calling func.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1104</span><span class="keyword">def </span>_np_conv_ok(volume, kernel, mode):</div>
<div class="line"><span class="lineno"> 1105</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    See if numpy supports convolution of `volume` and `kernel` (i.e. both are</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">    1D ndarrays and of the appropriate shape).  NumPy&#39;s &#39;same&#39; mode uses the</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    size of the larger input, while SciPy&#39;s uses the size of the first input.</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    Invalid mode strings will return False and be caught by the calling func.</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1112</span>    <span class="keywordflow">if</span> volume.ndim == kernel.ndim == 1:</div>
<div class="line"><span class="lineno"> 1113</span>        <span class="keywordflow">if</span> mode <span class="keywordflow">in</span> (<span class="stringliteral">&#39;full&#39;</span>, <span class="stringliteral">&#39;valid&#39;</span>):</div>
<div class="line"><span class="lineno"> 1114</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1115</span>        <span class="keywordflow">elif</span> mode == <span class="stringliteral">&#39;same&#39;</span>:</div>
<div class="line"><span class="lineno"> 1116</span>            <span class="keywordflow">return</span> volume.size &gt;= kernel.size</div>
<div class="line"><span class="lineno"> 1117</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1118</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1119</span> </div>
<div class="line"><span class="lineno"> 1120</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a64c8d1303a1a85d0867cb7ea296de026" name="a64c8d1303a1a85d0867cb7ea296de026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c8d1303a1a85d0867cb7ea296de026">&#9670;&#160;</a></span>_numeric_arrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._numeric_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kinds</em> = <code>'buifc'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">See if a list of arrays are all numeric.

Parameters
----------
arrays : array or list of arrays
    arrays to check if numeric.
kinds : string-like
    The dtypes of the arrays to be checked. If the dtype.kind of
    the ndarrays are not in this string the function returns False and
    otherwise returns True.
</pre> <div class="fragment"><div class="line"><span class="lineno">  990</span><span class="keyword">def </span>_numeric_arrays(arrays, kinds=&#39;buifc&#39;):</div>
<div class="line"><span class="lineno">  991</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    See if a list of arrays are all numeric.</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    arrays : array or list of arrays</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">        arrays to check if numeric.</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    kinds : string-like</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">        The dtypes of the arrays to be checked. If the dtype.kind of</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        the ndarrays are not in this string the function returns False and</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">        otherwise returns True.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1003</span>    <span class="keywordflow">if</span> type(arrays) == np.ndarray:</div>
<div class="line"><span class="lineno"> 1004</span>        <span class="keywordflow">return</span> arrays.dtype.kind <span class="keywordflow">in</span> kinds</div>
<div class="line"><span class="lineno"> 1005</span>    <span class="keywordflow">for</span> array_ <span class="keywordflow">in</span> arrays:</div>
<div class="line"><span class="lineno"> 1006</span>        <span class="keywordflow">if</span> array_.dtype.kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> kinds:</div>
<div class="line"><span class="lineno"> 1007</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1008</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1009</span> </div>
<div class="line"><span class="lineno"> 1010</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aab0027f7137b0079b191f19c7845815c" name="aab0027f7137b0079b191f19c7845815c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0027f7137b0079b191f19c7845815c">&#9670;&#160;</a></span>_reverse_and_conj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._reverse_and_conj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Reverse array `x` in all dimensions and perform the complex conjugate
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1096</span><span class="keyword">def </span>_reverse_and_conj(x):</div>
<div class="line"><span class="lineno"> 1097</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    Reverse array `x` in all dimensions and perform the complex conjugate</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1100</span>    reverse = (slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, -1),) * x.ndim</div>
<div class="line"><span class="lineno"> 1101</span>    <span class="keywordflow">return</span> x[reverse].conj()</div>
<div class="line"><span class="lineno"> 1102</span> </div>
<div class="line"><span class="lineno"> 1103</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bc76422dfb7336d1c120bc18287df11" name="a1bc76422dfb7336d1c120bc18287df11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc76422dfb7336d1c120bc18287df11">&#9670;&#160;</a></span>_timeit_fast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._timeit_fast </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stmt</em> = <code>&quot;pass&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>setup</em> = <code>&quot;pass&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repeat</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the time the statement/function took, in seconds.

Faster, less precise version of IPython's timeit. `stmt` can be a statement
written as a string or a callable.

Will do only 1 loop (like IPython's timeit) with no repetitions
(unlike IPython) for very slow functions.  For fast functions, only does
enough loops to take 5 ms, which seems to produce similar results (on
Windows at least), and avoids doing an extraneous cycle that isn't
measured.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1121</span><span class="keyword">def </span>_timeit_fast(stmt=&quot;pass&quot;, setup=&quot;pass&quot;, repeat=3):</div>
<div class="line"><span class="lineno"> 1122</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    Returns the time the statement/function took, in seconds.</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    Faster, less precise version of IPython&#39;s timeit. `stmt` can be a statement</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    written as a string or a callable.</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    Will do only 1 loop (like IPython&#39;s timeit) with no repetitions</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    (unlike IPython) for very slow functions.  For fast functions, only does</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    enough loops to take 5 ms, which seems to produce similar results (on</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    Windows at least), and avoids doing an extraneous cycle that isn&#39;t</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    measured.</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1135</span>    timer = timeit.Timer(stmt, setup)</div>
<div class="line"><span class="lineno"> 1136</span> </div>
<div class="line"><span class="lineno"> 1137</span>    <span class="comment"># determine number of calls per rep so total time for 1 rep &gt;= 5 ms</span></div>
<div class="line"><span class="lineno"> 1138</span>    x = 0</div>
<div class="line"><span class="lineno"> 1139</span>    <span class="keywordflow">for</span> p <span class="keywordflow">in</span> range(0, 10):</div>
<div class="line"><span class="lineno"> 1140</span>        number = 10**p</div>
<div class="line"><span class="lineno"> 1141</span>        x = timer.timeit(number)  <span class="comment"># seconds</span></div>
<div class="line"><span class="lineno"> 1142</span>        <span class="keywordflow">if</span> x &gt;= 5e-3 / 10:  <span class="comment"># 5 ms for final test, 1/10th that for this one</span></div>
<div class="line"><span class="lineno"> 1143</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1144</span>    <span class="keywordflow">if</span> x &gt; 1:  <span class="comment"># second</span></div>
<div class="line"><span class="lineno"> 1145</span>        <span class="comment"># If it&#39;s macroscopic, don&#39;t bother with repetitions</span></div>
<div class="line"><span class="lineno"> 1146</span>        best = x</div>
<div class="line"><span class="lineno"> 1147</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1148</span>        number *= 10</div>
<div class="line"><span class="lineno"> 1149</span>        r = timer.repeat(repeat, number)</div>
<div class="line"><span class="lineno"> 1150</span>        best = min(r)</div>
<div class="line"><span class="lineno"> 1151</span> </div>
<div class="line"><span class="lineno"> 1152</span>    sec = best / number</div>
<div class="line"><span class="lineno"> 1153</span>    <span class="keywordflow">return</span> sec</div>
<div class="line"><span class="lineno"> 1154</span> </div>
<div class="line"><span class="lineno"> 1155</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a641a8d36f14647c20438c1ace63a0a22" name="a641a8d36f14647c20438c1ace63a0a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641a8d36f14647c20438c1ace63a0a22">&#9670;&#160;</a></span>_valfrommode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._valfrommode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   40</span><span class="keyword">def </span>_valfrommode(mode):</div>
<div class="line"><span class="lineno">   41</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   42</span>        <span class="keywordflow">return</span> _modedict[mode]</div>
<div class="line"><span class="lineno">   43</span>    <span class="keywordflow">except</span> KeyError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">   44</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span></div>
<div class="line"><span class="lineno">   45</span>                         <span class="stringliteral">&quot; &#39;same&#39;, or &#39;full&#39;.&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">   46</span> </div>
<div class="line"><span class="lineno">   47</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ae68840e64243ec742a4867e7394e03" name="a5ae68840e64243ec742a4867e7394e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae68840e64243ec742a4867e7394e03">&#9670;&#160;</a></span>_validate_pad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._validate_pad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ntaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper to validate padding for filtfilt</pre> <div class="fragment"><div class="line"><span class="lineno"> 4105</span><span class="keyword">def </span>_validate_pad(padtype, padlen, x, axis, ntaps):</div>
<div class="line"><span class="lineno"> 4106</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to validate padding for filtfilt&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4107</span>    <span class="keywordflow">if</span> padtype <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;even&#39;</span>, <span class="stringliteral">&#39;odd&#39;</span>, <span class="stringliteral">&#39;constant&#39;</span>, <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4108</span>        <span class="keywordflow">raise</span> ValueError((<span class="stringliteral">&quot;Unknown value &#39;%s&#39; given to padtype.  padtype &quot;</span></div>
<div class="line"><span class="lineno"> 4109</span>                          <span class="stringliteral">&quot;must be &#39;even&#39;, &#39;odd&#39;, &#39;constant&#39;, or None.&quot;</span>) %</div>
<div class="line"><span class="lineno"> 4110</span>                         padtype)</div>
<div class="line"><span class="lineno"> 4111</span> </div>
<div class="line"><span class="lineno"> 4112</span>    <span class="keywordflow">if</span> padtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4113</span>        padlen = 0</div>
<div class="line"><span class="lineno"> 4114</span> </div>
<div class="line"><span class="lineno"> 4115</span>    <span class="keywordflow">if</span> padlen <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4116</span>        <span class="comment"># Original padding; preserved for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4117</span>        edge = ntaps * 3</div>
<div class="line"><span class="lineno"> 4118</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4119</span>        edge = padlen</div>
<div class="line"><span class="lineno"> 4120</span> </div>
<div class="line"><span class="lineno"> 4121</span>    <span class="comment"># x&#39;s &#39;axis&#39; dimension must be bigger than edge.</span></div>
<div class="line"><span class="lineno"> 4122</span>    <span class="keywordflow">if</span> x.shape[axis] &lt;= edge:</div>
<div class="line"><span class="lineno"> 4123</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The length of the input vector x must be greater &quot;</span></div>
<div class="line"><span class="lineno"> 4124</span>                         <span class="stringliteral">&quot;than padlen, which is %d.&quot;</span> % edge)</div>
<div class="line"><span class="lineno"> 4125</span> </div>
<div class="line"><span class="lineno"> 4126</span>    <span class="keywordflow">if</span> padtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> edge &gt; 0:</div>
<div class="line"><span class="lineno"> 4127</span>        <span class="comment"># Make an extension of length `edge` at each</span></div>
<div class="line"><span class="lineno"> 4128</span>        <span class="comment"># end of the input array.</span></div>
<div class="line"><span class="lineno"> 4129</span>        <span class="keywordflow">if</span> padtype == <span class="stringliteral">&#39;even&#39;</span>:</div>
<div class="line"><span class="lineno"> 4130</span>            ext = even_ext(x, edge, axis=axis)</div>
<div class="line"><span class="lineno"> 4131</span>        <span class="keywordflow">elif</span> padtype == <span class="stringliteral">&#39;odd&#39;</span>:</div>
<div class="line"><span class="lineno"> 4132</span>            ext = odd_ext(x, edge, axis=axis)</div>
<div class="line"><span class="lineno"> 4133</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4134</span>            ext = const_ext(x, edge, axis=axis)</div>
<div class="line"><span class="lineno"> 4135</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4136</span>        ext = x</div>
<div class="line"><span class="lineno"> 4137</span>    <span class="keywordflow">return</span> edge, ext</div>
<div class="line"><span class="lineno"> 4138</span> </div>
<div class="line"><span class="lineno"> 4139</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6b69f12c02e5d1278ee04311753a587" name="ac6b69f12c02e5d1278ee04311753a587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b69f12c02e5d1278ee04311753a587">&#9670;&#160;</a></span>_validate_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools._validate_x </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4140</span><span class="keyword">def </span>_validate_x(x):</div>
<div class="line"><span class="lineno"> 4141</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 4142</span>    <span class="keywordflow">if</span> x.ndim == 0:</div>
<div class="line"><span class="lineno"> 4143</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;x must be at least 1-D&#39;</span>)</div>
<div class="line"><span class="lineno"> 4144</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 4145</span> </div>
<div class="line"><span class="lineno"> 4146</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aff23f43a31650ce89a8557db33c5d802" name="aff23f43a31650ce89a8557db33c5d802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff23f43a31650ce89a8557db33c5d802">&#9670;&#160;</a></span>choose_conv_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.choose_conv_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>measure</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the fastest convolution/correlation method.

This primarily exists to be called during the ``method='auto'`` option in
`convolve` and `correlate`. It can also be used to determine the value of
``method`` for many different convolutions of the same dtype/shape.
In addition, it supports timing the convolution to adapt the value of
``method`` to a particular set of inputs and/or hardware.

Parameters
----------
in1 : array_like
    The first argument passed into the convolution function.
in2 : array_like
    The second argument passed into the convolution function.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.
measure : bool, optional
    If True, run and time the convolution of `in1` and `in2` with both
    methods and return the fastest. If False (default), predict the fastest
    method using precomputed values.

Returns
-------
method : str
    A string indicating which convolution method is fastest, either
    'direct' or 'fft'
times : dict, optional
    A dictionary containing the times (in seconds) needed for each method.
    This value is only returned if ``measure=True``.

See Also
--------
convolve
correlate

Notes
-----
Generally, this method is 99% accurate for 2D signals and 85% accurate
for 1D signals for randomly chosen input sizes. For precision, use
``measure=True`` to find the fastest method by timing the convolution.
This can be used to avoid the minimal overhead of finding the fastest
``method`` later, or to adapt the value of ``method`` to a particular set
of inputs.

Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this
function. These experiments measured the ratio between the time required
when using ``method='auto'`` and the time required for the fastest method
(i.e., ``ratio = time_auto / min(time_fft, time_direct)``). In these
experiments, we found:

* There is a 95% chance of this ratio being less than 1.5 for 1D signals
  and a 99% chance of being less than 2.5 for 2D signals.
* The ratio was always less than 2.5/5 for 1D/2D signals respectively.
* This function is most inaccurate for 1D convolutions that take between 1
  and 10 milliseconds with ``method='direct'``. A good proxy for this
  (at least in our experiments) is ``1e6 &lt;= in1.size * in2.size &lt;= 1e7``.

The 2D results almost certainly generalize to 3D/4D/etc because the
implementation is the same (the 1D implementation is different).

All the numbers above are specific to the EC2 machine. However, we did find
that this function generalizes fairly decently across hardware. The speed
tests were of similar quality (and even slightly better) than the same
tests performed on the machine to tune this function's numbers (a mid-2014
15-inch MacBook Pro with 16GB RAM and a 2.5GHz Intel i7 processor).

There are cases when `fftconvolve` supports the inputs but this function
returns `direct` (e.g., to protect against floating point integer
precision).

.. versionadded:: 0.19

Examples
--------
Estimate the fastest method for a given input:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; img = rng.random((32, 32))
&gt;&gt;&gt; filter = rng.random((8, 8))
&gt;&gt;&gt; method = signal.choose_conv_method(img, filter, mode='same')
&gt;&gt;&gt; method
'fft'

This can then be applied to other arrays of the same dtype and shape:

&gt;&gt;&gt; img2 = rng.random((32, 32))
&gt;&gt;&gt; filter2 = rng.random((8, 8))
&gt;&gt;&gt; corr2 = signal.correlate(img2, filter2, mode='same', method=method)
&gt;&gt;&gt; conv2 = signal.convolve(img2, filter2, mode='same', method=method)

The output of this function (``method``) works with `correlate` and
`convolve`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1156</span><span class="keyword">def </span>choose_conv_method(in1, in2, mode=&#39;full&#39;, measure=False):</div>
<div class="line"><span class="lineno"> 1157</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    Find the fastest convolution/correlation method.</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    This primarily exists to be called during the ``method=&#39;auto&#39;`` option in</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    `convolve` and `correlate`. It can also be used to determine the value of</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    ``method`` for many different convolutions of the same dtype/shape.</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    In addition, it supports timing the convolution to adapt the value of</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    ``method`` to a particular set of inputs and/or hardware.</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">        The first argument passed into the convolution function.</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">        The second argument passed into the convolution function.</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">        A string indicating the size of the output:</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">        ``full``</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">           The output is the full discrete linear convolution</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">           of the inputs. (Default)</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">        ``valid``</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">           The output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">           rely on the zero-padding.</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">        ``same``</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">           The output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">           with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    measure : bool, optional</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">        If True, run and time the convolution of `in1` and `in2` with both</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">        methods and return the fastest. If False (default), predict the fastest</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">        method using precomputed values.</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    method : str</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">        A string indicating which convolution method is fastest, either</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">        &#39;direct&#39; or &#39;fft&#39;</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    times : dict, optional</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">        A dictionary containing the times (in seconds) needed for each method.</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">        This value is only returned if ``measure=True``.</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    convolve</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    correlate</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    Generally, this method is 99% accurate for 2D signals and 85% accurate</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    for 1D signals for randomly chosen input sizes. For precision, use</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">    ``measure=True`` to find the fastest method by timing the convolution.</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    This can be used to avoid the minimal overhead of finding the fastest</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    ``method`` later, or to adapt the value of ``method`` to a particular set</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    of inputs.</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    function. These experiments measured the ratio between the time required</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">    when using ``method=&#39;auto&#39;`` and the time required for the fastest method</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    (i.e., ``ratio = time_auto / min(time_fft, time_direct)``). In these</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    experiments, we found:</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    * There is a 95% chance of this ratio being less than 1.5 for 1D signals</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">      and a 99% chance of being less than 2.5 for 2D signals.</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    * The ratio was always less than 2.5/5 for 1D/2D signals respectively.</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">    * This function is most inaccurate for 1D convolutions that take between 1</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">      and 10 milliseconds with ``method=&#39;direct&#39;``. A good proxy for this</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">      (at least in our experiments) is ``1e6 &lt;= in1.size * in2.size &lt;= 1e7``.</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">    The 2D results almost certainly generalize to 3D/4D/etc because the</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">    implementation is the same (the 1D implementation is different).</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">    All the numbers above are specific to the EC2 machine. However, we did find</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    that this function generalizes fairly decently across hardware. The speed</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">    tests were of similar quality (and even slightly better) than the same</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">    tests performed on the machine to tune this function&#39;s numbers (a mid-2014</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    15-inch MacBook Pro with 16GB RAM and a 2.5GHz Intel i7 processor).</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">    There are cases when `fftconvolve` supports the inputs but this function</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    returns `direct` (e.g., to protect against floating point integer</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    precision).</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    .. versionadded:: 0.19</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">    Estimate the fastest method for a given input:</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    &gt;&gt;&gt; img = rng.random((32, 32))</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    &gt;&gt;&gt; filter = rng.random((8, 8))</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">    &gt;&gt;&gt; method = signal.choose_conv_method(img, filter, mode=&#39;same&#39;)</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    &gt;&gt;&gt; method</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">    &#39;fft&#39;</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    This can then be applied to other arrays of the same dtype and shape:</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    &gt;&gt;&gt; img2 = rng.random((32, 32))</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    &gt;&gt;&gt; filter2 = rng.random((8, 8))</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    &gt;&gt;&gt; corr2 = signal.correlate(img2, filter2, mode=&#39;same&#39;, method=method)</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">    &gt;&gt;&gt; conv2 = signal.convolve(img2, filter2, mode=&#39;same&#39;, method=method)</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    The output of this function (``method``) works with `correlate` and</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    `convolve`.</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1263</span>    volume = np.asarray(in1)</div>
<div class="line"><span class="lineno"> 1264</span>    kernel = np.asarray(in2)</div>
<div class="line"><span class="lineno"> 1265</span> </div>
<div class="line"><span class="lineno"> 1266</span>    <span class="keywordflow">if</span> measure:</div>
<div class="line"><span class="lineno"> 1267</span>        times = {}</div>
<div class="line"><span class="lineno"> 1268</span>        <span class="keywordflow">for</span> method <span class="keywordflow">in</span> [<span class="stringliteral">&#39;fft&#39;</span>, <span class="stringliteral">&#39;direct&#39;</span>]:</div>
<div class="line"><span class="lineno"> 1269</span>            times[method] = _timeit_fast(<span class="keyword">lambda</span>: convolve(volume, kernel,</div>
<div class="line"><span class="lineno"> 1270</span>                                         mode=mode, method=method))</div>
<div class="line"><span class="lineno"> 1271</span> </div>
<div class="line"><span class="lineno"> 1272</span>        chosen_method = <span class="stringliteral">&#39;fft&#39;</span> <span class="keywordflow">if</span> times[<span class="stringliteral">&#39;fft&#39;</span>] &lt; times[<span class="stringliteral">&#39;direct&#39;</span>] <span class="keywordflow">else</span> <span class="stringliteral">&#39;direct&#39;</span></div>
<div class="line"><span class="lineno"> 1273</span>        <span class="keywordflow">return</span> chosen_method, times</div>
<div class="line"><span class="lineno"> 1274</span> </div>
<div class="line"><span class="lineno"> 1275</span>    <span class="comment"># for integer input,</span></div>
<div class="line"><span class="lineno"> 1276</span>    <span class="comment"># catch when more precision required than float provides (representing an</span></div>
<div class="line"><span class="lineno"> 1277</span>    <span class="comment"># integer as float can lose precision in fftconvolve if larger than 2**52)</span></div>
<div class="line"><span class="lineno"> 1278</span>    <span class="keywordflow">if</span> any([_numeric_arrays([x], kinds=<span class="stringliteral">&#39;ui&#39;</span>) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> [volume, kernel]]):</div>
<div class="line"><span class="lineno"> 1279</span>        max_value = int(np.abs(volume).max()) * int(np.abs(kernel).max())</div>
<div class="line"><span class="lineno"> 1280</span>        max_value *= int(min(volume.size, kernel.size))</div>
<div class="line"><span class="lineno"> 1281</span>        <span class="keywordflow">if</span> max_value &gt; 2**np.finfo(<span class="stringliteral">&#39;float&#39;</span>).nmant - 1:</div>
<div class="line"><span class="lineno"> 1282</span>            <span class="keywordflow">return</span> <span class="stringliteral">&#39;direct&#39;</span></div>
<div class="line"><span class="lineno"> 1283</span> </div>
<div class="line"><span class="lineno"> 1284</span>    <span class="keywordflow">if</span> _numeric_arrays([volume, kernel], kinds=<span class="stringliteral">&#39;b&#39;</span>):</div>
<div class="line"><span class="lineno"> 1285</span>        <span class="keywordflow">return</span> <span class="stringliteral">&#39;direct&#39;</span></div>
<div class="line"><span class="lineno"> 1286</span> </div>
<div class="line"><span class="lineno"> 1287</span>    <span class="keywordflow">if</span> _numeric_arrays([volume, kernel]):</div>
<div class="line"><span class="lineno"> 1288</span>        <span class="keywordflow">if</span> _fftconv_faster(volume, kernel, mode):</div>
<div class="line"><span class="lineno"> 1289</span>            <span class="keywordflow">return</span> <span class="stringliteral">&#39;fft&#39;</span></div>
<div class="line"><span class="lineno"> 1290</span> </div>
<div class="line"><span class="lineno"> 1291</span>    <span class="keywordflow">return</span> <span class="stringliteral">&#39;direct&#39;</span></div>
<div class="line"><span class="lineno"> 1292</span> </div>
<div class="line"><span class="lineno"> 1293</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a276770e9aefe62a7295acb1737465510" name="a276770e9aefe62a7295acb1737465510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276770e9aefe62a7295acb1737465510">&#9670;&#160;</a></span>cmplx_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.cmplx_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sort roots based on magnitude.

Parameters
----------
p : array_like
    The roots to sort, as a 1-D array.

Returns
-------
p_sorted : ndarray
    Sorted roots.
indx : ndarray
    Array of indices needed to sort the input `p`.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; vals = [1, 4, 1+1.j, 3]
&gt;&gt;&gt; p_sorted, indx = signal.cmplx_sort(vals)
&gt;&gt;&gt; p_sorted
array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])
&gt;&gt;&gt; indx
array([0, 2, 3, 1])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2382</span><span class="keyword">def </span>cmplx_sort(p):</div>
<div class="line"><span class="lineno"> 2383</span>    <span class="stringliteral">&quot;&quot;&quot;Sort roots based on magnitude.</span></div>
<div class="line"><span class="lineno"> 2384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2387</span><span class="stringliteral">    p : array_like</span></div>
<div class="line"><span class="lineno"> 2388</span><span class="stringliteral">        The roots to sort, as a 1-D array.</span></div>
<div class="line"><span class="lineno"> 2389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2390</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2391</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2392</span><span class="stringliteral">    p_sorted : ndarray</span></div>
<div class="line"><span class="lineno"> 2393</span><span class="stringliteral">        Sorted roots.</span></div>
<div class="line"><span class="lineno"> 2394</span><span class="stringliteral">    indx : ndarray</span></div>
<div class="line"><span class="lineno"> 2395</span><span class="stringliteral">        Array of indices needed to sort the input `p`.</span></div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">    &gt;&gt;&gt; vals = [1, 4, 1+1.j, 3]</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral">    &gt;&gt;&gt; p_sorted, indx = signal.cmplx_sort(vals)</span></div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral">    &gt;&gt;&gt; p_sorted</span></div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">    array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">    &gt;&gt;&gt; indx</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral">    array([0, 2, 3, 1])</span></div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2407</span>    p = np.asarray(p)</div>
<div class="line"><span class="lineno"> 2408</span>    indx = np.argsort(abs(p))</div>
<div class="line"><span class="lineno"> 2409</span>    <span class="keywordflow">return</span> np.take(p, indx, 0), indx</div>
<div class="line"><span class="lineno"> 2410</span> </div>
<div class="line"><span class="lineno"> 2411</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f693a6fea3f35c68bc6bea917167994" name="a1f693a6fea3f35c68bc6bea917167994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f693a6fea3f35c68bc6bea917167994">&#9670;&#160;</a></span>convolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.convolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convolve two N-dimensional arrays.

Convolve `in1` and `in2`, with the output size determined by the
`mode` argument.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding. In 'valid' mode, either `in1` or `in2`
       must be at least as large as the other in every dimension.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.
method : str {'auto', 'direct', 'fft'}, optional
    A string indicating which method to use to calculate the convolution.

    ``direct``
       The convolution is determined directly from sums, the definition of
       convolution.
    ``fft``
       The Fourier Transform is used to perform the convolution by calling
       `fftconvolve`.
    ``auto``
       Automatically chooses direct or Fourier method based on an estimate
       of which is faster (default).  See Notes for more detail.

       .. versionadded:: 0.19.0

Returns
-------
convolve : array
    An N-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.

Warns
-----
RuntimeWarning
    Use of the FFT convolution on input containing NAN or INF will lead
    to the entire output being NAN or INF. Use method='direct' when your
    input contains NAN or INF values.

See Also
--------
numpy.polymul : performs polynomial multiplication (same operation, but
                also accepts poly1d objects)
choose_conv_method : chooses the fastest appropriate convolution method
fftconvolve : Always uses the FFT method.
oaconvolve : Uses the overlap-add method to do convolution, which is
             generally faster when the input arrays are large and
             significantly different in size.

Notes
-----
By default, `convolve` and `correlate` use ``method='auto'``, which calls
`choose_conv_method` to choose the fastest method using pre-computed
values (`choose_conv_method` can also measure real-world timing with a
keyword argument). Because `fftconvolve` relies on floating point numbers,
there are certain constraints that may force `method=direct` (more detail
in `choose_conv_method` docstring).

Examples
--------
Smooth a square pulse using a Hann window:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; sig = np.repeat([0., 1., 0.], 100)
&gt;&gt;&gt; win = signal.windows.hann(50)
&gt;&gt;&gt; filtered = signal.convolve(sig, win, mode='same') / sum(win)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.set_title('Original pulse')
&gt;&gt;&gt; ax_orig.margins(0, 0.1)
&gt;&gt;&gt; ax_win.plot(win)
&gt;&gt;&gt; ax_win.set_title('Filter impulse response')
&gt;&gt;&gt; ax_win.margins(0, 0.1)
&gt;&gt;&gt; ax_filt.plot(filtered)
&gt;&gt;&gt; ax_filt.set_title('Filtered signal')
&gt;&gt;&gt; ax_filt.margins(0, 0.1)
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; fig.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1294</span><span class="keyword">def </span>convolve(in1, in2, mode=&#39;full&#39;, method=&#39;auto&#39;):</div>
<div class="line"><span class="lineno"> 1295</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    Convolve two N-dimensional arrays.</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    Convolve `in1` and `in2`, with the output size determined by the</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    `mode` argument.</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">        Second input. Should have the same number of dimensions as `in1`.</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">        A string indicating the size of the output:</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">        ``full``</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">           The output is the full discrete linear convolution</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral">           of the inputs. (Default)</span></div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">        ``valid``</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">           The output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">           must be at least as large as the other in every dimension.</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">        ``same``</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">           The output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">           with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    method : str {&#39;auto&#39;, &#39;direct&#39;, &#39;fft&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">        A string indicating which method to use to calculate the convolution.</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">        ``direct``</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">           The convolution is determined directly from sums, the definition of</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">           convolution.</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">        ``fft``</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">           The Fourier Transform is used to perform the convolution by calling</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">           `fftconvolve`.</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">        ``auto``</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">           Automatically chooses direct or Fourier method based on an estimate</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">           of which is faster (default).  See Notes for more detail.</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">           .. versionadded:: 0.19.0</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    convolve : array</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">        An N-dimensional array containing a subset of the discrete linear</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">        convolution of `in1` with `in2`.</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    RuntimeWarning</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">        Use of the FFT convolution on input containing NAN or INF will lead</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">        to the entire output being NAN or INF. Use method=&#39;direct&#39; when your</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">        input contains NAN or INF values.</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    numpy.polymul : performs polynomial multiplication (same operation, but</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">                    also accepts poly1d objects)</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    choose_conv_method : chooses the fastest appropriate convolution method</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    fftconvolve : Always uses the FFT method.</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    oaconvolve : Uses the overlap-add method to do convolution, which is</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">                 generally faster when the input arrays are large and</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">                 significantly different in size.</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    By default, `convolve` and `correlate` use ``method=&#39;auto&#39;``, which calls</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    `choose_conv_method` to choose the fastest method using pre-computed</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    values (`choose_conv_method` can also measure real-world timing with a</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    keyword argument). Because `fftconvolve` relies on floating point numbers,</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    there are certain constraints that may force `method=direct` (more detail</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    in `choose_conv_method` docstring).</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    Smooth a square pulse using a Hann window:</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    &gt;&gt;&gt; sig = np.repeat([0., 1., 0.], 100)</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    &gt;&gt;&gt; win = signal.windows.hann(50)</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    &gt;&gt;&gt; filtered = signal.convolve(sig, win, mode=&#39;same&#39;) / sum(win)</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.plot(sig)</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original pulse&#39;)</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    &gt;&gt;&gt; ax_win.plot(win)</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    &gt;&gt;&gt; ax_win.set_title(&#39;Filter impulse response&#39;)</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">    &gt;&gt;&gt; ax_win.margins(0, 0.1)</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">    &gt;&gt;&gt; ax_filt.plot(filtered)</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    &gt;&gt;&gt; ax_filt.set_title(&#39;Filtered signal&#39;)</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    &gt;&gt;&gt; ax_filt.margins(0, 0.1)</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    &gt;&gt;&gt; fig.tight_layout()</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    &gt;&gt;&gt; fig.show()</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1391</span>    volume = np.asarray(in1)</div>
<div class="line"><span class="lineno"> 1392</span>    kernel = np.asarray(in2)</div>
<div class="line"><span class="lineno"> 1393</span> </div>
<div class="line"><span class="lineno"> 1394</span>    <span class="keywordflow">if</span> volume.ndim == kernel.ndim == 0:</div>
<div class="line"><span class="lineno"> 1395</span>        <span class="keywordflow">return</span> volume * kernel</div>
<div class="line"><span class="lineno"> 1396</span>    <span class="keywordflow">elif</span> volume.ndim != kernel.ndim:</div>
<div class="line"><span class="lineno"> 1397</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;volume and kernel should have the same &quot;</span></div>
<div class="line"><span class="lineno"> 1398</span>                         <span class="stringliteral">&quot;dimensionality&quot;</span>)</div>
<div class="line"><span class="lineno"> 1399</span> </div>
<div class="line"><span class="lineno"> 1400</span>    <span class="keywordflow">if</span> _inputs_swap_needed(mode, volume.shape, kernel.shape):</div>
<div class="line"><span class="lineno"> 1401</span>        <span class="comment"># Convolution is commutative; order doesn&#39;t have any effect on output</span></div>
<div class="line"><span class="lineno"> 1402</span>        volume, kernel = kernel, volume</div>
<div class="line"><span class="lineno"> 1403</span> </div>
<div class="line"><span class="lineno"> 1404</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;auto&#39;</span>:</div>
<div class="line"><span class="lineno"> 1405</span>        method = choose_conv_method(volume, kernel, mode=mode)</div>
<div class="line"><span class="lineno"> 1406</span> </div>
<div class="line"><span class="lineno"> 1407</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;fft&#39;</span>:</div>
<div class="line"><span class="lineno"> 1408</span>        out = fftconvolve(volume, kernel, mode=mode)</div>
<div class="line"><span class="lineno"> 1409</span>        result_type = np.result_type(volume, kernel)</div>
<div class="line"><span class="lineno"> 1410</span>        <span class="keywordflow">if</span> result_type.kind <span class="keywordflow">in</span> {<span class="stringliteral">&#39;u&#39;</span>, <span class="stringliteral">&#39;i&#39;</span>}:</div>
<div class="line"><span class="lineno"> 1411</span>            out = np.around(out)</div>
<div class="line"><span class="lineno"> 1412</span> </div>
<div class="line"><span class="lineno"> 1413</span>        <span class="keywordflow">if</span> np.isnan(out.flat[0]) <span class="keywordflow">or</span> np.isinf(out.flat[0]):</div>
<div class="line"><span class="lineno"> 1414</span>            warnings.warn(<span class="stringliteral">&quot;Use of fft convolution on input with NAN or inf&quot;</span></div>
<div class="line"><span class="lineno"> 1415</span>                          <span class="stringliteral">&quot; results in NAN or inf output. Consider using&quot;</span></div>
<div class="line"><span class="lineno"> 1416</span>                          <span class="stringliteral">&quot; method=&#39;direct&#39; instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1417</span>                          category=RuntimeWarning, stacklevel=2)</div>
<div class="line"><span class="lineno"> 1418</span> </div>
<div class="line"><span class="lineno"> 1419</span>        <span class="keywordflow">return</span> out.astype(result_type)</div>
<div class="line"><span class="lineno"> 1420</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;direct&#39;</span>:</div>
<div class="line"><span class="lineno"> 1421</span>        <span class="comment"># fastpath to faster numpy.convolve for 1d inputs when possible</span></div>
<div class="line"><span class="lineno"> 1422</span>        <span class="keywordflow">if</span> _np_conv_ok(volume, kernel, mode):</div>
<div class="line"><span class="lineno"> 1423</span>            <span class="keywordflow">return</span> np.convolve(volume, kernel, mode)</div>
<div class="line"><span class="lineno"> 1424</span> </div>
<div class="line"><span class="lineno"> 1425</span>        <span class="keywordflow">return</span> correlate(volume, _reverse_and_conj(kernel), mode, <span class="stringliteral">&#39;direct&#39;</span>)</div>
<div class="line"><span class="lineno"> 1426</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1427</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Acceptable method flags are &#39;auto&#39;,&quot;</span></div>
<div class="line"><span class="lineno"> 1428</span>                         <span class="stringliteral">&quot; &#39;direct&#39;, or &#39;fft&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1429</span> </div>
<div class="line"><span class="lineno"> 1430</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acce2d3c83c57b7830f4e4c0d5b9f1268" name="acce2d3c83c57b7830f4e4c0d5b9f1268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce2d3c83c57b7830f4e4c0d5b9f1268">&#9670;&#160;</a></span>convolve2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.convolve2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>boundary</em> = <code>'fill'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convolve two 2-dimensional arrays.

Convolve `in1` and `in2` with output size determined by `mode`, and
boundary conditions determined by `boundary` and `fillvalue`.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding. In 'valid' mode, either `in1` or `in2`
       must be at least as large as the other in every dimension.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.
boundary : str {'fill', 'wrap', 'symm'}, optional
    A flag indicating how to handle boundaries:

    ``fill``
       pad input arrays with fillvalue. (default)
    ``wrap``
       circular boundary conditions.
    ``symm``
       symmetrical boundary conditions.

fillvalue : scalar, optional
    Value to fill pad input arrays with. Default is 0.

Returns
-------
out : ndarray
    A 2-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.

Examples
--------
Compute the gradient of an image by 2D convolution with a complex Scharr
operator.  (Horizontal operator is real, vertical is imaginary.)  Use
symmetric boundary condition to avoid creating edges at the image
boundaries.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; ascent = misc.ascent()
&gt;&gt;&gt; scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],
...                    [-10+0j, 0+ 0j, +10 +0j],
...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy
&gt;&gt;&gt; grad = signal.convolve2d(ascent, scharr, boundary='symm', mode='same')

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15))
&gt;&gt;&gt; ax_orig.imshow(ascent, cmap='gray')
&gt;&gt;&gt; ax_orig.set_title('Original')
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_mag.imshow(np.absolute(grad), cmap='gray')
&gt;&gt;&gt; ax_mag.set_title('Gradient magnitude')
&gt;&gt;&gt; ax_mag.set_axis_off()
&gt;&gt;&gt; ax_ang.imshow(np.angle(grad), cmap='hsv') # hsv is cyclic, like angles
&gt;&gt;&gt; ax_ang.set_title('Gradient orientation')
&gt;&gt;&gt; ax_ang.set_axis_off()
&gt;&gt;&gt; fig.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1632</span><span class="keyword">def </span>convolve2d(in1, in2, mode=&#39;full&#39;, boundary=&#39;fill&#39;, fillvalue=0):</div>
<div class="line"><span class="lineno"> 1633</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    Convolve two 2-dimensional arrays.</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    Convolve `in1` and `in2` with output size determined by `mode`, and</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    boundary conditions determined by `boundary` and `fillvalue`.</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">        Second input. Should have the same number of dimensions as `in1`.</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">        A string indicating the size of the output:</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">        ``full``</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">           The output is the full discrete linear convolution</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">           of the inputs. (Default)</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral">        ``valid``</span></div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral">           The output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral">           must be at least as large as the other in every dimension.</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">        ``same``</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">           The output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral">           with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">    boundary : str {&#39;fill&#39;, &#39;wrap&#39;, &#39;symm&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1659</span><span class="stringliteral">        A flag indicating how to handle boundaries:</span></div>
<div class="line"><span class="lineno"> 1660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1661</span><span class="stringliteral">        ``fill``</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">           pad input arrays with fillvalue. (default)</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral">        ``wrap``</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">           circular boundary conditions.</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">        ``symm``</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">           symmetrical boundary conditions.</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    fillvalue : scalar, optional</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">        Value to fill pad input arrays with. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">        A 2-dimensional array containing a subset of the discrete linear</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">        convolution of `in1` with `in2`.</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">    Compute the gradient of an image by 2D convolution with a complex Scharr</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">    operator.  (Horizontal operator is real, vertical is imaginary.)  Use</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">    symmetric boundary condition to avoid creating edges at the image</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">    boundaries.</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import misc</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">    &gt;&gt;&gt; ascent = misc.ascent()</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">    &gt;&gt;&gt; scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">    ...                    [-10+0j, 0+ 0j, +10 +0j],</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">    ...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    &gt;&gt;&gt; grad = signal.convolve2d(ascent, scharr, boundary=&#39;symm&#39;, mode=&#39;same&#39;)</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15))</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.imshow(ascent, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_axis_off()</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">    &gt;&gt;&gt; ax_mag.imshow(np.absolute(grad), cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">    &gt;&gt;&gt; ax_mag.set_title(&#39;Gradient magnitude&#39;)</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">    &gt;&gt;&gt; ax_mag.set_axis_off()</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    &gt;&gt;&gt; ax_ang.imshow(np.angle(grad), cmap=&#39;hsv&#39;) # hsv is cyclic, like angles</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">    &gt;&gt;&gt; ax_ang.set_title(&#39;Gradient orientation&#39;)</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    &gt;&gt;&gt; ax_ang.set_axis_off()</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    &gt;&gt;&gt; fig.show()</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1706</span>    in1 = np.asarray(in1)</div>
<div class="line"><span class="lineno"> 1707</span>    in2 = np.asarray(in2)</div>
<div class="line"><span class="lineno"> 1708</span> </div>
<div class="line"><span class="lineno"> 1709</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> in1.ndim == in2.ndim == 2:</div>
<div class="line"><span class="lineno"> 1710</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;convolve2d inputs must both be 2-D arrays&#39;</span>)</div>
<div class="line"><span class="lineno"> 1711</span> </div>
<div class="line"><span class="lineno"> 1712</span>    <span class="keywordflow">if</span> _inputs_swap_needed(mode, in1.shape, in2.shape):</div>
<div class="line"><span class="lineno"> 1713</span>        in1, in2 = in2, in1</div>
<div class="line"><span class="lineno"> 1714</span> </div>
<div class="line"><span class="lineno"> 1715</span>    val = _valfrommode(mode)</div>
<div class="line"><span class="lineno"> 1716</span>    bval = _bvalfromboundary(boundary)</div>
<div class="line"><span class="lineno"> 1717</span>    out = _sigtools._convolve2d(in1, in2, 1, val, bval, fillvalue)</div>
<div class="line"><span class="lineno"> 1718</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1719</span> </div>
<div class="line"><span class="lineno"> 1720</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aef3e49bb19062176206c9e57bf210674" name="aef3e49bb19062176206c9e57bf210674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3e49bb19062176206c9e57bf210674">&#9670;&#160;</a></span>correlate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.correlate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cross-correlate two N-dimensional arrays.

Cross-correlate `in1` and `in2`, with the output size determined by the
`mode` argument.

Parameters
----------
in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as `in1`.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:

``full``
The output is the full discrete linear cross-correlation
of the inputs. (Default)
``valid``
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either `in1` or `in2`
must be at least as large as the other in every dimension.
``same``
The output is the same size as `in1`, centered
with respect to the 'full' output.
method : str {'auto', 'direct', 'fft'}, optional
A string indicating which method to use to calculate the correlation.

``direct``
The correlation is determined directly from sums, the definition of
correlation.
``fft``
The Fast Fourier Transform is used to perform the correlation more
quickly (only available for numerical arrays.)
``auto``
Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See `convolve` Notes for more detail.

.. versionadded:: 0.19.0

Returns
-------
correlate : array
An N-dimensional array containing a subset of the discrete linear
cross-correlation of `in1` with `in2`.

See Also
--------
choose_conv_method : contains more documentation on `method`.
correlation_lags : calculates the lag / displacement indices array for 1D
cross-correlation.

Notes
-----
The correlation z of two d-dimensional arrays x and y is defined as::

z[...,k,...] = sum[..., i_l, ...] x[..., i_l,...] * conj(y[..., i_l - k,...])

This way, if x and y are 1-D arrays and ``z = correlate(x, y, 'full')``
then

.. math::

z[k] = (x * y)(k - N + 1)
= \sum_{l=0}^{||x||-1}x_l y_{l-k+N-1}^{*}

for :math:`k = 0, 1, ..., ||x|| + ||y|| - 2`

where :math:`||x||` is the length of ``x``, :math:`N = \max(||x||,||y||)`,
and :math:`y_m` is 0 when m is outside the range of y.

``method='fft'`` only works for numerical arrays as it relies on
`fftconvolve`. In certain cases (i.e., arrays of objects or when
rounding integers can lose precision), ``method='direct'`` is always used.

When using "same" mode with even-length inputs, the outputs of `correlate`
and `correlate2d` differ: There is a 1-index offset between them.

Examples
--------
Implement a matched filter using cross-correlation, to recover a signal
that has passed through a noisy channel.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

&gt;&gt;&gt; sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)
&gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig))
&gt;&gt;&gt; corr = signal.correlate(sig_noise, np.ones(128), mode='same') / 128

&gt;&gt;&gt; clock = np.arange(64, len(sig), 128)
&gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True)
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.plot(clock, sig[clock], 'ro')
&gt;&gt;&gt; ax_orig.set_title('Original signal')
&gt;&gt;&gt; ax_noise.plot(sig_noise)
&gt;&gt;&gt; ax_noise.set_title('Signal with noise')
&gt;&gt;&gt; ax_corr.plot(corr)
&gt;&gt;&gt; ax_corr.plot(clock, corr[clock], 'ro')
&gt;&gt;&gt; ax_corr.axhline(0.5, ls=':')
&gt;&gt;&gt; ax_corr.set_title('Cross-correlated with rectangular pulse')
&gt;&gt;&gt; ax_orig.margins(0, 0.1)
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; plt.show()

Compute the cross-correlation of a noisy signal with the original signal.

&gt;&gt;&gt; x = np.arange(128) / 128
&gt;&gt;&gt; sig = np.sin(2 * np.pi * x)
&gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig))
&gt;&gt;&gt; corr = signal.correlate(sig_noise, sig)
&gt;&gt;&gt; lags = signal.correlation_lags(len(sig), len(sig_noise))
&gt;&gt;&gt; corr /= np.max(corr)

&gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, figsize=(4.8, 4.8))
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.set_title('Original signal')
&gt;&gt;&gt; ax_orig.set_xlabel('Sample Number')
&gt;&gt;&gt; ax_noise.plot(sig_noise)
&gt;&gt;&gt; ax_noise.set_title('Signal with noise')
&gt;&gt;&gt; ax_noise.set_xlabel('Sample Number')
&gt;&gt;&gt; ax_corr.plot(lags, corr)
&gt;&gt;&gt; ax_corr.set_title('Cross-correlated signal')
&gt;&gt;&gt; ax_corr.set_xlabel('Lag')
&gt;&gt;&gt; ax_orig.margins(0, 0.1)
&gt;&gt;&gt; ax_noise.margins(0, 0.1)
&gt;&gt;&gt; ax_corr.margins(0, 0.1)
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">   90</span><span class="keyword">def </span>correlate(in1, in2, mode=&#39;full&#39;, method=&#39;auto&#39;):</div>
<div class="line"><span class="lineno">   91</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    Cross-correlate two N-dimensional arrays.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    Cross-correlate `in1` and `in2`, with the output size determined by the</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    `mode` argument.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        Second input. Should have the same number of dimensions as `in1`.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        A string indicating the size of the output:</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        ``full``</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">           The output is the full discrete linear cross-correlation</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">           of the inputs. (Default)</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        ``valid``</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">           The output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">           must be at least as large as the other in every dimension.</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        ``same``</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">           The output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">           with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    method : str {&#39;auto&#39;, &#39;direct&#39;, &#39;fft&#39;}, optional</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">        A string indicating which method to use to calculate the correlation.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        ``direct``</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">           The correlation is determined directly from sums, the definition of</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">           correlation.</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        ``fft``</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">           The Fast Fourier Transform is used to perform the correlation more</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">           quickly (only available for numerical arrays.)</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">        ``auto``</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">           Automatically chooses direct or Fourier method based on an estimate</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">           of which is faster (default).  See `convolve` Notes for more detail.</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">           .. versionadded:: 0.19.0</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    correlate : array</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">        An N-dimensional array containing a subset of the discrete linear</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">        cross-correlation of `in1` with `in2`.</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    choose_conv_method : contains more documentation on `method`.</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    correlation_lags : calculates the lag / displacement indices array for 1D</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        cross-correlation.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    The correlation z of two d-dimensional arrays x and y is defined as::</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">        z[...,k,...] = sum[..., i_l, ...] x[..., i_l,...] * conj(y[..., i_l - k,...])</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    This way, if x and y are 1-D arrays and ``z = correlate(x, y, &#39;full&#39;)``</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    then</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">          z[k] = (x * y)(k - N + 1)</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">               = \sum_{l=0}^{||x||-1}x_l y_{l-k+N-1}^{*}</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    for :math:`k = 0, 1, ..., ||x|| + ||y|| - 2`</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    where :math:`||x||` is the length of ``x``, :math:`N = \max(||x||,||y||)`,</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    and :math:`y_m` is 0 when m is outside the range of y.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    ``method=&#39;fft&#39;`` only works for numerical arrays as it relies on</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    `fftconvolve`. In certain cases (i.e., arrays of objects or when</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    rounding integers can lose precision), ``method=&#39;direct&#39;`` is always used.</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    When using &quot;same&quot; mode with even-length inputs, the outputs of `correlate`</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    and `correlate2d` differ: There is a 1-index offset between them.</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    Implement a matched filter using cross-correlation, to recover a signal</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    that has passed through a noisy channel.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    &gt;&gt;&gt; sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    &gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig))</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    &gt;&gt;&gt; corr = signal.correlate(sig_noise, np.ones(128), mode=&#39;same&#39;) / 128</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    &gt;&gt;&gt; clock = np.arange(64, len(sig), 128)</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True)</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.plot(sig)</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.plot(clock, sig[clock], &#39;ro&#39;)</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original signal&#39;)</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    &gt;&gt;&gt; ax_noise.plot(sig_noise)</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    &gt;&gt;&gt; ax_noise.set_title(&#39;Signal with noise&#39;)</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.plot(corr)</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.plot(clock, corr[clock], &#39;ro&#39;)</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.axhline(0.5, ls=&#39;:&#39;)</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlated with rectangular pulse&#39;)</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    &gt;&gt;&gt; fig.tight_layout()</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    Compute the cross-correlation of a noisy signal with the original signal.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(128) / 128</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    &gt;&gt;&gt; sig = np.sin(2 * np.pi * x)</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    &gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig))</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    &gt;&gt;&gt; corr = signal.correlate(sig_noise, sig)</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    &gt;&gt;&gt; lags = signal.correlation_lags(len(sig), len(sig_noise))</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    &gt;&gt;&gt; corr /= np.max(corr)</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, figsize=(4.8, 4.8))</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.plot(sig)</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original signal&#39;)</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_xlabel(&#39;Sample Number&#39;)</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    &gt;&gt;&gt; ax_noise.plot(sig_noise)</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    &gt;&gt;&gt; ax_noise.set_title(&#39;Signal with noise&#39;)</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    &gt;&gt;&gt; ax_noise.set_xlabel(&#39;Sample Number&#39;)</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.plot(lags, corr)</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlated signal&#39;)</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.set_xlabel(&#39;Lag&#39;)</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    &gt;&gt;&gt; ax_noise.margins(0, 0.1)</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.margins(0, 0.1)</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    &gt;&gt;&gt; fig.tight_layout()</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  223</span>    in1 = np.asarray(in1)</div>
<div class="line"><span class="lineno">  224</span>    in2 = np.asarray(in2)</div>
<div class="line"><span class="lineno">  225</span> </div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">if</span> in1.ndim == in2.ndim == 0:</div>
<div class="line"><span class="lineno">  227</span>        <span class="keywordflow">return</span> in1 * in2.conj()</div>
<div class="line"><span class="lineno">  228</span>    <span class="keywordflow">elif</span> in1.ndim != in2.ndim:</div>
<div class="line"><span class="lineno">  229</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;in1 and in2 should have the same dimensionality&quot;</span>)</div>
<div class="line"><span class="lineno">  230</span> </div>
<div class="line"><span class="lineno">  231</span>    <span class="comment"># Don&#39;t use _valfrommode, since correlate should not accept numeric modes</span></div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  233</span>        val = _modedict[mode]</div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">except</span> KeyError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  235</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span></div>
<div class="line"><span class="lineno">  236</span>                         <span class="stringliteral">&quot; &#39;same&#39;, or &#39;full&#39;.&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>    <span class="comment"># this either calls fftconvolve or this function with method==&#39;direct&#39;</span></div>
<div class="line"><span class="lineno">  239</span>    <span class="keywordflow">if</span> method <span class="keywordflow">in</span> (<span class="stringliteral">&#39;fft&#39;</span>, <span class="stringliteral">&#39;auto&#39;</span>):</div>
<div class="line"><span class="lineno">  240</span>        <span class="keywordflow">return</span> convolve(in1, _reverse_and_conj(in2), mode, method)</div>
<div class="line"><span class="lineno">  241</span> </div>
<div class="line"><span class="lineno">  242</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;direct&#39;</span>:</div>
<div class="line"><span class="lineno">  243</span>        <span class="comment"># fastpath to faster numpy.correlate for 1d inputs when possible</span></div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">if</span> _np_conv_ok(in1, in2, mode):</div>
<div class="line"><span class="lineno">  245</span>            <span class="keywordflow">return</span> np.correlate(in1, in2, mode)</div>
<div class="line"><span class="lineno">  246</span> </div>
<div class="line"><span class="lineno">  247</span>        <span class="comment"># _correlateND is far slower when in2.size &gt; in1.size, so swap them</span></div>
<div class="line"><span class="lineno">  248</span>        <span class="comment"># and then undo the effect afterward if mode == &#39;full&#39;.  Also, it fails</span></div>
<div class="line"><span class="lineno">  249</span>        <span class="comment"># with &#39;valid&#39; mode if in2 is larger than in1, so swap those, too.</span></div>
<div class="line"><span class="lineno">  250</span>        <span class="comment"># Don&#39;t swap inputs for &#39;same&#39; mode, since shape of in1 matters.</span></div>
<div class="line"><span class="lineno">  251</span>        swapped_inputs = ((mode == <span class="stringliteral">&#39;full&#39;</span>) <span class="keywordflow">and</span> (in2.size &gt; in1.size) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  252</span>                          _inputs_swap_needed(mode, in1.shape, in2.shape))</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>        <span class="keywordflow">if</span> swapped_inputs:</div>
<div class="line"><span class="lineno">  255</span>            in1, in2 = in2, in1</div>
<div class="line"><span class="lineno">  256</span> </div>
<div class="line"><span class="lineno">  257</span>        <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;valid&#39;</span>:</div>
<div class="line"><span class="lineno">  258</span>            ps = [i - j + 1 <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> zip(in1.shape, in2.shape)]</div>
<div class="line"><span class="lineno">  259</span>            out = np.empty(ps, in1.dtype)</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span>            z = _sigtools._correlateND(in1, in2, out, val)</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  264</span>            ps = [i + j - 1 <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> zip(in1.shape, in2.shape)]</div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span>            <span class="comment"># zero pad input</span></div>
<div class="line"><span class="lineno">  267</span>            in1zpadded = np.zeros(ps, in1.dtype)</div>
<div class="line"><span class="lineno">  268</span>            sc = tuple(slice(0, i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> in1.shape)</div>
<div class="line"><span class="lineno">  269</span>            in1zpadded[sc] = in1.copy()</div>
<div class="line"><span class="lineno">  270</span> </div>
<div class="line"><span class="lineno">  271</span>            <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;full&#39;</span>:</div>
<div class="line"><span class="lineno">  272</span>                out = np.empty(ps, in1.dtype)</div>
<div class="line"><span class="lineno">  273</span>            <span class="keywordflow">elif</span> mode == <span class="stringliteral">&#39;same&#39;</span>:</div>
<div class="line"><span class="lineno">  274</span>                out = np.empty(in1.shape, in1.dtype)</div>
<div class="line"><span class="lineno">  275</span> </div>
<div class="line"><span class="lineno">  276</span>            z = _sigtools._correlateND(in1zpadded, in2, out, val)</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>        <span class="keywordflow">if</span> swapped_inputs:</div>
<div class="line"><span class="lineno">  279</span>            <span class="comment"># Reverse and conjugate to undo the effect of swapping inputs</span></div>
<div class="line"><span class="lineno">  280</span>            z = _reverse_and_conj(z)</div>
<div class="line"><span class="lineno">  281</span> </div>
<div class="line"><span class="lineno">  282</span>        <span class="keywordflow">return</span> z</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Acceptable method flags are &#39;auto&#39;,&quot;</span></div>
<div class="line"><span class="lineno">  286</span>                         <span class="stringliteral">&quot; &#39;direct&#39;, or &#39;fft&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno">  287</span> </div>
<div class="line"><span class="lineno">  288</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d836cbe09788ce68bc6ea9d582125d6" name="a4d836cbe09788ce68bc6ea9d582125d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d836cbe09788ce68bc6ea9d582125d6">&#9670;&#160;</a></span>correlate2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.correlate2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>boundary</em> = <code>'fill'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cross-correlate two 2-dimensional arrays.

Cross correlate `in1` and `in2` with output size determined by `mode`, and
boundary conditions determined by `boundary` and `fillvalue`.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear cross-correlation
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding. In 'valid' mode, either `in1` or `in2`
       must be at least as large as the other in every dimension.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.
boundary : str {'fill', 'wrap', 'symm'}, optional
    A flag indicating how to handle boundaries:

    ``fill``
       pad input arrays with fillvalue. (default)
    ``wrap``
       circular boundary conditions.
    ``symm``
       symmetrical boundary conditions.

fillvalue : scalar, optional
    Value to fill pad input arrays with. Default is 0.

Returns
-------
correlate2d : ndarray
    A 2-dimensional array containing a subset of the discrete linear
    cross-correlation of `in1` with `in2`.

Notes
-----
When using "same" mode with even-length inputs, the outputs of `correlate`
and `correlate2d` differ: There is a 1-index offset between them.

Examples
--------
Use 2D cross-correlation to find the location of a template in a noisy
image:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; face = misc.face(gray=True) - misc.face(gray=True).mean()
&gt;&gt;&gt; template = np.copy(face[300:365, 670:750])  # right eye
&gt;&gt;&gt; template -= template.mean()
&gt;&gt;&gt; face = face + rng.standard_normal(face.shape) * 50  # add noise
&gt;&gt;&gt; corr = signal.correlate2d(face, template, boundary='symm', mode='same')
&gt;&gt;&gt; y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1,
...                                                     figsize=(6, 15))
&gt;&gt;&gt; ax_orig.imshow(face, cmap='gray')
&gt;&gt;&gt; ax_orig.set_title('Original')
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_template.imshow(template, cmap='gray')
&gt;&gt;&gt; ax_template.set_title('Template')
&gt;&gt;&gt; ax_template.set_axis_off()
&gt;&gt;&gt; ax_corr.imshow(corr, cmap='gray')
&gt;&gt;&gt; ax_corr.set_title('Cross-correlation')
&gt;&gt;&gt; ax_corr.set_axis_off()
&gt;&gt;&gt; ax_orig.plot(x, y, 'ro')
&gt;&gt;&gt; fig.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1721</span><span class="keyword">def </span>correlate2d(in1, in2, mode=&#39;full&#39;, boundary=&#39;fill&#39;, fillvalue=0):</div>
<div class="line"><span class="lineno"> 1722</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">    Cross-correlate two 2-dimensional arrays.</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral">    Cross correlate `in1` and `in2` with output size determined by `mode`, and</span></div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">    boundary conditions determined by `boundary` and `fillvalue`.</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">        Second input. Should have the same number of dimensions as `in1`.</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">        A string indicating the size of the output:</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral">        ``full``</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">           The output is the full discrete linear cross-correlation</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">           of the inputs. (Default)</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">        ``valid``</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral">           The output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">           must be at least as large as the other in every dimension.</span></div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral">        ``same``</span></div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">           The output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral">           with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral">    boundary : str {&#39;fill&#39;, &#39;wrap&#39;, &#39;symm&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">        A flag indicating how to handle boundaries:</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">        ``fill``</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral">           pad input arrays with fillvalue. (default)</span></div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">        ``wrap``</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">           circular boundary conditions.</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">        ``symm``</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">           symmetrical boundary conditions.</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">    fillvalue : scalar, optional</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">        Value to fill pad input arrays with. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1761</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">    correlate2d : ndarray</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral">        A 2-dimensional array containing a subset of the discrete linear</span></div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">        cross-correlation of `in1` with `in2`.</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral">    When using &quot;same&quot; mode with even-length inputs, the outputs of `correlate`</span></div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">    and `correlate2d` differ: There is a 1-index offset between them.</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral">    Use 2D cross-correlation to find the location of a template in a noisy</span></div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">    image:</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import misc</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">    &gt;&gt;&gt; face = misc.face(gray=True) - misc.face(gray=True).mean()</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    &gt;&gt;&gt; template = np.copy(face[300:365, 670:750])  # right eye</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral">    &gt;&gt;&gt; template -= template.mean()</span></div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">    &gt;&gt;&gt; face = face + rng.standard_normal(face.shape) * 50  # add noise</span></div>
<div class="line"><span class="lineno"> 1783</span><span class="stringliteral">    &gt;&gt;&gt; corr = signal.correlate2d(face, template, boundary=&#39;symm&#39;, mode=&#39;same&#39;)</span></div>
<div class="line"><span class="lineno"> 1784</span><span class="stringliteral">    &gt;&gt;&gt; y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match</span></div>
<div class="line"><span class="lineno"> 1785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1786</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1787</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1,</span></div>
<div class="line"><span class="lineno"> 1788</span><span class="stringliteral">    ...                                                     figsize=(6, 15))</span></div>
<div class="line"><span class="lineno"> 1789</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.imshow(face, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_axis_off()</span></div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">    &gt;&gt;&gt; ax_template.imshow(template, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">    &gt;&gt;&gt; ax_template.set_title(&#39;Template&#39;)</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">    &gt;&gt;&gt; ax_template.set_axis_off()</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.imshow(corr, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlation&#39;)</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">    &gt;&gt;&gt; ax_corr.set_axis_off()</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.plot(x, y, &#39;ro&#39;)</span></div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">    &gt;&gt;&gt; fig.show()</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1802</span>    in1 = np.asarray(in1)</div>
<div class="line"><span class="lineno"> 1803</span>    in2 = np.asarray(in2)</div>
<div class="line"><span class="lineno"> 1804</span> </div>
<div class="line"><span class="lineno"> 1805</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> in1.ndim == in2.ndim == 2:</div>
<div class="line"><span class="lineno"> 1806</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;correlate2d inputs must both be 2-D arrays&#39;</span>)</div>
<div class="line"><span class="lineno"> 1807</span> </div>
<div class="line"><span class="lineno"> 1808</span>    swapped_inputs = _inputs_swap_needed(mode, in1.shape, in2.shape)</div>
<div class="line"><span class="lineno"> 1809</span>    <span class="keywordflow">if</span> swapped_inputs:</div>
<div class="line"><span class="lineno"> 1810</span>        in1, in2 = in2, in1</div>
<div class="line"><span class="lineno"> 1811</span> </div>
<div class="line"><span class="lineno"> 1812</span>    val = _valfrommode(mode)</div>
<div class="line"><span class="lineno"> 1813</span>    bval = _bvalfromboundary(boundary)</div>
<div class="line"><span class="lineno"> 1814</span>    out = _sigtools._convolve2d(in1, in2.conj(), 0, val, bval, fillvalue)</div>
<div class="line"><span class="lineno"> 1815</span> </div>
<div class="line"><span class="lineno"> 1816</span>    <span class="keywordflow">if</span> swapped_inputs:</div>
<div class="line"><span class="lineno"> 1817</span>        out = out[::-1, ::-1]</div>
<div class="line"><span class="lineno"> 1818</span> </div>
<div class="line"><span class="lineno"> 1819</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1820</span> </div>
<div class="line"><span class="lineno"> 1821</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aef90bf80f1495a7830b961b1af081b3d" name="aef90bf80f1495a7830b961b1af081b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef90bf80f1495a7830b961b1af081b3d">&#9670;&#160;</a></span>correlation_lags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.correlation_lags </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'full'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the lag / displacement indices array for 1D cross-correlation.

Parameters
----------
in1_len : int
First input size.
in2_len : int
Second input size.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output.
See the documentation `correlate` for more information.

See Also
--------
correlate : Compute the N-dimensional cross-correlation.

Returns
-------
lags : array
Returns an array containing cross-correlation lag/displacement indices.
Indices can be indexed with the np.argmax of the correlation to return
the lag/displacement.

Notes
-----
Cross-correlation for continuous functions :math:`f` and :math:`g` is
defined as:

.. math::

\left ( f\star g \right )\left ( \tau \right )
\triangleq \int_{t_0}^{t_0 +T}
\overline{f\left ( t \right )}g\left ( t+\tau \right )dt

Where :math:`\tau` is defined as the displacement, also known as the lag.

Cross correlation for discrete functions :math:`f` and :math:`g` is
defined as:

.. math::
\left ( f\star g \right )\left [ n \right ]
\triangleq \sum_{-\infty}^{\infty}
\overline{f\left [ m \right ]}g\left [ m+n \right ]

Where :math:`n` is the lag.

Examples
--------
Cross-correlation of a signal with its time-delayed self.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; x = rng.standard_normal(1000)
&gt;&gt;&gt; y = np.concatenate([rng.standard_normal(100), x])
&gt;&gt;&gt; correlation = signal.correlate(x, y, mode="full")
&gt;&gt;&gt; lags = signal.correlation_lags(x.size, y.size, mode="full")
&gt;&gt;&gt; lag = lags[np.argmax(correlation)]
</pre> <div class="fragment"><div class="line"><span class="lineno">  289</span><span class="keyword">def </span>correlation_lags(in1_len, in2_len, mode=&#39;full&#39;):</div>
<div class="line"><span class="lineno">  290</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    Calculates the lag / displacement indices array for 1D cross-correlation.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    in1_len : int</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        First input size.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    in2_len : int</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        Second input size.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        A string indicating the size of the output.</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        See the documentation `correlate` for more information.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    correlate : Compute the N-dimensional cross-correlation.</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    lags : array</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        Returns an array containing cross-correlation lag/displacement indices.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        Indices can be indexed with the np.argmax of the correlation to return</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        the lag/displacement.</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    Cross-correlation for continuous functions :math:`f` and :math:`g` is</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    defined as:</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        \left ( f\star g \right )\left ( \tau \right )</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">        \triangleq \int_{t_0}^{t_0 +T}</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">        \overline{f\left ( t \right )}g\left ( t+\tau \right )dt</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    Where :math:`\tau` is defined as the displacement, also known as the lag.</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    Cross correlation for discrete functions :math:`f` and :math:`g` is</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    defined as:</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        \left ( f\star g \right )\left [ n \right ]</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        \triangleq \sum_{-\infty}^{\infty}</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">        \overline{f\left [ m \right ]}g\left [ m+n \right ]</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    Where :math:`n` is the lag.</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    Cross-correlation of a signal with its time-delayed self.</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.standard_normal(1000)</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    &gt;&gt;&gt; y = np.concatenate([rng.standard_normal(100), x])</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    &gt;&gt;&gt; correlation = signal.correlate(x, y, mode=&quot;full&quot;)</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    &gt;&gt;&gt; lags = signal.correlation_lags(x.size, y.size, mode=&quot;full&quot;)</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    &gt;&gt;&gt; lag = lags[np.argmax(correlation)]</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>    <span class="comment"># calculate lag ranges in different modes of operation</span></div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;full&quot;</span>:</div>
<div class="line"><span class="lineno">  353</span>        <span class="comment"># the output is the full discrete linear convolution</span></div>
<div class="line"><span class="lineno">  354</span>        <span class="comment"># of the inputs. (Default)</span></div>
<div class="line"><span class="lineno">  355</span>        lags = np.arange(-in2_len + 1, in1_len)</div>
<div class="line"><span class="lineno">  356</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;same&quot;</span>:</div>
<div class="line"><span class="lineno">  357</span>        <span class="comment"># the output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno">  358</span>        <span class="comment"># with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno">  359</span>        <span class="comment"># calculate the full output</span></div>
<div class="line"><span class="lineno">  360</span>        lags = np.arange(-in2_len + 1, in1_len)</div>
<div class="line"><span class="lineno">  361</span>        <span class="comment"># determine the midpoint in the full output</span></div>
<div class="line"><span class="lineno">  362</span>        mid = lags.size // 2</div>
<div class="line"><span class="lineno">  363</span>        <span class="comment"># determine lag_bound to be used with respect</span></div>
<div class="line"><span class="lineno">  364</span>        <span class="comment"># to the midpoint</span></div>
<div class="line"><span class="lineno">  365</span>        lag_bound = in1_len // 2</div>
<div class="line"><span class="lineno">  366</span>        <span class="comment"># calculate lag ranges for even and odd scenarios</span></div>
<div class="line"><span class="lineno">  367</span>        <span class="keywordflow">if</span> in1_len % 2 == 0:</div>
<div class="line"><span class="lineno">  368</span>            lags = lags[(mid-lag_bound):(mid+lag_bound)]</div>
<div class="line"><span class="lineno">  369</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  370</span>            lags = lags[(mid-lag_bound):(mid+lag_bound)+1]</div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;valid&quot;</span>:</div>
<div class="line"><span class="lineno">  372</span>        <span class="comment"># the output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno">  373</span>        <span class="comment"># rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span></div>
<div class="line"><span class="lineno">  374</span>        <span class="comment"># must be at least as large as the other in every dimension.</span></div>
<div class="line"><span class="lineno">  375</span> </div>
<div class="line"><span class="lineno">  376</span>        <span class="comment"># the lag_bound will be either negative or positive</span></div>
<div class="line"><span class="lineno">  377</span>        <span class="comment"># this let&#39;s us infer how to present the lag range</span></div>
<div class="line"><span class="lineno">  378</span>        lag_bound = in1_len - in2_len</div>
<div class="line"><span class="lineno">  379</span>        <span class="keywordflow">if</span> lag_bound &gt;= 0:</div>
<div class="line"><span class="lineno">  380</span>            lags = np.arange(lag_bound + 1)</div>
<div class="line"><span class="lineno">  381</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  382</span>            lags = np.arange(lag_bound, 1)</div>
<div class="line"><span class="lineno">  383</span>    <span class="keywordflow">return</span> lags</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a64bc89ac2894b85d89c68fb3ae2b346c" name="a64bc89ac2894b85d89c68fb3ae2b346c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bc89ac2894b85d89c68fb3ae2b346c">&#9670;&#160;</a></span>decimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.decimate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ftype</em> = <code>'iir'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zero_phase</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Downsample the signal after applying an anti-aliasing filter.

By default, an order 8 Chebyshev type I filter is used. A 30 point FIR
filter with Hamming window is used if `ftype` is 'fir'.

Parameters
----------
x : array_like
    The signal to be downsampled, as an N-dimensional array.
q : int
    The downsampling factor. When using IIR downsampling, it is recommended
    to call `decimate` multiple times for downsampling factors higher than
    13.
n : int, optional
    The order of the filter (1 less than the length for 'fir'). Defaults to
    8 for 'iir' and 20 times the downsampling factor for 'fir'.
ftype : str {'iir', 'fir'} or ``dlti`` instance, optional
    If 'iir' or 'fir', specifies the type of lowpass filter. If an instance
    of an `dlti` object, uses that object to filter before downsampling.
axis : int, optional
    The axis along which to decimate.
zero_phase : bool, optional
    Prevent phase shift by filtering with `filtfilt` instead of `lfilter`
    when using an IIR filter, and shifting the outputs back by the filter's
    group delay when using an FIR filter. The default value of ``True`` is
    recommended, since a phase shift is generally not desired.

    .. versionadded:: 0.18.0

Returns
-------
y : ndarray
    The down-sampled signal.

See Also
--------
resample : Resample up or down using the FFT method.
resample_poly : Resample using polyphase filtering and an FIR filter.

Notes
-----
The ``zero_phase`` keyword was added in 0.18.0.
The possibility to use instances of ``dlti`` as ``ftype`` was added in
0.18.0.

Examples
--------

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Define wave parameters.

&gt;&gt;&gt; wave_duration = 3
&gt;&gt;&gt; sample_rate = 100
&gt;&gt;&gt; freq = 2
&gt;&gt;&gt; q = 5

Calculate number of samples.

&gt;&gt;&gt; samples = wave_duration*sample_rate
&gt;&gt;&gt; samples_decimated = int(samples/q)

Create cosine wave.

&gt;&gt;&gt; x = np.linspace(0, wave_duration, samples, endpoint=False)
&gt;&gt;&gt; y = np.cos(x*np.pi*freq*2)

Decimate cosine wave.

&gt;&gt;&gt; ydem = signal.decimate(y, q)
&gt;&gt;&gt; xnew = np.linspace(0, wave_duration, samples_decimated, endpoint=False)

Plot original and decimated waves.

&gt;&gt;&gt; plt.plot(x, y, '.-', xnew, ydem, 'o-')
&gt;&gt;&gt; plt.xlabel('Time, Seconds')
&gt;&gt;&gt; plt.legend(['data', 'decimated'], loc='best')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 4371</span><span class="keyword">def </span>decimate(x, q, n=None, ftype=&#39;iir&#39;, axis=-1, zero_phase=True):</div>
<div class="line"><span class="lineno"> 4372</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4373</span><span class="stringliteral">    Downsample the signal after applying an anti-aliasing filter.</span></div>
<div class="line"><span class="lineno"> 4374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4375</span><span class="stringliteral">    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR</span></div>
<div class="line"><span class="lineno"> 4376</span><span class="stringliteral">    filter with Hamming window is used if `ftype` is &#39;fir&#39;.</span></div>
<div class="line"><span class="lineno"> 4377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4378</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4379</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4380</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 4381</span><span class="stringliteral">        The signal to be downsampled, as an N-dimensional array.</span></div>
<div class="line"><span class="lineno"> 4382</span><span class="stringliteral">    q : int</span></div>
<div class="line"><span class="lineno"> 4383</span><span class="stringliteral">        The downsampling factor. When using IIR downsampling, it is recommended</span></div>
<div class="line"><span class="lineno"> 4384</span><span class="stringliteral">        to call `decimate` multiple times for downsampling factors higher than</span></div>
<div class="line"><span class="lineno"> 4385</span><span class="stringliteral">        13.</span></div>
<div class="line"><span class="lineno"> 4386</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 4387</span><span class="stringliteral">        The order of the filter (1 less than the length for &#39;fir&#39;). Defaults to</span></div>
<div class="line"><span class="lineno"> 4388</span><span class="stringliteral">        8 for &#39;iir&#39; and 20 times the downsampling factor for &#39;fir&#39;.</span></div>
<div class="line"><span class="lineno"> 4389</span><span class="stringliteral">    ftype : str {&#39;iir&#39;, &#39;fir&#39;} or ``dlti`` instance, optional</span></div>
<div class="line"><span class="lineno"> 4390</span><span class="stringliteral">        If &#39;iir&#39; or &#39;fir&#39;, specifies the type of lowpass filter. If an instance</span></div>
<div class="line"><span class="lineno"> 4391</span><span class="stringliteral">        of an `dlti` object, uses that object to filter before downsampling.</span></div>
<div class="line"><span class="lineno"> 4392</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 4393</span><span class="stringliteral">        The axis along which to decimate.</span></div>
<div class="line"><span class="lineno"> 4394</span><span class="stringliteral">    zero_phase : bool, optional</span></div>
<div class="line"><span class="lineno"> 4395</span><span class="stringliteral">        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`</span></div>
<div class="line"><span class="lineno"> 4396</span><span class="stringliteral">        when using an IIR filter, and shifting the outputs back by the filter&#39;s</span></div>
<div class="line"><span class="lineno"> 4397</span><span class="stringliteral">        group delay when using an FIR filter. The default value of ``True`` is</span></div>
<div class="line"><span class="lineno"> 4398</span><span class="stringliteral">        recommended, since a phase shift is generally not desired.</span></div>
<div class="line"><span class="lineno"> 4399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4400</span><span class="stringliteral">        .. versionadded:: 0.18.0</span></div>
<div class="line"><span class="lineno"> 4401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4402</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4403</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4404</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 4405</span><span class="stringliteral">        The down-sampled signal.</span></div>
<div class="line"><span class="lineno"> 4406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4407</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4408</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4409</span><span class="stringliteral">    resample : Resample up or down using the FFT method.</span></div>
<div class="line"><span class="lineno"> 4410</span><span class="stringliteral">    resample_poly : Resample using polyphase filtering and an FIR filter.</span></div>
<div class="line"><span class="lineno"> 4411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4412</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4413</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4414</span><span class="stringliteral">    The ``zero_phase`` keyword was added in 0.18.0.</span></div>
<div class="line"><span class="lineno"> 4415</span><span class="stringliteral">    The possibility to use instances of ``dlti`` as ``ftype`` was added in</span></div>
<div class="line"><span class="lineno"> 4416</span><span class="stringliteral">    0.18.0.</span></div>
<div class="line"><span class="lineno"> 4417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4418</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4419</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4421</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 4422</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 4423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4424</span><span class="stringliteral">    Define wave parameters.</span></div>
<div class="line"><span class="lineno"> 4425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4426</span><span class="stringliteral">    &gt;&gt;&gt; wave_duration = 3</span></div>
<div class="line"><span class="lineno"> 4427</span><span class="stringliteral">    &gt;&gt;&gt; sample_rate = 100</span></div>
<div class="line"><span class="lineno"> 4428</span><span class="stringliteral">    &gt;&gt;&gt; freq = 2</span></div>
<div class="line"><span class="lineno"> 4429</span><span class="stringliteral">    &gt;&gt;&gt; q = 5</span></div>
<div class="line"><span class="lineno"> 4430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4431</span><span class="stringliteral">    Calculate number of samples.</span></div>
<div class="line"><span class="lineno"> 4432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4433</span><span class="stringliteral">    &gt;&gt;&gt; samples = wave_duration*sample_rate</span></div>
<div class="line"><span class="lineno"> 4434</span><span class="stringliteral">    &gt;&gt;&gt; samples_decimated = int(samples/q)</span></div>
<div class="line"><span class="lineno"> 4435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4436</span><span class="stringliteral">    Create cosine wave.</span></div>
<div class="line"><span class="lineno"> 4437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4438</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, wave_duration, samples, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 4439</span><span class="stringliteral">    &gt;&gt;&gt; y = np.cos(x*np.pi*freq*2)</span></div>
<div class="line"><span class="lineno"> 4440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4441</span><span class="stringliteral">    Decimate cosine wave.</span></div>
<div class="line"><span class="lineno"> 4442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4443</span><span class="stringliteral">    &gt;&gt;&gt; ydem = signal.decimate(y, q)</span></div>
<div class="line"><span class="lineno"> 4444</span><span class="stringliteral">    &gt;&gt;&gt; xnew = np.linspace(0, wave_duration, samples_decimated, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 4445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4446</span><span class="stringliteral">    Plot original and decimated waves.</span></div>
<div class="line"><span class="lineno"> 4447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4448</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, y, &#39;.-&#39;, xnew, ydem, &#39;o-&#39;)</span></div>
<div class="line"><span class="lineno"> 4449</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Time, Seconds&#39;)</span></div>
<div class="line"><span class="lineno"> 4450</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend([&#39;data&#39;, &#39;decimated&#39;], loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 4451</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 4452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4453</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4454</span> </div>
<div class="line"><span class="lineno"> 4455</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 4456</span>    q = operator.index(q)</div>
<div class="line"><span class="lineno"> 4457</span> </div>
<div class="line"><span class="lineno"> 4458</span>    <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4459</span>        n = operator.index(n)</div>
<div class="line"><span class="lineno"> 4460</span> </div>
<div class="line"><span class="lineno"> 4461</span>    <span class="keywordflow">if</span> ftype == <span class="stringliteral">&#39;fir&#39;</span>:</div>
<div class="line"><span class="lineno"> 4462</span>        <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4463</span>            half_len = 10 * q  <span class="comment"># reasonable cutoff for our sinc-like function</span></div>
<div class="line"><span class="lineno"> 4464</span>            n = 2 * half_len</div>
<div class="line"><span class="lineno"> 4465</span>        b, a = firwin(n+1, 1. / q, window=<span class="stringliteral">&#39;hamming&#39;</span>), 1.</div>
<div class="line"><span class="lineno"> 4466</span>    <span class="keywordflow">elif</span> ftype == <span class="stringliteral">&#39;iir&#39;</span>:</div>
<div class="line"><span class="lineno"> 4467</span>        <span class="keywordflow">if</span> n <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4468</span>            n = 8</div>
<div class="line"><span class="lineno"> 4469</span>        system = dlti(*cheby1(n, 0.05, 0.8 / q))</div>
<div class="line"><span class="lineno"> 4470</span>        b, a = system.num, system.den</div>
<div class="line"><span class="lineno"> 4471</span>    <span class="keywordflow">elif</span> isinstance(ftype, dlti):</div>
<div class="line"><span class="lineno"> 4472</span>        system = ftype._as_tf()  <span class="comment"># Avoids copying if already in TF form</span></div>
<div class="line"><span class="lineno"> 4473</span>        b, a = system.num, system.den</div>
<div class="line"><span class="lineno"> 4474</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4475</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;invalid ftype&#39;</span>)</div>
<div class="line"><span class="lineno"> 4476</span> </div>
<div class="line"><span class="lineno"> 4477</span>    result_type = x.dtype</div>
<div class="line"><span class="lineno"> 4478</span>    <span class="keywordflow">if</span> result_type.kind <span class="keywordflow">in</span> <span class="stringliteral">&#39;bui&#39;</span>:</div>
<div class="line"><span class="lineno"> 4479</span>        result_type = np.float64</div>
<div class="line"><span class="lineno"> 4480</span>    b = np.asarray(b, dtype=result_type)</div>
<div class="line"><span class="lineno"> 4481</span>    a = np.asarray(a, dtype=result_type)</div>
<div class="line"><span class="lineno"> 4482</span> </div>
<div class="line"><span class="lineno"> 4483</span>    sl = [slice(<span class="keywordtype">None</span>)] * x.ndim</div>
<div class="line"><span class="lineno"> 4484</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 4485</span> </div>
<div class="line"><span class="lineno"> 4486</span>    <span class="keywordflow">if</span> a.size == 1:  <span class="comment"># FIR case</span></div>
<div class="line"><span class="lineno"> 4487</span>        b = b / a</div>
<div class="line"><span class="lineno"> 4488</span>        <span class="keywordflow">if</span> zero_phase:</div>
<div class="line"><span class="lineno"> 4489</span>            y = resample_poly(x, 1, q, axis=axis, window=b)</div>
<div class="line"><span class="lineno"> 4490</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4491</span>            <span class="comment"># upfirdn is generally faster than lfilter by a factor equal to the</span></div>
<div class="line"><span class="lineno"> 4492</span>            <span class="comment"># downsampling factor, since it only calculates the needed outputs</span></div>
<div class="line"><span class="lineno"> 4493</span>            n_out = x.shape[axis] // q + bool(x.shape[axis] % q)</div>
<div class="line"><span class="lineno"> 4494</span>            y = upfirdn(b, x, up=1, down=q, axis=axis)</div>
<div class="line"><span class="lineno"> 4495</span>            sl[axis] = slice(<span class="keywordtype">None</span>, n_out, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 4496</span> </div>
<div class="line"><span class="lineno"> 4497</span>    <span class="keywordflow">else</span>:  <span class="comment"># IIR case</span></div>
<div class="line"><span class="lineno"> 4498</span>        <span class="keywordflow">if</span> zero_phase:</div>
<div class="line"><span class="lineno"> 4499</span>            y = filtfilt(b, a, x, axis=axis)</div>
<div class="line"><span class="lineno"> 4500</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4501</span>            y = lfilter(b, a, x, axis=axis)</div>
<div class="line"><span class="lineno"> 4502</span>        sl[axis] = slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, q)</div>
<div class="line"><span class="lineno"> 4503</span> </div>
<div class="line"><span class="lineno"> 4504</span>    <span class="keywordflow">return</span> y[tuple(sl)]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a226467ed8bc6dbfb08eea5e1e1285d6b" name="a226467ed8bc6dbfb08eea5e1e1285d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226467ed8bc6dbfb08eea5e1e1285d6b">&#9670;&#160;</a></span>deconvolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.deconvolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Deconvolves ``divisor`` out of ``signal`` using inverse filtering.

Returns the quotient and remainder such that
``signal = convolve(divisor, quotient) + remainder``

Parameters
----------
signal : (N,) array_like
    Signal data, typically a recorded signal
divisor : (N,) array_like
    Divisor data, typically an impulse response or filter that was
    applied to the original signal

Returns
-------
quotient : ndarray
    Quotient, typically the recovered original signal
remainder : ndarray
    Remainder

Examples
--------
Deconvolve a signal that's been filtered:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; original = [0, 1, 0, 0, 1, 1, 0, 0]
&gt;&gt;&gt; impulse_response = [2, 1]
&gt;&gt;&gt; recorded = signal.convolve(impulse_response, original)
&gt;&gt;&gt; recorded
array([0, 2, 1, 0, 2, 3, 1, 0, 0])
&gt;&gt;&gt; recovered, remainder = signal.deconvolve(recorded, impulse_response)
&gt;&gt;&gt; recovered
array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])

See Also
--------
numpy.polydiv : performs polynomial division (same operation, but
                also accepts poly1d objects)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2152</span><span class="keyword">def </span>deconvolve(signal, divisor):</div>
<div class="line"><span class="lineno"> 2153</span>    <span class="stringliteral">&quot;&quot;&quot;Deconvolves ``divisor`` out of ``signal`` using inverse filtering.</span></div>
<div class="line"><span class="lineno"> 2154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2155</span><span class="stringliteral">    Returns the quotient and remainder such that</span></div>
<div class="line"><span class="lineno"> 2156</span><span class="stringliteral">    ``signal = convolve(divisor, quotient) + remainder``</span></div>
<div class="line"><span class="lineno"> 2157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2158</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2159</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2160</span><span class="stringliteral">    signal : (N,) array_like</span></div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">        Signal data, typically a recorded signal</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral">    divisor : (N,) array_like</span></div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral">        Divisor data, typically an impulse response or filter that was</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">        applied to the original signal</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">    quotient : ndarray</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">        Quotient, typically the recovered original signal</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral">    remainder : ndarray</span></div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">        Remainder</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">    Deconvolve a signal that&#39;s been filtered:</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral">    &gt;&gt;&gt; original = [0, 1, 0, 0, 1, 1, 0, 0]</span></div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">    &gt;&gt;&gt; impulse_response = [2, 1]</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">    &gt;&gt;&gt; recorded = signal.convolve(impulse_response, original)</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral">    &gt;&gt;&gt; recorded</span></div>
<div class="line"><span class="lineno"> 2182</span><span class="stringliteral">    array([0, 2, 1, 0, 2, 3, 1, 0, 0])</span></div>
<div class="line"><span class="lineno"> 2183</span><span class="stringliteral">    &gt;&gt;&gt; recovered, remainder = signal.deconvolve(recorded, impulse_response)</span></div>
<div class="line"><span class="lineno"> 2184</span><span class="stringliteral">    &gt;&gt;&gt; recovered</span></div>
<div class="line"><span class="lineno"> 2185</span><span class="stringliteral">    array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])</span></div>
<div class="line"><span class="lineno"> 2186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2187</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2188</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2189</span><span class="stringliteral">    numpy.polydiv : performs polynomial division (same operation, but</span></div>
<div class="line"><span class="lineno"> 2190</span><span class="stringliteral">                    also accepts poly1d objects)</span></div>
<div class="line"><span class="lineno"> 2191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2192</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2193</span>    num = np.atleast_1d(signal)</div>
<div class="line"><span class="lineno"> 2194</span>    den = np.atleast_1d(divisor)</div>
<div class="line"><span class="lineno"> 2195</span>    <span class="keywordflow">if</span> num.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2196</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;signal must be 1-D.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2197</span>    <span class="keywordflow">if</span> den.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2198</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;divisor must be 1-D.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2199</span>    N = len(num)</div>
<div class="line"><span class="lineno"> 2200</span>    D = len(den)</div>
<div class="line"><span class="lineno"> 2201</span>    <span class="keywordflow">if</span> D &gt; N:</div>
<div class="line"><span class="lineno"> 2202</span>        quot = []</div>
<div class="line"><span class="lineno"> 2203</span>        rem = num</div>
<div class="line"><span class="lineno"> 2204</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2205</span>        input = np.zeros(N - D + 1, float)</div>
<div class="line"><span class="lineno"> 2206</span>        input[0] = 1</div>
<div class="line"><span class="lineno"> 2207</span>        quot = lfilter(num, den, input)</div>
<div class="line"><span class="lineno"> 2208</span>        rem = num - convolve(den, quot, mode=<span class="stringliteral">&#39;full&#39;</span>)</div>
<div class="line"><span class="lineno"> 2209</span>    <span class="keywordflow">return</span> quot, rem</div>
<div class="line"><span class="lineno"> 2210</span> </div>
<div class="line"><span class="lineno"> 2211</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2d71cde110198d9f3fb485301d42aa7" name="ac2d71cde110198d9f3fb485301d42aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d71cde110198d9f3fb485301d42aa7">&#9670;&#160;</a></span>detrend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.detrend </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>'linear'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_data</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove linear trend along axis from data.

Parameters
----------
data : array_like
    The input data.
axis : int, optional
    The axis along which to detrend the data. By default this is the
    last axis (-1).
type : {'linear', 'constant'}, optional
    The type of detrending. If ``type == 'linear'`` (default),
    the result of a linear least-squares fit to `data` is subtracted
    from `data`.
    If ``type == 'constant'``, only the mean of `data` is subtracted.
bp : array_like of ints, optional
    A sequence of break points. If given, an individual linear fit is
    performed for each part of `data` between two break points.
    Break points are specified as indices into `data`. This parameter
    only has an effect when ``type == 'linear'``.
overwrite_data : bool, optional
    If True, perform in place detrending and avoid a copy. Default is False

Returns
-------
ret : ndarray
    The detrended input data.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; npoints = 1000
&gt;&gt;&gt; noise = rng.standard_normal(npoints)
&gt;&gt;&gt; x = 3 + 2*np.linspace(0, 1, npoints) + noise
&gt;&gt;&gt; (signal.detrend(x) - noise).max()
0.06  # random</pre> <div class="fragment"><div class="line"><span class="lineno"> 3427</span><span class="keyword">def </span>detrend(data, axis=-1, type=&#39;linear&#39;, bp=0, overwrite_data=False):</div>
<div class="line"><span class="lineno"> 3428</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3429</span><span class="stringliteral">    Remove linear trend along axis from data.</span></div>
<div class="line"><span class="lineno"> 3430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3431</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3432</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3433</span><span class="stringliteral">    data : array_like</span></div>
<div class="line"><span class="lineno"> 3434</span><span class="stringliteral">        The input data.</span></div>
<div class="line"><span class="lineno"> 3435</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3436</span><span class="stringliteral">        The axis along which to detrend the data. By default this is the</span></div>
<div class="line"><span class="lineno"> 3437</span><span class="stringliteral">        last axis (-1).</span></div>
<div class="line"><span class="lineno"> 3438</span><span class="stringliteral">    type : {&#39;linear&#39;, &#39;constant&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3439</span><span class="stringliteral">        The type of detrending. If ``type == &#39;linear&#39;`` (default),</span></div>
<div class="line"><span class="lineno"> 3440</span><span class="stringliteral">        the result of a linear least-squares fit to `data` is subtracted</span></div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral">        from `data`.</span></div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral">        If ``type == &#39;constant&#39;``, only the mean of `data` is subtracted.</span></div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral">    bp : array_like of ints, optional</span></div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral">        A sequence of break points. If given, an individual linear fit is</span></div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">        performed for each part of `data` between two break points.</span></div>
<div class="line"><span class="lineno"> 3446</span><span class="stringliteral">        Break points are specified as indices into `data`. This parameter</span></div>
<div class="line"><span class="lineno"> 3447</span><span class="stringliteral">        only has an effect when ``type == &#39;linear&#39;``.</span></div>
<div class="line"><span class="lineno"> 3448</span><span class="stringliteral">    overwrite_data : bool, optional</span></div>
<div class="line"><span class="lineno"> 3449</span><span class="stringliteral">        If True, perform in place detrending and avoid a copy. Default is False</span></div>
<div class="line"><span class="lineno"> 3450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3451</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3452</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3453</span><span class="stringliteral">    ret : ndarray</span></div>
<div class="line"><span class="lineno"> 3454</span><span class="stringliteral">        The detrended input data.</span></div>
<div class="line"><span class="lineno"> 3455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3456</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3457</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3458</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3459</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno"> 3460</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno"> 3461</span><span class="stringliteral">    &gt;&gt;&gt; npoints = 1000</span></div>
<div class="line"><span class="lineno"> 3462</span><span class="stringliteral">    &gt;&gt;&gt; noise = rng.standard_normal(npoints)</span></div>
<div class="line"><span class="lineno"> 3463</span><span class="stringliteral">    &gt;&gt;&gt; x = 3 + 2*np.linspace(0, 1, npoints) + noise</span></div>
<div class="line"><span class="lineno"> 3464</span><span class="stringliteral">    &gt;&gt;&gt; (signal.detrend(x) - noise).max()</span></div>
<div class="line"><span class="lineno"> 3465</span><span class="stringliteral">    0.06  # random</span></div>
<div class="line"><span class="lineno"> 3466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3467</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3468</span>    <span class="keywordflow">if</span> type <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;linear&#39;</span>, <span class="stringliteral">&#39;l&#39;</span>, <span class="stringliteral">&#39;constant&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]:</div>
<div class="line"><span class="lineno"> 3469</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Trend type must be &#39;linear&#39; or &#39;constant&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3470</span>    data = np.asarray(data)</div>
<div class="line"><span class="lineno"> 3471</span>    dtype = data.dtype.char</div>
<div class="line"><span class="lineno"> 3472</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">not</span> <span class="keywordflow">in</span> <span class="stringliteral">&#39;dfDF&#39;</span>:</div>
<div class="line"><span class="lineno"> 3473</span>        dtype = <span class="stringliteral">&#39;d&#39;</span></div>
<div class="line"><span class="lineno"> 3474</span>    <span class="keywordflow">if</span> type <span class="keywordflow">in</span> [<span class="stringliteral">&#39;constant&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>]:</div>
<div class="line"><span class="lineno"> 3475</span>        ret = data - np.mean(data, axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3476</span>        <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 3477</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3478</span>        dshape = data.shape</div>
<div class="line"><span class="lineno"> 3479</span>        N = dshape[axis]</div>
<div class="line"><span class="lineno"> 3480</span>        bp = np.sort(np.unique(np.r_[0, bp, N]))</div>
<div class="line"><span class="lineno"> 3481</span>        <span class="keywordflow">if</span> np.any(bp &gt; N):</div>
<div class="line"><span class="lineno"> 3482</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Breakpoints must be less than length &quot;</span></div>
<div class="line"><span class="lineno"> 3483</span>                             <span class="stringliteral">&quot;of data along given axis.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3484</span>        Nreg = len(bp) - 1</div>
<div class="line"><span class="lineno"> 3485</span>        <span class="comment"># Restructure data so that axis is along first dimension and</span></div>
<div class="line"><span class="lineno"> 3486</span>        <span class="comment">#  all other dimensions are collapsed into second dimension</span></div>
<div class="line"><span class="lineno"> 3487</span>        rnk = len(dshape)</div>
<div class="line"><span class="lineno"> 3488</span>        <span class="keywordflow">if</span> axis &lt; 0:</div>
<div class="line"><span class="lineno"> 3489</span>            axis = axis + rnk</div>
<div class="line"><span class="lineno"> 3490</span>        newdims = np.r_[axis, 0:axis, axis + 1:rnk]</div>
<div class="line"><span class="lineno"> 3491</span>        newdata = np.reshape(np.transpose(data, tuple(newdims)),</div>
<div class="line"><span class="lineno"> 3492</span>                             (N, _prod(dshape) // N))</div>
<div class="line"><span class="lineno"> 3493</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> overwrite_data:</div>
<div class="line"><span class="lineno"> 3494</span>            newdata = newdata.copy()  <span class="comment"># make sure we have a copy</span></div>
<div class="line"><span class="lineno"> 3495</span>        <span class="keywordflow">if</span> newdata.dtype.char <span class="keywordflow">not</span> <span class="keywordflow">in</span> <span class="stringliteral">&#39;dfDF&#39;</span>:</div>
<div class="line"><span class="lineno"> 3496</span>            newdata = newdata.astype(dtype)</div>
<div class="line"><span class="lineno"> 3497</span>        <span class="comment"># Find leastsq fit and remove it for each piece</span></div>
<div class="line"><span class="lineno"> 3498</span>        <span class="keywordflow">for</span> m <span class="keywordflow">in</span> range(Nreg):</div>
<div class="line"><span class="lineno"> 3499</span>            Npts = bp[m + 1] - bp[m]</div>
<div class="line"><span class="lineno"> 3500</span>            A = np.ones((Npts, 2), dtype)</div>
<div class="line"><span class="lineno"> 3501</span>            A[:, 0] = np.cast[dtype](np.arange(1, Npts + 1) * 1.0 / Npts)</div>
<div class="line"><span class="lineno"> 3502</span>            sl = slice(bp[m], bp[m + 1])</div>
<div class="line"><span class="lineno"> 3503</span>            coef, resids, rank, s = linalg.lstsq(A, newdata[sl])</div>
<div class="line"><span class="lineno"> 3504</span>            newdata[sl] = newdata[sl] - np.dot(A, coef)</div>
<div class="line"><span class="lineno"> 3505</span>        <span class="comment"># Put data back in original shape.</span></div>
<div class="line"><span class="lineno"> 3506</span>        tdshape = np.take(dshape, newdims, 0)</div>
<div class="line"><span class="lineno"> 3507</span>        ret = np.reshape(newdata, tuple(tdshape))</div>
<div class="line"><span class="lineno"> 3508</span>        vals = list(range(1, rnk))</div>
<div class="line"><span class="lineno"> 3509</span>        olddims = vals[:axis] + [0] + vals[axis:]</div>
<div class="line"><span class="lineno"> 3510</span>        ret = np.transpose(ret, tuple(olddims))</div>
<div class="line"><span class="lineno"> 3511</span>        <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 3512</span> </div>
<div class="line"><span class="lineno"> 3513</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a341b357e73256ed5eaeaacdf148114a5" name="a341b357e73256ed5eaeaacdf148114a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341b357e73256ed5eaeaacdf148114a5">&#9670;&#160;</a></span>fftconvolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.fftconvolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;full&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convolve two N-dimensional arrays using FFT.

Convolve `in1` and `in2` using the fast Fourier transform method, with
the output size determined by the `mode` argument.

This is generally much faster than `convolve` for large arrays (n &gt; ~500),
but can be slower when only a few output values are needed, and can only
output float arrays (int or object array inputs will be cast to float).

As of v0.19, `convolve` automatically chooses this method or the direct
method based on an estimation of which is faster.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding. In 'valid' mode, either `in1` or `in2`
       must be at least as large as the other in every dimension.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.
axes : int or array_like of ints or None, optional
    Axes over which to compute the convolution.
    The default is over all axes.

Returns
-------
out : array
    An N-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.

See Also
--------
convolve : Uses the direct convolution or FFT convolution algorithm
           depending on which is faster.
oaconvolve : Uses the overlap-add method to do convolution, which is
             generally faster when the input arrays are large and
             significantly different in size.

Examples
--------
Autocorrelation of white noise is an impulse.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; sig = rng.standard_normal(1000)
&gt;&gt;&gt; autocorr = signal.fftconvolve(sig, sig[::-1], mode='full')

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.set_title('White noise')
&gt;&gt;&gt; ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)
&gt;&gt;&gt; ax_mag.set_title('Autocorrelation')
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; fig.show()

Gaussian blur implemented using FFT convolution.  Notice the dark borders
around the image, due to the zero-padding beyond its boundaries.
The `convolve2d` function allows for other types of image boundaries,
but is far slower.

&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; face = misc.face(gray=True)
&gt;&gt;&gt; kernel = np.outer(signal.windows.gaussian(70, 8),
...                   signal.windows.gaussian(70, 8))
&gt;&gt;&gt; blurred = signal.fftconvolve(face, kernel, mode='same')

&gt;&gt;&gt; fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(3, 1,
...                                                      figsize=(6, 15))
&gt;&gt;&gt; ax_orig.imshow(face, cmap='gray')
&gt;&gt;&gt; ax_orig.set_title('Original')
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_kernel.imshow(kernel, cmap='gray')
&gt;&gt;&gt; ax_kernel.set_title('Gaussian kernel')
&gt;&gt;&gt; ax_kernel.set_axis_off()
&gt;&gt;&gt; ax_blurred.imshow(blurred, cmap='gray')
&gt;&gt;&gt; ax_blurred.set_title('Blurred')
&gt;&gt;&gt; ax_blurred.set_axis_off()
&gt;&gt;&gt; fig.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  555</span><span class="keyword">def </span>fftconvolve(in1, in2, mode=&quot;full&quot;, axes=None):</div>
<div class="line"><span class="lineno">  556</span>    <span class="stringliteral">&quot;&quot;&quot;Convolve two N-dimensional arrays using FFT.</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    Convolve `in1` and `in2` using the fast Fourier transform method, with</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    the output size determined by the `mode` argument.</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    This is generally much faster than `convolve` for large arrays (n &gt; ~500),</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    but can be slower when only a few output values are needed, and can only</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    output float arrays (int or object array inputs will be cast to float).</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    As of v0.19, `convolve` automatically chooses this method or the direct</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    method based on an estimation of which is faster.</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        Second input. Should have the same number of dimensions as `in1`.</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">        A string indicating the size of the output:</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        ``full``</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">           The output is the full discrete linear convolution</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">           of the inputs. (Default)</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">        ``valid``</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">           The output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">           must be at least as large as the other in every dimension.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        ``same``</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">           The output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">           with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    axes : int or array_like of ints or None, optional</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">        Axes over which to compute the convolution.</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        The default is over all axes.</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    out : array</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        An N-dimensional array containing a subset of the discrete linear</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        convolution of `in1` with `in2`.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    convolve : Uses the direct convolution or FFT convolution algorithm</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">               depending on which is faster.</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    oaconvolve : Uses the overlap-add method to do convolution, which is</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">                 generally faster when the input arrays are large and</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">                 significantly different in size.</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    Autocorrelation of white noise is an impulse.</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    &gt;&gt;&gt; sig = rng.standard_normal(1000)</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    &gt;&gt;&gt; autocorr = signal.fftconvolve(sig, sig[::-1], mode=&#39;full&#39;)</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.plot(sig)</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;White noise&#39;)</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    &gt;&gt;&gt; ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    &gt;&gt;&gt; ax_mag.set_title(&#39;Autocorrelation&#39;)</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    &gt;&gt;&gt; fig.tight_layout()</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    &gt;&gt;&gt; fig.show()</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    Gaussian blur implemented using FFT convolution.  Notice the dark borders</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    around the image, due to the zero-padding beyond its boundaries.</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    The `convolve2d` function allows for other types of image boundaries,</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    but is far slower.</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import misc</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    &gt;&gt;&gt; face = misc.face(gray=True)</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    &gt;&gt;&gt; kernel = np.outer(signal.windows.gaussian(70, 8),</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    ...                   signal.windows.gaussian(70, 8))</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    &gt;&gt;&gt; blurred = signal.fftconvolve(face, kernel, mode=&#39;same&#39;)</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(3, 1,</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    ...                                                      figsize=(6, 15))</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.imshow(face, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_axis_off()</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    &gt;&gt;&gt; ax_kernel.imshow(kernel, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    &gt;&gt;&gt; ax_kernel.set_title(&#39;Gaussian kernel&#39;)</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    &gt;&gt;&gt; ax_kernel.set_axis_off()</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    &gt;&gt;&gt; ax_blurred.imshow(blurred, cmap=&#39;gray&#39;)</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    &gt;&gt;&gt; ax_blurred.set_title(&#39;Blurred&#39;)</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    &gt;&gt;&gt; ax_blurred.set_axis_off()</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    &gt;&gt;&gt; fig.show()</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  648</span>    in1 = np.asarray(in1)</div>
<div class="line"><span class="lineno">  649</span>    in2 = np.asarray(in2)</div>
<div class="line"><span class="lineno">  650</span> </div>
<div class="line"><span class="lineno">  651</span>    <span class="keywordflow">if</span> in1.ndim == in2.ndim == 0:  <span class="comment"># scalar inputs</span></div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">return</span> in1 * in2</div>
<div class="line"><span class="lineno">  653</span>    <span class="keywordflow">elif</span> in1.ndim != in2.ndim:</div>
<div class="line"><span class="lineno">  654</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;in1 and in2 should have the same dimensionality&quot;</span>)</div>
<div class="line"><span class="lineno">  655</span>    <span class="keywordflow">elif</span> in1.size == 0 <span class="keywordflow">or</span> in2.size == 0:  <span class="comment"># empty arrays</span></div>
<div class="line"><span class="lineno">  656</span>        <span class="keywordflow">return</span> np.array([])</div>
<div class="line"><span class="lineno">  657</span> </div>
<div class="line"><span class="lineno">  658</span>    in1, in2, axes = _init_freq_conv_axes(in1, in2, mode, axes,</div>
<div class="line"><span class="lineno">  659</span>                                          sorted_axes=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span>    s1 = in1.shape</div>
<div class="line"><span class="lineno">  662</span>    s2 = in2.shape</div>
<div class="line"><span class="lineno">  663</span> </div>
<div class="line"><span class="lineno">  664</span>    shape = [max((s1[i], s2[i])) <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> axes <span class="keywordflow">else</span> s1[i] + s2[i] - 1</div>
<div class="line"><span class="lineno">  665</span>             <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(in1.ndim)]</div>
<div class="line"><span class="lineno">  666</span> </div>
<div class="line"><span class="lineno">  667</span>    ret = _freq_domain_conv(in1, in2, axes, shape, calc_fast_len=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  668</span> </div>
<div class="line"><span class="lineno">  669</span>    <span class="keywordflow">return</span> _apply_conv_mode(ret, s1, s2, mode, axes)</div>
<div class="line"><span class="lineno">  670</span> </div>
<div class="line"><span class="lineno">  671</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5d5f7aec84133cbe6e52468d23c5e1f" name="ad5d5f7aec84133cbe6e52468d23c5e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d5f7aec84133cbe6e52468d23c5e1f">&#9670;&#160;</a></span>filtfilt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.filtfilt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padtype</em> = <code>'odd'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padlen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'pad'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>irlen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply a digital filter forward and backward to a signal.

This function applies a linear digital filter twice, once forward and
once backwards.  The combined filter has zero phase and a filter order
twice that of the original.

The function provides options for handling the edges of the signal.

The function `sosfiltfilt` (and filter design using ``output='sos'``)
should be preferred over `filtfilt` for most filtering tasks, as
second-order sections have fewer numerical problems.

Parameters
----------
b : (N,) array_like
    The numerator coefficient vector of the filter.
a : (N,) array_like
    The denominator coefficient vector of the filter.  If ``a[0]``
    is not 1, then both `a` and `b` are normalized by ``a[0]``.
x : array_like
    The array of data to be filtered.
axis : int, optional
    The axis of `x` to which the filter is applied.
    Default is -1.
padtype : str or None, optional
    Must be 'odd', 'even', 'constant', or None.  This determines the
    type of extension to use for the padded signal to which the filter
    is applied.  If `padtype` is None, no padding is used.  The default
    is 'odd'.
padlen : int or None, optional
    The number of elements by which to extend `x` at both ends of
    `axis` before applying the filter.  This value must be less than
    ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.
    The default value is ``3 * max(len(a), len(b))``.
method : str, optional
    Determines the method for handling the edges of the signal, either
    "pad" or "gust".  When `method` is "pad", the signal is padded; the
    type of padding is determined by `padtype` and `padlen`, and `irlen`
    is ignored.  When `method` is "gust", Gustafsson's method is used,
    and `padtype` and `padlen` are ignored.
irlen : int or None, optional
    When `method` is "gust", `irlen` specifies the length of the
    impulse response of the filter.  If `irlen` is None, no part
    of the impulse response is ignored.  For a long signal, specifying
    `irlen` can significantly improve the performance of the filter.

Returns
-------
y : ndarray
    The filtered output with the same shape as `x`.

See Also
--------
sosfiltfilt, lfilter_zi, lfilter, lfiltic, savgol_filter, sosfilt

Notes
-----
When `method` is "pad", the function pads the data along the given axis
in one of three ways: odd, even or constant.  The odd and even extensions
have the corresponding symmetry about the end point of the data.  The
constant extension extends the data with the values at the end points. On
both the forward and backward passes, the initial condition of the
filter is found by using `lfilter_zi` and scaling it by the end point of
the extended data.

When `method` is "gust", Gustafsson's method [1]_ is used.  Initial
conditions are chosen for the forward and backward passes so that the
forward-backward filter gives the same result as the backward-forward
filter.

The option to use Gustaffson's method was added in scipy version 0.16.0.

References
----------
.. [1] F. Gustaffson, "Determining the initial states in forward-backward
       filtering", Transactions on Signal Processing, Vol. 46, pp. 988-992,
       1996.

Examples
--------
The examples will use several functions from `scipy.signal`.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

First we create a one second signal that is the sum of two pure sine
waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.

&gt;&gt;&gt; t = np.linspace(0, 1.0, 2001)
&gt;&gt;&gt; xlow = np.sin(2 * np.pi * 5 * t)
&gt;&gt;&gt; xhigh = np.sin(2 * np.pi * 250 * t)
&gt;&gt;&gt; x = xlow + xhigh

Now create a lowpass Butterworth filter with a cutoff of 0.125 times
the Nyquist frequency, or 125 Hz, and apply it to ``x`` with `filtfilt`.
The result should be approximately ``xlow``, with no phase shift.

&gt;&gt;&gt; b, a = signal.butter(8, 0.125)
&gt;&gt;&gt; y = signal.filtfilt(b, a, x, padlen=150)
&gt;&gt;&gt; np.abs(y - xlow).max()
9.1086182074789912e-06

We get a fairly clean result for this artificial example because
the odd extension is exact, and with the moderately long padding,
the filter's transients have dissipated by the time the actual data
is reached.  In general, transient effects at the edges are
unavoidable.

The following example demonstrates the option ``method="gust"``.

First, create a filter.

&gt;&gt;&gt; b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied.

`sig` is a random input signal to be filtered.

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; n = 60
&gt;&gt;&gt; sig = rng.standard_normal(n)**3 + 3*rng.standard_normal(n).cumsum()

Apply `filtfilt` to `sig`, once using the Gustafsson method, and
once using padding, and plot the results for comparison.

&gt;&gt;&gt; fgust = signal.filtfilt(b, a, sig, method="gust")
&gt;&gt;&gt; fpad = signal.filtfilt(b, a, sig, padlen=50)
&gt;&gt;&gt; plt.plot(sig, 'k-', label='input')
&gt;&gt;&gt; plt.plot(fgust, 'b-', linewidth=4, label='gust')
&gt;&gt;&gt; plt.plot(fpad, 'c-', linewidth=1.5, label='pad')
&gt;&gt;&gt; plt.legend(loc='best')
&gt;&gt;&gt; plt.show()

The `irlen` argument can be used to improve the performance
of Gustafsson's method.

Estimate the impulse response length of the filter.

&gt;&gt;&gt; z, p, k = signal.tf2zpk(b, a)
&gt;&gt;&gt; eps = 1e-9
&gt;&gt;&gt; r = np.max(np.abs(p))
&gt;&gt;&gt; approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))
&gt;&gt;&gt; approx_impulse_len
137

Apply the filter to a longer signal, with and without the `irlen`
argument.  The difference between `y1` and `y2` is small.  For long
signals, using `irlen` gives a significant performance improvement.

&gt;&gt;&gt; x = rng.standard_normal(5000)
&gt;&gt;&gt; y1 = signal.filtfilt(b, a, x, method='gust')
&gt;&gt;&gt; y2 = signal.filtfilt(b, a, x, method='gust', irlen=approx_impulse_len)
&gt;&gt;&gt; print(np.max(np.abs(y1 - y2)))
1.80056858312e-10</pre> <div class="fragment"><div class="line"><span class="lineno"> 3905</span>             irlen=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3906</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3907</span><span class="stringliteral">    Apply a digital filter forward and backward to a signal.</span></div>
<div class="line"><span class="lineno"> 3908</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3909</span><span class="stringliteral">    This function applies a linear digital filter twice, once forward and</span></div>
<div class="line"><span class="lineno"> 3910</span><span class="stringliteral">    once backwards.  The combined filter has zero phase and a filter order</span></div>
<div class="line"><span class="lineno"> 3911</span><span class="stringliteral">    twice that of the original.</span></div>
<div class="line"><span class="lineno"> 3912</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3913</span><span class="stringliteral">    The function provides options for handling the edges of the signal.</span></div>
<div class="line"><span class="lineno"> 3914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3915</span><span class="stringliteral">    The function `sosfiltfilt` (and filter design using ``output=&#39;sos&#39;``)</span></div>
<div class="line"><span class="lineno"> 3916</span><span class="stringliteral">    should be preferred over `filtfilt` for most filtering tasks, as</span></div>
<div class="line"><span class="lineno"> 3917</span><span class="stringliteral">    second-order sections have fewer numerical problems.</span></div>
<div class="line"><span class="lineno"> 3918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3919</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3920</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3921</span><span class="stringliteral">    b : (N,) array_like</span></div>
<div class="line"><span class="lineno"> 3922</span><span class="stringliteral">        The numerator coefficient vector of the filter.</span></div>
<div class="line"><span class="lineno"> 3923</span><span class="stringliteral">    a : (N,) array_like</span></div>
<div class="line"><span class="lineno"> 3924</span><span class="stringliteral">        The denominator coefficient vector of the filter.  If ``a[0]``</span></div>
<div class="line"><span class="lineno"> 3925</span><span class="stringliteral">        is not 1, then both `a` and `b` are normalized by ``a[0]``.</span></div>
<div class="line"><span class="lineno"> 3926</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 3927</span><span class="stringliteral">        The array of data to be filtered.</span></div>
<div class="line"><span class="lineno"> 3928</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3929</span><span class="stringliteral">        The axis of `x` to which the filter is applied.</span></div>
<div class="line"><span class="lineno"> 3930</span><span class="stringliteral">        Default is -1.</span></div>
<div class="line"><span class="lineno"> 3931</span><span class="stringliteral">    padtype : str or None, optional</span></div>
<div class="line"><span class="lineno"> 3932</span><span class="stringliteral">        Must be &#39;odd&#39;, &#39;even&#39;, &#39;constant&#39;, or None.  This determines the</span></div>
<div class="line"><span class="lineno"> 3933</span><span class="stringliteral">        type of extension to use for the padded signal to which the filter</span></div>
<div class="line"><span class="lineno"> 3934</span><span class="stringliteral">        is applied.  If `padtype` is None, no padding is used.  The default</span></div>
<div class="line"><span class="lineno"> 3935</span><span class="stringliteral">        is &#39;odd&#39;.</span></div>
<div class="line"><span class="lineno"> 3936</span><span class="stringliteral">    padlen : int or None, optional</span></div>
<div class="line"><span class="lineno"> 3937</span><span class="stringliteral">        The number of elements by which to extend `x` at both ends of</span></div>
<div class="line"><span class="lineno"> 3938</span><span class="stringliteral">        `axis` before applying the filter.  This value must be less than</span></div>
<div class="line"><span class="lineno"> 3939</span><span class="stringliteral">        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.</span></div>
<div class="line"><span class="lineno"> 3940</span><span class="stringliteral">        The default value is ``3 * max(len(a), len(b))``.</span></div>
<div class="line"><span class="lineno"> 3941</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno"> 3942</span><span class="stringliteral">        Determines the method for handling the edges of the signal, either</span></div>
<div class="line"><span class="lineno"> 3943</span><span class="stringliteral">        &quot;pad&quot; or &quot;gust&quot;.  When `method` is &quot;pad&quot;, the signal is padded; the</span></div>
<div class="line"><span class="lineno"> 3944</span><span class="stringliteral">        type of padding is determined by `padtype` and `padlen`, and `irlen`</span></div>
<div class="line"><span class="lineno"> 3945</span><span class="stringliteral">        is ignored.  When `method` is &quot;gust&quot;, Gustafsson&#39;s method is used,</span></div>
<div class="line"><span class="lineno"> 3946</span><span class="stringliteral">        and `padtype` and `padlen` are ignored.</span></div>
<div class="line"><span class="lineno"> 3947</span><span class="stringliteral">    irlen : int or None, optional</span></div>
<div class="line"><span class="lineno"> 3948</span><span class="stringliteral">        When `method` is &quot;gust&quot;, `irlen` specifies the length of the</span></div>
<div class="line"><span class="lineno"> 3949</span><span class="stringliteral">        impulse response of the filter.  If `irlen` is None, no part</span></div>
<div class="line"><span class="lineno"> 3950</span><span class="stringliteral">        of the impulse response is ignored.  For a long signal, specifying</span></div>
<div class="line"><span class="lineno"> 3951</span><span class="stringliteral">        `irlen` can significantly improve the performance of the filter.</span></div>
<div class="line"><span class="lineno"> 3952</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3953</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3954</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3955</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 3956</span><span class="stringliteral">        The filtered output with the same shape as `x`.</span></div>
<div class="line"><span class="lineno"> 3957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3958</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3959</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3960</span><span class="stringliteral">    sosfiltfilt, lfilter_zi, lfilter, lfiltic, savgol_filter, sosfilt</span></div>
<div class="line"><span class="lineno"> 3961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3962</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3963</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3964</span><span class="stringliteral">    When `method` is &quot;pad&quot;, the function pads the data along the given axis</span></div>
<div class="line"><span class="lineno"> 3965</span><span class="stringliteral">    in one of three ways: odd, even or constant.  The odd and even extensions</span></div>
<div class="line"><span class="lineno"> 3966</span><span class="stringliteral">    have the corresponding symmetry about the end point of the data.  The</span></div>
<div class="line"><span class="lineno"> 3967</span><span class="stringliteral">    constant extension extends the data with the values at the end points. On</span></div>
<div class="line"><span class="lineno"> 3968</span><span class="stringliteral">    both the forward and backward passes, the initial condition of the</span></div>
<div class="line"><span class="lineno"> 3969</span><span class="stringliteral">    filter is found by using `lfilter_zi` and scaling it by the end point of</span></div>
<div class="line"><span class="lineno"> 3970</span><span class="stringliteral">    the extended data.</span></div>
<div class="line"><span class="lineno"> 3971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3972</span><span class="stringliteral">    When `method` is &quot;gust&quot;, Gustafsson&#39;s method [1]_ is used.  Initial</span></div>
<div class="line"><span class="lineno"> 3973</span><span class="stringliteral">    conditions are chosen for the forward and backward passes so that the</span></div>
<div class="line"><span class="lineno"> 3974</span><span class="stringliteral">    forward-backward filter gives the same result as the backward-forward</span></div>
<div class="line"><span class="lineno"> 3975</span><span class="stringliteral">    filter.</span></div>
<div class="line"><span class="lineno"> 3976</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3977</span><span class="stringliteral">    The option to use Gustaffson&#39;s method was added in scipy version 0.16.0.</span></div>
<div class="line"><span class="lineno"> 3978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3979</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3980</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3981</span><span class="stringliteral">    .. [1] F. Gustaffson, &quot;Determining the initial states in forward-backward</span></div>
<div class="line"><span class="lineno"> 3982</span><span class="stringliteral">           filtering&quot;, Transactions on Signal Processing, Vol. 46, pp. 988-992,</span></div>
<div class="line"><span class="lineno"> 3983</span><span class="stringliteral">           1996.</span></div>
<div class="line"><span class="lineno"> 3984</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3985</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3986</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3987</span><span class="stringliteral">    The examples will use several functions from `scipy.signal`.</span></div>
<div class="line"><span class="lineno"> 3988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3989</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3990</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3992</span><span class="stringliteral">    First we create a one second signal that is the sum of two pure sine</span></div>
<div class="line"><span class="lineno"> 3993</span><span class="stringliteral">    waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.</span></div>
<div class="line"><span class="lineno"> 3994</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3995</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 1.0, 2001)</span></div>
<div class="line"><span class="lineno"> 3996</span><span class="stringliteral">    &gt;&gt;&gt; xlow = np.sin(2 * np.pi * 5 * t)</span></div>
<div class="line"><span class="lineno"> 3997</span><span class="stringliteral">    &gt;&gt;&gt; xhigh = np.sin(2 * np.pi * 250 * t)</span></div>
<div class="line"><span class="lineno"> 3998</span><span class="stringliteral">    &gt;&gt;&gt; x = xlow + xhigh</span></div>
<div class="line"><span class="lineno"> 3999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4000</span><span class="stringliteral">    Now create a lowpass Butterworth filter with a cutoff of 0.125 times</span></div>
<div class="line"><span class="lineno"> 4001</span><span class="stringliteral">    the Nyquist frequency, or 125 Hz, and apply it to ``x`` with `filtfilt`.</span></div>
<div class="line"><span class="lineno"> 4002</span><span class="stringliteral">    The result should be approximately ``xlow``, with no phase shift.</span></div>
<div class="line"><span class="lineno"> 4003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4004</span><span class="stringliteral">    &gt;&gt;&gt; b, a = signal.butter(8, 0.125)</span></div>
<div class="line"><span class="lineno"> 4005</span><span class="stringliteral">    &gt;&gt;&gt; y = signal.filtfilt(b, a, x, padlen=150)</span></div>
<div class="line"><span class="lineno"> 4006</span><span class="stringliteral">    &gt;&gt;&gt; np.abs(y - xlow).max()</span></div>
<div class="line"><span class="lineno"> 4007</span><span class="stringliteral">    9.1086182074789912e-06</span></div>
<div class="line"><span class="lineno"> 4008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4009</span><span class="stringliteral">    We get a fairly clean result for this artificial example because</span></div>
<div class="line"><span class="lineno"> 4010</span><span class="stringliteral">    the odd extension is exact, and with the moderately long padding,</span></div>
<div class="line"><span class="lineno"> 4011</span><span class="stringliteral">    the filter&#39;s transients have dissipated by the time the actual data</span></div>
<div class="line"><span class="lineno"> 4012</span><span class="stringliteral">    is reached.  In general, transient effects at the edges are</span></div>
<div class="line"><span class="lineno"> 4013</span><span class="stringliteral">    unavoidable.</span></div>
<div class="line"><span class="lineno"> 4014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4015</span><span class="stringliteral">    The following example demonstrates the option ``method=&quot;gust&quot;``.</span></div>
<div class="line"><span class="lineno"> 4016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4017</span><span class="stringliteral">    First, create a filter.</span></div>
<div class="line"><span class="lineno"> 4018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4019</span><span class="stringliteral">    &gt;&gt;&gt; b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied.</span></div>
<div class="line"><span class="lineno"> 4020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4021</span><span class="stringliteral">    `sig` is a random input signal to be filtered.</span></div>
<div class="line"><span class="lineno"> 4022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4023</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 4024</span><span class="stringliteral">    &gt;&gt;&gt; n = 60</span></div>
<div class="line"><span class="lineno"> 4025</span><span class="stringliteral">    &gt;&gt;&gt; sig = rng.standard_normal(n)**3 + 3*rng.standard_normal(n).cumsum()</span></div>
<div class="line"><span class="lineno"> 4026</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4027</span><span class="stringliteral">    Apply `filtfilt` to `sig`, once using the Gustafsson method, and</span></div>
<div class="line"><span class="lineno"> 4028</span><span class="stringliteral">    once using padding, and plot the results for comparison.</span></div>
<div class="line"><span class="lineno"> 4029</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4030</span><span class="stringliteral">    &gt;&gt;&gt; fgust = signal.filtfilt(b, a, sig, method=&quot;gust&quot;)</span></div>
<div class="line"><span class="lineno"> 4031</span><span class="stringliteral">    &gt;&gt;&gt; fpad = signal.filtfilt(b, a, sig, padlen=50)</span></div>
<div class="line"><span class="lineno"> 4032</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(sig, &#39;k-&#39;, label=&#39;input&#39;)</span></div>
<div class="line"><span class="lineno"> 4033</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(fgust, &#39;b-&#39;, linewidth=4, label=&#39;gust&#39;)</span></div>
<div class="line"><span class="lineno"> 4034</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(fpad, &#39;c-&#39;, linewidth=1.5, label=&#39;pad&#39;)</span></div>
<div class="line"><span class="lineno"> 4035</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 4036</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 4037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4038</span><span class="stringliteral">    The `irlen` argument can be used to improve the performance</span></div>
<div class="line"><span class="lineno"> 4039</span><span class="stringliteral">    of Gustafsson&#39;s method.</span></div>
<div class="line"><span class="lineno"> 4040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4041</span><span class="stringliteral">    Estimate the impulse response length of the filter.</span></div>
<div class="line"><span class="lineno"> 4042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4043</span><span class="stringliteral">    &gt;&gt;&gt; z, p, k = signal.tf2zpk(b, a)</span></div>
<div class="line"><span class="lineno"> 4044</span><span class="stringliteral">    &gt;&gt;&gt; eps = 1e-9</span></div>
<div class="line"><span class="lineno"> 4045</span><span class="stringliteral">    &gt;&gt;&gt; r = np.max(np.abs(p))</span></div>
<div class="line"><span class="lineno"> 4046</span><span class="stringliteral">    &gt;&gt;&gt; approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))</span></div>
<div class="line"><span class="lineno"> 4047</span><span class="stringliteral">    &gt;&gt;&gt; approx_impulse_len</span></div>
<div class="line"><span class="lineno"> 4048</span><span class="stringliteral">    137</span></div>
<div class="line"><span class="lineno"> 4049</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4050</span><span class="stringliteral">    Apply the filter to a longer signal, with and without the `irlen`</span></div>
<div class="line"><span class="lineno"> 4051</span><span class="stringliteral">    argument.  The difference between `y1` and `y2` is small.  For long</span></div>
<div class="line"><span class="lineno"> 4052</span><span class="stringliteral">    signals, using `irlen` gives a significant performance improvement.</span></div>
<div class="line"><span class="lineno"> 4053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4054</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.standard_normal(5000)</span></div>
<div class="line"><span class="lineno"> 4055</span><span class="stringliteral">    &gt;&gt;&gt; y1 = signal.filtfilt(b, a, x, method=&#39;gust&#39;)</span></div>
<div class="line"><span class="lineno"> 4056</span><span class="stringliteral">    &gt;&gt;&gt; y2 = signal.filtfilt(b, a, x, method=&#39;gust&#39;, irlen=approx_impulse_len)</span></div>
<div class="line"><span class="lineno"> 4057</span><span class="stringliteral">    &gt;&gt;&gt; print(np.max(np.abs(y1 - y2)))</span></div>
<div class="line"><span class="lineno"> 4058</span><span class="stringliteral">    1.80056858312e-10</span></div>
<div class="line"><span class="lineno"> 4059</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4060</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4061</span>    b = np.atleast_1d(b)</div>
<div class="line"><span class="lineno"> 4062</span>    a = np.atleast_1d(a)</div>
<div class="line"><span class="lineno"> 4063</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 4064</span> </div>
<div class="line"><span class="lineno"> 4065</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;pad&quot;</span>, <span class="stringliteral">&quot;gust&quot;</span>]:</div>
<div class="line"><span class="lineno"> 4066</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;method must be &#39;pad&#39; or &#39;gust&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4067</span> </div>
<div class="line"><span class="lineno"> 4068</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;gust&quot;</span>:</div>
<div class="line"><span class="lineno"> 4069</span>        y, z1, z2 = _filtfilt_gust(b, a, x, axis=axis, irlen=irlen)</div>
<div class="line"><span class="lineno"> 4070</span>        <span class="keywordflow">return</span> y</div>
<div class="line"><span class="lineno"> 4071</span> </div>
<div class="line"><span class="lineno"> 4072</span>    <span class="comment"># method == &quot;pad&quot;</span></div>
<div class="line"><span class="lineno"> 4073</span>    edge, ext = _validate_pad(padtype, padlen, x, axis,</div>
<div class="line"><span class="lineno"> 4074</span>                              ntaps=max(len(a), len(b)))</div>
<div class="line"><span class="lineno"> 4075</span> </div>
<div class="line"><span class="lineno"> 4076</span>    <span class="comment"># Get the steady state of the filter&#39;s step response.</span></div>
<div class="line"><span class="lineno"> 4077</span>    zi = lfilter_zi(b, a)</div>
<div class="line"><span class="lineno"> 4078</span> </div>
<div class="line"><span class="lineno"> 4079</span>    <span class="comment"># Reshape zi and create x0 so that zi*x0 broadcasts</span></div>
<div class="line"><span class="lineno"> 4080</span>    <span class="comment"># to the correct value for the &#39;zi&#39; keyword argument</span></div>
<div class="line"><span class="lineno"> 4081</span>    <span class="comment"># to lfilter.</span></div>
<div class="line"><span class="lineno"> 4082</span>    zi_shape = [1] * x.ndim</div>
<div class="line"><span class="lineno"> 4083</span>    zi_shape[axis] = zi.size</div>
<div class="line"><span class="lineno"> 4084</span>    zi = np.reshape(zi, zi_shape)</div>
<div class="line"><span class="lineno"> 4085</span>    x0 = axis_slice(ext, stop=1, axis=axis)</div>
<div class="line"><span class="lineno"> 4086</span> </div>
<div class="line"><span class="lineno"> 4087</span>    <span class="comment"># Forward filter.</span></div>
<div class="line"><span class="lineno"> 4088</span>    (y, zf) = lfilter(b, a, ext, axis=axis, zi=zi * x0)</div>
<div class="line"><span class="lineno"> 4089</span> </div>
<div class="line"><span class="lineno"> 4090</span>    <span class="comment"># Backward filter.</span></div>
<div class="line"><span class="lineno"> 4091</span>    <span class="comment"># Create y0 so zi*y0 broadcasts appropriately.</span></div>
<div class="line"><span class="lineno"> 4092</span>    y0 = axis_slice(y, start=-1, axis=axis)</div>
<div class="line"><span class="lineno"> 4093</span>    (y, zf) = lfilter(b, a, axis_reverse(y, axis=axis), axis=axis, zi=zi * y0)</div>
<div class="line"><span class="lineno"> 4094</span> </div>
<div class="line"><span class="lineno"> 4095</span>    <span class="comment"># Reverse y.</span></div>
<div class="line"><span class="lineno"> 4096</span>    y = axis_reverse(y, axis=axis)</div>
<div class="line"><span class="lineno"> 4097</span> </div>
<div class="line"><span class="lineno"> 4098</span>    <span class="keywordflow">if</span> edge &gt; 0:</div>
<div class="line"><span class="lineno"> 4099</span>        <span class="comment"># Slice the actual signal from the extended signal.</span></div>
<div class="line"><span class="lineno"> 4100</span>        y = axis_slice(y, start=edge, stop=-edge, axis=axis)</div>
<div class="line"><span class="lineno"> 4101</span> </div>
<div class="line"><span class="lineno"> 4102</span>    <span class="keywordflow">return</span> y</div>
<div class="line"><span class="lineno"> 4103</span> </div>
<div class="line"><span class="lineno"> 4104</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a855107b383ce065fb67295d5bb0c7dae" name="a855107b383ce065fb67295d5bb0c7dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855107b383ce065fb67295d5bb0c7dae">&#9670;&#160;</a></span>hilbert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.hilbert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the analytic signal, using the Hilbert transform.

The transformation is done along the last axis by default.

Parameters
----------
x : array_like
    Signal data.  Must be real.
N : int, optional
    Number of Fourier components.  Default: ``x.shape[axis]``
axis : int, optional
    Axis along which to do the transformation.  Default: -1.

Returns
-------
xa : ndarray
    Analytic signal of `x`, of each 1-D array along `axis`

Notes
-----
The analytic signal ``x_a(t)`` of signal ``x(t)`` is:

.. math:: x_a = F^{-1}(F(x) 2U) = x + i y

where `F` is the Fourier transform, `U` the unit step function,
and `y` the Hilbert transform of `x`. [1]_

In other words, the negative half of the frequency spectrum is zeroed
out, turning the real-valued signal into a complex signal.  The Hilbert
transformed signal can be obtained from ``np.imag(hilbert(x))``, and the
original signal from ``np.real(hilbert(x))``.

Examples
--------
In this example we use the Hilbert transform to determine the amplitude
envelope and instantaneous frequency of an amplitude-modulated signal.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy.signal import hilbert, chirp

&gt;&gt;&gt; duration = 1.0
&gt;&gt;&gt; fs = 400.0
&gt;&gt;&gt; samples = int(fs*duration)
&gt;&gt;&gt; t = np.arange(samples) / fs

We create a chirp of which the frequency increases from 20 Hz to 100 Hz and
apply an amplitude modulation.

&gt;&gt;&gt; signal = chirp(t, 20.0, t[-1], 100.0)
&gt;&gt;&gt; signal *= (1.0 + 0.5 * np.sin(2.0*np.pi*3.0*t) )

The amplitude envelope is given by magnitude of the analytic signal. The
instantaneous frequency can be obtained by differentiating the
instantaneous phase in respect to time. The instantaneous phase corresponds
to the phase angle of the analytic signal.

&gt;&gt;&gt; analytic_signal = hilbert(signal)
&gt;&gt;&gt; amplitude_envelope = np.abs(analytic_signal)
&gt;&gt;&gt; instantaneous_phase = np.unwrap(np.angle(analytic_signal))
&gt;&gt;&gt; instantaneous_frequency = (np.diff(instantaneous_phase) /
...                            (2.0*np.pi) * fs)

&gt;&gt;&gt; fig, (ax0, ax1) = plt.subplots(nrows=2)
&gt;&gt;&gt; ax0.plot(t, signal, label='signal')
&gt;&gt;&gt; ax0.plot(t, amplitude_envelope, label='envelope')
&gt;&gt;&gt; ax0.set_xlabel("time in seconds")
&gt;&gt;&gt; ax0.legend()
&gt;&gt;&gt; ax1.plot(t[1:], instantaneous_frequency)
&gt;&gt;&gt; ax1.set_xlabel("time in seconds")
&gt;&gt;&gt; ax1.set_ylim(0.0, 120.0)
&gt;&gt;&gt; fig.tight_layout()

References
----------
.. [1] Wikipedia, "Analytic signal".
       https://en.wikipedia.org/wiki/Analytic_signal
.. [2] Leon Cohen, "Time-Frequency Analysis", 1995. Chapter 2.
.. [3] Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal
       Processing, Third Edition, 2009. Chapter 12.
       ISBN 13: 978-1292-02572-8</pre> <div class="fragment"><div class="line"><span class="lineno"> 2212</span><span class="keyword">def </span>hilbert(x, N=None, axis=-1):</div>
<div class="line"><span class="lineno"> 2213</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">    Compute the analytic signal, using the Hilbert transform.</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">    The transformation is done along the last axis by default.</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral">        Signal data.  Must be real.</span></div>
<div class="line"><span class="lineno"> 2222</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral">        Number of Fourier components.  Default: ``x.shape[axis]``</span></div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral">        Axis along which to do the transformation.  Default: -1.</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">    xa : ndarray</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">        Analytic signal of `x`, of each 1-D array along `axis`</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">    The analytic signal ``x_a(t)`` of signal ``x(t)`` is:</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    .. math:: x_a = F^{-1}(F(x) 2U) = x + i y</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral">    where `F` is the Fourier transform, `U` the unit step function,</span></div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">    and `y` the Hilbert transform of `x`. [1]_</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">    In other words, the negative half of the frequency spectrum is zeroed</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">    out, turning the real-valued signal into a complex signal.  The Hilbert</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">    transformed signal can be obtained from ``np.imag(hilbert(x))``, and the</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">    original signal from ``np.real(hilbert(x))``.</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">    In this example we use the Hilbert transform to determine the amplitude</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral">    envelope and instantaneous frequency of an amplitude-modulated signal.</span></div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import hilbert, chirp</span></div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">    &gt;&gt;&gt; duration = 1.0</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral">    &gt;&gt;&gt; fs = 400.0</span></div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral">    &gt;&gt;&gt; samples = int(fs*duration)</span></div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">    &gt;&gt;&gt; t = np.arange(samples) / fs</span></div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">    We create a chirp of which the frequency increases from 20 Hz to 100 Hz and</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral">    apply an amplitude modulation.</span></div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral">    &gt;&gt;&gt; signal = chirp(t, 20.0, t[-1], 100.0)</span></div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral">    &gt;&gt;&gt; signal *= (1.0 + 0.5 * np.sin(2.0*np.pi*3.0*t) )</span></div>
<div class="line"><span class="lineno"> 2265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2266</span><span class="stringliteral">    The amplitude envelope is given by magnitude of the analytic signal. The</span></div>
<div class="line"><span class="lineno"> 2267</span><span class="stringliteral">    instantaneous frequency can be obtained by differentiating the</span></div>
<div class="line"><span class="lineno"> 2268</span><span class="stringliteral">    instantaneous phase in respect to time. The instantaneous phase corresponds</span></div>
<div class="line"><span class="lineno"> 2269</span><span class="stringliteral">    to the phase angle of the analytic signal.</span></div>
<div class="line"><span class="lineno"> 2270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2271</span><span class="stringliteral">    &gt;&gt;&gt; analytic_signal = hilbert(signal)</span></div>
<div class="line"><span class="lineno"> 2272</span><span class="stringliteral">    &gt;&gt;&gt; amplitude_envelope = np.abs(analytic_signal)</span></div>
<div class="line"><span class="lineno"> 2273</span><span class="stringliteral">    &gt;&gt;&gt; instantaneous_phase = np.unwrap(np.angle(analytic_signal))</span></div>
<div class="line"><span class="lineno"> 2274</span><span class="stringliteral">    &gt;&gt;&gt; instantaneous_frequency = (np.diff(instantaneous_phase) /</span></div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral">    ...                            (2.0*np.pi) * fs)</span></div>
<div class="line"><span class="lineno"> 2276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2277</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax0, ax1) = plt.subplots(nrows=2)</span></div>
<div class="line"><span class="lineno"> 2278</span><span class="stringliteral">    &gt;&gt;&gt; ax0.plot(t, signal, label=&#39;signal&#39;)</span></div>
<div class="line"><span class="lineno"> 2279</span><span class="stringliteral">    &gt;&gt;&gt; ax0.plot(t, amplitude_envelope, label=&#39;envelope&#39;)</span></div>
<div class="line"><span class="lineno"> 2280</span><span class="stringliteral">    &gt;&gt;&gt; ax0.set_xlabel(&quot;time in seconds&quot;)</span></div>
<div class="line"><span class="lineno"> 2281</span><span class="stringliteral">    &gt;&gt;&gt; ax0.legend()</span></div>
<div class="line"><span class="lineno"> 2282</span><span class="stringliteral">    &gt;&gt;&gt; ax1.plot(t[1:], instantaneous_frequency)</span></div>
<div class="line"><span class="lineno"> 2283</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_xlabel(&quot;time in seconds&quot;)</span></div>
<div class="line"><span class="lineno"> 2284</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_ylim(0.0, 120.0)</span></div>
<div class="line"><span class="lineno"> 2285</span><span class="stringliteral">    &gt;&gt;&gt; fig.tight_layout()</span></div>
<div class="line"><span class="lineno"> 2286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2287</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2288</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2289</span><span class="stringliteral">    .. [1] Wikipedia, &quot;Analytic signal&quot;.</span></div>
<div class="line"><span class="lineno"> 2290</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Analytic_signal</span></div>
<div class="line"><span class="lineno"> 2291</span><span class="stringliteral">    .. [2] Leon Cohen, &quot;Time-Frequency Analysis&quot;, 1995. Chapter 2.</span></div>
<div class="line"><span class="lineno"> 2292</span><span class="stringliteral">    .. [3] Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal</span></div>
<div class="line"><span class="lineno"> 2293</span><span class="stringliteral">           Processing, Third Edition, 2009. Chapter 12.</span></div>
<div class="line"><span class="lineno"> 2294</span><span class="stringliteral">           ISBN 13: 978-1292-02572-8</span></div>
<div class="line"><span class="lineno"> 2295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2296</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2297</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 2298</span>    <span class="keywordflow">if</span> np.iscomplexobj(x):</div>
<div class="line"><span class="lineno"> 2299</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;x must be real.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2300</span>    <span class="keywordflow">if</span> N <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2301</span>        N = x.shape[axis]</div>
<div class="line"><span class="lineno"> 2302</span>    <span class="keywordflow">if</span> N &lt;= 0:</div>
<div class="line"><span class="lineno"> 2303</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;N must be positive.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2304</span> </div>
<div class="line"><span class="lineno"> 2305</span>    Xf = sp_fft.fft(x, N, axis=axis)</div>
<div class="line"><span class="lineno"> 2306</span>    h = np.zeros(N, dtype=Xf.dtype)</div>
<div class="line"><span class="lineno"> 2307</span>    <span class="keywordflow">if</span> N % 2 == 0:</div>
<div class="line"><span class="lineno"> 2308</span>        h[0] = h[N // 2] = 1</div>
<div class="line"><span class="lineno"> 2309</span>        h[1:N // 2] = 2</div>
<div class="line"><span class="lineno"> 2310</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2311</span>        h[0] = 1</div>
<div class="line"><span class="lineno"> 2312</span>        h[1:(N + 1) // 2] = 2</div>
<div class="line"><span class="lineno"> 2313</span> </div>
<div class="line"><span class="lineno"> 2314</span>    <span class="keywordflow">if</span> x.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2315</span>        ind = [np.newaxis] * x.ndim</div>
<div class="line"><span class="lineno"> 2316</span>        ind[axis] = slice(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 2317</span>        h = h[tuple(ind)]</div>
<div class="line"><span class="lineno"> 2318</span>    x = sp_fft.ifft(Xf * h, axis=axis)</div>
<div class="line"><span class="lineno"> 2319</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 2320</span> </div>
<div class="line"><span class="lineno"> 2321</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02f6f43cfe12ce0d267487ff8f520b90" name="a02f6f43cfe12ce0d267487ff8f520b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f6f43cfe12ce0d267487ff8f520b90">&#9670;&#160;</a></span>hilbert2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.hilbert2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the '2-D' analytic signal of `x`

Parameters
----------
x : array_like
    2-D signal data.
N : int or tuple of two ints, optional
    Number of Fourier components. Default is ``x.shape``

Returns
-------
xa : ndarray
    Analytic signal of `x` taken along axes (0,1).

References
----------
.. [1] Wikipedia, "Analytic signal",
    https://en.wikipedia.org/wiki/Analytic_signal</pre> <div class="fragment"><div class="line"><span class="lineno"> 2322</span><span class="keyword">def </span>hilbert2(x, N=None):</div>
<div class="line"><span class="lineno"> 2323</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2324</span><span class="stringliteral">    Compute the &#39;2-D&#39; analytic signal of `x`</span></div>
<div class="line"><span class="lineno"> 2325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2326</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2328</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 2329</span><span class="stringliteral">        2-D signal data.</span></div>
<div class="line"><span class="lineno"> 2330</span><span class="stringliteral">    N : int or tuple of two ints, optional</span></div>
<div class="line"><span class="lineno"> 2331</span><span class="stringliteral">        Number of Fourier components. Default is ``x.shape``</span></div>
<div class="line"><span class="lineno"> 2332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2333</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral">    xa : ndarray</span></div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">        Analytic signal of `x` taken along axes (0,1).</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral">    .. [1] Wikipedia, &quot;Analytic signal&quot;,</span></div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral">        https://en.wikipedia.org/wiki/Analytic_signal</span></div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2344</span>    x = np.atleast_2d(x)</div>
<div class="line"><span class="lineno"> 2345</span>    <span class="keywordflow">if</span> x.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 2346</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;x must be 2-D.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2347</span>    <span class="keywordflow">if</span> np.iscomplexobj(x):</div>
<div class="line"><span class="lineno"> 2348</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;x must be real.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2349</span>    <span class="keywordflow">if</span> N <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2350</span>        N = x.shape</div>
<div class="line"><span class="lineno"> 2351</span>    <span class="keywordflow">elif</span> isinstance(N, int):</div>
<div class="line"><span class="lineno"> 2352</span>        <span class="keywordflow">if</span> N &lt;= 0:</div>
<div class="line"><span class="lineno"> 2353</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;N must be positive.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2354</span>        N = (N, N)</div>
<div class="line"><span class="lineno"> 2355</span>    <span class="keywordflow">elif</span> len(N) != 2 <span class="keywordflow">or</span> np.any(np.asarray(N) &lt;= 0):</div>
<div class="line"><span class="lineno"> 2356</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;When given as a tuple, N must hold exactly &quot;</span></div>
<div class="line"><span class="lineno"> 2357</span>                         <span class="stringliteral">&quot;two positive integers&quot;</span>)</div>
<div class="line"><span class="lineno"> 2358</span> </div>
<div class="line"><span class="lineno"> 2359</span>    Xf = sp_fft.fft2(x, N, axes=(0, 1))</div>
<div class="line"><span class="lineno"> 2360</span>    h1 = np.zeros(N[0], dtype=Xf.dtype)</div>
<div class="line"><span class="lineno"> 2361</span>    h2 = np.zeros(N[1], dtype=Xf.dtype)</div>
<div class="line"><span class="lineno"> 2362</span>    <span class="keywordflow">for</span> p <span class="keywordflow">in</span> range(2):</div>
<div class="line"><span class="lineno"> 2363</span>        h = eval(<span class="stringliteral">&quot;h%d&quot;</span> % (p + 1))</div>
<div class="line"><span class="lineno"> 2364</span>        N1 = N[p]</div>
<div class="line"><span class="lineno"> 2365</span>        <span class="keywordflow">if</span> N1 % 2 == 0:</div>
<div class="line"><span class="lineno"> 2366</span>            h[0] = h[N1 // 2] = 1</div>
<div class="line"><span class="lineno"> 2367</span>            h[1:N1 // 2] = 2</div>
<div class="line"><span class="lineno"> 2368</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2369</span>            h[0] = 1</div>
<div class="line"><span class="lineno"> 2370</span>            h[1:(N1 + 1) // 2] = 2</div>
<div class="line"><span class="lineno"> 2371</span>        exec(<span class="stringliteral">&quot;h%d = h&quot;</span> % (p + 1), globals(), locals())</div>
<div class="line"><span class="lineno"> 2372</span> </div>
<div class="line"><span class="lineno"> 2373</span>    h = h1[:, np.newaxis] * h2[np.newaxis, :]</div>
<div class="line"><span class="lineno"> 2374</span>    k = x.ndim</div>
<div class="line"><span class="lineno"> 2375</span>    <span class="keywordflow">while</span> k &gt; 2:</div>
<div class="line"><span class="lineno"> 2376</span>        h = h[:, np.newaxis]</div>
<div class="line"><span class="lineno"> 2377</span>        k -= 1</div>
<div class="line"><span class="lineno"> 2378</span>    x = sp_fft.ifft2(Xf * h, axes=(0, 1))</div>
<div class="line"><span class="lineno"> 2379</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 2380</span> </div>
<div class="line"><span class="lineno"> 2381</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adc39c1bf004b27d9d064deb3a6c6ef22" name="adc39c1bf004b27d9d064deb3a6c6ef22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc39c1bf004b27d9d064deb3a6c6ef22">&#9670;&#160;</a></span>invres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.invres </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'avg'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute b(s) and a(s) from partial fraction expansion.

If `M` is the degree of numerator `b` and `N` the degree of denominator
`a`::

          b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]
  H(s) = ------ = ------------------------------------------
          a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]

then the partial-fraction expansion H(s) is defined as::

           r[0]       r[1]             r[-1]
       = -------- + -------- + ... + --------- + k(s)
         (s-p[0])   (s-p[1])         (s-p[-1])

If there are any repeated roots (closer together than `tol`), then H(s)
has terms like::

      r[i]      r[i+1]              r[i+n-1]
    -------- + ----------- + ... + -----------
    (s-p[i])  (s-p[i])**2          (s-p[i])**n

This function is used for polynomials in positive powers of s or z,
such as analog filters or digital filters in controls engineering.  For
negative powers of z (typical for digital filters in DSP), use `invresz`.

Parameters
----------
r : array_like
    Residues corresponding to the poles. For repeated poles, the residues
    must be ordered to correspond to ascending by power fractions.
p : array_like
    Poles. Equal poles must be adjacent.
k : array_like
    Coefficients of the direct polynomial term.
tol : float, optional
    The tolerance for two roots to be considered equal in terms of
    the distance between them. Default is 1e-3. See `unique_roots`
    for further details.
rtype : {'avg', 'min', 'max'}, optional
    Method for computing a root to represent a group of identical roots.
    Default is 'avg'. See `unique_roots` for further details.

Returns
-------
b : ndarray
    Numerator polynomial coefficients.
a : ndarray
    Denominator polynomial coefficients.

See Also
--------
residue, invresz, unique_roots</pre> <div class="fragment"><div class="line"><span class="lineno"> 2499</span><span class="keyword">def </span>invres(r, p, k, tol=1e-3, rtype=&#39;avg&#39;):</div>
<div class="line"><span class="lineno"> 2500</span>    <span class="stringliteral">&quot;&quot;&quot;Compute b(s) and a(s) from partial fraction expansion.</span></div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">    `a`::</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral">              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]</span></div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">      H(s) = ------ = ------------------------------------------</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral">              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</span></div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral">    then the partial-fraction expansion H(s) is defined as::</span></div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">               r[0]       r[1]             r[-1]</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">           = -------- + -------- + ... + --------- + k(s)</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">             (s-p[0])   (s-p[1])         (s-p[-1])</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2515</span><span class="stringliteral">    If there are any repeated roots (closer together than `tol`), then H(s)</span></div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">    has terms like::</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral">          r[i]      r[i+1]              r[i+n-1]</span></div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">        -------- + ----------- + ... + -----------</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral">        (s-p[i])  (s-p[i])**2          (s-p[i])**n</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">    This function is used for polynomials in positive powers of s or z,</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral">    such as analog filters or digital filters in controls engineering.  For</span></div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">    negative powers of z (typical for digital filters in DSP), use `invresz`.</span></div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">    r : array_like</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">        Residues corresponding to the poles. For repeated poles, the residues</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">        must be ordered to correspond to ascending by power fractions.</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral">    p : array_like</span></div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">        Poles. Equal poles must be adjacent.</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">    k : array_like</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">        Coefficients of the direct polynomial term.</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno"> 2536</span><span class="stringliteral">        The tolerance for two roots to be considered equal in terms of</span></div>
<div class="line"><span class="lineno"> 2537</span><span class="stringliteral">        the distance between them. Default is 1e-3. See `unique_roots`</span></div>
<div class="line"><span class="lineno"> 2538</span><span class="stringliteral">        for further details.</span></div>
<div class="line"><span class="lineno"> 2539</span><span class="stringliteral">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2540</span><span class="stringliteral">        Method for computing a root to represent a group of identical roots.</span></div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral">    b : ndarray</span></div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral">        Numerator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">        Denominator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral">    residue, invresz, unique_roots</span></div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2555</span>    r = np.atleast_1d(r)</div>
<div class="line"><span class="lineno"> 2556</span>    p = np.atleast_1d(p)</div>
<div class="line"><span class="lineno"> 2557</span>    k = np.trim_zeros(np.atleast_1d(k), <span class="stringliteral">&#39;f&#39;</span>)</div>
<div class="line"><span class="lineno"> 2558</span> </div>
<div class="line"><span class="lineno"> 2559</span>    unique_poles, multiplicity = _group_poles(p, tol, rtype)</div>
<div class="line"><span class="lineno"> 2560</span>    factors, denominator = _compute_factors(unique_poles, multiplicity,</div>
<div class="line"><span class="lineno"> 2561</span>                                            include_powers=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2562</span> </div>
<div class="line"><span class="lineno"> 2563</span>    <span class="keywordflow">if</span> len(k) == 0:</div>
<div class="line"><span class="lineno"> 2564</span>        numerator = 0</div>
<div class="line"><span class="lineno"> 2565</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2566</span>        numerator = np.polymul(k, denominator)</div>
<div class="line"><span class="lineno"> 2567</span> </div>
<div class="line"><span class="lineno"> 2568</span>    <span class="keywordflow">for</span> residue, factor <span class="keywordflow">in</span> zip(r, factors):</div>
<div class="line"><span class="lineno"> 2569</span>        numerator = np.polyadd(numerator, residue * factor)</div>
<div class="line"><span class="lineno"> 2570</span> </div>
<div class="line"><span class="lineno"> 2571</span>    <span class="keywordflow">return</span> numerator, denominator</div>
<div class="line"><span class="lineno"> 2572</span> </div>
<div class="line"><span class="lineno"> 2573</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af3d5f11397e42a0fa2ec7499a8ee9a99" name="af3d5f11397e42a0fa2ec7499a8ee9a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d5f11397e42a0fa2ec7499a8ee9a99">&#9670;&#160;</a></span>invresz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.invresz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'avg'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute b(z) and a(z) from partial fraction expansion.

If `M` is the degree of numerator `b` and `N` the degree of denominator
`a`::

            b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)
    H(z) = ------ = ------------------------------------------
            a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)

then the partial-fraction expansion H(z) is defined as::

             r[0]                   r[-1]
     = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...
       (1-p[0]z**(-1))         (1-p[-1]z**(-1))

If there are any repeated roots (closer than `tol`), then the partial
fraction expansion has terms like::

         r[i]              r[i+1]                    r[i+n-1]
    -------------- + ------------------ + ... + ------------------
    (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n

This function is used for polynomials in negative powers of z,
such as digital filters in DSP.  For positive powers, use `invres`.

Parameters
----------
r : array_like
    Residues corresponding to the poles. For repeated poles, the residues
    must be ordered to correspond to ascending by power fractions.
p : array_like
    Poles. Equal poles must be adjacent.
k : array_like
    Coefficients of the direct polynomial term.
tol : float, optional
    The tolerance for two roots to be considered equal in terms of
    the distance between them. Default is 1e-3. See `unique_roots`
    for further details.
rtype : {'avg', 'min', 'max'}, optional
    Method for computing a root to represent a group of identical roots.
    Default is 'avg'. See `unique_roots` for further details.

Returns
-------
b : ndarray
    Numerator polynomial coefficients.
a : ndarray
    Denominator polynomial coefficients.

See Also
--------
residuez, unique_roots, invres</pre> <div class="fragment"><div class="line"><span class="lineno"> 2877</span><span class="keyword">def </span>invresz(r, p, k, tol=1e-3, rtype=&#39;avg&#39;):</div>
<div class="line"><span class="lineno"> 2878</span>    <span class="stringliteral">&quot;&quot;&quot;Compute b(z) and a(z) from partial fraction expansion.</span></div>
<div class="line"><span class="lineno"> 2879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2880</span><span class="stringliteral">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span></div>
<div class="line"><span class="lineno"> 2881</span><span class="stringliteral">    `a`::</span></div>
<div class="line"><span class="lineno"> 2882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2883</span><span class="stringliteral">                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)</span></div>
<div class="line"><span class="lineno"> 2884</span><span class="stringliteral">        H(z) = ------ = ------------------------------------------</span></div>
<div class="line"><span class="lineno"> 2885</span><span class="stringliteral">                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</span></div>
<div class="line"><span class="lineno"> 2886</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2887</span><span class="stringliteral">    then the partial-fraction expansion H(z) is defined as::</span></div>
<div class="line"><span class="lineno"> 2888</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2889</span><span class="stringliteral">                 r[0]                   r[-1]</span></div>
<div class="line"><span class="lineno"> 2890</span><span class="stringliteral">         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...</span></div>
<div class="line"><span class="lineno"> 2891</span><span class="stringliteral">           (1-p[0]z**(-1))         (1-p[-1]z**(-1))</span></div>
<div class="line"><span class="lineno"> 2892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2893</span><span class="stringliteral">    If there are any repeated roots (closer than `tol`), then the partial</span></div>
<div class="line"><span class="lineno"> 2894</span><span class="stringliteral">    fraction expansion has terms like::</span></div>
<div class="line"><span class="lineno"> 2895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2896</span><span class="stringliteral">             r[i]              r[i+1]                    r[i+n-1]</span></div>
<div class="line"><span class="lineno"> 2897</span><span class="stringliteral">        -------------- + ------------------ + ... + ------------------</span></div>
<div class="line"><span class="lineno"> 2898</span><span class="stringliteral">        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n</span></div>
<div class="line"><span class="lineno"> 2899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2900</span><span class="stringliteral">    This function is used for polynomials in negative powers of z,</span></div>
<div class="line"><span class="lineno"> 2901</span><span class="stringliteral">    such as digital filters in DSP.  For positive powers, use `invres`.</span></div>
<div class="line"><span class="lineno"> 2902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2903</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2904</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2905</span><span class="stringliteral">    r : array_like</span></div>
<div class="line"><span class="lineno"> 2906</span><span class="stringliteral">        Residues corresponding to the poles. For repeated poles, the residues</span></div>
<div class="line"><span class="lineno"> 2907</span><span class="stringliteral">        must be ordered to correspond to ascending by power fractions.</span></div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral">    p : array_like</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral">        Poles. Equal poles must be adjacent.</span></div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral">    k : array_like</span></div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral">        Coefficients of the direct polynomial term.</span></div>
<div class="line"><span class="lineno"> 2912</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral">        The tolerance for two roots to be considered equal in terms of</span></div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral">        the distance between them. Default is 1e-3. See `unique_roots`</span></div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">        for further details.</span></div>
<div class="line"><span class="lineno"> 2916</span><span class="stringliteral">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2917</span><span class="stringliteral">        Method for computing a root to represent a group of identical roots.</span></div>
<div class="line"><span class="lineno"> 2918</span><span class="stringliteral">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span></div>
<div class="line"><span class="lineno"> 2919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2920</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2921</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2922</span><span class="stringliteral">    b : ndarray</span></div>
<div class="line"><span class="lineno"> 2923</span><span class="stringliteral">        Numerator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2924</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno"> 2925</span><span class="stringliteral">        Denominator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2926</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2927</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2928</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2929</span><span class="stringliteral">    residuez, unique_roots, invres</span></div>
<div class="line"><span class="lineno"> 2930</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2931</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2932</span>    r = np.atleast_1d(r)</div>
<div class="line"><span class="lineno"> 2933</span>    p = np.atleast_1d(p)</div>
<div class="line"><span class="lineno"> 2934</span>    k = np.trim_zeros(np.atleast_1d(k), <span class="stringliteral">&#39;b&#39;</span>)</div>
<div class="line"><span class="lineno"> 2935</span> </div>
<div class="line"><span class="lineno"> 2936</span>    unique_poles, multiplicity = _group_poles(p, tol, rtype)</div>
<div class="line"><span class="lineno"> 2937</span>    factors, denominator = _compute_factors(unique_poles, multiplicity,</div>
<div class="line"><span class="lineno"> 2938</span>                                            include_powers=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2939</span> </div>
<div class="line"><span class="lineno"> 2940</span>    <span class="keywordflow">if</span> len(k) == 0:</div>
<div class="line"><span class="lineno"> 2941</span>        numerator = 0</div>
<div class="line"><span class="lineno"> 2942</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2943</span>        numerator = np.polymul(k[::-1], denominator[::-1])</div>
<div class="line"><span class="lineno"> 2944</span> </div>
<div class="line"><span class="lineno"> 2945</span>    <span class="keywordflow">for</span> residue, factor <span class="keywordflow">in</span> zip(r, factors):</div>
<div class="line"><span class="lineno"> 2946</span>        numerator = np.polyadd(numerator, residue * factor[::-1])</div>
<div class="line"><span class="lineno"> 2947</span> </div>
<div class="line"><span class="lineno"> 2948</span>    <span class="keywordflow">return</span> numerator[::-1], denominator</div>
<div class="line"><span class="lineno"> 2949</span> </div>
<div class="line"><span class="lineno"> 2950</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a281ea82fa1b515b6fbdef0001e6fbdee" name="a281ea82fa1b515b6fbdef0001e6fbdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281ea82fa1b515b6fbdef0001e6fbdee">&#9670;&#160;</a></span>lfilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.lfilter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zi</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Filter data along one-dimension with an IIR or FIR filter.

Filter a data sequence, `x`, using a digital filter.  This works for many
fundamental data types (including Object type).  The filter is a direct
form II transposed implementation of the standard difference equation
(see Notes).

The function `sosfilt` (and filter design using ``output='sos'``) should be
preferred over `lfilter` for most filtering tasks, as second-order sections
have fewer numerical problems.

Parameters
----------
b : array_like
    The numerator coefficient vector in a 1-D sequence.
a : array_like
    The denominator coefficient vector in a 1-D sequence.  If ``a[0]``
    is not 1, then both `a` and `b` are normalized by ``a[0]``.
x : array_like
    An N-dimensional input array.
axis : int, optional
    The axis of the input data array along which to apply the
    linear filter. The filter is applied to each subarray along
    this axis.  Default is -1.
zi : array_like, optional
    Initial conditions for the filter delays.  It is a vector
    (or array of vectors for an N-dimensional input) of length
    ``max(len(a), len(b)) - 1``.  If `zi` is None or is not given then
    initial rest is assumed.  See `lfiltic` for more information.

Returns
-------
y : array
    The output of the digital filter.
zf : array, optional
    If `zi` is None, this is not returned, otherwise, `zf` holds the
    final filter delay values.

See Also
--------
lfiltic : Construct initial conditions for `lfilter`.
lfilter_zi : Compute initial state (steady state of step response) for
             `lfilter`.
filtfilt : A forward-backward filter, to obtain a filter with zero phase.
savgol_filter : A Savitzky-Golay filter.
sosfilt: Filter data using cascaded second-order sections.
sosfiltfilt: A forward-backward filter using second-order sections.

Notes
-----
The filter function is implemented as a direct II transposed structure.
This means that the filter implements::

   a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[M]*x[n-M]
                         - a[1]*y[n-1] - ... - a[N]*y[n-N]

where `M` is the degree of the numerator, `N` is the degree of the
denominator, and `n` is the sample number.  It is implemented using
the following difference equations (assuming M = N)::

     a[0]*y[n] = b[0] * x[n]               + d[0][n-1]
       d[0][n] = b[1] * x[n] - a[1] * y[n] + d[1][n-1]
       d[1][n] = b[2] * x[n] - a[2] * y[n] + d[2][n-1]
     ...
     d[N-2][n] = b[N-1]*x[n] - a[N-1]*y[n] + d[N-1][n-1]
     d[N-1][n] = b[N] * x[n] - a[N] * y[n]

where `d` are the state variables.

The rational transfer function describing this filter in the
z-transform domain is::

                         -1              -M
             b[0] + b[1]z  + ... + b[M] z
     Y(z) = -------------------------------- X(z)
                         -1              -N
             a[0] + a[1]z  + ... + a[N] z

Examples
--------
Generate a noisy signal to be filtered:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; t = np.linspace(-1, 1, 201)
&gt;&gt;&gt; x = (np.sin(2*np.pi*0.75*t*(1-t) + 2.1) +
...      0.1*np.sin(2*np.pi*1.25*t + 1) +
...      0.18*np.cos(2*np.pi*3.85*t))
&gt;&gt;&gt; xn = x + rng.standard_normal(len(t)) * 0.08

Create an order 3 lowpass butterworth filter:

&gt;&gt;&gt; b, a = signal.butter(3, 0.05)

Apply the filter to xn.  Use lfilter_zi to choose the initial condition of
the filter:

&gt;&gt;&gt; zi = signal.lfilter_zi(b, a)
&gt;&gt;&gt; z, _ = signal.lfilter(b, a, xn, zi=zi*xn[0])

Apply the filter again, to have a result filtered at an order the same as
filtfilt:

&gt;&gt;&gt; z2, _ = signal.lfilter(b, a, z, zi=zi*z[0])

Use filtfilt to apply the filter:

&gt;&gt;&gt; y = signal.filtfilt(b, a, xn)

Plot the original signal and the various filtered versions:

&gt;&gt;&gt; plt.figure
&gt;&gt;&gt; plt.plot(t, xn, 'b', alpha=0.75)
&gt;&gt;&gt; plt.plot(t, z, 'r--', t, z2, 'r', t, y, 'k')
&gt;&gt;&gt; plt.legend(('noisy signal', 'lfilter, once', 'lfilter, twice',
...             'filtfilt'), loc='best')
&gt;&gt;&gt; plt.grid(True)
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 1880</span><span class="keyword">def </span>lfilter(b, a, x, axis=-1, zi=None):</div>
<div class="line"><span class="lineno"> 1881</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral">    Filter data along one-dimension with an IIR or FIR filter.</span></div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">    Filter a data sequence, `x`, using a digital filter.  This works for many</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">    fundamental data types (including Object type).  The filter is a direct</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    form II transposed implementation of the standard difference equation</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral">    (see Notes).</span></div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral">    The function `sosfilt` (and filter design using ``output=&#39;sos&#39;``) should be</span></div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">    preferred over `lfilter` for most filtering tasks, as second-order sections</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">    have fewer numerical problems.</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">        The numerator coefficient vector in a 1-D sequence.</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">        The denominator coefficient vector in a 1-D sequence.  If ``a[0]``</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">        is not 1, then both `a` and `b` are normalized by ``a[0]``.</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">        An N-dimensional input array.</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">        The axis of the input data array along which to apply the</span></div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">        linear filter. The filter is applied to each subarray along</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral">        this axis.  Default is -1.</span></div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">    zi : array_like, optional</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">        Initial conditions for the filter delays.  It is a vector</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">        (or array of vectors for an N-dimensional input) of length</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">        ``max(len(a), len(b)) - 1``.  If `zi` is None or is not given then</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">        initial rest is assumed.  See `lfiltic` for more information.</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">    y : array</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">        The output of the digital filter.</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    zf : array, optional</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">        If `zi` is None, this is not returned, otherwise, `zf` holds the</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral">        final filter delay values.</span></div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral">    lfiltic : Construct initial conditions for `lfilter`.</span></div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">    lfilter_zi : Compute initial state (steady state of step response) for</span></div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral">                 `lfilter`.</span></div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">    filtfilt : A forward-backward filter, to obtain a filter with zero phase.</span></div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">    savgol_filter : A Savitzky-Golay filter.</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral">    sosfilt: Filter data using cascaded second-order sections.</span></div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">    sosfiltfilt: A forward-backward filter using second-order sections.</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral">    The filter function is implemented as a direct II transposed structure.</span></div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">    This means that the filter implements::</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral">       a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[M]*x[n-M]</span></div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral">                             - a[1]*y[n-1] - ... - a[N]*y[n-N]</span></div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral">    where `M` is the degree of the numerator, `N` is the degree of the</span></div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral">    denominator, and `n` is the sample number.  It is implemented using</span></div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral">    the following difference equations (assuming M = N)::</span></div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">         a[0]*y[n] = b[0] * x[n]               + d[0][n-1]</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">           d[0][n] = b[1] * x[n] - a[1] * y[n] + d[1][n-1]</span></div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">           d[1][n] = b[2] * x[n] - a[2] * y[n] + d[2][n-1]</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">         ...</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">         d[N-2][n] = b[N-1]*x[n] - a[N-1]*y[n] + d[N-1][n-1]</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">         d[N-1][n] = b[N] * x[n] - a[N] * y[n]</span></div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral">    where `d` are the state variables.</span></div>
<div class="line"><span class="lineno"> 1950</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1951</span><span class="stringliteral">    The rational transfer function describing this filter in the</span></div>
<div class="line"><span class="lineno"> 1952</span><span class="stringliteral">    z-transform domain is::</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">                             -1              -M</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">                 b[0] + b[1]z  + ... + b[M] z</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral">         Y(z) = -------------------------------- X(z)</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral">                             -1              -N</span></div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">                 a[0] + a[1]z  + ... + a[N] z</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">    Generate a noisy signal to be filtered:</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(-1, 1, 201)</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">    &gt;&gt;&gt; x = (np.sin(2*np.pi*0.75*t*(1-t) + 2.1) +</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">    ...      0.1*np.sin(2*np.pi*1.25*t + 1) +</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    ...      0.18*np.cos(2*np.pi*3.85*t))</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">    &gt;&gt;&gt; xn = x + rng.standard_normal(len(t)) * 0.08</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    Create an order 3 lowpass butterworth filter:</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">    &gt;&gt;&gt; b, a = signal.butter(3, 0.05)</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">    Apply the filter to xn.  Use lfilter_zi to choose the initial condition of</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">    the filter:</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">    &gt;&gt;&gt; zi = signal.lfilter_zi(b, a)</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">    &gt;&gt;&gt; z, _ = signal.lfilter(b, a, xn, zi=zi*xn[0])</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    Apply the filter again, to have a result filtered at an order the same as</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    filtfilt:</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">    &gt;&gt;&gt; z2, _ = signal.lfilter(b, a, z, zi=zi*z[0])</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    Use filtfilt to apply the filter:</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1990</span><span class="stringliteral">    &gt;&gt;&gt; y = signal.filtfilt(b, a, xn)</span></div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral">    Plot the original signal and the various filtered versions:</span></div>
<div class="line"><span class="lineno"> 1993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure</span></div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, xn, &#39;b&#39;, alpha=0.75)</span></div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, z, &#39;r--&#39;, t, z2, &#39;r&#39;, t, y, &#39;k&#39;)</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend((&#39;noisy signal&#39;, &#39;lfilter, once&#39;, &#39;lfilter, twice&#39;,</span></div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">    ...             &#39;filtfilt&#39;), loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(True)</span></div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2003</span>    a = np.atleast_1d(a)</div>
<div class="line"><span class="lineno"> 2004</span>    <span class="keywordflow">if</span> len(a) == 1:</div>
<div class="line"><span class="lineno"> 2005</span>        <span class="comment"># This path only supports types fdgFDGO to mirror _linear_filter below.</span></div>
<div class="line"><span class="lineno"> 2006</span>        <span class="comment"># Any of b, a, x, or zi can set the dtype, but there is no default</span></div>
<div class="line"><span class="lineno"> 2007</span>        <span class="comment"># casting of other types; instead a NotImplementedError is raised.</span></div>
<div class="line"><span class="lineno"> 2008</span>        b = np.asarray(b)</div>
<div class="line"><span class="lineno"> 2009</span>        a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 2010</span>        <span class="keywordflow">if</span> b.ndim != 1 <span class="keywordflow">and</span> a.ndim != 1:</div>
<div class="line"><span class="lineno"> 2011</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;object of too small depth for desired array&#39;</span>)</div>
<div class="line"><span class="lineno"> 2012</span>        x = _validate_x(x)</div>
<div class="line"><span class="lineno"> 2013</span>        inputs = [b, a, x]</div>
<div class="line"><span class="lineno"> 2014</span>        <span class="keywordflow">if</span> zi <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2015</span>            <span class="comment"># _linear_filter does not broadcast zi, but does do expansion of</span></div>
<div class="line"><span class="lineno"> 2016</span>            <span class="comment"># singleton dims.</span></div>
<div class="line"><span class="lineno"> 2017</span>            zi = np.asarray(zi)</div>
<div class="line"><span class="lineno"> 2018</span>            <span class="keywordflow">if</span> zi.ndim != x.ndim:</div>
<div class="line"><span class="lineno"> 2019</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;object of too small depth for desired array&#39;</span>)</div>
<div class="line"><span class="lineno"> 2020</span>            expected_shape = list(x.shape)</div>
<div class="line"><span class="lineno"> 2021</span>            expected_shape[axis] = b.shape[0] - 1</div>
<div class="line"><span class="lineno"> 2022</span>            expected_shape = tuple(expected_shape)</div>
<div class="line"><span class="lineno"> 2023</span>            <span class="comment"># check the trivial case where zi is the right shape first</span></div>
<div class="line"><span class="lineno"> 2024</span>            <span class="keywordflow">if</span> zi.shape != expected_shape:</div>
<div class="line"><span class="lineno"> 2025</span>                strides = zi.ndim * [<span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno"> 2026</span>                <span class="keywordflow">if</span> axis &lt; 0:</div>
<div class="line"><span class="lineno"> 2027</span>                    axis += zi.ndim</div>
<div class="line"><span class="lineno"> 2028</span>                <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(zi.ndim):</div>
<div class="line"><span class="lineno"> 2029</span>                    <span class="keywordflow">if</span> k == axis <span class="keywordflow">and</span> zi.shape[k] == expected_shape[k]:</div>
<div class="line"><span class="lineno"> 2030</span>                        strides[k] = zi.strides[k]</div>
<div class="line"><span class="lineno"> 2031</span>                    <span class="keywordflow">elif</span> k != axis <span class="keywordflow">and</span> zi.shape[k] == expected_shape[k]:</div>
<div class="line"><span class="lineno"> 2032</span>                        strides[k] = zi.strides[k]</div>
<div class="line"><span class="lineno"> 2033</span>                    <span class="keywordflow">elif</span> k != axis <span class="keywordflow">and</span> zi.shape[k] == 1:</div>
<div class="line"><span class="lineno"> 2034</span>                        strides[k] = 0</div>
<div class="line"><span class="lineno"> 2035</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2036</span>                        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Unexpected shape for zi: expected &#39;</span></div>
<div class="line"><span class="lineno"> 2037</span>                                         <span class="stringliteral">&#39;%s, found %s.&#39;</span> %</div>
<div class="line"><span class="lineno"> 2038</span>                                         (expected_shape, zi.shape))</div>
<div class="line"><span class="lineno"> 2039</span>                zi = np.lib.stride_tricks.as_strided(zi, expected_shape,</div>
<div class="line"><span class="lineno"> 2040</span>                                                     strides)</div>
<div class="line"><span class="lineno"> 2041</span>            inputs.append(zi)</div>
<div class="line"><span class="lineno"> 2042</span>        dtype = np.result_type(*inputs)</div>
<div class="line"><span class="lineno"> 2043</span> </div>
<div class="line"><span class="lineno"> 2044</span>        <span class="keywordflow">if</span> dtype.char <span class="keywordflow">not</span> <span class="keywordflow">in</span> <span class="stringliteral">&#39;fdgFDGO&#39;</span>:</div>
<div class="line"><span class="lineno"> 2045</span>            <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;input type &#39;%s&#39; not supported&quot;</span> % dtype)</div>
<div class="line"><span class="lineno"> 2046</span> </div>
<div class="line"><span class="lineno"> 2047</span>        b = np.array(b, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2048</span>        a = np.array(a, dtype=dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2049</span>        b /= a[0]</div>
<div class="line"><span class="lineno"> 2050</span>        x = np.array(x, dtype=dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2051</span> </div>
<div class="line"><span class="lineno"> 2052</span>        out_full = np.apply_along_axis(<span class="keyword">lambda</span> y: np.convolve(b, y), axis, x)</div>
<div class="line"><span class="lineno"> 2053</span>        ind = out_full.ndim * [slice(<span class="keywordtype">None</span>)]</div>
<div class="line"><span class="lineno"> 2054</span>        <span class="keywordflow">if</span> zi <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2055</span>            ind[axis] = slice(zi.shape[axis])</div>
<div class="line"><span class="lineno"> 2056</span>            out_full[tuple(ind)] += zi</div>
<div class="line"><span class="lineno"> 2057</span> </div>
<div class="line"><span class="lineno"> 2058</span>        ind[axis] = slice(out_full.shape[axis] - len(b) + 1)</div>
<div class="line"><span class="lineno"> 2059</span>        out = out_full[tuple(ind)]</div>
<div class="line"><span class="lineno"> 2060</span> </div>
<div class="line"><span class="lineno"> 2061</span>        <span class="keywordflow">if</span> zi <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2062</span>            <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 2063</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2064</span>            ind[axis] = slice(out_full.shape[axis] - len(b) + 1, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 2065</span>            zf = out_full[tuple(ind)]</div>
<div class="line"><span class="lineno"> 2066</span>            <span class="keywordflow">return</span> out, zf</div>
<div class="line"><span class="lineno"> 2067</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2068</span>        <span class="keywordflow">if</span> zi <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2069</span>            <span class="keywordflow">return</span> _sigtools._linear_filter(b, a, x, axis)</div>
<div class="line"><span class="lineno"> 2070</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2071</span>            <span class="keywordflow">return</span> _sigtools._linear_filter(b, a, x, axis, zi)</div>
<div class="line"><span class="lineno"> 2072</span> </div>
<div class="line"><span class="lineno"> 2073</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aca181b2c9b4293e589a8cc8ca5992e4d" name="aca181b2c9b4293e589a8cc8ca5992e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca181b2c9b4293e589a8cc8ca5992e4d">&#9670;&#160;</a></span>lfilter_zi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.lfilter_zi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct initial conditions for lfilter for step response steady-state.

Compute an initial state `zi` for the `lfilter` function that corresponds
to the steady state of the step response.

A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.

Parameters
----------
b, a : array_like (1-D)
    The IIR filter coefficients. See `lfilter` for more
    information.

Returns
-------
zi : 1-D ndarray
    The initial state for the filter.

See Also
--------
lfilter, lfiltic, filtfilt

Notes
-----
A linear filter with order m has a state space representation (A, B, C, D),
for which the output y of the filter can be expressed as::

    z(n+1) = A*z(n) + B*x(n)
    y(n)   = C*z(n) + D*x(n)

where z(n) is a vector of length m, A has shape (m, m), B has shape
(m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is
a scalar).  lfilter_zi solves::

    zi = A*zi + B

In other words, it finds the initial condition for which the response
to an input of all ones is a constant.

Given the filter coefficients `a` and `b`, the state space matrices
for the transposed direct form II implementation of the linear filter,
which is the implementation used by scipy.signal.lfilter, are::

    A = scipy.linalg.companion(a).T
    B = b[1:] - a[1:]*b[0]

assuming `a[0]` is 1.0; if `a[0]` is not 1, `a` and `b` are first
divided by a[0].

Examples
--------
The following code creates a lowpass Butterworth filter. Then it
applies that filter to an array whose values are all 1.0; the
output is also all 1.0, as expected for a lowpass filter.  If the
`zi` argument of `lfilter` had not been given, the output would have
shown the transient signal.

&gt;&gt;&gt; from numpy import array, ones
&gt;&gt;&gt; from scipy.signal import lfilter, lfilter_zi, butter
&gt;&gt;&gt; b, a = butter(5, 0.25)
&gt;&gt;&gt; zi = lfilter_zi(b, a)
&gt;&gt;&gt; y, zo = lfilter(b, a, ones(10), zi=zi)
&gt;&gt;&gt; y
array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])

Another example:

&gt;&gt;&gt; x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])
&gt;&gt;&gt; y, zf = lfilter(b, a, x, zi=zi*x[0])
&gt;&gt;&gt; y
array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,
    0.44399389,  0.35505241])

Note that the `zi` argument to `lfilter` was computed using
`lfilter_zi` and scaled by `x[0]`.  Then the output `y` has no
transient until the input drops from 0.5 to 0.0.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3514</span><span class="keyword">def </span>lfilter_zi(b, a):</div>
<div class="line"><span class="lineno"> 3515</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3516</span><span class="stringliteral">    Construct initial conditions for lfilter for step response steady-state.</span></div>
<div class="line"><span class="lineno"> 3517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3518</span><span class="stringliteral">    Compute an initial state `zi` for the `lfilter` function that corresponds</span></div>
<div class="line"><span class="lineno"> 3519</span><span class="stringliteral">    to the steady state of the step response.</span></div>
<div class="line"><span class="lineno"> 3520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3521</span><span class="stringliteral">    A typical use of this function is to set the initial state so that the</span></div>
<div class="line"><span class="lineno"> 3522</span><span class="stringliteral">    output of the filter starts at the same value as the first element of</span></div>
<div class="line"><span class="lineno"> 3523</span><span class="stringliteral">    the signal to be filtered.</span></div>
<div class="line"><span class="lineno"> 3524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3525</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3526</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3527</span><span class="stringliteral">    b, a : array_like (1-D)</span></div>
<div class="line"><span class="lineno"> 3528</span><span class="stringliteral">        The IIR filter coefficients. See `lfilter` for more</span></div>
<div class="line"><span class="lineno"> 3529</span><span class="stringliteral">        information.</span></div>
<div class="line"><span class="lineno"> 3530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3531</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3532</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3533</span><span class="stringliteral">    zi : 1-D ndarray</span></div>
<div class="line"><span class="lineno"> 3534</span><span class="stringliteral">        The initial state for the filter.</span></div>
<div class="line"><span class="lineno"> 3535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3536</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3537</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3538</span><span class="stringliteral">    lfilter, lfiltic, filtfilt</span></div>
<div class="line"><span class="lineno"> 3539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3540</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3541</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3542</span><span class="stringliteral">    A linear filter with order m has a state space representation (A, B, C, D),</span></div>
<div class="line"><span class="lineno"> 3543</span><span class="stringliteral">    for which the output y of the filter can be expressed as::</span></div>
<div class="line"><span class="lineno"> 3544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3545</span><span class="stringliteral">        z(n+1) = A*z(n) + B*x(n)</span></div>
<div class="line"><span class="lineno"> 3546</span><span class="stringliteral">        y(n)   = C*z(n) + D*x(n)</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral">    where z(n) is a vector of length m, A has shape (m, m), B has shape</span></div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">    (m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is</span></div>
<div class="line"><span class="lineno"> 3550</span><span class="stringliteral">    a scalar).  lfilter_zi solves::</span></div>
<div class="line"><span class="lineno"> 3551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3552</span><span class="stringliteral">        zi = A*zi + B</span></div>
<div class="line"><span class="lineno"> 3553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3554</span><span class="stringliteral">    In other words, it finds the initial condition for which the response</span></div>
<div class="line"><span class="lineno"> 3555</span><span class="stringliteral">    to an input of all ones is a constant.</span></div>
<div class="line"><span class="lineno"> 3556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3557</span><span class="stringliteral">    Given the filter coefficients `a` and `b`, the state space matrices</span></div>
<div class="line"><span class="lineno"> 3558</span><span class="stringliteral">    for the transposed direct form II implementation of the linear filter,</span></div>
<div class="line"><span class="lineno"> 3559</span><span class="stringliteral">    which is the implementation used by scipy.signal.lfilter, are::</span></div>
<div class="line"><span class="lineno"> 3560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3561</span><span class="stringliteral">        A = scipy.linalg.companion(a).T</span></div>
<div class="line"><span class="lineno"> 3562</span><span class="stringliteral">        B = b[1:] - a[1:]*b[0]</span></div>
<div class="line"><span class="lineno"> 3563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3564</span><span class="stringliteral">    assuming `a[0]` is 1.0; if `a[0]` is not 1, `a` and `b` are first</span></div>
<div class="line"><span class="lineno"> 3565</span><span class="stringliteral">    divided by a[0].</span></div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3568</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3569</span><span class="stringliteral">    The following code creates a lowpass Butterworth filter. Then it</span></div>
<div class="line"><span class="lineno"> 3570</span><span class="stringliteral">    applies that filter to an array whose values are all 1.0; the</span></div>
<div class="line"><span class="lineno"> 3571</span><span class="stringliteral">    output is also all 1.0, as expected for a lowpass filter.  If the</span></div>
<div class="line"><span class="lineno"> 3572</span><span class="stringliteral">    `zi` argument of `lfilter` had not been given, the output would have</span></div>
<div class="line"><span class="lineno"> 3573</span><span class="stringliteral">    shown the transient signal.</span></div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3575</span><span class="stringliteral">    &gt;&gt;&gt; from numpy import array, ones</span></div>
<div class="line"><span class="lineno"> 3576</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import lfilter, lfilter_zi, butter</span></div>
<div class="line"><span class="lineno"> 3577</span><span class="stringliteral">    &gt;&gt;&gt; b, a = butter(5, 0.25)</span></div>
<div class="line"><span class="lineno"> 3578</span><span class="stringliteral">    &gt;&gt;&gt; zi = lfilter_zi(b, a)</span></div>
<div class="line"><span class="lineno"> 3579</span><span class="stringliteral">    &gt;&gt;&gt; y, zo = lfilter(b, a, ones(10), zi=zi)</span></div>
<div class="line"><span class="lineno"> 3580</span><span class="stringliteral">    &gt;&gt;&gt; y</span></div>
<div class="line"><span class="lineno"> 3581</span><span class="stringliteral">    array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])</span></div>
<div class="line"><span class="lineno"> 3582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3583</span><span class="stringliteral">    Another example:</span></div>
<div class="line"><span class="lineno"> 3584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3585</span><span class="stringliteral">    &gt;&gt;&gt; x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])</span></div>
<div class="line"><span class="lineno"> 3586</span><span class="stringliteral">    &gt;&gt;&gt; y, zf = lfilter(b, a, x, zi=zi*x[0])</span></div>
<div class="line"><span class="lineno"> 3587</span><span class="stringliteral">    &gt;&gt;&gt; y</span></div>
<div class="line"><span class="lineno"> 3588</span><span class="stringliteral">    array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,</span></div>
<div class="line"><span class="lineno"> 3589</span><span class="stringliteral">        0.44399389,  0.35505241])</span></div>
<div class="line"><span class="lineno"> 3590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3591</span><span class="stringliteral">    Note that the `zi` argument to `lfilter` was computed using</span></div>
<div class="line"><span class="lineno"> 3592</span><span class="stringliteral">    `lfilter_zi` and scaled by `x[0]`.  Then the output `y` has no</span></div>
<div class="line"><span class="lineno"> 3593</span><span class="stringliteral">    transient until the input drops from 0.5 to 0.0.</span></div>
<div class="line"><span class="lineno"> 3594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3595</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3596</span> </div>
<div class="line"><span class="lineno"> 3597</span>    <span class="comment"># FIXME: Can this function be replaced with an appropriate</span></div>
<div class="line"><span class="lineno"> 3598</span>    <span class="comment"># use of lfiltic?  For example, when b,a = butter(N,Wn),</span></div>
<div class="line"><span class="lineno"> 3599</span>    <span class="comment">#    lfiltic(b, a, y=numpy.ones_like(a), x=numpy.ones_like(b)).</span></div>
<div class="line"><span class="lineno"> 3600</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3601</span> </div>
<div class="line"><span class="lineno"> 3602</span>    <span class="comment"># We could use scipy.signal.normalize, but it uses warnings in</span></div>
<div class="line"><span class="lineno"> 3603</span>    <span class="comment"># cases where a ValueError is more appropriate, and it allows</span></div>
<div class="line"><span class="lineno"> 3604</span>    <span class="comment"># b to be 2D.</span></div>
<div class="line"><span class="lineno"> 3605</span>    b = np.atleast_1d(b)</div>
<div class="line"><span class="lineno"> 3606</span>    <span class="keywordflow">if</span> b.ndim != 1:</div>
<div class="line"><span class="lineno"> 3607</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Numerator b must be 1-D.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3608</span>    a = np.atleast_1d(a)</div>
<div class="line"><span class="lineno"> 3609</span>    <span class="keywordflow">if</span> a.ndim != 1:</div>
<div class="line"><span class="lineno"> 3610</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Denominator a must be 1-D.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3611</span> </div>
<div class="line"><span class="lineno"> 3612</span>    <span class="keywordflow">while</span> len(a) &gt; 1 <span class="keywordflow">and</span> a[0] == 0.0:</div>
<div class="line"><span class="lineno"> 3613</span>        a = a[1:]</div>
<div class="line"><span class="lineno"> 3614</span>    <span class="keywordflow">if</span> a.size &lt; 1:</div>
<div class="line"><span class="lineno"> 3615</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;There must be at least one nonzero `a` coefficient.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3616</span> </div>
<div class="line"><span class="lineno"> 3617</span>    <span class="keywordflow">if</span> a[0] != 1.0:</div>
<div class="line"><span class="lineno"> 3618</span>        <span class="comment"># Normalize the coefficients so a[0] == 1.</span></div>
<div class="line"><span class="lineno"> 3619</span>        b = b / a[0]</div>
<div class="line"><span class="lineno"> 3620</span>        a = a / a[0]</div>
<div class="line"><span class="lineno"> 3621</span> </div>
<div class="line"><span class="lineno"> 3622</span>    n = max(len(a), len(b))</div>
<div class="line"><span class="lineno"> 3623</span> </div>
<div class="line"><span class="lineno"> 3624</span>    <span class="comment"># Pad a or b with zeros so they are the same length.</span></div>
<div class="line"><span class="lineno"> 3625</span>    <span class="keywordflow">if</span> len(a) &lt; n:</div>
<div class="line"><span class="lineno"> 3626</span>        a = np.r_[a, np.zeros(n - len(a), dtype=a.dtype)]</div>
<div class="line"><span class="lineno"> 3627</span>    <span class="keywordflow">elif</span> len(b) &lt; n:</div>
<div class="line"><span class="lineno"> 3628</span>        b = np.r_[b, np.zeros(n - len(b), dtype=b.dtype)]</div>
<div class="line"><span class="lineno"> 3629</span> </div>
<div class="line"><span class="lineno"> 3630</span>    IminusA = np.eye(n - 1, dtype=np.result_type(a, b)) - linalg.companion(a).T</div>
<div class="line"><span class="lineno"> 3631</span>    B = b[1:] - a[1:] * b[0]</div>
<div class="line"><span class="lineno"> 3632</span>    <span class="comment"># Solve zi = A*zi + B</span></div>
<div class="line"><span class="lineno"> 3633</span>    zi = np.linalg.solve(IminusA, B)</div>
<div class="line"><span class="lineno"> 3634</span> </div>
<div class="line"><span class="lineno"> 3635</span>    <span class="comment"># For future reference: we could also use the following</span></div>
<div class="line"><span class="lineno"> 3636</span>    <span class="comment"># explicit formulas to solve the linear system:</span></div>
<div class="line"><span class="lineno"> 3637</span>    <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 3638</span>    <span class="comment"># zi = np.zeros(n - 1)</span></div>
<div class="line"><span class="lineno"> 3639</span>    <span class="comment"># zi[0] = B.sum() / IminusA[:,0].sum()</span></div>
<div class="line"><span class="lineno"> 3640</span>    <span class="comment"># asum = 1.0</span></div>
<div class="line"><span class="lineno"> 3641</span>    <span class="comment"># csum = 0.0</span></div>
<div class="line"><span class="lineno"> 3642</span>    <span class="comment"># for k in range(1,n-1):</span></div>
<div class="line"><span class="lineno"> 3643</span>    <span class="comment">#     asum += a[k]</span></div>
<div class="line"><span class="lineno"> 3644</span>    <span class="comment">#     csum += b[k] - a[k]*b[0]</span></div>
<div class="line"><span class="lineno"> 3645</span>    <span class="comment">#     zi[k] = asum*zi[0] - csum</span></div>
<div class="line"><span class="lineno"> 3646</span> </div>
<div class="line"><span class="lineno"> 3647</span>    <span class="keywordflow">return</span> zi</div>
<div class="line"><span class="lineno"> 3648</span> </div>
<div class="line"><span class="lineno"> 3649</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a171d5cc1c314b8ae733afdbafc3b73b1" name="a171d5cc1c314b8ae733afdbafc3b73b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171d5cc1c314b8ae733afdbafc3b73b1">&#9670;&#160;</a></span>lfiltic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.lfiltic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct initial conditions for lfilter given input and output vectors.

Given a linear filter (b, a) and initial conditions on the output `y`
and the input `x`, return the initial conditions on the state vector zi
which is used by `lfilter` to generate the output given the input.

Parameters
----------
b : array_like
    Linear filter term.
a : array_like
    Linear filter term.
y : array_like
    Initial conditions.

    If ``N = len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``.

    If `y` is too short, it is padded with zeros.
x : array_like, optional
    Initial conditions.

    If ``M = len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``.

    If `x` is not given, its initial conditions are assumed zero.

    If `x` is too short, it is padded with zeros.

Returns
-------
zi : ndarray
    The state vector ``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``,
    where ``K = max(M, N)``.

See Also
--------
lfilter, lfilter_zi</pre> <div class="fragment"><div class="line"><span class="lineno"> 2074</span><span class="keyword">def </span>lfiltic(b, a, y, x=None):</div>
<div class="line"><span class="lineno"> 2075</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2076</span><span class="stringliteral">    Construct initial conditions for lfilter given input and output vectors.</span></div>
<div class="line"><span class="lineno"> 2077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2078</span><span class="stringliteral">    Given a linear filter (b, a) and initial conditions on the output `y`</span></div>
<div class="line"><span class="lineno"> 2079</span><span class="stringliteral">    and the input `x`, return the initial conditions on the state vector zi</span></div>
<div class="line"><span class="lineno"> 2080</span><span class="stringliteral">    which is used by `lfilter` to generate the output given the input.</span></div>
<div class="line"><span class="lineno"> 2081</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno"> 2085</span><span class="stringliteral">        Linear filter term.</span></div>
<div class="line"><span class="lineno"> 2086</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2087</span><span class="stringliteral">        Linear filter term.</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral">        Initial conditions.</span></div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">        If ``N = len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``.</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">        If `y` is too short, it is padded with zeros.</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">    x : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral">        Initial conditions.</span></div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">        If ``M = len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``.</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">        If `x` is not given, its initial conditions are assumed zero.</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">        If `x` is too short, it is padded with zeros.</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">    zi : ndarray</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral">        The state vector ``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``,</span></div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">        where ``K = max(M, N)``.</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">    lfilter, lfilter_zi</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2114</span>    N = np.size(a) - 1</div>
<div class="line"><span class="lineno"> 2115</span>    M = np.size(b) - 1</div>
<div class="line"><span class="lineno"> 2116</span>    K = max(M, N)</div>
<div class="line"><span class="lineno"> 2117</span>    y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 2118</span> </div>
<div class="line"><span class="lineno"> 2119</span>    <span class="keywordflow">if</span> x <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2120</span>        result_type = np.result_type(np.asarray(b), np.asarray(a), y)</div>
<div class="line"><span class="lineno"> 2121</span>        <span class="keywordflow">if</span> result_type.kind <span class="keywordflow">in</span> <span class="stringliteral">&#39;bui&#39;</span>:</div>
<div class="line"><span class="lineno"> 2122</span>            result_type = np.float64</div>
<div class="line"><span class="lineno"> 2123</span>        x = np.zeros(M, dtype=result_type)</div>
<div class="line"><span class="lineno"> 2124</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2125</span>        x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 2126</span> </div>
<div class="line"><span class="lineno"> 2127</span>        result_type = np.result_type(np.asarray(b), np.asarray(a), y, x)</div>
<div class="line"><span class="lineno"> 2128</span>        <span class="keywordflow">if</span> result_type.kind <span class="keywordflow">in</span> <span class="stringliteral">&#39;bui&#39;</span>:</div>
<div class="line"><span class="lineno"> 2129</span>            result_type = np.float64</div>
<div class="line"><span class="lineno"> 2130</span>        x = x.astype(result_type)</div>
<div class="line"><span class="lineno"> 2131</span> </div>
<div class="line"><span class="lineno"> 2132</span>        L = np.size(x)</div>
<div class="line"><span class="lineno"> 2133</span>        <span class="keywordflow">if</span> L &lt; M:</div>
<div class="line"><span class="lineno"> 2134</span>            x = np.r_[x, np.zeros(M - L)]</div>
<div class="line"><span class="lineno"> 2135</span> </div>
<div class="line"><span class="lineno"> 2136</span>    y = y.astype(result_type)</div>
<div class="line"><span class="lineno"> 2137</span>    zi = np.zeros(K, result_type)</div>
<div class="line"><span class="lineno"> 2138</span> </div>
<div class="line"><span class="lineno"> 2139</span>    L = np.size(y)</div>
<div class="line"><span class="lineno"> 2140</span>    <span class="keywordflow">if</span> L &lt; N:</div>
<div class="line"><span class="lineno"> 2141</span>        y = np.r_[y, np.zeros(N - L)]</div>
<div class="line"><span class="lineno"> 2142</span> </div>
<div class="line"><span class="lineno"> 2143</span>    <span class="keywordflow">for</span> m <span class="keywordflow">in</span> range(M):</div>
<div class="line"><span class="lineno"> 2144</span>        zi[m] = np.sum(b[m + 1:] * x[:M - m], axis=0)</div>
<div class="line"><span class="lineno"> 2145</span> </div>
<div class="line"><span class="lineno"> 2146</span>    <span class="keywordflow">for</span> m <span class="keywordflow">in</span> range(N):</div>
<div class="line"><span class="lineno"> 2147</span>        zi[m] -= np.sum(a[m + 1:] * y[:N - m], axis=0)</div>
<div class="line"><span class="lineno"> 2148</span> </div>
<div class="line"><span class="lineno"> 2149</span>    <span class="keywordflow">return</span> zi</div>
<div class="line"><span class="lineno"> 2150</span> </div>
<div class="line"><span class="lineno"> 2151</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ca78832b1bb44de7b1128139b51c600" name="a3ca78832b1bb44de7b1128139b51c600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca78832b1bb44de7b1128139b51c600">&#9670;&#160;</a></span>medfilt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.medfilt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kernel_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a median filter on an N-dimensional array.

Apply a median filter to the input array using a local window-size
given by `kernel_size`. The array will automatically be zero-padded.

Parameters
----------
volume : array_like
    An N-dimensional input array.
kernel_size : array_like, optional
    A scalar or an N-length list giving the size of the median filter
    window in each dimension.  Elements of `kernel_size` should be odd.
    If `kernel_size` is a scalar, then this scalar is used as the size in
    each dimension. Default size is 3 for each dimension.

Returns
-------
out : ndarray
    An array the same size as input containing the median filtered
    result.

Warns
-----
UserWarning
    If array size is smaller than kernel size along any dimension

See Also
--------
scipy.ndimage.median_filter
scipy.signal.medfilt2d

Notes
-----
The more general function `scipy.ndimage.median_filter` has a more
efficient implementation of a median filter and therefore runs much faster.

For 2-dimensional images with ``uint8``, ``float32`` or ``float64`` dtypes,
the specialised function `scipy.signal.medfilt2d` may be faster.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1492</span><span class="keyword">def </span>medfilt(volume, kernel_size=None):</div>
<div class="line"><span class="lineno"> 1493</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">    Perform a median filter on an N-dimensional array.</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">    Apply a median filter to the input array using a local window-size</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    given by `kernel_size`. The array will automatically be zero-padded.</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">    volume : array_like</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">        An N-dimensional input array.</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    kernel_size : array_like, optional</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">        A scalar or an N-length list giving the size of the median filter</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">        window in each dimension.  Elements of `kernel_size` should be odd.</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">        If `kernel_size` is a scalar, then this scalar is used as the size in</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">        each dimension. Default size is 3 for each dimension.</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        An array the same size as input containing the median filtered</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">        result.</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    UserWarning</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">        If array size is smaller than kernel size along any dimension</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    scipy.ndimage.median_filter</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">    scipy.signal.medfilt2d</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">    The more general function `scipy.ndimage.median_filter` has a more</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    efficient implementation of a median filter and therefore runs much faster.</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    For 2-dimensional images with ``uint8``, ``float32`` or ``float64`` dtypes,</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    the specialised function `scipy.signal.medfilt2d` may be faster.</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1534</span>    volume = np.atleast_1d(volume)</div>
<div class="line"><span class="lineno"> 1535</span>    <span class="keywordflow">if</span> kernel_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1536</span>        kernel_size = [3] * volume.ndim</div>
<div class="line"><span class="lineno"> 1537</span>    kernel_size = np.asarray(kernel_size)</div>
<div class="line"><span class="lineno"> 1538</span>    <span class="keywordflow">if</span> kernel_size.shape == ():</div>
<div class="line"><span class="lineno"> 1539</span>        kernel_size = np.repeat(kernel_size.item(), volume.ndim)</div>
<div class="line"><span class="lineno"> 1540</span> </div>
<div class="line"><span class="lineno"> 1541</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(volume.ndim):</div>
<div class="line"><span class="lineno"> 1542</span>        <span class="keywordflow">if</span> (kernel_size[k] % 2) != 1:</div>
<div class="line"><span class="lineno"> 1543</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Each element of kernel_size should be odd.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1544</span>    <span class="keywordflow">if</span> any(k &gt; s <span class="keywordflow">for</span> k, s <span class="keywordflow">in</span> zip(kernel_size, volume.shape)):</div>
<div class="line"><span class="lineno"> 1545</span>        warnings.warn(<span class="stringliteral">&#39;kernel_size exceeds volume extent: the volume will be &#39;</span></div>
<div class="line"><span class="lineno"> 1546</span>                      <span class="stringliteral">&#39;zero-padded.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1547</span> </div>
<div class="line"><span class="lineno"> 1548</span>    domain = np.ones(kernel_size, dtype=volume.dtype)</div>
<div class="line"><span class="lineno"> 1549</span> </div>
<div class="line"><span class="lineno"> 1550</span>    numels = np.prod(kernel_size, axis=0)</div>
<div class="line"><span class="lineno"> 1551</span>    order = numels // 2</div>
<div class="line"><span class="lineno"> 1552</span>    <span class="keywordflow">return</span> _sigtools._order_filterND(volume, domain, order)</div>
<div class="line"><span class="lineno"> 1553</span> </div>
<div class="line"><span class="lineno"> 1554</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abe423fd48568605c095ae8bec922a11c" name="abe423fd48568605c095ae8bec922a11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe423fd48568605c095ae8bec922a11c">&#9670;&#160;</a></span>medfilt2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.medfilt2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kernel_size</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Median filter a 2-dimensional array.

Apply a median filter to the `input` array using a local window-size
given by `kernel_size` (must be odd). The array is zero-padded
automatically.

Parameters
----------
input : array_like
    A 2-dimensional input array.
kernel_size : array_like, optional
    A scalar or a list of length 2, giving the size of the
    median filter window in each dimension.  Elements of
    `kernel_size` should be odd.  If `kernel_size` is a scalar,
    then this scalar is used as the size in each dimension.
    Default is a kernel of size (3, 3).

Returns
-------
out : ndarray
    An array the same size as input containing the median filtered
    result.

See also
--------
scipy.ndimage.median_filter

Notes
-----
This is faster than `medfilt` when the input dtype is ``uint8``,
``float32``, or ``float64``; for other types, this falls back to
`medfilt`; you should use `scipy.ndimage.median_filter` instead as it is
much faster.  In some situations, `scipy.ndimage.median_filter` may be
faster than this function.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1822</span><span class="keyword">def </span>medfilt2d(input, kernel_size=3):</div>
<div class="line"><span class="lineno"> 1823</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral">    Median filter a 2-dimensional array.</span></div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    Apply a median filter to the `input` array using a local window-size</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    given by `kernel_size` (must be odd). The array is zero-padded</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    automatically.</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">    input : array_like</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">        A 2-dimensional input array.</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    kernel_size : array_like, optional</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">        A scalar or a list of length 2, giving the size of the</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">        median filter window in each dimension.  Elements of</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">        `kernel_size` should be odd.  If `kernel_size` is a scalar,</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">        then this scalar is used as the size in each dimension.</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">        Default is a kernel of size (3, 3).</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">        An array the same size as input containing the median filtered</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">        result.</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    scipy.ndimage.median_filter</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    This is faster than `medfilt` when the input dtype is ``uint8``,</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    ``float32``, or ``float64``; for other types, this falls back to</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    `medfilt`; you should use `scipy.ndimage.median_filter` instead as it is</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    much faster.  In some situations, `scipy.ndimage.median_filter` may be</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    faster than this function.</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1860</span>    image = np.asarray(input)</div>
<div class="line"><span class="lineno"> 1861</span> </div>
<div class="line"><span class="lineno"> 1862</span>    <span class="comment"># checking dtype.type, rather than just dtype, is necessary for</span></div>
<div class="line"><span class="lineno"> 1863</span>    <span class="comment"># excluding np.longdouble with MS Visual C.</span></div>
<div class="line"><span class="lineno"> 1864</span>    <span class="keywordflow">if</span> image.dtype.type <span class="keywordflow">not</span> <span class="keywordflow">in</span> (np.ubyte, np.single, np.double):</div>
<div class="line"><span class="lineno"> 1865</span>        <span class="keywordflow">return</span> medfilt(image, kernel_size)</div>
<div class="line"><span class="lineno"> 1866</span> </div>
<div class="line"><span class="lineno"> 1867</span>    <span class="keywordflow">if</span> kernel_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1868</span>        kernel_size = [3] * 2</div>
<div class="line"><span class="lineno"> 1869</span>    kernel_size = np.asarray(kernel_size)</div>
<div class="line"><span class="lineno"> 1870</span>    <span class="keywordflow">if</span> kernel_size.shape == ():</div>
<div class="line"><span class="lineno"> 1871</span>        kernel_size = np.repeat(kernel_size.item(), 2)</div>
<div class="line"><span class="lineno"> 1872</span> </div>
<div class="line"><span class="lineno"> 1873</span>    <span class="keywordflow">for</span> size <span class="keywordflow">in</span> kernel_size:</div>
<div class="line"><span class="lineno"> 1874</span>        <span class="keywordflow">if</span> (size % 2) != 1:</div>
<div class="line"><span class="lineno"> 1875</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Each element of kernel_size should be odd.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1876</span> </div>
<div class="line"><span class="lineno"> 1877</span>    <span class="keywordflow">return</span> _sigtools._medfilt2d(image, kernel_size)</div>
<div class="line"><span class="lineno"> 1878</span> </div>
<div class="line"><span class="lineno"> 1879</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d1fb2e0af80cc502a8e8b140ca459e0" name="a3d1fb2e0af80cc502a8e8b140ca459e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1fb2e0af80cc502a8e8b140ca459e0">&#9670;&#160;</a></span>oaconvolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.oaconvolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;full&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convolve two N-dimensional arrays using the overlap-add method.

Convolve `in1` and `in2` using the overlap-add method, with
the output size determined by the `mode` argument.

This is generally much faster than `convolve` for large arrays (n &gt; ~500),
and generally much faster than `fftconvolve` when one array is much
larger than the other, but can be slower when only a few output values are
needed or when the arrays are very similar in shape, and can only
output float arrays (int or object array inputs will be cast to float).

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding. In 'valid' mode, either `in1` or `in2`
       must be at least as large as the other in every dimension.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.
axes : int or array_like of ints or None, optional
    Axes over which to compute the convolution.
    The default is over all axes.

Returns
-------
out : array
    An N-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.

See Also
--------
convolve : Uses the direct convolution or FFT convolution algorithm
           depending on which is faster.
fftconvolve : An implementation of convolution using FFT.

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Convolve a 100,000 sample signal with a 512-sample filter.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; sig = rng.standard_normal(100000)
&gt;&gt;&gt; filt = signal.firwin(512, 0.01)
&gt;&gt;&gt; fsig = signal.oaconvolve(sig, filt)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.set_title('White noise')
&gt;&gt;&gt; ax_mag.plot(fsig)
&gt;&gt;&gt; ax_mag.set_title('Filtered noise')
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; fig.show()

References
----------
.. [1] Wikipedia, "Overlap-add_method".
       https://en.wikipedia.org/wiki/Overlap-add_method
.. [2] Richard G. Lyons. Understanding Digital Signal Processing,
       Third Edition, 2011. Chapter 13.10.
       ISBN 13: 978-0137-02741-5</pre> <div class="fragment"><div class="line"><span class="lineno">  783</span><span class="keyword">def </span>oaconvolve(in1, in2, mode=&quot;full&quot;, axes=None):</div>
<div class="line"><span class="lineno">  784</span>    <span class="stringliteral">&quot;&quot;&quot;Convolve two N-dimensional arrays using the overlap-add method.</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    Convolve `in1` and `in2` using the overlap-add method, with</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    the output size determined by the `mode` argument.</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    This is generally much faster than `convolve` for large arrays (n &gt; ~500),</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    and generally much faster than `fftconvolve` when one array is much</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    larger than the other, but can be slower when only a few output values are</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    needed or when the arrays are very similar in shape, and can only</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    output float arrays (int or object array inputs will be cast to float).</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    in1 : array_like</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        First input.</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    in2 : array_like</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">        Second input. Should have the same number of dimensions as `in1`.</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">        A string indicating the size of the output:</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        ``full``</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">           The output is the full discrete linear convolution</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">           of the inputs. (Default)</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        ``valid``</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">           The output consists only of those elements that do not</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">           must be at least as large as the other in every dimension.</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        ``same``</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">           The output is the same size as `in1`, centered</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">           with respect to the &#39;full&#39; output.</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    axes : int or array_like of ints or None, optional</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">        Axes over which to compute the convolution.</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">        The default is over all axes.</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    out : array</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        An N-dimensional array containing a subset of the discrete linear</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        convolution of `in1` with `in2`.</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    convolve : Uses the direct convolution or FFT convolution algorithm</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">               depending on which is faster.</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    fftconvolve : An implementation of convolution using FFT.</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    Convolve a 100,000 sample signal with a 512-sample filter.</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    &gt;&gt;&gt; sig = rng.standard_normal(100000)</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    &gt;&gt;&gt; filt = signal.firwin(512, 0.01)</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    &gt;&gt;&gt; fsig = signal.oaconvolve(sig, filt)</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    &gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.plot(sig)</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    &gt;&gt;&gt; ax_orig.set_title(&#39;White noise&#39;)</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    &gt;&gt;&gt; ax_mag.plot(fsig)</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    &gt;&gt;&gt; ax_mag.set_title(&#39;Filtered noise&#39;)</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    &gt;&gt;&gt; fig.tight_layout()</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    &gt;&gt;&gt; fig.show()</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    .. [1] Wikipedia, &quot;Overlap-add_method&quot;.</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Overlap-add_method</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    .. [2] Richard G. Lyons. Understanding Digital Signal Processing,</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">           Third Edition, 2011. Chapter 13.10.</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">           ISBN 13: 978-0137-02741-5</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  862</span>    in1 = np.asarray(in1)</div>
<div class="line"><span class="lineno">  863</span>    in2 = np.asarray(in2)</div>
<div class="line"><span class="lineno">  864</span> </div>
<div class="line"><span class="lineno">  865</span>    <span class="keywordflow">if</span> in1.ndim == in2.ndim == 0:  <span class="comment"># scalar inputs</span></div>
<div class="line"><span class="lineno">  866</span>        <span class="keywordflow">return</span> in1 * in2</div>
<div class="line"><span class="lineno">  867</span>    <span class="keywordflow">elif</span> in1.ndim != in2.ndim:</div>
<div class="line"><span class="lineno">  868</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;in1 and in2 should have the same dimensionality&quot;</span>)</div>
<div class="line"><span class="lineno">  869</span>    <span class="keywordflow">elif</span> in1.size == 0 <span class="keywordflow">or</span> in2.size == 0:  <span class="comment"># empty arrays</span></div>
<div class="line"><span class="lineno">  870</span>        <span class="keywordflow">return</span> np.array([])</div>
<div class="line"><span class="lineno">  871</span>    <span class="keywordflow">elif</span> in1.shape == in2.shape:  <span class="comment"># Equivalent to fftconvolve</span></div>
<div class="line"><span class="lineno">  872</span>        <span class="keywordflow">return</span> fftconvolve(in1, in2, mode=mode, axes=axes)</div>
<div class="line"><span class="lineno">  873</span> </div>
<div class="line"><span class="lineno">  874</span>    in1, in2, axes = _init_freq_conv_axes(in1, in2, mode, axes,</div>
<div class="line"><span class="lineno">  875</span>                                          sorted_axes=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span>    s1 = in1.shape</div>
<div class="line"><span class="lineno">  878</span>    s2 = in2.shape</div>
<div class="line"><span class="lineno">  879</span> </div>
<div class="line"><span class="lineno">  880</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> axes:</div>
<div class="line"><span class="lineno">  881</span>        ret = in1 * in2</div>
<div class="line"><span class="lineno">  882</span>        <span class="keywordflow">return</span> _apply_conv_mode(ret, s1, s2, mode, axes)</div>
<div class="line"><span class="lineno">  883</span> </div>
<div class="line"><span class="lineno">  884</span>    <span class="comment"># Calculate this now since in1 is changed later</span></div>
<div class="line"><span class="lineno">  885</span>    shape_final = [<span class="keywordtype">None</span> <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> axes <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  886</span>                   s1[i] + s2[i] - 1 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(in1.ndim)]</div>
<div class="line"><span class="lineno">  887</span> </div>
<div class="line"><span class="lineno">  888</span>    <span class="comment"># Calculate the block sizes for the output, steps, first and second inputs.</span></div>
<div class="line"><span class="lineno">  889</span>    <span class="comment"># It is simpler to calculate them all together than doing them in separate</span></div>
<div class="line"><span class="lineno">  890</span>    <span class="comment"># loops due to all the special cases that need to be handled.</span></div>
<div class="line"><span class="lineno">  891</span>    optimal_sizes = ((-1, -1, s1[i], s2[i]) <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> axes <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  892</span>                     _calc_oa_lens(s1[i], s2[i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(in1.ndim))</div>
<div class="line"><span class="lineno">  893</span>    block_size, overlaps, \</div>
<div class="line"><span class="lineno">  894</span>        in1_step, in2_step = zip(*optimal_sizes)</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span>    <span class="comment"># Fall back to fftconvolve if there is only one block in every dimension.</span></div>
<div class="line"><span class="lineno">  897</span>    <span class="keywordflow">if</span> in1_step == s1 <span class="keywordflow">and</span> in2_step == s2:</div>
<div class="line"><span class="lineno">  898</span>        <span class="keywordflow">return</span> fftconvolve(in1, in2, mode=mode, axes=axes)</div>
<div class="line"><span class="lineno">  899</span> </div>
<div class="line"><span class="lineno">  900</span>    <span class="comment"># Figure out the number of steps and padding.</span></div>
<div class="line"><span class="lineno">  901</span>    <span class="comment"># This would get too complicated in a list comprehension.</span></div>
<div class="line"><span class="lineno">  902</span>    nsteps1 = []</div>
<div class="line"><span class="lineno">  903</span>    nsteps2 = []</div>
<div class="line"><span class="lineno">  904</span>    pad_size1 = []</div>
<div class="line"><span class="lineno">  905</span>    pad_size2 = []</div>
<div class="line"><span class="lineno">  906</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(in1.ndim):</div>
<div class="line"><span class="lineno">  907</span>        <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> axes:</div>
<div class="line"><span class="lineno">  908</span>            pad_size1 += [(0, 0)]</div>
<div class="line"><span class="lineno">  909</span>            pad_size2 += [(0, 0)]</div>
<div class="line"><span class="lineno">  910</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  911</span> </div>
<div class="line"><span class="lineno">  912</span>        <span class="keywordflow">if</span> s1[i] &gt; in1_step[i]:</div>
<div class="line"><span class="lineno">  913</span>            curnstep1 = math.ceil((s1[i]+1)/in1_step[i])</div>
<div class="line"><span class="lineno">  914</span>            <span class="keywordflow">if</span> (block_size[i] - overlaps[i])*curnstep1 &lt; shape_final[i]:</div>
<div class="line"><span class="lineno">  915</span>                curnstep1 += 1</div>
<div class="line"><span class="lineno">  916</span> </div>
<div class="line"><span class="lineno">  917</span>            curpad1 = curnstep1*in1_step[i] - s1[i]</div>
<div class="line"><span class="lineno">  918</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  919</span>            curnstep1 = 1</div>
<div class="line"><span class="lineno">  920</span>            curpad1 = 0</div>
<div class="line"><span class="lineno">  921</span> </div>
<div class="line"><span class="lineno">  922</span>        <span class="keywordflow">if</span> s2[i] &gt; in2_step[i]:</div>
<div class="line"><span class="lineno">  923</span>            curnstep2 = math.ceil((s2[i]+1)/in2_step[i])</div>
<div class="line"><span class="lineno">  924</span>            <span class="keywordflow">if</span> (block_size[i] - overlaps[i])*curnstep2 &lt; shape_final[i]:</div>
<div class="line"><span class="lineno">  925</span>                curnstep2 += 1</div>
<div class="line"><span class="lineno">  926</span> </div>
<div class="line"><span class="lineno">  927</span>            curpad2 = curnstep2*in2_step[i] - s2[i]</div>
<div class="line"><span class="lineno">  928</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  929</span>            curnstep2 = 1</div>
<div class="line"><span class="lineno">  930</span>            curpad2 = 0</div>
<div class="line"><span class="lineno">  931</span> </div>
<div class="line"><span class="lineno">  932</span>        nsteps1 += [curnstep1]</div>
<div class="line"><span class="lineno">  933</span>        nsteps2 += [curnstep2]</div>
<div class="line"><span class="lineno">  934</span>        pad_size1 += [(0, curpad1)]</div>
<div class="line"><span class="lineno">  935</span>        pad_size2 += [(0, curpad2)]</div>
<div class="line"><span class="lineno">  936</span> </div>
<div class="line"><span class="lineno">  937</span>    <span class="comment"># Pad the array to a size that can be reshaped to the desired shape</span></div>
<div class="line"><span class="lineno">  938</span>    <span class="comment"># if necessary.</span></div>
<div class="line"><span class="lineno">  939</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> all(curpad == (0, 0) <span class="keywordflow">for</span> curpad <span class="keywordflow">in</span> pad_size1):</div>
<div class="line"><span class="lineno">  940</span>        in1 = np.pad(in1, pad_size1, mode=<span class="stringliteral">&#39;constant&#39;</span>, constant_values=0)</div>
<div class="line"><span class="lineno">  941</span> </div>
<div class="line"><span class="lineno">  942</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> all(curpad == (0, 0) <span class="keywordflow">for</span> curpad <span class="keywordflow">in</span> pad_size2):</div>
<div class="line"><span class="lineno">  943</span>        in2 = np.pad(in2, pad_size2, mode=<span class="stringliteral">&#39;constant&#39;</span>, constant_values=0)</div>
<div class="line"><span class="lineno">  944</span> </div>
<div class="line"><span class="lineno">  945</span>    <span class="comment"># Reshape the overlap-add parts to input block sizes.</span></div>
<div class="line"><span class="lineno">  946</span>    split_axes = [iax+i <span class="keywordflow">for</span> i, iax <span class="keywordflow">in</span> enumerate(axes)]</div>
<div class="line"><span class="lineno">  947</span>    fft_axes = [iax+1 <span class="keywordflow">for</span> iax <span class="keywordflow">in</span> split_axes]</div>
<div class="line"><span class="lineno">  948</span> </div>
<div class="line"><span class="lineno">  949</span>    <span class="comment"># We need to put each new dimension before the corresponding dimension</span></div>
<div class="line"><span class="lineno">  950</span>    <span class="comment"># being reshaped in order to get the data in the right layout at the end.</span></div>
<div class="line"><span class="lineno">  951</span>    reshape_size1 = list(in1_step)</div>
<div class="line"><span class="lineno">  952</span>    reshape_size2 = list(in2_step)</div>
<div class="line"><span class="lineno">  953</span>    <span class="keywordflow">for</span> i, iax <span class="keywordflow">in</span> enumerate(split_axes):</div>
<div class="line"><span class="lineno">  954</span>        reshape_size1.insert(iax, nsteps1[i])</div>
<div class="line"><span class="lineno">  955</span>        reshape_size2.insert(iax, nsteps2[i])</div>
<div class="line"><span class="lineno">  956</span> </div>
<div class="line"><span class="lineno">  957</span>    in1 = in1.reshape(*reshape_size1)</div>
<div class="line"><span class="lineno">  958</span>    in2 = in2.reshape(*reshape_size2)</div>
<div class="line"><span class="lineno">  959</span> </div>
<div class="line"><span class="lineno">  960</span>    <span class="comment"># Do the convolution.</span></div>
<div class="line"><span class="lineno">  961</span>    fft_shape = [block_size[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> axes]</div>
<div class="line"><span class="lineno">  962</span>    ret = _freq_domain_conv(in1, in2, fft_axes, fft_shape, calc_fast_len=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  963</span> </div>
<div class="line"><span class="lineno">  964</span>    <span class="comment"># Do the overlap-add.</span></div>
<div class="line"><span class="lineno">  965</span>    <span class="keywordflow">for</span> ax, ax_fft, ax_split <span class="keywordflow">in</span> zip(axes, fft_axes, split_axes):</div>
<div class="line"><span class="lineno">  966</span>        overlap = overlaps[ax]</div>
<div class="line"><span class="lineno">  967</span>        <span class="keywordflow">if</span> overlap <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  968</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  969</span> </div>
<div class="line"><span class="lineno">  970</span>        ret, overpart = np.split(ret, [-overlap], ax_fft)</div>
<div class="line"><span class="lineno">  971</span>        overpart = np.split(overpart, [-1], ax_split)[0]</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>        ret_overpart = np.split(ret, [overlap], ax_fft)[0]</div>
<div class="line"><span class="lineno">  974</span>        ret_overpart = np.split(ret_overpart, [1], ax_split)[1]</div>
<div class="line"><span class="lineno">  975</span>        ret_overpart += overpart</div>
<div class="line"><span class="lineno">  976</span> </div>
<div class="line"><span class="lineno">  977</span>    <span class="comment"># Reshape back to the correct dimensionality.</span></div>
<div class="line"><span class="lineno">  978</span>    shape_ret = [ret.shape[i] <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> fft_axes <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  979</span>                 ret.shape[i]*ret.shape[i-1]</div>
<div class="line"><span class="lineno">  980</span>                 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(ret.ndim) <span class="keywordflow">if</span> i <span class="keywordflow">not</span> <span class="keywordflow">in</span> split_axes]</div>
<div class="line"><span class="lineno">  981</span>    ret = ret.reshape(*shape_ret)</div>
<div class="line"><span class="lineno">  982</span> </div>
<div class="line"><span class="lineno">  983</span>    <span class="comment"># Slice to the correct size.</span></div>
<div class="line"><span class="lineno">  984</span>    slice_final = tuple([slice(islice) <span class="keywordflow">for</span> islice <span class="keywordflow">in</span> shape_final])</div>
<div class="line"><span class="lineno">  985</span>    ret = ret[slice_final]</div>
<div class="line"><span class="lineno">  986</span> </div>
<div class="line"><span class="lineno">  987</span>    <span class="keywordflow">return</span> _apply_conv_mode(ret, s1, s2, mode, axes)</div>
<div class="line"><span class="lineno">  988</span> </div>
<div class="line"><span class="lineno">  989</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a84afe356beb04c096364fde83c7d8620" name="a84afe356beb04c096364fde83c7d8620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84afe356beb04c096364fde83c7d8620">&#9670;&#160;</a></span>order_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.order_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform an order filter on an N-D array.

Perform an order filter on the array in. The domain argument acts as a
mask centered over each pixel. The non-zero elements of domain are
used to select elements surrounding each input pixel which are placed
in a list. The list is sorted, and the output for that pixel is the
element corresponding to rank in the sorted list.

Parameters
----------
a : ndarray
    The N-dimensional input array.
domain : array_like
    A mask array with the same number of dimensions as `a`.
    Each dimension should have an odd number of elements.
rank : int
    A non-negative integer which selects the element from the
    sorted list (0 corresponds to the smallest element, 1 is the
    next smallest element, etc.).

Returns
-------
out : ndarray
    The results of the order filter in an array with the same
    shape as `a`.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; x = np.arange(25).reshape(5, 5)
&gt;&gt;&gt; domain = np.identity(3)
&gt;&gt;&gt; x
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
&gt;&gt;&gt; signal.order_filter(x, domain, 0)
array([[  0.,   0.,   0.,   0.,   0.],
       [  0.,   0.,   1.,   2.,   0.],
       [  0.,   5.,   6.,   7.,   0.],
       [  0.,  10.,  11.,  12.,   0.],
       [  0.,   0.,   0.,   0.,   0.]])
&gt;&gt;&gt; signal.order_filter(x, domain, 2)
array([[  6.,   7.,   8.,   9.,   4.],
       [ 11.,  12.,  13.,  14.,   9.],
       [ 16.,  17.,  18.,  19.,  14.],
       [ 21.,  22.,  23.,  24.,  19.],
       [ 20.,  21.,  22.,  23.,  24.]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1431</span><span class="keyword">def </span>order_filter(a, domain, rank):</div>
<div class="line"><span class="lineno"> 1432</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">    Perform an order filter on an N-D array.</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    Perform an order filter on the array in. The domain argument acts as a</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">    mask centered over each pixel. The non-zero elements of domain are</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">    used to select elements surrounding each input pixel which are placed</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    in a list. The list is sorted, and the output for that pixel is the</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">    element corresponding to rank in the sorted list.</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">        The N-dimensional input array.</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    domain : array_like</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">        A mask array with the same number of dimensions as `a`.</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">        Each dimension should have an odd number of elements.</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">    rank : int</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral">        A non-negative integer which selects the element from the</span></div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">        sorted list (0 corresponds to the smallest element, 1 is the</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">        next smallest element, etc.).</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">        The results of the order filter in an array with the same</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">        shape as `a`.</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(25).reshape(5, 5)</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">    &gt;&gt;&gt; domain = np.identity(3)</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">    array([[ 0,  1,  2,  3,  4],</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">           [ 5,  6,  7,  8,  9],</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral">           [10, 11, 12, 13, 14],</span></div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">           [15, 16, 17, 18, 19],</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">           [20, 21, 22, 23, 24]])</span></div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">    &gt;&gt;&gt; signal.order_filter(x, domain, 0)</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">    array([[  0.,   0.,   0.,   0.,   0.],</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">           [  0.,   0.,   1.,   2.,   0.],</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">           [  0.,   5.,   6.,   7.,   0.],</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral">           [  0.,  10.,  11.,  12.,   0.],</span></div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">           [  0.,   0.,   0.,   0.,   0.]])</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">    &gt;&gt;&gt; signal.order_filter(x, domain, 2)</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral">    array([[  6.,   7.,   8.,   9.,   4.],</span></div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">           [ 11.,  12.,  13.,  14.,   9.],</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">           [ 16.,  17.,  18.,  19.,  14.],</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral">           [ 21.,  22.,  23.,  24.,  19.],</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">           [ 20.,  21.,  22.,  23.,  24.]])</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1484</span>    domain = np.asarray(domain)</div>
<div class="line"><span class="lineno"> 1485</span>    <span class="keywordflow">for</span> dimsize <span class="keywordflow">in</span> domain.shape:</div>
<div class="line"><span class="lineno"> 1486</span>        <span class="keywordflow">if</span> (dimsize % 2) != 1:</div>
<div class="line"><span class="lineno"> 1487</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Each dimension of domain argument &quot;</span></div>
<div class="line"><span class="lineno"> 1488</span>                             <span class="stringliteral">&quot;should have an odd number of elements.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1489</span>    <span class="keywordflow">return</span> _sigtools._order_filterND(a, domain, rank)</div>
<div class="line"><span class="lineno"> 1490</span> </div>
<div class="line"><span class="lineno"> 1491</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af3cf97912d53105ef880c3f6bdf44396" name="af3cf97912d53105ef880c3f6bdf44396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cf97912d53105ef880c3f6bdf44396">&#9670;&#160;</a></span>resample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>'time'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Resample `x` to `num` samples using Fourier method along the given axis.

The resampled signal starts at the same value as `x` but is sampled
with a spacing of ``len(x) / num * (spacing of x)``.  Because a
Fourier method is used, the signal is assumed to be periodic.

Parameters
----------
x : array_like
    The data to be resampled.
num : int
    The number of samples in the resampled signal.
t : array_like, optional
    If `t` is given, it is assumed to be the equally spaced sample
    positions associated with the signal data in `x`.
axis : int, optional
    The axis of `x` that is resampled.  Default is 0.
window : array_like, callable, string, float, or tuple, optional
    Specifies the window applied to the signal in the Fourier
    domain.  See below for details.
domain : string, optional
    A string indicating the domain of the input `x`:
    ``time`` Consider the input `x` as time-domain (Default),
    ``freq`` Consider the input `x` as frequency-domain.

Returns
-------
resampled_x or (resampled_x, resampled_t)
    Either the resampled array, or, if `t` was given, a tuple
    containing the resampled array and the corresponding resampled
    positions.

See Also
--------
decimate : Downsample the signal after applying an FIR or IIR filter.
resample_poly : Resample using polyphase filtering and an FIR filter.

Notes
-----
The argument `window` controls a Fourier-domain window that tapers
the Fourier spectrum before zero-padding to alleviate ringing in
the resampled values for sampled signals you didn't intend to be
interpreted as band-limited.

If `window` is a function, then it is called with a vector of inputs
indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).

If `window` is an array of the same length as `x.shape[axis]` it is
assumed to be the window to be applied directly in the Fourier
domain (with dc and low-frequency first).

For any other type of `window`, the function `scipy.signal.get_window`
is called to generate the window.

The first sample of the returned vector is the same as the first
sample of the input vector.  The spacing between samples is changed
from ``dx`` to ``dx * len(x) / num``.

If `t` is not None, then it is used solely to calculate the resampled
positions `resampled_t`

As noted, `resample` uses FFT transformations, which can be very
slow if the number of input or output samples is large and prime;
see `scipy.fft.fft`.

Examples
--------
Note that the end of the resampled data rises to meet the first
sample of the next cycle:

&gt;&gt;&gt; from scipy import signal

&gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)
&gt;&gt;&gt; y = np.cos(-x**2/6.0)
&gt;&gt;&gt; f = signal.resample(y, 100)
&gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x, y, 'go-', xnew, f, '.-', 10, y[0], 'ro')
&gt;&gt;&gt; plt.legend(['data', 'resampled'], loc='best')
&gt;&gt;&gt; plt.show()
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2951</span><span class="keyword">def </span>resample(x, num, t=None, axis=0, window=None, domain=&#39;time&#39;):</div>
<div class="line"><span class="lineno"> 2952</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2953</span><span class="stringliteral">    Resample `x` to `num` samples using Fourier method along the given axis.</span></div>
<div class="line"><span class="lineno"> 2954</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2955</span><span class="stringliteral">    The resampled signal starts at the same value as `x` but is sampled</span></div>
<div class="line"><span class="lineno"> 2956</span><span class="stringliteral">    with a spacing of ``len(x) / num * (spacing of x)``.  Because a</span></div>
<div class="line"><span class="lineno"> 2957</span><span class="stringliteral">    Fourier method is used, the signal is assumed to be periodic.</span></div>
<div class="line"><span class="lineno"> 2958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2959</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2960</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2961</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 2962</span><span class="stringliteral">        The data to be resampled.</span></div>
<div class="line"><span class="lineno"> 2963</span><span class="stringliteral">    num : int</span></div>
<div class="line"><span class="lineno"> 2964</span><span class="stringliteral">        The number of samples in the resampled signal.</span></div>
<div class="line"><span class="lineno"> 2965</span><span class="stringliteral">    t : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2966</span><span class="stringliteral">        If `t` is given, it is assumed to be the equally spaced sample</span></div>
<div class="line"><span class="lineno"> 2967</span><span class="stringliteral">        positions associated with the signal data in `x`.</span></div>
<div class="line"><span class="lineno"> 2968</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 2969</span><span class="stringliteral">        The axis of `x` that is resampled.  Default is 0.</span></div>
<div class="line"><span class="lineno"> 2970</span><span class="stringliteral">    window : array_like, callable, string, float, or tuple, optional</span></div>
<div class="line"><span class="lineno"> 2971</span><span class="stringliteral">        Specifies the window applied to the signal in the Fourier</span></div>
<div class="line"><span class="lineno"> 2972</span><span class="stringliteral">        domain.  See below for details.</span></div>
<div class="line"><span class="lineno"> 2973</span><span class="stringliteral">    domain : string, optional</span></div>
<div class="line"><span class="lineno"> 2974</span><span class="stringliteral">        A string indicating the domain of the input `x`:</span></div>
<div class="line"><span class="lineno"> 2975</span><span class="stringliteral">        ``time`` Consider the input `x` as time-domain (Default),</span></div>
<div class="line"><span class="lineno"> 2976</span><span class="stringliteral">        ``freq`` Consider the input `x` as frequency-domain.</span></div>
<div class="line"><span class="lineno"> 2977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2978</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2979</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2980</span><span class="stringliteral">    resampled_x or (resampled_x, resampled_t)</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral">        Either the resampled array, or, if `t` was given, a tuple</span></div>
<div class="line"><span class="lineno"> 2982</span><span class="stringliteral">        containing the resampled array and the corresponding resampled</span></div>
<div class="line"><span class="lineno"> 2983</span><span class="stringliteral">        positions.</span></div>
<div class="line"><span class="lineno"> 2984</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2985</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral">    decimate : Downsample the signal after applying an FIR or IIR filter.</span></div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral">    resample_poly : Resample using polyphase filtering and an FIR filter.</span></div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">    The argument `window` controls a Fourier-domain window that tapers</span></div>
<div class="line"><span class="lineno"> 2993</span><span class="stringliteral">    the Fourier spectrum before zero-padding to alleviate ringing in</span></div>
<div class="line"><span class="lineno"> 2994</span><span class="stringliteral">    the resampled values for sampled signals you didn&#39;t intend to be</span></div>
<div class="line"><span class="lineno"> 2995</span><span class="stringliteral">    interpreted as band-limited.</span></div>
<div class="line"><span class="lineno"> 2996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2997</span><span class="stringliteral">    If `window` is a function, then it is called with a vector of inputs</span></div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral">    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).</span></div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral">    If `window` is an array of the same length as `x.shape[axis]` it is</span></div>
<div class="line"><span class="lineno"> 3001</span><span class="stringliteral">    assumed to be the window to be applied directly in the Fourier</span></div>
<div class="line"><span class="lineno"> 3002</span><span class="stringliteral">    domain (with dc and low-frequency first).</span></div>
<div class="line"><span class="lineno"> 3003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3004</span><span class="stringliteral">    For any other type of `window`, the function `scipy.signal.get_window`</span></div>
<div class="line"><span class="lineno"> 3005</span><span class="stringliteral">    is called to generate the window.</span></div>
<div class="line"><span class="lineno"> 3006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3007</span><span class="stringliteral">    The first sample of the returned vector is the same as the first</span></div>
<div class="line"><span class="lineno"> 3008</span><span class="stringliteral">    sample of the input vector.  The spacing between samples is changed</span></div>
<div class="line"><span class="lineno"> 3009</span><span class="stringliteral">    from ``dx`` to ``dx * len(x) / num``.</span></div>
<div class="line"><span class="lineno"> 3010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3011</span><span class="stringliteral">    If `t` is not None, then it is used solely to calculate the resampled</span></div>
<div class="line"><span class="lineno"> 3012</span><span class="stringliteral">    positions `resampled_t`</span></div>
<div class="line"><span class="lineno"> 3013</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3014</span><span class="stringliteral">    As noted, `resample` uses FFT transformations, which can be very</span></div>
<div class="line"><span class="lineno"> 3015</span><span class="stringliteral">    slow if the number of input or output samples is large and prime;</span></div>
<div class="line"><span class="lineno"> 3016</span><span class="stringliteral">    see `scipy.fft.fft`.</span></div>
<div class="line"><span class="lineno"> 3017</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3018</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3019</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3020</span><span class="stringliteral">    Note that the end of the resampled data rises to meet the first</span></div>
<div class="line"><span class="lineno"> 3021</span><span class="stringliteral">    sample of the next cycle:</span></div>
<div class="line"><span class="lineno"> 3022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3023</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3024</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3025</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 3026</span><span class="stringliteral">    &gt;&gt;&gt; y = np.cos(-x**2/6.0)</span></div>
<div class="line"><span class="lineno"> 3027</span><span class="stringliteral">    &gt;&gt;&gt; f = signal.resample(y, 100)</span></div>
<div class="line"><span class="lineno"> 3028</span><span class="stringliteral">    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3031</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, y, &#39;go-&#39;, xnew, f, &#39;.-&#39;, 10, y[0], &#39;ro&#39;)</span></div>
<div class="line"><span class="lineno"> 3032</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend([&#39;data&#39;, &#39;resampled&#39;], loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 3033</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3034</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3035</span> </div>
<div class="line"><span class="lineno"> 3036</span>    <span class="keywordflow">if</span> domain <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;time&#39;</span>, <span class="stringliteral">&#39;freq&#39;</span>):</div>
<div class="line"><span class="lineno"> 3037</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Acceptable domain flags are &#39;time&#39; or&quot;</span></div>
<div class="line"><span class="lineno"> 3038</span>                         <span class="stringliteral">&quot; &#39;freq&#39;, not domain={}&quot;</span>.format(domain))</div>
<div class="line"><span class="lineno"> 3039</span> </div>
<div class="line"><span class="lineno"> 3040</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 3041</span>    Nx = x.shape[axis]</div>
<div class="line"><span class="lineno"> 3042</span> </div>
<div class="line"><span class="lineno"> 3043</span>    <span class="comment"># Check if we can use faster real FFT</span></div>
<div class="line"><span class="lineno"> 3044</span>    real_input = np.isrealobj(x)</div>
<div class="line"><span class="lineno"> 3045</span> </div>
<div class="line"><span class="lineno"> 3046</span>    <span class="keywordflow">if</span> domain == <span class="stringliteral">&#39;time&#39;</span>:</div>
<div class="line"><span class="lineno"> 3047</span>        <span class="comment"># Forward transform</span></div>
<div class="line"><span class="lineno"> 3048</span>        <span class="keywordflow">if</span> real_input:</div>
<div class="line"><span class="lineno"> 3049</span>            X = sp_fft.rfft(x, axis=axis)</div>
<div class="line"><span class="lineno"> 3050</span>        <span class="keywordflow">else</span>:  <span class="comment"># Full complex FFT</span></div>
<div class="line"><span class="lineno"> 3051</span>            X = sp_fft.fft(x, axis=axis)</div>
<div class="line"><span class="lineno"> 3052</span>    <span class="keywordflow">else</span>:  <span class="comment"># domain == &#39;freq&#39;</span></div>
<div class="line"><span class="lineno"> 3053</span>        X = x</div>
<div class="line"><span class="lineno"> 3054</span> </div>
<div class="line"><span class="lineno"> 3055</span>    <span class="comment"># Apply window to spectrum</span></div>
<div class="line"><span class="lineno"> 3056</span>    <span class="keywordflow">if</span> window <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3057</span>        <span class="keywordflow">if</span> callable(window):</div>
<div class="line"><span class="lineno"> 3058</span>            W = window(sp_fft.fftfreq(Nx))</div>
<div class="line"><span class="lineno"> 3059</span>        <span class="keywordflow">elif</span> isinstance(window, np.ndarray):</div>
<div class="line"><span class="lineno"> 3060</span>            <span class="keywordflow">if</span> window.shape != (Nx,):</div>
<div class="line"><span class="lineno"> 3061</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must have the same length as data&#39;</span>)</div>
<div class="line"><span class="lineno"> 3062</span>            W = window</div>
<div class="line"><span class="lineno"> 3063</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3064</span>            W = sp_fft.ifftshift(get_window(window, Nx))</div>
<div class="line"><span class="lineno"> 3065</span> </div>
<div class="line"><span class="lineno"> 3066</span>        newshape_W = [1] * x.ndim</div>
<div class="line"><span class="lineno"> 3067</span>        newshape_W[axis] = X.shape[axis]</div>
<div class="line"><span class="lineno"> 3068</span>        <span class="keywordflow">if</span> real_input:</div>
<div class="line"><span class="lineno"> 3069</span>            <span class="comment"># Fold the window back on itself to mimic complex behavior</span></div>
<div class="line"><span class="lineno"> 3070</span>            W_real = W.copy()</div>
<div class="line"><span class="lineno"> 3071</span>            W_real[1:] += W_real[-1:0:-1]</div>
<div class="line"><span class="lineno"> 3072</span>            W_real[1:] *= 0.5</div>
<div class="line"><span class="lineno"> 3073</span>            X *= W_real[:newshape_W[axis]].reshape(newshape_W)</div>
<div class="line"><span class="lineno"> 3074</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3075</span>            X *= W.reshape(newshape_W)</div>
<div class="line"><span class="lineno"> 3076</span> </div>
<div class="line"><span class="lineno"> 3077</span>    <span class="comment"># Copy each half of the original spectrum to the output spectrum, either</span></div>
<div class="line"><span class="lineno"> 3078</span>    <span class="comment"># truncating high frequences (downsampling) or zero-padding them</span></div>
<div class="line"><span class="lineno"> 3079</span>    <span class="comment"># (upsampling)</span></div>
<div class="line"><span class="lineno"> 3080</span> </div>
<div class="line"><span class="lineno"> 3081</span>    <span class="comment"># Placeholder array for output spectrum</span></div>
<div class="line"><span class="lineno"> 3082</span>    newshape = list(x.shape)</div>
<div class="line"><span class="lineno"> 3083</span>    <span class="keywordflow">if</span> real_input:</div>
<div class="line"><span class="lineno"> 3084</span>        newshape[axis] = num // 2 + 1</div>
<div class="line"><span class="lineno"> 3085</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3086</span>        newshape[axis] = num</div>
<div class="line"><span class="lineno"> 3087</span>    Y = np.zeros(newshape, X.dtype)</div>
<div class="line"><span class="lineno"> 3088</span> </div>
<div class="line"><span class="lineno"> 3089</span>    <span class="comment"># Copy positive frequency components (and Nyquist, if present)</span></div>
<div class="line"><span class="lineno"> 3090</span>    N = min(num, Nx)</div>
<div class="line"><span class="lineno"> 3091</span>    nyq = N // 2 + 1  <span class="comment"># Slice index that includes Nyquist if present</span></div>
<div class="line"><span class="lineno"> 3092</span>    sl = [slice(<span class="keywordtype">None</span>)] * x.ndim</div>
<div class="line"><span class="lineno"> 3093</span>    sl[axis] = slice(0, nyq)</div>
<div class="line"><span class="lineno"> 3094</span>    Y[tuple(sl)] = X[tuple(sl)]</div>
<div class="line"><span class="lineno"> 3095</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> real_input:</div>
<div class="line"><span class="lineno"> 3096</span>        <span class="comment"># Copy negative frequency components</span></div>
<div class="line"><span class="lineno"> 3097</span>        <span class="keywordflow">if</span> N &gt; 2:  <span class="comment"># (slice expression doesn&#39;t collapse to empty array)</span></div>
<div class="line"><span class="lineno"> 3098</span>            sl[axis] = slice(nyq - N, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 3099</span>            Y[tuple(sl)] = X[tuple(sl)]</div>
<div class="line"><span class="lineno"> 3100</span> </div>
<div class="line"><span class="lineno"> 3101</span>    <span class="comment"># Split/join Nyquist component(s) if present</span></div>
<div class="line"><span class="lineno"> 3102</span>    <span class="comment"># So far we have set Y[+N/2]=X[+N/2]</span></div>
<div class="line"><span class="lineno"> 3103</span>    <span class="keywordflow">if</span> N % 2 == 0:</div>
<div class="line"><span class="lineno"> 3104</span>        <span class="keywordflow">if</span> num &lt; Nx:  <span class="comment"># downsampling</span></div>
<div class="line"><span class="lineno"> 3105</span>            <span class="keywordflow">if</span> real_input:</div>
<div class="line"><span class="lineno"> 3106</span>                sl[axis] = slice(N//2, N//2 + 1)</div>
<div class="line"><span class="lineno"> 3107</span>                Y[tuple(sl)] *= 2.</div>
<div class="line"><span class="lineno"> 3108</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3109</span>                <span class="comment"># select the component of Y at frequency +N/2,</span></div>
<div class="line"><span class="lineno"> 3110</span>                <span class="comment"># add the component of X at -N/2</span></div>
<div class="line"><span class="lineno"> 3111</span>                sl[axis] = slice(-N//2, -N//2 + 1)</div>
<div class="line"><span class="lineno"> 3112</span>                Y[tuple(sl)] += X[tuple(sl)]</div>
<div class="line"><span class="lineno"> 3113</span>        <span class="keywordflow">elif</span> Nx &lt; num:  <span class="comment"># upsampling</span></div>
<div class="line"><span class="lineno"> 3114</span>            <span class="comment"># select the component at frequency +N/2 and halve it</span></div>
<div class="line"><span class="lineno"> 3115</span>            sl[axis] = slice(N//2, N//2 + 1)</div>
<div class="line"><span class="lineno"> 3116</span>            Y[tuple(sl)] *= 0.5</div>
<div class="line"><span class="lineno"> 3117</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> real_input:</div>
<div class="line"><span class="lineno"> 3118</span>                temp = Y[tuple(sl)]</div>
<div class="line"><span class="lineno"> 3119</span>                <span class="comment"># set the component at -N/2 equal to the component at +N/2</span></div>
<div class="line"><span class="lineno"> 3120</span>                sl[axis] = slice(num-N//2, num-N//2 + 1)</div>
<div class="line"><span class="lineno"> 3121</span>                Y[tuple(sl)] = temp</div>
<div class="line"><span class="lineno"> 3122</span> </div>
<div class="line"><span class="lineno"> 3123</span>    <span class="comment"># Inverse transform</span></div>
<div class="line"><span class="lineno"> 3124</span>    <span class="keywordflow">if</span> real_input:</div>
<div class="line"><span class="lineno"> 3125</span>        y = sp_fft.irfft(Y, num, axis=axis)</div>
<div class="line"><span class="lineno"> 3126</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3127</span>        y = sp_fft.ifft(Y, axis=axis, overwrite_x=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3128</span> </div>
<div class="line"><span class="lineno"> 3129</span>    y *= (float(num) / float(Nx))</div>
<div class="line"><span class="lineno"> 3130</span> </div>
<div class="line"><span class="lineno"> 3131</span>    <span class="keywordflow">if</span> t <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3132</span>        <span class="keywordflow">return</span> y</div>
<div class="line"><span class="lineno"> 3133</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3134</span>        new_t = np.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]</div>
<div class="line"><span class="lineno"> 3135</span>        <span class="keywordflow">return</span> y, new_t</div>
<div class="line"><span class="lineno"> 3136</span> </div>
<div class="line"><span class="lineno"> 3137</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af7c8fd225e6045b551653f623aa6ae1c" name="af7c8fd225e6045b551653f623aa6ae1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c8fd225e6045b551653f623aa6ae1c">&#9670;&#160;</a></span>resample_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.resample_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>down</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>('kaiser',&#160;5.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padtype</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Resample `x` along the given axis using polyphase filtering.

The signal `x` is upsampled by the factor `up`, a zero-phase low-pass
FIR filter is applied, and then it is downsampled by the factor `down`.
The resulting sample rate is ``up / down`` times the original sample
rate. By default, values beyond the boundary of the signal are assumed
to be zero during the filtering step.

Parameters
----------
x : array_like
    The data to be resampled.
up : int
    The upsampling factor.
down : int
    The downsampling factor.
axis : int, optional
    The axis of `x` that is resampled. Default is 0.
window : string, tuple, or array_like, optional
    Desired window to use to design the low-pass filter, or the FIR filter
    coefficients to employ. See below for details.
padtype : string, optional
    `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of
    the other signal extension modes supported by `scipy.signal.upfirdn`.
    Changes assumptions on values beyond the boundary. If `constant`,
    assumed to be `cval` (default zero). If `line` assumed to continue a
    linear trend defined by the first and last points. `mean`, `median`,
    `maximum` and `minimum` work as in `np.pad` and assume that the values
    beyond the boundary are the mean, median, maximum or minimum
    respectively of the array along the axis.

    .. versionadded:: 1.4.0
cval : float, optional
    Value to use if `padtype='constant'`. Default is zero.

    .. versionadded:: 1.4.0

Returns
-------
resampled_x : array
    The resampled array.

See Also
--------
decimate : Downsample the signal after applying an FIR or IIR filter.
resample : Resample up or down using the FFT method.

Notes
-----
This polyphase method will likely be faster than the Fourier method
in `scipy.signal.resample` when the number of samples is large and
prime, or when the number of samples is large and `up` and `down`
share a large greatest common denominator. The length of the FIR
filter used will depend on ``max(up, down) // gcd(up, down)``, and
the number of operations during polyphase filtering will depend on
the filter length and `down` (see `scipy.signal.upfirdn` for details).

The argument `window` specifies the FIR low-pass filter design.

If `window` is an array_like it is assumed to be the FIR filter
coefficients. Note that the FIR filter is applied after the upsampling
step, so it should be designed to operate on a signal at a sampling
frequency higher than the original by a factor of `up//gcd(up, down)`.
This function's output will be centered with respect to this array, so it
is best to pass a symmetric filter with an odd number of samples if, as
is usually the case, a zero-phase filter is desired.

For any other type of `window`, the functions `scipy.signal.get_window`
and `scipy.signal.firwin` are called to generate the appropriate filter
coefficients.

The first sample of the returned vector is the same as the first
sample of the input vector. The spacing between samples is changed
from ``dx`` to ``dx * down / float(up)``.

Examples
--------
By default, the end of the resampled data rises to meet the first
sample of the next cycle for the FFT method, and gets closer to zero
for the polyphase method:

&gt;&gt;&gt; from scipy import signal

&gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)
&gt;&gt;&gt; y = np.cos(-x**2/6.0)
&gt;&gt;&gt; f_fft = signal.resample(y, 100)
&gt;&gt;&gt; f_poly = signal.resample_poly(y, 100, 20)
&gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(xnew, f_fft, 'b.-', xnew, f_poly, 'r.-')
&gt;&gt;&gt; plt.plot(x, y, 'ko-')
&gt;&gt;&gt; plt.plot(10, y[0], 'bo', 10, 0., 'ro')  # boundaries
&gt;&gt;&gt; plt.legend(['resample', 'resamp_poly', 'data'], loc='best')
&gt;&gt;&gt; plt.show()

This default behaviour can be changed by using the padtype option:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal

&gt;&gt;&gt; N = 5
&gt;&gt;&gt; x = np.linspace(0, 1, N, endpoint=False)
&gt;&gt;&gt; y = 2 + x**2 - 1.7*np.sin(x) + .2*np.cos(11*x)
&gt;&gt;&gt; y2 = 1 + x**3 + 0.1*np.sin(x) + .1*np.cos(11*x)
&gt;&gt;&gt; Y = np.stack([y, y2], axis=-1)
&gt;&gt;&gt; up = 4
&gt;&gt;&gt; xr = np.linspace(0, 1, N*up, endpoint=False)

&gt;&gt;&gt; y2 = signal.resample_poly(Y, up, 1, padtype='constant')
&gt;&gt;&gt; y3 = signal.resample_poly(Y, up, 1, padtype='mean')
&gt;&gt;&gt; y4 = signal.resample_poly(Y, up, 1, padtype='line')

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; for i in [0,1]:
...     plt.figure()
...     plt.plot(xr, y4[:,i], 'g.', label='line')
...     plt.plot(xr, y3[:,i], 'y.', label='mean')
...     plt.plot(xr, y2[:,i], 'r.', label='constant')
...     plt.plot(x, Y[:,i], 'k-')
...     plt.legend()
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3139</span>                  padtype=<span class="stringliteral">&#39;constant&#39;</span>, cval=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3140</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral">    Resample `x` along the given axis using polyphase filtering.</span></div>
<div class="line"><span class="lineno"> 3142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3143</span><span class="stringliteral">    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass</span></div>
<div class="line"><span class="lineno"> 3144</span><span class="stringliteral">    FIR filter is applied, and then it is downsampled by the factor `down`.</span></div>
<div class="line"><span class="lineno"> 3145</span><span class="stringliteral">    The resulting sample rate is ``up / down`` times the original sample</span></div>
<div class="line"><span class="lineno"> 3146</span><span class="stringliteral">    rate. By default, values beyond the boundary of the signal are assumed</span></div>
<div class="line"><span class="lineno"> 3147</span><span class="stringliteral">    to be zero during the filtering step.</span></div>
<div class="line"><span class="lineno"> 3148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3149</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3150</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3151</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 3152</span><span class="stringliteral">        The data to be resampled.</span></div>
<div class="line"><span class="lineno"> 3153</span><span class="stringliteral">    up : int</span></div>
<div class="line"><span class="lineno"> 3154</span><span class="stringliteral">        The upsampling factor.</span></div>
<div class="line"><span class="lineno"> 3155</span><span class="stringliteral">    down : int</span></div>
<div class="line"><span class="lineno"> 3156</span><span class="stringliteral">        The downsampling factor.</span></div>
<div class="line"><span class="lineno"> 3157</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3158</span><span class="stringliteral">        The axis of `x` that is resampled. Default is 0.</span></div>
<div class="line"><span class="lineno"> 3159</span><span class="stringliteral">    window : string, tuple, or array_like, optional</span></div>
<div class="line"><span class="lineno"> 3160</span><span class="stringliteral">        Desired window to use to design the low-pass filter, or the FIR filter</span></div>
<div class="line"><span class="lineno"> 3161</span><span class="stringliteral">        coefficients to employ. See below for details.</span></div>
<div class="line"><span class="lineno"> 3162</span><span class="stringliteral">    padtype : string, optional</span></div>
<div class="line"><span class="lineno"> 3163</span><span class="stringliteral">        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of</span></div>
<div class="line"><span class="lineno"> 3164</span><span class="stringliteral">        the other signal extension modes supported by `scipy.signal.upfirdn`.</span></div>
<div class="line"><span class="lineno"> 3165</span><span class="stringliteral">        Changes assumptions on values beyond the boundary. If `constant`,</span></div>
<div class="line"><span class="lineno"> 3166</span><span class="stringliteral">        assumed to be `cval` (default zero). If `line` assumed to continue a</span></div>
<div class="line"><span class="lineno"> 3167</span><span class="stringliteral">        linear trend defined by the first and last points. `mean`, `median`,</span></div>
<div class="line"><span class="lineno"> 3168</span><span class="stringliteral">        `maximum` and `minimum` work as in `np.pad` and assume that the values</span></div>
<div class="line"><span class="lineno"> 3169</span><span class="stringliteral">        beyond the boundary are the mean, median, maximum or minimum</span></div>
<div class="line"><span class="lineno"> 3170</span><span class="stringliteral">        respectively of the array along the axis.</span></div>
<div class="line"><span class="lineno"> 3171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3172</span><span class="stringliteral">        .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 3173</span><span class="stringliteral">    cval : float, optional</span></div>
<div class="line"><span class="lineno"> 3174</span><span class="stringliteral">        Value to use if `padtype=&#39;constant&#39;`. Default is zero.</span></div>
<div class="line"><span class="lineno"> 3175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3176</span><span class="stringliteral">        .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 3177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3178</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3179</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3180</span><span class="stringliteral">    resampled_x : array</span></div>
<div class="line"><span class="lineno"> 3181</span><span class="stringliteral">        The resampled array.</span></div>
<div class="line"><span class="lineno"> 3182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3183</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3184</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3185</span><span class="stringliteral">    decimate : Downsample the signal after applying an FIR or IIR filter.</span></div>
<div class="line"><span class="lineno"> 3186</span><span class="stringliteral">    resample : Resample up or down using the FFT method.</span></div>
<div class="line"><span class="lineno"> 3187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3188</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3189</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3190</span><span class="stringliteral">    This polyphase method will likely be faster than the Fourier method</span></div>
<div class="line"><span class="lineno"> 3191</span><span class="stringliteral">    in `scipy.signal.resample` when the number of samples is large and</span></div>
<div class="line"><span class="lineno"> 3192</span><span class="stringliteral">    prime, or when the number of samples is large and `up` and `down`</span></div>
<div class="line"><span class="lineno"> 3193</span><span class="stringliteral">    share a large greatest common denominator. The length of the FIR</span></div>
<div class="line"><span class="lineno"> 3194</span><span class="stringliteral">    filter used will depend on ``max(up, down) // gcd(up, down)``, and</span></div>
<div class="line"><span class="lineno"> 3195</span><span class="stringliteral">    the number of operations during polyphase filtering will depend on</span></div>
<div class="line"><span class="lineno"> 3196</span><span class="stringliteral">    the filter length and `down` (see `scipy.signal.upfirdn` for details).</span></div>
<div class="line"><span class="lineno"> 3197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3198</span><span class="stringliteral">    The argument `window` specifies the FIR low-pass filter design.</span></div>
<div class="line"><span class="lineno"> 3199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3200</span><span class="stringliteral">    If `window` is an array_like it is assumed to be the FIR filter</span></div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral">    coefficients. Note that the FIR filter is applied after the upsampling</span></div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral">    step, so it should be designed to operate on a signal at a sampling</span></div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">    frequency higher than the original by a factor of `up//gcd(up, down)`.</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral">    This function&#39;s output will be centered with respect to this array, so it</span></div>
<div class="line"><span class="lineno"> 3205</span><span class="stringliteral">    is best to pass a symmetric filter with an odd number of samples if, as</span></div>
<div class="line"><span class="lineno"> 3206</span><span class="stringliteral">    is usually the case, a zero-phase filter is desired.</span></div>
<div class="line"><span class="lineno"> 3207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3208</span><span class="stringliteral">    For any other type of `window`, the functions `scipy.signal.get_window`</span></div>
<div class="line"><span class="lineno"> 3209</span><span class="stringliteral">    and `scipy.signal.firwin` are called to generate the appropriate filter</span></div>
<div class="line"><span class="lineno"> 3210</span><span class="stringliteral">    coefficients.</span></div>
<div class="line"><span class="lineno"> 3211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3212</span><span class="stringliteral">    The first sample of the returned vector is the same as the first</span></div>
<div class="line"><span class="lineno"> 3213</span><span class="stringliteral">    sample of the input vector. The spacing between samples is changed</span></div>
<div class="line"><span class="lineno"> 3214</span><span class="stringliteral">    from ``dx`` to ``dx * down / float(up)``.</span></div>
<div class="line"><span class="lineno"> 3215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3216</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3217</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3218</span><span class="stringliteral">    By default, the end of the resampled data rises to meet the first</span></div>
<div class="line"><span class="lineno"> 3219</span><span class="stringliteral">    sample of the next cycle for the FFT method, and gets closer to zero</span></div>
<div class="line"><span class="lineno"> 3220</span><span class="stringliteral">    for the polyphase method:</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3224</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 3225</span><span class="stringliteral">    &gt;&gt;&gt; y = np.cos(-x**2/6.0)</span></div>
<div class="line"><span class="lineno"> 3226</span><span class="stringliteral">    &gt;&gt;&gt; f_fft = signal.resample(y, 100)</span></div>
<div class="line"><span class="lineno"> 3227</span><span class="stringliteral">    &gt;&gt;&gt; f_poly = signal.resample_poly(y, 100, 20)</span></div>
<div class="line"><span class="lineno"> 3228</span><span class="stringliteral">    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 3229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3230</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3231</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(xnew, f_fft, &#39;b.-&#39;, xnew, f_poly, &#39;r.-&#39;)</span></div>
<div class="line"><span class="lineno"> 3232</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, y, &#39;ko-&#39;)</span></div>
<div class="line"><span class="lineno"> 3233</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(10, y[0], &#39;bo&#39;, 10, 0., &#39;ro&#39;)  # boundaries</span></div>
<div class="line"><span class="lineno"> 3234</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend([&#39;resample&#39;, &#39;resamp_poly&#39;, &#39;data&#39;], loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 3235</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral">    This default behaviour can be changed by using the padtype option:</span></div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral">    &gt;&gt;&gt; N = 5</span></div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 1, N, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral">    &gt;&gt;&gt; y = 2 + x**2 - 1.7*np.sin(x) + .2*np.cos(11*x)</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">    &gt;&gt;&gt; y2 = 1 + x**3 + 0.1*np.sin(x) + .1*np.cos(11*x)</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral">    &gt;&gt;&gt; Y = np.stack([y, y2], axis=-1)</span></div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">    &gt;&gt;&gt; up = 4</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">    &gt;&gt;&gt; xr = np.linspace(0, 1, N*up, endpoint=False)</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">    &gt;&gt;&gt; y2 = signal.resample_poly(Y, up, 1, padtype=&#39;constant&#39;)</span></div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral">    &gt;&gt;&gt; y3 = signal.resample_poly(Y, up, 1, padtype=&#39;mean&#39;)</span></div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral">    &gt;&gt;&gt; y4 = signal.resample_poly(Y, up, 1, padtype=&#39;line&#39;)</span></div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">    &gt;&gt;&gt; for i in [0,1]:</span></div>
<div class="line"><span class="lineno"> 3256</span><span class="stringliteral">    ...     plt.figure()</span></div>
<div class="line"><span class="lineno"> 3257</span><span class="stringliteral">    ...     plt.plot(xr, y4[:,i], &#39;g.&#39;, label=&#39;line&#39;)</span></div>
<div class="line"><span class="lineno"> 3258</span><span class="stringliteral">    ...     plt.plot(xr, y3[:,i], &#39;y.&#39;, label=&#39;mean&#39;)</span></div>
<div class="line"><span class="lineno"> 3259</span><span class="stringliteral">    ...     plt.plot(xr, y2[:,i], &#39;r.&#39;, label=&#39;constant&#39;)</span></div>
<div class="line"><span class="lineno"> 3260</span><span class="stringliteral">    ...     plt.plot(x, Y[:,i], &#39;k-&#39;)</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">    ...     plt.legend()</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3265</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 3266</span>    <span class="keywordflow">if</span> up != int(up):</div>
<div class="line"><span class="lineno"> 3267</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;up must be an integer&quot;</span>)</div>
<div class="line"><span class="lineno"> 3268</span>    <span class="keywordflow">if</span> down != int(down):</div>
<div class="line"><span class="lineno"> 3269</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;down must be an integer&quot;</span>)</div>
<div class="line"><span class="lineno"> 3270</span>    up = int(up)</div>
<div class="line"><span class="lineno"> 3271</span>    down = int(down)</div>
<div class="line"><span class="lineno"> 3272</span>    <span class="keywordflow">if</span> up &lt; 1 <span class="keywordflow">or</span> down &lt; 1:</div>
<div class="line"><span class="lineno"> 3273</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;up and down must be &gt;= 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 3274</span>    <span class="keywordflow">if</span> cval <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> padtype != <span class="stringliteral">&#39;constant&#39;</span>:</div>
<div class="line"><span class="lineno"> 3275</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;cval has no effect when padtype is &#39;</span>, padtype)</div>
<div class="line"><span class="lineno"> 3276</span> </div>
<div class="line"><span class="lineno"> 3277</span>    <span class="comment"># Determine our up and down factors</span></div>
<div class="line"><span class="lineno"> 3278</span>    <span class="comment"># Use a rational approximation to save computation time on really long</span></div>
<div class="line"><span class="lineno"> 3279</span>    <span class="comment"># signals</span></div>
<div class="line"><span class="lineno"> 3280</span>    g_ = math.gcd(up, down)</div>
<div class="line"><span class="lineno"> 3281</span>    up //= g_</div>
<div class="line"><span class="lineno"> 3282</span>    down //= g_</div>
<div class="line"><span class="lineno"> 3283</span>    <span class="keywordflow">if</span> up == down == 1:</div>
<div class="line"><span class="lineno"> 3284</span>        <span class="keywordflow">return</span> x.copy()</div>
<div class="line"><span class="lineno"> 3285</span>    n_in = x.shape[axis]</div>
<div class="line"><span class="lineno"> 3286</span>    n_out = n_in * up</div>
<div class="line"><span class="lineno"> 3287</span>    n_out = n_out // down + bool(n_out % down)</div>
<div class="line"><span class="lineno"> 3288</span> </div>
<div class="line"><span class="lineno"> 3289</span>    <span class="keywordflow">if</span> isinstance(window, (list, np.ndarray)):</div>
<div class="line"><span class="lineno"> 3290</span>        window = np.array(window)  <span class="comment"># use array to force a copy (we modify it)</span></div>
<div class="line"><span class="lineno"> 3291</span>        <span class="keywordflow">if</span> window.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 3292</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;window must be 1-D&#39;</span>)</div>
<div class="line"><span class="lineno"> 3293</span>        half_len = (window.size - 1) // 2</div>
<div class="line"><span class="lineno"> 3294</span>        h = window</div>
<div class="line"><span class="lineno"> 3295</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3296</span>        <span class="comment"># Design a linear-phase low-pass FIR filter</span></div>
<div class="line"><span class="lineno"> 3297</span>        max_rate = max(up, down)</div>
<div class="line"><span class="lineno"> 3298</span>        f_c = 1. / max_rate  <span class="comment"># cutoff of FIR filter (rel. to Nyquist)</span></div>
<div class="line"><span class="lineno"> 3299</span>        half_len = 10 * max_rate  <span class="comment"># reasonable cutoff for sinc-like function</span></div>
<div class="line"><span class="lineno"> 3300</span>        h = firwin(2 * half_len + 1, f_c,</div>
<div class="line"><span class="lineno"> 3301</span>                   window=window).astype(x.dtype)  <span class="comment"># match dtype of x</span></div>
<div class="line"><span class="lineno"> 3302</span>    h *= up</div>
<div class="line"><span class="lineno"> 3303</span> </div>
<div class="line"><span class="lineno"> 3304</span>    <span class="comment"># Zero-pad our filter to put the output samples at the center</span></div>
<div class="line"><span class="lineno"> 3305</span>    n_pre_pad = (down - half_len % down)</div>
<div class="line"><span class="lineno"> 3306</span>    n_post_pad = 0</div>
<div class="line"><span class="lineno"> 3307</span>    n_pre_remove = (half_len + n_pre_pad) // down</div>
<div class="line"><span class="lineno"> 3308</span>    <span class="comment"># We should rarely need to do this given our filter lengths...</span></div>
<div class="line"><span class="lineno"> 3309</span>    <span class="keywordflow">while</span> _output_len(len(h) + n_pre_pad + n_post_pad, n_in,</div>
<div class="line"><span class="lineno"> 3310</span>                      up, down) &lt; n_out + n_pre_remove:</div>
<div class="line"><span class="lineno"> 3311</span>        n_post_pad += 1</div>
<div class="line"><span class="lineno"> 3312</span>    h = np.concatenate((np.zeros(n_pre_pad, dtype=h.dtype), h,</div>
<div class="line"><span class="lineno"> 3313</span>                        np.zeros(n_post_pad, dtype=h.dtype)))</div>
<div class="line"><span class="lineno"> 3314</span>    n_pre_remove_end = n_pre_remove + n_out</div>
<div class="line"><span class="lineno"> 3315</span> </div>
<div class="line"><span class="lineno"> 3316</span>    <span class="comment"># Remove background depending on the padtype option</span></div>
<div class="line"><span class="lineno"> 3317</span>    funcs = {<span class="stringliteral">&#39;mean&#39;</span>: np.mean, <span class="stringliteral">&#39;median&#39;</span>: np.median,</div>
<div class="line"><span class="lineno"> 3318</span>             <span class="stringliteral">&#39;minimum&#39;</span>: np.amin, <span class="stringliteral">&#39;maximum&#39;</span>: np.amax}</div>
<div class="line"><span class="lineno"> 3319</span>    upfirdn_kwargs = {<span class="stringliteral">&#39;mode&#39;</span>: <span class="stringliteral">&#39;constant&#39;</span>, <span class="stringliteral">&#39;cval&#39;</span>: 0}</div>
<div class="line"><span class="lineno"> 3320</span>    <span class="keywordflow">if</span> padtype <span class="keywordflow">in</span> funcs:</div>
<div class="line"><span class="lineno"> 3321</span>        background_values = funcs[padtype](x, axis=axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3322</span>    <span class="keywordflow">elif</span> padtype <span class="keywordflow">in</span> _upfirdn_modes:</div>
<div class="line"><span class="lineno"> 3323</span>        upfirdn_kwargs = {<span class="stringliteral">&#39;mode&#39;</span>: padtype}</div>
<div class="line"><span class="lineno"> 3324</span>        <span class="keywordflow">if</span> padtype == <span class="stringliteral">&#39;constant&#39;</span>:</div>
<div class="line"><span class="lineno"> 3325</span>            <span class="keywordflow">if</span> cval <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3326</span>                cval = 0</div>
<div class="line"><span class="lineno"> 3327</span>            upfirdn_kwargs[<span class="stringliteral">&#39;cval&#39;</span>] = cval</div>
<div class="line"><span class="lineno"> 3328</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3329</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3330</span>            <span class="stringliteral">&#39;padtype must be one of: maximum, mean, median, minimum, &#39;</span> +</div>
<div class="line"><span class="lineno"> 3331</span>            <span class="stringliteral">&#39;, &#39;</span>.join(_upfirdn_modes))</div>
<div class="line"><span class="lineno"> 3332</span> </div>
<div class="line"><span class="lineno"> 3333</span>    <span class="keywordflow">if</span> padtype <span class="keywordflow">in</span> funcs:</div>
<div class="line"><span class="lineno"> 3334</span>        x = x - background_values</div>
<div class="line"><span class="lineno"> 3335</span> </div>
<div class="line"><span class="lineno"> 3336</span>    <span class="comment"># filter then remove excess</span></div>
<div class="line"><span class="lineno"> 3337</span>    y = upfirdn(h, x, up, down, axis=axis, **upfirdn_kwargs)</div>
<div class="line"><span class="lineno"> 3338</span>    keep = [slice(<span class="keywordtype">None</span>), ]*x.ndim</div>
<div class="line"><span class="lineno"> 3339</span>    keep[axis] = slice(n_pre_remove, n_pre_remove_end)</div>
<div class="line"><span class="lineno"> 3340</span>    y_keep = y[tuple(keep)]</div>
<div class="line"><span class="lineno"> 3341</span> </div>
<div class="line"><span class="lineno"> 3342</span>    <span class="comment"># Add background back</span></div>
<div class="line"><span class="lineno"> 3343</span>    <span class="keywordflow">if</span> padtype <span class="keywordflow">in</span> funcs:</div>
<div class="line"><span class="lineno"> 3344</span>        y_keep += background_values</div>
<div class="line"><span class="lineno"> 3345</span> </div>
<div class="line"><span class="lineno"> 3346</span>    <span class="keywordflow">return</span> y_keep</div>
<div class="line"><span class="lineno"> 3347</span> </div>
<div class="line"><span class="lineno"> 3348</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c4286911a4ce17dcee1288cdcaf873d" name="a8c4286911a4ce17dcee1288cdcaf873d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4286911a4ce17dcee1288cdcaf873d">&#9670;&#160;</a></span>residue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.residue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'avg'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute partial-fraction expansion of b(s) / a(s).

If `M` is the degree of numerator `b` and `N` the degree of denominator
`a`::

          b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]
  H(s) = ------ = ------------------------------------------
          a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]

then the partial-fraction expansion H(s) is defined as::

           r[0]       r[1]             r[-1]
       = -------- + -------- + ... + --------- + k(s)
         (s-p[0])   (s-p[1])         (s-p[-1])

If there are any repeated roots (closer together than `tol`), then H(s)
has terms like::

      r[i]      r[i+1]              r[i+n-1]
    -------- + ----------- + ... + -----------
    (s-p[i])  (s-p[i])**2          (s-p[i])**n

This function is used for polynomials in positive powers of s or z,
such as analog filters or digital filters in controls engineering.  For
negative powers of z (typical for digital filters in DSP), use `residuez`.

See Notes for details about the algorithm.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
tol : float, optional
    The tolerance for two roots to be considered equal in terms of
    the distance between them. Default is 1e-3. See `unique_roots`
    for further details.
rtype : {'avg', 'min', 'max'}, optional
    Method for computing a root to represent a group of identical roots.
    Default is 'avg'. See `unique_roots` for further details.

Returns
-------
r : ndarray
    Residues corresponding to the poles. For repeated poles, the residues
    are ordered to correspond to ascending by power fractions.
p : ndarray
    Poles ordered by magnitude in ascending order.
k : ndarray
    Coefficients of the direct polynomial term.

See Also
--------
invres, residuez, numpy.poly, unique_roots

Notes
-----
The "deflation through subtraction" algorithm is used for
computations --- method 6 in [1]_.

The form of partial fraction expansion depends on poles multiplicity in
the exact mathematical sense. However there is no way to exactly
determine multiplicity of roots of a polynomial in numerical computing.
Thus you should think of the result of `residue` with given `tol` as
partial fraction expansion computed for the denominator composed of the
computed poles with empirically determined multiplicity. The choice of
`tol` can drastically change the result if there are close poles.

References
----------
.. [1] J. F. Mahoney, B. D. Sivazlian, "Partial fractions expansion: a
       review of computational methodology and efficiency", Journal of
       Computational and Applied Mathematics, Vol. 9, 1983.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2626</span><span class="keyword">def </span>residue(b, a, tol=1e-3, rtype=&#39;avg&#39;):</div>
<div class="line"><span class="lineno"> 2627</span>    <span class="stringliteral">&quot;&quot;&quot;Compute partial-fraction expansion of b(s) / a(s).</span></div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span></div>
<div class="line"><span class="lineno"> 2630</span><span class="stringliteral">    `a`::</span></div>
<div class="line"><span class="lineno"> 2631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2632</span><span class="stringliteral">              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]</span></div>
<div class="line"><span class="lineno"> 2633</span><span class="stringliteral">      H(s) = ------ = ------------------------------------------</span></div>
<div class="line"><span class="lineno"> 2634</span><span class="stringliteral">              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</span></div>
<div class="line"><span class="lineno"> 2635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2636</span><span class="stringliteral">    then the partial-fraction expansion H(s) is defined as::</span></div>
<div class="line"><span class="lineno"> 2637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2638</span><span class="stringliteral">               r[0]       r[1]             r[-1]</span></div>
<div class="line"><span class="lineno"> 2639</span><span class="stringliteral">           = -------- + -------- + ... + --------- + k(s)</span></div>
<div class="line"><span class="lineno"> 2640</span><span class="stringliteral">             (s-p[0])   (s-p[1])         (s-p[-1])</span></div>
<div class="line"><span class="lineno"> 2641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2642</span><span class="stringliteral">    If there are any repeated roots (closer together than `tol`), then H(s)</span></div>
<div class="line"><span class="lineno"> 2643</span><span class="stringliteral">    has terms like::</span></div>
<div class="line"><span class="lineno"> 2644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2645</span><span class="stringliteral">          r[i]      r[i+1]              r[i+n-1]</span></div>
<div class="line"><span class="lineno"> 2646</span><span class="stringliteral">        -------- + ----------- + ... + -----------</span></div>
<div class="line"><span class="lineno"> 2647</span><span class="stringliteral">        (s-p[i])  (s-p[i])**2          (s-p[i])**n</span></div>
<div class="line"><span class="lineno"> 2648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2649</span><span class="stringliteral">    This function is used for polynomials in positive powers of s or z,</span></div>
<div class="line"><span class="lineno"> 2650</span><span class="stringliteral">    such as analog filters or digital filters in controls engineering.  For</span></div>
<div class="line"><span class="lineno"> 2651</span><span class="stringliteral">    negative powers of z (typical for digital filters in DSP), use `residuez`.</span></div>
<div class="line"><span class="lineno"> 2652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral">    See Notes for details about the algorithm.</span></div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno"> 2658</span><span class="stringliteral">        Numerator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2659</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2660</span><span class="stringliteral">        Denominator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2661</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno"> 2662</span><span class="stringliteral">        The tolerance for two roots to be considered equal in terms of</span></div>
<div class="line"><span class="lineno"> 2663</span><span class="stringliteral">        the distance between them. Default is 1e-3. See `unique_roots`</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="stringliteral">        for further details.</span></div>
<div class="line"><span class="lineno"> 2665</span><span class="stringliteral">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2666</span><span class="stringliteral">        Method for computing a root to represent a group of identical roots.</span></div>
<div class="line"><span class="lineno"> 2667</span><span class="stringliteral">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span></div>
<div class="line"><span class="lineno"> 2668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2669</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral">    r : ndarray</span></div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">        Residues corresponding to the poles. For repeated poles, the residues</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">        are ordered to correspond to ascending by power fractions.</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">    p : ndarray</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">        Poles ordered by magnitude in ascending order.</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral">    k : ndarray</span></div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral">        Coefficients of the direct polynomial term.</span></div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral">    invres, residuez, numpy.poly, unique_roots</span></div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral">    The &quot;deflation through subtraction&quot; algorithm is used for</span></div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral">    computations --- method 6 in [1]_.</span></div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2688</span><span class="stringliteral">    The form of partial fraction expansion depends on poles multiplicity in</span></div>
<div class="line"><span class="lineno"> 2689</span><span class="stringliteral">    the exact mathematical sense. However there is no way to exactly</span></div>
<div class="line"><span class="lineno"> 2690</span><span class="stringliteral">    determine multiplicity of roots of a polynomial in numerical computing.</span></div>
<div class="line"><span class="lineno"> 2691</span><span class="stringliteral">    Thus you should think of the result of `residue` with given `tol` as</span></div>
<div class="line"><span class="lineno"> 2692</span><span class="stringliteral">    partial fraction expansion computed for the denominator composed of the</span></div>
<div class="line"><span class="lineno"> 2693</span><span class="stringliteral">    computed poles with empirically determined multiplicity. The choice of</span></div>
<div class="line"><span class="lineno"> 2694</span><span class="stringliteral">    `tol` can drastically change the result if there are close poles.</span></div>
<div class="line"><span class="lineno"> 2695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2696</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2697</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2698</span><span class="stringliteral">    .. [1] J. F. Mahoney, B. D. Sivazlian, &quot;Partial fractions expansion: a</span></div>
<div class="line"><span class="lineno"> 2699</span><span class="stringliteral">           review of computational methodology and efficiency&quot;, Journal of</span></div>
<div class="line"><span class="lineno"> 2700</span><span class="stringliteral">           Computational and Applied Mathematics, Vol. 9, 1983.</span></div>
<div class="line"><span class="lineno"> 2701</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2702</span>    b = np.asarray(b)</div>
<div class="line"><span class="lineno"> 2703</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 2704</span>    <span class="keywordflow">if</span> (np.issubdtype(b.dtype, np.complexfloating)</div>
<div class="line"><span class="lineno"> 2705</span>            <span class="keywordflow">or</span> np.issubdtype(a.dtype, np.complexfloating)):</div>
<div class="line"><span class="lineno"> 2706</span>        b = b.astype(complex)</div>
<div class="line"><span class="lineno"> 2707</span>        a = a.astype(complex)</div>
<div class="line"><span class="lineno"> 2708</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2709</span>        b = b.astype(float)</div>
<div class="line"><span class="lineno"> 2710</span>        a = a.astype(float)</div>
<div class="line"><span class="lineno"> 2711</span> </div>
<div class="line"><span class="lineno"> 2712</span>    b = np.trim_zeros(np.atleast_1d(b), <span class="stringliteral">&#39;f&#39;</span>)</div>
<div class="line"><span class="lineno"> 2713</span>    a = np.trim_zeros(np.atleast_1d(a), <span class="stringliteral">&#39;f&#39;</span>)</div>
<div class="line"><span class="lineno"> 2714</span> </div>
<div class="line"><span class="lineno"> 2715</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 2716</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Denominator `a` is zero.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2717</span> </div>
<div class="line"><span class="lineno"> 2718</span>    poles = np.roots(a)</div>
<div class="line"><span class="lineno"> 2719</span>    <span class="keywordflow">if</span> b.size == 0:</div>
<div class="line"><span class="lineno"> 2720</span>        <span class="keywordflow">return</span> np.zeros(poles.shape), cmplx_sort(poles)[0], np.array([])</div>
<div class="line"><span class="lineno"> 2721</span> </div>
<div class="line"><span class="lineno"> 2722</span>    <span class="keywordflow">if</span> len(b) &lt; len(a):</div>
<div class="line"><span class="lineno"> 2723</span>        k = np.empty(0)</div>
<div class="line"><span class="lineno"> 2724</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2725</span>        k, b = np.polydiv(b, a)</div>
<div class="line"><span class="lineno"> 2726</span> </div>
<div class="line"><span class="lineno"> 2727</span>    unique_poles, multiplicity = unique_roots(poles, tol=tol, rtype=rtype)</div>
<div class="line"><span class="lineno"> 2728</span>    unique_poles, order = cmplx_sort(unique_poles)</div>
<div class="line"><span class="lineno"> 2729</span>    multiplicity = multiplicity[order]</div>
<div class="line"><span class="lineno"> 2730</span> </div>
<div class="line"><span class="lineno"> 2731</span>    residues = _compute_residues(unique_poles, multiplicity, b)</div>
<div class="line"><span class="lineno"> 2732</span> </div>
<div class="line"><span class="lineno"> 2733</span>    index = 0</div>
<div class="line"><span class="lineno"> 2734</span>    <span class="keywordflow">for</span> pole, mult <span class="keywordflow">in</span> zip(unique_poles, multiplicity):</div>
<div class="line"><span class="lineno"> 2735</span>        poles[index:index + mult] = pole</div>
<div class="line"><span class="lineno"> 2736</span>        index += mult</div>
<div class="line"><span class="lineno"> 2737</span> </div>
<div class="line"><span class="lineno"> 2738</span>    <span class="keywordflow">return</span> residues / a[0], poles, k</div>
<div class="line"><span class="lineno"> 2739</span> </div>
<div class="line"><span class="lineno"> 2740</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a86de701cb1667df120fbb8c8cab0deda" name="a86de701cb1667df120fbb8c8cab0deda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86de701cb1667df120fbb8c8cab0deda">&#9670;&#160;</a></span>residuez()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.residuez </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'avg'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute partial-fraction expansion of b(z) / a(z).

If `M` is the degree of numerator `b` and `N` the degree of denominator
`a`::

            b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)
    H(z) = ------ = ------------------------------------------
            a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)

then the partial-fraction expansion H(z) is defined as::

             r[0]                   r[-1]
     = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...
       (1-p[0]z**(-1))         (1-p[-1]z**(-1))

If there are any repeated roots (closer than `tol`), then the partial
fraction expansion has terms like::

         r[i]              r[i+1]                    r[i+n-1]
    -------------- + ------------------ + ... + ------------------
    (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n

This function is used for polynomials in negative powers of z,
such as digital filters in DSP.  For positive powers, use `residue`.

See Notes of `residue` for details about the algorithm.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
tol : float, optional
    The tolerance for two roots to be considered equal in terms of
    the distance between them. Default is 1e-3. See `unique_roots`
    for further details.
rtype : {'avg', 'min', 'max'}, optional
    Method for computing a root to represent a group of identical roots.
    Default is 'avg'. See `unique_roots` for further details.

Returns
-------
r : ndarray
    Residues corresponding to the poles. For repeated poles, the residues
    are ordered to correspond to ascending by power fractions.
p : ndarray
    Poles ordered by magnitude in ascending order.
k : ndarray
    Coefficients of the direct polynomial term.

See Also
--------
invresz, residue, unique_roots
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2741</span><span class="keyword">def </span>residuez(b, a, tol=1e-3, rtype=&#39;avg&#39;):</div>
<div class="line"><span class="lineno"> 2742</span>    <span class="stringliteral">&quot;&quot;&quot;Compute partial-fraction expansion of b(z) / a(z).</span></div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span></div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral">    `a`::</span></div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral">                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)</span></div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral">        H(z) = ------ = ------------------------------------------</span></div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2751</span><span class="stringliteral">    then the partial-fraction expansion H(z) is defined as::</span></div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral">                 r[0]                   r[-1]</span></div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral">         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...</span></div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral">           (1-p[0]z**(-1))         (1-p[-1]z**(-1))</span></div>
<div class="line"><span class="lineno"> 2756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">    If there are any repeated roots (closer than `tol`), then the partial</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral">    fraction expansion has terms like::</span></div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2760</span><span class="stringliteral">             r[i]              r[i+1]                    r[i+n-1]</span></div>
<div class="line"><span class="lineno"> 2761</span><span class="stringliteral">        -------------- + ------------------ + ... + ------------------</span></div>
<div class="line"><span class="lineno"> 2762</span><span class="stringliteral">        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n</span></div>
<div class="line"><span class="lineno"> 2763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2764</span><span class="stringliteral">    This function is used for polynomials in negative powers of z,</span></div>
<div class="line"><span class="lineno"> 2765</span><span class="stringliteral">    such as digital filters in DSP.  For positive powers, use `residue`.</span></div>
<div class="line"><span class="lineno"> 2766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2767</span><span class="stringliteral">    See Notes of `residue` for details about the algorithm.</span></div>
<div class="line"><span class="lineno"> 2768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2769</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2770</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2771</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno"> 2772</span><span class="stringliteral">        Numerator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2773</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="stringliteral">        Denominator polynomial coefficients.</span></div>
<div class="line"><span class="lineno"> 2775</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno"> 2776</span><span class="stringliteral">        The tolerance for two roots to be considered equal in terms of</span></div>
<div class="line"><span class="lineno"> 2777</span><span class="stringliteral">        the distance between them. Default is 1e-3. See `unique_roots`</span></div>
<div class="line"><span class="lineno"> 2778</span><span class="stringliteral">        for further details.</span></div>
<div class="line"><span class="lineno"> 2779</span><span class="stringliteral">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2780</span><span class="stringliteral">        Method for computing a root to represent a group of identical roots.</span></div>
<div class="line"><span class="lineno"> 2781</span><span class="stringliteral">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span></div>
<div class="line"><span class="lineno"> 2782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2783</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2784</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2785</span><span class="stringliteral">    r : ndarray</span></div>
<div class="line"><span class="lineno"> 2786</span><span class="stringliteral">        Residues corresponding to the poles. For repeated poles, the residues</span></div>
<div class="line"><span class="lineno"> 2787</span><span class="stringliteral">        are ordered to correspond to ascending by power fractions.</span></div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">    p : ndarray</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral">        Poles ordered by magnitude in ascending order.</span></div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">    k : ndarray</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">        Coefficients of the direct polynomial term.</span></div>
<div class="line"><span class="lineno"> 2792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2793</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2794</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2795</span><span class="stringliteral">    invresz, residue, unique_roots</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2797</span>    b = np.asarray(b)</div>
<div class="line"><span class="lineno"> 2798</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 2799</span>    <span class="keywordflow">if</span> (np.issubdtype(b.dtype, np.complexfloating)</div>
<div class="line"><span class="lineno"> 2800</span>            <span class="keywordflow">or</span> np.issubdtype(a.dtype, np.complexfloating)):</div>
<div class="line"><span class="lineno"> 2801</span>        b = b.astype(complex)</div>
<div class="line"><span class="lineno"> 2802</span>        a = a.astype(complex)</div>
<div class="line"><span class="lineno"> 2803</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2804</span>        b = b.astype(float)</div>
<div class="line"><span class="lineno"> 2805</span>        a = a.astype(float)</div>
<div class="line"><span class="lineno"> 2806</span> </div>
<div class="line"><span class="lineno"> 2807</span>    b = np.trim_zeros(np.atleast_1d(b), <span class="stringliteral">&#39;b&#39;</span>)</div>
<div class="line"><span class="lineno"> 2808</span>    a = np.trim_zeros(np.atleast_1d(a), <span class="stringliteral">&#39;b&#39;</span>)</div>
<div class="line"><span class="lineno"> 2809</span> </div>
<div class="line"><span class="lineno"> 2810</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 2811</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Denominator `a` is zero.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2812</span>    <span class="keywordflow">elif</span> a[0] == 0:</div>
<div class="line"><span class="lineno"> 2813</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;First coefficient of determinant `a` must be &quot;</span></div>
<div class="line"><span class="lineno"> 2814</span>                         <span class="stringliteral">&quot;non-zero.&quot;</span>)</div>
<div class="line"><span class="lineno"> 2815</span> </div>
<div class="line"><span class="lineno"> 2816</span>    poles = np.roots(a)</div>
<div class="line"><span class="lineno"> 2817</span>    <span class="keywordflow">if</span> b.size == 0:</div>
<div class="line"><span class="lineno"> 2818</span>        <span class="keywordflow">return</span> np.zeros(poles.shape), cmplx_sort(poles)[0], np.array([])</div>
<div class="line"><span class="lineno"> 2819</span> </div>
<div class="line"><span class="lineno"> 2820</span>    b_rev = b[::-1]</div>
<div class="line"><span class="lineno"> 2821</span>    a_rev = a[::-1]</div>
<div class="line"><span class="lineno"> 2822</span> </div>
<div class="line"><span class="lineno"> 2823</span>    <span class="keywordflow">if</span> len(b_rev) &lt; len(a_rev):</div>
<div class="line"><span class="lineno"> 2824</span>        k_rev = np.empty(0)</div>
<div class="line"><span class="lineno"> 2825</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2826</span>        k_rev, b_rev = np.polydiv(b_rev, a_rev)</div>
<div class="line"><span class="lineno"> 2827</span> </div>
<div class="line"><span class="lineno"> 2828</span>    unique_poles, multiplicity = unique_roots(poles, tol=tol, rtype=rtype)</div>
<div class="line"><span class="lineno"> 2829</span>    unique_poles, order = cmplx_sort(unique_poles)</div>
<div class="line"><span class="lineno"> 2830</span>    multiplicity = multiplicity[order]</div>
<div class="line"><span class="lineno"> 2831</span> </div>
<div class="line"><span class="lineno"> 2832</span>    residues = _compute_residues(1 / unique_poles, multiplicity, b_rev)</div>
<div class="line"><span class="lineno"> 2833</span> </div>
<div class="line"><span class="lineno"> 2834</span>    index = 0</div>
<div class="line"><span class="lineno"> 2835</span>    powers = np.empty(len(residues), dtype=int)</div>
<div class="line"><span class="lineno"> 2836</span>    <span class="keywordflow">for</span> pole, mult <span class="keywordflow">in</span> zip(unique_poles, multiplicity):</div>
<div class="line"><span class="lineno"> 2837</span>        poles[index:index + mult] = pole</div>
<div class="line"><span class="lineno"> 2838</span>        powers[index:index + mult] = 1 + np.arange(mult)</div>
<div class="line"><span class="lineno"> 2839</span>        index += mult</div>
<div class="line"><span class="lineno"> 2840</span> </div>
<div class="line"><span class="lineno"> 2841</span>    residues *= (-poles) ** powers / a_rev[0]</div>
<div class="line"><span class="lineno"> 2842</span> </div>
<div class="line"><span class="lineno"> 2843</span>    <span class="keywordflow">return</span> residues, poles, k_rev[::-1]</div>
<div class="line"><span class="lineno"> 2844</span> </div>
<div class="line"><span class="lineno"> 2845</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40dc9f97985577063e15be92871e7d2d" name="a40dc9f97985577063e15be92871e7d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dc9f97985577063e15be92871e7d2d">&#9670;&#160;</a></span>sosfilt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.sosfilt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zi</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Filter data along one dimension using cascaded second-order sections.

Filter a data sequence, `x`, using a digital IIR filter defined by
`sos`.

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. Each row corresponds to a second-order
    section, with the first three columns providing the numerator
    coefficients and the last three providing the denominator
    coefficients.
x : array_like
    An N-dimensional input array.
axis : int, optional
    The axis of the input data array along which to apply the
    linear filter. The filter is applied to each subarray along
    this axis.  Default is -1.
zi : array_like, optional
    Initial conditions for the cascaded filter delays.  It is a (at
    least 2D) vector of shape ``(n_sections, ..., 2, ...)``, where
    ``..., 2, ...`` denotes the shape of `x`, but with ``x.shape[axis]``
    replaced by 2.  If `zi` is None or is not given then initial rest
    (i.e. all zeros) is assumed.
    Note that these initial conditions are *not* the same as the initial
    conditions given by `lfiltic` or `lfilter_zi`.

Returns
-------
y : ndarray
    The output of the digital filter.
zf : ndarray, optional
    If `zi` is None, this is not returned, otherwise, `zf` holds the
    final filter delay values.

See Also
--------
zpk2sos, sos2zpk, sosfilt_zi, sosfiltfilt, sosfreqz

Notes
-----
The filter function is implemented as a series of second-order filters
with direct-form II transposed structure. It is designed to minimize
numerical precision errors for high-order filters.

.. versionadded:: 0.16.0

Examples
--------
Plot a 13th-order filter's impulse response using both `lfilter` and
`sosfilt`, showing the instability that results from trying to do a
13th-order filter in a single stage (the numerical error pushes some poles
outside of the unit circle):

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; b, a = signal.ellip(13, 0.009, 80, 0.05, output='ba')
&gt;&gt;&gt; sos = signal.ellip(13, 0.009, 80, 0.05, output='sos')
&gt;&gt;&gt; x = signal.unit_impulse(700)
&gt;&gt;&gt; y_tf = signal.lfilter(b, a, x)
&gt;&gt;&gt; y_sos = signal.sosfilt(sos, x)
&gt;&gt;&gt; plt.plot(y_tf, 'r', label='TF')
&gt;&gt;&gt; plt.plot(y_sos, 'k', label='SOS')
&gt;&gt;&gt; plt.legend(loc='best')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 4147</span><span class="keyword">def </span>sosfilt(sos, x, axis=-1, zi=None):</div>
<div class="line"><span class="lineno"> 4148</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4149</span><span class="stringliteral">    Filter data along one dimension using cascaded second-order sections.</span></div>
<div class="line"><span class="lineno"> 4150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4151</span><span class="stringliteral">    Filter a data sequence, `x`, using a digital IIR filter defined by</span></div>
<div class="line"><span class="lineno"> 4152</span><span class="stringliteral">    `sos`.</span></div>
<div class="line"><span class="lineno"> 4153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4154</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4155</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4156</span><span class="stringliteral">    sos : array_like</span></div>
<div class="line"><span class="lineno"> 4157</span><span class="stringliteral">        Array of second-order filter coefficients, must have shape</span></div>
<div class="line"><span class="lineno"> 4158</span><span class="stringliteral">        ``(n_sections, 6)``. Each row corresponds to a second-order</span></div>
<div class="line"><span class="lineno"> 4159</span><span class="stringliteral">        section, with the first three columns providing the numerator</span></div>
<div class="line"><span class="lineno"> 4160</span><span class="stringliteral">        coefficients and the last three providing the denominator</span></div>
<div class="line"><span class="lineno"> 4161</span><span class="stringliteral">        coefficients.</span></div>
<div class="line"><span class="lineno"> 4162</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 4163</span><span class="stringliteral">        An N-dimensional input array.</span></div>
<div class="line"><span class="lineno"> 4164</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 4165</span><span class="stringliteral">        The axis of the input data array along which to apply the</span></div>
<div class="line"><span class="lineno"> 4166</span><span class="stringliteral">        linear filter. The filter is applied to each subarray along</span></div>
<div class="line"><span class="lineno"> 4167</span><span class="stringliteral">        this axis.  Default is -1.</span></div>
<div class="line"><span class="lineno"> 4168</span><span class="stringliteral">    zi : array_like, optional</span></div>
<div class="line"><span class="lineno"> 4169</span><span class="stringliteral">        Initial conditions for the cascaded filter delays.  It is a (at</span></div>
<div class="line"><span class="lineno"> 4170</span><span class="stringliteral">        least 2D) vector of shape ``(n_sections, ..., 2, ...)``, where</span></div>
<div class="line"><span class="lineno"> 4171</span><span class="stringliteral">        ``..., 2, ...`` denotes the shape of `x`, but with ``x.shape[axis]``</span></div>
<div class="line"><span class="lineno"> 4172</span><span class="stringliteral">        replaced by 2.  If `zi` is None or is not given then initial rest</span></div>
<div class="line"><span class="lineno"> 4173</span><span class="stringliteral">        (i.e. all zeros) is assumed.</span></div>
<div class="line"><span class="lineno"> 4174</span><span class="stringliteral">        Note that these initial conditions are *not* the same as the initial</span></div>
<div class="line"><span class="lineno"> 4175</span><span class="stringliteral">        conditions given by `lfiltic` or `lfilter_zi`.</span></div>
<div class="line"><span class="lineno"> 4176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4177</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4178</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4179</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 4180</span><span class="stringliteral">        The output of the digital filter.</span></div>
<div class="line"><span class="lineno"> 4181</span><span class="stringliteral">    zf : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 4182</span><span class="stringliteral">        If `zi` is None, this is not returned, otherwise, `zf` holds the</span></div>
<div class="line"><span class="lineno"> 4183</span><span class="stringliteral">        final filter delay values.</span></div>
<div class="line"><span class="lineno"> 4184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4185</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4186</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4187</span><span class="stringliteral">    zpk2sos, sos2zpk, sosfilt_zi, sosfiltfilt, sosfreqz</span></div>
<div class="line"><span class="lineno"> 4188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4189</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4190</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4191</span><span class="stringliteral">    The filter function is implemented as a series of second-order filters</span></div>
<div class="line"><span class="lineno"> 4192</span><span class="stringliteral">    with direct-form II transposed structure. It is designed to minimize</span></div>
<div class="line"><span class="lineno"> 4193</span><span class="stringliteral">    numerical precision errors for high-order filters.</span></div>
<div class="line"><span class="lineno"> 4194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4195</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno"> 4196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4197</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4198</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4199</span><span class="stringliteral">    Plot a 13th-order filter&#39;s impulse response using both `lfilter` and</span></div>
<div class="line"><span class="lineno"> 4200</span><span class="stringliteral">    `sosfilt`, showing the instability that results from trying to do a</span></div>
<div class="line"><span class="lineno"> 4201</span><span class="stringliteral">    13th-order filter in a single stage (the numerical error pushes some poles</span></div>
<div class="line"><span class="lineno"> 4202</span><span class="stringliteral">    outside of the unit circle):</span></div>
<div class="line"><span class="lineno"> 4203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4204</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 4205</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 4206</span><span class="stringliteral">    &gt;&gt;&gt; b, a = signal.ellip(13, 0.009, 80, 0.05, output=&#39;ba&#39;)</span></div>
<div class="line"><span class="lineno"> 4207</span><span class="stringliteral">    &gt;&gt;&gt; sos = signal.ellip(13, 0.009, 80, 0.05, output=&#39;sos&#39;)</span></div>
<div class="line"><span class="lineno"> 4208</span><span class="stringliteral">    &gt;&gt;&gt; x = signal.unit_impulse(700)</span></div>
<div class="line"><span class="lineno"> 4209</span><span class="stringliteral">    &gt;&gt;&gt; y_tf = signal.lfilter(b, a, x)</span></div>
<div class="line"><span class="lineno"> 4210</span><span class="stringliteral">    &gt;&gt;&gt; y_sos = signal.sosfilt(sos, x)</span></div>
<div class="line"><span class="lineno"> 4211</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(y_tf, &#39;r&#39;, label=&#39;TF&#39;)</span></div>
<div class="line"><span class="lineno"> 4212</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(y_sos, &#39;k&#39;, label=&#39;SOS&#39;)</span></div>
<div class="line"><span class="lineno"> 4213</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 4214</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 4215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4216</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4217</span>    x = _validate_x(x)</div>
<div class="line"><span class="lineno"> 4218</span>    sos, n_sections = _validate_sos(sos)</div>
<div class="line"><span class="lineno"> 4219</span>    x_zi_shape = list(x.shape)</div>
<div class="line"><span class="lineno"> 4220</span>    x_zi_shape[axis] = 2</div>
<div class="line"><span class="lineno"> 4221</span>    x_zi_shape = tuple([n_sections] + x_zi_shape)</div>
<div class="line"><span class="lineno"> 4222</span>    inputs = [sos, x]</div>
<div class="line"><span class="lineno"> 4223</span>    <span class="keywordflow">if</span> zi <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4224</span>        inputs.append(np.asarray(zi))</div>
<div class="line"><span class="lineno"> 4225</span>    dtype = np.result_type(*inputs)</div>
<div class="line"><span class="lineno"> 4226</span>    <span class="keywordflow">if</span> dtype.char <span class="keywordflow">not</span> <span class="keywordflow">in</span> <span class="stringliteral">&#39;fdgFDGO&#39;</span>:</div>
<div class="line"><span class="lineno"> 4227</span>        <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;input type &#39;%s&#39; not supported&quot;</span> % dtype)</div>
<div class="line"><span class="lineno"> 4228</span>    <span class="keywordflow">if</span> zi <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4229</span>        zi = np.array(zi, dtype)  <span class="comment"># make a copy so that we can operate in place</span></div>
<div class="line"><span class="lineno"> 4230</span>        <span class="keywordflow">if</span> zi.shape != x_zi_shape:</div>
<div class="line"><span class="lineno"> 4231</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Invalid zi shape. With axis=%r, an input with &#39;</span></div>
<div class="line"><span class="lineno"> 4232</span>                             <span class="stringliteral">&#39;shape %r, and an sos array with %d sections, zi &#39;</span></div>
<div class="line"><span class="lineno"> 4233</span>                             <span class="stringliteral">&#39;must have shape %r, got %r.&#39;</span> %</div>
<div class="line"><span class="lineno"> 4234</span>                             (axis, x.shape, n_sections, x_zi_shape, zi.shape))</div>
<div class="line"><span class="lineno"> 4235</span>        return_zi = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4236</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4237</span>        zi = np.zeros(x_zi_shape, dtype=dtype)</div>
<div class="line"><span class="lineno"> 4238</span>        return_zi = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4239</span>    axis = axis % x.ndim  <span class="comment"># make positive</span></div>
<div class="line"><span class="lineno"> 4240</span>    x = np.moveaxis(x, axis, -1)</div>
<div class="line"><span class="lineno"> 4241</span>    zi = np.moveaxis(zi, [0, axis + 1], [-2, -1])</div>
<div class="line"><span class="lineno"> 4242</span>    x_shape, zi_shape = x.shape, zi.shape</div>
<div class="line"><span class="lineno"> 4243</span>    x = np.reshape(x, (-1, x.shape[-1]))</div>
<div class="line"><span class="lineno"> 4244</span>    x = np.array(x, dtype, order=<span class="stringliteral">&#39;C&#39;</span>)  <span class="comment"># make a copy, can modify in place</span></div>
<div class="line"><span class="lineno"> 4245</span>    zi = np.ascontiguousarray(np.reshape(zi, (-1, n_sections, 2)))</div>
<div class="line"><span class="lineno"> 4246</span>    sos = sos.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 4247</span>    _sosfilt(sos, x, zi)</div>
<div class="line"><span class="lineno"> 4248</span>    x.shape = x_shape</div>
<div class="line"><span class="lineno"> 4249</span>    x = np.moveaxis(x, -1, axis)</div>
<div class="line"><span class="lineno"> 4250</span>    <span class="keywordflow">if</span> return_zi:</div>
<div class="line"><span class="lineno"> 4251</span>        zi.shape = zi_shape</div>
<div class="line"><span class="lineno"> 4252</span>        zi = np.moveaxis(zi, [-2, -1], [0, axis + 1])</div>
<div class="line"><span class="lineno"> 4253</span>        out = (x, zi)</div>
<div class="line"><span class="lineno"> 4254</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4255</span>        out = x</div>
<div class="line"><span class="lineno"> 4256</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 4257</span> </div>
<div class="line"><span class="lineno"> 4258</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa17f7e5a5e127ec7e05820383db98847" name="aa17f7e5a5e127ec7e05820383db98847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17f7e5a5e127ec7e05820383db98847">&#9670;&#160;</a></span>sosfilt_zi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.sosfilt_zi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct initial conditions for sosfilt for step response steady-state.

Compute an initial state `zi` for the `sosfilt` function that corresponds
to the steady state of the step response.

A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

Returns
-------
zi : ndarray
    Initial conditions suitable for use with ``sosfilt``, shape
    ``(n_sections, 2)``.

See Also
--------
sosfilt, zpk2sos

Notes
-----
.. versionadded:: 0.16.0

Examples
--------
Filter a rectangular pulse that begins at time 0, with and without
the use of the `zi` argument of `scipy.signal.sosfilt`.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; sos = signal.butter(9, 0.125, output='sos')
&gt;&gt;&gt; zi = signal.sosfilt_zi(sos)
&gt;&gt;&gt; x = (np.arange(250) &lt; 100).astype(int)
&gt;&gt;&gt; f1 = signal.sosfilt(sos, x)
&gt;&gt;&gt; f2, zo = signal.sosfilt(sos, x, zi=zi)

&gt;&gt;&gt; plt.plot(x, 'k--', label='x')
&gt;&gt;&gt; plt.plot(f1, 'b', alpha=0.5, linewidth=2, label='filtered')
&gt;&gt;&gt; plt.plot(f2, 'g', alpha=0.25, linewidth=4, label='filtered with zi')
&gt;&gt;&gt; plt.legend(loc='best')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3650</span><span class="keyword">def </span>sosfilt_zi(sos):</div>
<div class="line"><span class="lineno"> 3651</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3652</span><span class="stringliteral">    Construct initial conditions for sosfilt for step response steady-state.</span></div>
<div class="line"><span class="lineno"> 3653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3654</span><span class="stringliteral">    Compute an initial state `zi` for the `sosfilt` function that corresponds</span></div>
<div class="line"><span class="lineno"> 3655</span><span class="stringliteral">    to the steady state of the step response.</span></div>
<div class="line"><span class="lineno"> 3656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3657</span><span class="stringliteral">    A typical use of this function is to set the initial state so that the</span></div>
<div class="line"><span class="lineno"> 3658</span><span class="stringliteral">    output of the filter starts at the same value as the first element of</span></div>
<div class="line"><span class="lineno"> 3659</span><span class="stringliteral">    the signal to be filtered.</span></div>
<div class="line"><span class="lineno"> 3660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3661</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3662</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3663</span><span class="stringliteral">    sos : array_like</span></div>
<div class="line"><span class="lineno"> 3664</span><span class="stringliteral">        Array of second-order filter coefficients, must have shape</span></div>
<div class="line"><span class="lineno"> 3665</span><span class="stringliteral">        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format</span></div>
<div class="line"><span class="lineno"> 3666</span><span class="stringliteral">        specification.</span></div>
<div class="line"><span class="lineno"> 3667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3668</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3669</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3670</span><span class="stringliteral">    zi : ndarray</span></div>
<div class="line"><span class="lineno"> 3671</span><span class="stringliteral">        Initial conditions suitable for use with ``sosfilt``, shape</span></div>
<div class="line"><span class="lineno"> 3672</span><span class="stringliteral">        ``(n_sections, 2)``.</span></div>
<div class="line"><span class="lineno"> 3673</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3674</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3675</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3676</span><span class="stringliteral">    sosfilt, zpk2sos</span></div>
<div class="line"><span class="lineno"> 3677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3678</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3679</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3680</span><span class="stringliteral">    .. versionadded:: 0.16.0</span></div>
<div class="line"><span class="lineno"> 3681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3682</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3683</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3684</span><span class="stringliteral">    Filter a rectangular pulse that begins at time 0, with and without</span></div>
<div class="line"><span class="lineno"> 3685</span><span class="stringliteral">    the use of the `zi` argument of `scipy.signal.sosfilt`.</span></div>
<div class="line"><span class="lineno"> 3686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3687</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 3688</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3690</span><span class="stringliteral">    &gt;&gt;&gt; sos = signal.butter(9, 0.125, output=&#39;sos&#39;)</span></div>
<div class="line"><span class="lineno"> 3691</span><span class="stringliteral">    &gt;&gt;&gt; zi = signal.sosfilt_zi(sos)</span></div>
<div class="line"><span class="lineno"> 3692</span><span class="stringliteral">    &gt;&gt;&gt; x = (np.arange(250) &lt; 100).astype(int)</span></div>
<div class="line"><span class="lineno"> 3693</span><span class="stringliteral">    &gt;&gt;&gt; f1 = signal.sosfilt(sos, x)</span></div>
<div class="line"><span class="lineno"> 3694</span><span class="stringliteral">    &gt;&gt;&gt; f2, zo = signal.sosfilt(sos, x, zi=zi)</span></div>
<div class="line"><span class="lineno"> 3695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3696</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, &#39;k--&#39;, label=&#39;x&#39;)</span></div>
<div class="line"><span class="lineno"> 3697</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(f1, &#39;b&#39;, alpha=0.5, linewidth=2, label=&#39;filtered&#39;)</span></div>
<div class="line"><span class="lineno"> 3698</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(f2, &#39;g&#39;, alpha=0.25, linewidth=4, label=&#39;filtered with zi&#39;)</span></div>
<div class="line"><span class="lineno"> 3699</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 3700</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3702</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3703</span>    sos = np.asarray(sos)</div>
<div class="line"><span class="lineno"> 3704</span>    <span class="keywordflow">if</span> sos.ndim != 2 <span class="keywordflow">or</span> sos.shape[1] != 6:</div>
<div class="line"><span class="lineno"> 3705</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;sos must be shape (n_sections, 6)&#39;</span>)</div>
<div class="line"><span class="lineno"> 3706</span> </div>
<div class="line"><span class="lineno"> 3707</span>    <span class="keywordflow">if</span> sos.dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&#39;bui&#39;</span>:</div>
<div class="line"><span class="lineno"> 3708</span>        sos = sos.astype(np.float64)</div>
<div class="line"><span class="lineno"> 3709</span> </div>
<div class="line"><span class="lineno"> 3710</span>    n_sections = sos.shape[0]</div>
<div class="line"><span class="lineno"> 3711</span>    zi = np.empty((n_sections, 2), dtype=sos.dtype)</div>
<div class="line"><span class="lineno"> 3712</span>    scale = 1.0</div>
<div class="line"><span class="lineno"> 3713</span>    <span class="keywordflow">for</span> section <span class="keywordflow">in</span> range(n_sections):</div>
<div class="line"><span class="lineno"> 3714</span>        b = sos[section, :3]</div>
<div class="line"><span class="lineno"> 3715</span>        a = sos[section, 3:]</div>
<div class="line"><span class="lineno"> 3716</span>        zi[section] = scale * lfilter_zi(b, a)</div>
<div class="line"><span class="lineno"> 3717</span>        <span class="comment"># If H(z) = B(z)/A(z) is this section&#39;s transfer function, then</span></div>
<div class="line"><span class="lineno"> 3718</span>        <span class="comment"># b.sum()/a.sum() is H(1), the gain at omega=0.  That&#39;s the steady</span></div>
<div class="line"><span class="lineno"> 3719</span>        <span class="comment"># state value of this section&#39;s step response.</span></div>
<div class="line"><span class="lineno"> 3720</span>        scale *= b.sum() / a.sum()</div>
<div class="line"><span class="lineno"> 3721</span> </div>
<div class="line"><span class="lineno"> 3722</span>    <span class="keywordflow">return</span> zi</div>
<div class="line"><span class="lineno"> 3723</span> </div>
<div class="line"><span class="lineno"> 3724</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3b62559ed41c43b059b669a2da526c4" name="aa3b62559ed41c43b059b669a2da526c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b62559ed41c43b059b669a2da526c4">&#9670;&#160;</a></span>sosfiltfilt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.sosfiltfilt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padtype</em> = <code>'odd'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padlen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A forward-backward digital filter using cascaded second-order sections.

See `filtfilt` for more complete information about this method.

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. Each row corresponds to a second-order
    section, with the first three columns providing the numerator
    coefficients and the last three providing the denominator
    coefficients.
x : array_like
    The array of data to be filtered.
axis : int, optional
    The axis of `x` to which the filter is applied.
    Default is -1.
padtype : str or None, optional
    Must be 'odd', 'even', 'constant', or None.  This determines the
    type of extension to use for the padded signal to which the filter
    is applied.  If `padtype` is None, no padding is used.  The default
    is 'odd'.
padlen : int or None, optional
    The number of elements by which to extend `x` at both ends of
    `axis` before applying the filter.  This value must be less than
    ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.
    The default value is::

        3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),
                                    (sos[:, 5] == 0).sum()))

    The extra subtraction at the end attempts to compensate for poles
    and zeros at the origin (e.g. for odd-order filters) to yield
    equivalent estimates of `padlen` to those of `filtfilt` for
    second-order section filters built with `scipy.signal` functions.

Returns
-------
y : ndarray
    The filtered output with the same shape as `x`.

See Also
--------
filtfilt, sosfilt, sosfilt_zi, sosfreqz

Notes
-----
.. versionadded:: 0.18.0

Examples
--------
&gt;&gt;&gt; from scipy.signal import sosfiltfilt, butter
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Create an interesting signal to filter.

&gt;&gt;&gt; n = 201
&gt;&gt;&gt; t = np.linspace(0, 1, n)
&gt;&gt;&gt; x = 1 + (t &lt; 0.5) - 0.25*t**2 + 0.05*rng.standard_normal(n)

Create a lowpass Butterworth filter, and use it to filter `x`.

&gt;&gt;&gt; sos = butter(4, 0.125, output='sos')
&gt;&gt;&gt; y = sosfiltfilt(sos, x)

For comparison, apply an 8th order filter using `sosfilt`.  The filter
is initialized using the mean of the first four values of `x`.

&gt;&gt;&gt; from scipy.signal import sosfilt, sosfilt_zi
&gt;&gt;&gt; sos8 = butter(8, 0.125, output='sos')
&gt;&gt;&gt; zi = x[:4].mean() * sosfilt_zi(sos8)
&gt;&gt;&gt; y2, zo = sosfilt(sos8, x, zi=zi)

Plot the results.  Note that the phase of `y` matches the input, while
`y2` has a significant phase delay.

&gt;&gt;&gt; plt.plot(t, x, alpha=0.5, label='x(t)')
&gt;&gt;&gt; plt.plot(t, y, label='y(t)')
&gt;&gt;&gt; plt.plot(t, y2, label='y2(t)')
&gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)
&gt;&gt;&gt; plt.grid(alpha=0.25)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 4259</span><span class="keyword">def </span>sosfiltfilt(sos, x, axis=-1, padtype=&#39;odd&#39;, padlen=None):</div>
<div class="line"><span class="lineno"> 4260</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4261</span><span class="stringliteral">    A forward-backward digital filter using cascaded second-order sections.</span></div>
<div class="line"><span class="lineno"> 4262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4263</span><span class="stringliteral">    See `filtfilt` for more complete information about this method.</span></div>
<div class="line"><span class="lineno"> 4264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4265</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4266</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4267</span><span class="stringliteral">    sos : array_like</span></div>
<div class="line"><span class="lineno"> 4268</span><span class="stringliteral">        Array of second-order filter coefficients, must have shape</span></div>
<div class="line"><span class="lineno"> 4269</span><span class="stringliteral">        ``(n_sections, 6)``. Each row corresponds to a second-order</span></div>
<div class="line"><span class="lineno"> 4270</span><span class="stringliteral">        section, with the first three columns providing the numerator</span></div>
<div class="line"><span class="lineno"> 4271</span><span class="stringliteral">        coefficients and the last three providing the denominator</span></div>
<div class="line"><span class="lineno"> 4272</span><span class="stringliteral">        coefficients.</span></div>
<div class="line"><span class="lineno"> 4273</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 4274</span><span class="stringliteral">        The array of data to be filtered.</span></div>
<div class="line"><span class="lineno"> 4275</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 4276</span><span class="stringliteral">        The axis of `x` to which the filter is applied.</span></div>
<div class="line"><span class="lineno"> 4277</span><span class="stringliteral">        Default is -1.</span></div>
<div class="line"><span class="lineno"> 4278</span><span class="stringliteral">    padtype : str or None, optional</span></div>
<div class="line"><span class="lineno"> 4279</span><span class="stringliteral">        Must be &#39;odd&#39;, &#39;even&#39;, &#39;constant&#39;, or None.  This determines the</span></div>
<div class="line"><span class="lineno"> 4280</span><span class="stringliteral">        type of extension to use for the padded signal to which the filter</span></div>
<div class="line"><span class="lineno"> 4281</span><span class="stringliteral">        is applied.  If `padtype` is None, no padding is used.  The default</span></div>
<div class="line"><span class="lineno"> 4282</span><span class="stringliteral">        is &#39;odd&#39;.</span></div>
<div class="line"><span class="lineno"> 4283</span><span class="stringliteral">    padlen : int or None, optional</span></div>
<div class="line"><span class="lineno"> 4284</span><span class="stringliteral">        The number of elements by which to extend `x` at both ends of</span></div>
<div class="line"><span class="lineno"> 4285</span><span class="stringliteral">        `axis` before applying the filter.  This value must be less than</span></div>
<div class="line"><span class="lineno"> 4286</span><span class="stringliteral">        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.</span></div>
<div class="line"><span class="lineno"> 4287</span><span class="stringliteral">        The default value is::</span></div>
<div class="line"><span class="lineno"> 4288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4289</span><span class="stringliteral">            3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),</span></div>
<div class="line"><span class="lineno"> 4290</span><span class="stringliteral">                                        (sos[:, 5] == 0).sum()))</span></div>
<div class="line"><span class="lineno"> 4291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4292</span><span class="stringliteral">        The extra subtraction at the end attempts to compensate for poles</span></div>
<div class="line"><span class="lineno"> 4293</span><span class="stringliteral">        and zeros at the origin (e.g. for odd-order filters) to yield</span></div>
<div class="line"><span class="lineno"> 4294</span><span class="stringliteral">        equivalent estimates of `padlen` to those of `filtfilt` for</span></div>
<div class="line"><span class="lineno"> 4295</span><span class="stringliteral">        second-order section filters built with `scipy.signal` functions.</span></div>
<div class="line"><span class="lineno"> 4296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4297</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4298</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4299</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 4300</span><span class="stringliteral">        The filtered output with the same shape as `x`.</span></div>
<div class="line"><span class="lineno"> 4301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4302</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4303</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4304</span><span class="stringliteral">    filtfilt, sosfilt, sosfilt_zi, sosfreqz</span></div>
<div class="line"><span class="lineno"> 4305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4306</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4307</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4308</span><span class="stringliteral">    .. versionadded:: 0.18.0</span></div>
<div class="line"><span class="lineno"> 4309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4310</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4311</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4312</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import sosfiltfilt, butter</span></div>
<div class="line"><span class="lineno"> 4313</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 4314</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 4315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4316</span><span class="stringliteral">    Create an interesting signal to filter.</span></div>
<div class="line"><span class="lineno"> 4317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4318</span><span class="stringliteral">    &gt;&gt;&gt; n = 201</span></div>
<div class="line"><span class="lineno"> 4319</span><span class="stringliteral">    &gt;&gt;&gt; t = np.linspace(0, 1, n)</span></div>
<div class="line"><span class="lineno"> 4320</span><span class="stringliteral">    &gt;&gt;&gt; x = 1 + (t &lt; 0.5) - 0.25*t**2 + 0.05*rng.standard_normal(n)</span></div>
<div class="line"><span class="lineno"> 4321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4322</span><span class="stringliteral">    Create a lowpass Butterworth filter, and use it to filter `x`.</span></div>
<div class="line"><span class="lineno"> 4323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4324</span><span class="stringliteral">    &gt;&gt;&gt; sos = butter(4, 0.125, output=&#39;sos&#39;)</span></div>
<div class="line"><span class="lineno"> 4325</span><span class="stringliteral">    &gt;&gt;&gt; y = sosfiltfilt(sos, x)</span></div>
<div class="line"><span class="lineno"> 4326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4327</span><span class="stringliteral">    For comparison, apply an 8th order filter using `sosfilt`.  The filter</span></div>
<div class="line"><span class="lineno"> 4328</span><span class="stringliteral">    is initialized using the mean of the first four values of `x`.</span></div>
<div class="line"><span class="lineno"> 4329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4330</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import sosfilt, sosfilt_zi</span></div>
<div class="line"><span class="lineno"> 4331</span><span class="stringliteral">    &gt;&gt;&gt; sos8 = butter(8, 0.125, output=&#39;sos&#39;)</span></div>
<div class="line"><span class="lineno"> 4332</span><span class="stringliteral">    &gt;&gt;&gt; zi = x[:4].mean() * sosfilt_zi(sos8)</span></div>
<div class="line"><span class="lineno"> 4333</span><span class="stringliteral">    &gt;&gt;&gt; y2, zo = sosfilt(sos8, x, zi=zi)</span></div>
<div class="line"><span class="lineno"> 4334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4335</span><span class="stringliteral">    Plot the results.  Note that the phase of `y` matches the input, while</span></div>
<div class="line"><span class="lineno"> 4336</span><span class="stringliteral">    `y2` has a significant phase delay.</span></div>
<div class="line"><span class="lineno"> 4337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4338</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, x, alpha=0.5, label=&#39;x(t)&#39;)</span></div>
<div class="line"><span class="lineno"> 4339</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y, label=&#39;y(t)&#39;)</span></div>
<div class="line"><span class="lineno"> 4340</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(t, y2, label=&#39;y2(t)&#39;)</span></div>
<div class="line"><span class="lineno"> 4341</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)</span></div>
<div class="line"><span class="lineno"> 4342</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(alpha=0.25)</span></div>
<div class="line"><span class="lineno"> 4343</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span></div>
<div class="line"><span class="lineno"> 4344</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 4345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4346</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4347</span>    sos, n_sections = _validate_sos(sos)</div>
<div class="line"><span class="lineno"> 4348</span>    x = _validate_x(x)</div>
<div class="line"><span class="lineno"> 4349</span> </div>
<div class="line"><span class="lineno"> 4350</span>    <span class="comment"># `method` is &quot;pad&quot;...</span></div>
<div class="line"><span class="lineno"> 4351</span>    ntaps = 2 * n_sections + 1</div>
<div class="line"><span class="lineno"> 4352</span>    ntaps -= min((sos[:, 2] == 0).sum(), (sos[:, 5] == 0).sum())</div>
<div class="line"><span class="lineno"> 4353</span>    edge, ext = _validate_pad(padtype, padlen, x, axis,</div>
<div class="line"><span class="lineno"> 4354</span>                              ntaps=ntaps)</div>
<div class="line"><span class="lineno"> 4355</span> </div>
<div class="line"><span class="lineno"> 4356</span>    <span class="comment"># These steps follow the same form as filtfilt with modifications</span></div>
<div class="line"><span class="lineno"> 4357</span>    zi = sosfilt_zi(sos)  <span class="comment"># shape (n_sections, 2) --&gt; (n_sections, ..., 2, ...)</span></div>
<div class="line"><span class="lineno"> 4358</span>    zi_shape = [1] * x.ndim</div>
<div class="line"><span class="lineno"> 4359</span>    zi_shape[axis] = 2</div>
<div class="line"><span class="lineno"> 4360</span>    zi.shape = [n_sections] + zi_shape</div>
<div class="line"><span class="lineno"> 4361</span>    x_0 = axis_slice(ext, stop=1, axis=axis)</div>
<div class="line"><span class="lineno"> 4362</span>    (y, zf) = sosfilt(sos, ext, axis=axis, zi=zi * x_0)</div>
<div class="line"><span class="lineno"> 4363</span>    y_0 = axis_slice(y, start=-1, axis=axis)</div>
<div class="line"><span class="lineno"> 4364</span>    (y, zf) = sosfilt(sos, axis_reverse(y, axis=axis), axis=axis, zi=zi * y_0)</div>
<div class="line"><span class="lineno"> 4365</span>    y = axis_reverse(y, axis=axis)</div>
<div class="line"><span class="lineno"> 4366</span>    <span class="keywordflow">if</span> edge &gt; 0:</div>
<div class="line"><span class="lineno"> 4367</span>        y = axis_slice(y, start=edge, stop=-edge, axis=axis)</div>
<div class="line"><span class="lineno"> 4368</span>    <span class="keywordflow">return</span> y</div>
<div class="line"><span class="lineno"> 4369</span> </div>
<div class="line"><span class="lineno"> 4370</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a51a57e100adbc7af239e487a8f22a2bd" name="a51a57e100adbc7af239e487a8f22a2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a57e100adbc7af239e487a8f22a2bd">&#9670;&#160;</a></span>unique_roots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.unique_roots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtype</em> = <code>'min'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine unique roots and their multiplicities from a list of roots.

Parameters
----------
p : array_like
    The list of roots.
tol : float, optional
    The tolerance for two roots to be considered equal in terms of
    the distance between them. Default is 1e-3. Refer to Notes about
    the details on roots grouping.
rtype : {'max', 'maximum', 'min', 'minimum', 'avg', 'mean'}, optional
    How to determine the returned root if multiple roots are within
    `tol` of each other.

      - 'max', 'maximum': pick the maximum of those roots
      - 'min', 'minimum': pick the minimum of those roots
      - 'avg', 'mean': take the average of those roots

    When finding minimum or maximum among complex roots they are compared
    first by the real part and then by the imaginary part.

Returns
-------
unique : ndarray
    The list of unique roots.
multiplicity : ndarray
    The multiplicity of each root.

Notes
-----
If we have 3 roots ``a``, ``b`` and ``c``, such that ``a`` is close to
``b`` and ``b`` is close to ``c`` (distance is less than `tol`), then it
doesn't necessarily mean that ``a`` is close to ``c``. It means that roots
grouping is not unique. In this function we use "greedy" grouping going
through the roots in the order they are given in the input `p`.

This utility function is not specific to roots but can be used for any
sequence of values for which uniqueness and multiplicity has to be
determined. For a more general routine, see `numpy.unique`.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]
&gt;&gt;&gt; uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype='avg')

Check which roots have multiplicity larger than 1:

&gt;&gt;&gt; uniq[mult &gt; 1]
array([ 1.305])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2412</span><span class="keyword">def </span>unique_roots(p, tol=1e-3, rtype=&#39;min&#39;):</div>
<div class="line"><span class="lineno"> 2413</span>    <span class="stringliteral">&quot;&quot;&quot;Determine unique roots and their multiplicities from a list of roots.</span></div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral">    p : array_like</span></div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral">        The list of roots.</span></div>
<div class="line"><span class="lineno"> 2419</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno"> 2420</span><span class="stringliteral">        The tolerance for two roots to be considered equal in terms of</span></div>
<div class="line"><span class="lineno"> 2421</span><span class="stringliteral">        the distance between them. Default is 1e-3. Refer to Notes about</span></div>
<div class="line"><span class="lineno"> 2422</span><span class="stringliteral">        the details on roots grouping.</span></div>
<div class="line"><span class="lineno"> 2423</span><span class="stringliteral">    rtype : {&#39;max&#39;, &#39;maximum&#39;, &#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;mean&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2424</span><span class="stringliteral">        How to determine the returned root if multiple roots are within</span></div>
<div class="line"><span class="lineno"> 2425</span><span class="stringliteral">        `tol` of each other.</span></div>
<div class="line"><span class="lineno"> 2426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2427</span><span class="stringliteral">          - &#39;max&#39;, &#39;maximum&#39;: pick the maximum of those roots</span></div>
<div class="line"><span class="lineno"> 2428</span><span class="stringliteral">          - &#39;min&#39;, &#39;minimum&#39;: pick the minimum of those roots</span></div>
<div class="line"><span class="lineno"> 2429</span><span class="stringliteral">          - &#39;avg&#39;, &#39;mean&#39;: take the average of those roots</span></div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral">        When finding minimum or maximum among complex roots they are compared</span></div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral">        first by the real part and then by the imaginary part.</span></div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">    unique : ndarray</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">        The list of unique roots.</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">    multiplicity : ndarray</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">        The multiplicity of each root.</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">    If we have 3 roots ``a``, ``b`` and ``c``, such that ``a`` is close to</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral">    ``b`` and ``b`` is close to ``c`` (distance is less than `tol`), then it</span></div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">    doesn&#39;t necessarily mean that ``a`` is close to ``c``. It means that roots</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral">    grouping is not unique. In this function we use &quot;greedy&quot; grouping going</span></div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">    through the roots in the order they are given in the input `p`.</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">    This utility function is not specific to roots but can be used for any</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">    sequence of values for which uniqueness and multiplicity has to be</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral">    determined. For a more general routine, see `numpy.unique`.</span></div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">    &gt;&gt;&gt; vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral">    &gt;&gt;&gt; uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype=&#39;avg&#39;)</span></div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral">    Check which roots have multiplicity larger than 1:</span></div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">    &gt;&gt;&gt; uniq[mult &gt; 1]</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral">    array([ 1.305])</span></div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2464</span>    <span class="keywordflow">if</span> rtype <span class="keywordflow">in</span> [<span class="stringliteral">&#39;max&#39;</span>, <span class="stringliteral">&#39;maximum&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2465</span>        reduce = np.max</div>
<div class="line"><span class="lineno"> 2466</span>    <span class="keywordflow">elif</span> rtype <span class="keywordflow">in</span> [<span class="stringliteral">&#39;min&#39;</span>, <span class="stringliteral">&#39;minimum&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2467</span>        reduce = np.min</div>
<div class="line"><span class="lineno"> 2468</span>    <span class="keywordflow">elif</span> rtype <span class="keywordflow">in</span> [<span class="stringliteral">&#39;avg&#39;</span>, <span class="stringliteral">&#39;mean&#39;</span>]:</div>
<div class="line"><span class="lineno"> 2469</span>        reduce = np.mean</div>
<div class="line"><span class="lineno"> 2470</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2471</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`rtype` must be one of &quot;</span></div>
<div class="line"><span class="lineno"> 2472</span>                         <span class="stringliteral">&quot;{&#39;max&#39;, &#39;maximum&#39;, &#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;mean&#39;}&quot;</span>)</div>
<div class="line"><span class="lineno"> 2473</span> </div>
<div class="line"><span class="lineno"> 2474</span>    p = np.asarray(p)</div>
<div class="line"><span class="lineno"> 2475</span> </div>
<div class="line"><span class="lineno"> 2476</span>    points = np.empty((len(p), 2))</div>
<div class="line"><span class="lineno"> 2477</span>    points[:, 0] = np.real(p)</div>
<div class="line"><span class="lineno"> 2478</span>    points[:, 1] = np.imag(p)</div>
<div class="line"><span class="lineno"> 2479</span>    tree = cKDTree(points)</div>
<div class="line"><span class="lineno"> 2480</span> </div>
<div class="line"><span class="lineno"> 2481</span>    p_unique = []</div>
<div class="line"><span class="lineno"> 2482</span>    p_multiplicity = []</div>
<div class="line"><span class="lineno"> 2483</span>    used = np.zeros(len(p), dtype=bool)</div>
<div class="line"><span class="lineno"> 2484</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(p)):</div>
<div class="line"><span class="lineno"> 2485</span>        <span class="keywordflow">if</span> used[i]:</div>
<div class="line"><span class="lineno"> 2486</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 2487</span> </div>
<div class="line"><span class="lineno"> 2488</span>        group = tree.query_ball_point(points[i], tol)</div>
<div class="line"><span class="lineno"> 2489</span>        group = [x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> group <span class="keywordflow">if</span> <span class="keywordflow">not</span> used[x]]</div>
<div class="line"><span class="lineno"> 2490</span> </div>
<div class="line"><span class="lineno"> 2491</span>        p_unique.append(reduce(p[group]))</div>
<div class="line"><span class="lineno"> 2492</span>        p_multiplicity.append(len(group))</div>
<div class="line"><span class="lineno"> 2493</span> </div>
<div class="line"><span class="lineno"> 2494</span>        used[group] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2495</span> </div>
<div class="line"><span class="lineno"> 2496</span>    <span class="keywordflow">return</span> np.asarray(p_unique), np.asarray(p_multiplicity)</div>
<div class="line"><span class="lineno"> 2497</span> </div>
<div class="line"><span class="lineno"> 2498</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a79923863872e25bc09509a9255d46250" name="a79923863872e25bc09509a9255d46250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79923863872e25bc09509a9255d46250">&#9670;&#160;</a></span>vectorstrength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.vectorstrength </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine the vector strength of the events corresponding to the given
period.

The vector strength is a measure of phase synchrony, how well the
timing of the events is synchronized to a single period of a periodic
signal.

If multiple periods are used, calculate the vector strength of each.
This is called the "resonating vector strength".

Parameters
----------
events : 1D array_like
    An array of time points containing the timing of the events.
period : float or array_like
    The period of the signal that the events should synchronize to.
    The period is in the same units as `events`.  It can also be an array
    of periods, in which case the outputs are arrays of the same length.

Returns
-------
strength : float or 1D array
    The strength of the synchronization.  1.0 is perfect synchronization
    and 0.0 is no synchronization.  If `period` is an array, this is also
    an array with each element containing the vector strength at the
    corresponding period.
phase : float or array
    The phase that the events are most strongly synchronized to in radians.
    If `period` is an array, this is also an array with each element
    containing the phase for the corresponding period.

References
----------
van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector
    strength: Auditory system, electric fish, and noise.
    Chaos 21, 047508 (2011);
    :doi:`10.1063/1.3670512`.
van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:
    biological and mathematical perspectives.  Biol Cybern.
    2013 Aug;107(4):385-96. :doi:`10.1007/s00422-013-0561-7`.
van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens
    when we vary the "probing" frequency while keeping the spike times
    fixed.  Biol Cybern. 2013 Aug;107(4):491-94.
    :doi:`10.1007/s00422-013-0560-8`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3349</span><span class="keyword">def </span>vectorstrength(events, period):</div>
<div class="line"><span class="lineno"> 3350</span>    <span class="stringliteral">&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 3351</span><span class="stringliteral">    Determine the vector strength of the events corresponding to the given</span></div>
<div class="line"><span class="lineno"> 3352</span><span class="stringliteral">    period.</span></div>
<div class="line"><span class="lineno"> 3353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3354</span><span class="stringliteral">    The vector strength is a measure of phase synchrony, how well the</span></div>
<div class="line"><span class="lineno"> 3355</span><span class="stringliteral">    timing of the events is synchronized to a single period of a periodic</span></div>
<div class="line"><span class="lineno"> 3356</span><span class="stringliteral">    signal.</span></div>
<div class="line"><span class="lineno"> 3357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3358</span><span class="stringliteral">    If multiple periods are used, calculate the vector strength of each.</span></div>
<div class="line"><span class="lineno"> 3359</span><span class="stringliteral">    This is called the &quot;resonating vector strength&quot;.</span></div>
<div class="line"><span class="lineno"> 3360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3361</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3362</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3363</span><span class="stringliteral">    events : 1D array_like</span></div>
<div class="line"><span class="lineno"> 3364</span><span class="stringliteral">        An array of time points containing the timing of the events.</span></div>
<div class="line"><span class="lineno"> 3365</span><span class="stringliteral">    period : float or array_like</span></div>
<div class="line"><span class="lineno"> 3366</span><span class="stringliteral">        The period of the signal that the events should synchronize to.</span></div>
<div class="line"><span class="lineno"> 3367</span><span class="stringliteral">        The period is in the same units as `events`.  It can also be an array</span></div>
<div class="line"><span class="lineno"> 3368</span><span class="stringliteral">        of periods, in which case the outputs are arrays of the same length.</span></div>
<div class="line"><span class="lineno"> 3369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3370</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3371</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3372</span><span class="stringliteral">    strength : float or 1D array</span></div>
<div class="line"><span class="lineno"> 3373</span><span class="stringliteral">        The strength of the synchronization.  1.0 is perfect synchronization</span></div>
<div class="line"><span class="lineno"> 3374</span><span class="stringliteral">        and 0.0 is no synchronization.  If `period` is an array, this is also</span></div>
<div class="line"><span class="lineno"> 3375</span><span class="stringliteral">        an array with each element containing the vector strength at the</span></div>
<div class="line"><span class="lineno"> 3376</span><span class="stringliteral">        corresponding period.</span></div>
<div class="line"><span class="lineno"> 3377</span><span class="stringliteral">    phase : float or array</span></div>
<div class="line"><span class="lineno"> 3378</span><span class="stringliteral">        The phase that the events are most strongly synchronized to in radians.</span></div>
<div class="line"><span class="lineno"> 3379</span><span class="stringliteral">        If `period` is an array, this is also an array with each element</span></div>
<div class="line"><span class="lineno"> 3380</span><span class="stringliteral">        containing the phase for the corresponding period.</span></div>
<div class="line"><span class="lineno"> 3381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3382</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3383</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3384</span><span class="stringliteral">    van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector</span></div>
<div class="line"><span class="lineno"> 3385</span><span class="stringliteral">        strength: Auditory system, electric fish, and noise.</span></div>
<div class="line"><span class="lineno"> 3386</span><span class="stringliteral">        Chaos 21, 047508 (2011);</span></div>
<div class="line"><span class="lineno"> 3387</span><span class="stringliteral">        :doi:`10.1063/1.3670512`.</span></div>
<div class="line"><span class="lineno"> 3388</span><span class="stringliteral">    van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:</span></div>
<div class="line"><span class="lineno"> 3389</span><span class="stringliteral">        biological and mathematical perspectives.  Biol Cybern.</span></div>
<div class="line"><span class="lineno"> 3390</span><span class="stringliteral">        2013 Aug;107(4):385-96. :doi:`10.1007/s00422-013-0561-7`.</span></div>
<div class="line"><span class="lineno"> 3391</span><span class="stringliteral">    van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens</span></div>
<div class="line"><span class="lineno"> 3392</span><span class="stringliteral">        when we vary the &quot;probing&quot; frequency while keeping the spike times</span></div>
<div class="line"><span class="lineno"> 3393</span><span class="stringliteral">        fixed.  Biol Cybern. 2013 Aug;107(4):491-94.</span></div>
<div class="line"><span class="lineno"> 3394</span><span class="stringliteral">        :doi:`10.1007/s00422-013-0560-8`.</span></div>
<div class="line"><span class="lineno"> 3395</span><span class="stringliteral">    &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 3396</span>    events = np.asarray(events)</div>
<div class="line"><span class="lineno"> 3397</span>    period = np.asarray(period)</div>
<div class="line"><span class="lineno"> 3398</span>    <span class="keywordflow">if</span> events.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 3399</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;events cannot have dimensions more than 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 3400</span>    <span class="keywordflow">if</span> period.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 3401</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;period cannot have dimensions more than 1&#39;</span>)</div>
<div class="line"><span class="lineno"> 3402</span> </div>
<div class="line"><span class="lineno"> 3403</span>    <span class="comment"># we need to know later if period was originally a scalar</span></div>
<div class="line"><span class="lineno"> 3404</span>    scalarperiod = <span class="keywordflow">not</span> period.ndim</div>
<div class="line"><span class="lineno"> 3405</span> </div>
<div class="line"><span class="lineno"> 3406</span>    events = np.atleast_2d(events)</div>
<div class="line"><span class="lineno"> 3407</span>    period = np.atleast_2d(period)</div>
<div class="line"><span class="lineno"> 3408</span>    <span class="keywordflow">if</span> (period &lt;= 0).any():</div>
<div class="line"><span class="lineno"> 3409</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;periods must be positive&#39;</span>)</div>
<div class="line"><span class="lineno"> 3410</span> </div>
<div class="line"><span class="lineno"> 3411</span>    <span class="comment"># this converts the times to vectors</span></div>
<div class="line"><span class="lineno"> 3412</span>    vectors = np.exp(np.dot(2j*np.pi/period.T, events))</div>
<div class="line"><span class="lineno"> 3413</span> </div>
<div class="line"><span class="lineno"> 3414</span>    <span class="comment"># the vector strength is just the magnitude of the mean of the vectors</span></div>
<div class="line"><span class="lineno"> 3415</span>    <span class="comment"># the vector phase is the angle of the mean of the vectors</span></div>
<div class="line"><span class="lineno"> 3416</span>    vectormean = np.mean(vectors, axis=1)</div>
<div class="line"><span class="lineno"> 3417</span>    strength = abs(vectormean)</div>
<div class="line"><span class="lineno"> 3418</span>    phase = np.angle(vectormean)</div>
<div class="line"><span class="lineno"> 3419</span> </div>
<div class="line"><span class="lineno"> 3420</span>    <span class="comment"># if the original period was a scalar, return scalars</span></div>
<div class="line"><span class="lineno"> 3421</span>    <span class="keywordflow">if</span> scalarperiod:</div>
<div class="line"><span class="lineno"> 3422</span>        strength = strength[0]</div>
<div class="line"><span class="lineno"> 3423</span>        phase = phase[0]</div>
<div class="line"><span class="lineno"> 3424</span>    <span class="keywordflow">return</span> strength, phase</div>
<div class="line"><span class="lineno"> 3425</span> </div>
<div class="line"><span class="lineno"> 3426</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0476eca003c6c8287ec76e76a593f81" name="ad0476eca003c6c8287ec76e76a593f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0476eca003c6c8287ec76e76a593f81">&#9670;&#160;</a></span>wiener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._signaltools.wiener </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mysize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noise</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a Wiener filter on an N-dimensional array.

Apply a Wiener filter to the N-dimensional array `im`.

Parameters
----------
im : ndarray
    An N-dimensional array.
mysize : int or array_like, optional
    A scalar or an N-length list giving the size of the Wiener filter
    window in each dimension.  Elements of mysize should be odd.
    If mysize is a scalar, then this scalar is used as the size
    in each dimension.
noise : float, optional
    The noise-power to use. If None, then noise is estimated as the
    average of the local variance of the input.

Returns
-------
out : ndarray
    Wiener filtered result with the same shape as `im`.

Examples
--------

&gt;&gt;&gt; from scipy.misc import face
&gt;&gt;&gt; from scipy.signal import wiener
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; img = rng.random((40, 40))    #Create a random image
&gt;&gt;&gt; filtered_img = wiener(img, (5, 5))  #Filter the image
&gt;&gt;&gt; f, (plot1, plot2) = plt.subplots(1, 2)
&gt;&gt;&gt; plot1.imshow(img)
&gt;&gt;&gt; plot2.imshow(filtered_img)
&gt;&gt;&gt; plt.show()

Notes
-----
This implementation is similar to wiener2 in Matlab/Octave.
For more details see [1]_

References
----------
.. [1] Lim, Jae S., Two-Dimensional Signal and Image Processing,
       Englewood Cliffs, NJ, Prentice Hall, 1990, p. 548.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1555</span><span class="keyword">def </span>wiener(im, mysize=None, noise=None):</div>
<div class="line"><span class="lineno"> 1556</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    Perform a Wiener filter on an N-dimensional array.</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    Apply a Wiener filter to the N-dimensional array `im`.</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1562</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1563</span><span class="stringliteral">    im : ndarray</span></div>
<div class="line"><span class="lineno"> 1564</span><span class="stringliteral">        An N-dimensional array.</span></div>
<div class="line"><span class="lineno"> 1565</span><span class="stringliteral">    mysize : int or array_like, optional</span></div>
<div class="line"><span class="lineno"> 1566</span><span class="stringliteral">        A scalar or an N-length list giving the size of the Wiener filter</span></div>
<div class="line"><span class="lineno"> 1567</span><span class="stringliteral">        window in each dimension.  Elements of mysize should be odd.</span></div>
<div class="line"><span class="lineno"> 1568</span><span class="stringliteral">        If mysize is a scalar, then this scalar is used as the size</span></div>
<div class="line"><span class="lineno"> 1569</span><span class="stringliteral">        in each dimension.</span></div>
<div class="line"><span class="lineno"> 1570</span><span class="stringliteral">    noise : float, optional</span></div>
<div class="line"><span class="lineno"> 1571</span><span class="stringliteral">        The noise-power to use. If None, then noise is estimated as the</span></div>
<div class="line"><span class="lineno"> 1572</span><span class="stringliteral">        average of the local variance of the input.</span></div>
<div class="line"><span class="lineno"> 1573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">        Wiener filtered result with the same shape as `im`.</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.misc import face</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import wiener</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">    &gt;&gt;&gt; img = rng.random((40, 40))    #Create a random image</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">    &gt;&gt;&gt; filtered_img = wiener(img, (5, 5))  #Filter the image</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">    &gt;&gt;&gt; f, (plot1, plot2) = plt.subplots(1, 2)</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">    &gt;&gt;&gt; plot1.imshow(img)</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">    &gt;&gt;&gt; plot2.imshow(filtered_img)</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">    This implementation is similar to wiener2 in Matlab/Octave.</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    For more details see [1]_</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    .. [1] Lim, Jae S., Two-Dimensional Signal and Image Processing,</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">           Englewood Cliffs, NJ, Prentice Hall, 1990, p. 548.</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1606</span>    im = np.asarray(im)</div>
<div class="line"><span class="lineno"> 1607</span>    <span class="keywordflow">if</span> mysize <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1608</span>        mysize = [3] * im.ndim</div>
<div class="line"><span class="lineno"> 1609</span>    mysize = np.asarray(mysize)</div>
<div class="line"><span class="lineno"> 1610</span>    <span class="keywordflow">if</span> mysize.shape == ():</div>
<div class="line"><span class="lineno"> 1611</span>        mysize = np.repeat(mysize.item(), im.ndim)</div>
<div class="line"><span class="lineno"> 1612</span> </div>
<div class="line"><span class="lineno"> 1613</span>    <span class="comment"># Estimate the local mean</span></div>
<div class="line"><span class="lineno"> 1614</span>    lMean = correlate(im, np.ones(mysize), <span class="stringliteral">&#39;same&#39;</span>) / np.prod(mysize, axis=0)</div>
<div class="line"><span class="lineno"> 1615</span> </div>
<div class="line"><span class="lineno"> 1616</span>    <span class="comment"># Estimate the local variance</span></div>
<div class="line"><span class="lineno"> 1617</span>    lVar = (correlate(im ** 2, np.ones(mysize), <span class="stringliteral">&#39;same&#39;</span>) /</div>
<div class="line"><span class="lineno"> 1618</span>            np.prod(mysize, axis=0) - lMean ** 2)</div>
<div class="line"><span class="lineno"> 1619</span> </div>
<div class="line"><span class="lineno"> 1620</span>    <span class="comment"># Estimate the noise power if needed.</span></div>
<div class="line"><span class="lineno"> 1621</span>    <span class="keywordflow">if</span> noise <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1622</span>        noise = np.mean(np.ravel(lVar), axis=0)</div>
<div class="line"><span class="lineno"> 1623</span> </div>
<div class="line"><span class="lineno"> 1624</span>    res = (im - lMean)</div>
<div class="line"><span class="lineno"> 1625</span>    res *= (1 - noise / lVar)</div>
<div class="line"><span class="lineno"> 1626</span>    res += lMean</div>
<div class="line"><span class="lineno"> 1627</span>    out = np.where(lVar &lt; noise, lMean, res)</div>
<div class="line"><span class="lineno"> 1628</span> </div>
<div class="line"><span class="lineno"> 1629</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1630</span> </div>
<div class="line"><span class="lineno"> 1631</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3c8b8d1a93c3a15e771f42a2a5b5bfe4" name="a3c8b8d1a93c3a15e771f42a2a5b5bfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8b8d1a93c3a15e771f42a2a5b5bfe4">&#9670;&#160;</a></span>_boundarydict</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.signal._signaltools._boundarydict</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {<span class="stringliteral">&#39;fill&#39;</span>: 0, <span class="stringliteral">&#39;pad&#39;</span>: 0, <span class="stringliteral">&#39;wrap&#39;</span>: 2, <span class="stringliteral">&#39;circular&#39;</span>: 2, <span class="stringliteral">&#39;symm&#39;</span>: 1,</div>
<div class="line"><span class="lineno">    2</span>                 <span class="stringliteral">&#39;symmetric&#39;</span>: 1, <span class="stringliteral">&#39;reflect&#39;</span>: 4}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a69b1e186f46823dbde0944345c69e2e9" name="a69b1e186f46823dbde0944345c69e2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b1e186f46823dbde0944345c69e2e9">&#9670;&#160;</a></span>_modedict</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.signal._signaltools._modedict = {'valid': 0, 'same': 1, 'full': 2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
