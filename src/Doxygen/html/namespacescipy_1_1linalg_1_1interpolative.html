<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.linalg.interpolative Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html">interpolative</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg.interpolative Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4fb3ea59847064aa9989ea6124a5796d" id="r_a4fb3ea59847064aa9989ea6124a5796d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a4fb3ea59847064aa9989ea6124a5796d">_is_real</a> (A)</td></tr>
<tr class="separator:a4fb3ea59847064aa9989ea6124a5796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6ef9338273531558891d959344d6ce" id="r_a9f6ef9338273531558891d959344d6ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a9f6ef9338273531558891d959344d6ce">seed</a> (seed=None)</td></tr>
<tr class="separator:a9f6ef9338273531558891d959344d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7c7f98406a3439f3bfe2639c25e81b" id="r_a7b7c7f98406a3439f3bfe2639c25e81b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a7b7c7f98406a3439f3bfe2639c25e81b">rand</a> (*shape)</td></tr>
<tr class="separator:a7b7c7f98406a3439f3bfe2639c25e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948cd2b78b135e151e443828198d3941" id="r_a948cd2b78b135e151e443828198d3941"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a948cd2b78b135e151e443828198d3941">interp_decomp</a> (A, eps_or_k, <a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a7b7c7f98406a3439f3bfe2639c25e81b">rand</a>=True)</td></tr>
<tr class="separator:a948cd2b78b135e151e443828198d3941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5045f8b26d217e31fb8d10bbd910212d" id="r_a5045f8b26d217e31fb8d10bbd910212d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a5045f8b26d217e31fb8d10bbd910212d">reconstruct_matrix_from_id</a> (B, <a class="el" href="__lapack__subroutines_8h.html#a0de1bc518c4a24bade63153311d1d7b2">idx</a>, proj)</td></tr>
<tr class="separator:a5045f8b26d217e31fb8d10bbd910212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f0c7a424f7138106e0725d1cc746a7" id="r_aa2f0c7a424f7138106e0725d1cc746a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#aa2f0c7a424f7138106e0725d1cc746a7">reconstruct_interp_matrix</a> (<a class="el" href="__lapack__subroutines_8h.html#a0de1bc518c4a24bade63153311d1d7b2">idx</a>, proj)</td></tr>
<tr class="separator:aa2f0c7a424f7138106e0725d1cc746a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab997412a72d02dbbdc80bcb97fd9db14" id="r_ab997412a72d02dbbdc80bcb97fd9db14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#ab997412a72d02dbbdc80bcb97fd9db14">reconstruct_skel_matrix</a> (A, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, <a class="el" href="__lapack__subroutines_8h.html#a0de1bc518c4a24bade63153311d1d7b2">idx</a>)</td></tr>
<tr class="separator:ab997412a72d02dbbdc80bcb97fd9db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa95af637150917e364566b6a2adf43" id="r_aafa95af637150917e364566b6a2adf43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#aafa95af637150917e364566b6a2adf43">id_to_svd</a> (B, <a class="el" href="__lapack__subroutines_8h.html#a0de1bc518c4a24bade63153311d1d7b2">idx</a>, proj)</td></tr>
<tr class="separator:aafa95af637150917e364566b6a2adf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3341ab319a203cb604789ac87b2cbc8" id="r_ac3341ab319a203cb604789ac87b2cbc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#ac3341ab319a203cb604789ac87b2cbc8">estimate_spectral_norm</a> (A, its=20)</td></tr>
<tr class="separator:ac3341ab319a203cb604789ac87b2cbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9aadc4c923636c2320dcbe90c9bccf" id="r_a5f9aadc4c923636c2320dcbe90c9bccf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a5f9aadc4c923636c2320dcbe90c9bccf">estimate_spectral_norm_diff</a> (A, B, its=20)</td></tr>
<tr class="separator:a5f9aadc4c923636c2320dcbe90c9bccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bd55842ec1ddf4fed755c084a997ae" id="r_aa2bd55842ec1ddf4fed755c084a997ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#aa2bd55842ec1ddf4fed755c084a997ae">svd</a> (A, eps_or_k, <a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a7b7c7f98406a3439f3bfe2639c25e81b">rand</a>=True)</td></tr>
<tr class="separator:aa2bd55842ec1ddf4fed755c084a997ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1de039032653265ae1b8972297f31" id="r_a6db1de039032653265ae1b8972297f31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a6db1de039032653265ae1b8972297f31">estimate_rank</a> (A, <a class="el" href="namespacescipy_1_1linalg_1_1__decomp__schur.html#a84a27b180b32ed86c577c790944251ea">eps</a>)</td></tr>
<tr class="separator:a6db1de039032653265ae1b8972297f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9c5a03194cead350b216713ab3c75d47" id="r_a9c5a03194cead350b216713ab3c75d47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a9c5a03194cead350b216713ab3c75d47">_DTYPE_ERROR</a> = ValueError(&quot;invalid input dtype (input must be float64 or complex128)&quot;)</td></tr>
<tr class="separator:a9c5a03194cead350b216713ab3c75d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc8965a5343d92631c03a1a311843f2" id="r_a9cc8965a5343d92631c03a1a311843f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a9cc8965a5343d92631c03a1a311843f2">_TYPE_ERROR</a> = TypeError(&quot;invalid input type (must be array or LinearOperator)&quot;)</td></tr>
<tr class="separator:a9cc8965a5343d92631c03a1a311843f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78d5b7ff33102edad82ce96f5b5dc3" id="r_a7d78d5b7ff33102edad82ce96f5b5dc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a7d78d5b7ff33102edad82ce96f5b5dc3">_32BIT_ERROR</a></td></tr>
<tr class="separator:a7d78d5b7ff33102edad82ce96f5b5dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e222cbbc77cc9d19cbb576a6f67a3d2" id="r_a8e222cbbc77cc9d19cbb576a6f67a3d2"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a8e222cbbc77cc9d19cbb576a6f67a3d2">_IS_32BIT</a> = (sys.maxsize &lt; 2**32)</td></tr>
<tr class="separator:a8e222cbbc77cc9d19cbb576a6f67a3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">======================================================================
Interpolative matrix decomposition (:mod:`scipy.linalg.interpolative`)
======================================================================

.. moduleauthor:: Kenneth L. Ho &lt;klho@stanford.edu&gt;

.. versionadded:: 0.13

.. currentmodule:: scipy.linalg.interpolative

An interpolative decomposition (ID) of a matrix :math:`A \in
\mathbb{C}^{m \times n}` of rank :math:`k \leq \min \{ m, n \}` is a
factorization

.. math::
  A \Pi =
  \begin{bmatrix}
   A \Pi_{1} &amp; A \Pi_{2}
  \end{bmatrix} =
  A \Pi_{1}
  \begin{bmatrix}
   I &amp; T
  \end{bmatrix},

where :math:`\Pi = [\Pi_{1}, \Pi_{2}]` is a permutation matrix with
:math:`\Pi_{1} \in \{ 0, 1 \}^{n \times k}`, i.e., :math:`A \Pi_{2} =
A \Pi_{1} T`. This can equivalently be written as :math:`A = BP`,
where :math:`B = A \Pi_{1}` and :math:`P = [I, T] \Pi^{\mathsf{T}}`
are the *skeleton* and *interpolation matrices*, respectively.

If :math:`A` does not have exact rank :math:`k`, then there exists an
approximation in the form of an ID such that :math:`A = BP + E`, where
:math:`\| E \| \sim \sigma_{k + 1}` is on the order of the :math:`(k +
1)`-th largest singular value of :math:`A`. Note that :math:`\sigma_{k
+ 1}` is the best possible error for a rank-:math:`k` approximation
and, in fact, is achieved by the singular value decomposition (SVD)
:math:`A \approx U S V^{*}`, where :math:`U \in \mathbb{C}^{m \times
k}` and :math:`V \in \mathbb{C}^{n \times k}` have orthonormal columns
and :math:`S = \mathop{\mathrm{diag}} (\sigma_{i}) \in \mathbb{C}^{k
\times k}` is diagonal with nonnegative entries. The principal
advantages of using an ID over an SVD are that:

- it is cheaper to construct;
- it preserves the structure of :math:`A`; and
- it is more efficient to compute with in light of the identity submatrix of :math:`P`.

Routines
========

Main functionality:

.. autosummary::
   :toctree: generated/

   interp_decomp
   reconstruct_matrix_from_id
   reconstruct_interp_matrix
   reconstruct_skel_matrix
   id_to_svd
   svd
   estimate_spectral_norm
   estimate_spectral_norm_diff
   estimate_rank

Support functions:

.. autosummary::
   :toctree: generated/

   seed
   rand


References
==========

This module uses the ID software package [1]_ by Martinsson, Rokhlin,
Shkolnisky, and Tygert, which is a Fortran library for computing IDs
using various algorithms, including the rank-revealing QR approach of
[2]_ and the more recent randomized methods described in [3]_, [4]_,
and [5]_. This module exposes its functionality in a way convenient
for Python users. Note that this module does not add any functionality
beyond that of organizing a simpler and more consistent interface.

We advise the user to consult also the `documentation for the ID package
&lt;http://tygert.com/id_doc.4.pdf&gt;`_.

.. [1] P.G. Martinsson, V. Rokhlin, Y. Shkolnisky, M. Tygert. "ID: a
    software package for low-rank approximation of matrices via interpolative
    decompositions, version 0.2." http://tygert.com/id_doc.4.pdf.

.. [2] H. Cheng, Z. Gimbutas, P.G. Martinsson, V. Rokhlin. "On the
    compression of low rank matrices." *SIAM J. Sci. Comput.* 26 (4): 1389--1404,
    2005. :doi:`10.1137/030602678`.

.. [3] E. Liberty, F. Woolfe, P.G. Martinsson, V. Rokhlin, M.
    Tygert. "Randomized algorithms for the low-rank approximation of matrices."
    *Proc. Natl. Acad. Sci. U.S.A.* 104 (51): 20167--20172, 2007.
    :doi:`10.1073/pnas.0709640104`.

.. [4] P.G. Martinsson, V. Rokhlin, M. Tygert. "A randomized
    algorithm for the decomposition of matrices." *Appl. Comput. Harmon. Anal.* 30
    (1): 47--68,  2011. :doi:`10.1016/j.acha.2010.02.003`.

.. [5] F. Woolfe, E. Liberty, V. Rokhlin, M. Tygert. "A fast
    randomized algorithm for the approximation of matrices." *Appl. Comput.
    Harmon. Anal.* 25 (3): 335--366, 2008. :doi:`10.1016/j.acha.2007.12.002`.


Tutorial
========

Initializing
------------

The first step is to import :mod:`scipy.linalg.interpolative` by issuing the
command:

&gt;&gt;&gt; import scipy.linalg.interpolative as sli

Now let's build a matrix. For this, we consider a Hilbert matrix, which is well
know to have low rank:

&gt;&gt;&gt; from scipy.linalg import hilbert
&gt;&gt;&gt; n = 1000
&gt;&gt;&gt; A = hilbert(n)

We can also do this explicitly via:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n = 1000
&gt;&gt;&gt; A = np.empty((n, n), order='F')
&gt;&gt;&gt; for j in range(n):
&gt;&gt;&gt;     for i in range(n):
&gt;&gt;&gt;         A[i,j] = 1. / (i + j + 1)

Note the use of the flag ``order='F'`` in :func:`numpy.empty`. This
instantiates the matrix in Fortran-contiguous order and is important for
avoiding data copying when passing to the backend.

We then define multiplication routines for the matrix by regarding it as a
:class:`scipy.sparse.linalg.LinearOperator`:

&gt;&gt;&gt; from scipy.sparse.linalg import aslinearoperator
&gt;&gt;&gt; L = aslinearoperator(A)

This automatically sets up methods describing the action of the matrix and its
adjoint on a vector.

Computing an ID
---------------

We have several choices of algorithm to compute an ID. These fall largely
according to two dichotomies:

1. how the matrix is represented, i.e., via its entries or via its action on a
   vector; and
2. whether to approximate it to a fixed relative precision or to a fixed rank.

We step through each choice in turn below.

In all cases, the ID is represented by three parameters:

1. a rank ``k``;
2. an index array ``idx``; and
3. interpolation coefficients ``proj``.

The ID is specified by the relation
``np.dot(A[:,idx[:k]], proj) == A[:,idx[k:]]``.

From matrix entries
...................

We first consider a matrix given in terms of its entries.

To compute an ID to a fixed precision, type:

&gt;&gt;&gt; k, idx, proj = sli.interp_decomp(A, eps)

where ``eps &lt; 1`` is the desired precision.

To compute an ID to a fixed rank, use:

&gt;&gt;&gt; idx, proj = sli.interp_decomp(A, k)

where ``k &gt;= 1`` is the desired rank.

Both algorithms use random sampling and are usually faster than the
corresponding older, deterministic algorithms, which can be accessed via the
commands:

&gt;&gt;&gt; k, idx, proj = sli.interp_decomp(A, eps, rand=False)

and:

&gt;&gt;&gt; idx, proj = sli.interp_decomp(A, k, rand=False)

respectively.

From matrix action
..................

Now consider a matrix given in terms of its action on a vector as a
:class:`scipy.sparse.linalg.LinearOperator`.

To compute an ID to a fixed precision, type:

&gt;&gt;&gt; k, idx, proj = sli.interp_decomp(L, eps)

To compute an ID to a fixed rank, use:

&gt;&gt;&gt; idx, proj = sli.interp_decomp(L, k)

These algorithms are randomized.

Reconstructing an ID
--------------------

The ID routines above do not output the skeleton and interpolation matrices
explicitly but instead return the relevant information in a more compact (and
sometimes more useful) form. To build these matrices, write:

&gt;&gt;&gt; B = sli.reconstruct_skel_matrix(A, k, idx)

for the skeleton matrix and:

&gt;&gt;&gt; P = sli.reconstruct_interp_matrix(idx, proj)

for the interpolation matrix. The ID approximation can then be computed as:

&gt;&gt;&gt; C = np.dot(B, P)

This can also be constructed directly using:

&gt;&gt;&gt; C = sli.reconstruct_matrix_from_id(B, idx, proj)

without having to first compute ``P``.

Alternatively, this can be done explicitly as well using:

&gt;&gt;&gt; B = A[:,idx[:k]]
&gt;&gt;&gt; P = np.hstack([np.eye(k), proj])[:,np.argsort(idx)]
&gt;&gt;&gt; C = np.dot(B, P)

Computing an SVD
----------------

An ID can be converted to an SVD via the command:

&gt;&gt;&gt; U, S, V = sli.id_to_svd(B, idx, proj)

The SVD approximation is then:

&gt;&gt;&gt; C = np.dot(U, np.dot(np.diag(S), np.dot(V.conj().T)))

The SVD can also be computed "fresh" by combining both the ID and conversion
steps into one command. Following the various ID algorithms above, there are
correspondingly various SVD algorithms that one can employ.

From matrix entries
...................

We consider first SVD algorithms for a matrix given in terms of its entries.

To compute an SVD to a fixed precision, type:

&gt;&gt;&gt; U, S, V = sli.svd(A, eps)

To compute an SVD to a fixed rank, use:

&gt;&gt;&gt; U, S, V = sli.svd(A, k)

Both algorithms use random sampling; for the determinstic versions, issue the
keyword ``rand=False`` as above.

From matrix action
..................

Now consider a matrix given in terms of its action on a vector.

To compute an SVD to a fixed precision, type:

&gt;&gt;&gt; U, S, V = sli.svd(L, eps)

To compute an SVD to a fixed rank, use:

&gt;&gt;&gt; U, S, V = sli.svd(L, k)

Utility routines
----------------

Several utility routines are also available.

To estimate the spectral norm of a matrix, use:

&gt;&gt;&gt; snorm = sli.estimate_spectral_norm(A)

This algorithm is based on the randomized power method and thus requires only
matrix-vector products. The number of iterations to take can be set using the
keyword ``its`` (default: ``its=20``). The matrix is interpreted as a
:class:`scipy.sparse.linalg.LinearOperator`, but it is also valid to supply it
as a :class:`numpy.ndarray`, in which case it is trivially converted using
:func:`scipy.sparse.linalg.aslinearoperator`.

The same algorithm can also estimate the spectral norm of the difference of two
matrices ``A1`` and ``A2`` as follows:

&gt;&gt;&gt; diff = sli.estimate_spectral_norm_diff(A1, A2)

This is often useful for checking the accuracy of a matrix approximation.

Some routines in :mod:`scipy.linalg.interpolative` require estimating the rank
of a matrix as well. This can be done with either:

&gt;&gt;&gt; k = sli.estimate_rank(A, eps)

or:

&gt;&gt;&gt; k = sli.estimate_rank(L, eps)

depending on the representation. The parameter ``eps`` controls the definition
of the numerical rank.

Finally, the random number generation required for all randomized routines can
be controlled via :func:`scipy.linalg.interpolative.seed`. To reset the seed
values to their original values, use:

&gt;&gt;&gt; sli.seed('default')

To specify the seed values, use:

&gt;&gt;&gt; sli.seed(s)

where ``s`` must be an integer or array of 55 floats. If an integer, the array
of floats is obtained by using ``numpy.random.rand`` with the given integer
seed.

To simply generate some random numbers, type:

&gt;&gt;&gt; sli.rand(n)

where ``n`` is the number of random numbers to generate.

Remarks
-------

The above functions all automatically detect the appropriate interface and work
with both real and complex data types, passing input arguments to the proper
backend routine.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a4fb3ea59847064aa9989ea6124a5796d" name="a4fb3ea59847064aa9989ea6124a5796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb3ea59847064aa9989ea6124a5796d">&#9670;&#160;</a></span>_is_real()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative._is_real </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  410</span><span class="keyword">def </span>_is_real(A):</div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  412</span>        <span class="keywordflow">if</span> A.dtype == np.complex128:</div>
<div class="line"><span class="lineno">  413</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  414</span>        <span class="keywordflow">elif</span> A.dtype == np.float64:</div>
<div class="line"><span class="lineno">  415</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  416</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  417</span>            <span class="keywordflow">raise</span> _DTYPE_ERROR</div>
<div class="line"><span class="lineno">  418</span>    <span class="keywordflow">except</span> AttributeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">raise</span> _TYPE_ERROR <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  420</span> </div>
<div class="line"><span class="lineno">  421</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6db1de039032653265ae1b8972297f31" name="a6db1de039032653265ae1b8972297f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db1de039032653265ae1b8972297f31">&#9670;&#160;</a></span>estimate_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.estimate_rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate matrix rank to a specified relative precision using randomized
methods.

The matrix `A` can be given as either a :class:`numpy.ndarray` or a
:class:`scipy.sparse.linalg.LinearOperator`, with different algorithms used
for each case. If `A` is of type :class:`numpy.ndarray`, then the output
rank is typically about 8 higher than the actual numerical rank.

..  This function automatically detects the form of the input parameters and
    passes them to the appropriate backend. For details,
    see :func:`_backend.idd_estrank`, :func:`_backend.idd_findrank`,
    :func:`_backend.idz_estrank`, and :func:`_backend.idz_findrank`.

Parameters
----------
A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator`
    Matrix whose rank is to be estimated, given as either a
    :class:`numpy.ndarray` or a :class:`scipy.sparse.linalg.LinearOperator`
    with the `rmatvec` method (to apply the matrix adjoint).
eps : float
    Relative error for numerical rank definition.

Returns
-------
int
    Estimated matrix rank.
</pre> <div class="fragment"><div class="line"><span class="lineno">  954</span><span class="keyword">def </span>estimate_rank(A, eps):</div>
<div class="line"><span class="lineno">  955</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    Estimate matrix rank to a specified relative precision using randomized</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    methods.</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    The matrix `A` can be given as either a :class:`numpy.ndarray` or a</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    :class:`scipy.sparse.linalg.LinearOperator`, with different algorithms used</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    for each case. If `A` is of type :class:`numpy.ndarray`, then the output</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    rank is typically about 8 higher than the actual numerical rank.</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    ..  This function automatically detects the form of the input parameters and</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">        passes them to the appropriate backend. For details,</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">        see :func:`_backend.idd_estrank`, :func:`_backend.idd_findrank`,</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">        :func:`_backend.idz_estrank`, and :func:`_backend.idz_findrank`.</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator`</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">        Matrix whose rank is to be estimated, given as either a</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">        :class:`numpy.ndarray` or a :class:`scipy.sparse.linalg.LinearOperator`</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        with the `rmatvec` method (to apply the matrix adjoint).</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    eps : float</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">        Relative error for numerical rank definition.</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    int</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">        Estimated matrix rank.</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  983</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1sparse_1_1linalg.html">scipy.sparse.linalg</a> <span class="keyword">import</span> LinearOperator</div>
<div class="line"><span class="lineno">  984</span> </div>
<div class="line"><span class="lineno">  985</span>    real = _is_real(A)</div>
<div class="line"><span class="lineno">  986</span> </div>
<div class="line"><span class="lineno">  987</span>    <span class="keywordflow">if</span> isinstance(A, np.ndarray):</div>
<div class="line"><span class="lineno">  988</span>        <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  989</span>            rank = _backend.idd_estrank(eps, A)</div>
<div class="line"><span class="lineno">  990</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  991</span>            rank = _backend.idz_estrank(eps, A)</div>
<div class="line"><span class="lineno">  992</span>        <span class="keywordflow">if</span> rank == 0:</div>
<div class="line"><span class="lineno">  993</span>            <span class="comment"># special return value for nearly full rank</span></div>
<div class="line"><span class="lineno">  994</span>            rank = min(A.shape)</div>
<div class="line"><span class="lineno">  995</span>        <span class="keywordflow">return</span> rank</div>
<div class="line"><span class="lineno">  996</span>    <span class="keywordflow">elif</span> isinstance(A, LinearOperator):</div>
<div class="line"><span class="lineno">  997</span>        m, n = A.shape</div>
<div class="line"><span class="lineno">  998</span>        matveca = A.rmatvec</div>
<div class="line"><span class="lineno">  999</span>        <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno"> 1000</span>            <span class="keywordflow">return</span> _backend.idd_findrank(eps, m, n, matveca)</div>
<div class="line"><span class="lineno"> 1001</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1002</span>            <span class="keywordflow">return</span> _backend.idz_findrank(eps, m, n, matveca)</div>
<div class="line"><span class="lineno"> 1003</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1004</span>        <span class="keywordflow">raise</span> _TYPE_ERROR</div>
<div class="ttc" id="anamespacescipy_1_1sparse_1_1linalg_html"><div class="ttname"><a href="namespacescipy_1_1sparse_1_1linalg.html">scipy.sparse.linalg</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac3341ab319a203cb604789ac87b2cbc8" name="ac3341ab319a203cb604789ac87b2cbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3341ab319a203cb604789ac87b2cbc8">&#9670;&#160;</a></span>estimate_spectral_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.estimate_spectral_norm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of a matrix by the randomized power method.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`_backend.idd_snorm` and
    :func:`_backend.idz_snorm`.

Parameters
----------
A : :class:`scipy.sparse.linalg.LinearOperator`
    Matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the
    `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).
its : int, optional
    Number of power method iterations.

Returns
-------
float
    Spectral norm estimate.
</pre> <div class="fragment"><div class="line"><span class="lineno">  773</span><span class="keyword">def </span>estimate_spectral_norm(A, its=20):</div>
<div class="line"><span class="lineno">  774</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    Estimate spectral norm of a matrix by the randomized power method.</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    ..  This function automatically detects the matrix data type and calls the</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">        appropriate backend. For details, see :func:`_backend.idd_snorm` and</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        :func:`_backend.idz_snorm`.</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    A : :class:`scipy.sparse.linalg.LinearOperator`</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        Matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    its : int, optional</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        Number of power method iterations.</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    float</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        Spectral norm estimate.</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  794</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1sparse_1_1linalg.html">scipy.sparse.linalg</a> <span class="keyword">import</span> aslinearoperator</div>
<div class="line"><span class="lineno">  795</span>    A = aslinearoperator(A)</div>
<div class="line"><span class="lineno">  796</span>    m, n = A.shape</div>
<div class="line"><span class="lineno">  797</span>    matvec = <span class="keyword">lambda</span> x: A. matvec(x)</div>
<div class="line"><span class="lineno">  798</span>    matveca = <span class="keyword">lambda</span> x: A.rmatvec(x)</div>
<div class="line"><span class="lineno">  799</span>    <span class="keywordflow">if</span> _is_real(A):</div>
<div class="line"><span class="lineno">  800</span>        <span class="keywordflow">return</span> _backend.idd_snorm(m, n, matveca, matvec, its=its)</div>
<div class="line"><span class="lineno">  801</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  802</span>        <span class="keywordflow">return</span> _backend.idz_snorm(m, n, matveca, matvec, its=its)</div>
<div class="line"><span class="lineno">  803</span> </div>
<div class="line"><span class="lineno">  804</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f9aadc4c923636c2320dcbe90c9bccf" name="a5f9aadc4c923636c2320dcbe90c9bccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9aadc4c923636c2320dcbe90c9bccf">&#9670;&#160;</a></span>estimate_spectral_norm_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.estimate_spectral_norm_diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of the difference of two matrices by the randomized
power method.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`_backend.idd_diffsnorm` and
    :func:`_backend.idz_diffsnorm`.

Parameters
----------
A : :class:`scipy.sparse.linalg.LinearOperator`
    First matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the
    `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).
B : :class:`scipy.sparse.linalg.LinearOperator`
    Second matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with
    the `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).
its : int, optional
    Number of power method iterations.

Returns
-------
float
    Spectral norm estimate of matrix difference.
</pre> <div class="fragment"><div class="line"><span class="lineno">  805</span><span class="keyword">def </span>estimate_spectral_norm_diff(A, B, its=20):</div>
<div class="line"><span class="lineno">  806</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    Estimate spectral norm of the difference of two matrices by the randomized</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    power method.</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    ..  This function automatically detects the matrix data type and calls the</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        appropriate backend. For details, see :func:`_backend.idd_diffsnorm` and</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">        :func:`_backend.idz_diffsnorm`.</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    A : :class:`scipy.sparse.linalg.LinearOperator`</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        First matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">        `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    B : :class:`scipy.sparse.linalg.LinearOperator`</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">        Second matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        the `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    its : int, optional</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">        Number of power method iterations.</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    float</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        Spectral norm estimate of matrix difference.</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  830</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1sparse_1_1linalg.html">scipy.sparse.linalg</a> <span class="keyword">import</span> aslinearoperator</div>
<div class="line"><span class="lineno">  831</span>    A = aslinearoperator(A)</div>
<div class="line"><span class="lineno">  832</span>    B = aslinearoperator(B)</div>
<div class="line"><span class="lineno">  833</span>    m, n = A.shape</div>
<div class="line"><span class="lineno">  834</span>    matvec1 = <span class="keyword">lambda</span> x: A. matvec(x)</div>
<div class="line"><span class="lineno">  835</span>    matveca1 = <span class="keyword">lambda</span> x: A.rmatvec(x)</div>
<div class="line"><span class="lineno">  836</span>    matvec2 = <span class="keyword">lambda</span> x: B. matvec(x)</div>
<div class="line"><span class="lineno">  837</span>    matveca2 = <span class="keyword">lambda</span> x: B.rmatvec(x)</div>
<div class="line"><span class="lineno">  838</span>    <span class="keywordflow">if</span> _is_real(A):</div>
<div class="line"><span class="lineno">  839</span>        <span class="keywordflow">return</span> _backend.idd_diffsnorm(</div>
<div class="line"><span class="lineno">  840</span>            m, n, matveca1, matveca2, matvec1, matvec2, its=its)</div>
<div class="line"><span class="lineno">  841</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  842</span>        <span class="keywordflow">return</span> _backend.idz_diffsnorm(</div>
<div class="line"><span class="lineno">  843</span>            m, n, matveca1, matveca2, matvec1, matvec2, its=its)</div>
<div class="line"><span class="lineno">  844</span> </div>
<div class="line"><span class="lineno">  845</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aafa95af637150917e364566b6a2adf43" name="aafa95af637150917e364566b6a2adf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa95af637150917e364566b6a2adf43">&#9670;&#160;</a></span>id_to_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.id_to_svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert ID to SVD.

The SVD reconstruction of a matrix with skeleton matrix `B` and ID indices and
coefficients `idx` and `proj`, respectively, is::

    U, S, V = id_to_svd(B, idx, proj)
    A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))

See also :func:`svd`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`_backend.idd_id2svd` and
    :func:`_backend.idz_id2svd`.

Parameters
----------
B : :class:`numpy.ndarray`
    Skeleton matrix.
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.

Returns
-------
U : :class:`numpy.ndarray`
    Left singular vectors.
S : :class:`numpy.ndarray`
    Singular values.
V : :class:`numpy.ndarray`
    Right singular vectors.
</pre> <div class="fragment"><div class="line"><span class="lineno">  732</span><span class="keyword">def </span>id_to_svd(B, idx, proj):</div>
<div class="line"><span class="lineno">  733</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    Convert ID to SVD.</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    The SVD reconstruction of a matrix with skeleton matrix `B` and ID indices and</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    coefficients `idx` and `proj`, respectively, is::</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        U, S, V = id_to_svd(B, idx, proj)</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    See also :func:`svd`.</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    ..  This function automatically detects the matrix data type and calls the</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        appropriate backend. For details, see :func:`_backend.idd_id2svd` and</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        :func:`_backend.idz_id2svd`.</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    B : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        Skeleton matrix.</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    idx : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        Column index array.</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    proj : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        Interpolation coefficients.</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    U : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        Left singular vectors.</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    S : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        Singular values.</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    V : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        Right singular vectors.</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  766</span>    <span class="keywordflow">if</span> _is_real(B):</div>
<div class="line"><span class="lineno">  767</span>        U, V, S = _backend.idd_id2svd(B, idx + 1, proj)</div>
<div class="line"><span class="lineno">  768</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  769</span>        U, V, S = _backend.idz_id2svd(B, idx + 1, proj)</div>
<div class="line"><span class="lineno">  770</span>    <span class="keywordflow">return</span> U, S, V</div>
<div class="line"><span class="lineno">  771</span> </div>
<div class="line"><span class="lineno">  772</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a948cd2b78b135e151e443828198d3941" name="a948cd2b78b135e151e443828198d3941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948cd2b78b135e151e443828198d3941">&#9670;&#160;</a></span>interp_decomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.interp_decomp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps_or_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rand</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a matrix.

An ID of a matrix `A` is a factorization defined by a rank `k`, a column
index array `idx`, and interpolation coefficients `proj` such that::

    numpy.dot(A[:,idx[:k]], proj) = A[:,idx[k:]]

The original matrix can then be reconstructed as::

    numpy.hstack([A[:,idx[:k]],
                                numpy.dot(A[:,idx[:k]], proj)]
                            )[:,numpy.argsort(idx)]

or via the routine :func:`reconstruct_matrix_from_id`. This can
equivalently be written as::

    numpy.dot(A[:,idx[:k]],
                        numpy.hstack([numpy.eye(k), proj])
                      )[:,np.argsort(idx)]

in terms of the skeleton and interpolation matrices::

    B = A[:,idx[:k]]

and::

    P = numpy.hstack([numpy.eye(k), proj])[:,np.argsort(idx)]

respectively. See also :func:`reconstruct_interp_matrix` and
:func:`reconstruct_skel_matrix`.

The ID can be computed to any relative precision or rank (depending on the
value of `eps_or_k`). If a precision is specified (`eps_or_k &lt; 1`), then
this function has the output signature::

    k, idx, proj = interp_decomp(A, eps_or_k)

Otherwise, if a rank is specified (`eps_or_k &gt;= 1`), then the output
signature is::

    idx, proj = interp_decomp(A, eps_or_k)

..  This function automatically detects the form of the input parameters
    and passes them to the appropriate backend. For details, see
    :func:`_backend.iddp_id`, :func:`_backend.iddp_aid`,
    :func:`_backend.iddp_rid`, :func:`_backend.iddr_id`,
    :func:`_backend.iddr_aid`, :func:`_backend.iddr_rid`,
    :func:`_backend.idzp_id`, :func:`_backend.idzp_aid`,
    :func:`_backend.idzp_rid`, :func:`_backend.idzr_id`,
    :func:`_backend.idzr_aid`, and :func:`_backend.idzr_rid`.

Parameters
----------
A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator` with `rmatvec`
    Matrix to be factored
eps_or_k : float or int
    Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of
    approximation.
rand : bool, optional
    Whether to use random sampling if `A` is of type :class:`numpy.ndarray`
    (randomized algorithms are always used if `A` is of type
    :class:`scipy.sparse.linalg.LinearOperator`).

Returns
-------
k : int
    Rank required to achieve specified relative precision if
    `eps_or_k &lt; 1`.
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.
</pre> <div class="fragment"><div class="line"><span class="lineno">  482</span><span class="keyword">def </span>interp_decomp(A, eps_or_k, rand=True):</div>
<div class="line"><span class="lineno">  483</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    Compute ID of a matrix.</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    An ID of a matrix `A` is a factorization defined by a rank `k`, a column</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    index array `idx`, and interpolation coefficients `proj` such that::</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">        numpy.dot(A[:,idx[:k]], proj) = A[:,idx[k:]]</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    The original matrix can then be reconstructed as::</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        numpy.hstack([A[:,idx[:k]],</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">                                    numpy.dot(A[:,idx[:k]], proj)]</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">                                )[:,numpy.argsort(idx)]</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    or via the routine :func:`reconstruct_matrix_from_id`. This can</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    equivalently be written as::</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        numpy.dot(A[:,idx[:k]],</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">                            numpy.hstack([numpy.eye(k), proj])</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">                          )[:,np.argsort(idx)]</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    in terms of the skeleton and interpolation matrices::</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        B = A[:,idx[:k]]</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    and::</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        P = numpy.hstack([numpy.eye(k), proj])[:,np.argsort(idx)]</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    respectively. See also :func:`reconstruct_interp_matrix` and</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    :func:`reconstruct_skel_matrix`.</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    The ID can be computed to any relative precision or rank (depending on the</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    value of `eps_or_k`). If a precision is specified (`eps_or_k &lt; 1`), then</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    this function has the output signature::</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        k, idx, proj = interp_decomp(A, eps_or_k)</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    Otherwise, if a rank is specified (`eps_or_k &gt;= 1`), then the output</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    signature is::</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        idx, proj = interp_decomp(A, eps_or_k)</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    ..  This function automatically detects the form of the input parameters</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        and passes them to the appropriate backend. For details, see</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">        :func:`_backend.iddp_id`, :func:`_backend.iddp_aid`,</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        :func:`_backend.iddp_rid`, :func:`_backend.iddr_id`,</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        :func:`_backend.iddr_aid`, :func:`_backend.iddr_rid`,</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        :func:`_backend.idzp_id`, :func:`_backend.idzp_aid`,</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        :func:`_backend.idzp_rid`, :func:`_backend.idzr_id`,</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        :func:`_backend.idzr_aid`, and :func:`_backend.idzr_rid`.</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator` with `rmatvec`</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">        Matrix to be factored</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    eps_or_k : float or int</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">        Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        approximation.</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    rand : bool, optional</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        Whether to use random sampling if `A` is of type :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        (randomized algorithms are always used if `A` is of type</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        :class:`scipy.sparse.linalg.LinearOperator`).</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">        Rank required to achieve specified relative precision if</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        `eps_or_k &lt; 1`.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    idx : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        Column index array.</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    proj : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">        Interpolation coefficients.</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  557</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1sparse_1_1linalg.html">scipy.sparse.linalg</a> <span class="keyword">import</span> LinearOperator</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>    real = _is_real(A)</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>    <span class="keywordflow">if</span> isinstance(A, np.ndarray):</div>
<div class="line"><span class="lineno">  562</span>        <span class="keywordflow">if</span> eps_or_k &lt; 1:</div>
<div class="line"><span class="lineno">  563</span>            eps = eps_or_k</div>
<div class="line"><span class="lineno">  564</span>            <span class="keywordflow">if</span> rand:</div>
<div class="line"><span class="lineno">  565</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  566</span>                    k, idx, proj = _backend.iddp_aid(eps, A)</div>
<div class="line"><span class="lineno">  567</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  568</span>                    <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  569</span>                        <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  570</span>                    k, idx, proj = _backend.idzp_aid(eps, A)</div>
<div class="line"><span class="lineno">  571</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  572</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  573</span>                    k, idx, proj = _backend.iddp_id(eps, A)</div>
<div class="line"><span class="lineno">  574</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  575</span>                    k, idx, proj = _backend.idzp_id(eps, A)</div>
<div class="line"><span class="lineno">  576</span>            <span class="keywordflow">return</span> k, idx - 1, proj</div>
<div class="line"><span class="lineno">  577</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  578</span>            k = int(eps_or_k)</div>
<div class="line"><span class="lineno">  579</span>            <span class="keywordflow">if</span> rand:</div>
<div class="line"><span class="lineno">  580</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  581</span>                    idx, proj = _backend.iddr_aid(A, k)</div>
<div class="line"><span class="lineno">  582</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  583</span>                    <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  584</span>                        <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  585</span>                    idx, proj = _backend.idzr_aid(A, k)</div>
<div class="line"><span class="lineno">  586</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  587</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  588</span>                    idx, proj = _backend.iddr_id(A, k)</div>
<div class="line"><span class="lineno">  589</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  590</span>                    idx, proj = _backend.idzr_id(A, k)</div>
<div class="line"><span class="lineno">  591</span>            <span class="keywordflow">return</span> idx - 1, proj</div>
<div class="line"><span class="lineno">  592</span>    <span class="keywordflow">elif</span> isinstance(A, LinearOperator):</div>
<div class="line"><span class="lineno">  593</span>        m, n = A.shape</div>
<div class="line"><span class="lineno">  594</span>        matveca = A.rmatvec</div>
<div class="line"><span class="lineno">  595</span>        <span class="keywordflow">if</span> eps_or_k &lt; 1:</div>
<div class="line"><span class="lineno">  596</span>            eps = eps_or_k</div>
<div class="line"><span class="lineno">  597</span>            <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  598</span>                k, idx, proj = _backend.iddp_rid(eps, m, n, matveca)</div>
<div class="line"><span class="lineno">  599</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  600</span>                <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  601</span>                    <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  602</span>                k, idx, proj = _backend.idzp_rid(eps, m, n, matveca)</div>
<div class="line"><span class="lineno">  603</span>            <span class="keywordflow">return</span> k, idx - 1, proj</div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  605</span>            k = int(eps_or_k)</div>
<div class="line"><span class="lineno">  606</span>            <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  607</span>                idx, proj = _backend.iddr_rid(m, n, matveca, k)</div>
<div class="line"><span class="lineno">  608</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  609</span>                <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  610</span>                    <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  611</span>                idx, proj = _backend.idzr_rid(m, n, matveca, k)</div>
<div class="line"><span class="lineno">  612</span>            <span class="keywordflow">return</span> idx - 1, proj</div>
<div class="line"><span class="lineno">  613</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  614</span>        <span class="keywordflow">raise</span> _TYPE_ERROR</div>
<div class="line"><span class="lineno">  615</span> </div>
<div class="line"><span class="lineno">  616</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b7c7f98406a3439f3bfe2639c25e81b" name="a7b7c7f98406a3439f3bfe2639c25e81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7c7f98406a3439f3bfe2639c25e81b">&#9670;&#160;</a></span>rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.rand </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate standard uniform pseudorandom numbers via a very efficient lagged
Fibonacci method.

This routine is used for all random number generation in this package and
can affect ID and SVD results.

Parameters
----------
*shape
    Shape of output array</pre> <div class="fragment"><div class="line"><span class="lineno">  464</span><span class="keyword">def </span>rand(*shape):</div>
<div class="line"><span class="lineno">  465</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    Generate standard uniform pseudorandom numbers via a very efficient lagged</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    Fibonacci method.</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    This routine is used for all random number generation in this package and</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    can affect ID and SVD results.</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    *shape</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        Shape of output array</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  478</span>    <span class="comment"># For details, see :func:`_backend.id_srand`, and :func:`_backend.id_srando`.</span></div>
<div class="line"><span class="lineno">  479</span>    <span class="keywordflow">return</span> _backend.id_srand(np.prod(shape)).reshape(shape)</div>
<div class="line"><span class="lineno">  480</span> </div>
<div class="line"><span class="lineno">  481</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2f0c7a424f7138106e0725d1cc746a7" name="aa2f0c7a424f7138106e0725d1cc746a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f0c7a424f7138106e0725d1cc746a7">&#9670;&#160;</a></span>reconstruct_interp_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.reconstruct_interp_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct interpolation matrix from ID.

The interpolation matrix can be reconstructed from the ID indices and
coefficients `idx` and `proj`, respectively, as::

    P = numpy.hstack([numpy.eye(proj.shape[0]), proj])[:,numpy.argsort(idx)]

The original matrix can then be reconstructed from its skeleton matrix `B`
via::

    numpy.dot(B, P)

See also :func:`reconstruct_matrix_from_id` and
:func:`reconstruct_skel_matrix`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`_backend.idd_reconint` and
    :func:`_backend.idz_reconint`.

Parameters
----------
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.

Returns
-------
:class:`numpy.ndarray`
    Interpolation matrix.
</pre> <div class="fragment"><div class="line"><span class="lineno">  653</span><span class="keyword">def </span>reconstruct_interp_matrix(idx, proj):</div>
<div class="line"><span class="lineno">  654</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    Reconstruct interpolation matrix from ID.</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    The interpolation matrix can be reconstructed from the ID indices and</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">    coefficients `idx` and `proj`, respectively, as::</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        P = numpy.hstack([numpy.eye(proj.shape[0]), proj])[:,numpy.argsort(idx)]</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    The original matrix can then be reconstructed from its skeleton matrix `B`</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    via::</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        numpy.dot(B, P)</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    See also :func:`reconstruct_matrix_from_id` and</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    :func:`reconstruct_skel_matrix`.</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    ..  This function automatically detects the matrix data type and calls the</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        appropriate backend. For details, see :func:`_backend.idd_reconint` and</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        :func:`_backend.idz_reconint`.</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    idx : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        Column index array.</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    proj : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">        Interpolation coefficients.</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">        Interpolation matrix.</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  686</span>    <span class="keywordflow">if</span> _is_real(proj):</div>
<div class="line"><span class="lineno">  687</span>        <span class="keywordflow">return</span> _backend.idd_reconint(idx + 1, proj)</div>
<div class="line"><span class="lineno">  688</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  689</span>        <span class="keywordflow">return</span> _backend.idz_reconint(idx + 1, proj)</div>
<div class="line"><span class="lineno">  690</span> </div>
<div class="line"><span class="lineno">  691</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5045f8b26d217e31fb8d10bbd910212d" name="a5045f8b26d217e31fb8d10bbd910212d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5045f8b26d217e31fb8d10bbd910212d">&#9670;&#160;</a></span>reconstruct_matrix_from_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.reconstruct_matrix_from_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct matrix from its ID.

A matrix `A` with skeleton matrix `B` and ID indices and coefficients `idx`
and `proj`, respectively, can be reconstructed as::

    numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)]

See also :func:`reconstruct_interp_matrix` and
:func:`reconstruct_skel_matrix`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`_backend.idd_reconid` and
    :func:`_backend.idz_reconid`.

Parameters
----------
B : :class:`numpy.ndarray`
    Skeleton matrix.
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.

Returns
-------
:class:`numpy.ndarray`
    Reconstructed matrix.
</pre> <div class="fragment"><div class="line"><span class="lineno">  617</span><span class="keyword">def </span>reconstruct_matrix_from_id(B, idx, proj):</div>
<div class="line"><span class="lineno">  618</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    Reconstruct matrix from its ID.</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    A matrix `A` with skeleton matrix `B` and ID indices and coefficients `idx`</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    and `proj`, respectively, can be reconstructed as::</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)]</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    See also :func:`reconstruct_interp_matrix` and</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    :func:`reconstruct_skel_matrix`.</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    ..  This function automatically detects the matrix data type and calls the</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        appropriate backend. For details, see :func:`_backend.idd_reconid` and</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        :func:`_backend.idz_reconid`.</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    B : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">        Skeleton matrix.</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    idx : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">        Column index array.</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    proj : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">        Interpolation coefficients.</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">        Reconstructed matrix.</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  647</span>    <span class="keywordflow">if</span> _is_real(B):</div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">return</span> _backend.idd_reconid(B, idx + 1, proj)</div>
<div class="line"><span class="lineno">  649</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  650</span>        <span class="keywordflow">return</span> _backend.idz_reconid(B, idx + 1, proj)</div>
<div class="line"><span class="lineno">  651</span> </div>
<div class="line"><span class="lineno">  652</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab997412a72d02dbbdc80bcb97fd9db14" name="ab997412a72d02dbbdc80bcb97fd9db14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab997412a72d02dbbdc80bcb97fd9db14">&#9670;&#160;</a></span>reconstruct_skel_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.reconstruct_skel_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct skeleton matrix from ID.

The skeleton matrix can be reconstructed from the original matrix `A` and its
ID rank and indices `k` and `idx`, respectively, as::

    B = A[:,idx[:k]]

The original matrix can then be reconstructed via::

    numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)]

See also :func:`reconstruct_matrix_from_id` and
:func:`reconstruct_interp_matrix`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`_backend.idd_copycols` and
    :func:`_backend.idz_copycols`.

Parameters
----------
A : :class:`numpy.ndarray`
    Original matrix.
k : int
    Rank of ID.
idx : :class:`numpy.ndarray`
    Column index array.

Returns
-------
:class:`numpy.ndarray`
    Skeleton matrix.
</pre> <div class="fragment"><div class="line"><span class="lineno">  692</span><span class="keyword">def </span>reconstruct_skel_matrix(A, k, idx):</div>
<div class="line"><span class="lineno">  693</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    Reconstruct skeleton matrix from ID.</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    The skeleton matrix can be reconstructed from the original matrix `A` and its</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    ID rank and indices `k` and `idx`, respectively, as::</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        B = A[:,idx[:k]]</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    The original matrix can then be reconstructed via::</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)]</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    See also :func:`reconstruct_matrix_from_id` and</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    :func:`reconstruct_interp_matrix`.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    ..  This function automatically detects the matrix data type and calls the</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">        appropriate backend. For details, see :func:`_backend.idd_copycols` and</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">        :func:`_backend.idz_copycols`.</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    A : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">        Original matrix.</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        Rank of ID.</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    idx : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        Column index array.</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">        Skeleton matrix.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  726</span>    <span class="keywordflow">if</span> _is_real(A):</div>
<div class="line"><span class="lineno">  727</span>        <span class="keywordflow">return</span> _backend.idd_copycols(A, k, idx + 1)</div>
<div class="line"><span class="lineno">  728</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  729</span>        <span class="keywordflow">return</span> _backend.idz_copycols(A, k, idx + 1)</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f6ef9338273531558891d959344d6ce" name="a9f6ef9338273531558891d959344d6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6ef9338273531558891d959344d6ce">&#9670;&#160;</a></span>seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.seed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Seed the internal random number generator used in this ID package.

The generator is a lagged Fibonacci method with 55-element internal state.

Parameters
----------
seed : int, sequence, 'default', optional
    If 'default', the random seed is reset to a default value.

    If `seed` is a sequence containing 55 floating-point numbers
    in range [0,1], these are used to set the internal state of
    the generator.

    If the value is an integer, the internal state is obtained
    from `numpy.random.RandomState` (MT19937) with the integer
    used as the initial seed.

    If `seed` is omitted (None), ``numpy.random.rand`` is used to
    initialize the generator.</pre> <div class="fragment"><div class="line"><span class="lineno">  422</span><span class="keyword">def </span>seed(seed=None):</div>
<div class="line"><span class="lineno">  423</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    Seed the internal random number generator used in this ID package.</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    The generator is a lagged Fibonacci method with 55-element internal state.</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    seed : int, sequence, &#39;default&#39;, optional</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        If &#39;default&#39;, the random seed is reset to a default value.</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">        If `seed` is a sequence containing 55 floating-point numbers</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        in range [0,1], these are used to set the internal state of</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        the generator.</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">        If the value is an integer, the internal state is obtained</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        from `numpy.random.RandomState` (MT19937) with the integer</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">        used as the initial seed.</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">        If `seed` is omitted (None), ``numpy.random.rand`` is used to</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        initialize the generator.</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  445</span>    <span class="comment"># For details, see :func:`_backend.id_srand`, :func:`_backend.id_srandi`,</span></div>
<div class="line"><span class="lineno">  446</span>    <span class="comment"># and :func:`_backend.id_srando`.</span></div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">if</span> isinstance(seed, str) <span class="keywordflow">and</span> seed == <span class="stringliteral">&#39;default&#39;</span>:</div>
<div class="line"><span class="lineno">  449</span>        _backend.id_srando()</div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordflow">elif</span> hasattr(seed, <span class="stringliteral">&#39;__len__&#39;</span>):</div>
<div class="line"><span class="lineno">  451</span>        state = np.asfortranarray(seed, dtype=float)</div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordflow">if</span> state.shape != (55,):</div>
<div class="line"><span class="lineno">  453</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;invalid input size&quot;</span>)</div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">elif</span> state.min() &lt; 0 <span class="keywordflow">or</span> state.max() &gt; 1:</div>
<div class="line"><span class="lineno">  455</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;values not in range [0,1]&quot;</span>)</div>
<div class="line"><span class="lineno">  456</span>        _backend.id_srandi(state)</div>
<div class="line"><span class="lineno">  457</span>    <span class="keywordflow">elif</span> seed <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  458</span>        _backend.id_srandi(np.random.rand(55))</div>
<div class="line"><span class="lineno">  459</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  460</span>        rnd = np.random.RandomState(seed)</div>
<div class="line"><span class="lineno">  461</span>        _backend.id_srandi(rnd.rand(55))</div>
<div class="line"><span class="lineno">  462</span> </div>
<div class="line"><span class="lineno">  463</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2bd55842ec1ddf4fed755c084a997ae" name="aa2bd55842ec1ddf4fed755c084a997ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bd55842ec1ddf4fed755c084a997ae">&#9670;&#160;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative.svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps_or_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rand</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a matrix via an ID.

An SVD of a matrix `A` is a factorization::

    A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))

where `U` and `V` have orthonormal columns and `S` is nonnegative.

The SVD can be computed to any relative precision or rank (depending on the
value of `eps_or_k`).

See also :func:`interp_decomp` and :func:`id_to_svd`.

..  This function automatically detects the form of the input parameters and
    passes them to the appropriate backend. For details, see
    :func:`_backend.iddp_svd`, :func:`_backend.iddp_asvd`,
    :func:`_backend.iddp_rsvd`, :func:`_backend.iddr_svd`,
    :func:`_backend.iddr_asvd`, :func:`_backend.iddr_rsvd`,
    :func:`_backend.idzp_svd`, :func:`_backend.idzp_asvd`,
    :func:`_backend.idzp_rsvd`, :func:`_backend.idzr_svd`,
    :func:`_backend.idzr_asvd`, and :func:`_backend.idzr_rsvd`.

Parameters
----------
A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator`
    Matrix to be factored, given as either a :class:`numpy.ndarray` or a
    :class:`scipy.sparse.linalg.LinearOperator` with the `matvec` and
    `rmatvec` methods (to apply the matrix and its adjoint).
eps_or_k : float or int
    Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of
    approximation.
rand : bool, optional
    Whether to use random sampling if `A` is of type :class:`numpy.ndarray`
    (randomized algorithms are always used if `A` is of type
    :class:`scipy.sparse.linalg.LinearOperator`).

Returns
-------
U : :class:`numpy.ndarray`
    Left singular vectors.
S : :class:`numpy.ndarray`
    Singular values.
V : :class:`numpy.ndarray`
    Right singular vectors.
</pre> <div class="fragment"><div class="line"><span class="lineno">  846</span><span class="keyword">def </span>svd(A, eps_or_k, rand=True):</div>
<div class="line"><span class="lineno">  847</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    Compute SVD of a matrix via an ID.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    An SVD of a matrix `A` is a factorization::</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">        A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    where `U` and `V` have orthonormal columns and `S` is nonnegative.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    The SVD can be computed to any relative precision or rank (depending on the</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    value of `eps_or_k`).</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    See also :func:`interp_decomp` and :func:`id_to_svd`.</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    ..  This function automatically detects the form of the input parameters and</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">        passes them to the appropriate backend. For details, see</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">        :func:`_backend.iddp_svd`, :func:`_backend.iddp_asvd`,</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">        :func:`_backend.iddp_rsvd`, :func:`_backend.iddr_svd`,</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">        :func:`_backend.iddr_asvd`, :func:`_backend.iddr_rsvd`,</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">        :func:`_backend.idzp_svd`, :func:`_backend.idzp_asvd`,</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">        :func:`_backend.idzp_rsvd`, :func:`_backend.idzr_svd`,</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">        :func:`_backend.idzr_asvd`, and :func:`_backend.idzr_rsvd`.</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator`</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">        Matrix to be factored, given as either a :class:`numpy.ndarray` or a</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">        :class:`scipy.sparse.linalg.LinearOperator` with the `matvec` and</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        `rmatvec` methods (to apply the matrix and its adjoint).</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    eps_or_k : float or int</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">        Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">        approximation.</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    rand : bool, optional</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">        Whether to use random sampling if `A` is of type :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">        (randomized algorithms are always used if `A` is of type</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        :class:`scipy.sparse.linalg.LinearOperator`).</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    U : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">        Left singular vectors.</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    S : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        Singular values.</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    V : :class:`numpy.ndarray`</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">        Right singular vectors.</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  893</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1sparse_1_1linalg.html">scipy.sparse.linalg</a> <span class="keyword">import</span> LinearOperator</div>
<div class="line"><span class="lineno">  894</span> </div>
<div class="line"><span class="lineno">  895</span>    real = _is_real(A)</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span>    <span class="keywordflow">if</span> isinstance(A, np.ndarray):</div>
<div class="line"><span class="lineno">  898</span>        <span class="keywordflow">if</span> eps_or_k &lt; 1:</div>
<div class="line"><span class="lineno">  899</span>            eps = eps_or_k</div>
<div class="line"><span class="lineno">  900</span>            <span class="keywordflow">if</span> rand:</div>
<div class="line"><span class="lineno">  901</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  902</span>                    U, V, S = _backend.iddp_asvd(eps, A)</div>
<div class="line"><span class="lineno">  903</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  904</span>                    <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  905</span>                        <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  906</span>                    U, V, S = _backend.idzp_asvd(eps, A)</div>
<div class="line"><span class="lineno">  907</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  908</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  909</span>                    U, V, S = _backend.iddp_svd(eps, A)</div>
<div class="line"><span class="lineno">  910</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  911</span>                    U, V, S = _backend.idzp_svd(eps, A)</div>
<div class="line"><span class="lineno">  912</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  913</span>            k = int(eps_or_k)</div>
<div class="line"><span class="lineno">  914</span>            <span class="keywordflow">if</span> k &gt; min(A.shape):</div>
<div class="line"><span class="lineno">  915</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Approximation rank %s exceeds min(A.shape) = &quot;</span></div>
<div class="line"><span class="lineno">  916</span>                                 <span class="stringliteral">&quot; %s &quot;</span> % (k, min(A.shape)))</div>
<div class="line"><span class="lineno">  917</span>            <span class="keywordflow">if</span> rand:</div>
<div class="line"><span class="lineno">  918</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  919</span>                    U, V, S = _backend.iddr_asvd(A, k)</div>
<div class="line"><span class="lineno">  920</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  921</span>                    <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  922</span>                        <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  923</span>                    U, V, S = _backend.idzr_asvd(A, k)</div>
<div class="line"><span class="lineno">  924</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  925</span>                <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  926</span>                    U, V, S = _backend.iddr_svd(A, k)</div>
<div class="line"><span class="lineno">  927</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  928</span>                    U, V, S = _backend.idzr_svd(A, k)</div>
<div class="line"><span class="lineno">  929</span>    <span class="keywordflow">elif</span> isinstance(A, LinearOperator):</div>
<div class="line"><span class="lineno">  930</span>        m, n = A.shape</div>
<div class="line"><span class="lineno">  931</span>        matvec = <span class="keyword">lambda</span> x: A.matvec(x)</div>
<div class="line"><span class="lineno">  932</span>        matveca = <span class="keyword">lambda</span> x: A.rmatvec(x)</div>
<div class="line"><span class="lineno">  933</span>        <span class="keywordflow">if</span> eps_or_k &lt; 1:</div>
<div class="line"><span class="lineno">  934</span>            eps = eps_or_k</div>
<div class="line"><span class="lineno">  935</span>            <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  936</span>                U, V, S = _backend.iddp_rsvd(eps, m, n, matveca, matvec)</div>
<div class="line"><span class="lineno">  937</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  938</span>                <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  939</span>                    <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  940</span>                U, V, S = _backend.idzp_rsvd(eps, m, n, matveca, matvec)</div>
<div class="line"><span class="lineno">  941</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  942</span>            k = int(eps_or_k)</div>
<div class="line"><span class="lineno">  943</span>            <span class="keywordflow">if</span> real:</div>
<div class="line"><span class="lineno">  944</span>                U, V, S = _backend.iddr_rsvd(m, n, matveca, matvec, k)</div>
<div class="line"><span class="lineno">  945</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  946</span>                <span class="keywordflow">if</span> _IS_32BIT:</div>
<div class="line"><span class="lineno">  947</span>                    <span class="keywordflow">raise</span> _32BIT_ERROR</div>
<div class="line"><span class="lineno">  948</span>                U, V, S = _backend.idzr_rsvd(m, n, matveca, matvec, k)</div>
<div class="line"><span class="lineno">  949</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  950</span>        <span class="keywordflow">raise</span> _TYPE_ERROR</div>
<div class="line"><span class="lineno">  951</span>    <span class="keywordflow">return</span> U, S, V</div>
<div class="line"><span class="lineno">  952</span> </div>
<div class="line"><span class="lineno">  953</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7d78d5b7ff33102edad82ce96f5b5dc3" name="a7d78d5b7ff33102edad82ce96f5b5dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d78d5b7ff33102edad82ce96f5b5dc3">&#9670;&#160;</a></span>_32BIT_ERROR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative._32BIT_ERROR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  ValueError(<span class="stringliteral">&quot;interpolative decomposition on 32-bit systems &quot;</span></div>
<div class="line"><span class="lineno">    2</span>                          <span class="stringliteral">&quot;with complex128 is buggy&quot;</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c5a03194cead350b216713ab3c75d47" name="a9c5a03194cead350b216713ab3c75d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5a03194cead350b216713ab3c75d47">&#9670;&#160;</a></span>_DTYPE_ERROR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative._DTYPE_ERROR = ValueError(&quot;invalid input dtype (input must be float64 or complex128)&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e222cbbc77cc9d19cbb576a6f67a3d2" name="a8e222cbbc77cc9d19cbb576a6f67a3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e222cbbc77cc9d19cbb576a6f67a3d2">&#9670;&#160;</a></span>_IS_32BIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.linalg.interpolative._IS_32BIT = (sys.maxsize &lt; 2**32)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cc8965a5343d92631c03a1a311843f2" name="a9cc8965a5343d92631c03a1a311843f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc8965a5343d92631c03a1a311843f2">&#9670;&#160;</a></span>_TYPE_ERROR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg.interpolative._TYPE_ERROR = TypeError(&quot;invalid input type (must be array or LinearOperator)&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
