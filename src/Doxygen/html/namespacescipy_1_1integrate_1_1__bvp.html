<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.integrate._bvp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1integrate.html">integrate</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html">_bvp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.integrate._bvp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1integrate_1_1__bvp_1_1_b_v_p_result.html">BVPResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7e1d215a615a92553cf69d99c957daf1" id="r_a7e1d215a615a92553cf69d99c957daf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a7e1d215a615a92553cf69d99c957daf1">estimate_fun_jac</a> (fun, x, y, p, f0=None)</td></tr>
<tr class="separator:a7e1d215a615a92553cf69d99c957daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c9bd5fbc41d0665e0326c9bd5fccfb" id="r_a45c9bd5fbc41d0665e0326c9bd5fccfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a45c9bd5fbc41d0665e0326c9bd5fccfb">estimate_bc_jac</a> (bc, ya, yb, p, bc0=None)</td></tr>
<tr class="separator:a45c9bd5fbc41d0665e0326c9bd5fccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bbeda8eaef8fdac0da58fa78f6f198" id="r_af6bbeda8eaef8fdac0da58fa78f6f198"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#af6bbeda8eaef8fdac0da58fa78f6f198">compute_jac_indices</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, m, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:af6bbeda8eaef8fdac0da58fa78f6f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2ee109a1b89b59380bc4d9aa0b57ba" id="r_a1d2ee109a1b89b59380bc4d9aa0b57ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a1d2ee109a1b89b59380bc4d9aa0b57ba">stacked_matmul</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b)</td></tr>
<tr class="separator:a1d2ee109a1b89b59380bc4d9aa0b57ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1154189ea728f879fa1a50bf962f5628" id="r_a1154189ea728f879fa1a50bf962f5628"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a1154189ea728f879fa1a50bf962f5628">construct_global_jac</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, m, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, i_jac, j_jac, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>, df_dy, df_dy_middle, df_dp, df_dp_middle, dbc_dya, dbc_dyb, dbc_dp)</td></tr>
<tr class="separator:a1154189ea728f879fa1a50bf962f5628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10253dea50687b4fa2f6c452de6f749a" id="r_a10253dea50687b4fa2f6c452de6f749a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a10253dea50687b4fa2f6c452de6f749a">collocation_fun</a> (fun, y, p, x, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>)</td></tr>
<tr class="separator:a10253dea50687b4fa2f6c452de6f749a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5192bec9ee862fea0740740b0b180a" id="r_a3e5192bec9ee862fea0740740b0b180a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a3e5192bec9ee862fea0740740b0b180a">prepare_sys</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, m, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, fun, bc, fun_jac, bc_jac, x, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>)</td></tr>
<tr class="separator:a3e5192bec9ee862fea0740740b0b180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44b4b962bed36f279bfe9307fe6eb3" id="r_a9b44b4b962bed36f279bfe9307fe6eb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a9b44b4b962bed36f279bfe9307fe6eb3">solve_newton</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, m, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>, col_fun, bc, jac, y, p, B, bvp_tol, bc_tol)</td></tr>
<tr class="separator:a9b44b4b962bed36f279bfe9307fe6eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b30c7b4693fb5d60b6005793ae834a" id="r_a91b30c7b4693fb5d60b6005793ae834a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a91b30c7b4693fb5d60b6005793ae834a">print_iteration_header</a> ()</td></tr>
<tr class="separator:a91b30c7b4693fb5d60b6005793ae834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56031b469e5609df5d8dd39bd8f5509c" id="r_a56031b469e5609df5d8dd39bd8f5509c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a56031b469e5609df5d8dd39bd8f5509c">print_iteration_progress</a> (iteration, residual, bc_residual, total_nodes, nodes_added)</td></tr>
<tr class="separator:a56031b469e5609df5d8dd39bd8f5509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af426b824c4dbc0de39b9942652a8904e" id="r_af426b824c4dbc0de39b9942652a8904e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#af426b824c4dbc0de39b9942652a8904e">estimate_rms_residuals</a> (fun, sol, x, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>, p, r_middle, f_middle)</td></tr>
<tr class="separator:af426b824c4dbc0de39b9942652a8904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52008364a7339728115c99023d524c26" id="r_a52008364a7339728115c99023d524c26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a52008364a7339728115c99023d524c26">create_spline</a> (y, yp, x, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>)</td></tr>
<tr class="separator:a52008364a7339728115c99023d524c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2734b62ef488e502e42e0aa66a9946" id="r_a9b2734b62ef488e502e42e0aa66a9946"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a9b2734b62ef488e502e42e0aa66a9946">modify_mesh</a> (x, insert_1, insert_2)</td></tr>
<tr class="separator:a9b2734b62ef488e502e42e0aa66a9946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab326bbe47e4328938c2cf9b65c6d5dc3" id="r_ab326bbe47e4328938c2cf9b65c6d5dc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#ab326bbe47e4328938c2cf9b65c6d5dc3">wrap_functions</a> (fun, bc, fun_jac, bc_jac, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, S, D, dtype)</td></tr>
<tr class="separator:ab326bbe47e4328938c2cf9b65c6d5dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d9e00cd7b244fb96fd92ff8510b1a6" id="r_ac7d9e00cd7b244fb96fd92ff8510b1a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#ac7d9e00cd7b244fb96fd92ff8510b1a6">solve_bvp</a> (fun, bc, x, y, p=None, S=None, fun_jac=None, bc_jac=None, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-3, max_nodes=1000, verbose=0, bc_tol=None)</td></tr>
<tr class="separator:ac7d9e00cd7b244fb96fd92ff8510b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad99dbe0f4c37ff34045848221ac5174e" id="r_ad99dbe0f4c37ff34045848221ac5174e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#ad99dbe0f4c37ff34045848221ac5174e">EPS</a> = np.finfo(float).<a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a></td></tr>
<tr class="separator:ad99dbe0f4c37ff34045848221ac5174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0abd96fce877bfa6f1ba4fc0774515" id="r_a9e0abd96fce877bfa6f1ba4fc0774515"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1integrate_1_1__bvp.html#a9e0abd96fce877bfa6f1ba4fc0774515">TERMINATION_MESSAGES</a></td></tr>
<tr class="separator:a9e0abd96fce877bfa6f1ba4fc0774515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Boundary value problem solver.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a10253dea50687b4fa2f6c452de6f749a" name="a10253dea50687b4fa2f6c452de6f749a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10253dea50687b4fa2f6c452de6f749a">&#9670;&#160;</a></span>collocation_fun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.collocation_fun </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate collocation residuals.

This function lies in the core of the method. The solution is sought
as a cubic C1 continuous spline with derivatives matching the ODE rhs
at given nodes `x`. Collocation conditions are formed from the equality
of the spline derivatives and rhs of the ODE system in the middle points
between nodes.

Such method is classified to Lobbato IIIA family in ODE literature.
Refer to [1]_ for the formula and some discussion.

Returns
-------
col_res : ndarray, shape (n, m - 1)
    Collocation residuals at the middle points of the mesh intervals.
y_middle : ndarray, shape (n, m - 1)
    Values of the cubic spline evaluated at the middle points of the mesh
    intervals.
f : ndarray, shape (n, m)
    RHS of the ODE system evaluated at the mesh nodes.
f_middle : ndarray, shape (n, m - 1)
    RHS of the ODE system evaluated at the middle points of the mesh
    intervals (and using `y_middle`).

References
----------
.. [1] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
       Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
       Number 3, pp. 299-316, 2001.
</pre> <div class="fragment"><div class="line"><span class="lineno">  276</span><span class="keyword">def </span>collocation_fun(fun, y, p, x, h):</div>
<div class="line"><span class="lineno">  277</span>    <span class="stringliteral">&quot;&quot;&quot;Evaluate collocation residuals.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    This function lies in the core of the method. The solution is sought</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    as a cubic C1 continuous spline with derivatives matching the ODE rhs</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    at given nodes `x`. Collocation conditions are formed from the equality</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    of the spline derivatives and rhs of the ODE system in the middle points</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    between nodes.</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    Such method is classified to Lobbato IIIA family in ODE literature.</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    Refer to [1]_ for the formula and some discussion.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    col_res : ndarray, shape (n, m - 1)</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        Collocation residuals at the middle points of the mesh intervals.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    y_middle : ndarray, shape (n, m - 1)</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        Values of the cubic spline evaluated at the middle points of the mesh</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        intervals.</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    f : ndarray, shape (n, m)</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        RHS of the ODE system evaluated at the mesh nodes.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    f_middle : ndarray, shape (n, m - 1)</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        RHS of the ODE system evaluated at the middle points of the mesh</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        intervals (and using `y_middle`).</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    .. [1] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">           Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27,</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">           Number 3, pp. 299-316, 2001.</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  307</span>    f = fun(x, y, p)</div>
<div class="line"><span class="lineno">  308</span>    y_middle = (0.5 * (y[:, 1:] + y[:, :-1]) -</div>
<div class="line"><span class="lineno">  309</span>                0.125 * h * (f[:, 1:] - f[:, :-1]))</div>
<div class="line"><span class="lineno">  310</span>    f_middle = fun(x[:-1] + 0.5 * h, y_middle, p)</div>
<div class="line"><span class="lineno">  311</span>    col_res = y[:, 1:] - y[:, :-1] - h / 6 * (f[:, :-1] + f[:, 1:] +</div>
<div class="line"><span class="lineno">  312</span>                                              4 * f_middle)</div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span>    <span class="keywordflow">return</span> col_res, y_middle, f, f_middle</div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af6bbeda8eaef8fdac0da58fa78f6f198" name="af6bbeda8eaef8fdac0da58fa78f6f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bbeda8eaef8fdac0da58fa78f6f198">&#9670;&#160;</a></span>compute_jac_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.compute_jac_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute indices for the collocation system Jacobian construction.

See `construct_global_jac` for the explanation.
</pre> <div class="fragment"><div class="line"><span class="lineno">  117</span><span class="keyword">def </span>compute_jac_indices(n, m, k):</div>
<div class="line"><span class="lineno">  118</span>    <span class="stringliteral">&quot;&quot;&quot;Compute indices for the collocation system Jacobian construction.</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    See `construct_global_jac` for the explanation.</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  122</span>    i_col = np.repeat(np.arange((m - 1) * n), n)</div>
<div class="line"><span class="lineno">  123</span>    j_col = (np.tile(np.arange(n), n * (m - 1)) +</div>
<div class="line"><span class="lineno">  124</span>             np.repeat(np.arange(m - 1) * n, n**2))</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>    i_bc = np.repeat(np.arange((m - 1) * n, m * n + k), n)</div>
<div class="line"><span class="lineno">  127</span>    j_bc = np.tile(np.arange(n), n + k)</div>
<div class="line"><span class="lineno">  128</span> </div>
<div class="line"><span class="lineno">  129</span>    i_p_col = np.repeat(np.arange((m - 1) * n), k)</div>
<div class="line"><span class="lineno">  130</span>    j_p_col = np.tile(np.arange(m * n, m * n + k), (m - 1) * n)</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>    i_p_bc = np.repeat(np.arange((m - 1) * n, m * n + k), k)</div>
<div class="line"><span class="lineno">  133</span>    j_p_bc = np.tile(np.arange(m * n, m * n + k), n + k)</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>    i = np.hstack((i_col, i_col, i_bc, i_bc, i_p_col, i_p_bc))</div>
<div class="line"><span class="lineno">  136</span>    j = np.hstack((j_col, j_col + n,</div>
<div class="line"><span class="lineno">  137</span>                   j_bc, j_bc + (m - 1) * n,</div>
<div class="line"><span class="lineno">  138</span>                   j_p_col, j_p_bc))</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">return</span> i, j</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1154189ea728f879fa1a50bf962f5628" name="a1154189ea728f879fa1a50bf962f5628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1154189ea728f879fa1a50bf962f5628">&#9670;&#160;</a></span>construct_global_jac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.construct_global_jac </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_dy_middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_dp_middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dbc_dya</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dbc_dyb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dbc_dp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct the Jacobian of the collocation system.

There are n * m + k functions: m - 1 collocations residuals, each
containing n components, followed by n + k boundary condition residuals.

There are n * m + k variables: m vectors of y, each containing n
components, followed by k values of vector p.

For example, let m = 4, n = 2 and k = 1, then the Jacobian will have
the following sparsity structure:

    1 1 2 2 0 0 0 0  5
    1 1 2 2 0 0 0 0  5
    0 0 1 1 2 2 0 0  5
    0 0 1 1 2 2 0 0  5
    0 0 0 0 1 1 2 2  5
    0 0 0 0 1 1 2 2  5

    3 3 0 0 0 0 4 4  6
    3 3 0 0 0 0 4 4  6
    3 3 0 0 0 0 4 4  6

Zeros denote identically zero values, other values denote different kinds
of blocks in the matrix (see below). The blank row indicates the separation
of collocation residuals from boundary conditions. And the blank column
indicates the separation of y values from p values.

Refer to [1]_  (p. 306) for the formula of n x n blocks for derivatives
of collocation residuals with respect to y.

Parameters
----------
n : int
    Number of equations in the ODE system.
m : int
    Number of nodes in the mesh.
k : int
    Number of the unknown parameters.
i_jac, j_jac : ndarray
    Row and column indices returned by `compute_jac_indices`. They
    represent different blocks in the Jacobian matrix in the following
    order (see the scheme above):

        * 1: m - 1 diagonal n x n blocks for the collocation residuals.
        * 2: m - 1 off-diagonal n x n blocks for the collocation residuals.
        * 3 : (n + k) x n block for the dependency of the boundary
          conditions on ya.
        * 4: (n + k) x n block for the dependency of the boundary
          conditions on yb.
        * 5: (m - 1) * n x k block for the dependency of the collocation
          residuals on p.
        * 6: (n + k) x k block for the dependency of the boundary
          conditions on p.

df_dy : ndarray, shape (n, n, m)
    Jacobian of f with respect to y computed at the mesh nodes.
df_dy_middle : ndarray, shape (n, n, m - 1)
    Jacobian of f with respect to y computed at the middle between the
    mesh nodes.
df_dp : ndarray with shape (n, k, m) or None
    Jacobian of f with respect to p computed at the mesh nodes.
df_dp_middle : ndarray with shape (n, k, m - 1) or None
    Jacobian of f with respect to p computed at the middle between the
    mesh nodes.
dbc_dya, dbc_dyb : ndarray, shape (n, n)
    Jacobian of bc with respect to ya and yb.
dbc_dp : ndarray with shape (n, k) or None
    Jacobian of bc with respect to p.

Returns
-------
J : csc_matrix, shape (n * m + k, n * m + k)
    Jacobian of the collocation system in a sparse form.

References
----------
.. [1] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
   Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
   Number 3, pp. 299-316, 2001.
</pre> <div class="fragment"><div class="line"><span class="lineno">  159</span>                         df_dp_middle, dbc_dya, dbc_dyb, dbc_dp):</div>
<div class="line"><span class="lineno">  160</span>    <span class="stringliteral">&quot;&quot;&quot;Construct the Jacobian of the collocation system.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    There are n * m + k functions: m - 1 collocations residuals, each</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    containing n components, followed by n + k boundary condition residuals.</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    There are n * m + k variables: m vectors of y, each containing n</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    components, followed by k values of vector p.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    For example, let m = 4, n = 2 and k = 1, then the Jacobian will have</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    the following sparsity structure:</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        1 1 2 2 0 0 0 0  5</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        1 1 2 2 0 0 0 0  5</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        0 0 1 1 2 2 0 0  5</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">        0 0 1 1 2 2 0 0  5</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        0 0 0 0 1 1 2 2  5</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        0 0 0 0 1 1 2 2  5</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">        3 3 0 0 0 0 4 4  6</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">        3 3 0 0 0 0 4 4  6</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        3 3 0 0 0 0 4 4  6</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    Zeros denote identically zero values, other values denote different kinds</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    of blocks in the matrix (see below). The blank row indicates the separation</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    of collocation residuals from boundary conditions. And the blank column</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    indicates the separation of y values from p values.</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    Refer to [1]_  (p. 306) for the formula of n x n blocks for derivatives</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    of collocation residuals with respect to y.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        Number of equations in the ODE system.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    m : int</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        Number of nodes in the mesh.</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        Number of the unknown parameters.</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    i_jac, j_jac : ndarray</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">        Row and column indices returned by `compute_jac_indices`. They</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        represent different blocks in the Jacobian matrix in the following</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        order (see the scheme above):</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">            * 1: m - 1 diagonal n x n blocks for the collocation residuals.</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">            * 2: m - 1 off-diagonal n x n blocks for the collocation residuals.</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">            * 3 : (n + k) x n block for the dependency of the boundary</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">              conditions on ya.</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">            * 4: (n + k) x n block for the dependency of the boundary</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">              conditions on yb.</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">            * 5: (m - 1) * n x k block for the dependency of the collocation</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">              residuals on p.</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">            * 6: (n + k) x k block for the dependency of the boundary</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">              conditions on p.</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    df_dy : ndarray, shape (n, n, m)</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        Jacobian of f with respect to y computed at the mesh nodes.</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    df_dy_middle : ndarray, shape (n, n, m - 1)</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        Jacobian of f with respect to y computed at the middle between the</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        mesh nodes.</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    df_dp : ndarray with shape (n, k, m) or None</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        Jacobian of f with respect to p computed at the mesh nodes.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    df_dp_middle : ndarray with shape (n, k, m - 1) or None</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        Jacobian of f with respect to p computed at the middle between the</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">        mesh nodes.</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    dbc_dya, dbc_dyb : ndarray, shape (n, n)</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">        Jacobian of bc with respect to ya and yb.</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    dbc_dp : ndarray with shape (n, k) or None</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">        Jacobian of bc with respect to p.</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    J : csc_matrix, shape (n * m + k, n * m + k)</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        Jacobian of the collocation system in a sparse form.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    .. [1] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">       Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27,</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">       Number 3, pp. 299-316, 2001.</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  240</span>    df_dy = np.transpose(df_dy, (2, 0, 1))</div>
<div class="line"><span class="lineno">  241</span>    df_dy_middle = np.transpose(df_dy_middle, (2, 0, 1))</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>    h = h[:, np.newaxis, np.newaxis]</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span>    dtype = df_dy.dtype</div>
<div class="line"><span class="lineno">  246</span> </div>
<div class="line"><span class="lineno">  247</span>    <span class="comment"># Computing diagonal n x n blocks.</span></div>
<div class="line"><span class="lineno">  248</span>    dPhi_dy_0 = np.empty((m - 1, n, n), dtype=dtype)</div>
<div class="line"><span class="lineno">  249</span>    dPhi_dy_0[:] = -np.identity(n)</div>
<div class="line"><span class="lineno">  250</span>    dPhi_dy_0 -= h / 6 * (df_dy[:-1] + 2 * df_dy_middle)</div>
<div class="line"><span class="lineno">  251</span>    T = stacked_matmul(df_dy_middle, df_dy[:-1])</div>
<div class="line"><span class="lineno">  252</span>    dPhi_dy_0 -= h**2 / 12 * T</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>    <span class="comment"># Computing off-diagonal n x n blocks.</span></div>
<div class="line"><span class="lineno">  255</span>    dPhi_dy_1 = np.empty((m - 1, n, n), dtype=dtype)</div>
<div class="line"><span class="lineno">  256</span>    dPhi_dy_1[:] = np.identity(n)</div>
<div class="line"><span class="lineno">  257</span>    dPhi_dy_1 -= h / 6 * (df_dy[1:] + 2 * df_dy_middle)</div>
<div class="line"><span class="lineno">  258</span>    T = stacked_matmul(df_dy_middle, df_dy[1:])</div>
<div class="line"><span class="lineno">  259</span>    dPhi_dy_1 += h**2 / 12 * T</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span>    values = np.hstack((dPhi_dy_0.ravel(), dPhi_dy_1.ravel(), dbc_dya.ravel(),</div>
<div class="line"><span class="lineno">  262</span>                        dbc_dyb.ravel()))</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span>    <span class="keywordflow">if</span> k &gt; 0:</div>
<div class="line"><span class="lineno">  265</span>        df_dp = np.transpose(df_dp, (2, 0, 1))</div>
<div class="line"><span class="lineno">  266</span>        df_dp_middle = np.transpose(df_dp_middle, (2, 0, 1))</div>
<div class="line"><span class="lineno">  267</span>        T = stacked_matmul(df_dy_middle, df_dp[:-1] - df_dp[1:])</div>
<div class="line"><span class="lineno">  268</span>        df_dp_middle += 0.125 * h * T</div>
<div class="line"><span class="lineno">  269</span>        dPhi_dp = -h/6 * (df_dp[:-1] + df_dp[1:] + 4 * df_dp_middle)</div>
<div class="line"><span class="lineno">  270</span>        values = np.hstack((values, dPhi_dp.ravel(), dbc_dp.ravel()))</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span>    J = coo_matrix((values, (i_jac, j_jac)))</div>
<div class="line"><span class="lineno">  273</span>    <span class="keywordflow">return</span> csc_matrix(J)</div>
<div class="line"><span class="lineno">  274</span> </div>
<div class="line"><span class="lineno">  275</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a52008364a7339728115c99023d524c26" name="a52008364a7339728115c99023d524c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52008364a7339728115c99023d524c26">&#9670;&#160;</a></span>create_spline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.create_spline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>yp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a cubic spline given values and derivatives.

Formulas for the coefficients are taken from interpolate.CubicSpline.

Returns
-------
sol : PPoly
    Constructed spline as a PPoly instance.
</pre> <div class="fragment"><div class="line"><span class="lineno">  577</span><span class="keyword">def </span>create_spline(y, yp, x, h):</div>
<div class="line"><span class="lineno">  578</span>    <span class="stringliteral">&quot;&quot;&quot;Create a cubic spline given values and derivatives.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    Formulas for the coefficients are taken from interpolate.CubicSpline.</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    sol : PPoly</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        Constructed spline as a PPoly instance.</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  587</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacescipy_1_1interpolate.html">scipy.interpolate</a> <span class="keyword">import</span> PPoly</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span>    n, m = y.shape</div>
<div class="line"><span class="lineno">  590</span>    c = np.empty((4, n, m - 1), dtype=y.dtype)</div>
<div class="line"><span class="lineno">  591</span>    slope = (y[:, 1:] - y[:, :-1]) / h</div>
<div class="line"><span class="lineno">  592</span>    t = (yp[:, :-1] + yp[:, 1:] - 2 * slope) / h</div>
<div class="line"><span class="lineno">  593</span>    c[0] = t / h</div>
<div class="line"><span class="lineno">  594</span>    c[1] = (slope - yp[:, :-1]) / h - t</div>
<div class="line"><span class="lineno">  595</span>    c[2] = yp[:, :-1]</div>
<div class="line"><span class="lineno">  596</span>    c[3] = y[:, :-1]</div>
<div class="line"><span class="lineno">  597</span>    c = np.moveaxis(c, 1, 0)</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span>    <span class="keywordflow">return</span> PPoly(c, x, extrapolate=<span class="keyword">True</span>, axis=1)</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span> </div>
<div class="ttc" id="anamespacescipy_1_1interpolate_html"><div class="ttname"><a href="namespacescipy_1_1interpolate.html">scipy.interpolate</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a45c9bd5fbc41d0665e0326c9bd5fccfb" name="a45c9bd5fbc41d0665e0326c9bd5fccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c9bd5fbc41d0665e0326c9bd5fccfb">&#9670;&#160;</a></span>estimate_bc_jac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.estimate_bc_jac </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ya</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>yb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc0</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate derivatives of boundary conditions with forward differences.

Returns
-------
dbc_dya : ndarray, shape (n + k, n)
    Derivatives with respect to ya. An element (i, j) corresponds to
    d bc_i / d ya_j.
dbc_dyb : ndarray, shape (n + k, n)
    Derivatives with respect to yb. An element (i, j) corresponds to
    d bc_i / d ya_j.
dbc_dp : ndarray with shape (n + k, k) or None
    Derivatives with respect to p. An element (i, j) corresponds to
    d bc_i / d p_j. If `p` is empty, None is returned.
</pre> <div class="fragment"><div class="line"><span class="lineno">   58</span><span class="keyword">def </span>estimate_bc_jac(bc, ya, yb, p, bc0=None):</div>
<div class="line"><span class="lineno">   59</span>    <span class="stringliteral">&quot;&quot;&quot;Estimate derivatives of boundary conditions with forward differences.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    dbc_dya : ndarray, shape (n + k, n)</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">        Derivatives with respect to ya. An element (i, j) corresponds to</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        d bc_i / d ya_j.</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    dbc_dyb : ndarray, shape (n + k, n)</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">        Derivatives with respect to yb. An element (i, j) corresponds to</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">        d bc_i / d ya_j.</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    dbc_dp : ndarray with shape (n + k, k) or None</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">        Derivatives with respect to p. An element (i, j) corresponds to</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">        d bc_i / d p_j. If `p` is empty, None is returned.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   73</span>    n = ya.shape[0]</div>
<div class="line"><span class="lineno">   74</span>    k = p.shape[0]</div>
<div class="line"><span class="lineno">   75</span> </div>
<div class="line"><span class="lineno">   76</span>    <span class="keywordflow">if</span> bc0 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   77</span>        bc0 = bc(ya, yb, p)</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>    dtype = ya.dtype</div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>    dbc_dya = np.empty((n, n + k), dtype=dtype)</div>
<div class="line"><span class="lineno">   82</span>    h = EPS**0.5 * (1 + np.abs(ya))</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">   84</span>        ya_new = ya.copy()</div>
<div class="line"><span class="lineno">   85</span>        ya_new[i] += h[i]</div>
<div class="line"><span class="lineno">   86</span>        hi = ya_new[i] - ya[i]</div>
<div class="line"><span class="lineno">   87</span>        bc_new = bc(ya_new, yb, p)</div>
<div class="line"><span class="lineno">   88</span>        dbc_dya[i] = (bc_new - bc0) / hi</div>
<div class="line"><span class="lineno">   89</span>    dbc_dya = dbc_dya.T</div>
<div class="line"><span class="lineno">   90</span> </div>
<div class="line"><span class="lineno">   91</span>    h = EPS**0.5 * (1 + np.abs(yb))</div>
<div class="line"><span class="lineno">   92</span>    dbc_dyb = np.empty((n, n + k), dtype=dtype)</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">   94</span>        yb_new = yb.copy()</div>
<div class="line"><span class="lineno">   95</span>        yb_new[i] += h[i]</div>
<div class="line"><span class="lineno">   96</span>        hi = yb_new[i] - yb[i]</div>
<div class="line"><span class="lineno">   97</span>        bc_new = bc(ya, yb_new, p)</div>
<div class="line"><span class="lineno">   98</span>        dbc_dyb[i] = (bc_new - bc0) / hi</div>
<div class="line"><span class="lineno">   99</span>    dbc_dyb = dbc_dyb.T</div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno">  102</span>        dbc_dp = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  104</span>        h = EPS**0.5 * (1 + np.abs(p))</div>
<div class="line"><span class="lineno">  105</span>        dbc_dp = np.empty((k, n + k), dtype=dtype)</div>
<div class="line"><span class="lineno">  106</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno">  107</span>            p_new = p.copy()</div>
<div class="line"><span class="lineno">  108</span>            p_new[i] += h[i]</div>
<div class="line"><span class="lineno">  109</span>            hi = p_new[i] - p[i]</div>
<div class="line"><span class="lineno">  110</span>            bc_new = bc(ya, yb, p_new)</div>
<div class="line"><span class="lineno">  111</span>            dbc_dp[i] = (bc_new - bc0) / hi</div>
<div class="line"><span class="lineno">  112</span>        dbc_dp = dbc_dp.T</div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span>    <span class="keywordflow">return</span> dbc_dya, dbc_dyb, dbc_dp</div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e1d215a615a92553cf69d99c957daf1" name="a7e1d215a615a92553cf69d99c957daf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1d215a615a92553cf69d99c957daf1">&#9670;&#160;</a></span>estimate_fun_jac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.estimate_fun_jac </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f0</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate derivatives of an ODE system rhs with forward differences.

Returns
-------
df_dy : ndarray, shape (n, n, m)
    Derivatives with respect to y. An element (i, j, q) corresponds to
    d f_i(x_q, y_q) / d (y_q)_j.
df_dp : ndarray with shape (n, k, m) or None
    Derivatives with respect to p. An element (i, j, q) corresponds to
    d f_i(x_q, y_q, p) / d p_j. If `p` is empty, None is returned.
</pre> <div class="fragment"><div class="line"><span class="lineno">   15</span><span class="keyword">def </span>estimate_fun_jac(fun, x, y, p, f0=None):</div>
<div class="line"><span class="lineno">   16</span>    <span class="stringliteral">&quot;&quot;&quot;Estimate derivatives of an ODE system rhs with forward differences.</span></div>
<div class="line"><span class="lineno">   17</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   18</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral">    df_dy : ndarray, shape (n, n, m)</span></div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral">        Derivatives with respect to y. An element (i, j, q) corresponds to</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">        d f_i(x_q, y_q) / d (y_q)_j.</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    df_dp : ndarray with shape (n, k, m) or None</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">        Derivatives with respect to p. An element (i, j, q) corresponds to</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">        d f_i(x_q, y_q, p) / d p_j. If `p` is empty, None is returned.</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   27</span>    n, m = y.shape</div>
<div class="line"><span class="lineno">   28</span>    <span class="keywordflow">if</span> f0 <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   29</span>        f0 = fun(x, y, p)</div>
<div class="line"><span class="lineno">   30</span> </div>
<div class="line"><span class="lineno">   31</span>    dtype = y.dtype</div>
<div class="line"><span class="lineno">   32</span> </div>
<div class="line"><span class="lineno">   33</span>    df_dy = np.empty((n, n, m), dtype=dtype)</div>
<div class="line"><span class="lineno">   34</span>    h = EPS**0.5 * (1 + np.abs(y))</div>
<div class="line"><span class="lineno">   35</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">   36</span>        y_new = y.copy()</div>
<div class="line"><span class="lineno">   37</span>        y_new[i] += h[i]</div>
<div class="line"><span class="lineno">   38</span>        hi = y_new[i] - y[i]</div>
<div class="line"><span class="lineno">   39</span>        f_new = fun(x, y_new, p)</div>
<div class="line"><span class="lineno">   40</span>        df_dy[:, i, :] = (f_new - f0) / hi</div>
<div class="line"><span class="lineno">   41</span> </div>
<div class="line"><span class="lineno">   42</span>    k = p.shape[0]</div>
<div class="line"><span class="lineno">   43</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno">   44</span>        df_dp = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">   45</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   46</span>        df_dp = np.empty((n, k, m), dtype=dtype)</div>
<div class="line"><span class="lineno">   47</span>        h = EPS**0.5 * (1 + np.abs(p))</div>
<div class="line"><span class="lineno">   48</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k):</div>
<div class="line"><span class="lineno">   49</span>            p_new = p.copy()</div>
<div class="line"><span class="lineno">   50</span>            p_new[i] += h[i]</div>
<div class="line"><span class="lineno">   51</span>            hi = p_new[i] - p[i]</div>
<div class="line"><span class="lineno">   52</span>            f_new = fun(x, y, p_new)</div>
<div class="line"><span class="lineno">   53</span>            df_dp[:, i, :] = (f_new - f0) / hi</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">return</span> df_dy, df_dp</div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af426b824c4dbc0de39b9942652a8904e" name="af426b824c4dbc0de39b9942652a8904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af426b824c4dbc0de39b9942652a8904e">&#9670;&#160;</a></span>estimate_rms_residuals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.estimate_rms_residuals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r_middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f_middle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate rms values of collocation residuals using Lobatto quadrature.

The residuals are defined as the difference between the derivatives of
our solution and rhs of the ODE system. We use relative residuals, i.e.,
normalized by 1 + np.abs(f). RMS values are computed as sqrt from the
normalized integrals of the squared relative residuals over each interval.
Integrals are estimated using 5-point Lobatto quadrature [1]_, we use the
fact that residuals at the mesh nodes are identically zero.

In [2] they don't normalize integrals by interval lengths, which gives
a higher rate of convergence of the residuals by the factor of h**0.5.
I chose to do such normalization for an ease of interpretation of return
values as RMS estimates.

Returns
-------
rms_res : ndarray, shape (m - 1,)
    Estimated rms values of the relative residuals over each interval.

References
----------
.. [1] http://mathworld.wolfram.com/LobattoQuadrature.html
.. [2] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
   Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
   Number 3, pp. 299-316, 2001.
</pre> <div class="fragment"><div class="line"><span class="lineno">  526</span><span class="keyword">def </span>estimate_rms_residuals(fun, sol, x, h, p, r_middle, f_middle):</div>
<div class="line"><span class="lineno">  527</span>    <span class="stringliteral">&quot;&quot;&quot;Estimate rms values of collocation residuals using Lobatto quadrature.</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    The residuals are defined as the difference between the derivatives of</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    our solution and rhs of the ODE system. We use relative residuals, i.e.,</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    normalized by 1 + np.abs(f). RMS values are computed as sqrt from the</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    normalized integrals of the squared relative residuals over each interval.</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    Integrals are estimated using 5-point Lobatto quadrature [1]_, we use the</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    fact that residuals at the mesh nodes are identically zero.</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    In [2] they don&#39;t normalize integrals by interval lengths, which gives</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    a higher rate of convergence of the residuals by the factor of h**0.5.</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    I chose to do such normalization for an ease of interpretation of return</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    values as RMS estimates.</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    rms_res : ndarray, shape (m - 1,)</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        Estimated rms values of the relative residuals over each interval.</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    .. [1] http://mathworld.wolfram.com/LobattoQuadrature.html</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    .. [2] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">       Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27,</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">       Number 3, pp. 299-316, 2001.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  553</span>    x_middle = x[:-1] + 0.5 * h</div>
<div class="line"><span class="lineno">  554</span>    s = 0.5 * h * (3/7)**0.5</div>
<div class="line"><span class="lineno">  555</span>    x1 = x_middle + s</div>
<div class="line"><span class="lineno">  556</span>    x2 = x_middle - s</div>
<div class="line"><span class="lineno">  557</span>    y1 = sol(x1)</div>
<div class="line"><span class="lineno">  558</span>    y2 = sol(x2)</div>
<div class="line"><span class="lineno">  559</span>    y1_prime = sol(x1, 1)</div>
<div class="line"><span class="lineno">  560</span>    y2_prime = sol(x2, 1)</div>
<div class="line"><span class="lineno">  561</span>    f1 = fun(x1, y1, p)</div>
<div class="line"><span class="lineno">  562</span>    f2 = fun(x2, y2, p)</div>
<div class="line"><span class="lineno">  563</span>    r1 = y1_prime - f1</div>
<div class="line"><span class="lineno">  564</span>    r2 = y2_prime - f2</div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span>    r_middle /= 1 + np.abs(f_middle)</div>
<div class="line"><span class="lineno">  567</span>    r1 /= 1 + np.abs(f1)</div>
<div class="line"><span class="lineno">  568</span>    r2 /= 1 + np.abs(f2)</div>
<div class="line"><span class="lineno">  569</span> </div>
<div class="line"><span class="lineno">  570</span>    r1 = np.sum(np.real(r1 * np.conj(r1)), axis=0)</div>
<div class="line"><span class="lineno">  571</span>    r2 = np.sum(np.real(r2 * np.conj(r2)), axis=0)</div>
<div class="line"><span class="lineno">  572</span>    r_middle = np.sum(np.real(r_middle * np.conj(r_middle)), axis=0)</div>
<div class="line"><span class="lineno">  573</span> </div>
<div class="line"><span class="lineno">  574</span>    <span class="keywordflow">return</span> (0.5 * (32 / 45 * r_middle + 49 / 90 * (r1 + r2))) ** 0.5</div>
<div class="line"><span class="lineno">  575</span> </div>
<div class="line"><span class="lineno">  576</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b2734b62ef488e502e42e0aa66a9946" name="a9b2734b62ef488e502e42e0aa66a9946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2734b62ef488e502e42e0aa66a9946">&#9670;&#160;</a></span>modify_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.modify_mesh </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>insert_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>insert_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Insert nodes into a mesh.

Nodes removal logic is not established, its impact on the solver is
presumably negligible. So, only insertion is done in this function.

Parameters
----------
x : ndarray, shape (m,)
    Mesh nodes.
insert_1 : ndarray
    Intervals to each insert 1 new node in the middle.
insert_2 : ndarray
    Intervals to each insert 2 new nodes, such that divide an interval
    into 3 equal parts.

Returns
-------
x_new : ndarray
    New mesh nodes.

Notes
-----
`insert_1` and `insert_2` should not have common values.
</pre> <div class="fragment"><div class="line"><span class="lineno">  602</span><span class="keyword">def </span>modify_mesh(x, insert_1, insert_2):</div>
<div class="line"><span class="lineno">  603</span>    <span class="stringliteral">&quot;&quot;&quot;Insert nodes into a mesh.</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    Nodes removal logic is not established, its impact on the solver is</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    presumably negligible. So, only insertion is done in this function.</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    x : ndarray, shape (m,)</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">        Mesh nodes.</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    insert_1 : ndarray</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">        Intervals to each insert 1 new node in the middle.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    insert_2 : ndarray</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        Intervals to each insert 2 new nodes, such that divide an interval</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">        into 3 equal parts.</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    x_new : ndarray</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        New mesh nodes.</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    `insert_1` and `insert_2` should not have common values.</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  627</span>    <span class="comment"># Because np.insert implementation apparently varies with a version of</span></div>
<div class="line"><span class="lineno">  628</span>    <span class="comment"># NumPy, we use a simple and reliable approach with sorting.</span></div>
<div class="line"><span class="lineno">  629</span>    <span class="keywordflow">return</span> np.sort(np.hstack((</div>
<div class="line"><span class="lineno">  630</span>        x,</div>
<div class="line"><span class="lineno">  631</span>        0.5 * (x[insert_1] + x[insert_1 + 1]),</div>
<div class="line"><span class="lineno">  632</span>        (2 * x[insert_2] + x[insert_2 + 1]) / 3,</div>
<div class="line"><span class="lineno">  633</span>        (x[insert_2] + 2 * x[insert_2 + 1]) / 3</div>
<div class="line"><span class="lineno">  634</span>    )))</div>
<div class="line"><span class="lineno">  635</span> </div>
<div class="line"><span class="lineno">  636</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e5192bec9ee862fea0740740b0b180a" name="a3e5192bec9ee862fea0740740b0b180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5192bec9ee862fea0740740b0b180a">&#9670;&#160;</a></span>prepare_sys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.prepare_sys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create the function and the Jacobian for the collocation system.</pre> <div class="fragment"><div class="line"><span class="lineno">  317</span><span class="keyword">def </span>prepare_sys(n, m, k, fun, bc, fun_jac, bc_jac, x, h):</div>
<div class="line"><span class="lineno">  318</span>    <span class="stringliteral">&quot;&quot;&quot;Create the function and the Jacobian for the collocation system.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  319</span>    x_middle = x[:-1] + 0.5 * h</div>
<div class="line"><span class="lineno">  320</span>    i_jac, j_jac = compute_jac_indices(n, m, k)</div>
<div class="line"><span class="lineno">  321</span> </div>
<div class="line"><span class="lineno">  322</span>    <span class="keyword">def </span>col_fun(y, p):</div>
<div class="line"><span class="lineno">  323</span>        <span class="keywordflow">return</span> collocation_fun(fun, y, p, x, h)</div>
<div class="line"><span class="lineno">  324</span> </div>
<div class="line"><span class="lineno">  325</span>    <span class="keyword">def </span>sys_jac(y, p, y_middle, f, f_middle, bc0):</div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordflow">if</span> fun_jac <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  327</span>            df_dy, df_dp = estimate_fun_jac(fun, x, y, p, f)</div>
<div class="line"><span class="lineno">  328</span>            df_dy_middle, df_dp_middle = estimate_fun_jac(</div>
<div class="line"><span class="lineno">  329</span>                fun, x_middle, y_middle, p, f_middle)</div>
<div class="line"><span class="lineno">  330</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  331</span>            df_dy, df_dp = fun_jac(x, y, p)</div>
<div class="line"><span class="lineno">  332</span>            df_dy_middle, df_dp_middle = fun_jac(x_middle, y_middle, p)</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>        <span class="keywordflow">if</span> bc_jac <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  335</span>            dbc_dya, dbc_dyb, dbc_dp = estimate_bc_jac(bc, y[:, 0], y[:, -1],</div>
<div class="line"><span class="lineno">  336</span>                                                       p, bc0)</div>
<div class="line"><span class="lineno">  337</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  338</span>            dbc_dya, dbc_dyb, dbc_dp = bc_jac(y[:, 0], y[:, -1], p)</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>        <span class="keywordflow">return</span> construct_global_jac(n, m, k, i_jac, j_jac, h, df_dy,</div>
<div class="line"><span class="lineno">  341</span>                                    df_dy_middle, df_dp, df_dp_middle, dbc_dya,</div>
<div class="line"><span class="lineno">  342</span>                                    dbc_dyb, dbc_dp)</div>
<div class="line"><span class="lineno">  343</span> </div>
<div class="line"><span class="lineno">  344</span>    <span class="keywordflow">return</span> col_fun, sys_jac</div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a91b30c7b4693fb5d60b6005793ae834a" name="a91b30c7b4693fb5d60b6005793ae834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b30c7b4693fb5d60b6005793ae834a">&#9670;&#160;</a></span>print_iteration_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.print_iteration_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  502</span><span class="keyword">def </span>print_iteration_header():</div>
<div class="line"><span class="lineno">  503</span>    print(<span class="stringliteral">&quot;{:^15}{:^15}{:^15}{:^15}{:^15}&quot;</span>.format(</div>
<div class="line"><span class="lineno">  504</span>        <span class="stringliteral">&quot;Iteration&quot;</span>, <span class="stringliteral">&quot;Max residual&quot;</span>, <span class="stringliteral">&quot;Max BC residual&quot;</span>, <span class="stringliteral">&quot;Total nodes&quot;</span>,</div>
<div class="line"><span class="lineno">  505</span>        <span class="stringliteral">&quot;Nodes added&quot;</span>))</div>
<div class="line"><span class="lineno">  506</span> </div>
<div class="line"><span class="lineno">  507</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a56031b469e5609df5d8dd39bd8f5509c" name="a56031b469e5609df5d8dd39bd8f5509c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56031b469e5609df5d8dd39bd8f5509c">&#9670;&#160;</a></span>print_iteration_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.print_iteration_progress </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>total_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_added</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  509</span>                             nodes_added):</div>
<div class="line"><span class="lineno">  510</span>    print(<span class="stringliteral">&quot;{:^15}{:^15.2e}{:^15.2e}{:^15}{:^15}&quot;</span>.format(</div>
<div class="line"><span class="lineno">  511</span>        iteration, residual, bc_residual, total_nodes, nodes_added))</div>
<div class="line"><span class="lineno">  512</span> </div>
<div class="line"><span class="lineno">  513</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7d9e00cd7b244fb96fd92ff8510b1a6" name="ac7d9e00cd7b244fb96fd92ff8510b1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d9e00cd7b244fb96fd92ff8510b1a6">&#9670;&#160;</a></span>solve_bvp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.solve_bvp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun_jac</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc_jac</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_nodes</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc_tol</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a boundary value problem for a system of ODEs.

This function numerically solves a first order system of ODEs subject to
two-point boundary conditions::

    dy / dx = f(x, y, p) + S * y / (x - a), a &lt;= x &lt;= b
    bc(y(a), y(b), p) = 0

Here x is a 1-D independent variable, y(x) is an N-D
vector-valued function and p is a k-D vector of unknown
parameters which is to be found along with y(x). For the problem to be
determined, there must be n + k boundary conditions, i.e., bc must be an
(n + k)-D function.

The last singular term on the right-hand side of the system is optional.
It is defined by an n-by-n matrix S, such that the solution must satisfy
S y(a) = 0. This condition will be forced during iterations, so it must not
contradict boundary conditions. See [2]_ for the explanation how this term
is handled when solving BVPs numerically.

Problems in a complex domain can be solved as well. In this case, y and p
are considered to be complex, and f and bc are assumed to be complex-valued
functions, but x stays real. Note that f and bc must be complex
differentiable (satisfy Cauchy-Riemann equations [4]_), otherwise you
should rewrite your problem for real and imaginary parts separately. To
solve a problem in a complex domain, pass an initial guess for y with a
complex data type (see below).

Parameters
----------
fun : callable
    Right-hand side of the system. The calling signature is ``fun(x, y)``,
    or ``fun(x, y, p)`` if parameters are present. All arguments are
    ndarray: ``x`` with shape (m,), ``y`` with shape (n, m), meaning that
    ``y[:, i]`` corresponds to ``x[i]``, and ``p`` with shape (k,). The
    return value must be an array with shape (n, m) and with the same
    layout as ``y``.
bc : callable
    Function evaluating residuals of the boundary conditions. The calling
    signature is ``bc(ya, yb)``, or ``bc(ya, yb, p)`` if parameters are
    present. All arguments are ndarray: ``ya`` and ``yb`` with shape (n,),
    and ``p`` with shape (k,). The return value must be an array with
    shape (n + k,).
x : array_like, shape (m,)
    Initial mesh. Must be a strictly increasing sequence of real numbers
    with ``x[0]=a`` and ``x[-1]=b``.
y : array_like, shape (n, m)
    Initial guess for the function values at the mesh nodes, ith column
    corresponds to ``x[i]``. For problems in a complex domain pass `y`
    with a complex data type (even if the initial guess is purely real).
p : array_like with shape (k,) or None, optional
    Initial guess for the unknown parameters. If None (default), it is
    assumed that the problem doesn't depend on any parameters.
S : array_like with shape (n, n) or None
    Matrix defining the singular term. If None (default), the problem is
    solved without the singular term.
fun_jac : callable or None, optional
    Function computing derivatives of f with respect to y and p. The
    calling signature is ``fun_jac(x, y)``, or ``fun_jac(x, y, p)`` if
    parameters are present. The return must contain 1 or 2 elements in the
    following order:

        * df_dy : array_like with shape (n, n, m), where an element
          (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j.
        * df_dp : array_like with shape (n, k, m), where an element
          (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j.

    Here q numbers nodes at which x and y are defined, whereas i and j
    number vector components. If the problem is solved without unknown
    parameters, df_dp should not be returned.

    If `fun_jac` is None (default), the derivatives will be estimated
    by the forward finite differences.
bc_jac : callable or None, optional
    Function computing derivatives of bc with respect to ya, yb, and p.
    The calling signature is ``bc_jac(ya, yb)``, or ``bc_jac(ya, yb, p)``
    if parameters are present. The return must contain 2 or 3 elements in
    the following order:

        * dbc_dya : array_like with shape (n, n), where an element (i, j)
          equals to d bc_i(ya, yb, p) / d ya_j.
        * dbc_dyb : array_like with shape (n, n), where an element (i, j)
          equals to d bc_i(ya, yb, p) / d yb_j.
        * dbc_dp : array_like with shape (n, k), where an element (i, j)
          equals to d bc_i(ya, yb, p) / d p_j.

    If the problem is solved without unknown parameters, dbc_dp should not
    be returned.

    If `bc_jac` is None (default), the derivatives will be estimated by
    the forward finite differences.
tol : float, optional
    Desired tolerance of the solution. If we define ``r = y' - f(x, y)``,
    where y is the found solution, then the solver tries to achieve on each
    mesh interval ``norm(r / (1 + abs(f)) &lt; tol``, where ``norm`` is
    estimated in a root mean squared sense (using a numerical quadrature
    formula). Default is 1e-3.
max_nodes : int, optional
    Maximum allowed number of the mesh nodes. If exceeded, the algorithm
    terminates. Default is 1000.
verbose : {0, 1, 2}, optional
    Level of algorithm's verbosity:

        * 0 (default) : work silently.
        * 1 : display a termination report.
        * 2 : display progress during iterations.
bc_tol : float, optional
    Desired absolute tolerance for the boundary condition residuals: `bc`
    value should satisfy ``abs(bc) &lt; bc_tol`` component-wise.
    Equals to `tol` by default. Up to 10 iterations are allowed to achieve this
    tolerance.

Returns
-------
Bunch object with the following fields defined:
sol : PPoly
    Found solution for y as `scipy.interpolate.PPoly` instance, a C1
    continuous cubic spline.
p : ndarray or None, shape (k,)
    Found parameters. None, if the parameters were not present in the
    problem.
x : ndarray, shape (m,)
    Nodes of the final mesh.
y : ndarray, shape (n, m)
    Solution values at the mesh nodes.
yp : ndarray, shape (n, m)
    Solution derivatives at the mesh nodes.
rms_residuals : ndarray, shape (m - 1,)
    RMS values of the relative residuals over each mesh interval (see the
    description of `tol` parameter).
niter : int
    Number of completed iterations.
status : int
    Reason for algorithm termination:

        * 0: The algorithm converged to the desired accuracy.
        * 1: The maximum number of mesh nodes is exceeded.
        * 2: A singular Jacobian encountered when solving the collocation
          system.

message : string
    Verbal description of the termination reason.
success : bool
    True if the algorithm converged to the desired accuracy (``status=0``).

Notes
-----
This function implements a 4th order collocation algorithm with the
control of residuals similar to [1]_. A collocation system is solved
by a damped Newton method with an affine-invariant criterion function as
described in [3]_.

Note that in [1]_  integral residuals are defined without normalization
by interval lengths. So, their definition is different by a multiplier of
h**0.5 (h is an interval length) from the definition used here.

.. versionadded:: 0.18.0

References
----------
.. [1] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
       Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
       Number 3, pp. 299-316, 2001.
.. [2] L.F. Shampine, P. H. Muir and H. Xu, "A User-Friendly Fortran BVP
       Solver".
.. [3] U. Ascher, R. Mattheij and R. Russell "Numerical Solution of
       Boundary Value Problems for Ordinary Differential Equations".
.. [4] `Cauchy-Riemann equations
        &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on
        Wikipedia.

Examples
--------
In the first example, we solve Bratu's problem::

    y'' + k * exp(y) = 0
    y(0) = y(1) = 0

for k = 1.

We rewrite the equation as a first-order system and implement its
right-hand side evaluation::

    y1' = y2
    y2' = -exp(y1)

&gt;&gt;&gt; def fun(x, y):
...     return np.vstack((y[1], -np.exp(y[0])))

Implement evaluation of the boundary condition residuals:

&gt;&gt;&gt; def bc(ya, yb):
...     return np.array([ya[0], yb[0]])

Define the initial mesh with 5 nodes:

&gt;&gt;&gt; x = np.linspace(0, 1, 5)

This problem is known to have two solutions. To obtain both of them, we
use two different initial guesses for y. We denote them by subscripts
a and b.

&gt;&gt;&gt; y_a = np.zeros((2, x.size))
&gt;&gt;&gt; y_b = np.zeros((2, x.size))
&gt;&gt;&gt; y_b[0] = 3

Now we are ready to run the solver.

&gt;&gt;&gt; from scipy.integrate import solve_bvp
&gt;&gt;&gt; res_a = solve_bvp(fun, bc, x, y_a)
&gt;&gt;&gt; res_b = solve_bvp(fun, bc, x, y_b)

Let's plot the two found solutions. We take an advantage of having the
solution in a spline form to produce a smooth plot.

&gt;&gt;&gt; x_plot = np.linspace(0, 1, 100)
&gt;&gt;&gt; y_plot_a = res_a.sol(x_plot)[0]
&gt;&gt;&gt; y_plot_b = res_b.sol(x_plot)[0]
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x_plot, y_plot_a, label='y_a')
&gt;&gt;&gt; plt.plot(x_plot, y_plot_b, label='y_b')
&gt;&gt;&gt; plt.legend()
&gt;&gt;&gt; plt.xlabel("x")
&gt;&gt;&gt; plt.ylabel("y")
&gt;&gt;&gt; plt.show()

We see that the two solutions have similar shape, but differ in scale
significantly.

In the second example, we solve a simple Sturm-Liouville problem::

    y'' + k**2 * y = 0
    y(0) = y(1) = 0

It is known that a non-trivial solution y = A * sin(k * x) is possible for
k = pi * n, where n is an integer. To establish the normalization constant
A = 1 we add a boundary condition::

    y'(0) = k

Again, we rewrite our equation as a first-order system and implement its
right-hand side evaluation::

    y1' = y2
    y2' = -k**2 * y1

&gt;&gt;&gt; def fun(x, y, p):
...     k = p[0]
...     return np.vstack((y[1], -k**2 * y[0]))

Note that parameters p are passed as a vector (with one element in our
case).

Implement the boundary conditions:

&gt;&gt;&gt; def bc(ya, yb, p):
...     k = p[0]
...     return np.array([ya[0], yb[0], ya[1] - k])

Set up the initial mesh and guess for y. We aim to find the solution for
k = 2 * pi, to achieve that we set values of y to approximately follow
sin(2 * pi * x):

&gt;&gt;&gt; x = np.linspace(0, 1, 5)
&gt;&gt;&gt; y = np.zeros((2, x.size))
&gt;&gt;&gt; y[0, 1] = 1
&gt;&gt;&gt; y[0, 3] = -1

Run the solver with 6 as an initial guess for k.

&gt;&gt;&gt; sol = solve_bvp(fun, bc, x, y, p=[6])

We see that the found k is approximately correct:

&gt;&gt;&gt; sol.p[0]
6.28329460046

And, finally, plot the solution to see the anticipated sinusoid:

&gt;&gt;&gt; x_plot = np.linspace(0, 1, 100)
&gt;&gt;&gt; y_plot = sol.sol(x_plot)[0]
&gt;&gt;&gt; plt.plot(x_plot, y_plot)
&gt;&gt;&gt; plt.xlabel("x")
&gt;&gt;&gt; plt.ylabel("y")
&gt;&gt;&gt; plt.show()
</pre> <div class="fragment"><div class="line"><span class="lineno">  711</span>              tol=1e-3, max_nodes=1000, verbose=0, bc_tol=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  712</span>    <span class="stringliteral">&quot;&quot;&quot;Solve a boundary value problem for a system of ODEs.</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    This function numerically solves a first order system of ODEs subject to</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    two-point boundary conditions::</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        dy / dx = f(x, y, p) + S * y / (x - a), a &lt;= x &lt;= b</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">        bc(y(a), y(b), p) = 0</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    Here x is a 1-D independent variable, y(x) is an N-D</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    vector-valued function and p is a k-D vector of unknown</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    parameters which is to be found along with y(x). For the problem to be</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    determined, there must be n + k boundary conditions, i.e., bc must be an</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    (n + k)-D function.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    The last singular term on the right-hand side of the system is optional.</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    It is defined by an n-by-n matrix S, such that the solution must satisfy</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    S y(a) = 0. This condition will be forced during iterations, so it must not</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    contradict boundary conditions. See [2]_ for the explanation how this term</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    is handled when solving BVPs numerically.</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    Problems in a complex domain can be solved as well. In this case, y and p</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    are considered to be complex, and f and bc are assumed to be complex-valued</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    functions, but x stays real. Note that f and bc must be complex</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    differentiable (satisfy Cauchy-Riemann equations [4]_), otherwise you</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    should rewrite your problem for real and imaginary parts separately. To</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    solve a problem in a complex domain, pass an initial guess for y with a</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    complex data type (see below).</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    fun : callable</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        Right-hand side of the system. The calling signature is ``fun(x, y)``,</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        or ``fun(x, y, p)`` if parameters are present. All arguments are</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        ndarray: ``x`` with shape (m,), ``y`` with shape (n, m), meaning that</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        ``y[:, i]`` corresponds to ``x[i]``, and ``p`` with shape (k,). The</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        return value must be an array with shape (n, m) and with the same</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        layout as ``y``.</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    bc : callable</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        Function evaluating residuals of the boundary conditions. The calling</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        signature is ``bc(ya, yb)``, or ``bc(ya, yb, p)`` if parameters are</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        present. All arguments are ndarray: ``ya`` and ``yb`` with shape (n,),</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        and ``p`` with shape (k,). The return value must be an array with</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        shape (n + k,).</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    x : array_like, shape (m,)</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        Initial mesh. Must be a strictly increasing sequence of real numbers</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">        with ``x[0]=a`` and ``x[-1]=b``.</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    y : array_like, shape (n, m)</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        Initial guess for the function values at the mesh nodes, ith column</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        corresponds to ``x[i]``. For problems in a complex domain pass `y`</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        with a complex data type (even if the initial guess is purely real).</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    p : array_like with shape (k,) or None, optional</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        Initial guess for the unknown parameters. If None (default), it is</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        assumed that the problem doesn&#39;t depend on any parameters.</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    S : array_like with shape (n, n) or None</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        Matrix defining the singular term. If None (default), the problem is</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        solved without the singular term.</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    fun_jac : callable or None, optional</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">        Function computing derivatives of f with respect to y and p. The</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        calling signature is ``fun_jac(x, y)``, or ``fun_jac(x, y, p)`` if</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        parameters are present. The return must contain 1 or 2 elements in the</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">        following order:</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">            * df_dy : array_like with shape (n, n, m), where an element</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">              (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j.</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">            * df_dp : array_like with shape (n, k, m), where an element</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">              (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j.</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        Here q numbers nodes at which x and y are defined, whereas i and j</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">        number vector components. If the problem is solved without unknown</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">        parameters, df_dp should not be returned.</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        If `fun_jac` is None (default), the derivatives will be estimated</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        by the forward finite differences.</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    bc_jac : callable or None, optional</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        Function computing derivatives of bc with respect to ya, yb, and p.</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        The calling signature is ``bc_jac(ya, yb)``, or ``bc_jac(ya, yb, p)``</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        if parameters are present. The return must contain 2 or 3 elements in</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">        the following order:</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">            * dbc_dya : array_like with shape (n, n), where an element (i, j)</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">              equals to d bc_i(ya, yb, p) / d ya_j.</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">            * dbc_dyb : array_like with shape (n, n), where an element (i, j)</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">              equals to d bc_i(ya, yb, p) / d yb_j.</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">            * dbc_dp : array_like with shape (n, k), where an element (i, j)</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">              equals to d bc_i(ya, yb, p) / d p_j.</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        If the problem is solved without unknown parameters, dbc_dp should not</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        be returned.</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">        If `bc_jac` is None (default), the derivatives will be estimated by</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">        the forward finite differences.</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    tol : float, optional</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        Desired tolerance of the solution. If we define ``r = y&#39; - f(x, y)``,</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        where y is the found solution, then the solver tries to achieve on each</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        mesh interval ``norm(r / (1 + abs(f)) &lt; tol``, where ``norm`` is</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        estimated in a root mean squared sense (using a numerical quadrature</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        formula). Default is 1e-3.</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    max_nodes : int, optional</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">        Maximum allowed number of the mesh nodes. If exceeded, the algorithm</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        terminates. Default is 1000.</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    verbose : {0, 1, 2}, optional</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">        Level of algorithm&#39;s verbosity:</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">            * 0 (default) : work silently.</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">            * 1 : display a termination report.</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">            * 2 : display progress during iterations.</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    bc_tol : float, optional</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        Desired absolute tolerance for the boundary condition residuals: `bc`</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">        value should satisfy ``abs(bc) &lt; bc_tol`` component-wise.</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">        Equals to `tol` by default. Up to 10 iterations are allowed to achieve this</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">        tolerance.</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    Bunch object with the following fields defined:</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    sol : PPoly</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        Found solution for y as `scipy.interpolate.PPoly` instance, a C1</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">        continuous cubic spline.</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    p : ndarray or None, shape (k,)</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">        Found parameters. None, if the parameters were not present in the</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">        problem.</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    x : ndarray, shape (m,)</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        Nodes of the final mesh.</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    y : ndarray, shape (n, m)</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">        Solution values at the mesh nodes.</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    yp : ndarray, shape (n, m)</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">        Solution derivatives at the mesh nodes.</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral">    rms_residuals : ndarray, shape (m - 1,)</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">        RMS values of the relative residuals over each mesh interval (see the</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">        description of `tol` parameter).</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    niter : int</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        Number of completed iterations.</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    status : int</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        Reason for algorithm termination:</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">            * 0: The algorithm converged to the desired accuracy.</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">            * 1: The maximum number of mesh nodes is exceeded.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">            * 2: A singular Jacobian encountered when solving the collocation</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">              system.</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    message : string</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">        Verbal description of the termination reason.</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    success : bool</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">        True if the algorithm converged to the desired accuracy (``status=0``).</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    This function implements a 4th order collocation algorithm with the</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    control of residuals similar to [1]_. A collocation system is solved</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    by a damped Newton method with an affine-invariant criterion function as</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    described in [3]_.</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    Note that in [1]_  integral residuals are defined without normalization</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    by interval lengths. So, their definition is different by a multiplier of</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    h**0.5 (h is an interval length) from the definition used here.</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    .. versionadded:: 0.18.0</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    .. [1] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">           Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27,</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">           Number 3, pp. 299-316, 2001.</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    .. [2] L.F. Shampine, P. H. Muir and H. Xu, &quot;A User-Friendly Fortran BVP</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">           Solver&quot;.</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    .. [3] U. Ascher, R. Mattheij and R. Russell &quot;Numerical Solution of</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">           Boundary Value Problems for Ordinary Differential Equations&quot;.</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    .. [4] `Cauchy-Riemann equations</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">            &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">            Wikipedia.</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    In the first example, we solve Bratu&#39;s problem::</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">        y&#39;&#39; + k * exp(y) = 0</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        y(0) = y(1) = 0</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    for k = 1.</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    We rewrite the equation as a first-order system and implement its</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    right-hand side evaluation::</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">        y1&#39; = y2</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">        y2&#39; = -exp(y1)</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    &gt;&gt;&gt; def fun(x, y):</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    ...     return np.vstack((y[1], -np.exp(y[0])))</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    Implement evaluation of the boundary condition residuals:</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    &gt;&gt;&gt; def bc(ya, yb):</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    ...     return np.array([ya[0], yb[0]])</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    Define the initial mesh with 5 nodes:</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 1, 5)</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    This problem is known to have two solutions. To obtain both of them, we</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    use two different initial guesses for y. We denote them by subscripts</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    a and b.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    &gt;&gt;&gt; y_a = np.zeros((2, x.size))</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    &gt;&gt;&gt; y_b = np.zeros((2, x.size))</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    &gt;&gt;&gt; y_b[0] = 3</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    Now we are ready to run the solver.</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.integrate import solve_bvp</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    &gt;&gt;&gt; res_a = solve_bvp(fun, bc, x, y_a)</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    &gt;&gt;&gt; res_b = solve_bvp(fun, bc, x, y_b)</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    Let&#39;s plot the two found solutions. We take an advantage of having the</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    solution in a spline form to produce a smooth plot.</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    &gt;&gt;&gt; x_plot = np.linspace(0, 1, 100)</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    &gt;&gt;&gt; y_plot_a = res_a.sol(x_plot)[0]</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    &gt;&gt;&gt; y_plot_b = res_b.sol(x_plot)[0]</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x_plot, y_plot_a, label=&#39;y_a&#39;)</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x_plot, y_plot_b, label=&#39;y_b&#39;)</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend()</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;y&quot;)</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    We see that the two solutions have similar shape, but differ in scale</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    significantly.</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    In the second example, we solve a simple Sturm-Liouville problem::</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">        y&#39;&#39; + k**2 * y = 0</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">        y(0) = y(1) = 0</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">    It is known that a non-trivial solution y = A * sin(k * x) is possible for</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    k = pi * n, where n is an integer. To establish the normalization constant</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    A = 1 we add a boundary condition::</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">        y&#39;(0) = k</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    Again, we rewrite our equation as a first-order system and implement its</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    right-hand side evaluation::</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">        y1&#39; = y2</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">        y2&#39; = -k**2 * y1</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">    &gt;&gt;&gt; def fun(x, y, p):</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    ...     k = p[0]</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    ...     return np.vstack((y[1], -k**2 * y[0]))</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    Note that parameters p are passed as a vector (with one element in our</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    case).</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    Implement the boundary conditions:</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    &gt;&gt;&gt; def bc(ya, yb, p):</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    ...     k = p[0]</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    ...     return np.array([ya[0], yb[0], ya[1] - k])</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    Set up the initial mesh and guess for y. We aim to find the solution for</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">    k = 2 * pi, to achieve that we set values of y to approximately follow</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    sin(2 * pi * x):</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 1, 5)</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    &gt;&gt;&gt; y = np.zeros((2, x.size))</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    &gt;&gt;&gt; y[0, 1] = 1</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    &gt;&gt;&gt; y[0, 3] = -1</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    Run the solver with 6 as an initial guess for k.</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    &gt;&gt;&gt; sol = solve_bvp(fun, bc, x, y, p=[6])</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    We see that the found k is approximately correct:</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    &gt;&gt;&gt; sol.p[0]</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">    6.28329460046</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    And, finally, plot the solution to see the anticipated sinusoid:</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    &gt;&gt;&gt; x_plot = np.linspace(0, 1, 100)</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    &gt;&gt;&gt; y_plot = sol.sol(x_plot)[0]</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x_plot, y_plot)</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;y&quot;)</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  998</span>    x = np.asarray(x, dtype=float)</div>
<div class="line"><span class="lineno">  999</span>    <span class="keywordflow">if</span> x.ndim != 1:</div>
<div class="line"><span class="lineno"> 1000</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`x` must be 1 dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1001</span>    h = np.diff(x)</div>
<div class="line"><span class="lineno"> 1002</span>    <span class="keywordflow">if</span> np.any(h &lt;= 0):</div>
<div class="line"><span class="lineno"> 1003</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`x` must be strictly increasing.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1004</span>    a = x[0]</div>
<div class="line"><span class="lineno"> 1005</span> </div>
<div class="line"><span class="lineno"> 1006</span>    y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 1007</span>    <span class="keywordflow">if</span> np.issubdtype(y.dtype, np.complexfloating):</div>
<div class="line"><span class="lineno"> 1008</span>        dtype = complex</div>
<div class="line"><span class="lineno"> 1009</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1010</span>        dtype = float</div>
<div class="line"><span class="lineno"> 1011</span>    y = y.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1012</span> </div>
<div class="line"><span class="lineno"> 1013</span>    <span class="keywordflow">if</span> y.ndim != 2:</div>
<div class="line"><span class="lineno"> 1014</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`y` must be 2 dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1015</span>    <span class="keywordflow">if</span> y.shape[1] != x.shape[0]:</div>
<div class="line"><span class="lineno"> 1016</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`y` is expected to have {} columns, but actually &quot;</span></div>
<div class="line"><span class="lineno"> 1017</span>                         <span class="stringliteral">&quot;has {}.&quot;</span>.format(x.shape[0], y.shape[1]))</div>
<div class="line"><span class="lineno"> 1018</span> </div>
<div class="line"><span class="lineno"> 1019</span>    <span class="keywordflow">if</span> p <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1020</span>        p = np.array([])</div>
<div class="line"><span class="lineno"> 1021</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1022</span>        p = np.asarray(p, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1023</span>    <span class="keywordflow">if</span> p.ndim != 1:</div>
<div class="line"><span class="lineno"> 1024</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`p` must be 1 dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1025</span> </div>
<div class="line"><span class="lineno"> 1026</span>    <span class="keywordflow">if</span> tol &lt; 100 * EPS:</div>
<div class="line"><span class="lineno"> 1027</span>        warn(<span class="stringliteral">&quot;`tol` is too low, setting to {:.2e}&quot;</span>.format(100 * EPS))</div>
<div class="line"><span class="lineno"> 1028</span>        tol = 100 * EPS</div>
<div class="line"><span class="lineno"> 1029</span> </div>
<div class="line"><span class="lineno"> 1030</span>    <span class="keywordflow">if</span> verbose <span class="keywordflow">not</span> <span class="keywordflow">in</span> [0, 1, 2]:</div>
<div class="line"><span class="lineno"> 1031</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`verbose` must be in [0, 1, 2].&quot;</span>)</div>
<div class="line"><span class="lineno"> 1032</span> </div>
<div class="line"><span class="lineno"> 1033</span>    n = y.shape[0]</div>
<div class="line"><span class="lineno"> 1034</span>    k = p.shape[0]</div>
<div class="line"><span class="lineno"> 1035</span> </div>
<div class="line"><span class="lineno"> 1036</span>    <span class="keywordflow">if</span> S <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1037</span>        S = np.asarray(S, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1038</span>        <span class="keywordflow">if</span> S.shape != (n, n):</div>
<div class="line"><span class="lineno"> 1039</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`S` is expected to have shape {}, &quot;</span></div>
<div class="line"><span class="lineno"> 1040</span>                             <span class="stringliteral">&quot;but actually has {}&quot;</span>.format((n, n), S.shape))</div>
<div class="line"><span class="lineno"> 1041</span> </div>
<div class="line"><span class="lineno"> 1042</span>        <span class="comment"># Compute I - S^+ S to impose necessary boundary conditions.</span></div>
<div class="line"><span class="lineno"> 1043</span>        B = np.identity(n) - np.dot(pinv(S), S)</div>
<div class="line"><span class="lineno"> 1044</span> </div>
<div class="line"><span class="lineno"> 1045</span>        y[:, 0] = np.dot(B, y[:, 0])</div>
<div class="line"><span class="lineno"> 1046</span> </div>
<div class="line"><span class="lineno"> 1047</span>        <span class="comment"># Compute (I - S)^+ to correct derivatives at x=a.</span></div>
<div class="line"><span class="lineno"> 1048</span>        D = pinv(np.identity(n) - S)</div>
<div class="line"><span class="lineno"> 1049</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1050</span>        B = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1051</span>        D = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1052</span> </div>
<div class="line"><span class="lineno"> 1053</span>    <span class="keywordflow">if</span> bc_tol <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1054</span>        bc_tol = tol</div>
<div class="line"><span class="lineno"> 1055</span> </div>
<div class="line"><span class="lineno"> 1056</span>    <span class="comment"># Maximum number of iterations</span></div>
<div class="line"><span class="lineno"> 1057</span>    max_iteration = 10</div>
<div class="line"><span class="lineno"> 1058</span> </div>
<div class="line"><span class="lineno"> 1059</span>    fun_wrapped, bc_wrapped, fun_jac_wrapped, bc_jac_wrapped = wrap_functions(</div>
<div class="line"><span class="lineno"> 1060</span>        fun, bc, fun_jac, bc_jac, k, a, S, D, dtype)</div>
<div class="line"><span class="lineno"> 1061</span> </div>
<div class="line"><span class="lineno"> 1062</span>    f = fun_wrapped(x, y, p)</div>
<div class="line"><span class="lineno"> 1063</span>    <span class="keywordflow">if</span> f.shape != y.shape:</div>
<div class="line"><span class="lineno"> 1064</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`fun` return is expected to have shape {}, &quot;</span></div>
<div class="line"><span class="lineno"> 1065</span>                         <span class="stringliteral">&quot;but actually has {}.&quot;</span>.format(y.shape, f.shape))</div>
<div class="line"><span class="lineno"> 1066</span> </div>
<div class="line"><span class="lineno"> 1067</span>    bc_res = bc_wrapped(y[:, 0], y[:, -1], p)</div>
<div class="line"><span class="lineno"> 1068</span>    <span class="keywordflow">if</span> bc_res.shape != (n + k,):</div>
<div class="line"><span class="lineno"> 1069</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`bc` return is expected to have shape {}, &quot;</span></div>
<div class="line"><span class="lineno"> 1070</span>                         <span class="stringliteral">&quot;but actually has {}.&quot;</span>.format((n + k,), bc_res.shape))</div>
<div class="line"><span class="lineno"> 1071</span> </div>
<div class="line"><span class="lineno"> 1072</span>    status = 0</div>
<div class="line"><span class="lineno"> 1073</span>    iteration = 0</div>
<div class="line"><span class="lineno"> 1074</span>    <span class="keywordflow">if</span> verbose == 2:</div>
<div class="line"><span class="lineno"> 1075</span>        print_iteration_header()</div>
<div class="line"><span class="lineno"> 1076</span> </div>
<div class="line"><span class="lineno"> 1077</span>    <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno"> 1078</span>        m = x.shape[0]</div>
<div class="line"><span class="lineno"> 1079</span> </div>
<div class="line"><span class="lineno"> 1080</span>        col_fun, jac_sys = prepare_sys(n, m, k, fun_wrapped, bc_wrapped,</div>
<div class="line"><span class="lineno"> 1081</span>                                       fun_jac_wrapped, bc_jac_wrapped, x, h)</div>
<div class="line"><span class="lineno"> 1082</span>        y, p, singular = solve_newton(n, m, h, col_fun, bc_wrapped, jac_sys,</div>
<div class="line"><span class="lineno"> 1083</span>                                      y, p, B, tol, bc_tol)</div>
<div class="line"><span class="lineno"> 1084</span>        iteration += 1</div>
<div class="line"><span class="lineno"> 1085</span> </div>
<div class="line"><span class="lineno"> 1086</span>        col_res, y_middle, f, f_middle = collocation_fun(fun_wrapped, y,</div>
<div class="line"><span class="lineno"> 1087</span>                                                         p, x, h)</div>
<div class="line"><span class="lineno"> 1088</span>        bc_res = bc_wrapped(y[:, 0], y[:, -1], p)</div>
<div class="line"><span class="lineno"> 1089</span>        max_bc_res = np.max(abs(bc_res))</div>
<div class="line"><span class="lineno"> 1090</span> </div>
<div class="line"><span class="lineno"> 1091</span>        <span class="comment"># This relation is not trivial, but can be verified.</span></div>
<div class="line"><span class="lineno"> 1092</span>        r_middle = 1.5 * col_res / h</div>
<div class="line"><span class="lineno"> 1093</span>        sol = create_spline(y, f, x, h)</div>
<div class="line"><span class="lineno"> 1094</span>        rms_res = estimate_rms_residuals(fun_wrapped, sol, x, h, p,</div>
<div class="line"><span class="lineno"> 1095</span>                                         r_middle, f_middle)</div>
<div class="line"><span class="lineno"> 1096</span>        max_rms_res = np.max(rms_res)</div>
<div class="line"><span class="lineno"> 1097</span> </div>
<div class="line"><span class="lineno"> 1098</span>        <span class="keywordflow">if</span> singular:</div>
<div class="line"><span class="lineno"> 1099</span>            status = 2</div>
<div class="line"><span class="lineno"> 1100</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1101</span> </div>
<div class="line"><span class="lineno"> 1102</span>        insert_1, = np.nonzero((rms_res &gt; tol) &amp; (rms_res &lt; 100 * tol))</div>
<div class="line"><span class="lineno"> 1103</span>        insert_2, = np.nonzero(rms_res &gt;= 100 * tol)</div>
<div class="line"><span class="lineno"> 1104</span>        nodes_added = insert_1.shape[0] + 2 * insert_2.shape[0]</div>
<div class="line"><span class="lineno"> 1105</span> </div>
<div class="line"><span class="lineno"> 1106</span>        <span class="keywordflow">if</span> m + nodes_added &gt; max_nodes:</div>
<div class="line"><span class="lineno"> 1107</span>            status = 1</div>
<div class="line"><span class="lineno"> 1108</span>            <span class="keywordflow">if</span> verbose == 2:</div>
<div class="line"><span class="lineno"> 1109</span>                nodes_added = <span class="stringliteral">&quot;({})&quot;</span>.format(nodes_added)</div>
<div class="line"><span class="lineno"> 1110</span>                print_iteration_progress(iteration, max_rms_res, max_bc_res,</div>
<div class="line"><span class="lineno"> 1111</span>                                         m, nodes_added)</div>
<div class="line"><span class="lineno"> 1112</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1113</span> </div>
<div class="line"><span class="lineno"> 1114</span>        <span class="keywordflow">if</span> verbose == 2:</div>
<div class="line"><span class="lineno"> 1115</span>            print_iteration_progress(iteration, max_rms_res, max_bc_res, m,</div>
<div class="line"><span class="lineno"> 1116</span>                                     nodes_added)</div>
<div class="line"><span class="lineno"> 1117</span> </div>
<div class="line"><span class="lineno"> 1118</span>        <span class="keywordflow">if</span> nodes_added &gt; 0:</div>
<div class="line"><span class="lineno"> 1119</span>            x = modify_mesh(x, insert_1, insert_2)</div>
<div class="line"><span class="lineno"> 1120</span>            h = np.diff(x)</div>
<div class="line"><span class="lineno"> 1121</span>            y = sol(x)</div>
<div class="line"><span class="lineno"> 1122</span>        <span class="keywordflow">elif</span> max_bc_res &lt;= bc_tol:</div>
<div class="line"><span class="lineno"> 1123</span>            status = 0</div>
<div class="line"><span class="lineno"> 1124</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1125</span>        <span class="keywordflow">elif</span> iteration &gt;= max_iteration:</div>
<div class="line"><span class="lineno"> 1126</span>            status = 3</div>
<div class="line"><span class="lineno"> 1127</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1128</span> </div>
<div class="line"><span class="lineno"> 1129</span>    <span class="keywordflow">if</span> verbose &gt; 0:</div>
<div class="line"><span class="lineno"> 1130</span>        <span class="keywordflow">if</span> status == 0:</div>
<div class="line"><span class="lineno"> 1131</span>            print(<span class="stringliteral">&quot;Solved in {} iterations, number of nodes {}. \n&quot;</span></div>
<div class="line"><span class="lineno"> 1132</span>                  <span class="stringliteral">&quot;Maximum relative residual: {:.2e} \n&quot;</span></div>
<div class="line"><span class="lineno"> 1133</span>                  <span class="stringliteral">&quot;Maximum boundary residual: {:.2e}&quot;</span></div>
<div class="line"><span class="lineno"> 1134</span>                  .format(iteration, x.shape[0], max_rms_res, max_bc_res))</div>
<div class="line"><span class="lineno"> 1135</span>        <span class="keywordflow">elif</span> status == 1:</div>
<div class="line"><span class="lineno"> 1136</span>            print(<span class="stringliteral">&quot;Number of nodes is exceeded after iteration {}. \n&quot;</span></div>
<div class="line"><span class="lineno"> 1137</span>                  <span class="stringliteral">&quot;Maximum relative residual: {:.2e} \n&quot;</span></div>
<div class="line"><span class="lineno"> 1138</span>                  <span class="stringliteral">&quot;Maximum boundary residual: {:.2e}&quot;</span></div>
<div class="line"><span class="lineno"> 1139</span>                  .format(iteration, max_rms_res, max_bc_res))</div>
<div class="line"><span class="lineno"> 1140</span>        <span class="keywordflow">elif</span> status == 2:</div>
<div class="line"><span class="lineno"> 1141</span>            print(<span class="stringliteral">&quot;Singular Jacobian encountered when solving the collocation &quot;</span></div>
<div class="line"><span class="lineno"> 1142</span>                  <span class="stringliteral">&quot;system on iteration {}. \n&quot;</span></div>
<div class="line"><span class="lineno"> 1143</span>                  <span class="stringliteral">&quot;Maximum relative residual: {:.2e} \n&quot;</span></div>
<div class="line"><span class="lineno"> 1144</span>                  <span class="stringliteral">&quot;Maximum boundary residual: {:.2e}&quot;</span></div>
<div class="line"><span class="lineno"> 1145</span>                  .format(iteration, max_rms_res, max_bc_res))</div>
<div class="line"><span class="lineno"> 1146</span>        <span class="keywordflow">elif</span> status == 3:</div>
<div class="line"><span class="lineno"> 1147</span>            print(<span class="stringliteral">&quot;The solver was unable to satisfy boundary conditions &quot;</span></div>
<div class="line"><span class="lineno"> 1148</span>                  <span class="stringliteral">&quot;tolerance on iteration {}. \n&quot;</span></div>
<div class="line"><span class="lineno"> 1149</span>                  <span class="stringliteral">&quot;Maximum relative residual: {:.2e} \n&quot;</span></div>
<div class="line"><span class="lineno"> 1150</span>                  <span class="stringliteral">&quot;Maximum boundary residual: {:.2e}&quot;</span></div>
<div class="line"><span class="lineno"> 1151</span>                  .format(iteration, max_rms_res, max_bc_res))</div>
<div class="line"><span class="lineno"> 1152</span> </div>
<div class="line"><span class="lineno"> 1153</span>    <span class="keywordflow">if</span> p.size == 0:</div>
<div class="line"><span class="lineno"> 1154</span>        p = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1155</span> </div>
<div class="line"><span class="lineno"> 1156</span>    <span class="keywordflow">return</span> BVPResult(sol=sol, p=p, x=x, y=y, yp=f, rms_residuals=rms_res,</div>
<div class="line"><span class="lineno"> 1157</span>                     niter=iteration, status=status,</div>
<div class="line"><span class="lineno"> 1158</span>                     message=TERMINATION_MESSAGES[status], success=status == 0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b44b4b962bed36f279bfe9307fe6eb3" name="a9b44b4b962bed36f279bfe9307fe6eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b44b4b962bed36f279bfe9307fe6eb3">&#9670;&#160;</a></span>solve_newton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.solve_newton </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>col_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bvp_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the nonlinear collocation system by a Newton method.

This is a simple Newton method with a backtracking line search. As
advised in [1]_, an affine-invariant criterion function F = ||J^-1 r||^2
is used, where J is the Jacobian matrix at the current iteration and r is
the vector or collocation residuals (values of the system lhs).

The method alters between full Newton iterations and the fixed-Jacobian
iterations based

There are other tricks proposed in [1]_, but they are not used as they
don't seem to improve anything significantly, and even break the
convergence on some test problems I tried.

All important parameters of the algorithm are defined inside the function.

Parameters
----------
n : int
    Number of equations in the ODE system.
m : int
    Number of nodes in the mesh.
h : ndarray, shape (m-1,)
    Mesh intervals.
col_fun : callable
    Function computing collocation residuals.
bc : callable
    Function computing boundary condition residuals.
jac : callable
    Function computing the Jacobian of the whole system (including
    collocation and boundary condition residuals). It is supposed to
    return csc_matrix.
y : ndarray, shape (n, m)
    Initial guess for the function values at the mesh nodes.
p : ndarray, shape (k,)
    Initial guess for the unknown parameters.
B : ndarray with shape (n, n) or None
    Matrix to force the S y(a) = 0 condition for a problems with the
    singular term. If None, the singular term is assumed to be absent.
bvp_tol : float
    Tolerance to which we want to solve a BVP.
bc_tol : float
    Tolerance to which we want to satisfy the boundary conditions.

Returns
-------
y : ndarray, shape (n, m)
    Final iterate for the function values at the mesh nodes.
p : ndarray, shape (k,)
    Final iterate for the unknown parameters.
singular : bool
    True, if the LU decomposition failed because Jacobian turned out
    to be singular.

References
----------
.. [1]  U. Ascher, R. Mattheij and R. Russell "Numerical Solution of
   Boundary Value Problems for Ordinary Differential Equations"
</pre> <div class="fragment"><div class="line"><span class="lineno">  347</span><span class="keyword">def </span>solve_newton(n, m, h, col_fun, bc, jac, y, p, B, bvp_tol, bc_tol):</div>
<div class="line"><span class="lineno">  348</span>    <span class="stringliteral">&quot;&quot;&quot;Solve the nonlinear collocation system by a Newton method.</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    This is a simple Newton method with a backtracking line search. As</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    advised in [1]_, an affine-invariant criterion function F = ||J^-1 r||^2</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    is used, where J is the Jacobian matrix at the current iteration and r is</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    the vector or collocation residuals (values of the system lhs).</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    The method alters between full Newton iterations and the fixed-Jacobian</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    iterations based</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    There are other tricks proposed in [1]_, but they are not used as they</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    don&#39;t seem to improve anything significantly, and even break the</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    convergence on some test problems I tried.</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    All important parameters of the algorithm are defined inside the function.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">        Number of equations in the ODE system.</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    m : int</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">        Number of nodes in the mesh.</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    h : ndarray, shape (m-1,)</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">        Mesh intervals.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    col_fun : callable</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">        Function computing collocation residuals.</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    bc : callable</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        Function computing boundary condition residuals.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    jac : callable</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        Function computing the Jacobian of the whole system (including</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        collocation and boundary condition residuals). It is supposed to</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        return csc_matrix.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    y : ndarray, shape (n, m)</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        Initial guess for the function values at the mesh nodes.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    p : ndarray, shape (k,)</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        Initial guess for the unknown parameters.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    B : ndarray with shape (n, n) or None</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">        Matrix to force the S y(a) = 0 condition for a problems with the</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">        singular term. If None, the singular term is assumed to be absent.</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    bvp_tol : float</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        Tolerance to which we want to solve a BVP.</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    bc_tol : float</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">        Tolerance to which we want to satisfy the boundary conditions.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    y : ndarray, shape (n, m)</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">        Final iterate for the function values at the mesh nodes.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    p : ndarray, shape (k,)</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">        Final iterate for the unknown parameters.</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    singular : bool</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        True, if the LU decomposition failed because Jacobian turned out</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        to be singular.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    .. [1]  U. Ascher, R. Mattheij and R. Russell &quot;Numerical Solution of</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">       Boundary Value Problems for Ordinary Differential Equations&quot;</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  407</span>    <span class="comment"># We know that the solution residuals at the middle points of the mesh</span></div>
<div class="line"><span class="lineno">  408</span>    <span class="comment"># are connected with collocation residuals  r_middle = 1.5 * col_res / h.</span></div>
<div class="line"><span class="lineno">  409</span>    <span class="comment"># As our BVP solver tries to decrease relative residuals below a certain</span></div>
<div class="line"><span class="lineno">  410</span>    <span class="comment"># tolerance, it seems reasonable to terminated Newton iterations by</span></div>
<div class="line"><span class="lineno">  411</span>    <span class="comment"># comparison of r_middle / (1 + np.abs(f_middle)) with a certain threshold,</span></div>
<div class="line"><span class="lineno">  412</span>    <span class="comment"># which we choose to be 1.5 orders lower than the BVP tolerance. We rewrite</span></div>
<div class="line"><span class="lineno">  413</span>    <span class="comment"># the condition as col_res &lt; tol_r * (1 + np.abs(f_middle)), then tol_r</span></div>
<div class="line"><span class="lineno">  414</span>    <span class="comment"># should be computed as follows:</span></div>
<div class="line"><span class="lineno">  415</span>    tol_r = 2/3 * h * 5e-2 * bvp_tol</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>    <span class="comment"># Maximum allowed number of Jacobian evaluation and factorization, in</span></div>
<div class="line"><span class="lineno">  418</span>    <span class="comment"># other words, the maximum number of full Newton iterations. A small value</span></div>
<div class="line"><span class="lineno">  419</span>    <span class="comment"># is recommended in the literature.</span></div>
<div class="line"><span class="lineno">  420</span>    max_njev = 4</div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span>    <span class="comment"># Maximum number of iterations, considering that some of them can be</span></div>
<div class="line"><span class="lineno">  423</span>    <span class="comment"># performed with the fixed Jacobian. In theory, such iterations are cheap,</span></div>
<div class="line"><span class="lineno">  424</span>    <span class="comment"># but it&#39;s not that simple in Python.</span></div>
<div class="line"><span class="lineno">  425</span>    max_iter = 8</div>
<div class="line"><span class="lineno">  426</span> </div>
<div class="line"><span class="lineno">  427</span>    <span class="comment"># Minimum relative improvement of the criterion function to accept the</span></div>
<div class="line"><span class="lineno">  428</span>    <span class="comment"># step (Armijo constant).</span></div>
<div class="line"><span class="lineno">  429</span>    sigma = 0.2</div>
<div class="line"><span class="lineno">  430</span> </div>
<div class="line"><span class="lineno">  431</span>    <span class="comment"># Step size decrease factor for backtracking.</span></div>
<div class="line"><span class="lineno">  432</span>    tau = 0.5</div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>    <span class="comment"># Maximum number of backtracking steps, the minimum step is then</span></div>
<div class="line"><span class="lineno">  435</span>    <span class="comment"># tau ** n_trial.</span></div>
<div class="line"><span class="lineno">  436</span>    n_trial = 4</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span>    col_res, y_middle, f, f_middle = col_fun(y, p)</div>
<div class="line"><span class="lineno">  439</span>    bc_res = bc(y[:, 0], y[:, -1], p)</div>
<div class="line"><span class="lineno">  440</span>    res = np.hstack((col_res.ravel(order=<span class="stringliteral">&#39;F&#39;</span>), bc_res))</div>
<div class="line"><span class="lineno">  441</span> </div>
<div class="line"><span class="lineno">  442</span>    njev = 0</div>
<div class="line"><span class="lineno">  443</span>    singular = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  444</span>    recompute_jac = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  445</span>    <span class="keywordflow">for</span> iteration <span class="keywordflow">in</span> range(max_iter):</div>
<div class="line"><span class="lineno">  446</span>        <span class="keywordflow">if</span> recompute_jac:</div>
<div class="line"><span class="lineno">  447</span>            J = jac(y, p, y_middle, f, f_middle, bc_res)</div>
<div class="line"><span class="lineno">  448</span>            njev += 1</div>
<div class="line"><span class="lineno">  449</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  450</span>                LU = splu(J)</div>
<div class="line"><span class="lineno">  451</span>            <span class="keywordflow">except</span> RuntimeError:</div>
<div class="line"><span class="lineno">  452</span>                singular = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  453</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  454</span> </div>
<div class="line"><span class="lineno">  455</span>            step = LU.solve(res)</div>
<div class="line"><span class="lineno">  456</span>            cost = np.dot(step, step)</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>        y_step = step[:m * n].reshape((n, m), order=<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno">  459</span>        p_step = step[m * n:]</div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span>        alpha = 1</div>
<div class="line"><span class="lineno">  462</span>        <span class="keywordflow">for</span> trial <span class="keywordflow">in</span> range(n_trial + 1):</div>
<div class="line"><span class="lineno">  463</span>            y_new = y - alpha * y_step</div>
<div class="line"><span class="lineno">  464</span>            <span class="keywordflow">if</span> B <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  465</span>                y_new[:, 0] = np.dot(B, y_new[:, 0])</div>
<div class="line"><span class="lineno">  466</span>            p_new = p - alpha * p_step</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>            col_res, y_middle, f, f_middle = col_fun(y_new, p_new)</div>
<div class="line"><span class="lineno">  469</span>            bc_res = bc(y_new[:, 0], y_new[:, -1], p_new)</div>
<div class="line"><span class="lineno">  470</span>            res = np.hstack((col_res.ravel(order=<span class="stringliteral">&#39;F&#39;</span>), bc_res))</div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>            step_new = LU.solve(res)</div>
<div class="line"><span class="lineno">  473</span>            cost_new = np.dot(step_new, step_new)</div>
<div class="line"><span class="lineno">  474</span>            <span class="keywordflow">if</span> cost_new &lt; (1 - 2 * alpha * sigma) * cost:</div>
<div class="line"><span class="lineno">  475</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  476</span> </div>
<div class="line"><span class="lineno">  477</span>            <span class="keywordflow">if</span> trial &lt; n_trial:</div>
<div class="line"><span class="lineno">  478</span>                alpha *= tau</div>
<div class="line"><span class="lineno">  479</span> </div>
<div class="line"><span class="lineno">  480</span>        y = y_new</div>
<div class="line"><span class="lineno">  481</span>        p = p_new</div>
<div class="line"><span class="lineno">  482</span> </div>
<div class="line"><span class="lineno">  483</span>        <span class="keywordflow">if</span> njev == max_njev:</div>
<div class="line"><span class="lineno">  484</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  485</span> </div>
<div class="line"><span class="lineno">  486</span>        <span class="keywordflow">if</span> (np.all(np.abs(col_res) &lt; tol_r * (1 + np.abs(f_middle))) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  487</span>                np.all(np.abs(bc_res) &lt; bc_tol)):</div>
<div class="line"><span class="lineno">  488</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>        <span class="comment"># If the full step was taken, then we are going to continue with</span></div>
<div class="line"><span class="lineno">  491</span>        <span class="comment"># the same Jacobian. This is the approach of BVP_SOLVER.</span></div>
<div class="line"><span class="lineno">  492</span>        <span class="keywordflow">if</span> alpha == 1:</div>
<div class="line"><span class="lineno">  493</span>            step = step_new</div>
<div class="line"><span class="lineno">  494</span>            cost = cost_new</div>
<div class="line"><span class="lineno">  495</span>            recompute_jac = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  496</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  497</span>            recompute_jac = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  498</span> </div>
<div class="line"><span class="lineno">  499</span>    <span class="keywordflow">return</span> y, p, singular</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d2ee109a1b89b59380bc4d9aa0b57ba" name="a1d2ee109a1b89b59380bc4d9aa0b57ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2ee109a1b89b59380bc4d9aa0b57ba">&#9670;&#160;</a></span>stacked_matmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.stacked_matmul </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stacked matrix multiply: out[i,:,:] = np.dot(a[i,:,:], b[i,:,:]).

Empirical optimization. Use outer Python loop and BLAS for large
matrices, otherwise use a single einsum call.
</pre> <div class="fragment"><div class="line"><span class="lineno">  143</span><span class="keyword">def </span>stacked_matmul(a, b):</div>
<div class="line"><span class="lineno">  144</span>    <span class="stringliteral">&quot;&quot;&quot;Stacked matrix multiply: out[i,:,:] = np.dot(a[i,:,:], b[i,:,:]).</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    Empirical optimization. Use outer Python loop and BLAS for large</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    matrices, otherwise use a single einsum call.</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">if</span> a.shape[1] &gt; 50:</div>
<div class="line"><span class="lineno">  150</span>        out = np.empty((a.shape[0], a.shape[1], b.shape[2]))</div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(a.shape[0]):</div>
<div class="line"><span class="lineno">  152</span>            out[i] = np.dot(a[i], b[i])</div>
<div class="line"><span class="lineno">  153</span>        <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  155</span>        <span class="keywordflow">return</span> np.einsum(<span class="stringliteral">&#39;...ij,...jk-&gt;...ik&#39;</span>, a, b)</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab326bbe47e4328938c2cf9b65c6d5dc3" name="ab326bbe47e4328938c2cf9b65c6d5dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab326bbe47e4328938c2cf9b65c6d5dc3">&#9670;&#160;</a></span>wrap_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.wrap_functions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fun_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrap functions for unified usage in the solver.</pre> <div class="fragment"><div class="line"><span class="lineno">  637</span><span class="keyword">def </span>wrap_functions(fun, bc, fun_jac, bc_jac, k, a, S, D, dtype):</div>
<div class="line"><span class="lineno">  638</span>    <span class="stringliteral">&quot;&quot;&quot;Wrap functions for unified usage in the solver.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  639</span>    <span class="keywordflow">if</span> fun_jac <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  640</span>        fun_jac_wrapped = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  641</span> </div>
<div class="line"><span class="lineno">  642</span>    <span class="keywordflow">if</span> bc_jac <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  643</span>        bc_jac_wrapped = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  644</span> </div>
<div class="line"><span class="lineno">  645</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno">  646</span>        <span class="keyword">def </span>fun_p(x, y, _):</div>
<div class="line"><span class="lineno">  647</span>            <span class="keywordflow">return</span> np.asarray(fun(x, y), dtype)</div>
<div class="line"><span class="lineno">  648</span> </div>
<div class="line"><span class="lineno">  649</span>        <span class="keyword">def </span>bc_wrapped(ya, yb, _):</div>
<div class="line"><span class="lineno">  650</span>            <span class="keywordflow">return</span> np.asarray(bc(ya, yb), dtype)</div>
<div class="line"><span class="lineno">  651</span> </div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">if</span> fun_jac <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  653</span>            <span class="keyword">def </span>fun_jac_p(x, y, _):</div>
<div class="line"><span class="lineno">  654</span>                <span class="keywordflow">return</span> np.asarray(fun_jac(x, y), dtype), <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span>        <span class="keywordflow">if</span> bc_jac <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  657</span>            <span class="keyword">def </span>bc_jac_wrapped(ya, yb, _):</div>
<div class="line"><span class="lineno">  658</span>                dbc_dya, dbc_dyb = bc_jac(ya, yb)</div>
<div class="line"><span class="lineno">  659</span>                <span class="keywordflow">return</span> (np.asarray(dbc_dya, dtype),</div>
<div class="line"><span class="lineno">  660</span>                        np.asarray(dbc_dyb, dtype), <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  661</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  662</span>        <span class="keyword">def </span>fun_p(x, y, p):</div>
<div class="line"><span class="lineno">  663</span>            <span class="keywordflow">return</span> np.asarray(fun(x, y, p), dtype)</div>
<div class="line"><span class="lineno">  664</span> </div>
<div class="line"><span class="lineno">  665</span>        <span class="keyword">def </span>bc_wrapped(x, y, p):</div>
<div class="line"><span class="lineno">  666</span>            <span class="keywordflow">return</span> np.asarray(bc(x, y, p), dtype)</div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span>        <span class="keywordflow">if</span> fun_jac <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  669</span>            <span class="keyword">def </span>fun_jac_p(x, y, p):</div>
<div class="line"><span class="lineno">  670</span>                df_dy, df_dp = fun_jac(x, y, p)</div>
<div class="line"><span class="lineno">  671</span>                <span class="keywordflow">return</span> np.asarray(df_dy, dtype), np.asarray(df_dp, dtype)</div>
<div class="line"><span class="lineno">  672</span> </div>
<div class="line"><span class="lineno">  673</span>        <span class="keywordflow">if</span> bc_jac <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  674</span>            <span class="keyword">def </span>bc_jac_wrapped(ya, yb, p):</div>
<div class="line"><span class="lineno">  675</span>                dbc_dya, dbc_dyb, dbc_dp = bc_jac(ya, yb, p)</div>
<div class="line"><span class="lineno">  676</span>                <span class="keywordflow">return</span> (np.asarray(dbc_dya, dtype), np.asarray(dbc_dyb, dtype),</div>
<div class="line"><span class="lineno">  677</span>                        np.asarray(dbc_dp, dtype))</div>
<div class="line"><span class="lineno">  678</span> </div>
<div class="line"><span class="lineno">  679</span>    <span class="keywordflow">if</span> S <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  680</span>        fun_wrapped = fun_p</div>
<div class="line"><span class="lineno">  681</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  682</span>        <span class="keyword">def </span>fun_wrapped(x, y, p):</div>
<div class="line"><span class="lineno">  683</span>            f = fun_p(x, y, p)</div>
<div class="line"><span class="lineno">  684</span>            <span class="keywordflow">if</span> x[0] == a:</div>
<div class="line"><span class="lineno">  685</span>                f[:, 0] = np.dot(D, f[:, 0])</div>
<div class="line"><span class="lineno">  686</span>                f[:, 1:] += np.dot(S, y[:, 1:]) / (x[1:] - a)</div>
<div class="line"><span class="lineno">  687</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  688</span>                f += np.dot(S, y) / (x - a)</div>
<div class="line"><span class="lineno">  689</span>            <span class="keywordflow">return</span> f</div>
<div class="line"><span class="lineno">  690</span> </div>
<div class="line"><span class="lineno">  691</span>    <span class="keywordflow">if</span> fun_jac <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  692</span>        <span class="keywordflow">if</span> S <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  693</span>            fun_jac_wrapped = fun_jac_p</div>
<div class="line"><span class="lineno">  694</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  695</span>            Sr = S[:, :, np.newaxis]</div>
<div class="line"><span class="lineno">  696</span> </div>
<div class="line"><span class="lineno">  697</span>            <span class="keyword">def </span>fun_jac_wrapped(x, y, p):</div>
<div class="line"><span class="lineno">  698</span>                df_dy, df_dp = fun_jac_p(x, y, p)</div>
<div class="line"><span class="lineno">  699</span>                <span class="keywordflow">if</span> x[0] == a:</div>
<div class="line"><span class="lineno">  700</span>                    df_dy[:, :, 0] = np.dot(D, df_dy[:, :, 0])</div>
<div class="line"><span class="lineno">  701</span>                    df_dy[:, :, 1:] += Sr / (x[1:] - a)</div>
<div class="line"><span class="lineno">  702</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  703</span>                    df_dy += Sr / (x - a)</div>
<div class="line"><span class="lineno">  704</span> </div>
<div class="line"><span class="lineno">  705</span>                <span class="keywordflow">return</span> df_dy, df_dp</div>
<div class="line"><span class="lineno">  706</span> </div>
<div class="line"><span class="lineno">  707</span>    <span class="keywordflow">return</span> fun_wrapped, bc_wrapped, fun_jac_wrapped, bc_jac_wrapped</div>
<div class="line"><span class="lineno">  708</span> </div>
<div class="line"><span class="lineno">  709</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad99dbe0f4c37ff34045848221ac5174e" name="ad99dbe0f4c37ff34045848221ac5174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99dbe0f4c37ff34045848221ac5174e">&#9670;&#160;</a></span>EPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.EPS = np.finfo(float).<a class="el" href="__lapack__subroutines_8h.html#a57833d05f43fd1408080af6eec88fc43">eps</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e0abd96fce877bfa6f1ba4fc0774515" name="a9e0abd96fce877bfa6f1ba4fc0774515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0abd96fce877bfa6f1ba4fc0774515">&#9670;&#160;</a></span>TERMINATION_MESSAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.integrate._bvp.TERMINATION_MESSAGES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    0: <span class="stringliteral">&quot;The algorithm converged to the desired accuracy.&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    1: <span class="stringliteral">&quot;The maximum number of mesh nodes is exceeded.&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    2: <span class="stringliteral">&quot;A singular Jacobian encountered when solving the collocation system.&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    3: <span class="stringliteral">&quot;The solver was unable to satisfy boundary conditions tolerance on iteration 10.&quot;</span></div>
<div class="line"><span class="lineno">    6</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
