<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.optimize._shgo Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize.html">optimize</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1__shgo.html">_shgo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.optimize._shgo Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__shgo_1_1_l_map.html">LMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__shgo_1_1_l_map_cache.html">LMapCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__shgo_1_1_s_h_g_o.html">SHGO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8b2c1799a8946986541d3321a5b643b" id="r_aa8b2c1799a8946986541d3321a5b643b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__shgo.html#aa8b2c1799a8946986541d3321a5b643b">shgo</a> (<a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, bounds, args=(), constraints=None, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, iters=1, callback=None, minimizer_kwargs=None, options=None, sampling_method='simplicial')</td></tr>
<tr class="separator:aa8b2c1799a8946986541d3321a5b643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">shgo: The simplicial homology global optimisation algorithm
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aa8b2c1799a8946986541d3321a5b643b" name="aa8b2c1799a8946986541d3321a5b643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b2c1799a8946986541d3321a5b643b">&#9670;&#160;</a></span>shgo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._shgo.shgo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>constraints</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iters</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minimizer_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sampling_method</em> = <code>'simplicial'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds the global minimum of a function using SHG optimization.

SHGO stands for "simplicial homology global optimization".

Parameters
----------
func : callable
    The objective function to be minimized.  Must be in the form
    ``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array
    and ``args`` is a tuple of any additional fixed parameters needed to
    completely specify the function.
bounds : sequence or `Bounds`
    Bounds for variables. There are two ways to specify the bounds:

    1. Instance of `Bounds` class.
    2. Sequence of ``(min, max)`` pairs for each element in `x`.

args : tuple, optional
    Any additional fixed parameters needed to completely specify the
    objective function.
constraints : dict or sequence of dict, optional
    Constraints definition.
    Function(s) ``R**n`` in the form::

        g(x) &gt;= 0 applied as g : R^n -&gt; R^m
        h(x) == 0 applied as h : R^n -&gt; R^p

    Each constraint is defined in a dictionary with fields:

        type : str
            Constraint type: 'eq' for equality, 'ineq' for inequality.
        fun : callable
            The function defining the constraint.
        jac : callable, optional
            The Jacobian of `fun` (only for SLSQP).
        args : sequence, optional
            Extra arguments to be passed to the function and Jacobian.

    Equality constraint means that the constraint function result is to
    be zero whereas inequality means that it is to be non-negative.
    Note that COBYLA only supports inequality constraints.

    .. note::

       Only the COBYLA and SLSQP local minimize methods currently
       support constraint arguments. If the ``constraints`` sequence
       used in the local optimization problem is not defined in
       ``minimizer_kwargs`` and a constrained method is used then the
       global ``constraints`` will be used.
       (Defining a ``constraints`` sequence in ``minimizer_kwargs``
       means that ``constraints`` will not be added so if equality
       constraints and so forth need to be added then the inequality
       functions in ``constraints`` need to be added to
       ``minimizer_kwargs`` too).

n : int, optional
    Number of sampling points used in the construction of the simplicial
    complex. Note that this argument is only used for ``sobol`` and other
    arbitrary `sampling_methods`. In case of ``sobol``, it must be a
    power of 2: ``n=2**m``, and the argument will automatically be
    converted to the next higher power of 2. Default is 100 for
    ``sampling_method='simplicial'`` and 128 for
    ``sampling_method='sobol'``.
iters : int, optional
    Number of iterations used in the construction of the simplicial
    complex. Default is 1.
callback : callable, optional
    Called after each iteration, as ``callback(xk)``, where ``xk`` is the
    current parameter vector.
minimizer_kwargs : dict, optional
    Extra keyword arguments to be passed to the minimizer
    ``scipy.optimize.minimize`` Some important options could be:

        * method : str
            The minimization method, the default is ``SLSQP``.
        * args : tuple
            Extra arguments passed to the objective function (``func``) and
            its derivatives (Jacobian, Hessian).
        * options : dict, optional
            Note that by default the tolerance is specified as
            ``{ftol: 1e-12}``

options : dict, optional
    A dictionary of solver options. Many of the options specified for the
    global routine are also passed to the scipy.optimize.minimize routine.
    The options that are also passed to the local routine are marked with
    "(L)".

    Stopping criteria, the algorithm will terminate if any of the specified
    criteria are met. However, the default algorithm does not require any to
    be specified:

    * maxfev : int (L)
        Maximum number of function evaluations in the feasible domain.
        (Note only methods that support this option will terminate
        the routine at precisely exact specified value. Otherwise the
        criterion will only terminate during a global iteration)
    * f_min
        Specify the minimum objective function value, if it is known.
    * f_tol : float
        Precision goal for the value of f in the stopping
        criterion. Note that the global routine will also
        terminate if a sampling point in the global routine is
        within this tolerance.
    * maxiter : int
        Maximum number of iterations to perform.
    * maxev : int
        Maximum number of sampling evaluations to perform (includes
        searching in infeasible points).
    * maxtime : float
        Maximum processing runtime allowed
    * minhgrd : int
        Minimum homology group rank differential. The homology group of the
        objective function is calculated (approximately) during every
        iteration. The rank of this group has a one-to-one correspondence
        with the number of locally convex subdomains in the objective
        function (after adequate sampling points each of these subdomains
        contain a unique global minimum). If the difference in the hgr is 0
        between iterations for ``maxhgrd`` specified iterations the
        algorithm will terminate.

    Objective function knowledge:

    * symmetry : bool
        Specify True if the objective function contains symmetric variables.
        The search space (and therefore performance) is decreased by O(n!).

    * jac : bool or callable, optional
        Jacobian (gradient) of objective function. Only for CG, BFGS,
        Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg. If ``jac`` is a
        boolean and is True, ``fun`` is assumed to return the gradient along
        with the objective function. If False, the gradient will be
        estimated numerically. ``jac`` can also be a callable returning the
        gradient of the objective. In this case, it must accept the same
        arguments as ``fun``. (Passed to `scipy.optimize.minmize` automatically)

    * hess, hessp : callable, optional
        Hessian (matrix of second-order derivatives) of objective function
        or Hessian of objective function times an arbitrary vector p.
        Only for Newton-CG, dogleg, trust-ncg. Only one of ``hessp`` or
        ``hess`` needs to be given. If ``hess`` is provided, then
        ``hessp`` will be ignored. If neither ``hess`` nor ``hessp`` is
        provided, then the Hessian product will be approximated using
        finite differences on ``jac``. ``hessp`` must compute the Hessian
        times an arbitrary vector. (Passed to `scipy.optimize.minmize`
        automatically)

    Algorithm settings:

    * minimize_every_iter : bool
        If True then promising global sampling points will be passed to a
        local minimization routine every iteration. If False then only the
        final minimizer pool will be run. Defaults to False.
    * local_iter : int
        Only evaluate a few of the best minimizer pool candidates every
        iteration. If False all potential points are passed to the local
        minimization routine.
    * infty_constraints: bool
        If True then any sampling points generated which are outside will
        the feasible domain will be saved and given an objective function
        value of ``inf``. If False then these points will be discarded.
        Using this functionality could lead to higher performance with
        respect to function evaluations before the global minimum is found,
        specifying False will use less memory at the cost of a slight
        decrease in performance. Defaults to True.

    Feedback:

    * disp : bool (L)
        Set to True to print convergence messages.

sampling_method : str or function, optional
    Current built in sampling method options are ``halton``, ``sobol`` and
    ``simplicial``. The default ``simplicial`` provides
    the theoretical guarantee of convergence to the global minimum in finite
    time. ``halton`` and ``sobol`` method are faster in terms of sampling
    point generation at the cost of the loss of
    guaranteed convergence. It is more appropriate for most "easier"
    problems where the convergence is relatively fast.
    User defined sampling functions must accept two arguments of ``n``
    sampling points of dimension ``dim`` per call and output an array of
    sampling points with shape `n x dim`.

Returns
-------
res : OptimizeResult
    The optimization result represented as a `OptimizeResult` object.
    Important attributes are:
    ``x`` the solution array corresponding to the global minimum,
    ``fun`` the function output at the global solution,
    ``xl`` an ordered list of local minima solutions,
    ``funl`` the function output at the corresponding local solutions,
    ``success`` a Boolean flag indicating if the optimizer exited
    successfully,
    ``message`` which describes the cause of the termination,
    ``nfev`` the total number of objective function evaluations including
    the sampling calls,
    ``nlfev`` the total number of objective function evaluations
    culminating from all local search optimizations,
    ``nit`` number of iterations performed by the global routine.

Notes
-----
Global optimization using simplicial homology global optimization [1]_.
Appropriate for solving general purpose NLP and blackbox optimization
problems to global optimality (low-dimensional problems).

In general, the optimization problems are of the form::

    minimize f(x) subject to

    g_i(x) &gt;= 0,  i = 1,...,m
    h_j(x)  = 0,  j = 1,...,p

where x is a vector of one or more variables. ``f(x)`` is the objective
function ``R^n -&gt; R``, ``g_i(x)`` are the inequality constraints, and
``h_j(x)`` are the equality constraints.

Optionally, the lower and upper bounds for each element in x can also be
specified using the `bounds` argument.

While most of the theoretical advantages of SHGO are only proven for when
``f(x)`` is a Lipschitz smooth function, the algorithm is also proven to
converge to the global optimum for the more general case where ``f(x)`` is
non-continuous, non-convex and non-smooth, if the default sampling method
is used [1]_.

The local search method may be specified using the ``minimizer_kwargs``
parameter which is passed on to ``scipy.optimize.minimize``. By default,
the ``SLSQP`` method is used. In general, it is recommended to use the
``SLSQP`` or ``COBYLA`` local minimization if inequality constraints
are defined for the problem since the other methods do not use constraints.

The ``halton`` and ``sobol`` method points are generated using
`scipy.stats.qmc`. Any other QMC method could be used.

References
----------
.. [1] Endres, SC, Sandrock, C, Focke, WW (2018) "A simplicial homology
       algorithm for lipschitz optimisation", Journal of Global Optimization.
.. [2] Joe, SW and Kuo, FY (2008) "Constructing Sobol' sequences with
       better  two-dimensional projections", SIAM J. Sci. Comput. 30,
       2635-2654.
.. [3] Hoch, W and Schittkowski, K (1981) "Test examples for nonlinear
       programming codes", Lecture Notes in Economics and Mathematical
       Systems, 187. Springer-Verlag, New York.
       http://www.ai7.uni-bayreuth.de/test_problem_coll.pdf
.. [4] Wales, DJ (2015) "Perspective: Insight into reaction coordinates and
       dynamics from the potential energy landscape",
       Journal of Chemical Physics, 142(13), 2015.

Examples
--------
First consider the problem of minimizing the Rosenbrock function, `rosen`:

&gt;&gt;&gt; from scipy.optimize import rosen, shgo
&gt;&gt;&gt; bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]
&gt;&gt;&gt; result = shgo(rosen, bounds)
&gt;&gt;&gt; result.x, result.fun
(array([1., 1., 1., 1., 1.]), 2.920392374190081e-18)

Note that bounds determine the dimensionality of the objective
function and is therefore a required input, however you can specify
empty bounds using ``None`` or objects like ``np.inf`` which will be
converted to large float numbers.

&gt;&gt;&gt; bounds = [(None, None), ]*4
&gt;&gt;&gt; result = shgo(rosen, bounds)
&gt;&gt;&gt; result.x
array([0.99999851, 0.99999704, 0.99999411, 0.9999882 ])

Next, we consider the Eggholder function, a problem with several local
minima and one global minimum. We will demonstrate the use of arguments and
the capabilities of `shgo`.
(https://en.wikipedia.org/wiki/Test_functions_for_optimization)

&gt;&gt;&gt; def eggholder(x):
...     return (-(x[1] + 47.0)
...             * np.sin(np.sqrt(abs(x[0]/2.0 + (x[1] + 47.0))))
...             - x[0] * np.sin(np.sqrt(abs(x[0] - (x[1] + 47.0))))
...             )
...
&gt;&gt;&gt; bounds = [(-512, 512), (-512, 512)]

`shgo` has built-in low discrepancy sampling sequences. First, we will
input 64 initial sampling points of the *Sobol'* sequence:

&gt;&gt;&gt; result = shgo(eggholder, bounds, n=64, sampling_method='sobol')
&gt;&gt;&gt; result.x, result.fun
(array([512.        , 404.23180824]), -959.6406627208397)

`shgo` also has a return for any other local minima that was found, these
can be called using:

&gt;&gt;&gt; result.xl
array([[ 512.        ,  404.23180824],
       [ 283.0759062 , -487.12565635],
       [-294.66820039, -462.01964031],
       [-105.87688911,  423.15323845],
       [-242.97926   ,  274.38030925],
       [-506.25823477,    6.3131022 ],
       [-408.71980731, -156.10116949],
       [ 150.23207937,  301.31376595],
       [  91.00920901, -391.283763  ],
       [ 202.89662724, -269.38043241],
       [ 361.66623976, -106.96493868],
       [-219.40612786, -244.06020508]])

&gt;&gt;&gt; result.funl
array([-959.64066272, -718.16745962, -704.80659592, -565.99778097,
       -559.78685655, -557.36868733, -507.87385942, -493.9605115 ,
       -426.48799655, -421.15571437, -419.31194957, -410.98477763])

These results are useful in applications where there are many global minima
and the values of other global minima are desired or where the local minima
can provide insight into the system (for example morphologies
in physical chemistry [4]_).

If we want to find a larger number of local minima, we can increase the
number of sampling points or the number of iterations. We'll increase the
number of sampling points to 64 and the number of iterations from the
default of 1 to 3. Using ``simplicial`` this would have given us
64 x 3 = 192 initial sampling points.

&gt;&gt;&gt; result_2 = shgo(eggholder, bounds, n=64, iters=3, sampling_method='sobol')
&gt;&gt;&gt; len(result.xl), len(result_2.xl)
(12, 20)

Note the difference between, e.g., ``n=192, iters=1`` and ``n=64,
iters=3``.
In the first case the promising points contained in the minimiser pool
are processed only once. In the latter case it is processed every 64
sampling points for a total of 3 times.

To demonstrate solving problems with non-linear constraints consider the
following example from Hock and Schittkowski problem 73 (cattle-feed) [3]_::

    minimize: f = 24.55 * x_1 + 26.75 * x_2 + 39 * x_3 + 40.50 * x_4

    subject to: 2.3 * x_1 + 5.6 * x_2 + 11.1 * x_3 + 1.3 * x_4 - 5     &gt;= 0,

                12 * x_1 + 11.9 * x_2 + 41.8 * x_3 + 52.1 * x_4 - 21
                    -1.645 * sqrt(0.28 * x_1**2 + 0.19 * x_2**2 +
                                  20.5 * x_3**2 + 0.62 * x_4**2)       &gt;= 0,

                x_1 + x_2 + x_3 + x_4 - 1                              == 0,

                1 &gt;= x_i &gt;= 0 for all i

The approximate answer given in [3]_ is::

    f([0.6355216, -0.12e-11, 0.3127019, 0.05177655]) = 29.894378

&gt;&gt;&gt; def f(x):  # (cattle-feed)
...     return 24.55*x[0] + 26.75*x[1] + 39*x[2] + 40.50*x[3]
...
&gt;&gt;&gt; def g1(x):
...     return 2.3*x[0] + 5.6*x[1] + 11.1*x[2] + 1.3*x[3] - 5  # &gt;=0
...
&gt;&gt;&gt; def g2(x):
...     return (12*x[0] + 11.9*x[1] +41.8*x[2] + 52.1*x[3] - 21
...             - 1.645 * np.sqrt(0.28*x[0]**2 + 0.19*x[1]**2
...                             + 20.5*x[2]**2 + 0.62*x[3]**2)
...             ) # &gt;=0
...
&gt;&gt;&gt; def h1(x):
...     return x[0] + x[1] + x[2] + x[3] - 1  # == 0
...
&gt;&gt;&gt; cons = ({'type': 'ineq', 'fun': g1},
...         {'type': 'ineq', 'fun': g2},
...         {'type': 'eq', 'fun': h1})
&gt;&gt;&gt; bounds = [(0, 1.0),]*4
&gt;&gt;&gt; res = shgo(f, bounds, iters=3, constraints=cons)
&gt;&gt;&gt; res
     fun: 29.894378159142136
    funl: array([29.89437816])
 message: 'Optimization terminated successfully.'
    nfev: 114
     nit: 3
   nlfev: 35
   nlhev: 0
   nljev: 5
 success: True
       x: array([6.35521569e-01, 1.13700270e-13, 3.12701881e-01, 5.17765506e-02])
      xl: array([[6.35521569e-01, 1.13700270e-13, 3.12701881e-01, 5.17765506e-02]])

&gt;&gt;&gt; g1(res.x), g2(res.x), h1(res.x)
(-5.062616992290714e-14, -2.9594104944408173e-12, 0.0)</pre> <div class="fragment"><div class="line"><span class="lineno">   21</span>         minimizer_kwargs=<span class="keywordtype">None</span>, options=<span class="keywordtype">None</span>, sampling_method=<span class="stringliteral">&#39;simplicial&#39;</span>):</div>
<div class="line"><span class="lineno">   22</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    Finds the global minimum of a function using SHG optimization.</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">    SHGO stands for &quot;simplicial homology global optimization&quot;.</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">    func : callable</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">        The objective function to be minimized.  Must be in the form</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">        ``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">        and ``args`` is a tuple of any additional fixed parameters needed to</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">        completely specify the function.</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    bounds : sequence or `Bounds`</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">        Bounds for variables. There are two ways to specify the bounds:</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        1. Instance of `Bounds` class.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">        2. Sequence of ``(min, max)`` pairs for each element in `x`.</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">        Any additional fixed parameters needed to completely specify the</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        objective function.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    constraints : dict or sequence of dict, optional</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">        Constraints definition.</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        Function(s) ``R**n`` in the form::</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">            g(x) &gt;= 0 applied as g : R^n -&gt; R^m</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">            h(x) == 0 applied as h : R^n -&gt; R^p</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        Each constraint is defined in a dictionary with fields:</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">            type : str</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">                Constraint type: &#39;eq&#39; for equality, &#39;ineq&#39; for inequality.</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">            fun : callable</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">                The function defining the constraint.</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">            jac : callable, optional</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">                The Jacobian of `fun` (only for SLSQP).</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">            args : sequence, optional</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">                Extra arguments to be passed to the function and Jacobian.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        Equality constraint means that the constraint function result is to</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">        be zero whereas inequality means that it is to be non-negative.</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">        Note that COBYLA only supports inequality constraints.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        .. note::</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">           Only the COBYLA and SLSQP local minimize methods currently</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">           support constraint arguments. If the ``constraints`` sequence</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">           used in the local optimization problem is not defined in</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">           ``minimizer_kwargs`` and a constrained method is used then the</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">           global ``constraints`` will be used.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">           (Defining a ``constraints`` sequence in ``minimizer_kwargs``</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">           means that ``constraints`` will not be added so if equality</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">           constraints and so forth need to be added then the inequality</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">           functions in ``constraints`` need to be added to</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">           ``minimizer_kwargs`` too).</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        Number of sampling points used in the construction of the simplicial</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">        complex. Note that this argument is only used for ``sobol`` and other</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">        arbitrary `sampling_methods`. In case of ``sobol``, it must be a</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        power of 2: ``n=2**m``, and the argument will automatically be</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">        converted to the next higher power of 2. Default is 100 for</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        ``sampling_method=&#39;simplicial&#39;`` and 128 for</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        ``sampling_method=&#39;sobol&#39;``.</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    iters : int, optional</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        Number of iterations used in the construction of the simplicial</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        complex. Default is 1.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    callback : callable, optional</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        Called after each iteration, as ``callback(xk)``, where ``xk`` is the</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        current parameter vector.</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    minimizer_kwargs : dict, optional</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        Extra keyword arguments to be passed to the minimizer</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        ``scipy.optimize.minimize`` Some important options could be:</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">            * method : str</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">                The minimization method, the default is ``SLSQP``.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">            * args : tuple</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">                Extra arguments passed to the objective function (``func``) and</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">                its derivatives (Jacobian, Hessian).</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">            * options : dict, optional</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">                Note that by default the tolerance is specified as</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">                ``{ftol: 1e-12}``</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    options : dict, optional</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        A dictionary of solver options. Many of the options specified for the</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        global routine are also passed to the scipy.optimize.minimize routine.</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        The options that are also passed to the local routine are marked with</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">        &quot;(L)&quot;.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        Stopping criteria, the algorithm will terminate if any of the specified</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">        criteria are met. However, the default algorithm does not require any to</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">        be specified:</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">        * maxfev : int (L)</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">            Maximum number of function evaluations in the feasible domain.</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">            (Note only methods that support this option will terminate</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">            the routine at precisely exact specified value. Otherwise the</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">            criterion will only terminate during a global iteration)</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        * f_min</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">            Specify the minimum objective function value, if it is known.</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">        * f_tol : float</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">            Precision goal for the value of f in the stopping</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">            criterion. Note that the global routine will also</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">            terminate if a sampling point in the global routine is</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">            within this tolerance.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">        * maxiter : int</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">            Maximum number of iterations to perform.</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">        * maxev : int</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">            Maximum number of sampling evaluations to perform (includes</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">            searching in infeasible points).</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">        * maxtime : float</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">            Maximum processing runtime allowed</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">        * minhgrd : int</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">            Minimum homology group rank differential. The homology group of the</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">            objective function is calculated (approximately) during every</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">            iteration. The rank of this group has a one-to-one correspondence</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">            with the number of locally convex subdomains in the objective</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">            function (after adequate sampling points each of these subdomains</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">            contain a unique global minimum). If the difference in the hgr is 0</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">            between iterations for ``maxhgrd`` specified iterations the</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">            algorithm will terminate.</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        Objective function knowledge:</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">        * symmetry : bool</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">            Specify True if the objective function contains symmetric variables.</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">            The search space (and therefore performance) is decreased by O(n!).</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">        * jac : bool or callable, optional</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">            Jacobian (gradient) of objective function. Only for CG, BFGS,</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">            Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg. If ``jac`` is a</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">            boolean and is True, ``fun`` is assumed to return the gradient along</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">            with the objective function. If False, the gradient will be</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">            estimated numerically. ``jac`` can also be a callable returning the</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">            gradient of the objective. In this case, it must accept the same</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">            arguments as ``fun``. (Passed to `scipy.optimize.minmize` automatically)</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">        * hess, hessp : callable, optional</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">            Hessian (matrix of second-order derivatives) of objective function</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">            or Hessian of objective function times an arbitrary vector p.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">            Only for Newton-CG, dogleg, trust-ncg. Only one of ``hessp`` or</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">            ``hess`` needs to be given. If ``hess`` is provided, then</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">            ``hessp`` will be ignored. If neither ``hess`` nor ``hessp`` is</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">            provided, then the Hessian product will be approximated using</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">            finite differences on ``jac``. ``hessp`` must compute the Hessian</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">            times an arbitrary vector. (Passed to `scipy.optimize.minmize`</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">            automatically)</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        Algorithm settings:</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        * minimize_every_iter : bool</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">            If True then promising global sampling points will be passed to a</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">            local minimization routine every iteration. If False then only the</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">            final minimizer pool will be run. Defaults to False.</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">        * local_iter : int</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">            Only evaluate a few of the best minimizer pool candidates every</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">            iteration. If False all potential points are passed to the local</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">            minimization routine.</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        * infty_constraints: bool</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">            If True then any sampling points generated which are outside will</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">            the feasible domain will be saved and given an objective function</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">            value of ``inf``. If False then these points will be discarded.</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">            Using this functionality could lead to higher performance with</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">            respect to function evaluations before the global minimum is found,</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">            specifying False will use less memory at the cost of a slight</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">            decrease in performance. Defaults to True.</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">        Feedback:</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">        * disp : bool (L)</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">            Set to True to print convergence messages.</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    sampling_method : str or function, optional</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        Current built in sampling method options are ``halton``, ``sobol`` and</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">        ``simplicial``. The default ``simplicial`` provides</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        the theoretical guarantee of convergence to the global minimum in finite</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">        time. ``halton`` and ``sobol`` method are faster in terms of sampling</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">        point generation at the cost of the loss of</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        guaranteed convergence. It is more appropriate for most &quot;easier&quot;</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        problems where the convergence is relatively fast.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        User defined sampling functions must accept two arguments of ``n``</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        sampling points of dimension ``dim`` per call and output an array of</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        sampling points with shape `n x dim`.</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    res : OptimizeResult</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        The optimization result represented as a `OptimizeResult` object.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        Important attributes are:</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        ``x`` the solution array corresponding to the global minimum,</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        ``fun`` the function output at the global solution,</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        ``xl`` an ordered list of local minima solutions,</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        ``funl`` the function output at the corresponding local solutions,</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">        ``success`` a Boolean flag indicating if the optimizer exited</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        successfully,</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        ``message`` which describes the cause of the termination,</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        ``nfev`` the total number of objective function evaluations including</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        the sampling calls,</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        ``nlfev`` the total number of objective function evaluations</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">        culminating from all local search optimizations,</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        ``nit`` number of iterations performed by the global routine.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Global optimization using simplicial homology global optimization [1]_.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    Appropriate for solving general purpose NLP and blackbox optimization</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    problems to global optimality (low-dimensional problems).</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    In general, the optimization problems are of the form::</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        minimize f(x) subject to</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        g_i(x) &gt;= 0,  i = 1,...,m</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">        h_j(x)  = 0,  j = 1,...,p</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    where x is a vector of one or more variables. ``f(x)`` is the objective</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    function ``R^n -&gt; R``, ``g_i(x)`` are the inequality constraints, and</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    ``h_j(x)`` are the equality constraints.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    Optionally, the lower and upper bounds for each element in x can also be</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    specified using the `bounds` argument.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    While most of the theoretical advantages of SHGO are only proven for when</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    ``f(x)`` is a Lipschitz smooth function, the algorithm is also proven to</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    converge to the global optimum for the more general case where ``f(x)`` is</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    non-continuous, non-convex and non-smooth, if the default sampling method</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    is used [1]_.</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    The local search method may be specified using the ``minimizer_kwargs``</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    parameter which is passed on to ``scipy.optimize.minimize``. By default,</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    the ``SLSQP`` method is used. In general, it is recommended to use the</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    ``SLSQP`` or ``COBYLA`` local minimization if inequality constraints</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    are defined for the problem since the other methods do not use constraints.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    The ``halton`` and ``sobol`` method points are generated using</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    `scipy.stats.qmc`. Any other QMC method could be used.</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    .. [1] Endres, SC, Sandrock, C, Focke, WW (2018) &quot;A simplicial homology</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">           algorithm for lipschitz optimisation&quot;, Journal of Global Optimization.</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    .. [2] Joe, SW and Kuo, FY (2008) &quot;Constructing Sobol&#39; sequences with</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">           better  two-dimensional projections&quot;, SIAM J. Sci. Comput. 30,</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">           2635-2654.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    .. [3] Hoch, W and Schittkowski, K (1981) &quot;Test examples for nonlinear</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">           programming codes&quot;, Lecture Notes in Economics and Mathematical</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">           Systems, 187. Springer-Verlag, New York.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">           http://www.ai7.uni-bayreuth.de/test_problem_coll.pdf</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    .. [4] Wales, DJ (2015) &quot;Perspective: Insight into reaction coordinates and</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">           dynamics from the potential energy landscape&quot;,</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">           Journal of Chemical Physics, 142(13), 2015.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    First consider the problem of minimizing the Rosenbrock function, `rosen`:</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.optimize import rosen, shgo</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    &gt;&gt;&gt; bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    &gt;&gt;&gt; result = shgo(rosen, bounds)</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    &gt;&gt;&gt; result.x, result.fun</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    (array([1., 1., 1., 1., 1.]), 2.920392374190081e-18)</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    Note that bounds determine the dimensionality of the objective</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    function and is therefore a required input, however you can specify</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    empty bounds using ``None`` or objects like ``np.inf`` which will be</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    converted to large float numbers.</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &gt;&gt;&gt; bounds = [(None, None), ]*4</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    &gt;&gt;&gt; result = shgo(rosen, bounds)</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    &gt;&gt;&gt; result.x</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    array([0.99999851, 0.99999704, 0.99999411, 0.9999882 ])</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    Next, we consider the Eggholder function, a problem with several local</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    minima and one global minimum. We will demonstrate the use of arguments and</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    the capabilities of `shgo`.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    (https://en.wikipedia.org/wiki/Test_functions_for_optimization)</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    &gt;&gt;&gt; def eggholder(x):</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    ...     return (-(x[1] + 47.0)</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    ...             * np.sin(np.sqrt(abs(x[0]/2.0 + (x[1] + 47.0))))</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    ...             - x[0] * np.sin(np.sqrt(abs(x[0] - (x[1] + 47.0))))</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    ...             )</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    &gt;&gt;&gt; bounds = [(-512, 512), (-512, 512)]</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    `shgo` has built-in low discrepancy sampling sequences. First, we will</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    input 64 initial sampling points of the *Sobol&#39;* sequence:</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    &gt;&gt;&gt; result = shgo(eggholder, bounds, n=64, sampling_method=&#39;sobol&#39;)</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    &gt;&gt;&gt; result.x, result.fun</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    (array([512.        , 404.23180824]), -959.6406627208397)</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    `shgo` also has a return for any other local minima that was found, these</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    can be called using:</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    &gt;&gt;&gt; result.xl</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    array([[ 512.        ,  404.23180824],</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">           [ 283.0759062 , -487.12565635],</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">           [-294.66820039, -462.01964031],</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">           [-105.87688911,  423.15323845],</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">           [-242.97926   ,  274.38030925],</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">           [-506.25823477,    6.3131022 ],</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">           [-408.71980731, -156.10116949],</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">           [ 150.23207937,  301.31376595],</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">           [  91.00920901, -391.283763  ],</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">           [ 202.89662724, -269.38043241],</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">           [ 361.66623976, -106.96493868],</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">           [-219.40612786, -244.06020508]])</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    &gt;&gt;&gt; result.funl</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    array([-959.64066272, -718.16745962, -704.80659592, -565.99778097,</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">           -559.78685655, -557.36868733, -507.87385942, -493.9605115 ,</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">           -426.48799655, -421.15571437, -419.31194957, -410.98477763])</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    These results are useful in applications where there are many global minima</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    and the values of other global minima are desired or where the local minima</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    can provide insight into the system (for example morphologies</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    in physical chemistry [4]_).</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    If we want to find a larger number of local minima, we can increase the</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    number of sampling points or the number of iterations. We&#39;ll increase the</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    number of sampling points to 64 and the number of iterations from the</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    default of 1 to 3. Using ``simplicial`` this would have given us</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    64 x 3 = 192 initial sampling points.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    &gt;&gt;&gt; result_2 = shgo(eggholder, bounds, n=64, iters=3, sampling_method=&#39;sobol&#39;)</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    &gt;&gt;&gt; len(result.xl), len(result_2.xl)</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    (12, 20)</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    Note the difference between, e.g., ``n=192, iters=1`` and ``n=64,</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    iters=3``.</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    In the first case the promising points contained in the minimiser pool</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    are processed only once. In the latter case it is processed every 64</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    sampling points for a total of 3 times.</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    To demonstrate solving problems with non-linear constraints consider the</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    following example from Hock and Schittkowski problem 73 (cattle-feed) [3]_::</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        minimize: f = 24.55 * x_1 + 26.75 * x_2 + 39 * x_3 + 40.50 * x_4</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">        subject to: 2.3 * x_1 + 5.6 * x_2 + 11.1 * x_3 + 1.3 * x_4 - 5     &gt;= 0,</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">                    12 * x_1 + 11.9 * x_2 + 41.8 * x_3 + 52.1 * x_4 - 21</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">                        -1.645 * sqrt(0.28 * x_1**2 + 0.19 * x_2**2 +</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">                                      20.5 * x_3**2 + 0.62 * x_4**2)       &gt;= 0,</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">                    x_1 + x_2 + x_3 + x_4 - 1                              == 0,</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">                    1 &gt;= x_i &gt;= 0 for all i</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    The approximate answer given in [3]_ is::</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        f([0.6355216, -0.12e-11, 0.3127019, 0.05177655]) = 29.894378</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    &gt;&gt;&gt; def f(x):  # (cattle-feed)</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    ...     return 24.55*x[0] + 26.75*x[1] + 39*x[2] + 40.50*x[3]</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    &gt;&gt;&gt; def g1(x):</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    ...     return 2.3*x[0] + 5.6*x[1] + 11.1*x[2] + 1.3*x[3] - 5  # &gt;=0</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    &gt;&gt;&gt; def g2(x):</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    ...     return (12*x[0] + 11.9*x[1] +41.8*x[2] + 52.1*x[3] - 21</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    ...             - 1.645 * np.sqrt(0.28*x[0]**2 + 0.19*x[1]**2</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    ...                             + 20.5*x[2]**2 + 0.62*x[3]**2)</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    ...             ) # &gt;=0</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    &gt;&gt;&gt; def h1(x):</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    ...     return x[0] + x[1] + x[2] + x[3] - 1  # == 0</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    &gt;&gt;&gt; cons = ({&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: g1},</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    ...         {&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: g2},</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    ...         {&#39;type&#39;: &#39;eq&#39;, &#39;fun&#39;: h1})</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    &gt;&gt;&gt; bounds = [(0, 1.0),]*4</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    &gt;&gt;&gt; res = shgo(f, bounds, iters=3, constraints=cons)</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    &gt;&gt;&gt; res</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">         fun: 29.894378159142136</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        funl: array([29.89437816])</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">     message: &#39;Optimization terminated successfully.&#39;</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        nfev: 114</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">         nit: 3</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">       nlfev: 35</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">       nlhev: 0</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">       nljev: 5</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">     success: True</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">           x: array([6.35521569e-01, 1.13700270e-13, 3.12701881e-01, 5.17765506e-02])</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">          xl: array([[6.35521569e-01, 1.13700270e-13, 3.12701881e-01, 5.17765506e-02]])</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">    &gt;&gt;&gt; g1(res.x), g2(res.x), h1(res.x)</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    (-5.062616992290714e-14, -2.9594104944408173e-12, 0.0)</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>    <span class="comment"># if necessary, convert bounds class to old bounds</span></div>
<div class="line"><span class="lineno">  415</span>    <span class="keywordflow">if</span> isinstance(bounds, Bounds):</div>
<div class="line"><span class="lineno">  416</span>        bounds = new_bounds_to_old(bounds.lb, bounds.ub, len(bounds.lb))</div>
<div class="line"><span class="lineno">  417</span> </div>
<div class="line"><span class="lineno">  418</span>    <span class="comment"># Initiate SHGO class</span></div>
<div class="line"><span class="lineno">  419</span>    shc = SHGO(func, bounds, args=args, constraints=constraints, n=n,</div>
<div class="line"><span class="lineno">  420</span>               iters=iters, callback=callback,</div>
<div class="line"><span class="lineno">  421</span>               minimizer_kwargs=minimizer_kwargs,</div>
<div class="line"><span class="lineno">  422</span>               options=options, sampling_method=sampling_method)</div>
<div class="line"><span class="lineno">  423</span> </div>
<div class="line"><span class="lineno">  424</span>    <span class="comment"># Run the algorithm, process results and test success</span></div>
<div class="line"><span class="lineno">  425</span>    shc.construct_complex()</div>
<div class="line"><span class="lineno">  426</span> </div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> shc.break_routine:</div>
<div class="line"><span class="lineno">  428</span>        <span class="keywordflow">if</span> shc.disp:</div>
<div class="line"><span class="lineno">  429</span>            print(<span class="stringliteral">&quot;Successfully completed construction of complex.&quot;</span>)</div>
<div class="line"><span class="lineno">  430</span> </div>
<div class="line"><span class="lineno">  431</span>    <span class="comment"># Test post iterations success</span></div>
<div class="line"><span class="lineno">  432</span>    <span class="keywordflow">if</span> len(shc.LMC.xl_maps) == 0:</div>
<div class="line"><span class="lineno">  433</span>        <span class="comment"># If sampling failed to find pool, return lowest sampled point</span></div>
<div class="line"><span class="lineno">  434</span>        <span class="comment"># with a warning</span></div>
<div class="line"><span class="lineno">  435</span>        shc.find_lowest_vertex()</div>
<div class="line"><span class="lineno">  436</span>        shc.break_routine = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  437</span>        shc.fail_routine(mes=<span class="stringliteral">&quot;Failed to find a feasible minimizer point. &quot;</span></div>
<div class="line"><span class="lineno">  438</span>                             <span class="stringliteral">&quot;Lowest sampling point = {}&quot;</span>.format(shc.f_lowest))</div>
<div class="line"><span class="lineno">  439</span>        shc.res.fun = shc.f_lowest</div>
<div class="line"><span class="lineno">  440</span>        shc.res.x = shc.x_lowest</div>
<div class="line"><span class="lineno">  441</span>        shc.res.nfev = shc.fn</div>
<div class="line"><span class="lineno">  442</span> </div>
<div class="line"><span class="lineno">  443</span>    <span class="comment"># Confirm the routine ran successfully</span></div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> shc.break_routine:</div>
<div class="line"><span class="lineno">  445</span>        shc.res.message = <span class="stringliteral">&#39;Optimization terminated successfully.&#39;</span></div>
<div class="line"><span class="lineno">  446</span>        shc.res.success = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span>    <span class="comment"># Return the final results</span></div>
<div class="line"><span class="lineno">  449</span>    <span class="keywordflow">return</span> shc.res</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
