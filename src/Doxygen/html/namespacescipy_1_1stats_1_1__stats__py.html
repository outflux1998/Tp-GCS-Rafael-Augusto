<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.stats._stats_py Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats.html">stats</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html">_stats_py</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.stats._stats_py Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1stats_1_1__stats__py_1_1___parallel_p.html">_ParallelP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1stats_1_1__stats__py_1_1_pearson_r_result.html">PearsonRResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58e2338e05cdf4c8ce6c4a992fa0e557" id="r_a58e2338e05cdf4c8ce6c4a992fa0e557"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a58e2338e05cdf4c8ce6c4a992fa0e557">_contains_nan</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, nan_policy='propagate', use_summation=True)</td></tr>
<tr class="separator:a58e2338e05cdf4c8ce6c4a992fa0e557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8f1f67d10a05713172b6a32169ed91" id="r_aaa8f1f67d10a05713172b6a32169ed91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aaa8f1f67d10a05713172b6a32169ed91">_chk_asarray</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis)</td></tr>
<tr class="separator:aaa8f1f67d10a05713172b6a32169ed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b513e10adf4355933dc921bac165b7" id="r_aa7b513e10adf4355933dc921bac165b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aa7b513e10adf4355933dc921bac165b7">_chk2_asarray</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, axis)</td></tr>
<tr class="separator:aa7b513e10adf4355933dc921bac165b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686b42aa2995c61b6fbe6c6af38fc527" id="r_a686b42aa2995c61b6fbe6c6af38fc527"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a686b42aa2995c61b6fbe6c6af38fc527">_shape_with_dropped_axis</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis)</td></tr>
<tr class="separator:a686b42aa2995c61b6fbe6c6af38fc527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75919663212e70e8b42c261ff94f7f0" id="r_ae75919663212e70e8b42c261ff94f7f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ae75919663212e70e8b42c261ff94f7f0">_broadcast_shapes</a> (shape1, shape2)</td></tr>
<tr class="separator:ae75919663212e70e8b42c261ff94f7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab708b4ea9dd64696b388692dd3609d00" id="r_ab708b4ea9dd64696b388692dd3609d00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ab708b4ea9dd64696b388692dd3609d00">_broadcast_shapes_with_dropped_axis</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, axis)</td></tr>
<tr class="separator:ab708b4ea9dd64696b388692dd3609d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5f31167da564053a0666386c4e28b3" id="r_aeb5f31167da564053a0666386c4e28b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aeb5f31167da564053a0666386c4e28b3">gmean</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, dtype=None, weights=None)</td></tr>
<tr class="separator:aeb5f31167da564053a0666386c4e28b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88bd950fd9bccf915ce996246d4d040" id="r_af88bd950fd9bccf915ce996246d4d040"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#af88bd950fd9bccf915ce996246d4d040">hmean</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, dtype=None, *weights=None)</td></tr>
<tr class="separator:af88bd950fd9bccf915ce996246d4d040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7452f929f20900003c3bb82a929a08fe" id="r_a7452f929f20900003c3bb82a929a08fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7452f929f20900003c3bb82a929a08fe">pmean</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, p, *axis=0, dtype=None, weights=None)</td></tr>
<tr class="separator:a7452f929f20900003c3bb82a929a08fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7666823299f40b492d638a114d2fc91" id="r_ad7666823299f40b492d638a114d2fc91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad7666823299f40b492d638a114d2fc91">mode</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, nan_policy='propagate', keepdims=None)</td></tr>
<tr class="separator:ad7666823299f40b492d638a114d2fc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd16dbbb70282cb051e7b9556d4737f" id="r_aacd16dbbb70282cb051e7b9556d4737f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aacd16dbbb70282cb051e7b9556d4737f">_mask_to_limits</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, limits, inclusive)</td></tr>
<tr class="separator:aacd16dbbb70282cb051e7b9556d4737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429c8fac38c7f007f95416b907858513" id="r_a429c8fac38c7f007f95416b907858513"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a429c8fac38c7f007f95416b907858513">tmean</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, limits=None, inclusive=(True, True), axis=None)</td></tr>
<tr class="separator:a429c8fac38c7f007f95416b907858513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ec33f46d65449e3c4e90f85e6f3928" id="r_a26ec33f46d65449e3c4e90f85e6f3928"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a26ec33f46d65449e3c4e90f85e6f3928">tvar</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, limits=None, inclusive=(True, True), axis=0, ddof=1)</td></tr>
<tr class="separator:a26ec33f46d65449e3c4e90f85e6f3928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fced7efb0eda0d00485572e5cd317d" id="r_ad5fced7efb0eda0d00485572e5cd317d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad5fced7efb0eda0d00485572e5cd317d">tmin</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, lowerlimit=None, axis=0, inclusive=True, nan_policy='propagate')</td></tr>
<tr class="separator:ad5fced7efb0eda0d00485572e5cd317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2094871a926390297df45c2c23902e" id="r_a3a2094871a926390297df45c2c23902e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a3a2094871a926390297df45c2c23902e">tmax</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, upperlimit=None, axis=0, inclusive=True, nan_policy='propagate')</td></tr>
<tr class="separator:a3a2094871a926390297df45c2c23902e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556a06abd7478c8d2c7500b2992c51c3" id="r_a556a06abd7478c8d2c7500b2992c51c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a556a06abd7478c8d2c7500b2992c51c3">tstd</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, limits=None, inclusive=(True, True), axis=0, ddof=1)</td></tr>
<tr class="separator:a556a06abd7478c8d2c7500b2992c51c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31c6b6ef9f91a6dfc8e174a87c0e190" id="r_ad31c6b6ef9f91a6dfc8e174a87c0e190"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad31c6b6ef9f91a6dfc8e174a87c0e190">tsem</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, limits=None, inclusive=(True, True), axis=0, ddof=1)</td></tr>
<tr class="separator:ad31c6b6ef9f91a6dfc8e174a87c0e190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e755c164ac589dc31d320fecbe127e2" id="r_a9e755c164ac589dc31d320fecbe127e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a9e755c164ac589dc31d320fecbe127e2">_moment_outputs</a> (kwds)</td></tr>
<tr class="memdesc:a9e755c164ac589dc31d320fecbe127e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">MOMENTS #.  <br /></td></tr>
<tr class="separator:a9e755c164ac589dc31d320fecbe127e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ef2a077e3c712981b1a282bf3ee032" id="r_a41ef2a077e3c712981b1a282bf3ee032"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a41ef2a077e3c712981b1a282bf3ee032">_moment_result_object</a> (*args)</td></tr>
<tr class="separator:a41ef2a077e3c712981b1a282bf3ee032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa153789d51dd95cfb2c8833fcfd60f" id="r_aaaa153789d51dd95cfb2c8833fcfd60f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aaaa153789d51dd95cfb2c8833fcfd60f">moment</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, moment=1, axis=0, nan_policy='propagate')</td></tr>
<tr class="separator:aaaa153789d51dd95cfb2c8833fcfd60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db5b73a9a9ff1f4d6843b2d6687e4e7" id="r_a4db5b73a9a9ff1f4d6843b2d6687e4e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a4db5b73a9a9ff1f4d6843b2d6687e4e7">_moment</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aaaa153789d51dd95cfb2c8833fcfd60f">moment</a>, axis, *mean=None)</td></tr>
<tr class="separator:a4db5b73a9a9ff1f4d6843b2d6687e4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8cb83384c519dcefbf564456fe81dd" id="r_a9f8cb83384c519dcefbf564456fe81dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a9f8cb83384c519dcefbf564456fe81dd">_var</a> (x, axis=0, ddof=0, mean=None)</td></tr>
<tr class="separator:a9f8cb83384c519dcefbf564456fe81dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e56bc1f28e285175aa52cd9a8dccec" id="r_a57e56bc1f28e285175aa52cd9a8dccec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a57e56bc1f28e285175aa52cd9a8dccec">skew</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, bias=True, nan_policy='propagate')</td></tr>
<tr class="separator:a57e56bc1f28e285175aa52cd9a8dccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd18adf3aba669d3c24c5d052097f73" id="r_a9fd18adf3aba669d3c24c5d052097f73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a9fd18adf3aba669d3c24c5d052097f73">kurtosis</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, fisher=True, bias=True, nan_policy='propagate')</td></tr>
<tr class="separator:a9fd18adf3aba669d3c24c5d052097f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9074c49e4ce1d99373dae0a3c48c9d5e" id="r_a9074c49e4ce1d99373dae0a3c48c9d5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a9074c49e4ce1d99373dae0a3c48c9d5e">describe</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, ddof=1, bias=True, nan_policy='propagate')</td></tr>
<tr class="separator:a9074c49e4ce1d99373dae0a3c48c9d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e20026493d260d023531ce41e26c269" id="r_a0e20026493d260d023531ce41e26c269"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a0e20026493d260d023531ce41e26c269">_normtest_finish</a> (<a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>, alternative)</td></tr>
<tr class="memdesc:a0e20026493d260d023531ce41e26c269"><td class="mdescLeft">&#160;</td><td class="mdescRight">NORMALITY TESTS #.  <br /></td></tr>
<tr class="separator:a0e20026493d260d023531ce41e26c269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba4fbe391d511f26a5715213741ce19" id="r_a7ba4fbe391d511f26a5715213741ce19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7ba4fbe391d511f26a5715213741ce19">skewtest</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, nan_policy='propagate', alternative='two-sided')</td></tr>
<tr class="separator:a7ba4fbe391d511f26a5715213741ce19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afd0b93401a2e4378a7f325e2b53cf0" id="r_a8afd0b93401a2e4378a7f325e2b53cf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a8afd0b93401a2e4378a7f325e2b53cf0">kurtosistest</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, nan_policy='propagate', alternative='two-sided')</td></tr>
<tr class="separator:a8afd0b93401a2e4378a7f325e2b53cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cd8218975e527a625046de8cf8004d" id="r_a04cd8218975e527a625046de8cf8004d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a04cd8218975e527a625046de8cf8004d">normaltest</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, nan_policy='propagate')</td></tr>
<tr class="separator:a04cd8218975e527a625046de8cf8004d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90174889d2756209212a6c5974bd3057" id="r_a90174889d2756209212a6c5974bd3057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a90174889d2756209212a6c5974bd3057">jarque_bera</a> (x)</td></tr>
<tr class="separator:a90174889d2756209212a6c5974bd3057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b35c4e412f628c2f7e90a36bdabf25" id="r_a50b35c4e412f628c2f7e90a36bdabf25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a50b35c4e412f628c2f7e90a36bdabf25">scoreatpercentile</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, per, limit=(), interpolation_method='fraction', axis=None)</td></tr>
<tr class="memdesc:a50b35c4e412f628c2f7e90a36bdabf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">FREQUENCY FUNCTIONS #.  <br /></td></tr>
<tr class="separator:a50b35c4e412f628c2f7e90a36bdabf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83387627658b0c178785dca865ecd929" id="r_a83387627658b0c178785dca865ecd929"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a83387627658b0c178785dca865ecd929">_compute_qth_percentile</a> (sorted_, per, interpolation_method, axis)</td></tr>
<tr class="separator:a83387627658b0c178785dca865ecd929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139493d2638b97ca3345692a7835fd4" id="r_af139493d2638b97ca3345692a7835fd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#af139493d2638b97ca3345692a7835fd4">percentileofscore</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, score, kind='rank', nan_policy='propagate')</td></tr>
<tr class="separator:af139493d2638b97ca3345692a7835fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82eb3635bf1ad54e142971200bf9710" id="r_ae82eb3635bf1ad54e142971200bf9710"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ae82eb3635bf1ad54e142971200bf9710">_histogram</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, numbins=10, defaultlimits=None, weights=None, printextras=False)</td></tr>
<tr class="separator:ae82eb3635bf1ad54e142971200bf9710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cc05458723f566fbbd8bf5c92ac145" id="r_ab7cc05458723f566fbbd8bf5c92ac145"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ab7cc05458723f566fbbd8bf5c92ac145">cumfreq</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, numbins=10, defaultreallimits=None, weights=None)</td></tr>
<tr class="separator:ab7cc05458723f566fbbd8bf5c92ac145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad241a1e1cd58da4789b3217d42536d0b" id="r_ad241a1e1cd58da4789b3217d42536d0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad241a1e1cd58da4789b3217d42536d0b">relfreq</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, numbins=10, defaultreallimits=None, weights=None)</td></tr>
<tr class="separator:ad241a1e1cd58da4789b3217d42536d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa080af52b52bdc1e1998e5f15eef174d" id="r_aa080af52b52bdc1e1998e5f15eef174d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aa080af52b52bdc1e1998e5f15eef174d">obrientransform</a> (*samples)</td></tr>
<tr class="memdesc:aa080af52b52bdc1e1998e5f15eef174d"><td class="mdescLeft">&#160;</td><td class="mdescRight">VARIABILITY FUNCTIONS #.  <br /></td></tr>
<tr class="separator:aa080af52b52bdc1e1998e5f15eef174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d7d58643573008b4ddc6dfad7447a" id="r_ac92d7d58643573008b4ddc6dfad7447a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ac92d7d58643573008b4ddc6dfad7447a">sem</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, ddof=1, nan_policy='propagate')</td></tr>
<tr class="separator:ac92d7d58643573008b4ddc6dfad7447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd539f56514ee1098218fdfb869cea0" id="r_a5bd539f56514ee1098218fdfb869cea0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a5bd539f56514ee1098218fdfb869cea0">_isconst</a> (x)</td></tr>
<tr class="separator:a5bd539f56514ee1098218fdfb869cea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b21f46bcd2e74e726ebab41f7c799c8" id="r_a4b21f46bcd2e74e726ebab41f7c799c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a4b21f46bcd2e74e726ebab41f7c799c8">_quiet_nanmean</a> (x)</td></tr>
<tr class="separator:a4b21f46bcd2e74e726ebab41f7c799c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51738f78d33d4973d9bb92624d6a5bef" id="r_a51738f78d33d4973d9bb92624d6a5bef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a51738f78d33d4973d9bb92624d6a5bef">_quiet_nanstd</a> (x, ddof=0)</td></tr>
<tr class="separator:a51738f78d33d4973d9bb92624d6a5bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40557c1c2fd14506e84aa782a7382f68" id="r_a40557c1c2fd14506e84aa782a7382f68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a40557c1c2fd14506e84aa782a7382f68">zscore</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, ddof=0, nan_policy='propagate')</td></tr>
<tr class="separator:a40557c1c2fd14506e84aa782a7382f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cebfa557b24c866da2a534b13b20d0" id="r_a45cebfa557b24c866da2a534b13b20d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a45cebfa557b24c866da2a534b13b20d0">gzscore</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, *axis=0, ddof=0, nan_policy='propagate')</td></tr>
<tr class="separator:a45cebfa557b24c866da2a534b13b20d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecb96afa85e562e14f2ff4f301a0ef9" id="r_abecb96afa85e562e14f2ff4f301a0ef9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#abecb96afa85e562e14f2ff4f301a0ef9">zmap</a> (scores, compare, axis=0, ddof=0, nan_policy='propagate')</td></tr>
<tr class="separator:abecb96afa85e562e14f2ff4f301a0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720304ac94e199a283c3cde4e66448f1" id="r_a720304ac94e199a283c3cde4e66448f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a720304ac94e199a283c3cde4e66448f1">gstd</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0, ddof=1)</td></tr>
<tr class="separator:a720304ac94e199a283c3cde4e66448f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ae1ff6d5c66e636d72a57ad7ea0472" id="r_ad8ae1ff6d5c66e636d72a57ad7ea0472"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad8ae1ff6d5c66e636d72a57ad7ea0472">iqr</a> (x, axis=None, rng=(25, 75), scale=1.0, nan_policy='propagate', interpolation='linear', keepdims=False)</td></tr>
<tr class="separator:ad8ae1ff6d5c66e636d72a57ad7ea0472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bcb107f34707282163dc34932921d5" id="r_a12bcb107f34707282163dc34932921d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a12bcb107f34707282163dc34932921d5">_mad_1d</a> (x, center, nan_policy)</td></tr>
<tr class="separator:a12bcb107f34707282163dc34932921d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965fb8fb12386cc993ba9ea132af562" id="r_a3965fb8fb12386cc993ba9ea132af562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a3965fb8fb12386cc993ba9ea132af562">median_abs_deviation</a> (x, axis=0, center=np.median, scale=1.0, nan_policy='propagate')</td></tr>
<tr class="separator:a3965fb8fb12386cc993ba9ea132af562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c059cb94ceb8ed4b4573bca8b8024f" id="r_a40c059cb94ceb8ed4b4573bca8b8024f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a40c059cb94ceb8ed4b4573bca8b8024f">sigmaclip</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, low=4., high=4.)</td></tr>
<tr class="separator:a40c059cb94ceb8ed4b4573bca8b8024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b232b8ef2a078a8bda0f808ca871b0" id="r_af1b232b8ef2a078a8bda0f808ca871b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#af1b232b8ef2a078a8bda0f808ca871b0">trimboth</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, proportiontocut, axis=0)</td></tr>
<tr class="separator:af1b232b8ef2a078a8bda0f808ca871b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133a4a1cf3127cc59ab529a6342e4e3b" id="r_a133a4a1cf3127cc59ab529a6342e4e3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a133a4a1cf3127cc59ab529a6342e4e3b">trim1</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, proportiontocut, tail='right', axis=0)</td></tr>
<tr class="separator:a133a4a1cf3127cc59ab529a6342e4e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692b1677d3e31fb991495d59a7378aff" id="r_a692b1677d3e31fb991495d59a7378aff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a692b1677d3e31fb991495d59a7378aff">trim_mean</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, proportiontocut, axis=0)</td></tr>
<tr class="separator:a692b1677d3e31fb991495d59a7378aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e276e13ea5d7dfc68a7ccb7a5dee6dd" id="r_a2e276e13ea5d7dfc68a7ccb7a5dee6dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a2e276e13ea5d7dfc68a7ccb7a5dee6dd">_create_f_oneway_nan_result</a> (shape, axis)</td></tr>
<tr class="separator:a2e276e13ea5d7dfc68a7ccb7a5dee6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6e79d444d643e8f8c69359dd2e7a76" id="r_ace6e79d444d643e8f8c69359dd2e7a76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ace6e79d444d643e8f8c69359dd2e7a76">_first</a> (arr, axis)</td></tr>
<tr class="separator:ace6e79d444d643e8f8c69359dd2e7a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771f3b2db7c5785f3c8395389ec7b76" id="r_a7771f3b2db7c5785f3c8395389ec7b76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7771f3b2db7c5785f3c8395389ec7b76">f_oneway</a> (*samples, axis=0)</td></tr>
<tr class="separator:a7771f3b2db7c5785f3c8395389ec7b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a76cb8c69e3c610d9e9c69fc54e9b9" id="r_a25a76cb8c69e3c610d9e9c69fc54e9b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a25a76cb8c69e3c610d9e9c69fc54e9b9">alexandergovern</a> (*samples, nan_policy='propagate')</td></tr>
<tr class="separator:a25a76cb8c69e3c610d9e9c69fc54e9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d9eb219fb20aaeb0a65cee954f5001" id="r_ab1d9eb219fb20aaeb0a65cee954f5001"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ab1d9eb219fb20aaeb0a65cee954f5001">_alexandergovern_input_validation</a> (samples, nan_policy)</td></tr>
<tr class="separator:ab1d9eb219fb20aaeb0a65cee954f5001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf4e4f934f9bc9561d37ca281b850f5" id="r_acaf4e4f934f9bc9561d37ca281b850f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#acaf4e4f934f9bc9561d37ca281b850f5">_pearsonr_fisher_ci</a> (<a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, confidence_level, alternative)</td></tr>
<tr class="separator:acaf4e4f934f9bc9561d37ca281b850f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a080f1bfe9c97c7a3f1e609349e4a6c" id="r_a7a080f1bfe9c97c7a3f1e609349e4a6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7a080f1bfe9c97c7a3f1e609349e4a6c">pearsonr</a> (x, y, *alternative='two-sided')</td></tr>
<tr class="separator:a7a080f1bfe9c97c7a3f1e609349e4a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec971e2362ba3d1144450412cfb4d674" id="r_aec971e2362ba3d1144450412cfb4d674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aec971e2362ba3d1144450412cfb4d674">fisher_exact</a> (table, alternative='two-sided')</td></tr>
<tr class="separator:aec971e2362ba3d1144450412cfb4d674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38625835ee2b2814b8dd9ce450b73bde" id="r_a38625835ee2b2814b8dd9ce450b73bde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a38625835ee2b2814b8dd9ce450b73bde">spearmanr</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b=None, axis=0, nan_policy='propagate', alternative='two-sided')</td></tr>
<tr class="separator:a38625835ee2b2814b8dd9ce450b73bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e6eba419d8ef505e1e48f9333d995b" id="r_a92e6eba419d8ef505e1e48f9333d995b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a92e6eba419d8ef505e1e48f9333d995b">pointbiserialr</a> (x, y)</td></tr>
<tr class="separator:a92e6eba419d8ef505e1e48f9333d995b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce454d71767fd548c3da8a056cbd35" id="r_a40ce454d71767fd548c3da8a056cbd35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a40ce454d71767fd548c3da8a056cbd35">kendalltau</a> (x, y, initial_lexsort=None, nan_policy='propagate', <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='auto', variant='b', alternative='two-sided')</td></tr>
<tr class="separator:a40ce454d71767fd548c3da8a056cbd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba4662b53e915f8ac0f275bb2199d4f" id="r_a6ba4662b53e915f8ac0f275bb2199d4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a6ba4662b53e915f8ac0f275bb2199d4f">weightedtau</a> (x, y, rank=True, weigher=None, additive=True)</td></tr>
<tr class="separator:a6ba4662b53e915f8ac0f275bb2199d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0076d6e995299f62317826f85fe2cd6" id="r_ad0076d6e995299f62317826f85fe2cd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad0076d6e995299f62317826f85fe2cd6">_perm_test</a> (x, y, stat, reps=1000, workers=-1, random_state=None)</td></tr>
<tr class="separator:ad0076d6e995299f62317826f85fe2cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06697b36a6f3c2567d9e514a9147d59" id="r_ac06697b36a6f3c2567d9e514a9147d59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ac06697b36a6f3c2567d9e514a9147d59">_euclidean_dist</a> (x)</td></tr>
<tr class="separator:ac06697b36a6f3c2567d9e514a9147d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e6d4b63720d080eab70d14f43d74cd" id="r_aa5e6d4b63720d080eab70d14f43d74cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aa5e6d4b63720d080eab70d14f43d74cd">multiscale_graphcorr</a> (x, y, compute_distance=<a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ac06697b36a6f3c2567d9e514a9147d59">_euclidean_dist</a>, reps=1000, workers=1, is_twosamp=False, random_state=None)</td></tr>
<tr class="separator:aa5e6d4b63720d080eab70d14f43d74cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0aaa0ec15fefa642eb07a77dcf117" id="r_a16b0aaa0ec15fefa642eb07a77dcf117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a16b0aaa0ec15fefa642eb07a77dcf117">_mgc_stat</a> (distx, disty)</td></tr>
<tr class="separator:a16b0aaa0ec15fefa642eb07a77dcf117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436f9fb4bc5898afd29daa2f083de1dc" id="r_a436f9fb4bc5898afd29daa2f083de1dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a436f9fb4bc5898afd29daa2f083de1dc">_threshold_mgc_map</a> (stat_mgc_map, samp_size)</td></tr>
<tr class="separator:a436f9fb4bc5898afd29daa2f083de1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d928324e2a00e17b80082984cb5fae2" id="r_a9d928324e2a00e17b80082984cb5fae2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a9d928324e2a00e17b80082984cb5fae2">_smooth_mgc_map</a> (sig_connect, stat_mgc_map)</td></tr>
<tr class="separator:a9d928324e2a00e17b80082984cb5fae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b84fb54a29fcfd00875f50715d876dd" id="r_a8b84fb54a29fcfd00875f50715d876dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a8b84fb54a29fcfd00875f50715d876dd">_two_sample_transform</a> (u, v)</td></tr>
<tr class="separator:a8b84fb54a29fcfd00875f50715d876dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b40cba4553c34430dc8745cc657d107" id="r_a0b40cba4553c34430dc8745cc657d107"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a0b40cba4553c34430dc8745cc657d107">ttest_1samp</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, popmean, axis=0, nan_policy='propagate', alternative=&quot;two-sided&quot;)</td></tr>
<tr class="separator:a0b40cba4553c34430dc8745cc657d107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068fc003ca0623460250659b9421b133" id="r_a068fc003ca0623460250659b9421b133"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a068fc003ca0623460250659b9421b133">_ttest_finish</a> (<a class="el" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>, <a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#ad9d2b06b505e69d16256a02b7c928a69">t</a>, alternative)</td></tr>
<tr class="separator:a068fc003ca0623460250659b9421b133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d068bbda5a330aa2eeb320506a10c1a" id="r_a6d068bbda5a330aa2eeb320506a10c1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a6d068bbda5a330aa2eeb320506a10c1a">_ttest_ind_from_stats</a> (mean1, mean2, denom, <a class="el" href="__lapack__subroutines_8h.html#a2a33a012da63c0be8f0f3845c10bf577">df</a>, alternative)</td></tr>
<tr class="separator:a6d068bbda5a330aa2eeb320506a10c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b5678e9a5ee4406cdfc24418527a7" id="r_a705b5678e9a5ee4406cdfc24418527a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a705b5678e9a5ee4406cdfc24418527a7">_unequal_var_ttest_denom</a> (v1, <a class="el" href="__lapack__subroutines_8h.html#ad13241860d5aa9d8027c8c1d395e5cd9">n1</a>, v2, <a class="el" href="__lapack__subroutines_8h.html#a406c3832a5225544c3afbaeff4271ad6">n2</a>)</td></tr>
<tr class="separator:a705b5678e9a5ee4406cdfc24418527a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19d5534576fc2aed9f2cf56fd9b8d65" id="r_aa19d5534576fc2aed9f2cf56fd9b8d65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aa19d5534576fc2aed9f2cf56fd9b8d65">_equal_var_ttest_denom</a> (v1, <a class="el" href="__lapack__subroutines_8h.html#ad13241860d5aa9d8027c8c1d395e5cd9">n1</a>, v2, <a class="el" href="__lapack__subroutines_8h.html#a406c3832a5225544c3afbaeff4271ad6">n2</a>)</td></tr>
<tr class="separator:aa19d5534576fc2aed9f2cf56fd9b8d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b98b9c4e131fb2b6d72da0ec90092f9" id="r_a3b98b9c4e131fb2b6d72da0ec90092f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a3b98b9c4e131fb2b6d72da0ec90092f9">ttest_ind_from_stats</a> (mean1, std1, nobs1, mean2, std2, nobs2, equal_var=True, alternative=&quot;two-sided&quot;)</td></tr>
<tr class="separator:a3b98b9c4e131fb2b6d72da0ec90092f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb23641bb4cbf927aa5d747341d32012" id="r_acb23641bb4cbf927aa5d747341d32012"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#acb23641bb4cbf927aa5d747341d32012">_ttest_nans</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, axis, namedtuple_type)</td></tr>
<tr class="separator:acb23641bb4cbf927aa5d747341d32012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1021af752b49ceb9383493994d38eaef" id="r_a1021af752b49ceb9383493994d38eaef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a1021af752b49ceb9383493994d38eaef">ttest_ind</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, axis=0, equal_var=True, nan_policy='propagate', permutations=None, random_state=None, alternative=&quot;two-sided&quot;, trim=0)</td></tr>
<tr class="separator:a1021af752b49ceb9383493994d38eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe82260a73fb8c647b4f542dd691b1c" id="r_adbe82260a73fb8c647b4f542dd691b1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#adbe82260a73fb8c647b4f542dd691b1c">_ttest_trim_var_mean_len</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, trim, axis)</td></tr>
<tr class="separator:adbe82260a73fb8c647b4f542dd691b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506544ecd1507c36cadb7b2412e577dd" id="r_a506544ecd1507c36cadb7b2412e577dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a506544ecd1507c36cadb7b2412e577dd">_calculate_winsorized_variance</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#aeb0d2dd2a2609d5775607acf542b2161">g</a>, axis)</td></tr>
<tr class="separator:a506544ecd1507c36cadb7b2412e577dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3be4c10d446d0f0d68e56a854ba225c" id="r_ab3be4c10d446d0f0d68e56a854ba225c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ab3be4c10d446d0f0d68e56a854ba225c">_permutation_distribution_t</a> (data, permutations, size_a, equal_var, random_state=None)</td></tr>
<tr class="separator:ab3be4c10d446d0f0d68e56a854ba225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85145ca01f47db09a5cd8137b027c780" id="r_a85145ca01f47db09a5cd8137b027c780"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a85145ca01f47db09a5cd8137b027c780">_calc_t_stat</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, equal_var, axis=-1)</td></tr>
<tr class="separator:a85145ca01f47db09a5cd8137b027c780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76074b3d866305fa36a138f38ce9611b" id="r_a76074b3d866305fa36a138f38ce9611b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a76074b3d866305fa36a138f38ce9611b">_permutation_ttest</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, permutations, axis=0, equal_var=True, nan_policy='propagate', random_state=None, alternative=&quot;two-sided&quot;)</td></tr>
<tr class="separator:a76074b3d866305fa36a138f38ce9611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2686bf2f43feeb0760374ba16a87dd49" id="r_a2686bf2f43feeb0760374ba16a87dd49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a2686bf2f43feeb0760374ba16a87dd49">_get_len</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis, <a class="el" href="namespacescipy.html#aa152e900785e458cfd34a5a762735897">msg</a>)</td></tr>
<tr class="separator:a2686bf2f43feeb0760374ba16a87dd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e1ede0be1d6f44d3aa61aa9e1be55f" id="r_a40e1ede0be1d6f44d3aa61aa9e1be55f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a40e1ede0be1d6f44d3aa61aa9e1be55f">ttest_rel</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, axis=0, nan_policy='propagate', alternative=&quot;two-sided&quot;)</td></tr>
<tr class="separator:a40e1ede0be1d6f44d3aa61aa9e1be55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee99b9e592bd060aa2218c14a26081b" id="r_a0ee99b9e592bd060aa2218c14a26081b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a0ee99b9e592bd060aa2218c14a26081b">_count</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None)</td></tr>
<tr class="separator:a0ee99b9e592bd060aa2218c14a26081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ba35ca822e6023cb6ae415de882378" id="r_aa7ba35ca822e6023cb6ae415de882378"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aa7ba35ca822e6023cb6ae415de882378">_m_broadcast_to</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, shape)</td></tr>
<tr class="separator:aa7ba35ca822e6023cb6ae415de882378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf3d4c0145bfe43a1b40826651ea3f" id="r_a13bf3d4c0145bfe43a1b40826651ea3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a13bf3d4c0145bfe43a1b40826651ea3f">power_divergence</a> (f_obs, f_exp=None, ddof=0, axis=0, lambda_=None)</td></tr>
<tr class="separator:a13bf3d4c0145bfe43a1b40826651ea3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5794f15c32e4b9eaee99f403e23be4c5" id="r_a5794f15c32e4b9eaee99f403e23be4c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a5794f15c32e4b9eaee99f403e23be4c5">chisquare</a> (f_obs, f_exp=None, ddof=0, axis=0)</td></tr>
<tr class="separator:a5794f15c32e4b9eaee99f403e23be4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3ec19a2c40626858eb6d1686214675" id="r_a1e3ec19a2c40626858eb6d1686214675"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a1e3ec19a2c40626858eb6d1686214675">_compute_dplus</a> (cdfvals)</td></tr>
<tr class="separator:a1e3ec19a2c40626858eb6d1686214675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c0562f1c1cf6c8b5d6e22d5e78f7ec" id="r_ad4c0562f1c1cf6c8b5d6e22d5e78f7ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad4c0562f1c1cf6c8b5d6e22d5e78f7ec">_compute_dminus</a> (cdfvals)</td></tr>
<tr class="separator:ad4c0562f1c1cf6c8b5d6e22d5e78f7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9c2533435c2d2b47aa429ee290ae43" id="r_afd9c2533435c2d2b47aa429ee290ae43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#afd9c2533435c2d2b47aa429ee290ae43">ks_1samp</a> (x, cdf, args=(), alternative='two-sided', <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='auto')</td></tr>
<tr class="separator:afd9c2533435c2d2b47aa429ee290ae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b7cadb3896a61b502dcc260b808ddb" id="r_ae8b7cadb3896a61b502dcc260b808ddb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ae8b7cadb3896a61b502dcc260b808ddb">_compute_prob_outside_square</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>)</td></tr>
<tr class="separator:ae8b7cadb3896a61b502dcc260b808ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7203aa48462f055fd04fbfc629597002" id="r_a7203aa48462f055fd04fbfc629597002"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7203aa48462f055fd04fbfc629597002">_count_paths_outside_method</a> (m, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, <a class="el" href="__lapack__subroutines_8h.html#aeb0d2dd2a2609d5775607acf542b2161">g</a>, <a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>)</td></tr>
<tr class="separator:a7203aa48462f055fd04fbfc629597002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c62a9af6e096d5f25b9abb995c59ea4" id="r_a2c62a9af6e096d5f25b9abb995c59ea4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a2c62a9af6e096d5f25b9abb995c59ea4">_attempt_exact_2kssamp</a> (<a class="el" href="__lapack__subroutines_8h.html#ad13241860d5aa9d8027c8c1d395e5cd9">n1</a>, <a class="el" href="__lapack__subroutines_8h.html#a406c3832a5225544c3afbaeff4271ad6">n2</a>, <a class="el" href="__lapack__subroutines_8h.html#aeb0d2dd2a2609d5775607acf542b2161">g</a>, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>, alternative)</td></tr>
<tr class="separator:a2c62a9af6e096d5f25b9abb995c59ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171a6b4426dbc47cdb093d05f3f1b969" id="r_a171a6b4426dbc47cdb093d05f3f1b969"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a171a6b4426dbc47cdb093d05f3f1b969">ks_2samp</a> (data1, data2, alternative='two-sided', <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='auto')</td></tr>
<tr class="separator:a171a6b4426dbc47cdb093d05f3f1b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3af01a376d251df82e906d556ffaeb" id="r_adb3af01a376d251df82e906d556ffaeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#adb3af01a376d251df82e906d556ffaeb">_parse_kstest_args</a> (data1, data2, args, N)</td></tr>
<tr class="separator:adb3af01a376d251df82e906d556ffaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a98d18b72d14b9f81de22e21faa56" id="r_a918a98d18b72d14b9f81de22e21faa56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a918a98d18b72d14b9f81de22e21faa56">kstest</a> (rvs, cdf, args=(), N=20, alternative='two-sided', <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='auto')</td></tr>
<tr class="separator:a918a98d18b72d14b9f81de22e21faa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e457e8eecfa8d5e63416bd9fbf04af" id="r_aa1e457e8eecfa8d5e63416bd9fbf04af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aa1e457e8eecfa8d5e63416bd9fbf04af">tiecorrect</a> (rankvals)</td></tr>
<tr class="separator:aa1e457e8eecfa8d5e63416bd9fbf04af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9e3566461d8bb479cb9507e9a1bd2e" id="r_a5c9e3566461d8bb479cb9507e9a1bd2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a5c9e3566461d8bb479cb9507e9a1bd2e">ranksums</a> (x, y, alternative='two-sided')</td></tr>
<tr class="separator:a5c9e3566461d8bb479cb9507e9a1bd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cf6e865d5b5a8be777b158f295610d" id="r_a15cf6e865d5b5a8be777b158f295610d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a15cf6e865d5b5a8be777b158f295610d">kruskal</a> (*samples, nan_policy='propagate')</td></tr>
<tr class="separator:a15cf6e865d5b5a8be777b158f295610d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa458038daef3b9b7c308d681b36f93ba" id="r_aa458038daef3b9b7c308d681b36f93ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aa458038daef3b9b7c308d681b36f93ba">friedmanchisquare</a> (*samples)</td></tr>
<tr class="separator:aa458038daef3b9b7c308d681b36f93ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61540456aa6cd16b909618e175d798f9" id="r_a61540456aa6cd16b909618e175d798f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a61540456aa6cd16b909618e175d798f9">brunnermunzel</a> (x, y, alternative=&quot;two-sided&quot;, distribution=&quot;t&quot;, nan_policy='propagate')</td></tr>
<tr class="separator:a61540456aa6cd16b909618e175d798f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6200c846acee0166b2ecb13abdcba1" id="r_a0b6200c846acee0166b2ecb13abdcba1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a0b6200c846acee0166b2ecb13abdcba1">combine_pvalues</a> (pvalues, <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='fisher', weights=None)</td></tr>
<tr class="separator:a0b6200c846acee0166b2ecb13abdcba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030f7a94530750520b7f11137b0f88c6" id="r_a030f7a94530750520b7f11137b0f88c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a030f7a94530750520b7f11137b0f88c6">wasserstein_distance</a> (u_values, v_values, u_weights=None, v_weights=None)</td></tr>
<tr class="memdesc:a030f7a94530750520b7f11137b0f88c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">STATISTICAL DISTANCES #.  <br /></td></tr>
<tr class="separator:a030f7a94530750520b7f11137b0f88c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348efe926c611bfc19391b531685b053" id="r_a348efe926c611bfc19391b531685b053"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a348efe926c611bfc19391b531685b053">energy_distance</a> (u_values, v_values, u_weights=None, v_weights=None)</td></tr>
<tr class="separator:a348efe926c611bfc19391b531685b053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8344423e0575b4b92a28d1aca90279" id="r_a3f8344423e0575b4b92a28d1aca90279"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a3f8344423e0575b4b92a28d1aca90279">_cdf_distance</a> (p, u_values, v_values, u_weights=None, v_weights=None)</td></tr>
<tr class="separator:a3f8344423e0575b4b92a28d1aca90279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5946b7785fb379d1de1cc47b0b338faf" id="r_a5946b7785fb379d1de1cc47b0b338faf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a5946b7785fb379d1de1cc47b0b338faf">_validate_distribution</a> (values, weights)</td></tr>
<tr class="separator:a5946b7785fb379d1de1cc47b0b338faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394edc619f56ba4b055ea6050b269e6" id="r_a6394edc619f56ba4b055ea6050b269e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a6394edc619f56ba4b055ea6050b269e6">find_repeats</a> (arr)</td></tr>
<tr class="separator:a6394edc619f56ba4b055ea6050b269e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35baa494b62135807260b2445335c9f9" id="r_a35baa494b62135807260b2445335c9f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a35baa494b62135807260b2445335c9f9">_sum_of_squares</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0)</td></tr>
<tr class="separator:a35baa494b62135807260b2445335c9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f95272db5e6cd266ad36a67e1353b18" id="r_a4f95272db5e6cd266ad36a67e1353b18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a4f95272db5e6cd266ad36a67e1353b18">_square_of_sums</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=0)</td></tr>
<tr class="separator:a4f95272db5e6cd266ad36a67e1353b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae086c216e46ddf283e278492955e93b6" id="r_ae086c216e46ddf283e278492955e93b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ae086c216e46ddf283e278492955e93b6">rankdata</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='average', *axis=None)</td></tr>
<tr class="separator:ae086c216e46ddf283e278492955e93b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8276a1473f84d29df1cfb05a798c6c86" id="r_a8276a1473f84d29df1cfb05a798c6c86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a8276a1473f84d29df1cfb05a798c6c86">ModeResult</a> = namedtuple('ModeResult', ('<a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad7666823299f40b492d638a114d2fc91">mode</a>', 'count'))</td></tr>
<tr class="separator:a8276a1473f84d29df1cfb05a798c6c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17cbb60a06b3b961b8d3dec3f75f571" id="r_ad17cbb60a06b3b961b8d3dec3f75f571"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad17cbb60a06b3b961b8d3dec3f75f571">DescribeResult</a></td></tr>
<tr class="separator:ad17cbb60a06b3b961b8d3dec3f75f571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517833de500c51cf8468fe2ccee2b20d" id="r_a517833de500c51cf8468fe2ccee2b20d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a517833de500c51cf8468fe2ccee2b20d">SkewtestResult</a> = namedtuple('SkewtestResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a517833de500c51cf8468fe2ccee2b20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db485cb945393c294a5defd286e49bb" id="r_a4db485cb945393c294a5defd286e49bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a4db485cb945393c294a5defd286e49bb">KurtosistestResult</a> = namedtuple('KurtosistestResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a4db485cb945393c294a5defd286e49bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecccad49a9bf1d4db7baeba60ed6c54" id="r_a7ecccad49a9bf1d4db7baeba60ed6c54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a7ecccad49a9bf1d4db7baeba60ed6c54">NormaltestResult</a> = namedtuple('NormaltestResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a7ecccad49a9bf1d4db7baeba60ed6c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f439a7f7f10dd8205b17d45c2fb86b2" id="r_a1f439a7f7f10dd8205b17d45c2fb86b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a1f439a7f7f10dd8205b17d45c2fb86b2">Jarque_beraResult</a> = namedtuple('Jarque_beraResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a1f439a7f7f10dd8205b17d45c2fb86b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159d3500af93794f6cb4a9f959924bb5" id="r_a159d3500af93794f6cb4a9f959924bb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a159d3500af93794f6cb4a9f959924bb5">HistogramResult</a></td></tr>
<tr class="separator:a159d3500af93794f6cb4a9f959924bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a75604ce103a4f3a8661da14b41ba21" id="r_a1a75604ce103a4f3a8661da14b41ba21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a1a75604ce103a4f3a8661da14b41ba21">CumfreqResult</a></td></tr>
<tr class="separator:a1a75604ce103a4f3a8661da14b41ba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0739c0c0192b367b27d6d1fc6b076469" id="r_a0739c0c0192b367b27d6d1fc6b076469"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a0739c0c0192b367b27d6d1fc6b076469">RelfreqResult</a></td></tr>
<tr class="separator:a0739c0c0192b367b27d6d1fc6b076469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8ab9655add9064cf78ddbfc338cbb2" id="r_a1d8ab9655add9064cf78ddbfc338cbb2"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a1d8ab9655add9064cf78ddbfc338cbb2">_scale_conversions</a></td></tr>
<tr class="separator:a1d8ab9655add9064cf78ddbfc338cbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3bb71bac397106f36f0ebe2f76ff8e" id="r_ade3bb71bac397106f36f0ebe2f76ff8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ade3bb71bac397106f36f0ebe2f76ff8e">SigmaclipResult</a> = namedtuple('SigmaclipResult', ('clipped', 'lower', 'upper'))</td></tr>
<tr class="memdesc:ade3bb71bac397106f36f0ebe2f76ff8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRIMMING FUNCTIONS #.  <br /></td></tr>
<tr class="separator:ade3bb71bac397106f36f0ebe2f76ff8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dd91ad97a133a4f1c4014a850145ea" id="r_a55dd91ad97a133a4f1c4014a850145ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a55dd91ad97a133a4f1c4014a850145ea">F_onewayResult</a> = namedtuple('F_onewayResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a55dd91ad97a133a4f1c4014a850145ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7648a89e048475c07fbb825533e786c" id="r_ae7648a89e048475c07fbb825533e786c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ae7648a89e048475c07fbb825533e786c">AlexanderGovernResult</a></td></tr>
<tr class="separator:ae7648a89e048475c07fbb825533e786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1ccd5e913ab32dee4d40b27b90992" id="r_ae4b1ccd5e913ab32dee4d40b27b90992"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ae4b1ccd5e913ab32dee4d40b27b90992">ConfidenceInterval</a> = namedtuple('ConfidenceInterval', ['low', 'high'])</td></tr>
<tr class="separator:ae4b1ccd5e913ab32dee4d40b27b90992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad063c82a38b3f71d713793c4565ca702" id="r_ad063c82a38b3f71d713793c4565ca702"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad063c82a38b3f71d713793c4565ca702">PearsonRResultBase</a></td></tr>
<tr class="separator:ad063c82a38b3f71d713793c4565ca702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65c21aa9410cca040a193a63e87a6d7" id="r_af65c21aa9410cca040a193a63e87a6d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#af65c21aa9410cca040a193a63e87a6d7">SpearmanrResult</a> = namedtuple('SpearmanrResult', ('correlation', 'pvalue'))</td></tr>
<tr class="separator:af65c21aa9410cca040a193a63e87a6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913606dcc240c37cbf6afcf2792f5953" id="r_a913606dcc240c37cbf6afcf2792f5953"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a913606dcc240c37cbf6afcf2792f5953">PointbiserialrResult</a></td></tr>
<tr class="separator:a913606dcc240c37cbf6afcf2792f5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aec35f18fcad0d467a2f475f4e88e5b" id="r_a4aec35f18fcad0d467a2f475f4e88e5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a4aec35f18fcad0d467a2f475f4e88e5b">KendalltauResult</a> = namedtuple('KendalltauResult', ('correlation', 'pvalue'))</td></tr>
<tr class="separator:a4aec35f18fcad0d467a2f475f4e88e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930e1fabe137790d52534b714cb17086" id="r_a930e1fabe137790d52534b714cb17086"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a930e1fabe137790d52534b714cb17086">WeightedTauResult</a> = namedtuple('WeightedTauResult', ('correlation', 'pvalue'))</td></tr>
<tr class="separator:a930e1fabe137790d52534b714cb17086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b67a68f52e541cf43ed09574e13108" id="r_a79b67a68f52e541cf43ed09574e13108"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a79b67a68f52e541cf43ed09574e13108">MGCResult</a> = namedtuple('MGCResult', ('stat', 'pvalue', 'mgc_dict'))</td></tr>
<tr class="separator:a79b67a68f52e541cf43ed09574e13108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea14330e23d04b115bb0ff1ea380077b" id="r_aea14330e23d04b115bb0ff1ea380077b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#aea14330e23d04b115bb0ff1ea380077b">Ttest_1sampResult</a> = namedtuple('Ttest_1sampResult', ('statistic', 'pvalue'))</td></tr>
<tr class="memdesc:aea14330e23d04b115bb0ff1ea380077b"><td class="mdescLeft">&#160;</td><td class="mdescRight">INFERENTIAL STATISTICS #.  <br /></td></tr>
<tr class="separator:aea14330e23d04b115bb0ff1ea380077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b754f522c03e7fccd72c806de40407" id="r_ab6b754f522c03e7fccd72c806de40407"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ab6b754f522c03e7fccd72c806de40407">Ttest_indResult</a> = namedtuple('Ttest_indResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:ab6b754f522c03e7fccd72c806de40407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f00b9b1e4a728af7bbdd4d515a7cf3" id="r_a38f00b9b1e4a728af7bbdd4d515a7cf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a38f00b9b1e4a728af7bbdd4d515a7cf3">Ttest_relResult</a> = namedtuple('Ttest_relResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a38f00b9b1e4a728af7bbdd4d515a7cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1eac21b5e82f9848b2523b6b90995e" id="r_a8a1eac21b5e82f9848b2523b6b90995e"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a8a1eac21b5e82f9848b2523b6b90995e">_power_div_lambda_names</a></td></tr>
<tr class="separator:a8a1eac21b5e82f9848b2523b6b90995e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b74f644917a36fcd23aa95f48810815" id="r_a0b74f644917a36fcd23aa95f48810815"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a0b74f644917a36fcd23aa95f48810815">Power_divergenceResult</a></td></tr>
<tr class="separator:a0b74f644917a36fcd23aa95f48810815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c2563e8e2c6e7d3e19fa32131a6796" id="r_af6c2563e8e2c6e7d3e19fa32131a6796"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#af6c2563e8e2c6e7d3e19fa32131a6796">KstestResult</a> = namedtuple('KstestResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:af6c2563e8e2c6e7d3e19fa32131a6796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3e4d7762108939709c279fff05dcb4" id="r_a4c3e4d7762108939709c279fff05dcb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a4c3e4d7762108939709c279fff05dcb4">Ks_2sampResult</a> = <a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#af6c2563e8e2c6e7d3e19fa32131a6796">KstestResult</a></td></tr>
<tr class="separator:a4c3e4d7762108939709c279fff05dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13929c3e11b3aea010483ae368fdeeea" id="r_a13929c3e11b3aea010483ae368fdeeea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a13929c3e11b3aea010483ae368fdeeea">RanksumsResult</a> = namedtuple('RanksumsResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a13929c3e11b3aea010483ae368fdeeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cba6ca5b344ceda11181bcd5f6adea" id="r_ac9cba6ca5b344ceda11181bcd5f6adea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ac9cba6ca5b344ceda11181bcd5f6adea">KruskalResult</a> = namedtuple('KruskalResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:ac9cba6ca5b344ceda11181bcd5f6adea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf31b33400d148f6ef0e0f3b66f5d2be" id="r_acf31b33400d148f6ef0e0f3b66f5d2be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#acf31b33400d148f6ef0e0f3b66f5d2be">FriedmanchisquareResult</a></td></tr>
<tr class="separator:acf31b33400d148f6ef0e0f3b66f5d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084547535521fc8a4e2ca13da7ccf236" id="r_a084547535521fc8a4e2ca13da7ccf236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a084547535521fc8a4e2ca13da7ccf236">BrunnerMunzelResult</a></td></tr>
<tr class="separator:a084547535521fc8a4e2ca13da7ccf236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abc71d3f4e3d43499eea3985b7d2bd9" id="r_a5abc71d3f4e3d43499eea3985b7d2bd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#a5abc71d3f4e3d43499eea3985b7d2bd9">RepeatedResults</a> = namedtuple('RepeatedResults', ('values', 'counts'))</td></tr>
<tr class="memdesc:a5abc71d3f4e3d43499eea3985b7d2bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPORT FUNCTIONS #.  <br /></td></tr>
<tr class="separator:a5abc71d3f4e3d43499eea3985b7d2bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">A collection of basic statistical functions for Python.

References
----------
.. [CRCProbStat2000] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ab1d9eb219fb20aaeb0a65cee954f5001" name="ab1d9eb219fb20aaeb0a65cee954f5001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d9eb219fb20aaeb0a65cee954f5001">&#9670;&#160;</a></span>_alexandergovern_input_validation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._alexandergovern_input_validation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4095</span><span class="keyword">def </span>_alexandergovern_input_validation(samples, nan_policy):</div>
<div class="line"><span class="lineno"> 4096</span>    <span class="keywordflow">if</span> len(samples) &lt; 2:</div>
<div class="line"><span class="lineno"> 4097</span>        <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;2 or more inputs required, got {len(samples)}&quot;</span>)</div>
<div class="line"><span class="lineno"> 4098</span> </div>
<div class="line"><span class="lineno"> 4099</span>    <span class="comment"># input arrays are flattened</span></div>
<div class="line"><span class="lineno"> 4100</span>    samples = [np.asarray(sample, dtype=float) <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples]</div>
<div class="line"><span class="lineno"> 4101</span> </div>
<div class="line"><span class="lineno"> 4102</span>    <span class="keywordflow">for</span> i, sample <span class="keywordflow">in</span> enumerate(samples):</div>
<div class="line"><span class="lineno"> 4103</span>        <span class="keywordflow">if</span> np.size(sample) &lt;= 1:</div>
<div class="line"><span class="lineno"> 4104</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Input sample size must be greater than one.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4105</span>        <span class="keywordflow">if</span> sample.ndim != 1:</div>
<div class="line"><span class="lineno"> 4106</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Input samples must be one-dimensional&quot;</span>)</div>
<div class="line"><span class="lineno"> 4107</span>        <span class="keywordflow">if</span> np.isinf(sample).any():</div>
<div class="line"><span class="lineno"> 4108</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Input samples must be finite.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4109</span> </div>
<div class="line"><span class="lineno"> 4110</span>        contains_nan, nan_policy = _contains_nan(sample,</div>
<div class="line"><span class="lineno"> 4111</span>                                                 nan_policy=nan_policy)</div>
<div class="line"><span class="lineno"> 4112</span>        <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 4113</span>            samples[i] = ma.masked_invalid(sample)</div>
<div class="line"><span class="lineno"> 4114</span>    <span class="keywordflow">return</span> samples</div>
<div class="line"><span class="lineno"> 4115</span> </div>
<div class="line"><span class="lineno"> 4116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c62a9af6e096d5f25b9abb995c59ea4" name="a2c62a9af6e096d5f25b9abb995c59ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c62a9af6e096d5f25b9abb995c59ea4">&#9670;&#160;</a></span>_attempt_exact_2kssamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._attempt_exact_2kssamp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Attempts to compute the exact 2sample probability.

n1, n2 are the sample sizes
g is the gcd(n1, n2)
d is the computed max difference in ECDFs

Returns (success, d, probability)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 7623</span><span class="keyword">def </span>_attempt_exact_2kssamp(n1, n2, g, d, alternative):</div>
<div class="line"><span class="lineno"> 7624</span>    <span class="stringliteral">&quot;&quot;&quot;Attempts to compute the exact 2sample probability.</span></div>
<div class="line"><span class="lineno"> 7625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7626</span><span class="stringliteral">    n1, n2 are the sample sizes</span></div>
<div class="line"><span class="lineno"> 7627</span><span class="stringliteral">    g is the gcd(n1, n2)</span></div>
<div class="line"><span class="lineno"> 7628</span><span class="stringliteral">    d is the computed max difference in ECDFs</span></div>
<div class="line"><span class="lineno"> 7629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7630</span><span class="stringliteral">    Returns (success, d, probability)</span></div>
<div class="line"><span class="lineno"> 7631</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7632</span>    lcm = (n1 // g) * n2</div>
<div class="line"><span class="lineno"> 7633</span>    h = int(np.round(d * lcm))</div>
<div class="line"><span class="lineno"> 7634</span>    d = h * 1.0 / lcm</div>
<div class="line"><span class="lineno"> 7635</span>    <span class="keywordflow">if</span> h == 0:</div>
<div class="line"><span class="lineno"> 7636</span>        <span class="keywordflow">return</span> <span class="keyword">True</span>, d, 1.0</div>
<div class="line"><span class="lineno"> 7637</span>    saw_fp_error, prob = <span class="keyword">False</span>, np.nan</div>
<div class="line"><span class="lineno"> 7638</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 7639</span>        <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;two-sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 7640</span>            <span class="keywordflow">if</span> n1 == n2:</div>
<div class="line"><span class="lineno"> 7641</span>                prob = _compute_prob_outside_square(n1, h)</div>
<div class="line"><span class="lineno"> 7642</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7643</span>                prob = _compute_outer_prob_inside_method(n1, n2, g, h)</div>
<div class="line"><span class="lineno"> 7644</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7645</span>            <span class="keywordflow">if</span> n1 == n2:</div>
<div class="line"><span class="lineno"> 7646</span>                <span class="comment"># prob = binom(2n, n-h) / binom(2n, n)</span></div>
<div class="line"><span class="lineno"> 7647</span>                <span class="comment"># Evaluating in that form incurs roundoff errors</span></div>
<div class="line"><span class="lineno"> 7648</span>                <span class="comment"># from special.binom. Instead calculate directly</span></div>
<div class="line"><span class="lineno"> 7649</span>                jrange = np.arange(h)</div>
<div class="line"><span class="lineno"> 7650</span>                prob = np.prod((n1 - jrange) / (n1 + jrange + 1.0))</div>
<div class="line"><span class="lineno"> 7651</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7652</span>                <span class="keyword">with</span> np.errstate(over=<span class="stringliteral">&#39;raise&#39;</span>):</div>
<div class="line"><span class="lineno"> 7653</span>                    num_paths = _count_paths_outside_method(n1, n2, g, h)</div>
<div class="line"><span class="lineno"> 7654</span>                bin = special.binom(n1 + n2, n1)</div>
<div class="line"><span class="lineno"> 7655</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(bin) <span class="keywordflow">or</span> <span class="keywordflow">not</span> np.isfinite(num_paths)\</div>
<div class="line"><span class="lineno"> 7656</span>                        <span class="keywordflow">or</span> num_paths &gt; bin:</div>
<div class="line"><span class="lineno"> 7657</span>                    saw_fp_error = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 7658</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7659</span>                    prob = num_paths / bin</div>
<div class="line"><span class="lineno"> 7660</span> </div>
<div class="line"><span class="lineno"> 7661</span>    <span class="keywordflow">except</span> FloatingPointError:</div>
<div class="line"><span class="lineno"> 7662</span>        saw_fp_error = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 7663</span> </div>
<div class="line"><span class="lineno"> 7664</span>    <span class="keywordflow">if</span> saw_fp_error:</div>
<div class="line"><span class="lineno"> 7665</span>        <span class="keywordflow">return</span> <span class="keyword">False</span>, d, np.nan</div>
<div class="line"><span class="lineno"> 7666</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (0 &lt;= prob &lt;= 1):</div>
<div class="line"><span class="lineno"> 7667</span>        <span class="keywordflow">return</span> <span class="keyword">False</span>, d, prob</div>
<div class="line"><span class="lineno"> 7668</span>    <span class="keywordflow">return</span> <span class="keyword">True</span>, d, prob</div>
<div class="line"><span class="lineno"> 7669</span> </div>
<div class="line"><span class="lineno"> 7670</span> </div>
<div class="line"><span class="lineno"> 7671</span><span class="preprocessor">@_rename_parameter(&quot;mode&quot;, &quot;method&quot;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae75919663212e70e8b42c261ff94f7f0" name="ae75919663212e70e8b42c261ff94f7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75919663212e70e8b42c261ff94f7f0">&#9670;&#160;</a></span>_broadcast_shapes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._broadcast_shapes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Given two shapes (i.e. tuples of integers), return the shape
that would result from broadcasting two arrays with the given
shapes.

Examples
--------
&gt;&gt;&gt; _broadcast_shapes((2, 1), (4, 1, 3))
(4, 2, 3)
</pre> <div class="fragment"><div class="line"><span class="lineno">  174</span><span class="keyword">def </span>_broadcast_shapes(shape1, shape2):</div>
<div class="line"><span class="lineno">  175</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    Given two shapes (i.e. tuples of integers), return the shape</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    that would result from broadcasting two arrays with the given</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    shapes.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    &gt;&gt;&gt; _broadcast_shapes((2, 1), (4, 1, 3))</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    (4, 2, 3)</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  185</span>    d = len(shape1) - len(shape2)</div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">if</span> d &lt;= 0:</div>
<div class="line"><span class="lineno">  187</span>        shp1 = (1,)*(-d) + shape1</div>
<div class="line"><span class="lineno">  188</span>        shp2 = shape2</div>
<div class="line"><span class="lineno">  189</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  190</span>        shp1 = shape1</div>
<div class="line"><span class="lineno">  191</span>        shp2 = (1,)*d + shape2</div>
<div class="line"><span class="lineno">  192</span>    shape = []</div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordflow">for</span> n1, n2 <span class="keywordflow">in</span> zip(shp1, shp2):</div>
<div class="line"><span class="lineno">  194</span>        <span class="keywordflow">if</span> n1 == 1:</div>
<div class="line"><span class="lineno">  195</span>            n = n2</div>
<div class="line"><span class="lineno">  196</span>        <span class="keywordflow">elif</span> n2 == 1 <span class="keywordflow">or</span> n1 == n2:</div>
<div class="line"><span class="lineno">  197</span>            n = n1</div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  199</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;shapes {shape1} and {shape2} could not be &#39;</span></div>
<div class="line"><span class="lineno">  200</span>                             <span class="stringliteral">&#39;broadcast together&#39;</span>)</div>
<div class="line"><span class="lineno">  201</span>        shape.append(n)</div>
<div class="line"><span class="lineno">  202</span>    <span class="keywordflow">return</span> tuple(shape)</div>
<div class="line"><span class="lineno">  203</span> </div>
<div class="line"><span class="lineno">  204</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab708b4ea9dd64696b388692dd3609d00" name="ab708b4ea9dd64696b388692dd3609d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab708b4ea9dd64696b388692dd3609d00">&#9670;&#160;</a></span>_broadcast_shapes_with_dropped_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._broadcast_shapes_with_dropped_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Given two arrays `a` and `b` and an integer `axis`, find the
shape of the broadcast result after dropping `axis` from the
shapes of `a` and `b`.

Examples
--------
&gt;&gt;&gt; a = np.zeros((5, 2, 1))
&gt;&gt;&gt; b = np.zeros((1, 9, 3))
&gt;&gt;&gt; _broadcast_shapes_with_dropped_axis(a, b, 1)
(5, 3)
</pre> <div class="fragment"><div class="line"><span class="lineno">  205</span><span class="keyword">def </span>_broadcast_shapes_with_dropped_axis(a, b, axis):</div>
<div class="line"><span class="lineno">  206</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    Given two arrays `a` and `b` and an integer `axis`, find the</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    shape of the broadcast result after dropping `axis` from the</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    shapes of `a` and `b`.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((5, 2, 1))</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    &gt;&gt;&gt; b = np.zeros((1, 9, 3))</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; _broadcast_shapes_with_dropped_axis(a, b, 1)</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    (5, 3)</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  218</span>    shp1 = _shape_with_dropped_axis(a, axis)</div>
<div class="line"><span class="lineno">  219</span>    shp2 = _shape_with_dropped_axis(b, axis)</div>
<div class="line"><span class="lineno">  220</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  221</span>        shp = _broadcast_shapes(shp1, shp2)</div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;non-axis shapes {shp1} and {shp2} could not be &#39;</span></div>
<div class="line"><span class="lineno">  224</span>                         <span class="stringliteral">&#39;broadcast together&#39;</span>) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  225</span>    <span class="keywordflow">return</span> shp</div>
<div class="line"><span class="lineno">  226</span> </div>
<div class="line"><span class="lineno">  227</span> </div>
<div class="line"><span class="lineno">  228</span><span class="comment"># note that `weights` are paired with `x`</span></div>
<div class="line"><span class="lineno">  229</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno">  230</span>        <span class="keyword">lambda</span> x: x, n_samples=1, n_outputs=1, too_small=0, paired=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  231</span>        result_to_tuple=<span class="keyword">lambda</span> x: (x,), kwd_samples=[<span class="stringliteral">&#39;weights&#39;</span>])</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85145ca01f47db09a5cd8137b027c780" name="a85145ca01f47db09a5cd8137b027c780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85145ca01f47db09a5cd8137b027c780">&#9670;&#160;</a></span>_calc_t_stat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._calc_t_stat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate the t statistic along the given dimension.</pre> <div class="fragment"><div class="line"><span class="lineno"> 6700</span><span class="keyword">def </span>_calc_t_stat(a, b, equal_var, axis=-1):</div>
<div class="line"><span class="lineno"> 6701</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the t statistic along the given dimension.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6702</span>    na = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6703</span>    nb = b.shape[axis]</div>
<div class="line"><span class="lineno"> 6704</span>    avg_a = np.mean(a, axis=axis)</div>
<div class="line"><span class="lineno"> 6705</span>    avg_b = np.mean(b, axis=axis)</div>
<div class="line"><span class="lineno"> 6706</span>    var_a = _var(a, axis=axis, ddof=1)</div>
<div class="line"><span class="lineno"> 6707</span>    var_b = _var(b, axis=axis, ddof=1)</div>
<div class="line"><span class="lineno"> 6708</span> </div>
<div class="line"><span class="lineno"> 6709</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> equal_var:</div>
<div class="line"><span class="lineno"> 6710</span>        denom = _unequal_var_ttest_denom(var_a, na, var_b, nb)[1]</div>
<div class="line"><span class="lineno"> 6711</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6712</span>        denom = _equal_var_ttest_denom(var_a, na, var_b, nb)[1]</div>
<div class="line"><span class="lineno"> 6713</span> </div>
<div class="line"><span class="lineno"> 6714</span>    <span class="keywordflow">return</span> (avg_a-avg_b)/denom</div>
<div class="line"><span class="lineno"> 6715</span> </div>
<div class="line"><span class="lineno"> 6716</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a506544ecd1507c36cadb7b2412e577dd" name="a506544ecd1507c36cadb7b2412e577dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506544ecd1507c36cadb7b2412e577dd">&#9670;&#160;</a></span>_calculate_winsorized_variance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._calculate_winsorized_variance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculates g-times winsorized variance along specified axis</pre> <div class="fragment"><div class="line"><span class="lineno"> 6627</span><span class="keyword">def </span>_calculate_winsorized_variance(a, g, axis):</div>
<div class="line"><span class="lineno"> 6628</span>    <span class="stringliteral">&quot;&quot;&quot;Calculates g-times winsorized variance along specified axis&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6629</span>    <span class="comment"># it is expected that the input `a` is sorted along the correct axis</span></div>
<div class="line"><span class="lineno"> 6630</span>    <span class="keywordflow">if</span> g == 0:</div>
<div class="line"><span class="lineno"> 6631</span>        <span class="keywordflow">return</span> _var(a, ddof=1, axis=axis)</div>
<div class="line"><span class="lineno"> 6632</span>    <span class="comment"># move the intended axis to the end that way it is easier to manipulate</span></div>
<div class="line"><span class="lineno"> 6633</span>    a_win = np.moveaxis(a, axis, -1)</div>
<div class="line"><span class="lineno"> 6634</span> </div>
<div class="line"><span class="lineno"> 6635</span>    <span class="comment"># save where NaNs are for later use.</span></div>
<div class="line"><span class="lineno"> 6636</span>    nans_indices = np.any(np.isnan(a_win), axis=-1)</div>
<div class="line"><span class="lineno"> 6637</span> </div>
<div class="line"><span class="lineno"> 6638</span>    <span class="comment"># Winsorization and variance calculation are done in one step in [4]</span></div>
<div class="line"><span class="lineno"> 6639</span>    <span class="comment"># (1-3), but here winsorization is done first; replace the left and</span></div>
<div class="line"><span class="lineno"> 6640</span>    <span class="comment"># right sides with the repeating value. This can be see in effect in (</span></div>
<div class="line"><span class="lineno"> 6641</span>    <span class="comment"># 1-3) in [4], where the leftmost and rightmost tails are replaced with</span></div>
<div class="line"><span class="lineno"> 6642</span>    <span class="comment"># `(g + 1) * x_{g + 1}` on the left and `(g + 1) * x_{n - g}` on the</span></div>
<div class="line"><span class="lineno"> 6643</span>    <span class="comment"># right. Zero-indexing turns `g + 1` to `g`, and `n - g` to `- g - 1` in</span></div>
<div class="line"><span class="lineno"> 6644</span>    <span class="comment"># array indexing.</span></div>
<div class="line"><span class="lineno"> 6645</span>    a_win[..., :g] = a_win[..., [g]]</div>
<div class="line"><span class="lineno"> 6646</span>    a_win[..., -g:] = a_win[..., [-g - 1]]</div>
<div class="line"><span class="lineno"> 6647</span> </div>
<div class="line"><span class="lineno"> 6648</span>    <span class="comment"># Determine the variance. In [4], the degrees of freedom is expressed as</span></div>
<div class="line"><span class="lineno"> 6649</span>    <span class="comment"># `h - 1`, where `h = n - 2g` (unnumbered equations in Section 1, end of</span></div>
<div class="line"><span class="lineno"> 6650</span>    <span class="comment"># page 369, beginning of page 370). This is converted to NumPy&#39;s format,</span></div>
<div class="line"><span class="lineno"> 6651</span>    <span class="comment"># `n - ddof` for use with with `np.var`. The result is converted to an</span></div>
<div class="line"><span class="lineno"> 6652</span>    <span class="comment"># array to accommodate indexing later.</span></div>
<div class="line"><span class="lineno"> 6653</span>    var_win = np.asarray(_var(a_win, ddof=(2 * g + 1), axis=-1))</div>
<div class="line"><span class="lineno"> 6654</span> </div>
<div class="line"><span class="lineno"> 6655</span>    <span class="comment"># with `nan_policy=&#39;propagate&#39;`, NaNs may be completely trimmed out</span></div>
<div class="line"><span class="lineno"> 6656</span>    <span class="comment"># because they were sorted into the tail of the array. In these cases,</span></div>
<div class="line"><span class="lineno"> 6657</span>    <span class="comment"># replace computed variances with `np.nan`.</span></div>
<div class="line"><span class="lineno"> 6658</span>    var_win[nans_indices] = np.nan</div>
<div class="line"><span class="lineno"> 6659</span>    <span class="keywordflow">return</span> var_win</div>
<div class="line"><span class="lineno"> 6660</span> </div>
<div class="line"><span class="lineno"> 6661</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f8344423e0575b4b92a28d1aca90279" name="a3f8344423e0575b4b92a28d1aca90279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8344423e0575b4b92a28d1aca90279">&#9670;&#160;</a></span>_cdf_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._cdf_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v_weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    Compute, between two one-dimensional distributions :math:`u` and
    :math:`v`, whose respective CDFs are :math:`U` and :math:`V`, the
    statistical distance that is defined as:

    .. math::

        l_p(u, v) = \left( \int_{-\infty}^{+\infty} |U-V|^p \right)^{1/p}

    p is a positive parameter; p = 1 gives the Wasserstein distance, p = 2
    gives the energy distance.

    Parameters
    ----------
    u_values, v_values : array_like
        Values observed in the (empirical) distribution.
    u_weights, v_weights : array_like, optional
        Weight for each value. If unspecified, each value is assigned the same
        weight.
        `u_weights` (resp. `v_weights`) must have the same length as
        `u_values` (resp. `v_values`). If the weight sum differs from 1, it
        must still be positive and finite so that the weights can be normalized
        to sum to 1.

    Returns
    -------
    distance : float
        The computed distance between the distributions.

    Notes
    -----
    The input distributions can be empirical, therefore coming from samples
    whose values are effectively inputs of the function, or they can be seen as
    generalized functions, in which case they are weighted sums of Dirac delta
    functions located at the specified values.

    References
    ----------
    .. [1] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer,
           Munos "The Cramer Distance as a Solution to Biased Wasserstein
           Gradients" (2017). :arXiv:`1705.10743`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 8838</span><span class="keyword">def </span>_cdf_distance(p, u_values, v_values, u_weights=None, v_weights=None):</div>
<div class="line"><span class="lineno"> 8839</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8840</span><span class="stringliteral">    Compute, between two one-dimensional distributions :math:`u` and</span></div>
<div class="line"><span class="lineno"> 8841</span><span class="stringliteral">    :math:`v`, whose respective CDFs are :math:`U` and :math:`V`, the</span></div>
<div class="line"><span class="lineno"> 8842</span><span class="stringliteral">    statistical distance that is defined as:</span></div>
<div class="line"><span class="lineno"> 8843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8844</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 8845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8846</span><span class="stringliteral">        l_p(u, v) = \left( \int_{-\infty}^{+\infty} |U-V|^p \right)^{1/p}</span></div>
<div class="line"><span class="lineno"> 8847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8848</span><span class="stringliteral">    p is a positive parameter; p = 1 gives the Wasserstein distance, p = 2</span></div>
<div class="line"><span class="lineno"> 8849</span><span class="stringliteral">    gives the energy distance.</span></div>
<div class="line"><span class="lineno"> 8850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8851</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8852</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8853</span><span class="stringliteral">    u_values, v_values : array_like</span></div>
<div class="line"><span class="lineno"> 8854</span><span class="stringliteral">        Values observed in the (empirical) distribution.</span></div>
<div class="line"><span class="lineno"> 8855</span><span class="stringliteral">    u_weights, v_weights : array_like, optional</span></div>
<div class="line"><span class="lineno"> 8856</span><span class="stringliteral">        Weight for each value. If unspecified, each value is assigned the same</span></div>
<div class="line"><span class="lineno"> 8857</span><span class="stringliteral">        weight.</span></div>
<div class="line"><span class="lineno"> 8858</span><span class="stringliteral">        `u_weights` (resp. `v_weights`) must have the same length as</span></div>
<div class="line"><span class="lineno"> 8859</span><span class="stringliteral">        `u_values` (resp. `v_values`). If the weight sum differs from 1, it</span></div>
<div class="line"><span class="lineno"> 8860</span><span class="stringliteral">        must still be positive and finite so that the weights can be normalized</span></div>
<div class="line"><span class="lineno"> 8861</span><span class="stringliteral">        to sum to 1.</span></div>
<div class="line"><span class="lineno"> 8862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8863</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8864</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8865</span><span class="stringliteral">    distance : float</span></div>
<div class="line"><span class="lineno"> 8866</span><span class="stringliteral">        The computed distance between the distributions.</span></div>
<div class="line"><span class="lineno"> 8867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8868</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8869</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8870</span><span class="stringliteral">    The input distributions can be empirical, therefore coming from samples</span></div>
<div class="line"><span class="lineno"> 8871</span><span class="stringliteral">    whose values are effectively inputs of the function, or they can be seen as</span></div>
<div class="line"><span class="lineno"> 8872</span><span class="stringliteral">    generalized functions, in which case they are weighted sums of Dirac delta</span></div>
<div class="line"><span class="lineno"> 8873</span><span class="stringliteral">    functions located at the specified values.</span></div>
<div class="line"><span class="lineno"> 8874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8875</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8876</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8877</span><span class="stringliteral">    .. [1] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer,</span></div>
<div class="line"><span class="lineno"> 8878</span><span class="stringliteral">           Munos &quot;The Cramer Distance as a Solution to Biased Wasserstein</span></div>
<div class="line"><span class="lineno"> 8879</span><span class="stringliteral">           Gradients&quot; (2017). :arXiv:`1705.10743`.</span></div>
<div class="line"><span class="lineno"> 8880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8881</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8882</span>    u_values, u_weights = _validate_distribution(u_values, u_weights)</div>
<div class="line"><span class="lineno"> 8883</span>    v_values, v_weights = _validate_distribution(v_values, v_weights)</div>
<div class="line"><span class="lineno"> 8884</span> </div>
<div class="line"><span class="lineno"> 8885</span>    u_sorter = np.argsort(u_values)</div>
<div class="line"><span class="lineno"> 8886</span>    v_sorter = np.argsort(v_values)</div>
<div class="line"><span class="lineno"> 8887</span> </div>
<div class="line"><span class="lineno"> 8888</span>    all_values = np.concatenate((u_values, v_values))</div>
<div class="line"><span class="lineno"> 8889</span>    all_values.sort(kind=<span class="stringliteral">&#39;mergesort&#39;</span>)</div>
<div class="line"><span class="lineno"> 8890</span> </div>
<div class="line"><span class="lineno"> 8891</span>    <span class="comment"># Compute the differences between pairs of successive values of u and v.</span></div>
<div class="line"><span class="lineno"> 8892</span>    deltas = np.diff(all_values)</div>
<div class="line"><span class="lineno"> 8893</span> </div>
<div class="line"><span class="lineno"> 8894</span>    <span class="comment"># Get the respective positions of the values of u and v among the values of</span></div>
<div class="line"><span class="lineno"> 8895</span>    <span class="comment"># both distributions.</span></div>
<div class="line"><span class="lineno"> 8896</span>    u_cdf_indices = u_values[u_sorter].searchsorted(all_values[:-1], <span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno"> 8897</span>    v_cdf_indices = v_values[v_sorter].searchsorted(all_values[:-1], <span class="stringliteral">&#39;right&#39;</span>)</div>
<div class="line"><span class="lineno"> 8898</span> </div>
<div class="line"><span class="lineno"> 8899</span>    <span class="comment"># Calculate the CDFs of u and v using their weights, if specified.</span></div>
<div class="line"><span class="lineno"> 8900</span>    <span class="keywordflow">if</span> u_weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 8901</span>        u_cdf = u_cdf_indices / u_values.size</div>
<div class="line"><span class="lineno"> 8902</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 8903</span>        u_sorted_cumweights = np.concatenate(([0],</div>
<div class="line"><span class="lineno"> 8904</span>                                              np.cumsum(u_weights[u_sorter])))</div>
<div class="line"><span class="lineno"> 8905</span>        u_cdf = u_sorted_cumweights[u_cdf_indices] / u_sorted_cumweights[-1]</div>
<div class="line"><span class="lineno"> 8906</span> </div>
<div class="line"><span class="lineno"> 8907</span>    <span class="keywordflow">if</span> v_weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 8908</span>        v_cdf = v_cdf_indices / v_values.size</div>
<div class="line"><span class="lineno"> 8909</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 8910</span>        v_sorted_cumweights = np.concatenate(([0],</div>
<div class="line"><span class="lineno"> 8911</span>                                              np.cumsum(v_weights[v_sorter])))</div>
<div class="line"><span class="lineno"> 8912</span>        v_cdf = v_sorted_cumweights[v_cdf_indices] / v_sorted_cumweights[-1]</div>
<div class="line"><span class="lineno"> 8913</span> </div>
<div class="line"><span class="lineno"> 8914</span>    <span class="comment"># Compute the value of the integral based on the CDFs.</span></div>
<div class="line"><span class="lineno"> 8915</span>    <span class="comment"># If p = 1 or p = 2, we avoid using np.power, which introduces an overhead</span></div>
<div class="line"><span class="lineno"> 8916</span>    <span class="comment"># of about 15%.</span></div>
<div class="line"><span class="lineno"> 8917</span>    <span class="keywordflow">if</span> p == 1:</div>
<div class="line"><span class="lineno"> 8918</span>        <span class="keywordflow">return</span> np.sum(np.multiply(np.abs(u_cdf - v_cdf), deltas))</div>
<div class="line"><span class="lineno"> 8919</span>    <span class="keywordflow">if</span> p == 2:</div>
<div class="line"><span class="lineno"> 8920</span>        <span class="keywordflow">return</span> np.sqrt(np.sum(np.multiply(np.square(u_cdf - v_cdf), deltas)))</div>
<div class="line"><span class="lineno"> 8921</span>    <span class="keywordflow">return</span> np.power(np.sum(np.multiply(np.power(np.abs(u_cdf - v_cdf), p),</div>
<div class="line"><span class="lineno"> 8922</span>                                       deltas)), 1/p)</div>
<div class="line"><span class="lineno"> 8923</span> </div>
<div class="line"><span class="lineno"> 8924</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7b513e10adf4355933dc921bac165b7" name="aa7b513e10adf4355933dc921bac165b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b513e10adf4355933dc921bac165b7">&#9670;&#160;</a></span>_chk2_asarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._chk2_asarray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  136</span><span class="keyword">def </span>_chk2_asarray(a, b, axis):</div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  138</span>        a = np.ravel(a)</div>
<div class="line"><span class="lineno">  139</span>        b = np.ravel(b)</div>
<div class="line"><span class="lineno">  140</span>        outaxis = 0</div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  142</span>        a = np.asarray(a)</div>
<div class="line"><span class="lineno">  143</span>        b = np.asarray(b)</div>
<div class="line"><span class="lineno">  144</span>        outaxis = axis</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>    <span class="keywordflow">if</span> a.ndim == 0:</div>
<div class="line"><span class="lineno">  147</span>        a = np.atleast_1d(a)</div>
<div class="line"><span class="lineno">  148</span>    <span class="keywordflow">if</span> b.ndim == 0:</div>
<div class="line"><span class="lineno">  149</span>        b = np.atleast_1d(b)</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordflow">return</span> a, b, outaxis</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa8f1f67d10a05713172b6a32169ed91" name="aaa8f1f67d10a05713172b6a32169ed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8f1f67d10a05713172b6a32169ed91">&#9670;&#160;</a></span>_chk_asarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._chk_asarray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  122</span><span class="keyword">def </span>_chk_asarray(a, axis):</div>
<div class="line"><span class="lineno">  123</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  124</span>        a = np.ravel(a)</div>
<div class="line"><span class="lineno">  125</span>        outaxis = 0</div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  127</span>        a = np.asarray(a)</div>
<div class="line"><span class="lineno">  128</span>        outaxis = axis</div>
<div class="line"><span class="lineno">  129</span> </div>
<div class="line"><span class="lineno">  130</span>    <span class="keywordflow">if</span> a.ndim == 0:</div>
<div class="line"><span class="lineno">  131</span>        a = np.atleast_1d(a)</div>
<div class="line"><span class="lineno">  132</span> </div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">return</span> a, outaxis</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4c0562f1c1cf6c8b5d6e22d5e78f7ec" name="ad4c0562f1c1cf6c8b5d6e22d5e78f7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c0562f1c1cf6c8b5d6e22d5e78f7ec">&#9670;&#160;</a></span>_compute_dminus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._compute_dminus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cdfvals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computes D- as used in the Kolmogorov-Smirnov test.

Parameters
----------
cdfvals : array_like
    Sorted array of CDF values between 0 and 1

Returns
-------
  Maximum distance of the CDF values above Uniform(0, 1)</pre> <div class="fragment"><div class="line"><span class="lineno"> 7334</span><span class="keyword">def </span>_compute_dminus(cdfvals):</div>
<div class="line"><span class="lineno"> 7335</span>    <span class="stringliteral">&quot;&quot;&quot;Computes D- as used in the Kolmogorov-Smirnov test.</span></div>
<div class="line"><span class="lineno"> 7336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7337</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7338</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7339</span><span class="stringliteral">    cdfvals : array_like</span></div>
<div class="line"><span class="lineno"> 7340</span><span class="stringliteral">        Sorted array of CDF values between 0 and 1</span></div>
<div class="line"><span class="lineno"> 7341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7342</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7343</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7344</span><span class="stringliteral">      Maximum distance of the CDF values above Uniform(0, 1)</span></div>
<div class="line"><span class="lineno"> 7345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7346</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7347</span>    n = len(cdfvals)</div>
<div class="line"><span class="lineno"> 7348</span>    <span class="keywordflow">return</span> (cdfvals - np.arange(0.0, n)/n).max()</div>
<div class="line"><span class="lineno"> 7349</span> </div>
<div class="line"><span class="lineno"> 7350</span> </div>
<div class="line"><span class="lineno"> 7351</span><span class="preprocessor">@_rename_parameter(&quot;mode&quot;, &quot;method&quot;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e3ec19a2c40626858eb6d1686214675" name="a1e3ec19a2c40626858eb6d1686214675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3ec19a2c40626858eb6d1686214675">&#9670;&#160;</a></span>_compute_dplus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._compute_dplus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cdfvals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computes D+ as used in the Kolmogorov-Smirnov test.

Parameters
----------
cdfvals : array_like
    Sorted array of CDF values between 0 and 1

Returns
-------
  Maximum distance of the CDF values below Uniform(0, 1)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 7318</span><span class="keyword">def </span>_compute_dplus(cdfvals):</div>
<div class="line"><span class="lineno"> 7319</span>    <span class="stringliteral">&quot;&quot;&quot;Computes D+ as used in the Kolmogorov-Smirnov test.</span></div>
<div class="line"><span class="lineno"> 7320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7321</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7322</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7323</span><span class="stringliteral">    cdfvals : array_like</span></div>
<div class="line"><span class="lineno"> 7324</span><span class="stringliteral">        Sorted array of CDF values between 0 and 1</span></div>
<div class="line"><span class="lineno"> 7325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7326</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7327</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7328</span><span class="stringliteral">      Maximum distance of the CDF values below Uniform(0, 1)</span></div>
<div class="line"><span class="lineno"> 7329</span><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7330</span>    n = len(cdfvals)</div>
<div class="line"><span class="lineno"> 7331</span>    <span class="keywordflow">return</span> (np.arange(1.0, n + 1) / n - cdfvals).max()</div>
<div class="line"><span class="lineno"> 7332</span> </div>
<div class="line"><span class="lineno"> 7333</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8b7cadb3896a61b502dcc260b808ddb" name="ae8b7cadb3896a61b502dcc260b808ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b7cadb3896a61b502dcc260b808ddb">&#9670;&#160;</a></span>_compute_prob_outside_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._compute_prob_outside_square </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the proportion of paths that pass outside the two diagonal lines.

Parameters
----------
n : integer
    n &gt; 0
h : integer
    0 &lt;= h &lt;= n

Returns
-------
p : float
    The proportion of paths that pass outside the lines x-y = +/-h.</pre> <div class="fragment"><div class="line"><span class="lineno"> 7498</span><span class="keyword">def </span>_compute_prob_outside_square(n, h):</div>
<div class="line"><span class="lineno"> 7499</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7500</span><span class="stringliteral">    Compute the proportion of paths that pass outside the two diagonal lines.</span></div>
<div class="line"><span class="lineno"> 7501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7502</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7503</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7504</span><span class="stringliteral">    n : integer</span></div>
<div class="line"><span class="lineno"> 7505</span><span class="stringliteral">        n &gt; 0</span></div>
<div class="line"><span class="lineno"> 7506</span><span class="stringliteral">    h : integer</span></div>
<div class="line"><span class="lineno"> 7507</span><span class="stringliteral">        0 &lt;= h &lt;= n</span></div>
<div class="line"><span class="lineno"> 7508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7509</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7510</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7511</span><span class="stringliteral">    p : float</span></div>
<div class="line"><span class="lineno"> 7512</span><span class="stringliteral">        The proportion of paths that pass outside the lines x-y = +/-h.</span></div>
<div class="line"><span class="lineno"> 7513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7514</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7515</span>    <span class="comment"># Compute Pr(D_{n,n} &gt;= h/n)</span></div>
<div class="line"><span class="lineno"> 7516</span>    <span class="comment"># Prob = 2 * ( binom(2n, n-h) - binom(2n, n-2a) + binom(2n, n-3a) - ... )</span></div>
<div class="line"><span class="lineno"> 7517</span>    <span class="comment"># / binom(2n, n)</span></div>
<div class="line"><span class="lineno"> 7518</span>    <span class="comment"># This formulation exhibits subtractive cancellation.</span></div>
<div class="line"><span class="lineno"> 7519</span>    <span class="comment"># Instead divide each term by binom(2n, n), then factor common terms</span></div>
<div class="line"><span class="lineno"> 7520</span>    <span class="comment"># and use a Horner-like algorithm</span></div>
<div class="line"><span class="lineno"> 7521</span>    <span class="comment"># P = 2 * A0 * (1 - A1*(1 - A2*(1 - A3*(1 - A4*(...)))))</span></div>
<div class="line"><span class="lineno"> 7522</span> </div>
<div class="line"><span class="lineno"> 7523</span>    P = 0.0</div>
<div class="line"><span class="lineno"> 7524</span>    k = int(np.floor(n / h))</div>
<div class="line"><span class="lineno"> 7525</span>    <span class="keywordflow">while</span> k &gt;= 0:</div>
<div class="line"><span class="lineno"> 7526</span>        p1 = 1.0</div>
<div class="line"><span class="lineno"> 7527</span>        <span class="comment"># Each of the Ai terms has numerator and denominator with</span></div>
<div class="line"><span class="lineno"> 7528</span>        <span class="comment"># h simple terms.</span></div>
<div class="line"><span class="lineno"> 7529</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(h):</div>
<div class="line"><span class="lineno"> 7530</span>            p1 = (n - k * h - j) * p1 / (n + k * h + j + 1)</div>
<div class="line"><span class="lineno"> 7531</span>        P = p1 * (1.0 - P)</div>
<div class="line"><span class="lineno"> 7532</span>        k -= 1</div>
<div class="line"><span class="lineno"> 7533</span>    <span class="keywordflow">return</span> 2 * P</div>
<div class="line"><span class="lineno"> 7534</span> </div>
<div class="line"><span class="lineno"> 7535</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a83387627658b0c178785dca865ecd929" name="a83387627658b0c178785dca865ecd929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83387627658b0c178785dca865ecd929">&#9670;&#160;</a></span>_compute_qth_percentile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._compute_qth_percentile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sorted_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>per</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolation_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2020</span><span class="keyword">def </span>_compute_qth_percentile(sorted_, per, interpolation_method, axis):</div>
<div class="line"><span class="lineno"> 2021</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isscalar(per):</div>
<div class="line"><span class="lineno"> 2022</span>        score = [_compute_qth_percentile(sorted_, i,</div>
<div class="line"><span class="lineno"> 2023</span>                                         interpolation_method, axis)</div>
<div class="line"><span class="lineno"> 2024</span>                 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> per]</div>
<div class="line"><span class="lineno"> 2025</span>        <span class="keywordflow">return</span> np.array(score)</div>
<div class="line"><span class="lineno"> 2026</span> </div>
<div class="line"><span class="lineno"> 2027</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (0 &lt;= per &lt;= 100):</div>
<div class="line"><span class="lineno"> 2028</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;percentile must be in the range [0, 100]&quot;</span>)</div>
<div class="line"><span class="lineno"> 2029</span> </div>
<div class="line"><span class="lineno"> 2030</span>    indexer = [slice(<span class="keywordtype">None</span>)] * sorted_.ndim</div>
<div class="line"><span class="lineno"> 2031</span>    idx = per / 100. * (sorted_.shape[axis] - 1)</div>
<div class="line"><span class="lineno"> 2032</span> </div>
<div class="line"><span class="lineno"> 2033</span>    <span class="keywordflow">if</span> int(idx) != idx:</div>
<div class="line"><span class="lineno"> 2034</span>        <span class="comment"># round fractional indices according to interpolation method</span></div>
<div class="line"><span class="lineno"> 2035</span>        <span class="keywordflow">if</span> interpolation_method == <span class="stringliteral">&#39;lower&#39;</span>:</div>
<div class="line"><span class="lineno"> 2036</span>            idx = int(np.floor(idx))</div>
<div class="line"><span class="lineno"> 2037</span>        <span class="keywordflow">elif</span> interpolation_method == <span class="stringliteral">&#39;higher&#39;</span>:</div>
<div class="line"><span class="lineno"> 2038</span>            idx = int(np.ceil(idx))</div>
<div class="line"><span class="lineno"> 2039</span>        <span class="keywordflow">elif</span> interpolation_method == <span class="stringliteral">&#39;fraction&#39;</span>:</div>
<div class="line"><span class="lineno"> 2040</span>            <span class="keywordflow">pass</span>  <span class="comment"># keep idx as fraction and interpolate</span></div>
<div class="line"><span class="lineno"> 2041</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2042</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;interpolation_method can only be &#39;fraction&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 2043</span>                             <span class="stringliteral">&quot;&#39;lower&#39; or &#39;higher&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 2044</span> </div>
<div class="line"><span class="lineno"> 2045</span>    i = int(idx)</div>
<div class="line"><span class="lineno"> 2046</span>    <span class="keywordflow">if</span> i == idx:</div>
<div class="line"><span class="lineno"> 2047</span>        indexer[axis] = slice(i, i + 1)</div>
<div class="line"><span class="lineno"> 2048</span>        weights = array(1)</div>
<div class="line"><span class="lineno"> 2049</span>        sumval = 1.0</div>
<div class="line"><span class="lineno"> 2050</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2051</span>        indexer[axis] = slice(i, i + 2)</div>
<div class="line"><span class="lineno"> 2052</span>        j = i + 1</div>
<div class="line"><span class="lineno"> 2053</span>        weights = array([(j - idx), (idx - i)], float)</div>
<div class="line"><span class="lineno"> 2054</span>        wshape = [1] * sorted_.ndim</div>
<div class="line"><span class="lineno"> 2055</span>        wshape[axis] = 2</div>
<div class="line"><span class="lineno"> 2056</span>        weights.shape = wshape</div>
<div class="line"><span class="lineno"> 2057</span>        sumval = weights.sum()</div>
<div class="line"><span class="lineno"> 2058</span> </div>
<div class="line"><span class="lineno"> 2059</span>    <span class="comment"># Use np.add.reduce (== np.sum but a little faster) to coerce data type</span></div>
<div class="line"><span class="lineno"> 2060</span>    <span class="keywordflow">return</span> np.add.reduce(sorted_[tuple(indexer)] * weights, axis=axis) / sumval</div>
<div class="line"><span class="lineno"> 2061</span> </div>
<div class="line"><span class="lineno"> 2062</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a58e2338e05cdf4c8ce6c4a992fa0e557" name="a58e2338e05cdf4c8ce6c4a992fa0e557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e2338e05cdf4c8ce6c4a992fa0e557">&#9670;&#160;</a></span>_contains_nan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._contains_nan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_summation</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   86</span><span class="keyword">def </span>_contains_nan(a, nan_policy=&#39;propagate&#39;, use_summation=True):</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(a, np.ndarray):</div>
<div class="line"><span class="lineno">   88</span>        use_summation = <span class="keyword">False</span>  <span class="comment"># some array_likes ignore nans (e.g. pandas)</span></div>
<div class="line"><span class="lineno">   89</span>    policies = [<span class="stringliteral">&#39;propagate&#39;</span>, <span class="stringliteral">&#39;raise&#39;</span>, <span class="stringliteral">&#39;omit&#39;</span>]</div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">if</span> nan_policy <span class="keywordflow">not</span> <span class="keywordflow">in</span> policies:</div>
<div class="line"><span class="lineno">   91</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;nan_policy must be one of {%s}&quot;</span> %</div>
<div class="line"><span class="lineno">   92</span>                         <span class="stringliteral">&#39;, &#39;</span>.join(<span class="stringliteral">&quot;&#39;%s&#39;&quot;</span> % s <span class="keywordflow">for</span> s <span class="keywordflow">in</span> policies))</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">   94</span>        <span class="comment"># The summation method avoids creating a (potentially huge) array.</span></div>
<div class="line"><span class="lineno">   95</span>        <span class="comment"># But, it will set contains_nan to True for (e.g.) [-inf, ..., +inf].</span></div>
<div class="line"><span class="lineno">   96</span>        <span class="comment"># If this is undesirable, set use_summation to False instead.</span></div>
<div class="line"><span class="lineno">   97</span>        <span class="keywordflow">if</span> use_summation:</div>
<div class="line"><span class="lineno">   98</span>            <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>, over=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno">   99</span>                contains_nan = np.isnan(np.sum(a))</div>
<div class="line"><span class="lineno">  100</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  101</span>            contains_nan = np.isnan(a).any()</div>
<div class="line"><span class="lineno">  102</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  103</span>        <span class="comment"># This can happen when attempting to sum things which are not</span></div>
<div class="line"><span class="lineno">  104</span>        <span class="comment"># numbers (e.g. as in the function `mode`). Try an alternative method:</span></div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  106</span>            contains_nan = np.any(np.isnan(a))</div>
<div class="line"><span class="lineno">  107</span>        <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  108</span>            <span class="comment"># Don&#39;t know what to do. Fall back to omitting nan values and</span></div>
<div class="line"><span class="lineno">  109</span>            <span class="comment"># issue a warning.</span></div>
<div class="line"><span class="lineno">  110</span>            contains_nan = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  111</span>            nan_policy = <span class="stringliteral">&#39;omit&#39;</span></div>
<div class="line"><span class="lineno">  112</span>            warnings.warn(<span class="stringliteral">&quot;The input array could not be properly &quot;</span></div>
<div class="line"><span class="lineno">  113</span>                          <span class="stringliteral">&quot;checked for nan values. nan values &quot;</span></div>
<div class="line"><span class="lineno">  114</span>                          <span class="stringliteral">&quot;will be ignored.&quot;</span>, RuntimeWarning)</div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;raise&#39;</span>:</div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The input contains nan values&quot;</span>)</div>
<div class="line"><span class="lineno">  118</span> </div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">return</span> contains_nan, nan_policy</div>
<div class="line"><span class="lineno">  120</span> </div>
<div class="line"><span class="lineno">  121</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ee99b9e592bd060aa2218c14a26081b" name="a0ee99b9e592bd060aa2218c14a26081b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee99b9e592bd060aa2218c14a26081b">&#9670;&#160;</a></span>_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Count the number of non-masked elements of an array.

This function behaves like `np.ma.count`, but is much faster
for ndarrays.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6932</span><span class="keyword">def </span>_count(a, axis=None):</div>
<div class="line"><span class="lineno"> 6933</span>    <span class="stringliteral">&quot;&quot;&quot;Count the number of non-masked elements of an array.</span></div>
<div class="line"><span class="lineno"> 6934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6935</span><span class="stringliteral">    This function behaves like `np.ma.count`, but is much faster</span></div>
<div class="line"><span class="lineno"> 6936</span><span class="stringliteral">    for ndarrays.</span></div>
<div class="line"><span class="lineno"> 6937</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6938</span>    <span class="keywordflow">if</span> hasattr(a, <span class="stringliteral">&#39;count&#39;</span>):</div>
<div class="line"><span class="lineno"> 6939</span>        num = a.count(axis=axis)</div>
<div class="line"><span class="lineno"> 6940</span>        <span class="keywordflow">if</span> isinstance(num, np.ndarray) <span class="keywordflow">and</span> num.ndim == 0:</div>
<div class="line"><span class="lineno"> 6941</span>            <span class="comment"># In some cases, the `count` method returns a scalar array (e.g.</span></div>
<div class="line"><span class="lineno"> 6942</span>            <span class="comment"># np.array(3)), but we want a plain integer.</span></div>
<div class="line"><span class="lineno"> 6943</span>            num = int(num)</div>
<div class="line"><span class="lineno"> 6944</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6945</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6946</span>            num = a.size</div>
<div class="line"><span class="lineno"> 6947</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6948</span>            num = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6949</span>    <span class="keywordflow">return</span> num</div>
<div class="line"><span class="lineno"> 6950</span> </div>
<div class="line"><span class="lineno"> 6951</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7203aa48462f055fd04fbfc629597002" name="a7203aa48462f055fd04fbfc629597002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7203aa48462f055fd04fbfc629597002">&#9670;&#160;</a></span>_count_paths_outside_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._count_paths_outside_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Count the number of paths that pass outside the specified diagonal.

Parameters
----------
m : integer
    m &gt; 0
n : integer
    n &gt; 0
g : integer
    g is greatest common divisor of m and n
h : integer
    0 &lt;= h &lt;= lcm(m,n)

Returns
-------
p : float
    The number of paths that go low.
    The calculation may overflow - check for a finite answer.

Raises
------
FloatingPointError: Raised if the intermediate computation goes outside
the range of a float.

Notes
-----
Count the integer lattice paths from (0, 0) to (m, n), which at some
point (x, y) along the path, satisfy:
  m*y &lt;= n*x - h*g
The paths make steps of size +1 in either positive x or positive y
directions.

We generally follow Hodges' treatment of Drion/Gnedenko/Korolyuk.
Hodges, J.L. Jr.,
"The Significance Probability of the Smirnov Two-Sample Test,"
Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.</pre> <div class="fragment"><div class="line"><span class="lineno"> 7536</span><span class="keyword">def </span>_count_paths_outside_method(m, n, g, h):</div>
<div class="line"><span class="lineno"> 7537</span>    <span class="stringliteral">&quot;&quot;&quot;Count the number of paths that pass outside the specified diagonal.</span></div>
<div class="line"><span class="lineno"> 7538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7539</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7540</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7541</span><span class="stringliteral">    m : integer</span></div>
<div class="line"><span class="lineno"> 7542</span><span class="stringliteral">        m &gt; 0</span></div>
<div class="line"><span class="lineno"> 7543</span><span class="stringliteral">    n : integer</span></div>
<div class="line"><span class="lineno"> 7544</span><span class="stringliteral">        n &gt; 0</span></div>
<div class="line"><span class="lineno"> 7545</span><span class="stringliteral">    g : integer</span></div>
<div class="line"><span class="lineno"> 7546</span><span class="stringliteral">        g is greatest common divisor of m and n</span></div>
<div class="line"><span class="lineno"> 7547</span><span class="stringliteral">    h : integer</span></div>
<div class="line"><span class="lineno"> 7548</span><span class="stringliteral">        0 &lt;= h &lt;= lcm(m,n)</span></div>
<div class="line"><span class="lineno"> 7549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7550</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7551</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7552</span><span class="stringliteral">    p : float</span></div>
<div class="line"><span class="lineno"> 7553</span><span class="stringliteral">        The number of paths that go low.</span></div>
<div class="line"><span class="lineno"> 7554</span><span class="stringliteral">        The calculation may overflow - check for a finite answer.</span></div>
<div class="line"><span class="lineno"> 7555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7556</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 7557</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 7558</span><span class="stringliteral">    FloatingPointError: Raised if the intermediate computation goes outside</span></div>
<div class="line"><span class="lineno"> 7559</span><span class="stringliteral">    the range of a float.</span></div>
<div class="line"><span class="lineno"> 7560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7561</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 7562</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 7563</span><span class="stringliteral">    Count the integer lattice paths from (0, 0) to (m, n), which at some</span></div>
<div class="line"><span class="lineno"> 7564</span><span class="stringliteral">    point (x, y) along the path, satisfy:</span></div>
<div class="line"><span class="lineno"> 7565</span><span class="stringliteral">      m*y &lt;= n*x - h*g</span></div>
<div class="line"><span class="lineno"> 7566</span><span class="stringliteral">    The paths make steps of size +1 in either positive x or positive y</span></div>
<div class="line"><span class="lineno"> 7567</span><span class="stringliteral">    directions.</span></div>
<div class="line"><span class="lineno"> 7568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7569</span><span class="stringliteral">    We generally follow Hodges&#39; treatment of Drion/Gnedenko/Korolyuk.</span></div>
<div class="line"><span class="lineno"> 7570</span><span class="stringliteral">    Hodges, J.L. Jr.,</span></div>
<div class="line"><span class="lineno"> 7571</span><span class="stringliteral">    &quot;The Significance Probability of the Smirnov Two-Sample Test,&quot;</span></div>
<div class="line"><span class="lineno"> 7572</span><span class="stringliteral">    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.</span></div>
<div class="line"><span class="lineno"> 7573</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7574</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7575</span>    <span class="comment"># Compute #paths which stay lower than x/m-y/n = h/lcm(m,n)</span></div>
<div class="line"><span class="lineno"> 7576</span>    <span class="comment"># B(x, y) = #{paths from (0,0) to (x,y) without</span></div>
<div class="line"><span class="lineno"> 7577</span>    <span class="comment">#             previously crossing the boundary}</span></div>
<div class="line"><span class="lineno"> 7578</span>    <span class="comment">#         = binom(x, y) - #{paths which already reached the boundary}</span></div>
<div class="line"><span class="lineno"> 7579</span>    <span class="comment"># Multiply by the number of path extensions going from (x, y) to (m, n)</span></div>
<div class="line"><span class="lineno"> 7580</span>    <span class="comment"># Sum.</span></div>
<div class="line"><span class="lineno"> 7581</span> </div>
<div class="line"><span class="lineno"> 7582</span>    <span class="comment"># Probability is symmetrical in m, n.  Computation below assumes m &gt;= n.</span></div>
<div class="line"><span class="lineno"> 7583</span>    <span class="keywordflow">if</span> m &lt; n:</div>
<div class="line"><span class="lineno"> 7584</span>        m, n = n, m</div>
<div class="line"><span class="lineno"> 7585</span>    mg = m // g</div>
<div class="line"><span class="lineno"> 7586</span>    ng = n // g</div>
<div class="line"><span class="lineno"> 7587</span> </div>
<div class="line"><span class="lineno"> 7588</span>    <span class="comment"># Not every x needs to be considered.</span></div>
<div class="line"><span class="lineno"> 7589</span>    <span class="comment"># xj holds the list of x values to be checked.</span></div>
<div class="line"><span class="lineno"> 7590</span>    <span class="comment"># Wherever n*x/m + ng*h crosses an integer</span></div>
<div class="line"><span class="lineno"> 7591</span>    lxj = n + (mg-h)//mg</div>
<div class="line"><span class="lineno"> 7592</span>    xj = [(h + mg * j + ng-1)//ng <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(lxj)]</div>
<div class="line"><span class="lineno"> 7593</span>    <span class="comment"># B is an array just holding a few values of B(x,y), the ones needed.</span></div>
<div class="line"><span class="lineno"> 7594</span>    <span class="comment"># B[j] == B(x_j, j)</span></div>
<div class="line"><span class="lineno"> 7595</span>    <span class="keywordflow">if</span> lxj == 0:</div>
<div class="line"><span class="lineno"> 7596</span>        <span class="keywordflow">return</span> np.round(special.binom(m + n, n))</div>
<div class="line"><span class="lineno"> 7597</span>    B = np.zeros(lxj)</div>
<div class="line"><span class="lineno"> 7598</span>    B[0] = 1</div>
<div class="line"><span class="lineno"> 7599</span>    <span class="comment"># Compute the B(x, y) terms</span></div>
<div class="line"><span class="lineno"> 7600</span>    <span class="comment"># The binomial coefficient is an integer, but special.binom()</span></div>
<div class="line"><span class="lineno"> 7601</span>    <span class="comment"># may return a float. Round it to the nearest integer.</span></div>
<div class="line"><span class="lineno"> 7602</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(1, lxj):</div>
<div class="line"><span class="lineno"> 7603</span>        Bj = np.round(special.binom(xj[j] + j, j))</div>
<div class="line"><span class="lineno"> 7604</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(Bj):</div>
<div class="line"><span class="lineno"> 7605</span>            <span class="keywordflow">raise</span> FloatingPointError()</div>
<div class="line"><span class="lineno"> 7606</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(j):</div>
<div class="line"><span class="lineno"> 7607</span>            bin = np.round(special.binom(xj[j] - xj[i] + j - i, j-i))</div>
<div class="line"><span class="lineno"> 7608</span>            Bj -= bin * B[i]</div>
<div class="line"><span class="lineno"> 7609</span>        B[j] = Bj</div>
<div class="line"><span class="lineno"> 7610</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(Bj):</div>
<div class="line"><span class="lineno"> 7611</span>            <span class="keywordflow">raise</span> FloatingPointError()</div>
<div class="line"><span class="lineno"> 7612</span>    <span class="comment"># Compute the number of path extensions...</span></div>
<div class="line"><span class="lineno"> 7613</span>    num_paths = 0</div>
<div class="line"><span class="lineno"> 7614</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(lxj):</div>
<div class="line"><span class="lineno"> 7615</span>        bin = np.round(special.binom((m-xj[j]) + (n - j), n-j))</div>
<div class="line"><span class="lineno"> 7616</span>        term = B[j] * bin</div>
<div class="line"><span class="lineno"> 7617</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isfinite(term):</div>
<div class="line"><span class="lineno"> 7618</span>            <span class="keywordflow">raise</span> FloatingPointError()</div>
<div class="line"><span class="lineno"> 7619</span>        num_paths += term</div>
<div class="line"><span class="lineno"> 7620</span>    <span class="keywordflow">return</span> np.round(num_paths)</div>
<div class="line"><span class="lineno"> 7621</span> </div>
<div class="line"><span class="lineno"> 7622</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e276e13ea5d7dfc68a7ccb7a5dee6dd" name="a2e276e13ea5d7dfc68a7ccb7a5dee6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e276e13ea5d7dfc68a7ccb7a5dee6dd">&#9670;&#160;</a></span>_create_f_oneway_nan_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._create_f_oneway_nan_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">This is a helper function for f_oneway for creating the return values
in certain degenerate conditions.  It creates return values that are
all nan with the appropriate shape for the given `shape` and `axis`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3703</span><span class="keyword">def </span>_create_f_oneway_nan_result(shape, axis):</div>
<div class="line"><span class="lineno"> 3704</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3705</span><span class="stringliteral">    This is a helper function for f_oneway for creating the return values</span></div>
<div class="line"><span class="lineno"> 3706</span><span class="stringliteral">    in certain degenerate conditions.  It creates return values that are</span></div>
<div class="line"><span class="lineno"> 3707</span><span class="stringliteral">    all nan with the appropriate shape for the given `shape` and `axis`.</span></div>
<div class="line"><span class="lineno"> 3708</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3709</span>    axis = np.core.multiarray.normalize_axis_index(axis, len(shape))</div>
<div class="line"><span class="lineno"> 3710</span>    shp = shape[:axis] + shape[axis+1:]</div>
<div class="line"><span class="lineno"> 3711</span>    <span class="keywordflow">if</span> shp == ():</div>
<div class="line"><span class="lineno"> 3712</span>        f = np.nan</div>
<div class="line"><span class="lineno"> 3713</span>        prob = np.nan</div>
<div class="line"><span class="lineno"> 3714</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3715</span>        f = np.full(shp, fill_value=np.nan)</div>
<div class="line"><span class="lineno"> 3716</span>        prob = f.copy()</div>
<div class="line"><span class="lineno"> 3717</span>    <span class="keywordflow">return</span> F_onewayResult(f, prob)</div>
<div class="line"><span class="lineno"> 3718</span> </div>
<div class="line"><span class="lineno"> 3719</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa19d5534576fc2aed9f2cf56fd9b8d65" name="aa19d5534576fc2aed9f2cf56fd9b8d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19d5534576fc2aed9f2cf56fd9b8d65">&#9670;&#160;</a></span>_equal_var_ttest_denom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._equal_var_ttest_denom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6135</span><span class="keyword">def </span>_equal_var_ttest_denom(v1, n1, v2, n2):</div>
<div class="line"><span class="lineno"> 6136</span>    df = n1 + n2 - 2.0</div>
<div class="line"><span class="lineno"> 6137</span>    svar = ((n1 - 1) * v1 + (n2 - 1) * v2) / df</div>
<div class="line"><span class="lineno"> 6138</span>    denom = np.sqrt(svar * (1.0 / n1 + 1.0 / n2))</div>
<div class="line"><span class="lineno"> 6139</span>    <span class="keywordflow">return</span> df, denom</div>
<div class="line"><span class="lineno"> 6140</span> </div>
<div class="line"><span class="lineno"> 6141</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac06697b36a6f3c2567d9e514a9147d59" name="ac06697b36a6f3c2567d9e514a9147d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06697b36a6f3c2567d9e514a9147d59">&#9670;&#160;</a></span>_euclidean_dist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._euclidean_dist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5484</span><span class="keyword">def </span>_euclidean_dist(x):</div>
<div class="line"><span class="lineno"> 5485</span>    <span class="keywordflow">return</span> cdist(x, x)</div>
<div class="line"><span class="lineno"> 5486</span> </div>
<div class="line"><span class="lineno"> 5487</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ace6e79d444d643e8f8c69359dd2e7a76" name="ace6e79d444d643e8f8c69359dd2e7a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6e79d444d643e8f8c69359dd2e7a76">&#9670;&#160;</a></span>_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._first </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return arr[..., 0:1, ...] where 0:1 is in the `axis` position.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3720</span><span class="keyword">def </span>_first(arr, axis):</div>
<div class="line"><span class="lineno"> 3721</span>    <span class="stringliteral">&quot;&quot;&quot;Return arr[..., 0:1, ...] where 0:1 is in the `axis` position.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3722</span>    <span class="keywordflow">return</span> np.take_along_axis(arr, np.array(0, ndmin=arr.ndim), axis)</div>
<div class="line"><span class="lineno"> 3723</span> </div>
<div class="line"><span class="lineno"> 3724</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2686bf2f43feeb0760374ba16a87dd49" name="a2686bf2f43feeb0760374ba16a87dd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2686bf2f43feeb0760374ba16a87dd49">&#9670;&#160;</a></span>_get_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._get_len </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6792</span><span class="keyword">def </span>_get_len(a, axis, msg):</div>
<div class="line"><span class="lineno"> 6793</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 6794</span>        n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6795</span>    <span class="keywordflow">except</span> IndexError:</div>
<div class="line"><span class="lineno"> 6796</span>        <span class="keywordflow">raise</span> np.AxisError(axis, a.ndim, msg) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6797</span>    <span class="keywordflow">return</span> n</div>
<div class="line"><span class="lineno"> 6798</span> </div>
<div class="line"><span class="lineno"> 6799</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae82eb3635bf1ad54e142971200bf9710" name="ae82eb3635bf1ad54e142971200bf9710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82eb3635bf1ad54e142971200bf9710">&#9670;&#160;</a></span>_histogram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._histogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numbins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaultlimits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>printextras</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create a histogram.

Separate the range into several bins and return the number of instances
in each bin.

Parameters
----------
a : array_like
    Array of scores which will be put into bins.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultlimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0
printextras : bool, optional
    If True, if there are extra points (i.e. the points that fall outside
    the bin limits) a warning is raised saying how many of those points
    there are.  Default is False.

Returns
-------
count : ndarray
    Number of points (or sum of weights) in each bin.
lowerlimit : float
    Lowest value of histogram, the lower limit of the first bin.
binsize : float
    The size of the bins (all bins have the same size).
extrapoints : int
    The number of points outside the range of the histogram.

See Also
--------
numpy.histogram

Notes
-----
This histogram is based on numpy's histogram but has a larger range by
default if default limits is not set.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2230</span>               printextras=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 2231</span>    <span class="stringliteral">&quot;&quot;&quot;Create a histogram.</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">    Separate the range into several bins and return the number of instances</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">    in each bin.</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">        Array of scores which will be put into bins.</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral">    numbins : int, optional</span></div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">        The number of bins to use for the histogram. Default is 10.</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">    defaultlimits : tuple (lower, upper), optional</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">        The lower and upper values for the range of the histogram.</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">        If no value is given, a range slightly larger than the range of the</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral">        values in a is used. Specifically ``(a.min() - s, a.max() + s)``,</span></div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">        The weights for each value in `a`. Default is None, which gives each</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral">        value a weight of 1.0</span></div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral">    printextras : bool, optional</span></div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral">        If True, if there are extra points (i.e. the points that fall outside</span></div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral">        the bin limits) a warning is raised saying how many of those points</span></div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">        there are.  Default is False.</span></div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral">    count : ndarray</span></div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">        Number of points (or sum of weights) in each bin.</span></div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral">    lowerlimit : float</span></div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">        Lowest value of histogram, the lower limit of the first bin.</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral">    binsize : float</span></div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral">        The size of the bins (all bins have the same size).</span></div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral">    extrapoints : int</span></div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral">        The number of points outside the range of the histogram.</span></div>
<div class="line"><span class="lineno"> 2265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2266</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2267</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2268</span><span class="stringliteral">    numpy.histogram</span></div>
<div class="line"><span class="lineno"> 2269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2270</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2271</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2272</span><span class="stringliteral">    This histogram is based on numpy&#39;s histogram but has a larger range by</span></div>
<div class="line"><span class="lineno"> 2273</span><span class="stringliteral">    default if default limits is not set.</span></div>
<div class="line"><span class="lineno"> 2274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2276</span>    a = np.ravel(a)</div>
<div class="line"><span class="lineno"> 2277</span>    <span class="keywordflow">if</span> defaultlimits <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2278</span>        <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 2279</span>            <span class="comment"># handle empty arrays. Undetermined range, so use 0-1.</span></div>
<div class="line"><span class="lineno"> 2280</span>            defaultlimits = (0, 1)</div>
<div class="line"><span class="lineno"> 2281</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2282</span>            <span class="comment"># no range given, so use values in `a`</span></div>
<div class="line"><span class="lineno"> 2283</span>            data_min = a.min()</div>
<div class="line"><span class="lineno"> 2284</span>            data_max = a.max()</div>
<div class="line"><span class="lineno"> 2285</span>            <span class="comment"># Have bins extend past min and max values slightly</span></div>
<div class="line"><span class="lineno"> 2286</span>            s = (data_max - data_min) / (2. * (numbins - 1.))</div>
<div class="line"><span class="lineno"> 2287</span>            defaultlimits = (data_min - s, data_max + s)</div>
<div class="line"><span class="lineno"> 2288</span> </div>
<div class="line"><span class="lineno"> 2289</span>    <span class="comment"># use numpy&#39;s histogram method to compute bins</span></div>
<div class="line"><span class="lineno"> 2290</span>    hist, bin_edges = np.histogram(a, bins=numbins, range=defaultlimits,</div>
<div class="line"><span class="lineno"> 2291</span>                                   weights=weights)</div>
<div class="line"><span class="lineno"> 2292</span>    <span class="comment"># hist are not always floats, convert to keep with old output</span></div>
<div class="line"><span class="lineno"> 2293</span>    hist = np.array(hist, dtype=float)</div>
<div class="line"><span class="lineno"> 2294</span>    <span class="comment"># fixed width for bins is assumed, as numpy&#39;s histogram gives</span></div>
<div class="line"><span class="lineno"> 2295</span>    <span class="comment"># fixed width bins for int values for &#39;bins&#39;</span></div>
<div class="line"><span class="lineno"> 2296</span>    binsize = bin_edges[1] - bin_edges[0]</div>
<div class="line"><span class="lineno"> 2297</span>    <span class="comment"># calculate number of extra points</span></div>
<div class="line"><span class="lineno"> 2298</span>    extrapoints = len([v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> a</div>
<div class="line"><span class="lineno"> 2299</span>                       <span class="keywordflow">if</span> defaultlimits[0] &gt; v <span class="keywordflow">or</span> v &gt; defaultlimits[1]])</div>
<div class="line"><span class="lineno"> 2300</span>    <span class="keywordflow">if</span> extrapoints &gt; 0 <span class="keywordflow">and</span> printextras:</div>
<div class="line"><span class="lineno"> 2301</span>        warnings.warn(<span class="stringliteral">&quot;Points outside given histogram range = %s&quot;</span></div>
<div class="line"><span class="lineno"> 2302</span>                      % extrapoints)</div>
<div class="line"><span class="lineno"> 2303</span> </div>
<div class="line"><span class="lineno"> 2304</span>    <span class="keywordflow">return</span> HistogramResult(hist, defaultlimits[0], binsize, extrapoints)</div>
<div class="line"><span class="lineno"> 2305</span> </div>
<div class="line"><span class="lineno"> 2306</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5bd539f56514ee1098218fdfb869cea0" name="a5bd539f56514ee1098218fdfb869cea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd539f56514ee1098218fdfb869cea0">&#9670;&#160;</a></span>_isconst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._isconst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check if all values in x are the same.  nans are ignored.

x must be a 1d array.

The return value is a 1d array with length 1, so it can be used
in np.apply_along_axis.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2621</span><span class="keyword">def </span>_isconst(x):</div>
<div class="line"><span class="lineno"> 2622</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2623</span><span class="stringliteral">    Check if all values in x are the same.  nans are ignored.</span></div>
<div class="line"><span class="lineno"> 2624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2625</span><span class="stringliteral">    x must be a 1d array.</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral">    The return value is a 1d array with length 1, so it can be used</span></div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral">    in np.apply_along_axis.</span></div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2630</span>    y = x[~np.isnan(x)]</div>
<div class="line"><span class="lineno"> 2631</span>    <span class="keywordflow">if</span> y.size == 0:</div>
<div class="line"><span class="lineno"> 2632</span>        <span class="keywordflow">return</span> np.array([<span class="keyword">True</span>])</div>
<div class="line"><span class="lineno"> 2633</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2634</span>        <span class="keywordflow">return</span> (y[0] == y).all(keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2635</span> </div>
<div class="line"><span class="lineno"> 2636</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7ba35ca822e6023cb6ae415de882378" name="aa7ba35ca822e6023cb6ae415de882378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ba35ca822e6023cb6ae415de882378">&#9670;&#160;</a></span>_m_broadcast_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._m_broadcast_to </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6952</span><span class="keyword">def </span>_m_broadcast_to(a, shape):</div>
<div class="line"><span class="lineno"> 6953</span>    <span class="keywordflow">if</span> np.ma.isMaskedArray(a):</div>
<div class="line"><span class="lineno"> 6954</span>        <span class="keywordflow">return</span> np.ma.masked_array(np.broadcast_to(a, shape),</div>
<div class="line"><span class="lineno"> 6955</span>                                  mask=np.broadcast_to(a.mask, shape))</div>
<div class="line"><span class="lineno"> 6956</span>    <span class="keywordflow">return</span> np.broadcast_to(a, shape, subok=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 6957</span> </div>
<div class="line"><span class="lineno"> 6958</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a12bcb107f34707282163dc34932921d5" name="a12bcb107f34707282163dc34932921d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bcb107f34707282163dc34932921d5">&#9670;&#160;</a></span>_mad_1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._mad_1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3209</span><span class="keyword">def </span>_mad_1d(x, center, nan_policy):</div>
<div class="line"><span class="lineno"> 3210</span>    <span class="comment"># Median absolute deviation for 1-d array x.</span></div>
<div class="line"><span class="lineno"> 3211</span>    <span class="comment"># This is a helper function for `median_abs_deviation`; it assumes its</span></div>
<div class="line"><span class="lineno"> 3212</span>    <span class="comment"># arguments have been validated already.  In particular,  x must be a</span></div>
<div class="line"><span class="lineno"> 3213</span>    <span class="comment"># 1-d numpy array, center must be callable, and if nan_policy is not</span></div>
<div class="line"><span class="lineno"> 3214</span>    <span class="comment"># &#39;propagate&#39;, it is assumed to be &#39;omit&#39;, because &#39;raise&#39; is handled</span></div>
<div class="line"><span class="lineno"> 3215</span>    <span class="comment"># in `median_abs_deviation`.</span></div>
<div class="line"><span class="lineno"> 3216</span>    <span class="comment"># No warning is generated if x is empty or all nan.</span></div>
<div class="line"><span class="lineno"> 3217</span>    isnan = np.isnan(x)</div>
<div class="line"><span class="lineno"> 3218</span>    <span class="keywordflow">if</span> isnan.any():</div>
<div class="line"><span class="lineno"> 3219</span>        <span class="keywordflow">if</span> nan_policy == <span class="stringliteral">&#39;propagate&#39;</span>:</div>
<div class="line"><span class="lineno"> 3220</span>            <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 3221</span>        x = x[~isnan]</div>
<div class="line"><span class="lineno"> 3222</span>    <span class="keywordflow">if</span> x.size == 0:</div>
<div class="line"><span class="lineno"> 3223</span>        <span class="comment"># MAD of an empty array is nan.</span></div>
<div class="line"><span class="lineno"> 3224</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 3225</span>    <span class="comment"># Edge cases have been handled, so do the basic MAD calculation.</span></div>
<div class="line"><span class="lineno"> 3226</span>    med = center(x)</div>
<div class="line"><span class="lineno"> 3227</span>    mad = np.median(np.abs(x - med))</div>
<div class="line"><span class="lineno"> 3228</span>    <span class="keywordflow">return</span> mad</div>
<div class="line"><span class="lineno"> 3229</span> </div>
<div class="line"><span class="lineno"> 3230</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aacd16dbbb70282cb051e7b9556d4737f" name="aacd16dbbb70282cb051e7b9556d4737f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd16dbbb70282cb051e7b9556d4737f">&#9670;&#160;</a></span>_mask_to_limits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._mask_to_limits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Mask an array for values outside of given limits.

This is primarily a utility function.

Parameters
----------
a : array
limits : (float or None, float or None)
    A tuple consisting of the (lower limit, upper limit).  Values in the
    input array less than the lower limit or greater than the upper limit
    will be masked out. None implies no limit.
inclusive : (bool, bool)
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to lower or upper are allowed.

Returns
-------
A MaskedArray.

Raises
------
A ValueError if there are no values within the given limits.</pre> <div class="fragment"><div class="line"><span class="lineno">  688</span><span class="keyword">def </span>_mask_to_limits(a, limits, inclusive):</div>
<div class="line"><span class="lineno">  689</span>    <span class="stringliteral">&quot;&quot;&quot;Mask an array for values outside of given limits.</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    This is primarily a utility function.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    a : array</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    limits : (float or None, float or None)</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        A tuple consisting of the (lower limit, upper limit).  Values in the</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        input array less than the lower limit or greater than the upper limit</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        will be masked out. None implies no limit.</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    inclusive : (bool, bool)</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        A tuple consisting of the (lower flag, upper flag).  These flags</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        determine whether values exactly equal to lower or upper are allowed.</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    A MaskedArray.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    A ValueError if there are no values within the given limits.</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  713</span>    lower_limit, upper_limit = limits</div>
<div class="line"><span class="lineno">  714</span>    lower_include, upper_include = inclusive</div>
<div class="line"><span class="lineno">  715</span>    am = ma.MaskedArray(a)</div>
<div class="line"><span class="lineno">  716</span>    <span class="keywordflow">if</span> lower_limit <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  717</span>        <span class="keywordflow">if</span> lower_include:</div>
<div class="line"><span class="lineno">  718</span>            am = ma.masked_less(am, lower_limit)</div>
<div class="line"><span class="lineno">  719</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  720</span>            am = ma.masked_less_equal(am, lower_limit)</div>
<div class="line"><span class="lineno">  721</span> </div>
<div class="line"><span class="lineno">  722</span>    <span class="keywordflow">if</span> upper_limit <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  723</span>        <span class="keywordflow">if</span> upper_include:</div>
<div class="line"><span class="lineno">  724</span>            am = ma.masked_greater(am, upper_limit)</div>
<div class="line"><span class="lineno">  725</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  726</span>            am = ma.masked_greater_equal(am, upper_limit)</div>
<div class="line"><span class="lineno">  727</span> </div>
<div class="line"><span class="lineno">  728</span>    <span class="keywordflow">if</span> am.count() == 0:</div>
<div class="line"><span class="lineno">  729</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;No array values within given limits&quot;</span>)</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span>    <span class="keywordflow">return</span> am</div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="line"><span class="lineno">  733</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a16b0aaa0ec15fefa642eb07a77dcf117" name="a16b0aaa0ec15fefa642eb07a77dcf117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b0aaa0ec15fefa642eb07a77dcf117">&#9670;&#160;</a></span>_mgc_stat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._mgc_stat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function that calculates the MGC stat. See above for use.

Parameters
----------
distx, disty : ndarray
`distx` and `disty` have shapes `(n, p)` and `(n, q)` or
`(n, n)` and `(n, n)`
if distance matrices.

Returns
-------
stat : float
The sample MGC test statistic within `[-1, 1]`.
stat_dict : dict
Contains additional useful additional returns containing the following
keys:

- stat_mgc_map : ndarray
MGC-map of the statistics.
- opt_scale : (float, float)
The estimated optimal scale as a `(x, y)` pair.</pre> <div class="fragment"><div class="line"><span class="lineno"> 5778</span><span class="keyword">def </span>_mgc_stat(distx, disty):</div>
<div class="line"><span class="lineno"> 5779</span>    <span class="stringliteral">r&quot;&quot;&quot;Helper function that calculates the MGC stat. See above for use.</span></div>
<div class="line"><span class="lineno"> 5780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5781</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5782</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5783</span><span class="stringliteral">    distx, disty : ndarray</span></div>
<div class="line"><span class="lineno"> 5784</span><span class="stringliteral">        `distx` and `disty` have shapes `(n, p)` and `(n, q)` or</span></div>
<div class="line"><span class="lineno"> 5785</span><span class="stringliteral">        `(n, n)` and `(n, n)`</span></div>
<div class="line"><span class="lineno"> 5786</span><span class="stringliteral">        if distance matrices.</span></div>
<div class="line"><span class="lineno"> 5787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5788</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5789</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5790</span><span class="stringliteral">    stat : float</span></div>
<div class="line"><span class="lineno"> 5791</span><span class="stringliteral">        The sample MGC test statistic within `[-1, 1]`.</span></div>
<div class="line"><span class="lineno"> 5792</span><span class="stringliteral">    stat_dict : dict</span></div>
<div class="line"><span class="lineno"> 5793</span><span class="stringliteral">        Contains additional useful additional returns containing the following</span></div>
<div class="line"><span class="lineno"> 5794</span><span class="stringliteral">        keys:</span></div>
<div class="line"><span class="lineno"> 5795</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5796</span><span class="stringliteral">            - stat_mgc_map : ndarray</span></div>
<div class="line"><span class="lineno"> 5797</span><span class="stringliteral">                MGC-map of the statistics.</span></div>
<div class="line"><span class="lineno"> 5798</span><span class="stringliteral">            - opt_scale : (float, float)</span></div>
<div class="line"><span class="lineno"> 5799</span><span class="stringliteral">                The estimated optimal scale as a `(x, y)` pair.</span></div>
<div class="line"><span class="lineno"> 5800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5801</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5802</span>    <span class="comment"># calculate MGC map and optimal scale</span></div>
<div class="line"><span class="lineno"> 5803</span>    stat_mgc_map = _local_correlations(distx, disty, global_corr=<span class="stringliteral">&#39;mgc&#39;</span>)</div>
<div class="line"><span class="lineno"> 5804</span> </div>
<div class="line"><span class="lineno"> 5805</span>    n, m = stat_mgc_map.shape</div>
<div class="line"><span class="lineno"> 5806</span>    <span class="keywordflow">if</span> m == 1 <span class="keywordflow">or</span> n == 1:</div>
<div class="line"><span class="lineno"> 5807</span>        <span class="comment"># the global scale at is the statistic calculated at maximial nearest</span></div>
<div class="line"><span class="lineno"> 5808</span>        <span class="comment"># neighbors. There is not enough local scale to search over, so</span></div>
<div class="line"><span class="lineno"> 5809</span>        <span class="comment"># default to global scale</span></div>
<div class="line"><span class="lineno"> 5810</span>        stat = stat_mgc_map[m - 1][n - 1]</div>
<div class="line"><span class="lineno"> 5811</span>        opt_scale = m * n</div>
<div class="line"><span class="lineno"> 5812</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5813</span>        samp_size = len(distx) - 1</div>
<div class="line"><span class="lineno"> 5814</span> </div>
<div class="line"><span class="lineno"> 5815</span>        <span class="comment"># threshold to find connected region of significant local correlations</span></div>
<div class="line"><span class="lineno"> 5816</span>        sig_connect = _threshold_mgc_map(stat_mgc_map, samp_size)</div>
<div class="line"><span class="lineno"> 5817</span> </div>
<div class="line"><span class="lineno"> 5818</span>        <span class="comment"># maximum within the significant region</span></div>
<div class="line"><span class="lineno"> 5819</span>        stat, opt_scale = _smooth_mgc_map(sig_connect, stat_mgc_map)</div>
<div class="line"><span class="lineno"> 5820</span> </div>
<div class="line"><span class="lineno"> 5821</span>    stat_dict = {<span class="stringliteral">&quot;stat_mgc_map&quot;</span>: stat_mgc_map,</div>
<div class="line"><span class="lineno"> 5822</span>                 <span class="stringliteral">&quot;opt_scale&quot;</span>: opt_scale}</div>
<div class="line"><span class="lineno"> 5823</span> </div>
<div class="line"><span class="lineno"> 5824</span>    <span class="keywordflow">return</span> stat, stat_dict</div>
<div class="line"><span class="lineno"> 5825</span> </div>
<div class="line"><span class="lineno"> 5826</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4db5b73a9a9ff1f4d6843b2d6687e4e7" name="a4db5b73a9a9ff1f4d6843b2d6687e4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db5b73a9a9ff1f4d6843b2d6687e4e7">&#9670;&#160;</a></span>_moment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._moment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>moment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>mean</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1188</span><span class="keyword">def </span>_moment(a, moment, axis, *, mean=None):</div>
<div class="line"><span class="lineno"> 1189</span>    <span class="keywordflow">if</span> np.abs(moment - np.round(moment)) &gt; 0:</div>
<div class="line"><span class="lineno"> 1190</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All moment parameters must be integers&quot;</span>)</div>
<div class="line"><span class="lineno"> 1191</span> </div>
<div class="line"><span class="lineno"> 1192</span>    <span class="comment"># moment of empty array is the same regardless of order</span></div>
<div class="line"><span class="lineno"> 1193</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 1194</span>        <span class="keywordflow">return</span> np.mean(a, axis=axis)</div>
<div class="line"><span class="lineno"> 1195</span> </div>
<div class="line"><span class="lineno"> 1196</span>    <span class="keywordflow">if</span> moment == 0 <span class="keywordflow">or</span> moment == 1:</div>
<div class="line"><span class="lineno"> 1197</span>        <span class="comment"># By definition the zeroth moment about the mean is 1, and the first</span></div>
<div class="line"><span class="lineno"> 1198</span>        <span class="comment"># moment is 0.</span></div>
<div class="line"><span class="lineno"> 1199</span>        shape = list(a.shape)</div>
<div class="line"><span class="lineno"> 1200</span>        del shape[axis]</div>
<div class="line"><span class="lineno"> 1201</span>        dtype = a.dtype.type <span class="keywordflow">if</span> a.dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&#39;fc&#39;</span> <span class="keywordflow">else</span> np.float64</div>
<div class="line"><span class="lineno"> 1202</span> </div>
<div class="line"><span class="lineno"> 1203</span>        <span class="keywordflow">if</span> len(shape) == 0:</div>
<div class="line"><span class="lineno"> 1204</span>            <span class="keywordflow">return</span> <a class="code hl_namespace" href="namespacedtype.html">dtype</a>(1.0 <span class="keywordflow">if</span> moment == 0 <span class="keywordflow">else</span> 0.0)</div>
<div class="line"><span class="lineno"> 1205</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1206</span>            <span class="keywordflow">return</span> (np.ones(shape, dtype=dtype) <span class="keywordflow">if</span> moment == 0</div>
<div class="line"><span class="lineno"> 1207</span>                    <span class="keywordflow">else</span> np.zeros(shape, dtype=dtype))</div>
<div class="line"><span class="lineno"> 1208</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1209</span>        <span class="comment"># Exponentiation by squares: form exponent sequence</span></div>
<div class="line"><span class="lineno"> 1210</span>        n_list = [moment]</div>
<div class="line"><span class="lineno"> 1211</span>        current_n = moment</div>
<div class="line"><span class="lineno"> 1212</span>        <span class="keywordflow">while</span> current_n &gt; 2:</div>
<div class="line"><span class="lineno"> 1213</span>            <span class="keywordflow">if</span> current_n % 2:</div>
<div class="line"><span class="lineno"> 1214</span>                current_n = (current_n - 1) / 2</div>
<div class="line"><span class="lineno"> 1215</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1216</span>                current_n /= 2</div>
<div class="line"><span class="lineno"> 1217</span>            n_list.append(current_n)</div>
<div class="line"><span class="lineno"> 1218</span> </div>
<div class="line"><span class="lineno"> 1219</span>        <span class="comment"># Starting point for exponentiation by squares</span></div>
<div class="line"><span class="lineno"> 1220</span>        mean = a.mean(axis, keepdims=<span class="keyword">True</span>) <span class="keywordflow">if</span> mean <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> mean</div>
<div class="line"><span class="lineno"> 1221</span>        a_zero_mean = a - mean</div>
<div class="line"><span class="lineno"> 1222</span> </div>
<div class="line"><span class="lineno"> 1223</span>        eps = np.finfo(a_zero_mean.dtype).resolution * 10</div>
<div class="line"><span class="lineno"> 1224</span>        <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>, invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 1225</span>            rel_diff = np.max(np.abs(a_zero_mean), axis=axis,</div>
<div class="line"><span class="lineno"> 1226</span>                              keepdims=<span class="keyword">True</span>) / np.abs(mean)</div>
<div class="line"><span class="lineno"> 1227</span>        <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 1228</span>            precision_loss = np.any(rel_diff &lt; eps)</div>
<div class="line"><span class="lineno"> 1229</span>        <span class="keywordflow">if</span> precision_loss:</div>
<div class="line"><span class="lineno"> 1230</span>            message = (<span class="stringliteral">&quot;Precision loss occurred in moment calculation due to &quot;</span></div>
<div class="line"><span class="lineno"> 1231</span>                       <span class="stringliteral">&quot;catastrophic cancellation. This occurs when the data &quot;</span></div>
<div class="line"><span class="lineno"> 1232</span>                       <span class="stringliteral">&quot;are nearly identical. Results may be unreliable.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1233</span>            warnings.warn(message, RuntimeWarning, stacklevel=4)</div>
<div class="line"><span class="lineno"> 1234</span> </div>
<div class="line"><span class="lineno"> 1235</span>        <span class="keywordflow">if</span> n_list[-1] == 1:</div>
<div class="line"><span class="lineno"> 1236</span>            s = a_zero_mean.copy()</div>
<div class="line"><span class="lineno"> 1237</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1238</span>            s = a_zero_mean**2</div>
<div class="line"><span class="lineno"> 1239</span> </div>
<div class="line"><span class="lineno"> 1240</span>        <span class="comment"># Perform multiplications</span></div>
<div class="line"><span class="lineno"> 1241</span>        <span class="keywordflow">for</span> n <span class="keywordflow">in</span> n_list[-2::-1]:</div>
<div class="line"><span class="lineno"> 1242</span>            s = s**2</div>
<div class="line"><span class="lineno"> 1243</span>            <span class="keywordflow">if</span> n % 2:</div>
<div class="line"><span class="lineno"> 1244</span>                s *= a_zero_mean</div>
<div class="line"><span class="lineno"> 1245</span>        <span class="keywordflow">return</span> np.mean(s, axis)</div>
<div class="line"><span class="lineno"> 1246</span> </div>
<div class="line"><span class="lineno"> 1247</span> </div>
<div class="ttc" id="anamespacedtype_html"><div class="ttname"><a href="namespacedtype.html">dtype</a></div><div class="ttdef"><b>Definition</b> dtype.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e755c164ac589dc31d320fecbe127e2" name="a9e755c164ac589dc31d320fecbe127e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e755c164ac589dc31d320fecbe127e2">&#9670;&#160;</a></span>_moment_outputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._moment_outputs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MOMENTS #. </p>
<div class="fragment"><div class="line"><span class="lineno"> 1067</span><span class="keyword">def </span>_moment_outputs(kwds):</div>
<div class="line"><span class="lineno"> 1068</span>    moment = np.atleast_1d(kwds.get(<span class="stringliteral">&#39;moment&#39;</span>, 1))</div>
<div class="line"><span class="lineno"> 1069</span>    <span class="keywordflow">if</span> moment.size == 0:</div>
<div class="line"><span class="lineno"> 1070</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;moment&#39; must be a scalar or a non-empty 1D &quot;</span></div>
<div class="line"><span class="lineno"> 1071</span>                         <span class="stringliteral">&quot;list/array.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1072</span>    <span class="keywordflow">return</span> len(moment)</div>
<div class="line"><span class="lineno"> 1073</span> </div>
<div class="line"><span class="lineno"> 1074</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a41ef2a077e3c712981b1a282bf3ee032" name="a41ef2a077e3c712981b1a282bf3ee032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ef2a077e3c712981b1a282bf3ee032">&#9670;&#160;</a></span>_moment_result_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._moment_result_object </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1075</span><span class="keyword">def </span>_moment_result_object(*args):</div>
<div class="line"><span class="lineno"> 1076</span>    <span class="keywordflow">if</span> len(args) == 1:</div>
<div class="line"><span class="lineno"> 1077</span>        <span class="keywordflow">return</span> args[0]</div>
<div class="line"><span class="lineno"> 1078</span>    <span class="keywordflow">return</span> np.asarray(args)</div>
<div class="line"><span class="lineno"> 1079</span> </div>
<div class="line"><span class="lineno"> 1080</span><span class="comment"># `moment` fits into the `_axis_nan_policy` pattern, but it is a bit unusual</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="comment"># because the number of outputs is variable. Specifically,</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="comment"># `result_to_tuple=lambda x: (x,)` may be surprising for a function that</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="comment"># can produce more than one output, but it is intended here.</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="comment"># When `moment is called to produce the output:</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="comment"># - `result_to_tuple` packs the returned array into a single-element tuple,</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="comment"># - `_moment_result_object` extracts and returns that single element.</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="comment"># However, when the input array is empty, `moment` is never called. Instead,</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="comment"># - `_check_empty_inputs` is used to produce an empty array with the</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="comment">#   appropriate dimensions.</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="comment"># - A list comprehension creates the appropriate number of copies of this</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="comment">#   array, depending on `n_outputs`.</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="comment"># - This list - which may have multiple elements - is passed into</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="comment">#   `_moment_result_object`.</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="comment"># - If there is a single output, `_moment_result_object` extracts and returns</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="comment">#   the single output from the list.</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="comment"># - If there are multiple outputs, and therefore multiple elements in the list,</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="comment">#   `_moment_result_object` converts the list of arrays to a single array and</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="comment">#   returns it.</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="comment"># Currently this leads to a slight inconsistency: when the input array is</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="comment"># empty, there is no distinction between the `moment` function being called</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="comment"># with parameter `moments=1` and `moments=[1]`; the latter *should* produce</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="comment"># the same as the former but with a singleton zeroth dimension.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="preprocessor">@_axis_nan_policy_factory</span>(  <span class="comment"># noqa: E302</span></div>
<div class="line"><span class="lineno"> 1104</span>    _moment_result_object, n_samples=1, result_to_tuple=<span class="keyword">lambda</span> x: (x,),</div>
<div class="line"><span class="lineno"> 1105</span>    n_outputs=_moment_outputs</div>
<div class="line"><span class="lineno"> 1106</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e20026493d260d023531ce41e26c269" name="a0e20026493d260d023531ce41e26c269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e20026493d260d023531ce41e26c269">&#9670;&#160;</a></span>_normtest_finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._normtest_finish </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NORMALITY TESTS #. </p>
<pre class="fragment">Common code between all the normality-test functions.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1569</span><span class="keyword">def </span>_normtest_finish(z, alternative):</div>
<div class="line"><span class="lineno"> 1570</span>    <span class="stringliteral">&quot;&quot;&quot;Common code between all the normality-test functions.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1571</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;less&#39;</span>:</div>
<div class="line"><span class="lineno"> 1572</span>        prob = distributions.norm.cdf(z)</div>
<div class="line"><span class="lineno"> 1573</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;greater&#39;</span>:</div>
<div class="line"><span class="lineno"> 1574</span>        prob = distributions.norm.sf(z)</div>
<div class="line"><span class="lineno"> 1575</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;two-sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 1576</span>        prob = 2 * distributions.norm.sf(np.abs(z))</div>
<div class="line"><span class="lineno"> 1577</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1578</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;alternative must be &quot;</span></div>
<div class="line"><span class="lineno"> 1579</span>                         <span class="stringliteral">&quot;&#39;less&#39;, &#39;greater&#39; or &#39;two-sided&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1580</span> </div>
<div class="line"><span class="lineno"> 1581</span>    <span class="keywordflow">if</span> z.ndim == 0:</div>
<div class="line"><span class="lineno"> 1582</span>        z = z[()]</div>
<div class="line"><span class="lineno"> 1583</span> </div>
<div class="line"><span class="lineno"> 1584</span>    <span class="keywordflow">return</span> z, prob</div>
<div class="line"><span class="lineno"> 1585</span> </div>
<div class="line"><span class="lineno"> 1586</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adb3af01a376d251df82e906d556ffaeb" name="adb3af01a376d251df82e906d556ffaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3af01a376d251df82e906d556ffaeb">&#9670;&#160;</a></span>_parse_kstest_args()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._parse_kstest_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 7878</span><span class="keyword">def </span>_parse_kstest_args(data1, data2, args, N):</div>
<div class="line"><span class="lineno"> 7879</span>    <span class="comment"># kstest allows many different variations of arguments.</span></div>
<div class="line"><span class="lineno"> 7880</span>    <span class="comment"># Pull out the parsing into a separate function</span></div>
<div class="line"><span class="lineno"> 7881</span>    <span class="comment"># (xvals, yvals, )  # 2sample</span></div>
<div class="line"><span class="lineno"> 7882</span>    <span class="comment"># (xvals, cdf function,..)</span></div>
<div class="line"><span class="lineno"> 7883</span>    <span class="comment"># (xvals, name of distribution, ...)</span></div>
<div class="line"><span class="lineno"> 7884</span>    <span class="comment"># (name of distribution, name of distribution, ...)</span></div>
<div class="line"><span class="lineno"> 7885</span> </div>
<div class="line"><span class="lineno"> 7886</span>    <span class="comment"># Returns xvals, yvals, cdf</span></div>
<div class="line"><span class="lineno"> 7887</span>    <span class="comment"># where cdf is a cdf function, or None</span></div>
<div class="line"><span class="lineno"> 7888</span>    <span class="comment"># and yvals is either an array_like of values, or None</span></div>
<div class="line"><span class="lineno"> 7889</span>    <span class="comment"># and xvals is array_like.</span></div>
<div class="line"><span class="lineno"> 7890</span>    rvsfunc, cdf = <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 7891</span>    <span class="keywordflow">if</span> isinstance(data1, str):</div>
<div class="line"><span class="lineno"> 7892</span>        rvsfunc = getattr(distributions, data1).rvs</div>
<div class="line"><span class="lineno"> 7893</span>    <span class="keywordflow">elif</span> callable(data1):</div>
<div class="line"><span class="lineno"> 7894</span>        rvsfunc = data1</div>
<div class="line"><span class="lineno"> 7895</span> </div>
<div class="line"><span class="lineno"> 7896</span>    <span class="keywordflow">if</span> isinstance(data2, str):</div>
<div class="line"><span class="lineno"> 7897</span>        cdf = getattr(distributions, data2).cdf</div>
<div class="line"><span class="lineno"> 7898</span>        data2 = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 7899</span>    <span class="keywordflow">elif</span> callable(data2):</div>
<div class="line"><span class="lineno"> 7900</span>        cdf = data2</div>
<div class="line"><span class="lineno"> 7901</span>        data2 = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 7902</span> </div>
<div class="line"><span class="lineno"> 7903</span>    data1 = np.sort(rvsfunc(*args, size=N) <span class="keywordflow">if</span> rvsfunc <span class="keywordflow">else</span> data1)</div>
<div class="line"><span class="lineno"> 7904</span>    <span class="keywordflow">return</span> data1, data2, cdf</div>
<div class="line"><span class="lineno"> 7905</span> </div>
<div class="line"><span class="lineno"> 7906</span> </div>
<div class="line"><span class="lineno"> 7907</span><span class="preprocessor">@_rename_parameter(&quot;mode&quot;, &quot;method&quot;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="acaf4e4f934f9bc9561d37ca281b850f5" name="acaf4e4f934f9bc9561d37ca281b850f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf4e4f934f9bc9561d37ca281b850f5">&#9670;&#160;</a></span>_pearsonr_fisher_ci()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._pearsonr_fisher_ci </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>confidence_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the confidence interval for Pearson's R.

Fisher's transformation is used to compute the confidence interval
(https://en.wikipedia.org/wiki/Fisher_transformation).
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4121</span><span class="keyword">def </span>_pearsonr_fisher_ci(r, n, confidence_level, alternative):</div>
<div class="line"><span class="lineno"> 4122</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4123</span><span class="stringliteral">    Compute the confidence interval for Pearson&#39;s R.</span></div>
<div class="line"><span class="lineno"> 4124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4125</span><span class="stringliteral">    Fisher&#39;s transformation is used to compute the confidence interval</span></div>
<div class="line"><span class="lineno"> 4126</span><span class="stringliteral">    (https://en.wikipedia.org/wiki/Fisher_transformation).</span></div>
<div class="line"><span class="lineno"> 4127</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4128</span>    <span class="keywordflow">if</span> r == 1:</div>
<div class="line"><span class="lineno"> 4129</span>        zr = np.inf</div>
<div class="line"><span class="lineno"> 4130</span>    <span class="keywordflow">elif</span> r == -1:</div>
<div class="line"><span class="lineno"> 4131</span>        zr = -np.inf</div>
<div class="line"><span class="lineno"> 4132</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4133</span>        zr = np.arctanh(r)</div>
<div class="line"><span class="lineno"> 4134</span> </div>
<div class="line"><span class="lineno"> 4135</span>    <span class="keywordflow">if</span> n &gt; 3:</div>
<div class="line"><span class="lineno"> 4136</span>        se = np.sqrt(1 / (n - 3))</div>
<div class="line"><span class="lineno"> 4137</span>        <span class="keywordflow">if</span> alternative == <span class="stringliteral">&quot;two-sided&quot;</span>:</div>
<div class="line"><span class="lineno"> 4138</span>            h = special.ndtri(0.5 + confidence_level/2)</div>
<div class="line"><span class="lineno"> 4139</span>            zlo = zr - h*se</div>
<div class="line"><span class="lineno"> 4140</span>            zhi = zr + h*se</div>
<div class="line"><span class="lineno"> 4141</span>            rlo = np.tanh(zlo)</div>
<div class="line"><span class="lineno"> 4142</span>            rhi = np.tanh(zhi)</div>
<div class="line"><span class="lineno"> 4143</span>        <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&quot;less&quot;</span>:</div>
<div class="line"><span class="lineno"> 4144</span>            h = special.ndtri(confidence_level)</div>
<div class="line"><span class="lineno"> 4145</span>            zhi = zr + h*se</div>
<div class="line"><span class="lineno"> 4146</span>            rhi = np.tanh(zhi)</div>
<div class="line"><span class="lineno"> 4147</span>            rlo = -1.0</div>
<div class="line"><span class="lineno"> 4148</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4149</span>            <span class="comment"># alternative == &quot;greater&quot;:</span></div>
<div class="line"><span class="lineno"> 4150</span>            h = special.ndtri(confidence_level)</div>
<div class="line"><span class="lineno"> 4151</span>            zlo = zr - h*se</div>
<div class="line"><span class="lineno"> 4152</span>            rlo = np.tanh(zlo)</div>
<div class="line"><span class="lineno"> 4153</span>            rhi = 1.0</div>
<div class="line"><span class="lineno"> 4154</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4155</span>        rlo, rhi = -1.0, 1.0</div>
<div class="line"><span class="lineno"> 4156</span> </div>
<div class="line"><span class="lineno"> 4157</span>    <span class="keywordflow">return</span> ConfidenceInterval(low=rlo, high=rhi)</div>
<div class="line"><span class="lineno"> 4158</span> </div>
<div class="line"><span class="lineno"> 4159</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0076d6e995299f62317826f85fe2cd6" name="ad0076d6e995299f62317826f85fe2cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0076d6e995299f62317826f85fe2cd6">&#9670;&#160;</a></span>_perm_test()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._perm_test </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reps</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>workers</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function that calculates the p-value. See below for uses.

Parameters
----------
x, y : ndarray
`x` and `y` have shapes `(n, p)` and `(n, q)`.
stat : float
The sample test statistic.
reps : int, optional
The number of replications used to estimate the null when using the
permutation test. The default is 1000 replications.
workers : int or map-like callable, optional
If `workers` is an int the population is subdivided into `workers`
sections and evaluated in parallel (uses
`multiprocessing.Pool &lt;multiprocessing&gt;`). Supply `-1` to use all cores
available to the Process. Alternatively supply a map-like callable,
such as `multiprocessing.Pool.map` for evaluating the population in
parallel. This evaluation is carried out as `workers(func, iterable)`.
Requires that `func` be pickleable.
random_state : {None, int, `numpy.random.Generator`,
            `numpy.random.RandomState`}, optional

If `seed` is None (or `np.random`), the `numpy.random.RandomState`
singleton is used.
If `seed` is an int, a new ``RandomState`` instance is used,
seeded with `seed`.
If `seed` is already a ``Generator`` or ``RandomState`` instance then
that instance is used.

Returns
-------
pvalue : float
The sample test p-value.
null_dist : list
The approximated null distribution.</pre> <div class="fragment"><div class="line"><span class="lineno"> 5429</span><span class="keyword">def </span>_perm_test(x, y, stat, reps=1000, workers=-1, random_state=None):</div>
<div class="line"><span class="lineno"> 5430</span>    <span class="stringliteral">r&quot;&quot;&quot;Helper function that calculates the p-value. See below for uses.</span></div>
<div class="line"><span class="lineno"> 5431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5432</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5433</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5434</span><span class="stringliteral">    x, y : ndarray</span></div>
<div class="line"><span class="lineno"> 5435</span><span class="stringliteral">        `x` and `y` have shapes `(n, p)` and `(n, q)`.</span></div>
<div class="line"><span class="lineno"> 5436</span><span class="stringliteral">    stat : float</span></div>
<div class="line"><span class="lineno"> 5437</span><span class="stringliteral">        The sample test statistic.</span></div>
<div class="line"><span class="lineno"> 5438</span><span class="stringliteral">    reps : int, optional</span></div>
<div class="line"><span class="lineno"> 5439</span><span class="stringliteral">        The number of replications used to estimate the null when using the</span></div>
<div class="line"><span class="lineno"> 5440</span><span class="stringliteral">        permutation test. The default is 1000 replications.</span></div>
<div class="line"><span class="lineno"> 5441</span><span class="stringliteral">    workers : int or map-like callable, optional</span></div>
<div class="line"><span class="lineno"> 5442</span><span class="stringliteral">        If `workers` is an int the population is subdivided into `workers`</span></div>
<div class="line"><span class="lineno"> 5443</span><span class="stringliteral">        sections and evaluated in parallel (uses</span></div>
<div class="line"><span class="lineno"> 5444</span><span class="stringliteral">        `multiprocessing.Pool &lt;multiprocessing&gt;`). Supply `-1` to use all cores</span></div>
<div class="line"><span class="lineno"> 5445</span><span class="stringliteral">        available to the Process. Alternatively supply a map-like callable,</span></div>
<div class="line"><span class="lineno"> 5446</span><span class="stringliteral">        such as `multiprocessing.Pool.map` for evaluating the population in</span></div>
<div class="line"><span class="lineno"> 5447</span><span class="stringliteral">        parallel. This evaluation is carried out as `workers(func, iterable)`.</span></div>
<div class="line"><span class="lineno"> 5448</span><span class="stringliteral">        Requires that `func` be pickleable.</span></div>
<div class="line"><span class="lineno"> 5449</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno"> 5450</span><span class="stringliteral">                    `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno"> 5451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5452</span><span class="stringliteral">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno"> 5453</span><span class="stringliteral">        singleton is used.</span></div>
<div class="line"><span class="lineno"> 5454</span><span class="stringliteral">        If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno"> 5455</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno"> 5456</span><span class="stringliteral">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno"> 5457</span><span class="stringliteral">        that instance is used.</span></div>
<div class="line"><span class="lineno"> 5458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5459</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5460</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5461</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 5462</span><span class="stringliteral">        The sample test p-value.</span></div>
<div class="line"><span class="lineno"> 5463</span><span class="stringliteral">    null_dist : list</span></div>
<div class="line"><span class="lineno"> 5464</span><span class="stringliteral">        The approximated null distribution.</span></div>
<div class="line"><span class="lineno"> 5465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5466</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5467</span>    <span class="comment"># generate seeds for each rep (change to new parallel random number</span></div>
<div class="line"><span class="lineno"> 5468</span>    <span class="comment"># capabilities in numpy &gt;= 1.17+)</span></div>
<div class="line"><span class="lineno"> 5469</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno"> 5470</span>    random_states = [np.random.RandomState(rng_integers(random_state, 1 &lt;&lt; 32,</div>
<div class="line"><span class="lineno"> 5471</span>                     size=4, dtype=np.uint32)) <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(reps)]</div>
<div class="line"><span class="lineno"> 5472</span> </div>
<div class="line"><span class="lineno"> 5473</span>    <span class="comment"># parallelizes with specified workers over number of reps and set seeds</span></div>
<div class="line"><span class="lineno"> 5474</span>    parallelp = _ParallelP(x=x, y=y, random_states=random_states)</div>
<div class="line"><span class="lineno"> 5475</span>    <span class="keyword">with</span> MapWrapper(workers) <span class="keyword">as</span> mapwrapper:</div>
<div class="line"><span class="lineno"> 5476</span>        null_dist = np.array(list(mapwrapper(parallelp, range(reps))))</div>
<div class="line"><span class="lineno"> 5477</span> </div>
<div class="line"><span class="lineno"> 5478</span>    <span class="comment"># calculate p-value and significant permutation map through list</span></div>
<div class="line"><span class="lineno"> 5479</span>    pvalue = (1 + (null_dist &gt;= stat).sum()) / (1 + reps)</div>
<div class="line"><span class="lineno"> 5480</span> </div>
<div class="line"><span class="lineno"> 5481</span>    <span class="keywordflow">return</span> pvalue, null_dist</div>
<div class="line"><span class="lineno"> 5482</span> </div>
<div class="line"><span class="lineno"> 5483</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3be4c10d446d0f0d68e56a854ba225c" name="ab3be4c10d446d0f0d68e56a854ba225c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3be4c10d446d0f0d68e56a854ba225c">&#9670;&#160;</a></span>_permutation_distribution_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._permutation_distribution_t </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generation permutation distribution of t statistic</pre> <div class="fragment"><div class="line"><span class="lineno"> 6663</span>                                random_state=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 6664</span>    <span class="stringliteral">&quot;&quot;&quot;Generation permutation distribution of t statistic&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6665</span> </div>
<div class="line"><span class="lineno"> 6666</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno"> 6667</span> </div>
<div class="line"><span class="lineno"> 6668</span>    <span class="comment"># prepare permutation indices</span></div>
<div class="line"><span class="lineno"> 6669</span>    size = data.shape[-1]</div>
<div class="line"><span class="lineno"> 6670</span>    <span class="comment"># number of distinct combinations</span></div>
<div class="line"><span class="lineno"> 6671</span>    n_max = special.comb(size, size_a)</div>
<div class="line"><span class="lineno"> 6672</span> </div>
<div class="line"><span class="lineno"> 6673</span>    <span class="keywordflow">if</span> permutations &lt; n_max:</div>
<div class="line"><span class="lineno"> 6674</span>        perm_generator = (random_state.permutation(size)</div>
<div class="line"><span class="lineno"> 6675</span>                          <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(permutations))</div>
<div class="line"><span class="lineno"> 6676</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6677</span>        permutations = n_max</div>
<div class="line"><span class="lineno"> 6678</span>        perm_generator = (np.concatenate(z)</div>
<div class="line"><span class="lineno"> 6679</span>                          <span class="keywordflow">for</span> z <span class="keywordflow">in</span> _all_partitions(size_a, size-size_a))</div>
<div class="line"><span class="lineno"> 6680</span> </div>
<div class="line"><span class="lineno"> 6681</span>    t_stat = []</div>
<div class="line"><span class="lineno"> 6682</span>    <span class="keywordflow">for</span> indices <span class="keywordflow">in</span> _batch_generator(perm_generator, batch=50):</div>
<div class="line"><span class="lineno"> 6683</span>        <span class="comment"># get one batch from perm_generator at a time as a list</span></div>
<div class="line"><span class="lineno"> 6684</span>        indices = np.array(indices)</div>
<div class="line"><span class="lineno"> 6685</span>        <span class="comment"># generate permutations</span></div>
<div class="line"><span class="lineno"> 6686</span>        data_perm = data[..., indices]</div>
<div class="line"><span class="lineno"> 6687</span>        <span class="comment"># move axis indexing permutations to position 0 to broadcast</span></div>
<div class="line"><span class="lineno"> 6688</span>        <span class="comment"># nicely with t_stat_observed, which doesn&#39;t have this dimension</span></div>
<div class="line"><span class="lineno"> 6689</span>        data_perm = np.moveaxis(data_perm, -2, 0)</div>
<div class="line"><span class="lineno"> 6690</span> </div>
<div class="line"><span class="lineno"> 6691</span>        a = data_perm[..., :size_a]</div>
<div class="line"><span class="lineno"> 6692</span>        b = data_perm[..., size_a:]</div>
<div class="line"><span class="lineno"> 6693</span>        t_stat.append(_calc_t_stat(a, b, equal_var))</div>
<div class="line"><span class="lineno"> 6694</span> </div>
<div class="line"><span class="lineno"> 6695</span>    t_stat = np.concatenate(t_stat, axis=0)</div>
<div class="line"><span class="lineno"> 6696</span> </div>
<div class="line"><span class="lineno"> 6697</span>    <span class="keywordflow">return</span> t_stat, permutations, n_max</div>
<div class="line"><span class="lineno"> 6698</span> </div>
<div class="line"><span class="lineno"> 6699</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a76074b3d866305fa36a138f38ce9611b" name="a76074b3d866305fa36a138f38ce9611b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76074b3d866305fa36a138f38ce9611b">&#9670;&#160;</a></span>_permutation_ttest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._permutation_ttest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_var</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculates the T-test for the means of TWO INDEPENDENT samples of scores
using permutation methods.

This test is similar to `stats.ttest_ind`, except it doesn't rely on an
approximate normality assumption since it uses a permutation test.
This function is only called from ttest_ind when permutations is not None.

Parameters
----------
a, b : array_like
    The arrays must be broadcastable, except along the dimension
    corresponding to `axis` (the zeroth, by default).
axis : int, optional
    The axis over which to operate on a and b.
permutations : int, optional
    Number of permutations used to calculate p-value. If greater than or
    equal to the number of distinct permutations, perform an exact test.
equal_var : bool, optional
    If False, an equal variance (Welch's) t-test is conducted.  Otherwise,
    an ordinary t-test is conducted.
random_state : {None, int, `numpy.random.Generator`}, optional
    If `seed` is None the `numpy.random.Generator` singleton is used.
    If `seed` is an int, a new ``Generator`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` instance then that instance is
    used.
    Pseudorandom number generator state used for generating random
    permutations.

Returns
-------
statistic : float or array
    The calculated t-statistic.
pvalue : float or array
    The p-value.</pre> <div class="fragment"><div class="line"><span class="lineno"> 6719</span>                       alternative=<span class="stringliteral">&quot;two-sided&quot;</span>):</div>
<div class="line"><span class="lineno"> 6720</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6721</span><span class="stringliteral">    Calculates the T-test for the means of TWO INDEPENDENT samples of scores</span></div>
<div class="line"><span class="lineno"> 6722</span><span class="stringliteral">    using permutation methods.</span></div>
<div class="line"><span class="lineno"> 6723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6724</span><span class="stringliteral">    This test is similar to `stats.ttest_ind`, except it doesn&#39;t rely on an</span></div>
<div class="line"><span class="lineno"> 6725</span><span class="stringliteral">    approximate normality assumption since it uses a permutation test.</span></div>
<div class="line"><span class="lineno"> 6726</span><span class="stringliteral">    This function is only called from ttest_ind when permutations is not None.</span></div>
<div class="line"><span class="lineno"> 6727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6728</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 6729</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6730</span><span class="stringliteral">    a, b : array_like</span></div>
<div class="line"><span class="lineno"> 6731</span><span class="stringliteral">        The arrays must be broadcastable, except along the dimension</span></div>
<div class="line"><span class="lineno"> 6732</span><span class="stringliteral">        corresponding to `axis` (the zeroth, by default).</span></div>
<div class="line"><span class="lineno"> 6733</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 6734</span><span class="stringliteral">        The axis over which to operate on a and b.</span></div>
<div class="line"><span class="lineno"> 6735</span><span class="stringliteral">    permutations : int, optional</span></div>
<div class="line"><span class="lineno"> 6736</span><span class="stringliteral">        Number of permutations used to calculate p-value. If greater than or</span></div>
<div class="line"><span class="lineno"> 6737</span><span class="stringliteral">        equal to the number of distinct permutations, perform an exact test.</span></div>
<div class="line"><span class="lineno"> 6738</span><span class="stringliteral">    equal_var : bool, optional</span></div>
<div class="line"><span class="lineno"> 6739</span><span class="stringliteral">        If False, an equal variance (Welch&#39;s) t-test is conducted.  Otherwise,</span></div>
<div class="line"><span class="lineno"> 6740</span><span class="stringliteral">        an ordinary t-test is conducted.</span></div>
<div class="line"><span class="lineno"> 6741</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`}, optional</span></div>
<div class="line"><span class="lineno"> 6742</span><span class="stringliteral">        If `seed` is None the `numpy.random.Generator` singleton is used.</span></div>
<div class="line"><span class="lineno"> 6743</span><span class="stringliteral">        If `seed` is an int, a new ``Generator`` instance is used,</span></div>
<div class="line"><span class="lineno"> 6744</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno"> 6745</span><span class="stringliteral">        If `seed` is already a ``Generator`` instance then that instance is</span></div>
<div class="line"><span class="lineno"> 6746</span><span class="stringliteral">        used.</span></div>
<div class="line"><span class="lineno"> 6747</span><span class="stringliteral">        Pseudorandom number generator state used for generating random</span></div>
<div class="line"><span class="lineno"> 6748</span><span class="stringliteral">        permutations.</span></div>
<div class="line"><span class="lineno"> 6749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6750</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 6751</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 6752</span><span class="stringliteral">    statistic : float or array</span></div>
<div class="line"><span class="lineno"> 6753</span><span class="stringliteral">        The calculated t-statistic.</span></div>
<div class="line"><span class="lineno"> 6754</span><span class="stringliteral">    pvalue : float or array</span></div>
<div class="line"><span class="lineno"> 6755</span><span class="stringliteral">        The p-value.</span></div>
<div class="line"><span class="lineno"> 6756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6757</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6758</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno"> 6759</span> </div>
<div class="line"><span class="lineno"> 6760</span>    t_stat_observed = _calc_t_stat(a, b, equal_var, axis=axis)</div>
<div class="line"><span class="lineno"> 6761</span> </div>
<div class="line"><span class="lineno"> 6762</span>    na = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6763</span>    mat = _broadcast_concatenate((a, b), axis=axis)</div>
<div class="line"><span class="lineno"> 6764</span>    mat = np.moveaxis(mat, axis, -1)</div>
<div class="line"><span class="lineno"> 6765</span> </div>
<div class="line"><span class="lineno"> 6766</span>    t_stat, permutations, n_max = _permutation_distribution_t(</div>
<div class="line"><span class="lineno"> 6767</span>        mat, permutations, size_a=na, equal_var=equal_var,</div>
<div class="line"><span class="lineno"> 6768</span>        random_state=random_state)</div>
<div class="line"><span class="lineno"> 6769</span> </div>
<div class="line"><span class="lineno"> 6770</span>    compare = {<span class="stringliteral">&quot;less&quot;</span>: np.less_equal,</div>
<div class="line"><span class="lineno"> 6771</span>               <span class="stringliteral">&quot;greater&quot;</span>: np.greater_equal,</div>
<div class="line"><span class="lineno"> 6772</span>               <span class="stringliteral">&quot;two-sided&quot;</span>: <span class="keyword">lambda</span> x, y: (x &lt;= -np.abs(y)) | (x &gt;= np.abs(y))}</div>
<div class="line"><span class="lineno"> 6773</span> </div>
<div class="line"><span class="lineno"> 6774</span>    <span class="comment"># Calculate the p-values</span></div>
<div class="line"><span class="lineno"> 6775</span>    cmps = compare[alternative](t_stat, t_stat_observed)</div>
<div class="line"><span class="lineno"> 6776</span>    <span class="comment"># Randomized test p-value calculation should use biased estimate; see e.g.</span></div>
<div class="line"><span class="lineno"> 6777</span>    <span class="comment"># https://www.degruyter.com/document/doi/10.2202/1544-6115.1585/</span></div>
<div class="line"><span class="lineno"> 6778</span>    adjustment = 1 <span class="keywordflow">if</span> n_max &gt; permutations <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno"> 6779</span>    pvalues = (cmps.sum(axis=0) + adjustment) / (permutations + adjustment)</div>
<div class="line"><span class="lineno"> 6780</span> </div>
<div class="line"><span class="lineno"> 6781</span>    <span class="comment"># nans propagate naturally in statistic calculation, but need to be</span></div>
<div class="line"><span class="lineno"> 6782</span>    <span class="comment"># propagated manually into pvalues</span></div>
<div class="line"><span class="lineno"> 6783</span>    <span class="keywordflow">if</span> nan_policy == <span class="stringliteral">&#39;propagate&#39;</span> <span class="keywordflow">and</span> np.isnan(t_stat_observed).any():</div>
<div class="line"><span class="lineno"> 6784</span>        <span class="keywordflow">if</span> np.ndim(pvalues) == 0:</div>
<div class="line"><span class="lineno"> 6785</span>            pvalues = np.float64(np.nan)</div>
<div class="line"><span class="lineno"> 6786</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6787</span>            pvalues[np.isnan(t_stat_observed)] = np.nan</div>
<div class="line"><span class="lineno"> 6788</span> </div>
<div class="line"><span class="lineno"> 6789</span>    <span class="keywordflow">return</span> (t_stat_observed, pvalues)</div>
<div class="line"><span class="lineno"> 6790</span> </div>
<div class="line"><span class="lineno"> 6791</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b21f46bcd2e74e726ebab41f7c799c8" name="a4b21f46bcd2e74e726ebab41f7c799c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b21f46bcd2e74e726ebab41f7c799c8">&#9670;&#160;</a></span>_quiet_nanmean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._quiet_nanmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute nanmean for the 1d array x, but quietly return nan if x is all nan.

The return value is a 1d array with length 1, so it can be used
in np.apply_along_axis.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2637</span><span class="keyword">def </span>_quiet_nanmean(x):</div>
<div class="line"><span class="lineno"> 2638</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2639</span><span class="stringliteral">    Compute nanmean for the 1d array x, but quietly return nan if x is all nan.</span></div>
<div class="line"><span class="lineno"> 2640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2641</span><span class="stringliteral">    The return value is a 1d array with length 1, so it can be used</span></div>
<div class="line"><span class="lineno"> 2642</span><span class="stringliteral">    in np.apply_along_axis.</span></div>
<div class="line"><span class="lineno"> 2643</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2644</span>    y = x[~np.isnan(x)]</div>
<div class="line"><span class="lineno"> 2645</span>    <span class="keywordflow">if</span> y.size == 0:</div>
<div class="line"><span class="lineno"> 2646</span>        <span class="keywordflow">return</span> np.array([np.nan])</div>
<div class="line"><span class="lineno"> 2647</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2648</span>        <span class="keywordflow">return</span> np.mean(y, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2649</span> </div>
<div class="line"><span class="lineno"> 2650</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a51738f78d33d4973d9bb92624d6a5bef" name="a51738f78d33d4973d9bb92624d6a5bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51738f78d33d4973d9bb92624d6a5bef">&#9670;&#160;</a></span>_quiet_nanstd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._quiet_nanstd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute nanstd for the 1d array x, but quietly return nan if x is all nan.

The return value is a 1d array with length 1, so it can be used
in np.apply_along_axis.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2651</span><span class="keyword">def </span>_quiet_nanstd(x, ddof=0):</div>
<div class="line"><span class="lineno"> 2652</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral">    Compute nanstd for the 1d array x, but quietly return nan if x is all nan.</span></div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral">    The return value is a 1d array with length 1, so it can be used</span></div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral">    in np.apply_along_axis.</span></div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2658</span>    y = x[~np.isnan(x)]</div>
<div class="line"><span class="lineno"> 2659</span>    <span class="keywordflow">if</span> y.size == 0:</div>
<div class="line"><span class="lineno"> 2660</span>        <span class="keywordflow">return</span> np.array([np.nan])</div>
<div class="line"><span class="lineno"> 2661</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2662</span>        <span class="keywordflow">return</span> np.std(y, keepdims=<span class="keyword">True</span>, ddof=ddof)</div>
<div class="line"><span class="lineno"> 2663</span> </div>
<div class="line"><span class="lineno"> 2664</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a686b42aa2995c61b6fbe6c6af38fc527" name="a686b42aa2995c61b6fbe6c6af38fc527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686b42aa2995c61b6fbe6c6af38fc527">&#9670;&#160;</a></span>_shape_with_dropped_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._shape_with_dropped_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Given an array `a` and an integer `axis`, return the shape
of `a` with the `axis` dimension removed.

Examples
--------
&gt;&gt;&gt; a = np.zeros((3, 5, 2))
&gt;&gt;&gt; _shape_with_dropped_axis(a, 1)
(3, 2)</pre> <div class="fragment"><div class="line"><span class="lineno">  154</span><span class="keyword">def </span>_shape_with_dropped_axis(a, axis):</div>
<div class="line"><span class="lineno">  155</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    Given an array `a` and an integer `axis`, return the shape</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    of `a` with the `axis` dimension removed.</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((3, 5, 2))</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    &gt;&gt;&gt; _shape_with_dropped_axis(a, 1)</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    (3, 2)</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  166</span>    shp = list(a.shape)</div>
<div class="line"><span class="lineno">  167</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  168</span>        del shp[axis]</div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">except</span> IndexError:</div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordflow">raise</span> np.AxisError(axis, a.ndim) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  171</span>    <span class="keywordflow">return</span> tuple(shp)</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d928324e2a00e17b80082984cb5fae2" name="a9d928324e2a00e17b80082984cb5fae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d928324e2a00e17b80082984cb5fae2">&#9670;&#160;</a></span>_smooth_mgc_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._smooth_mgc_map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sig_connect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stat_mgc_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Finds the smoothed maximal within the significant region R.

If area of R is too small it returns the last local correlation. Otherwise,
returns the maximum within significant_connected_region.

Parameters
----------
sig_connect : ndarray
    A binary matrix with 1's indicating the significant region.
stat_mgc_map : ndarray
    All local correlations within `[-1, 1]`.

Returns
-------
stat : float
    The sample MGC statistic within `[-1, 1]`.
opt_scale: (float, float)
    The estimated optimal scale as an `(x, y)` pair.</pre> <div class="fragment"><div class="line"><span class="lineno"> 5872</span><span class="keyword">def </span>_smooth_mgc_map(sig_connect, stat_mgc_map):</div>
<div class="line"><span class="lineno"> 5873</span>    <span class="stringliteral">&quot;&quot;&quot;Finds the smoothed maximal within the significant region R.</span></div>
<div class="line"><span class="lineno"> 5874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5875</span><span class="stringliteral">    If area of R is too small it returns the last local correlation. Otherwise,</span></div>
<div class="line"><span class="lineno"> 5876</span><span class="stringliteral">    returns the maximum within significant_connected_region.</span></div>
<div class="line"><span class="lineno"> 5877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5878</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5879</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5880</span><span class="stringliteral">    sig_connect : ndarray</span></div>
<div class="line"><span class="lineno"> 5881</span><span class="stringliteral">        A binary matrix with 1&#39;s indicating the significant region.</span></div>
<div class="line"><span class="lineno"> 5882</span><span class="stringliteral">    stat_mgc_map : ndarray</span></div>
<div class="line"><span class="lineno"> 5883</span><span class="stringliteral">        All local correlations within `[-1, 1]`.</span></div>
<div class="line"><span class="lineno"> 5884</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5885</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5886</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5887</span><span class="stringliteral">    stat : float</span></div>
<div class="line"><span class="lineno"> 5888</span><span class="stringliteral">        The sample MGC statistic within `[-1, 1]`.</span></div>
<div class="line"><span class="lineno"> 5889</span><span class="stringliteral">    opt_scale: (float, float)</span></div>
<div class="line"><span class="lineno"> 5890</span><span class="stringliteral">        The estimated optimal scale as an `(x, y)` pair.</span></div>
<div class="line"><span class="lineno"> 5891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5892</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5893</span>    m, n = stat_mgc_map.shape</div>
<div class="line"><span class="lineno"> 5894</span> </div>
<div class="line"><span class="lineno"> 5895</span>    <span class="comment"># the global scale at is the statistic calculated at maximial nearest</span></div>
<div class="line"><span class="lineno"> 5896</span>    <span class="comment"># neighbors. By default, statistic and optimal scale are global.</span></div>
<div class="line"><span class="lineno"> 5897</span>    stat = stat_mgc_map[m - 1][n - 1]</div>
<div class="line"><span class="lineno"> 5898</span>    opt_scale = [m, n]</div>
<div class="line"><span class="lineno"> 5899</span> </div>
<div class="line"><span class="lineno"> 5900</span>    <span class="keywordflow">if</span> np.linalg.norm(sig_connect) != 0:</div>
<div class="line"><span class="lineno"> 5901</span>        <span class="comment"># proceed only when the connected region&#39;s area is sufficiently large</span></div>
<div class="line"><span class="lineno"> 5902</span>        <span class="comment"># 0.02 is simply an empirical threshold, this can be set to 0.01 or 0.05</span></div>
<div class="line"><span class="lineno"> 5903</span>        <span class="comment"># with varying levels of performance</span></div>
<div class="line"><span class="lineno"> 5904</span>        <span class="keywordflow">if</span> np.sum(sig_connect) &gt;= np.ceil(0.02 * max(m, n)) * min(m, n):</div>
<div class="line"><span class="lineno"> 5905</span>            max_corr = max(stat_mgc_map[sig_connect])</div>
<div class="line"><span class="lineno"> 5906</span> </div>
<div class="line"><span class="lineno"> 5907</span>            <span class="comment"># find all scales within significant_connected_region that maximize</span></div>
<div class="line"><span class="lineno"> 5908</span>            <span class="comment"># the local correlation</span></div>
<div class="line"><span class="lineno"> 5909</span>            max_corr_index = np.where((stat_mgc_map &gt;= max_corr) &amp; sig_connect)</div>
<div class="line"><span class="lineno"> 5910</span> </div>
<div class="line"><span class="lineno"> 5911</span>            <span class="keywordflow">if</span> max_corr &gt;= stat:</div>
<div class="line"><span class="lineno"> 5912</span>                stat = max_corr</div>
<div class="line"><span class="lineno"> 5913</span> </div>
<div class="line"><span class="lineno"> 5914</span>                k, l = max_corr_index</div>
<div class="line"><span class="lineno"> 5915</span>                one_d_indices = k * n + l  <span class="comment"># 2D to 1D indexing</span></div>
<div class="line"><span class="lineno"> 5916</span>                k = np.max(one_d_indices) // n</div>
<div class="line"><span class="lineno"> 5917</span>                l = np.max(one_d_indices) % n</div>
<div class="line"><span class="lineno"> 5918</span>                opt_scale = [k+1, l+1]  <span class="comment"># adding 1s to match R indexing</span></div>
<div class="line"><span class="lineno"> 5919</span> </div>
<div class="line"><span class="lineno"> 5920</span>    <span class="keywordflow">return</span> stat, opt_scale</div>
<div class="line"><span class="lineno"> 5921</span> </div>
<div class="line"><span class="lineno"> 5922</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f95272db5e6cd266ad36a67e1353b18" name="a4f95272db5e6cd266ad36a67e1353b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f95272db5e6cd266ad36a67e1353b18">&#9670;&#160;</a></span>_square_of_sums()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._square_of_sums </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Sum elements of the input array, and return the square(s) of that sum.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    Axis along which to calculate. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
square_of_sums : float or ndarray
    The square of the sum over `axis`.

See Also
--------
_sum_of_squares : The sum of squares (the opposite of `square_of_sums`).</pre> <div class="fragment"><div class="line"><span class="lineno"> 9036</span><span class="keyword">def </span>_square_of_sums(a, axis=0):</div>
<div class="line"><span class="lineno"> 9037</span>    <span class="stringliteral">&quot;&quot;&quot;Sum elements of the input array, and return the square(s) of that sum.</span></div>
<div class="line"><span class="lineno"> 9038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9039</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 9040</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 9041</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 9042</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 9043</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 9044</span><span class="stringliteral">        Axis along which to calculate. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 9045</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 9046</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9047</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 9048</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 9049</span><span class="stringliteral">    square_of_sums : float or ndarray</span></div>
<div class="line"><span class="lineno"> 9050</span><span class="stringliteral">        The square of the sum over `axis`.</span></div>
<div class="line"><span class="lineno"> 9051</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9052</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 9053</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 9054</span><span class="stringliteral">    _sum_of_squares : The sum of squares (the opposite of `square_of_sums`).</span></div>
<div class="line"><span class="lineno"> 9055</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9056</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 9057</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 9058</span>    s = np.sum(a, axis)</div>
<div class="line"><span class="lineno"> 9059</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isscalar(s):</div>
<div class="line"><span class="lineno"> 9060</span>        <span class="keywordflow">return</span> s.astype(float) * s</div>
<div class="line"><span class="lineno"> 9061</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 9062</span>        <span class="keywordflow">return</span> float(s) * s</div>
<div class="line"><span class="lineno"> 9063</span> </div>
<div class="line"><span class="lineno"> 9064</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a35baa494b62135807260b2445335c9f9" name="a35baa494b62135807260b2445335c9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35baa494b62135807260b2445335c9f9">&#9670;&#160;</a></span>_sum_of_squares()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._sum_of_squares </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Square each element of the input array, and return the sum(s) of that.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    Axis along which to calculate. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
sum_of_squares : ndarray
    The sum along the given axis for (a**2).

See Also
--------
_square_of_sums : The square(s) of the sum(s) (the opposite of
    `_sum_of_squares`).</pre> <div class="fragment"><div class="line"><span class="lineno"> 9010</span><span class="keyword">def </span>_sum_of_squares(a, axis=0):</div>
<div class="line"><span class="lineno"> 9011</span>    <span class="stringliteral">&quot;&quot;&quot;Square each element of the input array, and return the sum(s) of that.</span></div>
<div class="line"><span class="lineno"> 9012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9013</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 9014</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 9015</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 9016</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 9017</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 9018</span><span class="stringliteral">        Axis along which to calculate. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 9019</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 9020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9021</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 9022</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 9023</span><span class="stringliteral">    sum_of_squares : ndarray</span></div>
<div class="line"><span class="lineno"> 9024</span><span class="stringliteral">        The sum along the given axis for (a**2).</span></div>
<div class="line"><span class="lineno"> 9025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9026</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 9027</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 9028</span><span class="stringliteral">    _square_of_sums : The square(s) of the sum(s) (the opposite of</span></div>
<div class="line"><span class="lineno"> 9029</span><span class="stringliteral">        `_sum_of_squares`).</span></div>
<div class="line"><span class="lineno"> 9030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9031</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 9032</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 9033</span>    <span class="keywordflow">return</span> np.sum(a*a, axis)</div>
<div class="line"><span class="lineno"> 9034</span> </div>
<div class="line"><span class="lineno"> 9035</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a436f9fb4bc5898afd29daa2f083de1dc" name="a436f9fb4bc5898afd29daa2f083de1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436f9fb4bc5898afd29daa2f083de1dc">&#9670;&#160;</a></span>_threshold_mgc_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._threshold_mgc_map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stat_mgc_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samp_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Finds a connected region of significance in the MGC-map by thresholding.

Parameters
----------
stat_mgc_map : ndarray
All local correlations within `[-1,1]`.
samp_size : int
The sample size of original data.

Returns
-------
sig_connect : ndarray
A binary matrix with 1's indicating the significant region.</pre> <div class="fragment"><div class="line"><span class="lineno"> 5827</span><span class="keyword">def </span>_threshold_mgc_map(stat_mgc_map, samp_size):</div>
<div class="line"><span class="lineno"> 5828</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5829</span><span class="stringliteral">    Finds a connected region of significance in the MGC-map by thresholding.</span></div>
<div class="line"><span class="lineno"> 5830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5831</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5832</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5833</span><span class="stringliteral">    stat_mgc_map : ndarray</span></div>
<div class="line"><span class="lineno"> 5834</span><span class="stringliteral">        All local correlations within `[-1,1]`.</span></div>
<div class="line"><span class="lineno"> 5835</span><span class="stringliteral">    samp_size : int</span></div>
<div class="line"><span class="lineno"> 5836</span><span class="stringliteral">        The sample size of original data.</span></div>
<div class="line"><span class="lineno"> 5837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5838</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5839</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5840</span><span class="stringliteral">    sig_connect : ndarray</span></div>
<div class="line"><span class="lineno"> 5841</span><span class="stringliteral">        A binary matrix with 1&#39;s indicating the significant region.</span></div>
<div class="line"><span class="lineno"> 5842</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5843</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5844</span>    m, n = stat_mgc_map.shape</div>
<div class="line"><span class="lineno"> 5845</span> </div>
<div class="line"><span class="lineno"> 5846</span>    <span class="comment"># 0.02 is simply an empirical threshold, this can be set to 0.01 or 0.05</span></div>
<div class="line"><span class="lineno"> 5847</span>    <span class="comment"># with varying levels of performance. Threshold is based on a beta</span></div>
<div class="line"><span class="lineno"> 5848</span>    <span class="comment"># approximation.</span></div>
<div class="line"><span class="lineno"> 5849</span>    per_sig = 1 - (0.02 / samp_size)  <span class="comment"># Percentile to consider as significant</span></div>
<div class="line"><span class="lineno"> 5850</span>    threshold = samp_size * (samp_size - 3)/4 - 1/2  <span class="comment"># Beta approximation</span></div>
<div class="line"><span class="lineno"> 5851</span>    threshold = distributions.beta.ppf(per_sig, threshold, threshold) * 2 - 1</div>
<div class="line"><span class="lineno"> 5852</span> </div>
<div class="line"><span class="lineno"> 5853</span>    <span class="comment"># the global scale at is the statistic calculated at maximial nearest</span></div>
<div class="line"><span class="lineno"> 5854</span>    <span class="comment"># neighbors. Threshold is the maximum on the global and local scales</span></div>
<div class="line"><span class="lineno"> 5855</span>    threshold = max(threshold, stat_mgc_map[m - 1][n - 1])</div>
<div class="line"><span class="lineno"> 5856</span> </div>
<div class="line"><span class="lineno"> 5857</span>    <span class="comment"># find the largest connected component of significant correlations</span></div>
<div class="line"><span class="lineno"> 5858</span>    sig_connect = stat_mgc_map &gt; threshold</div>
<div class="line"><span class="lineno"> 5859</span>    <span class="keywordflow">if</span> np.sum(sig_connect) &gt; 0:</div>
<div class="line"><span class="lineno"> 5860</span>        sig_connect, _ = _measurements.label(sig_connect)</div>
<div class="line"><span class="lineno"> 5861</span>        _, label_counts = np.unique(sig_connect, return_counts=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 5862</span> </div>
<div class="line"><span class="lineno"> 5863</span>        <span class="comment"># skip the first element in label_counts, as it is count(zeros)</span></div>
<div class="line"><span class="lineno"> 5864</span>        max_label = np.argmax(label_counts[1:]) + 1</div>
<div class="line"><span class="lineno"> 5865</span>        sig_connect = sig_connect == max_label</div>
<div class="line"><span class="lineno"> 5866</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5867</span>        sig_connect = np.array([[<span class="keyword">False</span>]])</div>
<div class="line"><span class="lineno"> 5868</span> </div>
<div class="line"><span class="lineno"> 5869</span>    <span class="keywordflow">return</span> sig_connect</div>
<div class="line"><span class="lineno"> 5870</span> </div>
<div class="line"><span class="lineno"> 5871</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a068fc003ca0623460250659b9421b133" name="a068fc003ca0623460250659b9421b133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068fc003ca0623460250659b9421b133">&#9670;&#160;</a></span>_ttest_finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._ttest_finish </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Common code between all 3 t-test functions.</pre> <div class="fragment"><div class="line"><span class="lineno"> 6087</span><span class="keyword">def </span>_ttest_finish(df, t, alternative):</div>
<div class="line"><span class="lineno"> 6088</span>    <span class="stringliteral">&quot;&quot;&quot;Common code between all 3 t-test functions.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6089</span>    <span class="comment"># We use ``stdtr`` directly here as it handles the case when ``nan``</span></div>
<div class="line"><span class="lineno"> 6090</span>    <span class="comment"># values are present in the data and masked arrays are passed</span></div>
<div class="line"><span class="lineno"> 6091</span>    <span class="comment"># while ``t.cdf`` emits runtime warnings. This way ``_ttest_finish``</span></div>
<div class="line"><span class="lineno"> 6092</span>    <span class="comment"># can be shared between the ``stats`` and ``mstats`` versions.</span></div>
<div class="line"><span class="lineno"> 6093</span> </div>
<div class="line"><span class="lineno"> 6094</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;less&#39;</span>:</div>
<div class="line"><span class="lineno"> 6095</span>        pval = special.stdtr(df, t)</div>
<div class="line"><span class="lineno"> 6096</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;greater&#39;</span>:</div>
<div class="line"><span class="lineno"> 6097</span>        pval = special.stdtr(df, -t)</div>
<div class="line"><span class="lineno"> 6098</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;two-sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 6099</span>        pval = special.stdtr(df, -np.abs(t))*2</div>
<div class="line"><span class="lineno"> 6100</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6101</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;alternative must be &quot;</span></div>
<div class="line"><span class="lineno"> 6102</span>                         <span class="stringliteral">&quot;&#39;less&#39;, &#39;greater&#39; or &#39;two-sided&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 6103</span> </div>
<div class="line"><span class="lineno"> 6104</span>    <span class="keywordflow">if</span> t.ndim == 0:</div>
<div class="line"><span class="lineno"> 6105</span>        t = t[()]</div>
<div class="line"><span class="lineno"> 6106</span>    <span class="keywordflow">if</span> pval.ndim == 0:</div>
<div class="line"><span class="lineno"> 6107</span>        pval = pval[()]</div>
<div class="line"><span class="lineno"> 6108</span> </div>
<div class="line"><span class="lineno"> 6109</span>    <span class="keywordflow">return</span> t, pval</div>
<div class="line"><span class="lineno"> 6110</span> </div>
<div class="line"><span class="lineno"> 6111</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d068bbda5a330aa2eeb320506a10c1a" name="a6d068bbda5a330aa2eeb320506a10c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d068bbda5a330aa2eeb320506a10c1a">&#9670;&#160;</a></span>_ttest_ind_from_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._ttest_ind_from_stats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6112</span><span class="keyword">def </span>_ttest_ind_from_stats(mean1, mean2, denom, df, alternative):</div>
<div class="line"><span class="lineno"> 6113</span> </div>
<div class="line"><span class="lineno"> 6114</span>    d = mean1 - mean2</div>
<div class="line"><span class="lineno"> 6115</span>    <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>, invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 6116</span>        t = np.divide(d, denom)</div>
<div class="line"><span class="lineno"> 6117</span>    t, prob = _ttest_finish(df, t, alternative)</div>
<div class="line"><span class="lineno"> 6118</span> </div>
<div class="line"><span class="lineno"> 6119</span>    <span class="keywordflow">return</span> (t, prob)</div>
<div class="line"><span class="lineno"> 6120</span> </div>
<div class="line"><span class="lineno"> 6121</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acb23641bb4cbf927aa5d747341d32012" name="acb23641bb4cbf927aa5d747341d32012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb23641bb4cbf927aa5d747341d32012">&#9670;&#160;</a></span>_ttest_nans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._ttest_nans </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namedtuple_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generate an array of `nan`, with shape determined by `a`, `b` and `axis`.

This function is used by ttest_ind and ttest_rel to create the return
value when one of the inputs has size 0.

The shapes of the arrays are determined by dropping `axis` from the
shapes of `a` and `b` and broadcasting what is left.

The return value is a named tuple of the type given in `namedtuple_type`.

Examples
--------
&gt;&gt;&gt; a = np.zeros((9, 2))
&gt;&gt;&gt; b = np.zeros((5, 1))
&gt;&gt;&gt; _ttest_nans(a, b, 0, Ttest_indResult)
Ttest_indResult(statistic=array([nan, nan]), pvalue=array([nan, nan]))

&gt;&gt;&gt; a = np.zeros((3, 0, 9))
&gt;&gt;&gt; b = np.zeros((1, 10))
&gt;&gt;&gt; stat, p = _ttest_nans(a, b, -1, Ttest_indResult)
&gt;&gt;&gt; stat
array([], shape=(3, 0), dtype=float64)
&gt;&gt;&gt; p
array([], shape=(3, 0), dtype=float64)

&gt;&gt;&gt; a = np.zeros(10)
&gt;&gt;&gt; b = np.zeros(7)
&gt;&gt;&gt; _ttest_nans(a, b, 0, Ttest_indResult)
Ttest_indResult(statistic=nan, pvalue=nan)</pre> <div class="fragment"><div class="line"><span class="lineno"> 6274</span><span class="keyword">def </span>_ttest_nans(a, b, axis, namedtuple_type):</div>
<div class="line"><span class="lineno"> 6275</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6276</span><span class="stringliteral">    Generate an array of `nan`, with shape determined by `a`, `b` and `axis`.</span></div>
<div class="line"><span class="lineno"> 6277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6278</span><span class="stringliteral">    This function is used by ttest_ind and ttest_rel to create the return</span></div>
<div class="line"><span class="lineno"> 6279</span><span class="stringliteral">    value when one of the inputs has size 0.</span></div>
<div class="line"><span class="lineno"> 6280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6281</span><span class="stringliteral">    The shapes of the arrays are determined by dropping `axis` from the</span></div>
<div class="line"><span class="lineno"> 6282</span><span class="stringliteral">    shapes of `a` and `b` and broadcasting what is left.</span></div>
<div class="line"><span class="lineno"> 6283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6284</span><span class="stringliteral">    The return value is a named tuple of the type given in `namedtuple_type`.</span></div>
<div class="line"><span class="lineno"> 6285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6286</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 6287</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 6288</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((9, 2))</span></div>
<div class="line"><span class="lineno"> 6289</span><span class="stringliteral">    &gt;&gt;&gt; b = np.zeros((5, 1))</span></div>
<div class="line"><span class="lineno"> 6290</span><span class="stringliteral">    &gt;&gt;&gt; _ttest_nans(a, b, 0, Ttest_indResult)</span></div>
<div class="line"><span class="lineno"> 6291</span><span class="stringliteral">    Ttest_indResult(statistic=array([nan, nan]), pvalue=array([nan, nan]))</span></div>
<div class="line"><span class="lineno"> 6292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6293</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((3, 0, 9))</span></div>
<div class="line"><span class="lineno"> 6294</span><span class="stringliteral">    &gt;&gt;&gt; b = np.zeros((1, 10))</span></div>
<div class="line"><span class="lineno"> 6295</span><span class="stringliteral">    &gt;&gt;&gt; stat, p = _ttest_nans(a, b, -1, Ttest_indResult)</span></div>
<div class="line"><span class="lineno"> 6296</span><span class="stringliteral">    &gt;&gt;&gt; stat</span></div>
<div class="line"><span class="lineno"> 6297</span><span class="stringliteral">    array([], shape=(3, 0), dtype=float64)</span></div>
<div class="line"><span class="lineno"> 6298</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 6299</span><span class="stringliteral">    array([], shape=(3, 0), dtype=float64)</span></div>
<div class="line"><span class="lineno"> 6300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6301</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros(10)</span></div>
<div class="line"><span class="lineno"> 6302</span><span class="stringliteral">    &gt;&gt;&gt; b = np.zeros(7)</span></div>
<div class="line"><span class="lineno"> 6303</span><span class="stringliteral">    &gt;&gt;&gt; _ttest_nans(a, b, 0, Ttest_indResult)</span></div>
<div class="line"><span class="lineno"> 6304</span><span class="stringliteral">    Ttest_indResult(statistic=nan, pvalue=nan)</span></div>
<div class="line"><span class="lineno"> 6305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6306</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6307</span>    shp = _broadcast_shapes_with_dropped_axis(a, b, axis)</div>
<div class="line"><span class="lineno"> 6308</span>    <span class="keywordflow">if</span> len(shp) == 0:</div>
<div class="line"><span class="lineno"> 6309</span>        t = np.nan</div>
<div class="line"><span class="lineno"> 6310</span>        p = np.nan</div>
<div class="line"><span class="lineno"> 6311</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6312</span>        t = np.full(shp, fill_value=np.nan)</div>
<div class="line"><span class="lineno"> 6313</span>        p = t.copy()</div>
<div class="line"><span class="lineno"> 6314</span>    <span class="keywordflow">return</span> namedtuple_type(t, p)</div>
<div class="line"><span class="lineno"> 6315</span> </div>
<div class="line"><span class="lineno"> 6316</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adbe82260a73fb8c647b4f542dd691b1c" name="adbe82260a73fb8c647b4f542dd691b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe82260a73fb8c647b4f542dd691b1c">&#9670;&#160;</a></span>_ttest_trim_var_mean_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._ttest_trim_var_mean_len </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Variance, mean, and length of winsorized input along specified axis</pre> <div class="fragment"><div class="line"><span class="lineno"> 6603</span><span class="keyword">def </span>_ttest_trim_var_mean_len(a, trim, axis):</div>
<div class="line"><span class="lineno"> 6604</span>    <span class="stringliteral">&quot;&quot;&quot;Variance, mean, and length of winsorized input along specified axis&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6605</span>    <span class="comment"># for use with `ttest_ind` when trimming.</span></div>
<div class="line"><span class="lineno"> 6606</span>    <span class="comment"># further calculations in this test assume that the inputs are sorted.</span></div>
<div class="line"><span class="lineno"> 6607</span>    <span class="comment"># From [4] Section 1 &quot;Let x_1, ..., x_n be n ordered observations...&quot;</span></div>
<div class="line"><span class="lineno"> 6608</span>    a = np.sort(a, axis=axis)</div>
<div class="line"><span class="lineno"> 6609</span> </div>
<div class="line"><span class="lineno"> 6610</span>    <span class="comment"># `g` is the number of elements to be replaced on each tail, converted</span></div>
<div class="line"><span class="lineno"> 6611</span>    <span class="comment"># from a percentage amount of trimming</span></div>
<div class="line"><span class="lineno"> 6612</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6613</span>    g = int(n * trim)</div>
<div class="line"><span class="lineno"> 6614</span> </div>
<div class="line"><span class="lineno"> 6615</span>    <span class="comment"># Calculate the Winsorized variance of the input samples according to</span></div>
<div class="line"><span class="lineno"> 6616</span>    <span class="comment"># specified `g`</span></div>
<div class="line"><span class="lineno"> 6617</span>    v = _calculate_winsorized_variance(a, g, axis)</div>
<div class="line"><span class="lineno"> 6618</span> </div>
<div class="line"><span class="lineno"> 6619</span>    <span class="comment"># the total number of elements in the trimmed samples</span></div>
<div class="line"><span class="lineno"> 6620</span>    n -= 2 * g</div>
<div class="line"><span class="lineno"> 6621</span> </div>
<div class="line"><span class="lineno"> 6622</span>    <span class="comment"># calculate the g-times trimmed mean, as defined in [4] (1-1)</span></div>
<div class="line"><span class="lineno"> 6623</span>    m = trim_mean(a, trim, axis=axis)</div>
<div class="line"><span class="lineno"> 6624</span>    <span class="keywordflow">return</span> v, m, n</div>
<div class="line"><span class="lineno"> 6625</span> </div>
<div class="line"><span class="lineno"> 6626</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b84fb54a29fcfd00875f50715d876dd" name="a8b84fb54a29fcfd00875f50715d876dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b84fb54a29fcfd00875f50715d876dd">&#9670;&#160;</a></span>_two_sample_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._two_sample_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function that concatenates x and y for two sample MGC stat.

See above for use.

Parameters
----------
u, v : ndarray
    `u` and `v` have shapes `(n, p)` and `(m, p)`.

Returns
-------
x : ndarray
    Concatenate `u` and `v` along the `axis = 0`. `x` thus has shape
    `(2n, p)`.
y : ndarray
    Label matrix for `x` where 0 refers to samples that comes from `u` and
    1 refers to samples that come from `v`. `y` thus has shape `(2n, 1)`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 5923</span><span class="keyword">def </span>_two_sample_transform(u, v):</div>
<div class="line"><span class="lineno"> 5924</span>    <span class="stringliteral">&quot;&quot;&quot;Helper function that concatenates x and y for two sample MGC stat.</span></div>
<div class="line"><span class="lineno"> 5925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5926</span><span class="stringliteral">    See above for use.</span></div>
<div class="line"><span class="lineno"> 5927</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5928</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5929</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5930</span><span class="stringliteral">    u, v : ndarray</span></div>
<div class="line"><span class="lineno"> 5931</span><span class="stringliteral">        `u` and `v` have shapes `(n, p)` and `(m, p)`.</span></div>
<div class="line"><span class="lineno"> 5932</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5933</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5934</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5935</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno"> 5936</span><span class="stringliteral">        Concatenate `u` and `v` along the `axis = 0`. `x` thus has shape</span></div>
<div class="line"><span class="lineno"> 5937</span><span class="stringliteral">        `(2n, p)`.</span></div>
<div class="line"><span class="lineno"> 5938</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno"> 5939</span><span class="stringliteral">        Label matrix for `x` where 0 refers to samples that comes from `u` and</span></div>
<div class="line"><span class="lineno"> 5940</span><span class="stringliteral">        1 refers to samples that come from `v`. `y` thus has shape `(2n, 1)`.</span></div>
<div class="line"><span class="lineno"> 5941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5942</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5943</span>    nx = u.shape[0]</div>
<div class="line"><span class="lineno"> 5944</span>    ny = v.shape[0]</div>
<div class="line"><span class="lineno"> 5945</span>    x = np.concatenate([u, v], axis=0)</div>
<div class="line"><span class="lineno"> 5946</span>    y = np.concatenate([np.zeros(nx), np.ones(ny)], axis=0).reshape(-1, 1)</div>
<div class="line"><span class="lineno"> 5947</span>    <span class="keywordflow">return</span> x, y</div>
<div class="line"><span class="lineno"> 5948</span> </div>
<div class="line"><span class="lineno"> 5949</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a705b5678e9a5ee4406cdfc24418527a7" name="a705b5678e9a5ee4406cdfc24418527a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b5678e9a5ee4406cdfc24418527a7">&#9670;&#160;</a></span>_unequal_var_ttest_denom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._unequal_var_ttest_denom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6122</span><span class="keyword">def </span>_unequal_var_ttest_denom(v1, n1, v2, n2):</div>
<div class="line"><span class="lineno"> 6123</span>    vn1 = v1 / n1</div>
<div class="line"><span class="lineno"> 6124</span>    vn2 = v2 / n2</div>
<div class="line"><span class="lineno"> 6125</span>    <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>, invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 6126</span>        df = (vn1 + vn2)**2 / (vn1**2 / (n1 - 1) + vn2**2 / (n2 - 1))</div>
<div class="line"><span class="lineno"> 6127</span> </div>
<div class="line"><span class="lineno"> 6128</span>    <span class="comment"># If df is undefined, variances are zero (assumes n1 &gt; 0 &amp; n2 &gt; 0).</span></div>
<div class="line"><span class="lineno"> 6129</span>    <span class="comment"># Hence it doesn&#39;t matter what df is as long as it&#39;s not NaN.</span></div>
<div class="line"><span class="lineno"> 6130</span>    df = np.where(np.isnan(df), 1, df)</div>
<div class="line"><span class="lineno"> 6131</span>    denom = np.sqrt(vn1 + vn2)</div>
<div class="line"><span class="lineno"> 6132</span>    <span class="keywordflow">return</span> df, denom</div>
<div class="line"><span class="lineno"> 6133</span> </div>
<div class="line"><span class="lineno"> 6134</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5946b7785fb379d1de1cc47b0b338faf" name="a5946b7785fb379d1de1cc47b0b338faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5946b7785fb379d1de1cc47b0b338faf">&#9670;&#160;</a></span>_validate_distribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._validate_distribution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validate the values and weights from a distribution input of `cdf_distance`
and return them as ndarray objects.

Parameters
----------
values : array_like
    Values observed in the (empirical) distribution.
weights : array_like
    Weight for each value.

Returns
-------
values : ndarray
    Values as ndarray.
weights : ndarray
    Weights as ndarray.</pre> <div class="fragment"><div class="line"><span class="lineno"> 8925</span><span class="keyword">def </span>_validate_distribution(values, weights):</div>
<div class="line"><span class="lineno"> 8926</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8927</span><span class="stringliteral">    Validate the values and weights from a distribution input of `cdf_distance`</span></div>
<div class="line"><span class="lineno"> 8928</span><span class="stringliteral">    and return them as ndarray objects.</span></div>
<div class="line"><span class="lineno"> 8929</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8930</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8931</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8932</span><span class="stringliteral">    values : array_like</span></div>
<div class="line"><span class="lineno"> 8933</span><span class="stringliteral">        Values observed in the (empirical) distribution.</span></div>
<div class="line"><span class="lineno"> 8934</span><span class="stringliteral">    weights : array_like</span></div>
<div class="line"><span class="lineno"> 8935</span><span class="stringliteral">        Weight for each value.</span></div>
<div class="line"><span class="lineno"> 8936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8937</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8938</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8939</span><span class="stringliteral">    values : ndarray</span></div>
<div class="line"><span class="lineno"> 8940</span><span class="stringliteral">        Values as ndarray.</span></div>
<div class="line"><span class="lineno"> 8941</span><span class="stringliteral">    weights : ndarray</span></div>
<div class="line"><span class="lineno"> 8942</span><span class="stringliteral">        Weights as ndarray.</span></div>
<div class="line"><span class="lineno"> 8943</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8944</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8945</span>    <span class="comment"># Validate the value array.</span></div>
<div class="line"><span class="lineno"> 8946</span>    values = np.asarray(values, dtype=float)</div>
<div class="line"><span class="lineno"> 8947</span>    <span class="keywordflow">if</span> len(values) == 0:</div>
<div class="line"><span class="lineno"> 8948</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Distribution can&#39;t be empty.&quot;</span>)</div>
<div class="line"><span class="lineno"> 8949</span> </div>
<div class="line"><span class="lineno"> 8950</span>    <span class="comment"># Validate the weight array, if specified.</span></div>
<div class="line"><span class="lineno"> 8951</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 8952</span>        weights = np.asarray(weights, dtype=float)</div>
<div class="line"><span class="lineno"> 8953</span>        <span class="keywordflow">if</span> len(weights) != len(values):</div>
<div class="line"><span class="lineno"> 8954</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Value and weight array-likes for the same &#39;</span></div>
<div class="line"><span class="lineno"> 8955</span>                             <span class="stringliteral">&#39;empirical distribution must be of the same size.&#39;</span>)</div>
<div class="line"><span class="lineno"> 8956</span>        <span class="keywordflow">if</span> np.any(weights &lt; 0):</div>
<div class="line"><span class="lineno"> 8957</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;All weights must be non-negative.&#39;</span>)</div>
<div class="line"><span class="lineno"> 8958</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> 0 &lt; np.sum(weights) &lt; np.inf:</div>
<div class="line"><span class="lineno"> 8959</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Weight array-like sum must be positive and &#39;</span></div>
<div class="line"><span class="lineno"> 8960</span>                             <span class="stringliteral">&#39;finite. Set as None for an equal distribution of &#39;</span></div>
<div class="line"><span class="lineno"> 8961</span>                             <span class="stringliteral">&#39;weight.&#39;</span>)</div>
<div class="line"><span class="lineno"> 8962</span> </div>
<div class="line"><span class="lineno"> 8963</span>        <span class="keywordflow">return</span> values, weights</div>
<div class="line"><span class="lineno"> 8964</span> </div>
<div class="line"><span class="lineno"> 8965</span>    <span class="keywordflow">return</span> values, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 8966</span> </div>
<div class="line"><span class="lineno"> 8967</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f8cb83384c519dcefbf564456fe81dd" name="a9f8cb83384c519dcefbf564456fe81dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8cb83384c519dcefbf564456fe81dd">&#9670;&#160;</a></span>_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py._var </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mean</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1248</span><span class="keyword">def </span>_var(x, axis=0, ddof=0, mean=None):</div>
<div class="line"><span class="lineno"> 1249</span>    <span class="comment"># Calculate variance of sample, warning if precision is lost</span></div>
<div class="line"><span class="lineno"> 1250</span>    var = _moment(x, 2, axis, mean=mean)</div>
<div class="line"><span class="lineno"> 1251</span>    <span class="keywordflow">if</span> ddof != 0:</div>
<div class="line"><span class="lineno"> 1252</span>        n = x.shape[axis] <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> x.size</div>
<div class="line"><span class="lineno"> 1253</span>        var *= np.divide(n, n-ddof)  <span class="comment"># to avoid error on division by zero</span></div>
<div class="line"><span class="lineno"> 1254</span>    <span class="keywordflow">return</span> var</div>
<div class="line"><span class="lineno"> 1255</span> </div>
<div class="line"><span class="lineno"> 1256</span> </div>
<div class="line"><span class="lineno"> 1257</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno"> 1258</span>    <span class="keyword">lambda</span> x: x, result_to_tuple=<span class="keyword">lambda</span> x: (x,), n_outputs=1</div>
<div class="line"><span class="lineno"> 1259</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a25a76cb8c69e3c610d9e9c69fc54e9b9" name="a25a76cb8c69e3c610d9e9c69fc54e9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a76cb8c69e3c610d9e9c69fc54e9b9">&#9670;&#160;</a></span>alexandergovern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.alexandergovern </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the Alexander Govern test.

The Alexander-Govern approximation tests the equality of k independent
means in the face of heterogeneity of variance. The test is applied to
samples from two or more groups, possibly with differing sizes.

Parameters
----------
sample1, sample2, ... : array_like
    The sample measurements for each group.  There must be at least
    two samples.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

Returns
-------
statistic : float
    The computed A statistic of the test.
pvalue : float
    The associated p-value from the chi-squared distribution.

Warns
-----
`~scipy.stats.ConstantInputWarning`
    Raised if an input is a constant array.  The statistic is not defined
    in this case, so ``np.nan`` is returned.

See Also
--------
f_oneway : one-way ANOVA

Notes
-----
The use of this test relies on several assumptions.

1. The samples are independent.
2. Each sample is from a normally distributed population.
3. Unlike `f_oneway`, this test does not assume on homoscedasticity,
   instead relaxing the assumption of equal variances.

Input samples must be finite, one dimensional, and with size greater than
one.

References
----------
.. [1] Alexander, Ralph A., and Diane M. Govern. "A New and Simpler
       Approximation for ANOVA under Variance Heterogeneity." Journal
       of Educational Statistics, vol. 19, no. 2, 1994, pp. 91-101.
       JSTOR, www.jstor.org/stable/1165140. Accessed 12 Sept. 2020.

Examples
--------
&gt;&gt;&gt; from scipy.stats import alexandergovern

Here are some data on annual percentage rate of interest charged on
new car loans at nine of the largest banks in four American cities
taken from the National Institute of Standards and Technology's
ANOVA dataset.

We use `alexandergovern` to test the null hypothesis that all cities
have the same mean APR against the alternative that the cities do not
all have the same mean APR. We decide that a significance level of 5%
is required to reject the null hypothesis in favor of the alternative.

&gt;&gt;&gt; atlanta = [13.75, 13.75, 13.5, 13.5, 13.0, 13.0, 13.0, 12.75, 12.5]
&gt;&gt;&gt; chicago = [14.25, 13.0, 12.75, 12.5, 12.5, 12.4, 12.3, 11.9, 11.9]
&gt;&gt;&gt; houston = [14.0, 14.0, 13.51, 13.5, 13.5, 13.25, 13.0, 12.5, 12.5]
&gt;&gt;&gt; memphis = [15.0, 14.0, 13.75, 13.59, 13.25, 12.97, 12.5, 12.25,
...           11.89]
&gt;&gt;&gt; alexandergovern(atlanta, chicago, houston, memphis)
AlexanderGovernResult(statistic=4.65087071883494,
                      pvalue=0.19922132490385214)

The p-value is 0.1992, indicating a nearly 20% chance of observing
such an extreme value of the test statistic under the null hypothesis.
This exceeds 5%, so we do not reject the null hypothesis in favor of
the alternative.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3959</span><span class="keyword">def </span>alexandergovern(*samples, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 3960</span>    <span class="stringliteral">&quot;&quot;&quot;Performs the Alexander Govern test.</span></div>
<div class="line"><span class="lineno"> 3961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3962</span><span class="stringliteral">    The Alexander-Govern approximation tests the equality of k independent</span></div>
<div class="line"><span class="lineno"> 3963</span><span class="stringliteral">    means in the face of heterogeneity of variance. The test is applied to</span></div>
<div class="line"><span class="lineno"> 3964</span><span class="stringliteral">    samples from two or more groups, possibly with differing sizes.</span></div>
<div class="line"><span class="lineno"> 3965</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3966</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3967</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3968</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 3969</span><span class="stringliteral">        The sample measurements for each group.  There must be at least</span></div>
<div class="line"><span class="lineno"> 3970</span><span class="stringliteral">        two samples.</span></div>
<div class="line"><span class="lineno"> 3971</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3972</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 3973</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 3974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3975</span><span class="stringliteral">        * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 3976</span><span class="stringliteral">        * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 3977</span><span class="stringliteral">        * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 3978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3979</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3980</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3981</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 3982</span><span class="stringliteral">        The computed A statistic of the test.</span></div>
<div class="line"><span class="lineno"> 3983</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 3984</span><span class="stringliteral">        The associated p-value from the chi-squared distribution.</span></div>
<div class="line"><span class="lineno"> 3985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3986</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno"> 3987</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3988</span><span class="stringliteral">    `~scipy.stats.ConstantInputWarning`</span></div>
<div class="line"><span class="lineno"> 3989</span><span class="stringliteral">        Raised if an input is a constant array.  The statistic is not defined</span></div>
<div class="line"><span class="lineno"> 3990</span><span class="stringliteral">        in this case, so ``np.nan`` is returned.</span></div>
<div class="line"><span class="lineno"> 3991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3992</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3993</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3994</span><span class="stringliteral">    f_oneway : one-way ANOVA</span></div>
<div class="line"><span class="lineno"> 3995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3996</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3997</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3998</span><span class="stringliteral">    The use of this test relies on several assumptions.</span></div>
<div class="line"><span class="lineno"> 3999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4000</span><span class="stringliteral">    1. The samples are independent.</span></div>
<div class="line"><span class="lineno"> 4001</span><span class="stringliteral">    2. Each sample is from a normally distributed population.</span></div>
<div class="line"><span class="lineno"> 4002</span><span class="stringliteral">    3. Unlike `f_oneway`, this test does not assume on homoscedasticity,</span></div>
<div class="line"><span class="lineno"> 4003</span><span class="stringliteral">       instead relaxing the assumption of equal variances.</span></div>
<div class="line"><span class="lineno"> 4004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4005</span><span class="stringliteral">    Input samples must be finite, one dimensional, and with size greater than</span></div>
<div class="line"><span class="lineno"> 4006</span><span class="stringliteral">    one.</span></div>
<div class="line"><span class="lineno"> 4007</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4008</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 4009</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4010</span><span class="stringliteral">    .. [1] Alexander, Ralph A., and Diane M. Govern. &quot;A New and Simpler</span></div>
<div class="line"><span class="lineno"> 4011</span><span class="stringliteral">           Approximation for ANOVA under Variance Heterogeneity.&quot; Journal</span></div>
<div class="line"><span class="lineno"> 4012</span><span class="stringliteral">           of Educational Statistics, vol. 19, no. 2, 1994, pp. 91-101.</span></div>
<div class="line"><span class="lineno"> 4013</span><span class="stringliteral">           JSTOR, www.jstor.org/stable/1165140. Accessed 12 Sept. 2020.</span></div>
<div class="line"><span class="lineno"> 4014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4015</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4016</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4017</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import alexandergovern</span></div>
<div class="line"><span class="lineno"> 4018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4019</span><span class="stringliteral">    Here are some data on annual percentage rate of interest charged on</span></div>
<div class="line"><span class="lineno"> 4020</span><span class="stringliteral">    new car loans at nine of the largest banks in four American cities</span></div>
<div class="line"><span class="lineno"> 4021</span><span class="stringliteral">    taken from the National Institute of Standards and Technology&#39;s</span></div>
<div class="line"><span class="lineno"> 4022</span><span class="stringliteral">    ANOVA dataset.</span></div>
<div class="line"><span class="lineno"> 4023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4024</span><span class="stringliteral">    We use `alexandergovern` to test the null hypothesis that all cities</span></div>
<div class="line"><span class="lineno"> 4025</span><span class="stringliteral">    have the same mean APR against the alternative that the cities do not</span></div>
<div class="line"><span class="lineno"> 4026</span><span class="stringliteral">    all have the same mean APR. We decide that a significance level of 5%</span></div>
<div class="line"><span class="lineno"> 4027</span><span class="stringliteral">    is required to reject the null hypothesis in favor of the alternative.</span></div>
<div class="line"><span class="lineno"> 4028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4029</span><span class="stringliteral">    &gt;&gt;&gt; atlanta = [13.75, 13.75, 13.5, 13.5, 13.0, 13.0, 13.0, 12.75, 12.5]</span></div>
<div class="line"><span class="lineno"> 4030</span><span class="stringliteral">    &gt;&gt;&gt; chicago = [14.25, 13.0, 12.75, 12.5, 12.5, 12.4, 12.3, 11.9, 11.9]</span></div>
<div class="line"><span class="lineno"> 4031</span><span class="stringliteral">    &gt;&gt;&gt; houston = [14.0, 14.0, 13.51, 13.5, 13.5, 13.25, 13.0, 12.5, 12.5]</span></div>
<div class="line"><span class="lineno"> 4032</span><span class="stringliteral">    &gt;&gt;&gt; memphis = [15.0, 14.0, 13.75, 13.59, 13.25, 12.97, 12.5, 12.25,</span></div>
<div class="line"><span class="lineno"> 4033</span><span class="stringliteral">    ...           11.89]</span></div>
<div class="line"><span class="lineno"> 4034</span><span class="stringliteral">    &gt;&gt;&gt; alexandergovern(atlanta, chicago, houston, memphis)</span></div>
<div class="line"><span class="lineno"> 4035</span><span class="stringliteral">    AlexanderGovernResult(statistic=4.65087071883494,</span></div>
<div class="line"><span class="lineno"> 4036</span><span class="stringliteral">                          pvalue=0.19922132490385214)</span></div>
<div class="line"><span class="lineno"> 4037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4038</span><span class="stringliteral">    The p-value is 0.1992, indicating a nearly 20% chance of observing</span></div>
<div class="line"><span class="lineno"> 4039</span><span class="stringliteral">    such an extreme value of the test statistic under the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 4040</span><span class="stringliteral">    This exceeds 5%, so we do not reject the null hypothesis in favor of</span></div>
<div class="line"><span class="lineno"> 4041</span><span class="stringliteral">    the alternative.</span></div>
<div class="line"><span class="lineno"> 4042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4043</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4044</span>    samples = _alexandergovern_input_validation(samples, nan_policy)</div>
<div class="line"><span class="lineno"> 4045</span> </div>
<div class="line"><span class="lineno"> 4046</span>    <span class="keywordflow">if</span> np.any([(sample == sample[0]).all() <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples]):</div>
<div class="line"><span class="lineno"> 4047</span>        msg = <span class="stringliteral">&quot;An input array is constant; the statistic is not defined.&quot;</span></div>
<div class="line"><span class="lineno"> 4048</span>        warnings.warn(stats.ConstantInputWarning(msg))</div>
<div class="line"><span class="lineno"> 4049</span>        <span class="keywordflow">return</span> AlexanderGovernResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 4050</span> </div>
<div class="line"><span class="lineno"> 4051</span>    <span class="comment"># The following formula numbers reference the equation described on</span></div>
<div class="line"><span class="lineno"> 4052</span>    <span class="comment"># page 92 by Alexander, Govern. Formulas 5, 6, and 7 describe other</span></div>
<div class="line"><span class="lineno"> 4053</span>    <span class="comment"># tests that serve as the basis for equation (8) but are not needed</span></div>
<div class="line"><span class="lineno"> 4054</span>    <span class="comment"># to perform the test.</span></div>
<div class="line"><span class="lineno"> 4055</span> </div>
<div class="line"><span class="lineno"> 4056</span>    <span class="comment"># precalculate mean and length of each sample</span></div>
<div class="line"><span class="lineno"> 4057</span>    lengths = np.array([ma.count(sample) <span class="keywordflow">if</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span></div>
<div class="line"><span class="lineno"> 4058</span>                        <span class="keywordflow">else</span> len(sample) <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples])</div>
<div class="line"><span class="lineno"> 4059</span>    means = np.array([np.mean(sample) <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples])</div>
<div class="line"><span class="lineno"> 4060</span> </div>
<div class="line"><span class="lineno"> 4061</span>    <span class="comment"># (1) determine standard error of the mean for each sample</span></div>
<div class="line"><span class="lineno"> 4062</span>    standard_errors = [np.std(sample, ddof=1) / np.sqrt(length)</div>
<div class="line"><span class="lineno"> 4063</span>                       <span class="keywordflow">for</span> sample, length <span class="keywordflow">in</span> zip(samples, lengths)]</div>
<div class="line"><span class="lineno"> 4064</span> </div>
<div class="line"><span class="lineno"> 4065</span>    <span class="comment"># (2) define a weight for each sample</span></div>
<div class="line"><span class="lineno"> 4066</span>    inv_sq_se = 1 / np.square(standard_errors)</div>
<div class="line"><span class="lineno"> 4067</span>    weights = inv_sq_se / np.sum(inv_sq_se)</div>
<div class="line"><span class="lineno"> 4068</span> </div>
<div class="line"><span class="lineno"> 4069</span>    <span class="comment"># (3) determine variance-weighted estimate of the common mean</span></div>
<div class="line"><span class="lineno"> 4070</span>    var_w = np.sum(weights * means)</div>
<div class="line"><span class="lineno"> 4071</span> </div>
<div class="line"><span class="lineno"> 4072</span>    <span class="comment"># (4) determine one-sample t statistic for each group</span></div>
<div class="line"><span class="lineno"> 4073</span>    t_stats = (means - var_w)/standard_errors</div>
<div class="line"><span class="lineno"> 4074</span> </div>
<div class="line"><span class="lineno"> 4075</span>    <span class="comment"># calculate parameters to be used in transformation</span></div>
<div class="line"><span class="lineno"> 4076</span>    v = lengths - 1</div>
<div class="line"><span class="lineno"> 4077</span>    a = v - .5</div>
<div class="line"><span class="lineno"> 4078</span>    b = 48 * a**2</div>
<div class="line"><span class="lineno"> 4079</span>    c = (a * np.log(1 + (t_stats ** 2)/v))**.5</div>
<div class="line"><span class="lineno"> 4080</span> </div>
<div class="line"><span class="lineno"> 4081</span>    <span class="comment"># (8) perform a normalizing transformation on t statistic</span></div>
<div class="line"><span class="lineno"> 4082</span>    z = (c + ((c**3 + 3*c)/b) -</div>
<div class="line"><span class="lineno"> 4083</span>         ((4*c**7 + 33*c**5 + 240*c**3 + 855*c) /</div>
<div class="line"><span class="lineno"> 4084</span>          (b**2*10 + 8*b*c**4 + 1000*b)))</div>
<div class="line"><span class="lineno"> 4085</span> </div>
<div class="line"><span class="lineno"> 4086</span>    <span class="comment"># (9) calculate statistic</span></div>
<div class="line"><span class="lineno"> 4087</span>    A = np.sum(np.square(z))</div>
<div class="line"><span class="lineno"> 4088</span> </div>
<div class="line"><span class="lineno"> 4089</span>    <span class="comment"># &quot;[the p value is determined from] central chi-square random deviates</span></div>
<div class="line"><span class="lineno"> 4090</span>    <span class="comment"># with k - 1 degrees of freedom&quot;. Alexander, Govern (94)</span></div>
<div class="line"><span class="lineno"> 4091</span>    p = distributions.chi2.sf(A, len(samples) - 1)</div>
<div class="line"><span class="lineno"> 4092</span>    <span class="keywordflow">return</span> AlexanderGovernResult(A, p)</div>
<div class="line"><span class="lineno"> 4093</span> </div>
<div class="line"><span class="lineno"> 4094</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a61540456aa6cd16b909618e175d798f9" name="a61540456aa6cd16b909618e175d798f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61540456aa6cd16b909618e175d798f9">&#9670;&#160;</a></span>brunnermunzel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.brunnermunzel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distribution</em> = <code>&quot;t&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Brunner-Munzel test on samples x and y.

The Brunner-Munzel test is a nonparametric test of the null hypothesis that
when values are taken one by one from each group, the probabilities of
getting large values in both groups are equal.
Unlike the Wilcoxon-Mann-Whitney's U test, this does not require the
assumption of equivariance of two groups. Note that this does not assume
the distributions are same. This test works on two independent samples,
which may have different sizes.

Parameters
----------
x, y : array_like
    Array of samples, should be one-dimensional.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

      * 'two-sided'
      * 'less': one-sided
      * 'greater': one-sided
distribution : {'t', 'normal'}, optional
    Defines how to get the p-value.
    The following options are available (default is 't'):

      * 't': get the p-value by t-distribution
      * 'normal': get the p-value by standard normal distribution.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
statistic : float
    The Brunner-Munzer W statistic.
pvalue : float
    p-value assuming an t distribution. One-sided or
    two-sided, depending on the choice of `alternative` and `distribution`.

See Also
--------
mannwhitneyu : Mann-Whitney rank test on two samples.

Notes
-----
Brunner and Munzel recommended to estimate the p-value by t-distribution
when the size of data is 50 or less. If the size is lower than 10, it would
be better to use permuted Brunner Munzel test (see [2]_).

References
----------
.. [1] Brunner, E. and Munzel, U. "The nonparametric Benhrens-Fisher
       problem: Asymptotic theory and a small-sample approximation".
       Biometrical Journal. Vol. 42(2000): 17-25.
.. [2] Neubert, K. and Brunner, E. "A studentized permutation test for the
       non-parametric Behrens-Fisher problem". Computational Statistics and
       Data Analysis. Vol. 51(2007): 5192-5204.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x1 = [1,2,1,1,1,1,1,1,1,1,2,4,1,1]
&gt;&gt;&gt; x2 = [3,3,4,3,1,2,3,1,1,5,4]
&gt;&gt;&gt; w, p_value = stats.brunnermunzel(x1, x2)
&gt;&gt;&gt; w
3.1374674823029505
&gt;&gt;&gt; p_value
0.0057862086661515377</pre> <div class="fragment"><div class="line"><span class="lineno"> 8382</span>                  nan_policy=<span class="stringliteral">&#39;propagate&#39;</span>):</div>
<div class="line"><span class="lineno"> 8383</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the Brunner-Munzel test on samples x and y.</span></div>
<div class="line"><span class="lineno"> 8384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8385</span><span class="stringliteral">    The Brunner-Munzel test is a nonparametric test of the null hypothesis that</span></div>
<div class="line"><span class="lineno"> 8386</span><span class="stringliteral">    when values are taken one by one from each group, the probabilities of</span></div>
<div class="line"><span class="lineno"> 8387</span><span class="stringliteral">    getting large values in both groups are equal.</span></div>
<div class="line"><span class="lineno"> 8388</span><span class="stringliteral">    Unlike the Wilcoxon-Mann-Whitney&#39;s U test, this does not require the</span></div>
<div class="line"><span class="lineno"> 8389</span><span class="stringliteral">    assumption of equivariance of two groups. Note that this does not assume</span></div>
<div class="line"><span class="lineno"> 8390</span><span class="stringliteral">    the distributions are same. This test works on two independent samples,</span></div>
<div class="line"><span class="lineno"> 8391</span><span class="stringliteral">    which may have different sizes.</span></div>
<div class="line"><span class="lineno"> 8392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8393</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8394</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8395</span><span class="stringliteral">    x, y : array_like</span></div>
<div class="line"><span class="lineno"> 8396</span><span class="stringliteral">        Array of samples, should be one-dimensional.</span></div>
<div class="line"><span class="lineno"> 8397</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 8398</span><span class="stringliteral">        Defines the alternative hypothesis.</span></div>
<div class="line"><span class="lineno"> 8399</span><span class="stringliteral">        The following options are available (default is &#39;two-sided&#39;):</span></div>
<div class="line"><span class="lineno"> 8400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8401</span><span class="stringliteral">          * &#39;two-sided&#39;</span></div>
<div class="line"><span class="lineno"> 8402</span><span class="stringliteral">          * &#39;less&#39;: one-sided</span></div>
<div class="line"><span class="lineno"> 8403</span><span class="stringliteral">          * &#39;greater&#39;: one-sided</span></div>
<div class="line"><span class="lineno"> 8404</span><span class="stringliteral">    distribution : {&#39;t&#39;, &#39;normal&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 8405</span><span class="stringliteral">        Defines how to get the p-value.</span></div>
<div class="line"><span class="lineno"> 8406</span><span class="stringliteral">        The following options are available (default is &#39;t&#39;):</span></div>
<div class="line"><span class="lineno"> 8407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8408</span><span class="stringliteral">          * &#39;t&#39;: get the p-value by t-distribution</span></div>
<div class="line"><span class="lineno"> 8409</span><span class="stringliteral">          * &#39;normal&#39;: get the p-value by standard normal distribution.</span></div>
<div class="line"><span class="lineno"> 8410</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 8411</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 8412</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 8413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8414</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 8415</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 8416</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 8417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8418</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8419</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8420</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 8421</span><span class="stringliteral">        The Brunner-Munzer W statistic.</span></div>
<div class="line"><span class="lineno"> 8422</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 8423</span><span class="stringliteral">        p-value assuming an t distribution. One-sided or</span></div>
<div class="line"><span class="lineno"> 8424</span><span class="stringliteral">        two-sided, depending on the choice of `alternative` and `distribution`.</span></div>
<div class="line"><span class="lineno"> 8425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8426</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 8427</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8428</span><span class="stringliteral">    mannwhitneyu : Mann-Whitney rank test on two samples.</span></div>
<div class="line"><span class="lineno"> 8429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8430</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8431</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8432</span><span class="stringliteral">    Brunner and Munzel recommended to estimate the p-value by t-distribution</span></div>
<div class="line"><span class="lineno"> 8433</span><span class="stringliteral">    when the size of data is 50 or less. If the size is lower than 10, it would</span></div>
<div class="line"><span class="lineno"> 8434</span><span class="stringliteral">    be better to use permuted Brunner Munzel test (see [2]_).</span></div>
<div class="line"><span class="lineno"> 8435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8436</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8437</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8438</span><span class="stringliteral">    .. [1] Brunner, E. and Munzel, U. &quot;The nonparametric Benhrens-Fisher</span></div>
<div class="line"><span class="lineno"> 8439</span><span class="stringliteral">           problem: Asymptotic theory and a small-sample approximation&quot;.</span></div>
<div class="line"><span class="lineno"> 8440</span><span class="stringliteral">           Biometrical Journal. Vol. 42(2000): 17-25.</span></div>
<div class="line"><span class="lineno"> 8441</span><span class="stringliteral">    .. [2] Neubert, K. and Brunner, E. &quot;A studentized permutation test for the</span></div>
<div class="line"><span class="lineno"> 8442</span><span class="stringliteral">           non-parametric Behrens-Fisher problem&quot;. Computational Statistics and</span></div>
<div class="line"><span class="lineno"> 8443</span><span class="stringliteral">           Data Analysis. Vol. 51(2007): 5192-5204.</span></div>
<div class="line"><span class="lineno"> 8444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8445</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 8446</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8447</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 8448</span><span class="stringliteral">    &gt;&gt;&gt; x1 = [1,2,1,1,1,1,1,1,1,1,2,4,1,1]</span></div>
<div class="line"><span class="lineno"> 8449</span><span class="stringliteral">    &gt;&gt;&gt; x2 = [3,3,4,3,1,2,3,1,1,5,4]</span></div>
<div class="line"><span class="lineno"> 8450</span><span class="stringliteral">    &gt;&gt;&gt; w, p_value = stats.brunnermunzel(x1, x2)</span></div>
<div class="line"><span class="lineno"> 8451</span><span class="stringliteral">    &gt;&gt;&gt; w</span></div>
<div class="line"><span class="lineno"> 8452</span><span class="stringliteral">    3.1374674823029505</span></div>
<div class="line"><span class="lineno"> 8453</span><span class="stringliteral">    &gt;&gt;&gt; p_value</span></div>
<div class="line"><span class="lineno"> 8454</span><span class="stringliteral">    0.0057862086661515377</span></div>
<div class="line"><span class="lineno"> 8455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8456</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8457</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 8458</span>    y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 8459</span> </div>
<div class="line"><span class="lineno"> 8460</span>    <span class="comment"># check both x and y</span></div>
<div class="line"><span class="lineno"> 8461</span>    cnx, npx = _contains_nan(x, nan_policy)</div>
<div class="line"><span class="lineno"> 8462</span>    cny, npy = _contains_nan(y, nan_policy)</div>
<div class="line"><span class="lineno"> 8463</span>    contains_nan = cnx <span class="keywordflow">or</span> cny</div>
<div class="line"><span class="lineno"> 8464</span>    <span class="keywordflow">if</span> npx == <span class="stringliteral">&quot;omit&quot;</span> <span class="keywordflow">or</span> npy == <span class="stringliteral">&quot;omit&quot;</span>:</div>
<div class="line"><span class="lineno"> 8465</span>        nan_policy = <span class="stringliteral">&quot;omit&quot;</span></div>
<div class="line"><span class="lineno"> 8466</span> </div>
<div class="line"><span class="lineno"> 8467</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&quot;propagate&quot;</span>:</div>
<div class="line"><span class="lineno"> 8468</span>        <span class="keywordflow">return</span> BrunnerMunzelResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 8469</span>    <span class="keywordflow">elif</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&quot;omit&quot;</span>:</div>
<div class="line"><span class="lineno"> 8470</span>        x = ma.masked_invalid(x)</div>
<div class="line"><span class="lineno"> 8471</span>        y = ma.masked_invalid(y)</div>
<div class="line"><span class="lineno"> 8472</span>        <span class="keywordflow">return</span> mstats_basic.brunnermunzel(x, y, alternative, distribution)</div>
<div class="line"><span class="lineno"> 8473</span> </div>
<div class="line"><span class="lineno"> 8474</span>    nx = len(x)</div>
<div class="line"><span class="lineno"> 8475</span>    ny = len(y)</div>
<div class="line"><span class="lineno"> 8476</span>    <span class="keywordflow">if</span> nx == 0 <span class="keywordflow">or</span> ny == 0:</div>
<div class="line"><span class="lineno"> 8477</span>        <span class="keywordflow">return</span> BrunnerMunzelResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 8478</span>    rankc = rankdata(np.concatenate((x, y)))</div>
<div class="line"><span class="lineno"> 8479</span>    rankcx = rankc[0:nx]</div>
<div class="line"><span class="lineno"> 8480</span>    rankcy = rankc[nx:nx+ny]</div>
<div class="line"><span class="lineno"> 8481</span>    rankcx_mean = np.mean(rankcx)</div>
<div class="line"><span class="lineno"> 8482</span>    rankcy_mean = np.mean(rankcy)</div>
<div class="line"><span class="lineno"> 8483</span>    rankx = rankdata(x)</div>
<div class="line"><span class="lineno"> 8484</span>    ranky = rankdata(y)</div>
<div class="line"><span class="lineno"> 8485</span>    rankx_mean = np.mean(rankx)</div>
<div class="line"><span class="lineno"> 8486</span>    ranky_mean = np.mean(ranky)</div>
<div class="line"><span class="lineno"> 8487</span> </div>
<div class="line"><span class="lineno"> 8488</span>    Sx = np.sum(np.power(rankcx - rankx - rankcx_mean + rankx_mean, 2.0))</div>
<div class="line"><span class="lineno"> 8489</span>    Sx /= nx - 1</div>
<div class="line"><span class="lineno"> 8490</span>    Sy = np.sum(np.power(rankcy - ranky - rankcy_mean + ranky_mean, 2.0))</div>
<div class="line"><span class="lineno"> 8491</span>    Sy /= ny - 1</div>
<div class="line"><span class="lineno"> 8492</span> </div>
<div class="line"><span class="lineno"> 8493</span>    wbfn = nx * ny * (rankcy_mean - rankcx_mean)</div>
<div class="line"><span class="lineno"> 8494</span>    wbfn /= (nx + ny) * np.sqrt(nx * Sx + ny * Sy)</div>
<div class="line"><span class="lineno"> 8495</span> </div>
<div class="line"><span class="lineno"> 8496</span>    <span class="keywordflow">if</span> distribution == <span class="stringliteral">&quot;t&quot;</span>:</div>
<div class="line"><span class="lineno"> 8497</span>        df_numer = np.power(nx * Sx + ny * Sy, 2.0)</div>
<div class="line"><span class="lineno"> 8498</span>        df_denom = np.power(nx * Sx, 2.0) / (nx - 1)</div>
<div class="line"><span class="lineno"> 8499</span>        df_denom += np.power(ny * Sy, 2.0) / (ny - 1)</div>
<div class="line"><span class="lineno"> 8500</span>        df = df_numer / df_denom</div>
<div class="line"><span class="lineno"> 8501</span> </div>
<div class="line"><span class="lineno"> 8502</span>        <span class="keywordflow">if</span> (df_numer == 0) <span class="keywordflow">and</span> (df_denom == 0):</div>
<div class="line"><span class="lineno"> 8503</span>            message = (<span class="stringliteral">&quot;p-value cannot be estimated with `distribution=&#39;t&#39; &quot;</span></div>
<div class="line"><span class="lineno"> 8504</span>                       <span class="stringliteral">&quot;because degrees of freedom parameter is undefined &quot;</span></div>
<div class="line"><span class="lineno"> 8505</span>                       <span class="stringliteral">&quot;(0/0). Try using `distribution=&#39;normal&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 8506</span>            warnings.warn(message, RuntimeWarning)</div>
<div class="line"><span class="lineno"> 8507</span> </div>
<div class="line"><span class="lineno"> 8508</span>        p = distributions.t.cdf(wbfn, df)</div>
<div class="line"><span class="lineno"> 8509</span>    <span class="keywordflow">elif</span> distribution == <span class="stringliteral">&quot;normal&quot;</span>:</div>
<div class="line"><span class="lineno"> 8510</span>        p = distributions.norm.cdf(wbfn)</div>
<div class="line"><span class="lineno"> 8511</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 8512</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 8513</span>            <span class="stringliteral">&quot;distribution should be &#39;t&#39; or &#39;normal&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 8514</span> </div>
<div class="line"><span class="lineno"> 8515</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&quot;greater&quot;</span>:</div>
<div class="line"><span class="lineno"> 8516</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 8517</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&quot;less&quot;</span>:</div>
<div class="line"><span class="lineno"> 8518</span>        p = 1 - p</div>
<div class="line"><span class="lineno"> 8519</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&quot;two-sided&quot;</span>:</div>
<div class="line"><span class="lineno"> 8520</span>        p = 2 * np.min([p, 1-p])</div>
<div class="line"><span class="lineno"> 8521</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 8522</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 8523</span>            <span class="stringliteral">&quot;alternative should be &#39;less&#39;, &#39;greater&#39; or &#39;two-sided&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 8524</span> </div>
<div class="line"><span class="lineno"> 8525</span>    <span class="keywordflow">return</span> BrunnerMunzelResult(wbfn, p)</div>
<div class="line"><span class="lineno"> 8526</span> </div>
<div class="line"><span class="lineno"> 8527</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5794f15c32e4b9eaee99f403e23be4c5" name="a5794f15c32e4b9eaee99f403e23be4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5794f15c32e4b9eaee99f403e23be4c5">&#9670;&#160;</a></span>chisquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.chisquare </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f_exp</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate a one-way chi-square test.

The chi-square test tests the null hypothesis that the categorical data
has the given frequencies.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.

Returns
-------
chisq : float or ndarray
    The chi-squared test statistic.  The value is a float if `axis` is
    None or `f_obs` and `f_exp` are 1-D.
p : float or ndarray
    The p-value of the test.  The value is a float if `ddof` and the
    return value `chisq` are scalars.

See Also
--------
scipy.stats.power_divergence
scipy.stats.fisher_exact : Fisher exact test on a 2x2 contingency table.
scipy.stats.barnard_exact : An unconditional exact test. An alternative
    to chi-squared test for small sample sizes.

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5. According to [3]_, the
total number of samples is recommended to be greater than 13,
otherwise exact tests (such as Barnard's Exact test) should be used
because they do not overreject.

Also, the sum of the observed and expected frequencies must be the same
for the test to be valid; `chisquare` raises an error if the sums do not
agree within a relative tolerance of ``1e-8``.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not chi-square, in which case this test
is not appropriate.

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8.
       https://web.archive.org/web/20171022032306/http://vassarstats.net:80/textbook/ch8pt1.html
.. [2] "Chi-squared test", https://en.wikipedia.org/wiki/Chi-squared_test
.. [3] Pearson, Karl. "On the criterion that a given system of deviations from the probable
       in the case of a correlated system of variables is such that it can be reasonably
       supposed to have arisen from random sampling", Philosophical Magazine. Series 5. 50
       (1900), pp. 157-175.

Examples
--------
When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.

&gt;&gt;&gt; from scipy.stats import chisquare
&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12])
(2.0, 0.84914503608460956)

With `f_exp` the expected frequencies can be given.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8])
(3.5, 0.62338762774958223)

When `f_obs` is 2-D, by default the test is applied to each column.

&gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
&gt;&gt;&gt; obs.shape
(6, 2)
&gt;&gt;&gt; chisquare(obs)
(array([ 2.        ,  6.66666667]), array([ 0.84914504,  0.24663415]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

&gt;&gt;&gt; chisquare(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
&gt;&gt;&gt; chisquare(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
chi-squared statistic with `ddof`.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we use ``axis=1``:

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12],
...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]],
...           axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</pre> <div class="fragment"><div class="line"><span class="lineno"> 7187</span><span class="keyword">def </span>chisquare(f_obs, f_exp=None, ddof=0, axis=0):</div>
<div class="line"><span class="lineno"> 7188</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate a one-way chi-square test.</span></div>
<div class="line"><span class="lineno"> 7189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7190</span><span class="stringliteral">    The chi-square test tests the null hypothesis that the categorical data</span></div>
<div class="line"><span class="lineno"> 7191</span><span class="stringliteral">    has the given frequencies.</span></div>
<div class="line"><span class="lineno"> 7192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7193</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7194</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7195</span><span class="stringliteral">    f_obs : array_like</span></div>
<div class="line"><span class="lineno"> 7196</span><span class="stringliteral">        Observed frequencies in each category.</span></div>
<div class="line"><span class="lineno"> 7197</span><span class="stringliteral">    f_exp : array_like, optional</span></div>
<div class="line"><span class="lineno"> 7198</span><span class="stringliteral">        Expected frequencies in each category.  By default the categories are</span></div>
<div class="line"><span class="lineno"> 7199</span><span class="stringliteral">        assumed to be equally likely.</span></div>
<div class="line"><span class="lineno"> 7200</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 7201</span><span class="stringliteral">        &quot;Delta degrees of freedom&quot;: adjustment to the degrees of freedom</span></div>
<div class="line"><span class="lineno"> 7202</span><span class="stringliteral">        for the p-value.  The p-value is computed using a chi-squared</span></div>
<div class="line"><span class="lineno"> 7203</span><span class="stringliteral">        distribution with ``k - 1 - ddof`` degrees of freedom, where `k`</span></div>
<div class="line"><span class="lineno"> 7204</span><span class="stringliteral">        is the number of observed frequencies.  The default value of `ddof`</span></div>
<div class="line"><span class="lineno"> 7205</span><span class="stringliteral">        is 0.</span></div>
<div class="line"><span class="lineno"> 7206</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 7207</span><span class="stringliteral">        The axis of the broadcast result of `f_obs` and `f_exp` along which to</span></div>
<div class="line"><span class="lineno"> 7208</span><span class="stringliteral">        apply the test.  If axis is None, all values in `f_obs` are treated</span></div>
<div class="line"><span class="lineno"> 7209</span><span class="stringliteral">        as a single data set.  Default is 0.</span></div>
<div class="line"><span class="lineno"> 7210</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7211</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7212</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7213</span><span class="stringliteral">    chisq : float or ndarray</span></div>
<div class="line"><span class="lineno"> 7214</span><span class="stringliteral">        The chi-squared test statistic.  The value is a float if `axis` is</span></div>
<div class="line"><span class="lineno"> 7215</span><span class="stringliteral">        None or `f_obs` and `f_exp` are 1-D.</span></div>
<div class="line"><span class="lineno"> 7216</span><span class="stringliteral">    p : float or ndarray</span></div>
<div class="line"><span class="lineno"> 7217</span><span class="stringliteral">        The p-value of the test.  The value is a float if `ddof` and the</span></div>
<div class="line"><span class="lineno"> 7218</span><span class="stringliteral">        return value `chisq` are scalars.</span></div>
<div class="line"><span class="lineno"> 7219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7220</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 7221</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7222</span><span class="stringliteral">    scipy.stats.power_divergence</span></div>
<div class="line"><span class="lineno"> 7223</span><span class="stringliteral">    scipy.stats.fisher_exact : Fisher exact test on a 2x2 contingency table.</span></div>
<div class="line"><span class="lineno"> 7224</span><span class="stringliteral">    scipy.stats.barnard_exact : An unconditional exact test. An alternative</span></div>
<div class="line"><span class="lineno"> 7225</span><span class="stringliteral">        to chi-squared test for small sample sizes.</span></div>
<div class="line"><span class="lineno"> 7226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7227</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 7228</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 7229</span><span class="stringliteral">    This test is invalid when the observed or expected frequencies in each</span></div>
<div class="line"><span class="lineno"> 7230</span><span class="stringliteral">    category are too small.  A typical rule is that all of the observed</span></div>
<div class="line"><span class="lineno"> 7231</span><span class="stringliteral">    and expected frequencies should be at least 5. According to [3]_, the</span></div>
<div class="line"><span class="lineno"> 7232</span><span class="stringliteral">    total number of samples is recommended to be greater than 13,</span></div>
<div class="line"><span class="lineno"> 7233</span><span class="stringliteral">    otherwise exact tests (such as Barnard&#39;s Exact test) should be used</span></div>
<div class="line"><span class="lineno"> 7234</span><span class="stringliteral">    because they do not overreject.</span></div>
<div class="line"><span class="lineno"> 7235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7236</span><span class="stringliteral">    Also, the sum of the observed and expected frequencies must be the same</span></div>
<div class="line"><span class="lineno"> 7237</span><span class="stringliteral">    for the test to be valid; `chisquare` raises an error if the sums do not</span></div>
<div class="line"><span class="lineno"> 7238</span><span class="stringliteral">    agree within a relative tolerance of ``1e-8``.</span></div>
<div class="line"><span class="lineno"> 7239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7240</span><span class="stringliteral">    The default degrees of freedom, k-1, are for the case when no parameters</span></div>
<div class="line"><span class="lineno"> 7241</span><span class="stringliteral">    of the distribution are estimated. If p parameters are estimated by</span></div>
<div class="line"><span class="lineno"> 7242</span><span class="stringliteral">    efficient maximum likelihood then the correct degrees of freedom are</span></div>
<div class="line"><span class="lineno"> 7243</span><span class="stringliteral">    k-1-p. If the parameters are estimated in a different way, then the</span></div>
<div class="line"><span class="lineno"> 7244</span><span class="stringliteral">    dof can be between k-1-p and k-1. However, it is also possible that</span></div>
<div class="line"><span class="lineno"> 7245</span><span class="stringliteral">    the asymptotic distribution is not chi-square, in which case this test</span></div>
<div class="line"><span class="lineno"> 7246</span><span class="stringliteral">    is not appropriate.</span></div>
<div class="line"><span class="lineno"> 7247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7248</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 7249</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7250</span><span class="stringliteral">    .. [1] Lowry, Richard.  &quot;Concepts and Applications of Inferential</span></div>
<div class="line"><span class="lineno"> 7251</span><span class="stringliteral">           Statistics&quot;. Chapter 8.</span></div>
<div class="line"><span class="lineno"> 7252</span><span class="stringliteral">           https://web.archive.org/web/20171022032306/http://vassarstats.net:80/textbook/ch8pt1.html</span></div>
<div class="line"><span class="lineno"> 7253</span><span class="stringliteral">    .. [2] &quot;Chi-squared test&quot;, https://en.wikipedia.org/wiki/Chi-squared_test</span></div>
<div class="line"><span class="lineno"> 7254</span><span class="stringliteral">    .. [3] Pearson, Karl. &quot;On the criterion that a given system of deviations from the probable</span></div>
<div class="line"><span class="lineno"> 7255</span><span class="stringliteral">           in the case of a correlated system of variables is such that it can be reasonably</span></div>
<div class="line"><span class="lineno"> 7256</span><span class="stringliteral">           supposed to have arisen from random sampling&quot;, Philosophical Magazine. Series 5. 50</span></div>
<div class="line"><span class="lineno"> 7257</span><span class="stringliteral">           (1900), pp. 157-175.</span></div>
<div class="line"><span class="lineno"> 7258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7259</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 7260</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7261</span><span class="stringliteral">    When just `f_obs` is given, it is assumed that the expected frequencies</span></div>
<div class="line"><span class="lineno"> 7262</span><span class="stringliteral">    are uniform and given by the mean of the observed frequencies.</span></div>
<div class="line"><span class="lineno"> 7263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7264</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import chisquare</span></div>
<div class="line"><span class="lineno"> 7265</span><span class="stringliteral">    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12])</span></div>
<div class="line"><span class="lineno"> 7266</span><span class="stringliteral">    (2.0, 0.84914503608460956)</span></div>
<div class="line"><span class="lineno"> 7267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7268</span><span class="stringliteral">    With `f_exp` the expected frequencies can be given.</span></div>
<div class="line"><span class="lineno"> 7269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7270</span><span class="stringliteral">    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8])</span></div>
<div class="line"><span class="lineno"> 7271</span><span class="stringliteral">    (3.5, 0.62338762774958223)</span></div>
<div class="line"><span class="lineno"> 7272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7273</span><span class="stringliteral">    When `f_obs` is 2-D, by default the test is applied to each column.</span></div>
<div class="line"><span class="lineno"> 7274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7275</span><span class="stringliteral">    &gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T</span></div>
<div class="line"><span class="lineno"> 7276</span><span class="stringliteral">    &gt;&gt;&gt; obs.shape</span></div>
<div class="line"><span class="lineno"> 7277</span><span class="stringliteral">    (6, 2)</span></div>
<div class="line"><span class="lineno"> 7278</span><span class="stringliteral">    &gt;&gt;&gt; chisquare(obs)</span></div>
<div class="line"><span class="lineno"> 7279</span><span class="stringliteral">    (array([ 2.        ,  6.66666667]), array([ 0.84914504,  0.24663415]))</span></div>
<div class="line"><span class="lineno"> 7280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7281</span><span class="stringliteral">    By setting ``axis=None``, the test is applied to all data in the array,</span></div>
<div class="line"><span class="lineno"> 7282</span><span class="stringliteral">    which is equivalent to applying the test to the flattened array.</span></div>
<div class="line"><span class="lineno"> 7283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7284</span><span class="stringliteral">    &gt;&gt;&gt; chisquare(obs, axis=None)</span></div>
<div class="line"><span class="lineno"> 7285</span><span class="stringliteral">    (23.31034482758621, 0.015975692534127565)</span></div>
<div class="line"><span class="lineno"> 7286</span><span class="stringliteral">    &gt;&gt;&gt; chisquare(obs.ravel())</span></div>
<div class="line"><span class="lineno"> 7287</span><span class="stringliteral">    (23.31034482758621, 0.015975692534127565)</span></div>
<div class="line"><span class="lineno"> 7288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7289</span><span class="stringliteral">    `ddof` is the change to make to the default degrees of freedom.</span></div>
<div class="line"><span class="lineno"> 7290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7291</span><span class="stringliteral">    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=1)</span></div>
<div class="line"><span class="lineno"> 7292</span><span class="stringliteral">    (2.0, 0.73575888234288467)</span></div>
<div class="line"><span class="lineno"> 7293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7294</span><span class="stringliteral">    The calculation of the p-values is done by broadcasting the</span></div>
<div class="line"><span class="lineno"> 7295</span><span class="stringliteral">    chi-squared statistic with `ddof`.</span></div>
<div class="line"><span class="lineno"> 7296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7297</span><span class="stringliteral">    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=[0,1,2])</span></div>
<div class="line"><span class="lineno"> 7298</span><span class="stringliteral">    (2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))</span></div>
<div class="line"><span class="lineno"> 7299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7300</span><span class="stringliteral">    `f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has</span></div>
<div class="line"><span class="lineno"> 7301</span><span class="stringliteral">    shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting</span></div>
<div class="line"><span class="lineno"> 7302</span><span class="stringliteral">    `f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared</span></div>
<div class="line"><span class="lineno"> 7303</span><span class="stringliteral">    statistics, we use ``axis=1``:</span></div>
<div class="line"><span class="lineno"> 7304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7305</span><span class="stringliteral">    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12],</span></div>
<div class="line"><span class="lineno"> 7306</span><span class="stringliteral">    ...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]],</span></div>
<div class="line"><span class="lineno"> 7307</span><span class="stringliteral">    ...           axis=1)</span></div>
<div class="line"><span class="lineno"> 7308</span><span class="stringliteral">    (array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</span></div>
<div class="line"><span class="lineno"> 7309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7310</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7311</span>    <span class="keywordflow">return</span> power_divergence(f_obs, f_exp=f_exp, ddof=ddof, axis=axis,</div>
<div class="line"><span class="lineno"> 7312</span>                            lambda_=<span class="stringliteral">&quot;pearson&quot;</span>)</div>
<div class="line"><span class="lineno"> 7313</span> </div>
<div class="line"><span class="lineno"> 7314</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b6200c846acee0166b2ecb13abdcba1" name="a0b6200c846acee0166b2ecb13abdcba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6200c846acee0166b2ecb13abdcba1">&#9670;&#160;</a></span>combine_pvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.combine_pvalues </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'fisher'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Combine p-values from independent tests that bear upon the same hypothesis.

These methods are intended only for combining p-values from hypothesis
tests based upon continuous distributions.

Each method assumes that under the null hypothesis, the p-values are
sampled independently and uniformly from the interval [0, 1]. A test
statistic (different for each method) is computed and a combined
p-value is calculated based upon the distribution of this test statistic
under the null hypothesis.

Parameters
----------
pvalues : array_like, 1-D
    Array of p-values assumed to come from independent tests based on
    continuous distributions.
method : {'fisher', 'pearson', 'tippett', 'stouffer', 'mudholkar_george'}

    Name of method to use to combine p-values.

    The available methods are (see Notes for details):

    * 'fisher': Fisher's method (Fisher's combined probability test)
    * 'pearson': Pearson's method
    * 'mudholkar_george': Mudholkar's and George's method
    * 'tippett': Tippett's method
    * 'stouffer': Stouffer's Z-score method
weights : array_like, 1-D, optional
    Optional array of weights used only for Stouffer's Z-score method.

Returns
-------
statistic: float
    The statistic calculated by the specified method.
pval: float
    The combined p-value.

Notes
-----
If this function is applied to tests with a discrete statistics such as
any rank test or contingency-table test, it will yield systematically
wrong results, e.g. Fisher's method will systematically overestimate the
p-value [1]_. This problem becomes less severe for large sample sizes
when the discrete distributions become approximately continuous.

The differences between the methods can be best illustrated by their
statistics and what aspects of a combination of p-values they emphasise
when considering significance [2]_. For example, methods emphasising large
p-values are more sensitive to strong false and true negatives; conversely
methods focussing on small p-values are sensitive to positives.

* The statistics of Fisher's method (also known as Fisher's combined
  probability test) [3]_ is :math:`-2\\sum_i \\log(p_i)`, which is
  equivalent (as a test statistics) to the product of individual p-values:
  :math:`\\prod_i p_i`. Under the null hypothesis, this statistics follows
  a :math:`\\chi^2` distribution. This method emphasises small p-values.
* Pearson's method uses :math:`-2\\sum_i\\log(1-p_i)`, which is equivalent
  to :math:`\\prod_i \\frac{1}{1-p_i}` [2]_.
  It thus emphasises large p-values.
* Mudholkar and George compromise between Fisher's and Pearson's method by
  averaging their statistics [4]_. Their method emphasises extreme
  p-values, both close to 1 and 0.
* Stouffer's method [5]_ uses Z-scores and the statistic:
  :math:`\\sum_i \\Phi^{-1} (p_i)`, where :math:`\\Phi` is the CDF of the
  standard normal distribution. The advantage of this method is that it is
  straightforward to introduce weights, which can make Stouffer's method
  more powerful than Fisher's method when the p-values are from studies
  of different size [6]_ [7]_.
* Tippett's method uses the smallest p-value as a statistic.
  (Mind that this minimum is not the combined p-value.)

Fisher's method may be extended to combine p-values from dependent tests
[8]_. Extensions such as Brown's method and Kost's method are not currently
implemented.

.. versionadded:: 0.15.0

References
----------
.. [1] Kincaid, W. M., "The Combination of Tests Based on Discrete
       Distributions." Journal of the American Statistical Association 57,
       no. 297 (1962), 10-19.
.. [2] Heard, N. and Rubin-Delanchey, P. "Choosing between methods of
       combining p-values."  Biometrika 105.1 (2018): 239-246.
.. [3] https://en.wikipedia.org/wiki/Fisher%27s_method
.. [4] George, E. O., and G. S. Mudholkar. "On the convolution of logistic
       random variables." Metrika 30.1 (1983): 1-13.
.. [5] https://en.wikipedia.org/wiki/Fisher%27s_method#Relation_to_Stouffer.27s_Z-score_method
.. [6] Whitlock, M. C. "Combining probability from independent tests: the
       weighted Z-method is superior to Fisher's approach." Journal of
       Evolutionary Biology 18, no. 5 (2005): 1368-1373.
.. [7] Zaykin, Dmitri V. "Optimally weighted Z-test is a powerful method
       for combining probabilities in meta-analysis." Journal of
       Evolutionary Biology 24, no. 8 (2011): 1836-1841.
.. [8] https://en.wikipedia.org/wiki/Extensions_of_Fisher%27s_method</pre> <div class="fragment"><div class="line"><span class="lineno"> 8528</span><span class="keyword">def </span>combine_pvalues(pvalues, method=&#39;fisher&#39;, weights=None):</div>
<div class="line"><span class="lineno"> 8529</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8530</span><span class="stringliteral">    Combine p-values from independent tests that bear upon the same hypothesis.</span></div>
<div class="line"><span class="lineno"> 8531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8532</span><span class="stringliteral">    These methods are intended only for combining p-values from hypothesis</span></div>
<div class="line"><span class="lineno"> 8533</span><span class="stringliteral">    tests based upon continuous distributions.</span></div>
<div class="line"><span class="lineno"> 8534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8535</span><span class="stringliteral">    Each method assumes that under the null hypothesis, the p-values are</span></div>
<div class="line"><span class="lineno"> 8536</span><span class="stringliteral">    sampled independently and uniformly from the interval [0, 1]. A test</span></div>
<div class="line"><span class="lineno"> 8537</span><span class="stringliteral">    statistic (different for each method) is computed and a combined</span></div>
<div class="line"><span class="lineno"> 8538</span><span class="stringliteral">    p-value is calculated based upon the distribution of this test statistic</span></div>
<div class="line"><span class="lineno"> 8539</span><span class="stringliteral">    under the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 8540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8541</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8542</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8543</span><span class="stringliteral">    pvalues : array_like, 1-D</span></div>
<div class="line"><span class="lineno"> 8544</span><span class="stringliteral">        Array of p-values assumed to come from independent tests based on</span></div>
<div class="line"><span class="lineno"> 8545</span><span class="stringliteral">        continuous distributions.</span></div>
<div class="line"><span class="lineno"> 8546</span><span class="stringliteral">    method : {&#39;fisher&#39;, &#39;pearson&#39;, &#39;tippett&#39;, &#39;stouffer&#39;, &#39;mudholkar_george&#39;}</span></div>
<div class="line"><span class="lineno"> 8547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8548</span><span class="stringliteral">        Name of method to use to combine p-values.</span></div>
<div class="line"><span class="lineno"> 8549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8550</span><span class="stringliteral">        The available methods are (see Notes for details):</span></div>
<div class="line"><span class="lineno"> 8551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8552</span><span class="stringliteral">        * &#39;fisher&#39;: Fisher&#39;s method (Fisher&#39;s combined probability test)</span></div>
<div class="line"><span class="lineno"> 8553</span><span class="stringliteral">        * &#39;pearson&#39;: Pearson&#39;s method</span></div>
<div class="line"><span class="lineno"> 8554</span><span class="stringliteral">        * &#39;mudholkar_george&#39;: Mudholkar&#39;s and George&#39;s method</span></div>
<div class="line"><span class="lineno"> 8555</span><span class="stringliteral">        * &#39;tippett&#39;: Tippett&#39;s method</span></div>
<div class="line"><span class="lineno"> 8556</span><span class="stringliteral">        * &#39;stouffer&#39;: Stouffer&#39;s Z-score method</span></div>
<div class="line"><span class="lineno"> 8557</span><span class="stringliteral">    weights : array_like, 1-D, optional</span></div>
<div class="line"><span class="lineno"> 8558</span><span class="stringliteral">        Optional array of weights used only for Stouffer&#39;s Z-score method.</span></div>
<div class="line"><span class="lineno"> 8559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8560</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8561</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8562</span><span class="stringliteral">    statistic: float</span></div>
<div class="line"><span class="lineno"> 8563</span><span class="stringliteral">        The statistic calculated by the specified method.</span></div>
<div class="line"><span class="lineno"> 8564</span><span class="stringliteral">    pval: float</span></div>
<div class="line"><span class="lineno"> 8565</span><span class="stringliteral">        The combined p-value.</span></div>
<div class="line"><span class="lineno"> 8566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8567</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8568</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8569</span><span class="stringliteral">    If this function is applied to tests with a discrete statistics such as</span></div>
<div class="line"><span class="lineno"> 8570</span><span class="stringliteral">    any rank test or contingency-table test, it will yield systematically</span></div>
<div class="line"><span class="lineno"> 8571</span><span class="stringliteral">    wrong results, e.g. Fisher&#39;s method will systematically overestimate the</span></div>
<div class="line"><span class="lineno"> 8572</span><span class="stringliteral">    p-value [1]_. This problem becomes less severe for large sample sizes</span></div>
<div class="line"><span class="lineno"> 8573</span><span class="stringliteral">    when the discrete distributions become approximately continuous.</span></div>
<div class="line"><span class="lineno"> 8574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8575</span><span class="stringliteral">    The differences between the methods can be best illustrated by their</span></div>
<div class="line"><span class="lineno"> 8576</span><span class="stringliteral">    statistics and what aspects of a combination of p-values they emphasise</span></div>
<div class="line"><span class="lineno"> 8577</span><span class="stringliteral">    when considering significance [2]_. For example, methods emphasising large</span></div>
<div class="line"><span class="lineno"> 8578</span><span class="stringliteral">    p-values are more sensitive to strong false and true negatives; conversely</span></div>
<div class="line"><span class="lineno"> 8579</span><span class="stringliteral">    methods focussing on small p-values are sensitive to positives.</span></div>
<div class="line"><span class="lineno"> 8580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8581</span><span class="stringliteral">    * The statistics of Fisher&#39;s method (also known as Fisher&#39;s combined</span></div>
<div class="line"><span class="lineno"> 8582</span><span class="stringliteral">      probability test) [3]_ is :math:`-2\\sum_i \\log(p_i)`, which is</span></div>
<div class="line"><span class="lineno"> 8583</span><span class="stringliteral">      equivalent (as a test statistics) to the product of individual p-values:</span></div>
<div class="line"><span class="lineno"> 8584</span><span class="stringliteral">      :math:`\\prod_i p_i`. Under the null hypothesis, this statistics follows</span></div>
<div class="line"><span class="lineno"> 8585</span><span class="stringliteral">      a :math:`\\chi^2` distribution. This method emphasises small p-values.</span></div>
<div class="line"><span class="lineno"> 8586</span><span class="stringliteral">    * Pearson&#39;s method uses :math:`-2\\sum_i\\log(1-p_i)`, which is equivalent</span></div>
<div class="line"><span class="lineno"> 8587</span><span class="stringliteral">      to :math:`\\prod_i \\frac{1}{1-p_i}` [2]_.</span></div>
<div class="line"><span class="lineno"> 8588</span><span class="stringliteral">      It thus emphasises large p-values.</span></div>
<div class="line"><span class="lineno"> 8589</span><span class="stringliteral">    * Mudholkar and George compromise between Fisher&#39;s and Pearson&#39;s method by</span></div>
<div class="line"><span class="lineno"> 8590</span><span class="stringliteral">      averaging their statistics [4]_. Their method emphasises extreme</span></div>
<div class="line"><span class="lineno"> 8591</span><span class="stringliteral">      p-values, both close to 1 and 0.</span></div>
<div class="line"><span class="lineno"> 8592</span><span class="stringliteral">    * Stouffer&#39;s method [5]_ uses Z-scores and the statistic:</span></div>
<div class="line"><span class="lineno"> 8593</span><span class="stringliteral">      :math:`\\sum_i \\Phi^{-1} (p_i)`, where :math:`\\Phi` is the CDF of the</span></div>
<div class="line"><span class="lineno"> 8594</span><span class="stringliteral">      standard normal distribution. The advantage of this method is that it is</span></div>
<div class="line"><span class="lineno"> 8595</span><span class="stringliteral">      straightforward to introduce weights, which can make Stouffer&#39;s method</span></div>
<div class="line"><span class="lineno"> 8596</span><span class="stringliteral">      more powerful than Fisher&#39;s method when the p-values are from studies</span></div>
<div class="line"><span class="lineno"> 8597</span><span class="stringliteral">      of different size [6]_ [7]_.</span></div>
<div class="line"><span class="lineno"> 8598</span><span class="stringliteral">    * Tippett&#39;s method uses the smallest p-value as a statistic.</span></div>
<div class="line"><span class="lineno"> 8599</span><span class="stringliteral">      (Mind that this minimum is not the combined p-value.)</span></div>
<div class="line"><span class="lineno"> 8600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8601</span><span class="stringliteral">    Fisher&#39;s method may be extended to combine p-values from dependent tests</span></div>
<div class="line"><span class="lineno"> 8602</span><span class="stringliteral">    [8]_. Extensions such as Brown&#39;s method and Kost&#39;s method are not currently</span></div>
<div class="line"><span class="lineno"> 8603</span><span class="stringliteral">    implemented.</span></div>
<div class="line"><span class="lineno"> 8604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8605</span><span class="stringliteral">    .. versionadded:: 0.15.0</span></div>
<div class="line"><span class="lineno"> 8606</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8607</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8608</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8609</span><span class="stringliteral">    .. [1] Kincaid, W. M., &quot;The Combination of Tests Based on Discrete</span></div>
<div class="line"><span class="lineno"> 8610</span><span class="stringliteral">           Distributions.&quot; Journal of the American Statistical Association 57,</span></div>
<div class="line"><span class="lineno"> 8611</span><span class="stringliteral">           no. 297 (1962), 10-19.</span></div>
<div class="line"><span class="lineno"> 8612</span><span class="stringliteral">    .. [2] Heard, N. and Rubin-Delanchey, P. &quot;Choosing between methods of</span></div>
<div class="line"><span class="lineno"> 8613</span><span class="stringliteral">           combining p-values.&quot;  Biometrika 105.1 (2018): 239-246.</span></div>
<div class="line"><span class="lineno"> 8614</span><span class="stringliteral">    .. [3] https://en.wikipedia.org/wiki/Fisher%27s_method</span></div>
<div class="line"><span class="lineno"> 8615</span><span class="stringliteral">    .. [4] George, E. O., and G. S. Mudholkar. &quot;On the convolution of logistic</span></div>
<div class="line"><span class="lineno"> 8616</span><span class="stringliteral">           random variables.&quot; Metrika 30.1 (1983): 1-13.</span></div>
<div class="line"><span class="lineno"> 8617</span><span class="stringliteral">    .. [5] https://en.wikipedia.org/wiki/Fisher%27s_method#Relation_to_Stouffer.27s_Z-score_method</span></div>
<div class="line"><span class="lineno"> 8618</span><span class="stringliteral">    .. [6] Whitlock, M. C. &quot;Combining probability from independent tests: the</span></div>
<div class="line"><span class="lineno"> 8619</span><span class="stringliteral">           weighted Z-method is superior to Fisher&#39;s approach.&quot; Journal of</span></div>
<div class="line"><span class="lineno"> 8620</span><span class="stringliteral">           Evolutionary Biology 18, no. 5 (2005): 1368-1373.</span></div>
<div class="line"><span class="lineno"> 8621</span><span class="stringliteral">    .. [7] Zaykin, Dmitri V. &quot;Optimally weighted Z-test is a powerful method</span></div>
<div class="line"><span class="lineno"> 8622</span><span class="stringliteral">           for combining probabilities in meta-analysis.&quot; Journal of</span></div>
<div class="line"><span class="lineno"> 8623</span><span class="stringliteral">           Evolutionary Biology 24, no. 8 (2011): 1836-1841.</span></div>
<div class="line"><span class="lineno"> 8624</span><span class="stringliteral">    .. [8] https://en.wikipedia.org/wiki/Extensions_of_Fisher%27s_method</span></div>
<div class="line"><span class="lineno"> 8625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8626</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8627</span>    pvalues = np.asarray(pvalues)</div>
<div class="line"><span class="lineno"> 8628</span>    <span class="keywordflow">if</span> pvalues.ndim != 1:</div>
<div class="line"><span class="lineno"> 8629</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;pvalues is not 1-D&quot;</span>)</div>
<div class="line"><span class="lineno"> 8630</span> </div>
<div class="line"><span class="lineno"> 8631</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;fisher&#39;</span>:</div>
<div class="line"><span class="lineno"> 8632</span>        statistic = -2 * np.sum(np.log(pvalues))</div>
<div class="line"><span class="lineno"> 8633</span>        pval = distributions.chi2.sf(statistic, 2 * len(pvalues))</div>
<div class="line"><span class="lineno"> 8634</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;pearson&#39;</span>:</div>
<div class="line"><span class="lineno"> 8635</span>        statistic = 2 * np.sum(np.log1p(-pvalues))</div>
<div class="line"><span class="lineno"> 8636</span>        pval = distributions.chi2.cdf(-statistic, 2 * len(pvalues))</div>
<div class="line"><span class="lineno"> 8637</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;mudholkar_george&#39;</span>:</div>
<div class="line"><span class="lineno"> 8638</span>        normalizing_factor = np.sqrt(3/len(pvalues))/np.pi</div>
<div class="line"><span class="lineno"> 8639</span>        statistic = -np.sum(np.log(pvalues)) + np.sum(np.log1p(-pvalues))</div>
<div class="line"><span class="lineno"> 8640</span>        nu = 5 * len(pvalues) + 4</div>
<div class="line"><span class="lineno"> 8641</span>        approx_factor = np.sqrt(nu / (nu - 2))</div>
<div class="line"><span class="lineno"> 8642</span>        pval = distributions.t.sf(statistic * normalizing_factor</div>
<div class="line"><span class="lineno"> 8643</span>                                  * approx_factor, nu)</div>
<div class="line"><span class="lineno"> 8644</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;tippett&#39;</span>:</div>
<div class="line"><span class="lineno"> 8645</span>        statistic = np.min(pvalues)</div>
<div class="line"><span class="lineno"> 8646</span>        pval = distributions.beta.cdf(statistic, 1, len(pvalues))</div>
<div class="line"><span class="lineno"> 8647</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;stouffer&#39;</span>:</div>
<div class="line"><span class="lineno"> 8648</span>        <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 8649</span>            weights = np.ones_like(pvalues)</div>
<div class="line"><span class="lineno"> 8650</span>        <span class="keywordflow">elif</span> len(weights) != len(pvalues):</div>
<div class="line"><span class="lineno"> 8651</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;pvalues and weights must be of the same size.&quot;</span>)</div>
<div class="line"><span class="lineno"> 8652</span> </div>
<div class="line"><span class="lineno"> 8653</span>        weights = np.asarray(weights)</div>
<div class="line"><span class="lineno"> 8654</span>        <span class="keywordflow">if</span> weights.ndim != 1:</div>
<div class="line"><span class="lineno"> 8655</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;weights is not 1-D&quot;</span>)</div>
<div class="line"><span class="lineno"> 8656</span> </div>
<div class="line"><span class="lineno"> 8657</span>        Zi = distributions.norm.isf(pvalues)</div>
<div class="line"><span class="lineno"> 8658</span>        statistic = np.dot(weights, Zi) / np.linalg.norm(weights)</div>
<div class="line"><span class="lineno"> 8659</span>        pval = distributions.norm.sf(statistic)</div>
<div class="line"><span class="lineno"> 8660</span> </div>
<div class="line"><span class="lineno"> 8661</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 8662</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 8663</span>            f<span class="stringliteral">&quot;Invalid method {method!r}. Valid methods are &#39;fisher&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 8664</span>            <span class="stringliteral">&quot;&#39;pearson&#39;, &#39;mudholkar_george&#39;, &#39;tippett&#39;, and &#39;stouffer&#39;&quot;</span></div>
<div class="line"><span class="lineno"> 8665</span>        )</div>
<div class="line"><span class="lineno"> 8666</span> </div>
<div class="line"><span class="lineno"> 8667</span>    <span class="keywordflow">return</span> (statistic, pval)</div>
<div class="line"><span class="lineno"> 8668</span> </div>
<div class="line"><span class="lineno"> 8669</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7cc05458723f566fbbd8bf5c92ac145" name="ab7cc05458723f566fbbd8bf5c92ac145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cc05458723f566fbbd8bf5c92ac145">&#9670;&#160;</a></span>cumfreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.cumfreq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numbins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaultreallimits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a cumulative frequency histogram, using the histogram function.

A cumulative histogram is a mapping that counts the cumulative number of
observations in all of the bins up to the specified bin.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultreallimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
cumcount : ndarray
    Binned values of cumulative frequency.
lowerlimit : float
    Lower real limit
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; x = [1, 4, 2, 1, 3, 1]
&gt;&gt;&gt; res = stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5))
&gt;&gt;&gt; res.cumcount
array([ 1.,  2.,  3.,  3.])
&gt;&gt;&gt; res.extrapoints
3

Create a normal distribution with 1000 random values

&gt;&gt;&gt; samples = stats.norm.rvs(size=1000, random_state=rng)

Calculate cumulative frequencies

&gt;&gt;&gt; res = stats.cumfreq(samples, numbins=25)

Calculate space of values for x

&gt;&gt;&gt; x = res.lowerlimit + np.linspace(0, res.binsize*res.cumcount.size,
...                                  res.cumcount.size)

Plot histogram and cumulative histogram

&gt;&gt;&gt; fig = plt.figure(figsize=(10, 4))
&gt;&gt;&gt; ax1 = fig.add_subplot(1, 2, 1)
&gt;&gt;&gt; ax2 = fig.add_subplot(1, 2, 2)
&gt;&gt;&gt; ax1.hist(samples, bins=25)
&gt;&gt;&gt; ax1.set_title('Histogram')
&gt;&gt;&gt; ax2.bar(x, res.cumcount, width=res.binsize)
&gt;&gt;&gt; ax2.set_title('Cumulative histogram')
&gt;&gt;&gt; ax2.set_xlim([x.min(), x.max()])

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2312</span><span class="keyword">def </span>cumfreq(a, numbins=10, defaultreallimits=None, weights=None):</div>
<div class="line"><span class="lineno"> 2313</span>    <span class="stringliteral">&quot;&quot;&quot;Return a cumulative frequency histogram, using the histogram function.</span></div>
<div class="line"><span class="lineno"> 2314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2315</span><span class="stringliteral">    A cumulative histogram is a mapping that counts the cumulative number of</span></div>
<div class="line"><span class="lineno"> 2316</span><span class="stringliteral">    observations in all of the bins up to the specified bin.</span></div>
<div class="line"><span class="lineno"> 2317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2318</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2319</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2320</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2321</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 2322</span><span class="stringliteral">    numbins : int, optional</span></div>
<div class="line"><span class="lineno"> 2323</span><span class="stringliteral">        The number of bins to use for the histogram. Default is 10.</span></div>
<div class="line"><span class="lineno"> 2324</span><span class="stringliteral">    defaultreallimits : tuple (lower, upper), optional</span></div>
<div class="line"><span class="lineno"> 2325</span><span class="stringliteral">        The lower and upper values for the range of the histogram.</span></div>
<div class="line"><span class="lineno"> 2326</span><span class="stringliteral">        If no value is given, a range slightly larger than the range of the</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral">        values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``,</span></div>
<div class="line"><span class="lineno"> 2328</span><span class="stringliteral">        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.</span></div>
<div class="line"><span class="lineno"> 2329</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2330</span><span class="stringliteral">        The weights for each value in `a`. Default is None, which gives each</span></div>
<div class="line"><span class="lineno"> 2331</span><span class="stringliteral">        value a weight of 1.0</span></div>
<div class="line"><span class="lineno"> 2332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2333</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral">    cumcount : ndarray</span></div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">        Binned values of cumulative frequency.</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral">    lowerlimit : float</span></div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral">        Lower real limit</span></div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral">    binsize : float</span></div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral">        Width of each bin.</span></div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral">    extrapoints : int</span></div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral">        Extra points.</span></div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2344</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2345</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2346</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2347</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno"> 2348</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 2349</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno"> 2350</span><span class="stringliteral">    &gt;&gt;&gt; x = [1, 4, 2, 1, 3, 1]</span></div>
<div class="line"><span class="lineno"> 2351</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5))</span></div>
<div class="line"><span class="lineno"> 2352</span><span class="stringliteral">    &gt;&gt;&gt; res.cumcount</span></div>
<div class="line"><span class="lineno"> 2353</span><span class="stringliteral">    array([ 1.,  2.,  3.,  3.])</span></div>
<div class="line"><span class="lineno"> 2354</span><span class="stringliteral">    &gt;&gt;&gt; res.extrapoints</span></div>
<div class="line"><span class="lineno"> 2355</span><span class="stringliteral">    3</span></div>
<div class="line"><span class="lineno"> 2356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2357</span><span class="stringliteral">    Create a normal distribution with 1000 random values</span></div>
<div class="line"><span class="lineno"> 2358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2359</span><span class="stringliteral">    &gt;&gt;&gt; samples = stats.norm.rvs(size=1000, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 2360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2361</span><span class="stringliteral">    Calculate cumulative frequencies</span></div>
<div class="line"><span class="lineno"> 2362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2363</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.cumfreq(samples, numbins=25)</span></div>
<div class="line"><span class="lineno"> 2364</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2365</span><span class="stringliteral">    Calculate space of values for x</span></div>
<div class="line"><span class="lineno"> 2366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2367</span><span class="stringliteral">    &gt;&gt;&gt; x = res.lowerlimit + np.linspace(0, res.binsize*res.cumcount.size,</span></div>
<div class="line"><span class="lineno"> 2368</span><span class="stringliteral">    ...                                  res.cumcount.size)</span></div>
<div class="line"><span class="lineno"> 2369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2370</span><span class="stringliteral">    Plot histogram and cumulative histogram</span></div>
<div class="line"><span class="lineno"> 2371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2372</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure(figsize=(10, 4))</span></div>
<div class="line"><span class="lineno"> 2373</span><span class="stringliteral">    &gt;&gt;&gt; ax1 = fig.add_subplot(1, 2, 1)</span></div>
<div class="line"><span class="lineno"> 2374</span><span class="stringliteral">    &gt;&gt;&gt; ax2 = fig.add_subplot(1, 2, 2)</span></div>
<div class="line"><span class="lineno"> 2375</span><span class="stringliteral">    &gt;&gt;&gt; ax1.hist(samples, bins=25)</span></div>
<div class="line"><span class="lineno"> 2376</span><span class="stringliteral">    &gt;&gt;&gt; ax1.set_title(&#39;Histogram&#39;)</span></div>
<div class="line"><span class="lineno"> 2377</span><span class="stringliteral">    &gt;&gt;&gt; ax2.bar(x, res.cumcount, width=res.binsize)</span></div>
<div class="line"><span class="lineno"> 2378</span><span class="stringliteral">    &gt;&gt;&gt; ax2.set_title(&#39;Cumulative histogram&#39;)</span></div>
<div class="line"><span class="lineno"> 2379</span><span class="stringliteral">    &gt;&gt;&gt; ax2.set_xlim([x.min(), x.max()])</span></div>
<div class="line"><span class="lineno"> 2380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2381</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2383</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2384</span>    h, l, b, e = _histogram(a, numbins, defaultreallimits, weights=weights)</div>
<div class="line"><span class="lineno"> 2385</span>    cumhist = np.cumsum(h * 1, axis=0)</div>
<div class="line"><span class="lineno"> 2386</span>    <span class="keywordflow">return</span> CumfreqResult(cumhist, l, b, e)</div>
<div class="line"><span class="lineno"> 2387</span> </div>
<div class="line"><span class="lineno"> 2388</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9074c49e4ce1d99373dae0a3c48c9d5e" name="a9074c49e4ce1d99373dae0a3c48c9d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9074c49e4ce1d99373dae0a3c48c9d5e">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.describe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bias</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute several descriptive statistics of the passed array.

Parameters
----------
a : array_like
    Input data.
axis : int or None, optional
    Axis along which statistics are calculated. Default is 0.
    If None, compute over the whole array `a`.
ddof : int, optional
    Delta degrees of freedom (only for variance).  Default is 1.
bias : bool, optional
    If False, then the skewness and kurtosis calculations are corrected
    for statistical bias.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

Returns
-------
nobs : int or ndarray of ints
    Number of observations (length of data along `axis`).
    When 'omit' is chosen as nan_policy, the length along each axis
    slice is counted separately.
minmax: tuple of ndarrays or floats
    Minimum and maximum value of `a` along the given axis.
mean : ndarray or float
    Arithmetic mean of `a` along the given axis.
variance : ndarray or float
    Unbiased variance of `a` along the given axis; denominator is number
    of observations minus one.
skewness : ndarray or float
    Skewness of `a` along the given axis, based on moment calculations
    with denominator equal to the number of observations, i.e. no degrees
    of freedom correction.
kurtosis : ndarray or float
    Kurtosis (Fisher) of `a` along the given axis.  The kurtosis is
    normalized so that it is zero for the normal distribution.  No
    degrees of freedom are used.

See Also
--------
skew, kurtosis

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; stats.describe(a)
DescribeResult(nobs=10, minmax=(0, 9), mean=4.5,
               variance=9.166666666666666, skewness=0.0,
               kurtosis=-1.2242424242424244)
&gt;&gt;&gt; b = [[1, 2], [3, 4]]
&gt;&gt;&gt; stats.describe(b)
DescribeResult(nobs=2, minmax=(array([1, 2]), array([3, 4])),
               mean=array([2., 3.]), variance=array([2., 2.]),
               skewness=array([0., 0.]), kurtosis=array([-2., -2.]))</pre> <div class="fragment"><div class="line"><span class="lineno"> 1481</span><span class="keyword">def </span>describe(a, axis=0, ddof=1, bias=True, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 1482</span>    <span class="stringliteral">&quot;&quot;&quot;Compute several descriptive statistics of the passed array.</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">        Axis along which statistics are calculated. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">        If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">        Delta degrees of freedom (only for variance).  Default is 1.</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">    bias : bool, optional</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">        If False, then the skewness and kurtosis calculations are corrected</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">        for statistical bias.</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">        * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">        * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral">        * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">    nobs : int or ndarray of ints</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">        Number of observations (length of data along `axis`).</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">        When &#39;omit&#39; is chosen as nan_policy, the length along each axis</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">        slice is counted separately.</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    minmax: tuple of ndarrays or floats</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">        Minimum and maximum value of `a` along the given axis.</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">    mean : ndarray or float</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">        Arithmetic mean of `a` along the given axis.</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">    variance : ndarray or float</span></div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">        Unbiased variance of `a` along the given axis; denominator is number</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral">        of observations minus one.</span></div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">    skewness : ndarray or float</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral">        Skewness of `a` along the given axis, based on moment calculations</span></div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">        with denominator equal to the number of observations, i.e. no degrees</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">        of freedom correction.</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    kurtosis : ndarray or float</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">        Kurtosis (Fisher) of `a` along the given axis.  The kurtosis is</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">        normalized so that it is zero for the normal distribution.  No</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">        degrees of freedom are used.</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    skew, kurtosis</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(10)</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">    &gt;&gt;&gt; stats.describe(a)</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">    DescribeResult(nobs=10, minmax=(0, 9), mean=4.5,</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">                   variance=9.166666666666666, skewness=0.0,</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">                   kurtosis=-1.2242424242424244)</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    &gt;&gt;&gt; b = [[1, 2], [3, 4]]</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">    &gt;&gt;&gt; stats.describe(b)</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    DescribeResult(nobs=2, minmax=(array([1, 2]), array([3, 4])),</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">                   mean=array([2., 3.]), variance=array([2., 2.]),</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">                   skewness=array([0., 0.]), kurtosis=array([-2., -2.]))</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1545</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 1546</span> </div>
<div class="line"><span class="lineno"> 1547</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 1548</span> </div>
<div class="line"><span class="lineno"> 1549</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 1550</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 1551</span>        <span class="keywordflow">return</span> mstats_basic.describe(a, axis, ddof, bias)</div>
<div class="line"><span class="lineno"> 1552</span> </div>
<div class="line"><span class="lineno"> 1553</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 1554</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The input must not be empty.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1555</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 1556</span>    mm = (np.min(a, axis=axis), np.max(a, axis=axis))</div>
<div class="line"><span class="lineno"> 1557</span>    m = np.mean(a, axis=axis)</div>
<div class="line"><span class="lineno"> 1558</span>    v = _var(a, axis=axis, ddof=ddof)</div>
<div class="line"><span class="lineno"> 1559</span>    sk = skew(a, axis, bias=bias)</div>
<div class="line"><span class="lineno"> 1560</span>    kurt = kurtosis(a, axis, bias=bias)</div>
<div class="line"><span class="lineno"> 1561</span> </div>
<div class="line"><span class="lineno"> 1562</span>    <span class="keywordflow">return</span> DescribeResult(n, mm, m, v, sk, kurt)</div>
<div class="line"><span class="lineno"> 1563</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a348efe926c611bfc19391b531685b053" name="a348efe926c611bfc19391b531685b053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348efe926c611bfc19391b531685b053">&#9670;&#160;</a></span>energy_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.energy_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v_weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the energy distance between two 1D distributions.

    .. versionadded:: 1.0.0

    Parameters
    ----------
    u_values, v_values : array_like
        Values observed in the (empirical) distribution.
    u_weights, v_weights : array_like, optional
        Weight for each value. If unspecified, each value is assigned the same
        weight.
        `u_weights` (resp. `v_weights`) must have the same length as
        `u_values` (resp. `v_values`). If the weight sum differs from 1, it
        must still be positive and finite so that the weights can be normalized
        to sum to 1.

    Returns
    -------
    distance : float
        The computed distance between the distributions.

    Notes
    -----
    The energy distance between two distributions :math:`u` and :math:`v`, whose
    respective CDFs are :math:`U` and :math:`V`, equals to:

    .. math::

        D(u, v) = \left( 2\mathbb E|X - Y| - \mathbb E|X - X'| -
        \mathbb E|Y - Y'| \right)^{1/2}

    where :math:`X` and :math:`X'` (resp. :math:`Y` and :math:`Y'`) are
    independent random variables whose probability distribution is :math:`u`
    (resp. :math:`v`).

    Sometimes the square of this quantity is referred to as the "energy
    distance" (e.g. in [2]_, [4]_), but as noted in [1]_ and [3]_, only the
    definition above satisfies the axioms of a distance function (metric).

    As shown in [2]_, for one-dimensional real-valued variables, the energy
    distance is linked to the non-distribution-free version of the Cramr-von
    Mises distance:

    .. math::

        D(u, v) = \sqrt{2} l_2(u, v) = \left( 2 \int_{-\infty}^{+\infty} (U-V)^2
        \right)^{1/2}

    Note that the common Cramr-von Mises criterion uses the distribution-free
    version of the distance. See [2]_ (section 2), for more details about both
    versions of the distance.

    The input distributions can be empirical, therefore coming from samples
    whose values are effectively inputs of the function, or they can be seen as
    generalized functions, in which case they are weighted sums of Dirac delta
    functions located at the specified values.

    References
    ----------
    .. [1] Rizzo, Szekely "Energy distance." Wiley Interdisciplinary Reviews:
           Computational Statistics, 8(1):27-38 (2015).
    .. [2] Szekely "E-statistics: The energy of statistical samples." Bowling
           Green State University, Department of Mathematics and Statistics,
           Technical Report 02-16 (2002).
    .. [3] "Energy distance", https://en.wikipedia.org/wiki/Energy_distance
    .. [4] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer,
           Munos "The Cramer Distance as a Solution to Biased Wasserstein
           Gradients" (2017). :arXiv:`1705.10743`.

    Examples
    --------
    &gt;&gt;&gt; from scipy.stats import energy_distance
    &gt;&gt;&gt; energy_distance([0], [2])
    2.0000000000000004
    &gt;&gt;&gt; energy_distance([0, 8], [0, 8], [3, 1], [2, 2])
    1.0000000000000002
    &gt;&gt;&gt; energy_distance([0.7, 7.4, 2.4, 6.8], [1.4, 8. ],
    ...                 [2.1, 4.2, 7.4, 8. ], [7.6, 8.8])
    0.88003340976158217</pre> <div class="fragment"><div class="line"><span class="lineno"> 8752</span><span class="keyword">def </span>energy_distance(u_values, v_values, u_weights=None, v_weights=None):</div>
<div class="line"><span class="lineno"> 8753</span>    <span class="stringliteral">r&quot;&quot;&quot;Compute the energy distance between two 1D distributions.</span></div>
<div class="line"><span class="lineno"> 8754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8755</span><span class="stringliteral">    .. versionadded:: 1.0.0</span></div>
<div class="line"><span class="lineno"> 8756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8757</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8758</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8759</span><span class="stringliteral">    u_values, v_values : array_like</span></div>
<div class="line"><span class="lineno"> 8760</span><span class="stringliteral">        Values observed in the (empirical) distribution.</span></div>
<div class="line"><span class="lineno"> 8761</span><span class="stringliteral">    u_weights, v_weights : array_like, optional</span></div>
<div class="line"><span class="lineno"> 8762</span><span class="stringliteral">        Weight for each value. If unspecified, each value is assigned the same</span></div>
<div class="line"><span class="lineno"> 8763</span><span class="stringliteral">        weight.</span></div>
<div class="line"><span class="lineno"> 8764</span><span class="stringliteral">        `u_weights` (resp. `v_weights`) must have the same length as</span></div>
<div class="line"><span class="lineno"> 8765</span><span class="stringliteral">        `u_values` (resp. `v_values`). If the weight sum differs from 1, it</span></div>
<div class="line"><span class="lineno"> 8766</span><span class="stringliteral">        must still be positive and finite so that the weights can be normalized</span></div>
<div class="line"><span class="lineno"> 8767</span><span class="stringliteral">        to sum to 1.</span></div>
<div class="line"><span class="lineno"> 8768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8769</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8770</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8771</span><span class="stringliteral">    distance : float</span></div>
<div class="line"><span class="lineno"> 8772</span><span class="stringliteral">        The computed distance between the distributions.</span></div>
<div class="line"><span class="lineno"> 8773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8774</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8775</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8776</span><span class="stringliteral">    The energy distance between two distributions :math:`u` and :math:`v`, whose</span></div>
<div class="line"><span class="lineno"> 8777</span><span class="stringliteral">    respective CDFs are :math:`U` and :math:`V`, equals to:</span></div>
<div class="line"><span class="lineno"> 8778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8779</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 8780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8781</span><span class="stringliteral">        D(u, v) = \left( 2\mathbb E|X - Y| - \mathbb E|X - X&#39;| -</span></div>
<div class="line"><span class="lineno"> 8782</span><span class="stringliteral">        \mathbb E|Y - Y&#39;| \right)^{1/2}</span></div>
<div class="line"><span class="lineno"> 8783</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8784</span><span class="stringliteral">    where :math:`X` and :math:`X&#39;` (resp. :math:`Y` and :math:`Y&#39;`) are</span></div>
<div class="line"><span class="lineno"> 8785</span><span class="stringliteral">    independent random variables whose probability distribution is :math:`u`</span></div>
<div class="line"><span class="lineno"> 8786</span><span class="stringliteral">    (resp. :math:`v`).</span></div>
<div class="line"><span class="lineno"> 8787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8788</span><span class="stringliteral">    Sometimes the square of this quantity is referred to as the &quot;energy</span></div>
<div class="line"><span class="lineno"> 8789</span><span class="stringliteral">    distance&quot; (e.g. in [2]_, [4]_), but as noted in [1]_ and [3]_, only the</span></div>
<div class="line"><span class="lineno"> 8790</span><span class="stringliteral">    definition above satisfies the axioms of a distance function (metric).</span></div>
<div class="line"><span class="lineno"> 8791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8792</span><span class="stringliteral">    As shown in [2]_, for one-dimensional real-valued variables, the energy</span></div>
<div class="line"><span class="lineno"> 8793</span><span class="stringliteral">    distance is linked to the non-distribution-free version of the Cramr-von</span></div>
<div class="line"><span class="lineno"> 8794</span><span class="stringliteral">    Mises distance:</span></div>
<div class="line"><span class="lineno"> 8795</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8796</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 8797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8798</span><span class="stringliteral">        D(u, v) = \sqrt{2} l_2(u, v) = \left( 2 \int_{-\infty}^{+\infty} (U-V)^2</span></div>
<div class="line"><span class="lineno"> 8799</span><span class="stringliteral">        \right)^{1/2}</span></div>
<div class="line"><span class="lineno"> 8800</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8801</span><span class="stringliteral">    Note that the common Cramr-von Mises criterion uses the distribution-free</span></div>
<div class="line"><span class="lineno"> 8802</span><span class="stringliteral">    version of the distance. See [2]_ (section 2), for more details about both</span></div>
<div class="line"><span class="lineno"> 8803</span><span class="stringliteral">    versions of the distance.</span></div>
<div class="line"><span class="lineno"> 8804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8805</span><span class="stringliteral">    The input distributions can be empirical, therefore coming from samples</span></div>
<div class="line"><span class="lineno"> 8806</span><span class="stringliteral">    whose values are effectively inputs of the function, or they can be seen as</span></div>
<div class="line"><span class="lineno"> 8807</span><span class="stringliteral">    generalized functions, in which case they are weighted sums of Dirac delta</span></div>
<div class="line"><span class="lineno"> 8808</span><span class="stringliteral">    functions located at the specified values.</span></div>
<div class="line"><span class="lineno"> 8809</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8810</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8811</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8812</span><span class="stringliteral">    .. [1] Rizzo, Szekely &quot;Energy distance.&quot; Wiley Interdisciplinary Reviews:</span></div>
<div class="line"><span class="lineno"> 8813</span><span class="stringliteral">           Computational Statistics, 8(1):27-38 (2015).</span></div>
<div class="line"><span class="lineno"> 8814</span><span class="stringliteral">    .. [2] Szekely &quot;E-statistics: The energy of statistical samples.&quot; Bowling</span></div>
<div class="line"><span class="lineno"> 8815</span><span class="stringliteral">           Green State University, Department of Mathematics and Statistics,</span></div>
<div class="line"><span class="lineno"> 8816</span><span class="stringliteral">           Technical Report 02-16 (2002).</span></div>
<div class="line"><span class="lineno"> 8817</span><span class="stringliteral">    .. [3] &quot;Energy distance&quot;, https://en.wikipedia.org/wiki/Energy_distance</span></div>
<div class="line"><span class="lineno"> 8818</span><span class="stringliteral">    .. [4] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer,</span></div>
<div class="line"><span class="lineno"> 8819</span><span class="stringliteral">           Munos &quot;The Cramer Distance as a Solution to Biased Wasserstein</span></div>
<div class="line"><span class="lineno"> 8820</span><span class="stringliteral">           Gradients&quot; (2017). :arXiv:`1705.10743`.</span></div>
<div class="line"><span class="lineno"> 8821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8822</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 8823</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8824</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import energy_distance</span></div>
<div class="line"><span class="lineno"> 8825</span><span class="stringliteral">    &gt;&gt;&gt; energy_distance([0], [2])</span></div>
<div class="line"><span class="lineno"> 8826</span><span class="stringliteral">    2.0000000000000004</span></div>
<div class="line"><span class="lineno"> 8827</span><span class="stringliteral">    &gt;&gt;&gt; energy_distance([0, 8], [0, 8], [3, 1], [2, 2])</span></div>
<div class="line"><span class="lineno"> 8828</span><span class="stringliteral">    1.0000000000000002</span></div>
<div class="line"><span class="lineno"> 8829</span><span class="stringliteral">    &gt;&gt;&gt; energy_distance([0.7, 7.4, 2.4, 6.8], [1.4, 8. ],</span></div>
<div class="line"><span class="lineno"> 8830</span><span class="stringliteral">    ...                 [2.1, 4.2, 7.4, 8. ], [7.6, 8.8])</span></div>
<div class="line"><span class="lineno"> 8831</span><span class="stringliteral">    0.88003340976158217</span></div>
<div class="line"><span class="lineno"> 8832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8833</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8834</span>    <span class="keywordflow">return</span> np.sqrt(2) * _cdf_distance(2, u_values, v_values,</div>
<div class="line"><span class="lineno"> 8835</span>                                      u_weights, v_weights)</div>
<div class="line"><span class="lineno"> 8836</span> </div>
<div class="line"><span class="lineno"> 8837</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7771f3b2db7c5785f3c8395389ec7b76" name="a7771f3b2db7c5785f3c8395389ec7b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7771f3b2db7c5785f3c8395389ec7b76">&#9670;&#160;</a></span>f_oneway()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.f_oneway </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform one-way ANOVA.

The one-way ANOVA tests the null hypothesis that two or more groups have
the same population mean.  The test is applied to samples from two or
more groups, possibly with differing sizes.

Parameters
----------
sample1, sample2, ... : array_like
    The sample measurements for each group.  There must be at least
    two arguments.  If the arrays are multidimensional, then all the
    dimensions of the array must be the same except for `axis`.
axis : int, optional
    Axis of the input arrays along which the test is applied.
    Default is 0.

Returns
-------
statistic : float
    The computed F statistic of the test.
pvalue : float
    The associated p-value from the F distribution.

Warns
-----
`~scipy.stats.ConstantInputWarning`
    Raised if all values within each of the input arrays are identical.
    In this case the F statistic is either infinite or isn't defined,
    so ``np.inf`` or ``np.nan`` is returned.

`~scipy.stats.DegenerateDataWarning`
    Raised if the length of any input array is 0, or if all the input
    arrays have length 1.  ``np.nan`` is returned for the F statistic
    and the p-value in these cases.

Notes
-----
The ANOVA test has important assumptions that must be satisfied in order
for the associated p-value to be valid.

1. The samples are independent.
2. Each sample is from a normally distributed population.
3. The population standard deviations of the groups are all equal.  This
   property is known as homoscedasticity.

If these assumptions are not true for a given set of data, it may still
be possible to use the Kruskal-Wallis H-test (`scipy.stats.kruskal`) or
the Alexander-Govern test (`scipy.stats.alexandergovern`) although with
some loss of power.

The length of each group must be at least one, and there must be at
least one group with length greater than one.  If these conditions
are not satisfied, a warning is generated and (``np.nan``, ``np.nan``)
is returned.

If all values in each group are identical, and there exist at least two
groups with different values, the function generates a warning and
returns (``np.inf``, 0).

If all values in all groups are the same, function generates a warning
and returns (``np.nan``, ``np.nan``).

The algorithm is from Heiman [2]_, pp.394-7.

References
----------
.. [1] R. Lowry, "Concepts and Applications of Inferential Statistics",
       Chapter 14, 2014, http://vassarstats.net/textbook/

.. [2] G.W. Heiman, "Understanding research methods and statistics: An
       integrated introduction for psychology", Houghton, Mifflin and
       Company, 2001.

.. [3] G.H. McDonald, "Handbook of Biological Statistics", One-way ANOVA.
       http://www.biostathandbook.com/onewayanova.html

Examples
--------
&gt;&gt;&gt; from scipy.stats import f_oneway

Here are some data [3]_ on a shell measurement (the length of the anterior
adductor muscle scar, standardized by dividing by length) in the mussel
Mytilus trossulus from five locations: Tillamook, Oregon; Newport, Oregon;
Petersburg, Alaska; Magadan, Russia; and Tvarminne, Finland, taken from a
much larger data set used in McDonald et al. (1991).

&gt;&gt;&gt; tillamook = [0.0571, 0.0813, 0.0831, 0.0976, 0.0817, 0.0859, 0.0735,
...              0.0659, 0.0923, 0.0836]
&gt;&gt;&gt; newport = [0.0873, 0.0662, 0.0672, 0.0819, 0.0749, 0.0649, 0.0835,
...            0.0725]
&gt;&gt;&gt; petersburg = [0.0974, 0.1352, 0.0817, 0.1016, 0.0968, 0.1064, 0.105]
&gt;&gt;&gt; magadan = [0.1033, 0.0915, 0.0781, 0.0685, 0.0677, 0.0697, 0.0764,
...            0.0689]
&gt;&gt;&gt; tvarminne = [0.0703, 0.1026, 0.0956, 0.0973, 0.1039, 0.1045]
&gt;&gt;&gt; f_oneway(tillamook, newport, petersburg, magadan, tvarminne)
F_onewayResult(statistic=7.121019471642447, pvalue=0.0002812242314534544)

`f_oneway` accepts multidimensional input arrays.  When the inputs
are multidimensional and `axis` is not given, the test is performed
along the first axis of the input arrays.  For the following data, the
test is performed three times, once for each column.

&gt;&gt;&gt; a = np.array([[9.87, 9.03, 6.81],
...               [7.18, 8.35, 7.00],
...               [8.39, 7.58, 7.68],
...               [7.45, 6.33, 9.35],
...               [6.41, 7.10, 9.33],
...               [8.00, 8.24, 8.44]])
&gt;&gt;&gt; b = np.array([[6.35, 7.30, 7.16],
...               [6.65, 6.68, 7.63],
...               [5.72, 7.73, 6.72],
...               [7.01, 9.19, 7.41],
...               [7.75, 7.87, 8.30],
...               [6.90, 7.97, 6.97]])
&gt;&gt;&gt; c = np.array([[3.31, 8.77, 1.01],
...               [8.25, 3.24, 3.62],
...               [6.32, 8.81, 5.19],
...               [7.48, 8.83, 8.91],
...               [8.59, 6.01, 6.07],
...               [3.07, 9.72, 7.48]])
&gt;&gt;&gt; F, p = f_oneway(a, b, c)
&gt;&gt;&gt; F
array([1.75676344, 0.03701228, 3.76439349])
&gt;&gt;&gt; p
array([0.20630784, 0.96375203, 0.04733157])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3725</span><span class="keyword">def </span>f_oneway(*samples, axis=0):</div>
<div class="line"><span class="lineno"> 3726</span>    <span class="stringliteral">&quot;&quot;&quot;Perform one-way ANOVA.</span></div>
<div class="line"><span class="lineno"> 3727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3728</span><span class="stringliteral">    The one-way ANOVA tests the null hypothesis that two or more groups have</span></div>
<div class="line"><span class="lineno"> 3729</span><span class="stringliteral">    the same population mean.  The test is applied to samples from two or</span></div>
<div class="line"><span class="lineno"> 3730</span><span class="stringliteral">    more groups, possibly with differing sizes.</span></div>
<div class="line"><span class="lineno"> 3731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3732</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3733</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3734</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 3735</span><span class="stringliteral">        The sample measurements for each group.  There must be at least</span></div>
<div class="line"><span class="lineno"> 3736</span><span class="stringliteral">        two arguments.  If the arrays are multidimensional, then all the</span></div>
<div class="line"><span class="lineno"> 3737</span><span class="stringliteral">        dimensions of the array must be the same except for `axis`.</span></div>
<div class="line"><span class="lineno"> 3738</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 3739</span><span class="stringliteral">        Axis of the input arrays along which the test is applied.</span></div>
<div class="line"><span class="lineno"> 3740</span><span class="stringliteral">        Default is 0.</span></div>
<div class="line"><span class="lineno"> 3741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3742</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3743</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3744</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 3745</span><span class="stringliteral">        The computed F statistic of the test.</span></div>
<div class="line"><span class="lineno"> 3746</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 3747</span><span class="stringliteral">        The associated p-value from the F distribution.</span></div>
<div class="line"><span class="lineno"> 3748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3749</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno"> 3750</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3751</span><span class="stringliteral">    `~scipy.stats.ConstantInputWarning`</span></div>
<div class="line"><span class="lineno"> 3752</span><span class="stringliteral">        Raised if all values within each of the input arrays are identical.</span></div>
<div class="line"><span class="lineno"> 3753</span><span class="stringliteral">        In this case the F statistic is either infinite or isn&#39;t defined,</span></div>
<div class="line"><span class="lineno"> 3754</span><span class="stringliteral">        so ``np.inf`` or ``np.nan`` is returned.</span></div>
<div class="line"><span class="lineno"> 3755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3756</span><span class="stringliteral">    `~scipy.stats.DegenerateDataWarning`</span></div>
<div class="line"><span class="lineno"> 3757</span><span class="stringliteral">        Raised if the length of any input array is 0, or if all the input</span></div>
<div class="line"><span class="lineno"> 3758</span><span class="stringliteral">        arrays have length 1.  ``np.nan`` is returned for the F statistic</span></div>
<div class="line"><span class="lineno"> 3759</span><span class="stringliteral">        and the p-value in these cases.</span></div>
<div class="line"><span class="lineno"> 3760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3761</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3762</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3763</span><span class="stringliteral">    The ANOVA test has important assumptions that must be satisfied in order</span></div>
<div class="line"><span class="lineno"> 3764</span><span class="stringliteral">    for the associated p-value to be valid.</span></div>
<div class="line"><span class="lineno"> 3765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3766</span><span class="stringliteral">    1. The samples are independent.</span></div>
<div class="line"><span class="lineno"> 3767</span><span class="stringliteral">    2. Each sample is from a normally distributed population.</span></div>
<div class="line"><span class="lineno"> 3768</span><span class="stringliteral">    3. The population standard deviations of the groups are all equal.  This</span></div>
<div class="line"><span class="lineno"> 3769</span><span class="stringliteral">       property is known as homoscedasticity.</span></div>
<div class="line"><span class="lineno"> 3770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3771</span><span class="stringliteral">    If these assumptions are not true for a given set of data, it may still</span></div>
<div class="line"><span class="lineno"> 3772</span><span class="stringliteral">    be possible to use the Kruskal-Wallis H-test (`scipy.stats.kruskal`) or</span></div>
<div class="line"><span class="lineno"> 3773</span><span class="stringliteral">    the Alexander-Govern test (`scipy.stats.alexandergovern`) although with</span></div>
<div class="line"><span class="lineno"> 3774</span><span class="stringliteral">    some loss of power.</span></div>
<div class="line"><span class="lineno"> 3775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3776</span><span class="stringliteral">    The length of each group must be at least one, and there must be at</span></div>
<div class="line"><span class="lineno"> 3777</span><span class="stringliteral">    least one group with length greater than one.  If these conditions</span></div>
<div class="line"><span class="lineno"> 3778</span><span class="stringliteral">    are not satisfied, a warning is generated and (``np.nan``, ``np.nan``)</span></div>
<div class="line"><span class="lineno"> 3779</span><span class="stringliteral">    is returned.</span></div>
<div class="line"><span class="lineno"> 3780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3781</span><span class="stringliteral">    If all values in each group are identical, and there exist at least two</span></div>
<div class="line"><span class="lineno"> 3782</span><span class="stringliteral">    groups with different values, the function generates a warning and</span></div>
<div class="line"><span class="lineno"> 3783</span><span class="stringliteral">    returns (``np.inf``, 0).</span></div>
<div class="line"><span class="lineno"> 3784</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3785</span><span class="stringliteral">    If all values in all groups are the same, function generates a warning</span></div>
<div class="line"><span class="lineno"> 3786</span><span class="stringliteral">    and returns (``np.nan``, ``np.nan``).</span></div>
<div class="line"><span class="lineno"> 3787</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3788</span><span class="stringliteral">    The algorithm is from Heiman [2]_, pp.394-7.</span></div>
<div class="line"><span class="lineno"> 3789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3790</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3791</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3792</span><span class="stringliteral">    .. [1] R. Lowry, &quot;Concepts and Applications of Inferential Statistics&quot;,</span></div>
<div class="line"><span class="lineno"> 3793</span><span class="stringliteral">           Chapter 14, 2014, http://vassarstats.net/textbook/</span></div>
<div class="line"><span class="lineno"> 3794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3795</span><span class="stringliteral">    .. [2] G.W. Heiman, &quot;Understanding research methods and statistics: An</span></div>
<div class="line"><span class="lineno"> 3796</span><span class="stringliteral">           integrated introduction for psychology&quot;, Houghton, Mifflin and</span></div>
<div class="line"><span class="lineno"> 3797</span><span class="stringliteral">           Company, 2001.</span></div>
<div class="line"><span class="lineno"> 3798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3799</span><span class="stringliteral">    .. [3] G.H. McDonald, &quot;Handbook of Biological Statistics&quot;, One-way ANOVA.</span></div>
<div class="line"><span class="lineno"> 3800</span><span class="stringliteral">           http://www.biostathandbook.com/onewayanova.html</span></div>
<div class="line"><span class="lineno"> 3801</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3802</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3803</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3804</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import f_oneway</span></div>
<div class="line"><span class="lineno"> 3805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3806</span><span class="stringliteral">    Here are some data [3]_ on a shell measurement (the length of the anterior</span></div>
<div class="line"><span class="lineno"> 3807</span><span class="stringliteral">    adductor muscle scar, standardized by dividing by length) in the mussel</span></div>
<div class="line"><span class="lineno"> 3808</span><span class="stringliteral">    Mytilus trossulus from five locations: Tillamook, Oregon; Newport, Oregon;</span></div>
<div class="line"><span class="lineno"> 3809</span><span class="stringliteral">    Petersburg, Alaska; Magadan, Russia; and Tvarminne, Finland, taken from a</span></div>
<div class="line"><span class="lineno"> 3810</span><span class="stringliteral">    much larger data set used in McDonald et al. (1991).</span></div>
<div class="line"><span class="lineno"> 3811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3812</span><span class="stringliteral">    &gt;&gt;&gt; tillamook = [0.0571, 0.0813, 0.0831, 0.0976, 0.0817, 0.0859, 0.0735,</span></div>
<div class="line"><span class="lineno"> 3813</span><span class="stringliteral">    ...              0.0659, 0.0923, 0.0836]</span></div>
<div class="line"><span class="lineno"> 3814</span><span class="stringliteral">    &gt;&gt;&gt; newport = [0.0873, 0.0662, 0.0672, 0.0819, 0.0749, 0.0649, 0.0835,</span></div>
<div class="line"><span class="lineno"> 3815</span><span class="stringliteral">    ...            0.0725]</span></div>
<div class="line"><span class="lineno"> 3816</span><span class="stringliteral">    &gt;&gt;&gt; petersburg = [0.0974, 0.1352, 0.0817, 0.1016, 0.0968, 0.1064, 0.105]</span></div>
<div class="line"><span class="lineno"> 3817</span><span class="stringliteral">    &gt;&gt;&gt; magadan = [0.1033, 0.0915, 0.0781, 0.0685, 0.0677, 0.0697, 0.0764,</span></div>
<div class="line"><span class="lineno"> 3818</span><span class="stringliteral">    ...            0.0689]</span></div>
<div class="line"><span class="lineno"> 3819</span><span class="stringliteral">    &gt;&gt;&gt; tvarminne = [0.0703, 0.1026, 0.0956, 0.0973, 0.1039, 0.1045]</span></div>
<div class="line"><span class="lineno"> 3820</span><span class="stringliteral">    &gt;&gt;&gt; f_oneway(tillamook, newport, petersburg, magadan, tvarminne)</span></div>
<div class="line"><span class="lineno"> 3821</span><span class="stringliteral">    F_onewayResult(statistic=7.121019471642447, pvalue=0.0002812242314534544)</span></div>
<div class="line"><span class="lineno"> 3822</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3823</span><span class="stringliteral">    `f_oneway` accepts multidimensional input arrays.  When the inputs</span></div>
<div class="line"><span class="lineno"> 3824</span><span class="stringliteral">    are multidimensional and `axis` is not given, the test is performed</span></div>
<div class="line"><span class="lineno"> 3825</span><span class="stringliteral">    along the first axis of the input arrays.  For the following data, the</span></div>
<div class="line"><span class="lineno"> 3826</span><span class="stringliteral">    test is performed three times, once for each column.</span></div>
<div class="line"><span class="lineno"> 3827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3828</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[9.87, 9.03, 6.81],</span></div>
<div class="line"><span class="lineno"> 3829</span><span class="stringliteral">    ...               [7.18, 8.35, 7.00],</span></div>
<div class="line"><span class="lineno"> 3830</span><span class="stringliteral">    ...               [8.39, 7.58, 7.68],</span></div>
<div class="line"><span class="lineno"> 3831</span><span class="stringliteral">    ...               [7.45, 6.33, 9.35],</span></div>
<div class="line"><span class="lineno"> 3832</span><span class="stringliteral">    ...               [6.41, 7.10, 9.33],</span></div>
<div class="line"><span class="lineno"> 3833</span><span class="stringliteral">    ...               [8.00, 8.24, 8.44]])</span></div>
<div class="line"><span class="lineno"> 3834</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[6.35, 7.30, 7.16],</span></div>
<div class="line"><span class="lineno"> 3835</span><span class="stringliteral">    ...               [6.65, 6.68, 7.63],</span></div>
<div class="line"><span class="lineno"> 3836</span><span class="stringliteral">    ...               [5.72, 7.73, 6.72],</span></div>
<div class="line"><span class="lineno"> 3837</span><span class="stringliteral">    ...               [7.01, 9.19, 7.41],</span></div>
<div class="line"><span class="lineno"> 3838</span><span class="stringliteral">    ...               [7.75, 7.87, 8.30],</span></div>
<div class="line"><span class="lineno"> 3839</span><span class="stringliteral">    ...               [6.90, 7.97, 6.97]])</span></div>
<div class="line"><span class="lineno"> 3840</span><span class="stringliteral">    &gt;&gt;&gt; c = np.array([[3.31, 8.77, 1.01],</span></div>
<div class="line"><span class="lineno"> 3841</span><span class="stringliteral">    ...               [8.25, 3.24, 3.62],</span></div>
<div class="line"><span class="lineno"> 3842</span><span class="stringliteral">    ...               [6.32, 8.81, 5.19],</span></div>
<div class="line"><span class="lineno"> 3843</span><span class="stringliteral">    ...               [7.48, 8.83, 8.91],</span></div>
<div class="line"><span class="lineno"> 3844</span><span class="stringliteral">    ...               [8.59, 6.01, 6.07],</span></div>
<div class="line"><span class="lineno"> 3845</span><span class="stringliteral">    ...               [3.07, 9.72, 7.48]])</span></div>
<div class="line"><span class="lineno"> 3846</span><span class="stringliteral">    &gt;&gt;&gt; F, p = f_oneway(a, b, c)</span></div>
<div class="line"><span class="lineno"> 3847</span><span class="stringliteral">    &gt;&gt;&gt; F</span></div>
<div class="line"><span class="lineno"> 3848</span><span class="stringliteral">    array([1.75676344, 0.03701228, 3.76439349])</span></div>
<div class="line"><span class="lineno"> 3849</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 3850</span><span class="stringliteral">    array([0.20630784, 0.96375203, 0.04733157])</span></div>
<div class="line"><span class="lineno"> 3851</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3852</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3853</span>    <span class="keywordflow">if</span> len(samples) &lt; 2:</div>
<div class="line"><span class="lineno"> 3854</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;at least two inputs are required;&#39;</span></div>
<div class="line"><span class="lineno"> 3855</span>                        f<span class="stringliteral">&#39; got {len(samples)}.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3856</span> </div>
<div class="line"><span class="lineno"> 3857</span>    samples = [np.asarray(sample, dtype=float) <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples]</div>
<div class="line"><span class="lineno"> 3858</span> </div>
<div class="line"><span class="lineno"> 3859</span>    <span class="comment"># ANOVA on N groups, each in its own array</span></div>
<div class="line"><span class="lineno"> 3860</span>    num_groups = len(samples)</div>
<div class="line"><span class="lineno"> 3861</span> </div>
<div class="line"><span class="lineno"> 3862</span>    <span class="comment"># We haven&#39;t explicitly validated axis, but if it is bad, this call of</span></div>
<div class="line"><span class="lineno"> 3863</span>    <span class="comment"># np.concatenate will raise np.AxisError.  The call will raise ValueError</span></div>
<div class="line"><span class="lineno"> 3864</span>    <span class="comment"># if the dimensions of all the arrays, except the axis dimension, are not</span></div>
<div class="line"><span class="lineno"> 3865</span>    <span class="comment"># the same.</span></div>
<div class="line"><span class="lineno"> 3866</span>    alldata = np.concatenate(samples, axis=axis)</div>
<div class="line"><span class="lineno"> 3867</span>    bign = alldata.shape[axis]</div>
<div class="line"><span class="lineno"> 3868</span> </div>
<div class="line"><span class="lineno"> 3869</span>    <span class="comment"># Check this after forming alldata, so shape errors are detected</span></div>
<div class="line"><span class="lineno"> 3870</span>    <span class="comment"># and reported before checking for 0 length inputs.</span></div>
<div class="line"><span class="lineno"> 3871</span>    <span class="keywordflow">if</span> any(sample.shape[axis] == 0 <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples):</div>
<div class="line"><span class="lineno"> 3872</span>        warnings.warn(stats.DegenerateDataWarning(<span class="stringliteral">&#39;at least one input &#39;</span></div>
<div class="line"><span class="lineno"> 3873</span>                                                  <span class="stringliteral">&#39;has length 0&#39;</span>))</div>
<div class="line"><span class="lineno"> 3874</span>        <span class="keywordflow">return</span> _create_f_oneway_nan_result(alldata.shape, axis)</div>
<div class="line"><span class="lineno"> 3875</span> </div>
<div class="line"><span class="lineno"> 3876</span>    <span class="comment"># Must have at least one group with length greater than 1.</span></div>
<div class="line"><span class="lineno"> 3877</span>    <span class="keywordflow">if</span> all(sample.shape[axis] == 1 <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples):</div>
<div class="line"><span class="lineno"> 3878</span>        msg = (<span class="stringliteral">&#39;all input arrays have length 1.  f_oneway requires that at &#39;</span></div>
<div class="line"><span class="lineno"> 3879</span>               <span class="stringliteral">&#39;least one input has length greater than 1.&#39;</span>)</div>
<div class="line"><span class="lineno"> 3880</span>        warnings.warn(stats.DegenerateDataWarning(msg))</div>
<div class="line"><span class="lineno"> 3881</span>        <span class="keywordflow">return</span> _create_f_oneway_nan_result(alldata.shape, axis)</div>
<div class="line"><span class="lineno"> 3882</span> </div>
<div class="line"><span class="lineno"> 3883</span>    <span class="comment"># Check if all values within each group are identical, and if the common</span></div>
<div class="line"><span class="lineno"> 3884</span>    <span class="comment"># value in at least one group is different from that in another group.</span></div>
<div class="line"><span class="lineno"> 3885</span>    <span class="comment"># Based on https://github.com/scipy/scipy/issues/11669</span></div>
<div class="line"><span class="lineno"> 3886</span> </div>
<div class="line"><span class="lineno"> 3887</span>    <span class="comment"># If axis=0, say, and the groups have shape (n0, ...), (n1, ...), ...,</span></div>
<div class="line"><span class="lineno"> 3888</span>    <span class="comment"># then is_const is a boolean array with shape (num_groups, ...).</span></div>
<div class="line"><span class="lineno"> 3889</span>    <span class="comment"># It is True if the values within the groups along the axis slice are</span></div>
<div class="line"><span class="lineno"> 3890</span>    <span class="comment"># identical. In the typical case where each input array is 1-d, is_const is</span></div>
<div class="line"><span class="lineno"> 3891</span>    <span class="comment"># a 1-d array with length num_groups.</span></div>
<div class="line"><span class="lineno"> 3892</span>    is_const = np.concatenate(</div>
<div class="line"><span class="lineno"> 3893</span>        [(_first(sample, axis) == sample).all(axis=axis,</div>
<div class="line"><span class="lineno"> 3894</span>                                              keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3895</span>         <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples],</div>
<div class="line"><span class="lineno"> 3896</span>        axis=axis</div>
<div class="line"><span class="lineno"> 3897</span>    )</div>
<div class="line"><span class="lineno"> 3898</span> </div>
<div class="line"><span class="lineno"> 3899</span>    <span class="comment"># all_const is a boolean array with shape (...) (see previous comment).</span></div>
<div class="line"><span class="lineno"> 3900</span>    <span class="comment"># It is True if the values within each group along the axis slice are</span></div>
<div class="line"><span class="lineno"> 3901</span>    <span class="comment"># the same (e.g. [[3, 3, 3], [5, 5, 5, 5], [4, 4, 4]]).</span></div>
<div class="line"><span class="lineno"> 3902</span>    all_const = is_const.all(axis=axis)</div>
<div class="line"><span class="lineno"> 3903</span>    <span class="keywordflow">if</span> all_const.any():</div>
<div class="line"><span class="lineno"> 3904</span>        msg = (<span class="stringliteral">&quot;Each of the input arrays is constant;&quot;</span></div>
<div class="line"><span class="lineno"> 3905</span>               <span class="stringliteral">&quot;the F statistic is not defined or infinite&quot;</span>)</div>
<div class="line"><span class="lineno"> 3906</span>        warnings.warn(stats.ConstantInputWarning(msg))</div>
<div class="line"><span class="lineno"> 3907</span> </div>
<div class="line"><span class="lineno"> 3908</span>    <span class="comment"># all_same_const is True if all the values in the groups along the axis=0</span></div>
<div class="line"><span class="lineno"> 3909</span>    <span class="comment"># slice are the same (e.g. [[3, 3, 3], [3, 3, 3, 3], [3, 3, 3]]).</span></div>
<div class="line"><span class="lineno"> 3910</span>    all_same_const = (_first(alldata, axis) == alldata).all(axis=axis)</div>
<div class="line"><span class="lineno"> 3911</span> </div>
<div class="line"><span class="lineno"> 3912</span>    <span class="comment"># Determine the mean of the data, and subtract that from all inputs to a</span></div>
<div class="line"><span class="lineno"> 3913</span>    <span class="comment"># variance (via sum_of_sq / sq_of_sum) calculation.  Variance is invariant</span></div>
<div class="line"><span class="lineno"> 3914</span>    <span class="comment"># to a shift in location, and centering all data around zero vastly</span></div>
<div class="line"><span class="lineno"> 3915</span>    <span class="comment"># improves numerical stability.</span></div>
<div class="line"><span class="lineno"> 3916</span>    offset = alldata.mean(axis=axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3917</span>    alldata -= offset</div>
<div class="line"><span class="lineno"> 3918</span> </div>
<div class="line"><span class="lineno"> 3919</span>    normalized_ss = _square_of_sums(alldata, axis=axis) / bign</div>
<div class="line"><span class="lineno"> 3920</span> </div>
<div class="line"><span class="lineno"> 3921</span>    sstot = _sum_of_squares(alldata, axis=axis) - normalized_ss</div>
<div class="line"><span class="lineno"> 3922</span> </div>
<div class="line"><span class="lineno"> 3923</span>    ssbn = 0</div>
<div class="line"><span class="lineno"> 3924</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples:</div>
<div class="line"><span class="lineno"> 3925</span>        ssbn += _square_of_sums(sample - offset,</div>
<div class="line"><span class="lineno"> 3926</span>                                axis=axis) / sample.shape[axis]</div>
<div class="line"><span class="lineno"> 3927</span> </div>
<div class="line"><span class="lineno"> 3928</span>    <span class="comment"># Naming: variables ending in bn/b are for &quot;between treatments&quot;, wn/w are</span></div>
<div class="line"><span class="lineno"> 3929</span>    <span class="comment"># for &quot;within treatments&quot;</span></div>
<div class="line"><span class="lineno"> 3930</span>    ssbn -= normalized_ss</div>
<div class="line"><span class="lineno"> 3931</span>    sswn = sstot - ssbn</div>
<div class="line"><span class="lineno"> 3932</span>    dfbn = num_groups - 1</div>
<div class="line"><span class="lineno"> 3933</span>    dfwn = bign - num_groups</div>
<div class="line"><span class="lineno"> 3934</span>    msb = ssbn / dfbn</div>
<div class="line"><span class="lineno"> 3935</span>    msw = sswn / dfwn</div>
<div class="line"><span class="lineno"> 3936</span>    <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>, invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 3937</span>        f = msb / msw</div>
<div class="line"><span class="lineno"> 3938</span> </div>
<div class="line"><span class="lineno"> 3939</span>    prob = special.fdtrc(dfbn, dfwn, f)   <span class="comment"># equivalent to stats.f.sf</span></div>
<div class="line"><span class="lineno"> 3940</span> </div>
<div class="line"><span class="lineno"> 3941</span>    <span class="comment"># Fix any f values that should be inf or nan because the corresponding</span></div>
<div class="line"><span class="lineno"> 3942</span>    <span class="comment"># inputs were constant.</span></div>
<div class="line"><span class="lineno"> 3943</span>    <span class="keywordflow">if</span> np.isscalar(f):</div>
<div class="line"><span class="lineno"> 3944</span>        <span class="keywordflow">if</span> all_same_const:</div>
<div class="line"><span class="lineno"> 3945</span>            f = np.nan</div>
<div class="line"><span class="lineno"> 3946</span>            prob = np.nan</div>
<div class="line"><span class="lineno"> 3947</span>        <span class="keywordflow">elif</span> all_const:</div>
<div class="line"><span class="lineno"> 3948</span>            f = np.inf</div>
<div class="line"><span class="lineno"> 3949</span>            prob = 0.0</div>
<div class="line"><span class="lineno"> 3950</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3951</span>        f[all_const] = np.inf</div>
<div class="line"><span class="lineno"> 3952</span>        prob[all_const] = 0.0</div>
<div class="line"><span class="lineno"> 3953</span>        f[all_same_const] = np.nan</div>
<div class="line"><span class="lineno"> 3954</span>        prob[all_same_const] = np.nan</div>
<div class="line"><span class="lineno"> 3955</span> </div>
<div class="line"><span class="lineno"> 3956</span>    <span class="keywordflow">return</span> F_onewayResult(f, prob)</div>
<div class="line"><span class="lineno"> 3957</span> </div>
<div class="line"><span class="lineno"> 3958</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6394edc619f56ba4b055ea6050b269e6" name="a6394edc619f56ba4b055ea6050b269e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394edc619f56ba4b055ea6050b269e6">&#9670;&#160;</a></span>find_repeats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.find_repeats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find repeats and repeat counts.

Parameters
----------
arr : array_like
    Input array. This is cast to float64.

Returns
-------
values : ndarray
    The unique values from the (flattened) input that are repeated.

counts : ndarray
    Number of times the corresponding 'value' is repeated.

Notes
-----
In numpy &gt;= 1.9 `numpy.unique` provides similar functionality. The main
difference is that `find_repeats` only returns repeated values.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.find_repeats([2, 1, 2, 3, 2, 2, 5])
RepeatedResults(values=array([2.]), counts=array([4]))

&gt;&gt;&gt; stats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]])
RepeatedResults(values=array([4.,  5.]), counts=array([2, 2]))</pre> <div class="fragment"><div class="line"><span class="lineno"> 8975</span><span class="keyword">def </span>find_repeats(arr):</div>
<div class="line"><span class="lineno"> 8976</span>    <span class="stringliteral">&quot;&quot;&quot;Find repeats and repeat counts.</span></div>
<div class="line"><span class="lineno"> 8977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8978</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8979</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8980</span><span class="stringliteral">    arr : array_like</span></div>
<div class="line"><span class="lineno"> 8981</span><span class="stringliteral">        Input array. This is cast to float64.</span></div>
<div class="line"><span class="lineno"> 8982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8983</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8984</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8985</span><span class="stringliteral">    values : ndarray</span></div>
<div class="line"><span class="lineno"> 8986</span><span class="stringliteral">        The unique values from the (flattened) input that are repeated.</span></div>
<div class="line"><span class="lineno"> 8987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8988</span><span class="stringliteral">    counts : ndarray</span></div>
<div class="line"><span class="lineno"> 8989</span><span class="stringliteral">        Number of times the corresponding &#39;value&#39; is repeated.</span></div>
<div class="line"><span class="lineno"> 8990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8991</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8992</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8993</span><span class="stringliteral">    In numpy &gt;= 1.9 `numpy.unique` provides similar functionality. The main</span></div>
<div class="line"><span class="lineno"> 8994</span><span class="stringliteral">    difference is that `find_repeats` only returns repeated values.</span></div>
<div class="line"><span class="lineno"> 8995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8996</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 8997</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8998</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 8999</span><span class="stringliteral">    &gt;&gt;&gt; stats.find_repeats([2, 1, 2, 3, 2, 2, 5])</span></div>
<div class="line"><span class="lineno"> 9000</span><span class="stringliteral">    RepeatedResults(values=array([2.]), counts=array([4]))</span></div>
<div class="line"><span class="lineno"> 9001</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9002</span><span class="stringliteral">    &gt;&gt;&gt; stats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]])</span></div>
<div class="line"><span class="lineno"> 9003</span><span class="stringliteral">    RepeatedResults(values=array([4.,  5.]), counts=array([2, 2]))</span></div>
<div class="line"><span class="lineno"> 9004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9005</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 9006</span>    <span class="comment"># Note: always copies.</span></div>
<div class="line"><span class="lineno"> 9007</span>    <span class="keywordflow">return</span> RepeatedResults(*_find_repeats(np.array(arr, dtype=np.float64)))</div>
<div class="line"><span class="lineno"> 9008</span> </div>
<div class="line"><span class="lineno"> 9009</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aec971e2362ba3d1144450412cfb4d674" name="aec971e2362ba3d1144450412cfb4d674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec971e2362ba3d1144450412cfb4d674">&#9670;&#160;</a></span>fisher_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.fisher_exact </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a Fisher exact test on a 2x2 contingency table.

The null hypothesis is that the true odds ratio of the populations
underlying the observations is one, and the observations were sampled
from these populations under a condition: the marginals of the
resulting table must equal those of the observed table. The statistic
returned is the unconditional maximum likelihood estimate of the odds
ratio, and the p-value is the probability under the null hypothesis of
obtaining a table at least as extreme as the one that was actually
observed. There are other possible choices of statistic and two-sided
p-value definition associated with Fisher's exact test; please see the
Notes for more information.

Parameters
----------
table : array_like of ints
    A 2x2 contingency table.  Elements must be non-negative integers.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the odds ratio of the underlying population is not one
    * 'less': the odds ratio of the underlying population is less than one
    * 'greater': the odds ratio of the underlying population is greater
      than one

    See the Notes for more details.

Returns
-------
oddsratio : float
    This is prior odds ratio and not a posterior estimate.
p_value : float
    P-value, the probability under the null hypothesis of obtaining a
    table at least as extreme as the one that was actually observed.

See Also
--------
chi2_contingency : Chi-square test of independence of variables in a
    contingency table.  This can be used as an alternative to
    `fisher_exact` when the numbers in the table are large.
barnard_exact : Barnard's exact test, which is a more powerful alternative
    than Fisher's exact test for 2x2 contingency tables.
boschloo_exact : Boschloo's exact test, which is a more powerful alternative
    than Fisher's exact test for 2x2 contingency tables.

Notes
-----
*Null hypothesis and p-values*

The null hypothesis is that the true odds ratio of the populations
underlying the observations is one, and the observations were sampled at
random from these populations under a condition: the marginals of the
resulting table must equal those of the observed table. Equivalently,
the null hypothesis is that the input table is from the hypergeometric
distribution with parameters (as used in `hypergeom`)
``M = a + b + c + d``, ``n = a + b`` and ``N = a + c``, where the
input table is ``[[a, b], [c, d]]``.  This distribution has support
``max(0, N + n - M) &lt;= x &lt;= min(N, n)``, or, in terms of the values
in the input table, ``min(0, a - d) &lt;= x &lt;= a + min(b, c)``.  ``x``
can be interpreted as the upper-left element of a 2x2 table, so the
tables in the distribution have form::

    [  x           n - x     ]
    [N - x    M - (n + N) + x]

For example, if::

    table = [6  2]
            [1  4]

then the support is ``2 &lt;= x &lt;= 7``, and the tables in the distribution
are::

    [2 6]   [3 5]   [4 4]   [5 3]   [6 2]  [7 1]
    [5 0]   [4 1]   [3 2]   [2 3]   [1 4]  [0 5]

The probability of each table is given by the hypergeometric distribution
``hypergeom.pmf(x, M, n, N)``.  For this example, these are (rounded to
three significant digits)::

    x       2      3      4      5       6        7
    p  0.0163  0.163  0.408  0.326  0.0816  0.00466

These can be computed with::

    &gt;&gt;&gt; from scipy.stats import hypergeom
    &gt;&gt;&gt; table = np.array([[6, 2], [1, 4]])
    &gt;&gt;&gt; M = table.sum()
    &gt;&gt;&gt; n = table[0].sum()
    &gt;&gt;&gt; N = table[:, 0].sum()
    &gt;&gt;&gt; start, end = hypergeom.support(M, n, N)
    &gt;&gt;&gt; hypergeom.pmf(np.arange(start, end+1), M, n, N)
    array([0.01631702, 0.16317016, 0.40792541, 0.32634033, 0.08158508,
           0.004662  ])

The two-sided p-value is the probability that, under the null hypothesis,
a random table would have a probability equal to or less than the
probability of the input table.  For our example, the probability of
the input table (where ``x = 6``) is 0.0816.  The x values where the
probability does not exceed this are 2, 6 and 7, so the two-sided p-value
is ``0.0163 + 0.0816 + 0.00466 ~= 0.10256``::

    &gt;&gt;&gt; from scipy.stats import fisher_exact
    &gt;&gt;&gt; oddsr, p = fisher_exact(table, alternative='two-sided')
    &gt;&gt;&gt; p
    0.10256410256410257

The one-sided p-value for ``alternative='greater'`` is the probability
that a random table has ``x &gt;= a``, which in our example is ``x &gt;= 6``,
or ``0.0816 + 0.00466 ~= 0.08626``::

    &gt;&gt;&gt; oddsr, p = fisher_exact(table, alternative='greater')
    &gt;&gt;&gt; p
    0.08624708624708627

This is equivalent to computing the survival function of the
distribution at ``x = 5`` (one less than ``x`` from the input table,
because we want to include the probability of ``x = 6`` in the sum)::

    &gt;&gt;&gt; hypergeom.sf(5, M, n, N)
    0.08624708624708627

For ``alternative='less'``, the one-sided p-value is the probability
that a random table has ``x &lt;= a``, (i.e. ``x &lt;= 6`` in our example),
or ``0.0163 + 0.163 + 0.408 + 0.326 + 0.0816 ~= 0.9949``::

    &gt;&gt;&gt; oddsr, p = fisher_exact(table, alternative='less')
    &gt;&gt;&gt; p
    0.9953379953379957

This is equivalent to computing the cumulative distribution function
of the distribution at ``x = 6``:

    &gt;&gt;&gt; hypergeom.cdf(6, M, n, N)
    0.9953379953379957

*Odds ratio*

The calculated odds ratio is different from the one R uses. This SciPy
implementation returns the (more common) "unconditional Maximum
Likelihood Estimate", while R uses the "conditional Maximum Likelihood
Estimate".

Examples
--------
Say we spend a few days counting whales and sharks in the Atlantic and
Indian oceans. In the Atlantic ocean we find 8 whales and 1 shark, in the
Indian ocean 2 whales and 5 sharks. Then our contingency table is::

            Atlantic  Indian
    whales     8        2
    sharks     1        5

We use this table to find the p-value:

&gt;&gt;&gt; from scipy.stats import fisher_exact
&gt;&gt;&gt; oddsratio, pvalue = fisher_exact([[8, 2], [1, 5]])
&gt;&gt;&gt; pvalue
0.0349...

The probability that we would observe this or an even more imbalanced ratio
by chance is about 3.5%.  A commonly used significance level is 5%--if we
adopt that, we can therefore conclude that our observed imbalance is
statistically significant; whales prefer the Atlantic while sharks prefer
the Indian ocean.</pre> <div class="fragment"><div class="line"><span class="lineno"> 4495</span><span class="keyword">def </span>fisher_exact(table, alternative=&#39;two-sided&#39;):</div>
<div class="line"><span class="lineno"> 4496</span>    <span class="stringliteral">&quot;&quot;&quot;Perform a Fisher exact test on a 2x2 contingency table.</span></div>
<div class="line"><span class="lineno"> 4497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4498</span><span class="stringliteral">    The null hypothesis is that the true odds ratio of the populations</span></div>
<div class="line"><span class="lineno"> 4499</span><span class="stringliteral">    underlying the observations is one, and the observations were sampled</span></div>
<div class="line"><span class="lineno"> 4500</span><span class="stringliteral">    from these populations under a condition: the marginals of the</span></div>
<div class="line"><span class="lineno"> 4501</span><span class="stringliteral">    resulting table must equal those of the observed table. The statistic</span></div>
<div class="line"><span class="lineno"> 4502</span><span class="stringliteral">    returned is the unconditional maximum likelihood estimate of the odds</span></div>
<div class="line"><span class="lineno"> 4503</span><span class="stringliteral">    ratio, and the p-value is the probability under the null hypothesis of</span></div>
<div class="line"><span class="lineno"> 4504</span><span class="stringliteral">    obtaining a table at least as extreme as the one that was actually</span></div>
<div class="line"><span class="lineno"> 4505</span><span class="stringliteral">    observed. There are other possible choices of statistic and two-sided</span></div>
<div class="line"><span class="lineno"> 4506</span><span class="stringliteral">    p-value definition associated with Fisher&#39;s exact test; please see the</span></div>
<div class="line"><span class="lineno"> 4507</span><span class="stringliteral">    Notes for more information.</span></div>
<div class="line"><span class="lineno"> 4508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4509</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4510</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4511</span><span class="stringliteral">    table : array_like of ints</span></div>
<div class="line"><span class="lineno"> 4512</span><span class="stringliteral">        A 2x2 contingency table.  Elements must be non-negative integers.</span></div>
<div class="line"><span class="lineno"> 4513</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 4514</span><span class="stringliteral">        Defines the alternative hypothesis.</span></div>
<div class="line"><span class="lineno"> 4515</span><span class="stringliteral">        The following options are available (default is &#39;two-sided&#39;):</span></div>
<div class="line"><span class="lineno"> 4516</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4517</span><span class="stringliteral">        * &#39;two-sided&#39;: the odds ratio of the underlying population is not one</span></div>
<div class="line"><span class="lineno"> 4518</span><span class="stringliteral">        * &#39;less&#39;: the odds ratio of the underlying population is less than one</span></div>
<div class="line"><span class="lineno"> 4519</span><span class="stringliteral">        * &#39;greater&#39;: the odds ratio of the underlying population is greater</span></div>
<div class="line"><span class="lineno"> 4520</span><span class="stringliteral">          than one</span></div>
<div class="line"><span class="lineno"> 4521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4522</span><span class="stringliteral">        See the Notes for more details.</span></div>
<div class="line"><span class="lineno"> 4523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4524</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4525</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4526</span><span class="stringliteral">    oddsratio : float</span></div>
<div class="line"><span class="lineno"> 4527</span><span class="stringliteral">        This is prior odds ratio and not a posterior estimate.</span></div>
<div class="line"><span class="lineno"> 4528</span><span class="stringliteral">    p_value : float</span></div>
<div class="line"><span class="lineno"> 4529</span><span class="stringliteral">        P-value, the probability under the null hypothesis of obtaining a</span></div>
<div class="line"><span class="lineno"> 4530</span><span class="stringliteral">        table at least as extreme as the one that was actually observed.</span></div>
<div class="line"><span class="lineno"> 4531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4532</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4533</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4534</span><span class="stringliteral">    chi2_contingency : Chi-square test of independence of variables in a</span></div>
<div class="line"><span class="lineno"> 4535</span><span class="stringliteral">        contingency table.  This can be used as an alternative to</span></div>
<div class="line"><span class="lineno"> 4536</span><span class="stringliteral">        `fisher_exact` when the numbers in the table are large.</span></div>
<div class="line"><span class="lineno"> 4537</span><span class="stringliteral">    barnard_exact : Barnard&#39;s exact test, which is a more powerful alternative</span></div>
<div class="line"><span class="lineno"> 4538</span><span class="stringliteral">        than Fisher&#39;s exact test for 2x2 contingency tables.</span></div>
<div class="line"><span class="lineno"> 4539</span><span class="stringliteral">    boschloo_exact : Boschloo&#39;s exact test, which is a more powerful alternative</span></div>
<div class="line"><span class="lineno"> 4540</span><span class="stringliteral">        than Fisher&#39;s exact test for 2x2 contingency tables.</span></div>
<div class="line"><span class="lineno"> 4541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4542</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4543</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4544</span><span class="stringliteral">    *Null hypothesis and p-values*</span></div>
<div class="line"><span class="lineno"> 4545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4546</span><span class="stringliteral">    The null hypothesis is that the true odds ratio of the populations</span></div>
<div class="line"><span class="lineno"> 4547</span><span class="stringliteral">    underlying the observations is one, and the observations were sampled at</span></div>
<div class="line"><span class="lineno"> 4548</span><span class="stringliteral">    random from these populations under a condition: the marginals of the</span></div>
<div class="line"><span class="lineno"> 4549</span><span class="stringliteral">    resulting table must equal those of the observed table. Equivalently,</span></div>
<div class="line"><span class="lineno"> 4550</span><span class="stringliteral">    the null hypothesis is that the input table is from the hypergeometric</span></div>
<div class="line"><span class="lineno"> 4551</span><span class="stringliteral">    distribution with parameters (as used in `hypergeom`)</span></div>
<div class="line"><span class="lineno"> 4552</span><span class="stringliteral">    ``M = a + b + c + d``, ``n = a + b`` and ``N = a + c``, where the</span></div>
<div class="line"><span class="lineno"> 4553</span><span class="stringliteral">    input table is ``[[a, b], [c, d]]``.  This distribution has support</span></div>
<div class="line"><span class="lineno"> 4554</span><span class="stringliteral">    ``max(0, N + n - M) &lt;= x &lt;= min(N, n)``, or, in terms of the values</span></div>
<div class="line"><span class="lineno"> 4555</span><span class="stringliteral">    in the input table, ``min(0, a - d) &lt;= x &lt;= a + min(b, c)``.  ``x``</span></div>
<div class="line"><span class="lineno"> 4556</span><span class="stringliteral">    can be interpreted as the upper-left element of a 2x2 table, so the</span></div>
<div class="line"><span class="lineno"> 4557</span><span class="stringliteral">    tables in the distribution have form::</span></div>
<div class="line"><span class="lineno"> 4558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4559</span><span class="stringliteral">        [  x           n - x     ]</span></div>
<div class="line"><span class="lineno"> 4560</span><span class="stringliteral">        [N - x    M - (n + N) + x]</span></div>
<div class="line"><span class="lineno"> 4561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4562</span><span class="stringliteral">    For example, if::</span></div>
<div class="line"><span class="lineno"> 4563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4564</span><span class="stringliteral">        table = [6  2]</span></div>
<div class="line"><span class="lineno"> 4565</span><span class="stringliteral">                [1  4]</span></div>
<div class="line"><span class="lineno"> 4566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4567</span><span class="stringliteral">    then the support is ``2 &lt;= x &lt;= 7``, and the tables in the distribution</span></div>
<div class="line"><span class="lineno"> 4568</span><span class="stringliteral">    are::</span></div>
<div class="line"><span class="lineno"> 4569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4570</span><span class="stringliteral">        [2 6]   [3 5]   [4 4]   [5 3]   [6 2]  [7 1]</span></div>
<div class="line"><span class="lineno"> 4571</span><span class="stringliteral">        [5 0]   [4 1]   [3 2]   [2 3]   [1 4]  [0 5]</span></div>
<div class="line"><span class="lineno"> 4572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4573</span><span class="stringliteral">    The probability of each table is given by the hypergeometric distribution</span></div>
<div class="line"><span class="lineno"> 4574</span><span class="stringliteral">    ``hypergeom.pmf(x, M, n, N)``.  For this example, these are (rounded to</span></div>
<div class="line"><span class="lineno"> 4575</span><span class="stringliteral">    three significant digits)::</span></div>
<div class="line"><span class="lineno"> 4576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4577</span><span class="stringliteral">        x       2      3      4      5       6        7</span></div>
<div class="line"><span class="lineno"> 4578</span><span class="stringliteral">        p  0.0163  0.163  0.408  0.326  0.0816  0.00466</span></div>
<div class="line"><span class="lineno"> 4579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4580</span><span class="stringliteral">    These can be computed with::</span></div>
<div class="line"><span class="lineno"> 4581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4582</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.stats import hypergeom</span></div>
<div class="line"><span class="lineno"> 4583</span><span class="stringliteral">        &gt;&gt;&gt; table = np.array([[6, 2], [1, 4]])</span></div>
<div class="line"><span class="lineno"> 4584</span><span class="stringliteral">        &gt;&gt;&gt; M = table.sum()</span></div>
<div class="line"><span class="lineno"> 4585</span><span class="stringliteral">        &gt;&gt;&gt; n = table[0].sum()</span></div>
<div class="line"><span class="lineno"> 4586</span><span class="stringliteral">        &gt;&gt;&gt; N = table[:, 0].sum()</span></div>
<div class="line"><span class="lineno"> 4587</span><span class="stringliteral">        &gt;&gt;&gt; start, end = hypergeom.support(M, n, N)</span></div>
<div class="line"><span class="lineno"> 4588</span><span class="stringliteral">        &gt;&gt;&gt; hypergeom.pmf(np.arange(start, end+1), M, n, N)</span></div>
<div class="line"><span class="lineno"> 4589</span><span class="stringliteral">        array([0.01631702, 0.16317016, 0.40792541, 0.32634033, 0.08158508,</span></div>
<div class="line"><span class="lineno"> 4590</span><span class="stringliteral">               0.004662  ])</span></div>
<div class="line"><span class="lineno"> 4591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4592</span><span class="stringliteral">    The two-sided p-value is the probability that, under the null hypothesis,</span></div>
<div class="line"><span class="lineno"> 4593</span><span class="stringliteral">    a random table would have a probability equal to or less than the</span></div>
<div class="line"><span class="lineno"> 4594</span><span class="stringliteral">    probability of the input table.  For our example, the probability of</span></div>
<div class="line"><span class="lineno"> 4595</span><span class="stringliteral">    the input table (where ``x = 6``) is 0.0816.  The x values where the</span></div>
<div class="line"><span class="lineno"> 4596</span><span class="stringliteral">    probability does not exceed this are 2, 6 and 7, so the two-sided p-value</span></div>
<div class="line"><span class="lineno"> 4597</span><span class="stringliteral">    is ``0.0163 + 0.0816 + 0.00466 ~= 0.10256``::</span></div>
<div class="line"><span class="lineno"> 4598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4599</span><span class="stringliteral">        &gt;&gt;&gt; from scipy.stats import fisher_exact</span></div>
<div class="line"><span class="lineno"> 4600</span><span class="stringliteral">        &gt;&gt;&gt; oddsr, p = fisher_exact(table, alternative=&#39;two-sided&#39;)</span></div>
<div class="line"><span class="lineno"> 4601</span><span class="stringliteral">        &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 4602</span><span class="stringliteral">        0.10256410256410257</span></div>
<div class="line"><span class="lineno"> 4603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4604</span><span class="stringliteral">    The one-sided p-value for ``alternative=&#39;greater&#39;`` is the probability</span></div>
<div class="line"><span class="lineno"> 4605</span><span class="stringliteral">    that a random table has ``x &gt;= a``, which in our example is ``x &gt;= 6``,</span></div>
<div class="line"><span class="lineno"> 4606</span><span class="stringliteral">    or ``0.0816 + 0.00466 ~= 0.08626``::</span></div>
<div class="line"><span class="lineno"> 4607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4608</span><span class="stringliteral">        &gt;&gt;&gt; oddsr, p = fisher_exact(table, alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 4609</span><span class="stringliteral">        &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 4610</span><span class="stringliteral">        0.08624708624708627</span></div>
<div class="line"><span class="lineno"> 4611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4612</span><span class="stringliteral">    This is equivalent to computing the survival function of the</span></div>
<div class="line"><span class="lineno"> 4613</span><span class="stringliteral">    distribution at ``x = 5`` (one less than ``x`` from the input table,</span></div>
<div class="line"><span class="lineno"> 4614</span><span class="stringliteral">    because we want to include the probability of ``x = 6`` in the sum)::</span></div>
<div class="line"><span class="lineno"> 4615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4616</span><span class="stringliteral">        &gt;&gt;&gt; hypergeom.sf(5, M, n, N)</span></div>
<div class="line"><span class="lineno"> 4617</span><span class="stringliteral">        0.08624708624708627</span></div>
<div class="line"><span class="lineno"> 4618</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4619</span><span class="stringliteral">    For ``alternative=&#39;less&#39;``, the one-sided p-value is the probability</span></div>
<div class="line"><span class="lineno"> 4620</span><span class="stringliteral">    that a random table has ``x &lt;= a``, (i.e. ``x &lt;= 6`` in our example),</span></div>
<div class="line"><span class="lineno"> 4621</span><span class="stringliteral">    or ``0.0163 + 0.163 + 0.408 + 0.326 + 0.0816 ~= 0.9949``::</span></div>
<div class="line"><span class="lineno"> 4622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4623</span><span class="stringliteral">        &gt;&gt;&gt; oddsr, p = fisher_exact(table, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 4624</span><span class="stringliteral">        &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 4625</span><span class="stringliteral">        0.9953379953379957</span></div>
<div class="line"><span class="lineno"> 4626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4627</span><span class="stringliteral">    This is equivalent to computing the cumulative distribution function</span></div>
<div class="line"><span class="lineno"> 4628</span><span class="stringliteral">    of the distribution at ``x = 6``:</span></div>
<div class="line"><span class="lineno"> 4629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4630</span><span class="stringliteral">        &gt;&gt;&gt; hypergeom.cdf(6, M, n, N)</span></div>
<div class="line"><span class="lineno"> 4631</span><span class="stringliteral">        0.9953379953379957</span></div>
<div class="line"><span class="lineno"> 4632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4633</span><span class="stringliteral">    *Odds ratio*</span></div>
<div class="line"><span class="lineno"> 4634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4635</span><span class="stringliteral">    The calculated odds ratio is different from the one R uses. This SciPy</span></div>
<div class="line"><span class="lineno"> 4636</span><span class="stringliteral">    implementation returns the (more common) &quot;unconditional Maximum</span></div>
<div class="line"><span class="lineno"> 4637</span><span class="stringliteral">    Likelihood Estimate&quot;, while R uses the &quot;conditional Maximum Likelihood</span></div>
<div class="line"><span class="lineno"> 4638</span><span class="stringliteral">    Estimate&quot;.</span></div>
<div class="line"><span class="lineno"> 4639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4640</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4641</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4642</span><span class="stringliteral">    Say we spend a few days counting whales and sharks in the Atlantic and</span></div>
<div class="line"><span class="lineno"> 4643</span><span class="stringliteral">    Indian oceans. In the Atlantic ocean we find 8 whales and 1 shark, in the</span></div>
<div class="line"><span class="lineno"> 4644</span><span class="stringliteral">    Indian ocean 2 whales and 5 sharks. Then our contingency table is::</span></div>
<div class="line"><span class="lineno"> 4645</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4646</span><span class="stringliteral">                Atlantic  Indian</span></div>
<div class="line"><span class="lineno"> 4647</span><span class="stringliteral">        whales     8        2</span></div>
<div class="line"><span class="lineno"> 4648</span><span class="stringliteral">        sharks     1        5</span></div>
<div class="line"><span class="lineno"> 4649</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4650</span><span class="stringliteral">    We use this table to find the p-value:</span></div>
<div class="line"><span class="lineno"> 4651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4652</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import fisher_exact</span></div>
<div class="line"><span class="lineno"> 4653</span><span class="stringliteral">    &gt;&gt;&gt; oddsratio, pvalue = fisher_exact([[8, 2], [1, 5]])</span></div>
<div class="line"><span class="lineno"> 4654</span><span class="stringliteral">    &gt;&gt;&gt; pvalue</span></div>
<div class="line"><span class="lineno"> 4655</span><span class="stringliteral">    0.0349...</span></div>
<div class="line"><span class="lineno"> 4656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4657</span><span class="stringliteral">    The probability that we would observe this or an even more imbalanced ratio</span></div>
<div class="line"><span class="lineno"> 4658</span><span class="stringliteral">    by chance is about 3.5%.  A commonly used significance level is 5%--if we</span></div>
<div class="line"><span class="lineno"> 4659</span><span class="stringliteral">    adopt that, we can therefore conclude that our observed imbalance is</span></div>
<div class="line"><span class="lineno"> 4660</span><span class="stringliteral">    statistically significant; whales prefer the Atlantic while sharks prefer</span></div>
<div class="line"><span class="lineno"> 4661</span><span class="stringliteral">    the Indian ocean.</span></div>
<div class="line"><span class="lineno"> 4662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4663</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4664</span>    hypergeom = distributions.hypergeom</div>
<div class="line"><span class="lineno"> 4665</span>    <span class="comment"># int32 is not enough for the algorithm</span></div>
<div class="line"><span class="lineno"> 4666</span>    c = np.asarray(table, dtype=np.int64)</div>
<div class="line"><span class="lineno"> 4667</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> c.shape == (2, 2):</div>
<div class="line"><span class="lineno"> 4668</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The input `table` must be of shape (2, 2).&quot;</span>)</div>
<div class="line"><span class="lineno"> 4669</span> </div>
<div class="line"><span class="lineno"> 4670</span>    <span class="keywordflow">if</span> np.any(c &lt; 0):</div>
<div class="line"><span class="lineno"> 4671</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All values in `table` must be nonnegative.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4672</span> </div>
<div class="line"><span class="lineno"> 4673</span>    <span class="keywordflow">if</span> 0 <span class="keywordflow">in</span> c.sum(axis=0) <span class="keywordflow">or</span> 0 <span class="keywordflow">in</span> c.sum(axis=1):</div>
<div class="line"><span class="lineno"> 4674</span>        <span class="comment"># If both values in a row or column are zero, the p-value is 1 and</span></div>
<div class="line"><span class="lineno"> 4675</span>        <span class="comment"># the odds ratio is NaN.</span></div>
<div class="line"><span class="lineno"> 4676</span>        <span class="keywordflow">return</span> np.nan, 1.0</div>
<div class="line"><span class="lineno"> 4677</span> </div>
<div class="line"><span class="lineno"> 4678</span>    <span class="keywordflow">if</span> c[1, 0] &gt; 0 <span class="keywordflow">and</span> c[0, 1] &gt; 0:</div>
<div class="line"><span class="lineno"> 4679</span>        oddsratio = c[0, 0] * c[1, 1] / (c[1, 0] * c[0, 1])</div>
<div class="line"><span class="lineno"> 4680</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4681</span>        oddsratio = np.inf</div>
<div class="line"><span class="lineno"> 4682</span> </div>
<div class="line"><span class="lineno"> 4683</span>    n1 = c[0, 0] + c[0, 1]</div>
<div class="line"><span class="lineno"> 4684</span>    n2 = c[1, 0] + c[1, 1]</div>
<div class="line"><span class="lineno"> 4685</span>    n = c[0, 0] + c[1, 0]</div>
<div class="line"><span class="lineno"> 4686</span> </div>
<div class="line"><span class="lineno"> 4687</span>    <span class="keyword">def </span>pmf(x):</div>
<div class="line"><span class="lineno"> 4688</span>        <span class="keywordflow">return</span> hypergeom.pmf(x, n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4689</span> </div>
<div class="line"><span class="lineno"> 4690</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;less&#39;</span>:</div>
<div class="line"><span class="lineno"> 4691</span>        pvalue = hypergeom.cdf(c[0, 0], n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4692</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;greater&#39;</span>:</div>
<div class="line"><span class="lineno"> 4693</span>        <span class="comment"># Same formula as the &#39;less&#39; case, but with the second column.</span></div>
<div class="line"><span class="lineno"> 4694</span>        pvalue = hypergeom.cdf(c[0, 1], n1 + n2, n1, c[0, 1] + c[1, 1])</div>
<div class="line"><span class="lineno"> 4695</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;two-sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 4696</span>        mode = int((n + 1) * (n1 + 1) / (n1 + n2 + 2))</div>
<div class="line"><span class="lineno"> 4697</span>        pexact = hypergeom.pmf(c[0, 0], n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4698</span>        pmode = hypergeom.pmf(mode, n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4699</span> </div>
<div class="line"><span class="lineno"> 4700</span>        epsilon = 1e-14</div>
<div class="line"><span class="lineno"> 4701</span>        gamma = 1 + epsilon</div>
<div class="line"><span class="lineno"> 4702</span> </div>
<div class="line"><span class="lineno"> 4703</span>        <span class="keywordflow">if</span> np.abs(pexact - pmode) / np.maximum(pexact, pmode) &lt;= epsilon:</div>
<div class="line"><span class="lineno"> 4704</span>            <span class="keywordflow">return</span> oddsratio, 1.</div>
<div class="line"><span class="lineno"> 4705</span> </div>
<div class="line"><span class="lineno"> 4706</span>        <span class="keywordflow">elif</span> c[0, 0] &lt; mode:</div>
<div class="line"><span class="lineno"> 4707</span>            plower = hypergeom.cdf(c[0, 0], n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4708</span>            <span class="keywordflow">if</span> hypergeom.pmf(n, n1 + n2, n1, n) &gt; pexact * gamma:</div>
<div class="line"><span class="lineno"> 4709</span>                <span class="keywordflow">return</span> oddsratio, plower</div>
<div class="line"><span class="lineno"> 4710</span> </div>
<div class="line"><span class="lineno"> 4711</span>            guess = _binary_search(<span class="keyword">lambda</span> x: -pmf(x), -pexact * gamma, mode, n)</div>
<div class="line"><span class="lineno"> 4712</span>            pvalue = plower + hypergeom.sf(guess, n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4713</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4714</span>            pupper = hypergeom.sf(c[0, 0] - 1, n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4715</span>            <span class="keywordflow">if</span> hypergeom.pmf(0, n1 + n2, n1, n) &gt; pexact * gamma:</div>
<div class="line"><span class="lineno"> 4716</span>                <span class="keywordflow">return</span> oddsratio, pupper</div>
<div class="line"><span class="lineno"> 4717</span> </div>
<div class="line"><span class="lineno"> 4718</span>            guess = _binary_search(pmf, pexact * gamma, 0, mode)</div>
<div class="line"><span class="lineno"> 4719</span>            pvalue = pupper + hypergeom.cdf(guess, n1 + n2, n1, n)</div>
<div class="line"><span class="lineno"> 4720</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4721</span>        msg = <span class="stringliteral">&quot;`alternative` should be one of {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}&quot;</span></div>
<div class="line"><span class="lineno"> 4722</span>        <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 4723</span> </div>
<div class="line"><span class="lineno"> 4724</span>    pvalue = min(pvalue, 1.0)</div>
<div class="line"><span class="lineno"> 4725</span> </div>
<div class="line"><span class="lineno"> 4726</span>    <span class="keywordflow">return</span> oddsratio, pvalue</div>
<div class="line"><span class="lineno"> 4727</span> </div>
<div class="line"><span class="lineno"> 4728</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa458038daef3b9b7c308d681b36f93ba" name="aa458038daef3b9b7c308d681b36f93ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa458038daef3b9b7c308d681b36f93ba">&#9670;&#160;</a></span>friedmanchisquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.friedmanchisquare </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Friedman test for repeated samples.

The Friedman test tests the null hypothesis that repeated samples of
the same individuals have the same distribution.  It is often used
to test for consistency among samples obtained in different ways.
For example, if two sampling techniques are used on the same set of
individuals, the Friedman test can be used to determine if the two
sampling techniques are consistent.

Parameters
----------
sample1, sample2, sample3... : array_like
    Arrays of observations.  All of the arrays must have the same number
    of elements.  At least three samples must be given.

Returns
-------
statistic : float
    The test statistic, correcting for ties.
pvalue : float
    The associated p-value assuming that the test statistic has a chi
    squared distribution.

Notes
-----
Due to the assumption that the test statistic has a chi squared
distribution, the p-value is only reliable for n &gt; 10 and more than
6 repeated samples.

References
----------
.. [1] https://en.wikipedia.org/wiki/Friedman_test</pre> <div class="fragment"><div class="line"><span class="lineno"> 8312</span><span class="keyword">def </span>friedmanchisquare(*samples):</div>
<div class="line"><span class="lineno"> 8313</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the Friedman test for repeated samples.</span></div>
<div class="line"><span class="lineno"> 8314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8315</span><span class="stringliteral">    The Friedman test tests the null hypothesis that repeated samples of</span></div>
<div class="line"><span class="lineno"> 8316</span><span class="stringliteral">    the same individuals have the same distribution.  It is often used</span></div>
<div class="line"><span class="lineno"> 8317</span><span class="stringliteral">    to test for consistency among samples obtained in different ways.</span></div>
<div class="line"><span class="lineno"> 8318</span><span class="stringliteral">    For example, if two sampling techniques are used on the same set of</span></div>
<div class="line"><span class="lineno"> 8319</span><span class="stringliteral">    individuals, the Friedman test can be used to determine if the two</span></div>
<div class="line"><span class="lineno"> 8320</span><span class="stringliteral">    sampling techniques are consistent.</span></div>
<div class="line"><span class="lineno"> 8321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8322</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8323</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8324</span><span class="stringliteral">    sample1, sample2, sample3... : array_like</span></div>
<div class="line"><span class="lineno"> 8325</span><span class="stringliteral">        Arrays of observations.  All of the arrays must have the same number</span></div>
<div class="line"><span class="lineno"> 8326</span><span class="stringliteral">        of elements.  At least three samples must be given.</span></div>
<div class="line"><span class="lineno"> 8327</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8328</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8329</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8330</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 8331</span><span class="stringliteral">        The test statistic, correcting for ties.</span></div>
<div class="line"><span class="lineno"> 8332</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 8333</span><span class="stringliteral">        The associated p-value assuming that the test statistic has a chi</span></div>
<div class="line"><span class="lineno"> 8334</span><span class="stringliteral">        squared distribution.</span></div>
<div class="line"><span class="lineno"> 8335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8336</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8337</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8338</span><span class="stringliteral">    Due to the assumption that the test statistic has a chi squared</span></div>
<div class="line"><span class="lineno"> 8339</span><span class="stringliteral">    distribution, the p-value is only reliable for n &gt; 10 and more than</span></div>
<div class="line"><span class="lineno"> 8340</span><span class="stringliteral">    6 repeated samples.</span></div>
<div class="line"><span class="lineno"> 8341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8342</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8343</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8344</span><span class="stringliteral">    .. [1] https://en.wikipedia.org/wiki/Friedman_test</span></div>
<div class="line"><span class="lineno"> 8345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8346</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8347</span>    k = len(samples)</div>
<div class="line"><span class="lineno"> 8348</span>    <span class="keywordflow">if</span> k &lt; 3:</div>
<div class="line"><span class="lineno"> 8349</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;At least 3 sets of samples must be given &#39;</span></div>
<div class="line"><span class="lineno"> 8350</span>                         <span class="stringliteral">&#39;for Friedman test, got {}.&#39;</span>.format(k))</div>
<div class="line"><span class="lineno"> 8351</span> </div>
<div class="line"><span class="lineno"> 8352</span>    n = len(samples[0])</div>
<div class="line"><span class="lineno"> 8353</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, k):</div>
<div class="line"><span class="lineno"> 8354</span>        <span class="keywordflow">if</span> len(samples[i]) != n:</div>
<div class="line"><span class="lineno"> 8355</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Unequal N in friedmanchisquare.  Aborting.&#39;</span>)</div>
<div class="line"><span class="lineno"> 8356</span> </div>
<div class="line"><span class="lineno"> 8357</span>    <span class="comment"># Rank data</span></div>
<div class="line"><span class="lineno"> 8358</span>    data = np.vstack(samples).T</div>
<div class="line"><span class="lineno"> 8359</span>    data = data.astype(float)</div>
<div class="line"><span class="lineno"> 8360</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(data)):</div>
<div class="line"><span class="lineno"> 8361</span>        data[i] = rankdata(data[i])</div>
<div class="line"><span class="lineno"> 8362</span> </div>
<div class="line"><span class="lineno"> 8363</span>    <span class="comment"># Handle ties</span></div>
<div class="line"><span class="lineno"> 8364</span>    ties = 0</div>
<div class="line"><span class="lineno"> 8365</span>    <span class="keywordflow">for</span> d <span class="keywordflow">in</span> data:</div>
<div class="line"><span class="lineno"> 8366</span>        replist, repnum = find_repeats(array(d))</div>
<div class="line"><span class="lineno"> 8367</span>        <span class="keywordflow">for</span> t <span class="keywordflow">in</span> repnum:</div>
<div class="line"><span class="lineno"> 8368</span>            ties += t * (t*t - 1)</div>
<div class="line"><span class="lineno"> 8369</span>    c = 1 - ties / (k*(k*k - 1)*n)</div>
<div class="line"><span class="lineno"> 8370</span> </div>
<div class="line"><span class="lineno"> 8371</span>    ssbn = np.sum(data.sum(axis=0)**2)</div>
<div class="line"><span class="lineno"> 8372</span>    chisq = (12.0 / (k*n*(k+1)) * ssbn - 3*n*(k+1)) / c</div>
<div class="line"><span class="lineno"> 8373</span> </div>
<div class="line"><span class="lineno"> 8374</span>    <span class="keywordflow">return</span> FriedmanchisquareResult(chisq, distributions.chi2.sf(chisq, k - 1))</div>
<div class="line"><span class="lineno"> 8375</span> </div>
<div class="line"><span class="lineno"> 8376</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb5f31167da564053a0666386c4e28b3" name="aeb5f31167da564053a0666386c4e28b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5f31167da564053a0666386c4e28b3">&#9670;&#160;</a></span>gmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.gmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the weighted geometric mean along the specified axis.

The weighted geometric mean of the array :math:`a_i` associated to weights
:math:`w_i` is:

.. math::

\exp \left( \frac{ \sum_{i=1}^n w_i \ln a_i }{ \sum_{i=1}^n w_i }
\right) \, ,

and, with equal weights, it gives:

.. math::

\sqrt[n]{ \prod_{i=1}^n a_i } \, .

Parameters
----------
a : array_like
Input array or object that can be converted to an array.
axis : int or None, optional
Axis along which the geometric mean is computed. Default is 0.
If None, compute over the whole array `a`.
dtype : dtype, optional
Type of the returned array and of the accumulator in which the
elements are summed. If dtype is not specified, it defaults to the
dtype of a, unless a has an integer dtype with a precision less than
that of the default platform integer. In that case, the default
platform integer is used.
weights : array_like, optional
The `weights` array must be broadcastable to the same shape as `a`.
Default is None, which gives each value a weight of 1.0.

Returns
-------
gmean : ndarray
See `dtype` parameter above.

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
hmean : Harmonic mean

Notes
-----
The geometric average is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

References
----------
.. [1] "Weighted Geometric Mean", *Wikipedia*,
https://en.wikipedia.org/wiki/Weighted_geometric_mean.

Examples
--------
&gt;&gt;&gt; from scipy.stats import gmean
&gt;&gt;&gt; gmean([1, 4])
2.0
&gt;&gt;&gt; gmean([1, 2, 3, 4, 5, 6, 7])
3.3800151591412964
&gt;&gt;&gt; gmean([1, 4, 7], weights=[3, 1, 3])
2.80668351922014</pre> <div class="fragment"><div class="line"><span class="lineno">  232</span><span class="keyword">def </span>gmean(a, axis=0, dtype=None, weights=None):</div>
<div class="line"><span class="lineno">  233</span>    <span class="stringliteral">r&quot;&quot;&quot;Compute the weighted geometric mean along the specified axis.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    The weighted geometric mean of the array :math:`a_i` associated to weights</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    :math:`w_i` is:</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">        \exp \left( \frac{ \sum_{i=1}^n w_i \ln a_i }{ \sum_{i=1}^n w_i }</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">                   \right) \, ,</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    and, with equal weights, it gives:</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        \sqrt[n]{ \prod_{i=1}^n a_i } \, .</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">        Axis along which the geometric mean is computed. Default is 0.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">        If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">        Type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">        elements are summed. If dtype is not specified, it defaults to the</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        dtype of a, unless a has an integer dtype with a precision less than</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        that of the default platform integer. In that case, the default</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        platform integer is used.</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">        The `weights` array must be broadcastable to the same shape as `a`.</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">        Default is None, which gives each value a weight of 1.0.</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    gmean : ndarray</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">        See `dtype` parameter above.</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    numpy.mean : Arithmetic average</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    numpy.average : Weighted average</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    hmean : Harmonic mean</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    The geometric average is computed over a single dimension of the input</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    array, axis=0 by default, or all values in the array if axis=None.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    float64 intermediate and return values are used for integer inputs.</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    .. [1] &quot;Weighted Geometric Mean&quot;, *Wikipedia*,</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Weighted_geometric_mean.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import gmean</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    &gt;&gt;&gt; gmean([1, 4])</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    &gt;&gt;&gt; gmean([1, 2, 3, 4, 5, 6, 7])</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">    3.3800151591412964</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    &gt;&gt;&gt; gmean([1, 4, 7], weights=[3, 1, 3])</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    2.80668351922014</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(a, np.ndarray):</div>
<div class="line"><span class="lineno">  300</span>        <span class="comment"># if not an ndarray object attempt to convert it</span></div>
<div class="line"><span class="lineno">  301</span>        a = np.array(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  302</span>    <span class="keywordflow">elif</span> dtype:</div>
<div class="line"><span class="lineno">  303</span>        <span class="comment"># Must change the default dtype allowing array type</span></div>
<div class="line"><span class="lineno">  304</span>        <span class="keywordflow">if</span> isinstance(a, np.ma.MaskedArray):</div>
<div class="line"><span class="lineno">  305</span>            a = np.ma.asarray(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  306</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  307</span>            a = np.asarray(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span>    <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno">  310</span>        log_a = np.log(a)</div>
<div class="line"><span class="lineno">  311</span> </div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  313</span>        weights = np.asanyarray(weights, dtype=dtype)</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>    <span class="keywordflow">return</span> np.exp(np.average(log_a, axis=axis, weights=weights))</div>
<div class="line"><span class="lineno">  316</span> </div>
<div class="line"><span class="lineno">  317</span> </div>
<div class="line"><span class="lineno">  318</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno">  319</span>        <span class="keyword">lambda</span> x: x, n_samples=1, n_outputs=1, too_small=0, paired=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  320</span>        result_to_tuple=<span class="keyword">lambda</span> x: (x,), kwd_samples=[<span class="stringliteral">&#39;weights&#39;</span>])</div>
</div><!-- fragment -->
</div>
</div>
<a id="a720304ac94e199a283c3cde4e66448f1" name="a720304ac94e199a283c3cde4e66448f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720304ac94e199a283c3cde4e66448f1">&#9670;&#160;</a></span>gstd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.gstd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the geometric standard deviation of an array.

The geometric standard deviation describes the spread of a set of numbers
where the geometric mean is preferred. It is a multiplicative factor, and
so a dimensionless quantity.

It is defined as the exponent of the standard deviation of ``log(a)``.
Mathematically the population geometric standard deviation can be
evaluated as::

    gstd = exp(std(log(a)))

.. versionadded:: 1.3.0

Parameters
----------
a : array_like
    An array like object containing the sample data.
axis : int, tuple or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degree of freedom correction in the calculation of the
    geometric standard deviation. Default is 1.

Returns
-------
ndarray or float
    An array of the geometric standard deviation. If `axis` is None or `a`
    is a 1d array a float is returned.

See Also
--------
gmean : Geometric mean
numpy.std : Standard deviation

Notes
-----
As the calculation requires the use of logarithms the geometric standard
deviation only supports strictly positive values. Any non-positive or
infinite values will raise a `ValueError`.
The geometric standard deviation is sometimes confused with the exponent of
the standard deviation, ``exp(std(a))``. Instead the geometric standard
deviation is ``exp(std(log(a)))``.
The default value for `ddof` is different to the default value (0) used
by other ddof containing functions, such as ``np.std`` and ``np.nanstd``.

References
----------
.. [1] Kirkwood, T. B., "Geometric means and measures of dispersion",
       Biometrics, vol. 35, pp. 908-909, 1979

Examples
--------
Find the geometric standard deviation of a log-normally distributed sample.
Note that the standard deviation of the distribution is one, on a
log scale this evaluates to approximately ``exp(1)``.

&gt;&gt;&gt; from scipy.stats import gstd
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; sample = rng.lognormal(mean=0, sigma=1, size=1000)
&gt;&gt;&gt; gstd(sample)
2.810010162475324

Compute the geometric standard deviation of a multidimensional array and
of a given axis.

&gt;&gt;&gt; a = np.arange(1, 25).reshape(2, 3, 4)
&gt;&gt;&gt; gstd(a, axis=None)
2.2944076136018947
&gt;&gt;&gt; gstd(a, axis=2)
array([[1.82424757, 1.22436866, 1.13183117],
       [1.09348306, 1.07244798, 1.05914985]])
&gt;&gt;&gt; gstd(a, axis=(1,2))
array([2.12939215, 1.22120169])

The geometric standard deviation further handles masked arrays.

&gt;&gt;&gt; a = np.arange(1, 25).reshape(2, 3, 4)
&gt;&gt;&gt; ma = np.ma.masked_where(a &gt; 16, a)
&gt;&gt;&gt; ma
masked_array(
  data=[[[1, 2, 3, 4],
         [5, 6, 7, 8],
         [9, 10, 11, 12]],
        [[13, 14, 15, 16],
         [--, --, --, --],
         [--, --, --, --]]],
  mask=[[[False, False, False, False],
         [False, False, False, False],
         [False, False, False, False]],
        [[False, False, False, False],
         [ True,  True,  True,  True],
         [ True,  True,  True,  True]]],
  fill_value=999999)
&gt;&gt;&gt; gstd(ma, axis=2)
masked_array(
  data=[[1.8242475707663655, 1.2243686572447428, 1.1318311657788478],
        [1.0934830582350938, --, --]],
  mask=[[False, False, False],
        [False,  True,  True]],
  fill_value=999999)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2906</span><span class="keyword">def </span>gstd(a, axis=0, ddof=1):</div>
<div class="line"><span class="lineno"> 2907</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral">    Calculate the geometric standard deviation of an array.</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral">    The geometric standard deviation describes the spread of a set of numbers</span></div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral">    where the geometric mean is preferred. It is a multiplicative factor, and</span></div>
<div class="line"><span class="lineno"> 2912</span><span class="stringliteral">    so a dimensionless quantity.</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral">    It is defined as the exponent of the standard deviation of ``log(a)``.</span></div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">    Mathematically the population geometric standard deviation can be</span></div>
<div class="line"><span class="lineno"> 2916</span><span class="stringliteral">    evaluated as::</span></div>
<div class="line"><span class="lineno"> 2917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2918</span><span class="stringliteral">        gstd = exp(std(log(a)))</span></div>
<div class="line"><span class="lineno"> 2919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2920</span><span class="stringliteral">    .. versionadded:: 1.3.0</span></div>
<div class="line"><span class="lineno"> 2921</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2922</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2923</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2924</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2925</span><span class="stringliteral">        An array like object containing the sample data.</span></div>
<div class="line"><span class="lineno"> 2926</span><span class="stringliteral">    axis : int, tuple or None, optional</span></div>
<div class="line"><span class="lineno"> 2927</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 2928</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 2929</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 2930</span><span class="stringliteral">        Degree of freedom correction in the calculation of the</span></div>
<div class="line"><span class="lineno"> 2931</span><span class="stringliteral">        geometric standard deviation. Default is 1.</span></div>
<div class="line"><span class="lineno"> 2932</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2933</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2934</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2935</span><span class="stringliteral">    ndarray or float</span></div>
<div class="line"><span class="lineno"> 2936</span><span class="stringliteral">        An array of the geometric standard deviation. If `axis` is None or `a`</span></div>
<div class="line"><span class="lineno"> 2937</span><span class="stringliteral">        is a 1d array a float is returned.</span></div>
<div class="line"><span class="lineno"> 2938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2939</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2940</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2941</span><span class="stringliteral">    gmean : Geometric mean</span></div>
<div class="line"><span class="lineno"> 2942</span><span class="stringliteral">    numpy.std : Standard deviation</span></div>
<div class="line"><span class="lineno"> 2943</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2944</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2945</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2946</span><span class="stringliteral">    As the calculation requires the use of logarithms the geometric standard</span></div>
<div class="line"><span class="lineno"> 2947</span><span class="stringliteral">    deviation only supports strictly positive values. Any non-positive or</span></div>
<div class="line"><span class="lineno"> 2948</span><span class="stringliteral">    infinite values will raise a `ValueError`.</span></div>
<div class="line"><span class="lineno"> 2949</span><span class="stringliteral">    The geometric standard deviation is sometimes confused with the exponent of</span></div>
<div class="line"><span class="lineno"> 2950</span><span class="stringliteral">    the standard deviation, ``exp(std(a))``. Instead the geometric standard</span></div>
<div class="line"><span class="lineno"> 2951</span><span class="stringliteral">    deviation is ``exp(std(log(a)))``.</span></div>
<div class="line"><span class="lineno"> 2952</span><span class="stringliteral">    The default value for `ddof` is different to the default value (0) used</span></div>
<div class="line"><span class="lineno"> 2953</span><span class="stringliteral">    by other ddof containing functions, such as ``np.std`` and ``np.nanstd``.</span></div>
<div class="line"><span class="lineno"> 2954</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2955</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2956</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2957</span><span class="stringliteral">    .. [1] Kirkwood, T. B., &quot;Geometric means and measures of dispersion&quot;,</span></div>
<div class="line"><span class="lineno"> 2958</span><span class="stringliteral">           Biometrics, vol. 35, pp. 908-909, 1979</span></div>
<div class="line"><span class="lineno"> 2959</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2960</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2961</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2962</span><span class="stringliteral">    Find the geometric standard deviation of a log-normally distributed sample.</span></div>
<div class="line"><span class="lineno"> 2963</span><span class="stringliteral">    Note that the standard deviation of the distribution is one, on a</span></div>
<div class="line"><span class="lineno"> 2964</span><span class="stringliteral">    log scale this evaluates to approximately ``exp(1)``.</span></div>
<div class="line"><span class="lineno"> 2965</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2966</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import gstd</span></div>
<div class="line"><span class="lineno"> 2967</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 2968</span><span class="stringliteral">    &gt;&gt;&gt; sample = rng.lognormal(mean=0, sigma=1, size=1000)</span></div>
<div class="line"><span class="lineno"> 2969</span><span class="stringliteral">    &gt;&gt;&gt; gstd(sample)</span></div>
<div class="line"><span class="lineno"> 2970</span><span class="stringliteral">    2.810010162475324</span></div>
<div class="line"><span class="lineno"> 2971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2972</span><span class="stringliteral">    Compute the geometric standard deviation of a multidimensional array and</span></div>
<div class="line"><span class="lineno"> 2973</span><span class="stringliteral">    of a given axis.</span></div>
<div class="line"><span class="lineno"> 2974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2975</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(1, 25).reshape(2, 3, 4)</span></div>
<div class="line"><span class="lineno"> 2976</span><span class="stringliteral">    &gt;&gt;&gt; gstd(a, axis=None)</span></div>
<div class="line"><span class="lineno"> 2977</span><span class="stringliteral">    2.2944076136018947</span></div>
<div class="line"><span class="lineno"> 2978</span><span class="stringliteral">    &gt;&gt;&gt; gstd(a, axis=2)</span></div>
<div class="line"><span class="lineno"> 2979</span><span class="stringliteral">    array([[1.82424757, 1.22436866, 1.13183117],</span></div>
<div class="line"><span class="lineno"> 2980</span><span class="stringliteral">           [1.09348306, 1.07244798, 1.05914985]])</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral">    &gt;&gt;&gt; gstd(a, axis=(1,2))</span></div>
<div class="line"><span class="lineno"> 2982</span><span class="stringliteral">    array([2.12939215, 1.22120169])</span></div>
<div class="line"><span class="lineno"> 2983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2984</span><span class="stringliteral">    The geometric standard deviation further handles masked arrays.</span></div>
<div class="line"><span class="lineno"> 2985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(1, 25).reshape(2, 3, 4)</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral">    &gt;&gt;&gt; ma = np.ma.masked_where(a &gt; 16, a)</span></div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral">    &gt;&gt;&gt; ma</span></div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral">    masked_array(</span></div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral">      data=[[[1, 2, 3, 4],</span></div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral">             [5, 6, 7, 8],</span></div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">             [9, 10, 11, 12]],</span></div>
<div class="line"><span class="lineno"> 2993</span><span class="stringliteral">            [[13, 14, 15, 16],</span></div>
<div class="line"><span class="lineno"> 2994</span><span class="stringliteral">             [--, --, --, --],</span></div>
<div class="line"><span class="lineno"> 2995</span><span class="stringliteral">             [--, --, --, --]]],</span></div>
<div class="line"><span class="lineno"> 2996</span><span class="stringliteral">      mask=[[[False, False, False, False],</span></div>
<div class="line"><span class="lineno"> 2997</span><span class="stringliteral">             [False, False, False, False],</span></div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral">             [False, False, False, False]],</span></div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral">            [[False, False, False, False],</span></div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral">             [ True,  True,  True,  True],</span></div>
<div class="line"><span class="lineno"> 3001</span><span class="stringliteral">             [ True,  True,  True,  True]]],</span></div>
<div class="line"><span class="lineno"> 3002</span><span class="stringliteral">      fill_value=999999)</span></div>
<div class="line"><span class="lineno"> 3003</span><span class="stringliteral">    &gt;&gt;&gt; gstd(ma, axis=2)</span></div>
<div class="line"><span class="lineno"> 3004</span><span class="stringliteral">    masked_array(</span></div>
<div class="line"><span class="lineno"> 3005</span><span class="stringliteral">      data=[[1.8242475707663655, 1.2243686572447428, 1.1318311657788478],</span></div>
<div class="line"><span class="lineno"> 3006</span><span class="stringliteral">            [1.0934830582350938, --, --]],</span></div>
<div class="line"><span class="lineno"> 3007</span><span class="stringliteral">      mask=[[False, False, False],</span></div>
<div class="line"><span class="lineno"> 3008</span><span class="stringliteral">            [False,  True,  True]],</span></div>
<div class="line"><span class="lineno"> 3009</span><span class="stringliteral">      fill_value=999999)</span></div>
<div class="line"><span class="lineno"> 3010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3011</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3012</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 3013</span>    log = ma.log <span class="keywordflow">if</span> isinstance(a, ma.MaskedArray) <span class="keywordflow">else</span> np.log</div>
<div class="line"><span class="lineno"> 3014</span> </div>
<div class="line"><span class="lineno"> 3015</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3016</span>        <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno"> 3017</span>            warnings.simplefilter(<span class="stringliteral">&quot;error&quot;</span>, RuntimeWarning)</div>
<div class="line"><span class="lineno"> 3018</span>            <span class="keywordflow">return</span> np.exp(np.std(log(a), axis=axis, ddof=ddof))</div>
<div class="line"><span class="lineno"> 3019</span>    <span class="keywordflow">except</span> RuntimeWarning <span class="keyword">as</span> w:</div>
<div class="line"><span class="lineno"> 3020</span>        <span class="keywordflow">if</span> np.isinf(a).any():</div>
<div class="line"><span class="lineno"> 3021</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3022</span>                <span class="stringliteral">&#39;Infinite value encountered. The geometric standard deviation &#39;</span></div>
<div class="line"><span class="lineno"> 3023</span>                <span class="stringliteral">&#39;is defined for strictly positive values only.&#39;</span></div>
<div class="line"><span class="lineno"> 3024</span>            ) <span class="keyword">from</span> w</div>
<div class="line"><span class="lineno"> 3025</span>        a_nan = np.isnan(a)</div>
<div class="line"><span class="lineno"> 3026</span>        a_nan_any = a_nan.any()</div>
<div class="line"><span class="lineno"> 3027</span>        <span class="comment"># exclude NaN&#39;s from negativity check, but</span></div>
<div class="line"><span class="lineno"> 3028</span>        <span class="comment"># avoid expensive masking for arrays with no NaN</span></div>
<div class="line"><span class="lineno"> 3029</span>        <span class="keywordflow">if</span> ((a_nan_any <span class="keywordflow">and</span> np.less_equal(np.nanmin(a), 0)) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 3030</span>                (<span class="keywordflow">not</span> a_nan_any <span class="keywordflow">and</span> np.less_equal(a, 0).any())):</div>
<div class="line"><span class="lineno"> 3031</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3032</span>                <span class="stringliteral">&#39;Non positive value encountered. The geometric standard &#39;</span></div>
<div class="line"><span class="lineno"> 3033</span>                <span class="stringliteral">&#39;deviation is defined for strictly positive values only.&#39;</span></div>
<div class="line"><span class="lineno"> 3034</span>            ) <span class="keyword">from</span> w</div>
<div class="line"><span class="lineno"> 3035</span>        <span class="keywordflow">elif</span> <span class="stringliteral">&#39;Degrees of freedom &lt;= 0 for slice&#39;</span> == str(w):</div>
<div class="line"><span class="lineno"> 3036</span>            <span class="keywordflow">raise</span> ValueError(w) <span class="keyword">from</span> w</div>
<div class="line"><span class="lineno"> 3037</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3038</span>            <span class="comment">#  Remaining warnings don&#39;t need to be exceptions.</span></div>
<div class="line"><span class="lineno"> 3039</span>            <span class="keywordflow">return</span> np.exp(np.std(log(a, where=~a_nan), axis=axis, ddof=ddof))</div>
<div class="line"><span class="lineno"> 3040</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 3041</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3042</span>            <span class="stringliteral">&#39;Invalid array input. The inputs could not be &#39;</span></div>
<div class="line"><span class="lineno"> 3043</span>            <span class="stringliteral">&#39;safely coerced to any supported types&#39;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 3044</span> </div>
<div class="line"><span class="lineno"> 3045</span> </div>
<div class="line"><span class="lineno"> 3046</span><span class="comment"># Private dictionary initialized only once at module level</span></div>
<div class="line"><span class="lineno"> 3047</span><span class="comment"># See https://en.wikipedia.org/wiki/Robust_measures_of_scale</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a45cebfa557b24c866da2a534b13b20d0" name="a45cebfa557b24c866da2a534b13b20d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cebfa557b24c866da2a534b13b20d0">&#9670;&#160;</a></span>gzscore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.gzscore </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the geometric standard score.

Compute the geometric z score of each strictly positive value in the
sample, relative to the geometric mean and standard deviation.
Mathematically the geometric z score can be evaluated as::

    gzscore = log(a/gmu) / log(gsigma)

where ``gmu`` (resp. ``gsigma``) is the geometric mean (resp. standard
deviation).

Parameters
----------
a : array_like
    Sample data.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.  Note that when the value is 'omit',
    nans in the input also propagate to the output, but they do not affect
    the geometric z scores computed for the non-nan values.

Returns
-------
gzscore : array_like
    The geometric z scores, standardized by geometric mean and geometric
    standard deviation of input array `a`.

See Also
--------
gmean : Geometric mean
gstd : Geometric standard deviation
zscore : Standard score

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses ``asanyarray`` instead of
``asarray`` for parameters).

.. versionadded:: 1.8

Examples
--------
Draw samples from a log-normal distribution:

&gt;&gt;&gt; from scipy.stats import zscore, gzscore
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; mu, sigma = 3., 1.  # mean and standard deviation
&gt;&gt;&gt; x = rng.lognormal(mu, sigma, size=500)

Display the histogram of the samples:

&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; ax.hist(x, 50)
&gt;&gt;&gt; plt.show()

Display the histogram of the samples standardized by the classical zscore.
Distribution is rescaled but its shape is unchanged.

&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; ax.hist(zscore(x), 50)
&gt;&gt;&gt; plt.show()

Demonstrate that the distribution of geometric zscores is rescaled and
quasinormal:

&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; ax.hist(gzscore(x), 50)
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2736</span><span class="keyword">def </span>gzscore(a, *, axis=0, ddof=0, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 2737</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2738</span><span class="stringliteral">    Compute the geometric standard score.</span></div>
<div class="line"><span class="lineno"> 2739</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2740</span><span class="stringliteral">    Compute the geometric z score of each strictly positive value in the</span></div>
<div class="line"><span class="lineno"> 2741</span><span class="stringliteral">    sample, relative to the geometric mean and standard deviation.</span></div>
<div class="line"><span class="lineno"> 2742</span><span class="stringliteral">    Mathematically the geometric z score can be evaluated as::</span></div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral">        gzscore = log(a/gmu) / log(gsigma)</span></div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral">    where ``gmu`` (resp. ``gsigma``) is the geometric mean (resp. standard</span></div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral">    deviation).</span></div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2751</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral">        Sample data.</span></div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 2756</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">        Degrees of freedom correction in the calculation of the</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral">        standard deviation. Default is 0.</span></div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2760</span><span class="stringliteral">        Defines how to handle when input contains nan. &#39;propagate&#39; returns nan,</span></div>
<div class="line"><span class="lineno"> 2761</span><span class="stringliteral">        &#39;raise&#39; throws an error, &#39;omit&#39; performs the calculations ignoring nan</span></div>
<div class="line"><span class="lineno"> 2762</span><span class="stringliteral">        values. Default is &#39;propagate&#39;.  Note that when the value is &#39;omit&#39;,</span></div>
<div class="line"><span class="lineno"> 2763</span><span class="stringliteral">        nans in the input also propagate to the output, but they do not affect</span></div>
<div class="line"><span class="lineno"> 2764</span><span class="stringliteral">        the geometric z scores computed for the non-nan values.</span></div>
<div class="line"><span class="lineno"> 2765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2766</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2767</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2768</span><span class="stringliteral">    gzscore : array_like</span></div>
<div class="line"><span class="lineno"> 2769</span><span class="stringliteral">        The geometric z scores, standardized by geometric mean and geometric</span></div>
<div class="line"><span class="lineno"> 2770</span><span class="stringliteral">        standard deviation of input array `a`.</span></div>
<div class="line"><span class="lineno"> 2771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2772</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2773</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="stringliteral">    gmean : Geometric mean</span></div>
<div class="line"><span class="lineno"> 2775</span><span class="stringliteral">    gstd : Geometric standard deviation</span></div>
<div class="line"><span class="lineno"> 2776</span><span class="stringliteral">    zscore : Standard score</span></div>
<div class="line"><span class="lineno"> 2777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2778</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2779</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2780</span><span class="stringliteral">    This function preserves ndarray subclasses, and works also with</span></div>
<div class="line"><span class="lineno"> 2781</span><span class="stringliteral">    matrices and masked arrays (it uses ``asanyarray`` instead of</span></div>
<div class="line"><span class="lineno"> 2782</span><span class="stringliteral">    ``asarray`` for parameters).</span></div>
<div class="line"><span class="lineno"> 2783</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2784</span><span class="stringliteral">    .. versionadded:: 1.8</span></div>
<div class="line"><span class="lineno"> 2785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2786</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2787</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">    Draw samples from a log-normal distribution:</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import zscore, gzscore</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2793</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 2794</span><span class="stringliteral">    &gt;&gt;&gt; mu, sigma = 3., 1.  # mean and standard deviation</span></div>
<div class="line"><span class="lineno"> 2795</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.lognormal(mu, sigma, size=500)</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2797</span><span class="stringliteral">    Display the histogram of the samples:</span></div>
<div class="line"><span class="lineno"> 2798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2799</span><span class="stringliteral">    &gt;&gt;&gt; fig, ax = plt.subplots()</span></div>
<div class="line"><span class="lineno"> 2800</span><span class="stringliteral">    &gt;&gt;&gt; ax.hist(x, 50)</span></div>
<div class="line"><span class="lineno"> 2801</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2803</span><span class="stringliteral">    Display the histogram of the samples standardized by the classical zscore.</span></div>
<div class="line"><span class="lineno"> 2804</span><span class="stringliteral">    Distribution is rescaled but its shape is unchanged.</span></div>
<div class="line"><span class="lineno"> 2805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2806</span><span class="stringliteral">    &gt;&gt;&gt; fig, ax = plt.subplots()</span></div>
<div class="line"><span class="lineno"> 2807</span><span class="stringliteral">    &gt;&gt;&gt; ax.hist(zscore(x), 50)</span></div>
<div class="line"><span class="lineno"> 2808</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2809</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2810</span><span class="stringliteral">    Demonstrate that the distribution of geometric zscores is rescaled and</span></div>
<div class="line"><span class="lineno"> 2811</span><span class="stringliteral">    quasinormal:</span></div>
<div class="line"><span class="lineno"> 2812</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2813</span><span class="stringliteral">    &gt;&gt;&gt; fig, ax = plt.subplots()</span></div>
<div class="line"><span class="lineno"> 2814</span><span class="stringliteral">    &gt;&gt;&gt; ax.hist(gzscore(x), 50)</span></div>
<div class="line"><span class="lineno"> 2815</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2816</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2817</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2818</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 2819</span>    log = ma.log <span class="keywordflow">if</span> isinstance(a, ma.MaskedArray) <span class="keywordflow">else</span> np.log</div>
<div class="line"><span class="lineno"> 2820</span> </div>
<div class="line"><span class="lineno"> 2821</span>    <span class="keywordflow">return</span> zscore(log(a), axis=axis, ddof=ddof, nan_policy=nan_policy)</div>
<div class="line"><span class="lineno"> 2822</span> </div>
<div class="line"><span class="lineno"> 2823</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af88bd950fd9bccf915ce996246d4d040" name="af88bd950fd9bccf915ce996246d4d040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88bd950fd9bccf915ce996246d4d040">&#9670;&#160;</a></span>hmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.hmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the weighted harmonic mean along the specified axis.

The weighted harmonic mean of the array :math:`a_i` associated to weights
:math:`w_i` is:

.. math::

\frac{ \sum_{i=1}^n w_i }{ \sum_{i=1}^n \frac{w_i}{a_i} } \, ,

and, with equal weights, it gives:

.. math::

\frac{ n }{ \sum_{i=1}^n \frac{1}{a_i} } \, .

Parameters
----------
a : array_like
Input array, masked array or object that can be converted to an array.
axis : int or None, optional
Axis along which the harmonic mean is computed. Default is 0.
If None, compute over the whole array `a`.
dtype : dtype, optional
Type of the returned array and of the accumulator in which the
elements are summed. If `dtype` is not specified, it defaults to the
dtype of `a`, unless `a` has an integer `dtype` with a precision less
than that of the default platform integer. In that case, the default
platform integer is used.
weights : array_like, optional
The weights array can either be 1-D (in which case its length must be
the size of `a` along the given `axis`) or of the same shape as `a`.
Default is None, which gives each value a weight of 1.0.

.. versionadded:: 1.9

Returns
-------
hmean : ndarray
See `dtype` parameter above.

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
gmean : Geometric mean

Notes
-----
The harmonic mean is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

References
----------
.. [1] "Weighted Harmonic Mean", *Wikipedia*,
   https://en.wikipedia.org/wiki/Harmonic_mean#Weighted_harmonic_mean
.. [2] Ferger, F., "The nature and use of the harmonic mean", Journal of
   the American Statistical Association, vol. 26, pp. 36-40, 1931

Examples
--------
&gt;&gt;&gt; from scipy.stats import hmean
&gt;&gt;&gt; hmean([1, 4])
1.6000000000000001
&gt;&gt;&gt; hmean([1, 2, 3, 4, 5, 6, 7])
2.6997245179063363
&gt;&gt;&gt; hmean([1, 4, 7], weights=[3, 1, 3])
1.9029126213592233</pre> <div class="fragment"><div class="line"><span class="lineno">  321</span><span class="keyword">def </span>hmean(a, axis=0, dtype=None, *, weights=None):</div>
<div class="line"><span class="lineno">  322</span>    <span class="stringliteral">r&quot;&quot;&quot;Calculate the weighted harmonic mean along the specified axis.</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    The weighted harmonic mean of the array :math:`a_i` associated to weights</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    :math:`w_i` is:</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        \frac{ \sum_{i=1}^n w_i }{ \sum_{i=1}^n \frac{w_i}{a_i} } \, ,</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    and, with equal weights, it gives:</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">        \frac{ n }{ \sum_{i=1}^n \frac{1}{a_i} } \, .</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">        Input array, masked array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">        Axis along which the harmonic mean is computed. Default is 0.</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">        If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">        Type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">        elements are summed. If `dtype` is not specified, it defaults to the</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">        dtype of `a`, unless `a` has an integer `dtype` with a precision less</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        than that of the default platform integer. In that case, the default</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">        platform integer is used.</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">        The weights array can either be 1-D (in which case its length must be</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        the size of `a` along the given `axis`) or of the same shape as `a`.</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">        Default is None, which gives each value a weight of 1.0.</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        .. versionadded:: 1.9</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    hmean : ndarray</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        See `dtype` parameter above.</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    numpy.mean : Arithmetic average</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    numpy.average : Weighted average</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    gmean : Geometric mean</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    The harmonic mean is computed over a single dimension of the input</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    array, axis=0 by default, or all values in the array if axis=None.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    float64 intermediate and return values are used for integer inputs.</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    .. [1] &quot;Weighted Harmonic Mean&quot;, *Wikipedia*,</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Harmonic_mean#Weighted_harmonic_mean</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    .. [2] Ferger, F., &quot;The nature and use of the harmonic mean&quot;, Journal of</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">           the American Statistical Association, vol. 26, pp. 36-40, 1931</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import hmean</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    &gt;&gt;&gt; hmean([1, 4])</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    1.6000000000000001</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    &gt;&gt;&gt; hmean([1, 2, 3, 4, 5, 6, 7])</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    2.6997245179063363</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    &gt;&gt;&gt; hmean([1, 4, 7], weights=[3, 1, 3])</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    1.9029126213592233</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(a, np.ndarray):</div>
<div class="line"><span class="lineno">  393</span>        a = np.array(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">elif</span> dtype:</div>
<div class="line"><span class="lineno">  395</span>        <span class="comment"># Must change the default dtype allowing array type</span></div>
<div class="line"><span class="lineno">  396</span>        <span class="keywordflow">if</span> isinstance(a, np.ma.MaskedArray):</div>
<div class="line"><span class="lineno">  397</span>            a = np.ma.asarray(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  398</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  399</span>            a = np.asarray(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  400</span> </div>
<div class="line"><span class="lineno">  401</span>    <span class="keywordflow">if</span> np.all(a &gt;= 0):</div>
<div class="line"><span class="lineno">  402</span>        <span class="comment"># Harmonic mean only defined if greater than or equal to zero.</span></div>
<div class="line"><span class="lineno">  403</span>        <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  404</span>            weights = np.asanyarray(weights, dtype=dtype)</div>
<div class="line"><span class="lineno">  405</span> </div>
<div class="line"><span class="lineno">  406</span>        <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno">  407</span>            <span class="keywordflow">return</span> 1.0 / np.average(1.0 / a, axis=axis, weights=weights)</div>
<div class="line"><span class="lineno">  408</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  409</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Harmonic mean only defined if all elements greater &quot;</span></div>
<div class="line"><span class="lineno">  410</span>                         <span class="stringliteral">&quot;than or equal to zero&quot;</span>)</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno">  414</span>        <span class="keyword">lambda</span> x: x, n_samples=1, n_outputs=1, too_small=0, paired=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  415</span>        result_to_tuple=<span class="keyword">lambda</span> x: (x,), kwd_samples=[<span class="stringliteral">&#39;weights&#39;</span>])</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8ae1ff6d5c66e636d72a57ad7ea0472" name="ad8ae1ff6d5c66e636d72a57ad7ea0472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ae1ff6d5c66e636d72a57ad7ea0472">&#9670;&#160;</a></span>iqr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.iqr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>(25,&#160;75)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>'linear'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the interquartile range of the data along the specified axis.

The interquartile range (IQR) is the difference between the 75th and
25th percentile of the data. It is a measure of the dispersion
similar to standard deviation or variance, but is much more robust
against outliers [2]_.

The ``rng`` parameter allows this function to compute other
percentile ranges than the actual IQR. For example, setting
``rng=(0, 100)`` is equivalent to `numpy.ptp`.

The IQR of an empty array is `np.nan`.

.. versionadded:: 0.18.0

Parameters
----------
x : array_like
Input array or object that can be converted to an array.
axis : int or sequence of int, optional
Axis along which the range is computed. The default is to
compute the IQR for the entire array.
rng : Two-element sequence containing floats in range of [0,100] optional
Percentiles over which to compute the range. Each must be
between 0 and 100, inclusive. The default is the true IQR:
``(25, 75)``. The order of the elements is not important.
scale : scalar or str, optional
The numerical value of scale will be divided out of the final
result. The following string values are recognized:

* 'raw' : No scaling, just return the raw IQR.
**Deprecated!**  Use ``scale=1`` instead.
* 'normal' : Scale by
:math:`2 \sqrt{2} erf^{-1}(\frac{1}{2}) \approx 1.349`.

The default is 1.0. The use of ``scale='raw'`` is deprecated.
Array-like `scale` is also allowed, as long
as it broadcasts correctly to the output such that
``out / scale`` is a valid operation. The output dimensions
depend on the input array, `x`, the `axis` argument, and the
`keepdims` flag.
nan_policy : {'propagate', 'raise', 'omit'}, optional
Defines how to handle when input contains nan.
The following options are available (default is 'propagate'):

* 'propagate': returns nan
* 'raise': throws an error
* 'omit': performs the calculations ignoring nan values
interpolation : str, optional

Specifies the interpolation method to use when the percentile
boundaries lie between two data points ``i`` and ``j``.
The following options are available (default is 'linear'):

* 'linear': ``i + (j - i)*fraction``, where ``fraction`` is the
fractional part of the index surrounded by ``i`` and ``j``.
* 'lower': ``i``.
* 'higher': ``j``.
* 'nearest': ``i`` or ``j`` whichever is nearest.
* 'midpoint': ``(i + j)/2``.

For NumPy &gt;= 1.22.0, the additional options provided by the ``method``
keyword of `numpy.percentile` are also valid.

keepdims : bool, optional
If this is set to True, the reduced axes are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original array `x`.

Returns
-------
iqr : scalar or ndarray
If ``axis=None``, a scalar is returned. If the input contains
integers or floats of smaller precision than ``np.float64``, then the
output data-type is ``np.float64``. Otherwise, the output data-type is
the same as that of the input.

See Also
--------
numpy.std, numpy.var

References
----------
.. [1] "Interquartile range" https://en.wikipedia.org/wiki/Interquartile_range
.. [2] "Robust measures of scale" https://en.wikipedia.org/wiki/Robust_measures_of_scale
.. [3] "Quantile" https://en.wikipedia.org/wiki/Quantile

Examples
--------
&gt;&gt;&gt; from scipy.stats import iqr
&gt;&gt;&gt; x = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; x
array([[10,  7,  4],
[ 3,  2,  1]])
&gt;&gt;&gt; iqr(x)
4.0
&gt;&gt;&gt; iqr(x, axis=0)
array([ 3.5,  2.5,  1.5])
&gt;&gt;&gt; iqr(x, axis=1)
array([ 3.,  1.])
&gt;&gt;&gt; iqr(x, axis=1, keepdims=True)
array([[ 3.],
[ 1.]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3053</span>        interpolation=<span class="stringliteral">&#39;linear&#39;</span>, keepdims=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 3054</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3055</span><span class="stringliteral">    Compute the interquartile range of the data along the specified axis.</span></div>
<div class="line"><span class="lineno"> 3056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3057</span><span class="stringliteral">    The interquartile range (IQR) is the difference between the 75th and</span></div>
<div class="line"><span class="lineno"> 3058</span><span class="stringliteral">    25th percentile of the data. It is a measure of the dispersion</span></div>
<div class="line"><span class="lineno"> 3059</span><span class="stringliteral">    similar to standard deviation or variance, but is much more robust</span></div>
<div class="line"><span class="lineno"> 3060</span><span class="stringliteral">    against outliers [2]_.</span></div>
<div class="line"><span class="lineno"> 3061</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3062</span><span class="stringliteral">    The ``rng`` parameter allows this function to compute other</span></div>
<div class="line"><span class="lineno"> 3063</span><span class="stringliteral">    percentile ranges than the actual IQR. For example, setting</span></div>
<div class="line"><span class="lineno"> 3064</span><span class="stringliteral">    ``rng=(0, 100)`` is equivalent to `numpy.ptp`.</span></div>
<div class="line"><span class="lineno"> 3065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3066</span><span class="stringliteral">    The IQR of an empty array is `np.nan`.</span></div>
<div class="line"><span class="lineno"> 3067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3068</span><span class="stringliteral">    .. versionadded:: 0.18.0</span></div>
<div class="line"><span class="lineno"> 3069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3070</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3071</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3072</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 3073</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 3074</span><span class="stringliteral">    axis : int or sequence of int, optional</span></div>
<div class="line"><span class="lineno"> 3075</span><span class="stringliteral">        Axis along which the range is computed. The default is to</span></div>
<div class="line"><span class="lineno"> 3076</span><span class="stringliteral">        compute the IQR for the entire array.</span></div>
<div class="line"><span class="lineno"> 3077</span><span class="stringliteral">    rng : Two-element sequence containing floats in range of [0,100] optional</span></div>
<div class="line"><span class="lineno"> 3078</span><span class="stringliteral">        Percentiles over which to compute the range. Each must be</span></div>
<div class="line"><span class="lineno"> 3079</span><span class="stringliteral">        between 0 and 100, inclusive. The default is the true IQR:</span></div>
<div class="line"><span class="lineno"> 3080</span><span class="stringliteral">        ``(25, 75)``. The order of the elements is not important.</span></div>
<div class="line"><span class="lineno"> 3081</span><span class="stringliteral">    scale : scalar or str, optional</span></div>
<div class="line"><span class="lineno"> 3082</span><span class="stringliteral">        The numerical value of scale will be divided out of the final</span></div>
<div class="line"><span class="lineno"> 3083</span><span class="stringliteral">        result. The following string values are recognized:</span></div>
<div class="line"><span class="lineno"> 3084</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3085</span><span class="stringliteral">          * &#39;raw&#39; : No scaling, just return the raw IQR.</span></div>
<div class="line"><span class="lineno"> 3086</span><span class="stringliteral">            **Deprecated!**  Use ``scale=1`` instead.</span></div>
<div class="line"><span class="lineno"> 3087</span><span class="stringliteral">          * &#39;normal&#39; : Scale by</span></div>
<div class="line"><span class="lineno"> 3088</span><span class="stringliteral">            :math:`2 \sqrt{2} erf^{-1}(\frac{1}{2}) \approx 1.349`.</span></div>
<div class="line"><span class="lineno"> 3089</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3090</span><span class="stringliteral">        The default is 1.0. The use of ``scale=&#39;raw&#39;`` is deprecated.</span></div>
<div class="line"><span class="lineno"> 3091</span><span class="stringliteral">        Array-like `scale` is also allowed, as long</span></div>
<div class="line"><span class="lineno"> 3092</span><span class="stringliteral">        as it broadcasts correctly to the output such that</span></div>
<div class="line"><span class="lineno"> 3093</span><span class="stringliteral">        ``out / scale`` is a valid operation. The output dimensions</span></div>
<div class="line"><span class="lineno"> 3094</span><span class="stringliteral">        depend on the input array, `x`, the `axis` argument, and the</span></div>
<div class="line"><span class="lineno"> 3095</span><span class="stringliteral">        `keepdims` flag.</span></div>
<div class="line"><span class="lineno"> 3096</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3097</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 3098</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 3099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3100</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 3101</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 3102</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 3103</span><span class="stringliteral">    interpolation : str, optional</span></div>
<div class="line"><span class="lineno"> 3104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3105</span><span class="stringliteral">        Specifies the interpolation method to use when the percentile</span></div>
<div class="line"><span class="lineno"> 3106</span><span class="stringliteral">        boundaries lie between two data points ``i`` and ``j``.</span></div>
<div class="line"><span class="lineno"> 3107</span><span class="stringliteral">        The following options are available (default is &#39;linear&#39;):</span></div>
<div class="line"><span class="lineno"> 3108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3109</span><span class="stringliteral">          * &#39;linear&#39;: ``i + (j - i)*fraction``, where ``fraction`` is the</span></div>
<div class="line"><span class="lineno"> 3110</span><span class="stringliteral">            fractional part of the index surrounded by ``i`` and ``j``.</span></div>
<div class="line"><span class="lineno"> 3111</span><span class="stringliteral">          * &#39;lower&#39;: ``i``.</span></div>
<div class="line"><span class="lineno"> 3112</span><span class="stringliteral">          * &#39;higher&#39;: ``j``.</span></div>
<div class="line"><span class="lineno"> 3113</span><span class="stringliteral">          * &#39;nearest&#39;: ``i`` or ``j`` whichever is nearest.</span></div>
<div class="line"><span class="lineno"> 3114</span><span class="stringliteral">          * &#39;midpoint&#39;: ``(i + j)/2``.</span></div>
<div class="line"><span class="lineno"> 3115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3116</span><span class="stringliteral">        For NumPy &gt;= 1.22.0, the additional options provided by the ``method``</span></div>
<div class="line"><span class="lineno"> 3117</span><span class="stringliteral">        keyword of `numpy.percentile` are also valid.</span></div>
<div class="line"><span class="lineno"> 3118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3119</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 3120</span><span class="stringliteral">        If this is set to True, the reduced axes are left in the</span></div>
<div class="line"><span class="lineno"> 3121</span><span class="stringliteral">        result as dimensions with size one. With this option, the result</span></div>
<div class="line"><span class="lineno"> 3122</span><span class="stringliteral">        will broadcast correctly against the original array `x`.</span></div>
<div class="line"><span class="lineno"> 3123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3124</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3125</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3126</span><span class="stringliteral">    iqr : scalar or ndarray</span></div>
<div class="line"><span class="lineno"> 3127</span><span class="stringliteral">        If ``axis=None``, a scalar is returned. If the input contains</span></div>
<div class="line"><span class="lineno"> 3128</span><span class="stringliteral">        integers or floats of smaller precision than ``np.float64``, then the</span></div>
<div class="line"><span class="lineno"> 3129</span><span class="stringliteral">        output data-type is ``np.float64``. Otherwise, the output data-type is</span></div>
<div class="line"><span class="lineno"> 3130</span><span class="stringliteral">        the same as that of the input.</span></div>
<div class="line"><span class="lineno"> 3131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3132</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3133</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3134</span><span class="stringliteral">    numpy.std, numpy.var</span></div>
<div class="line"><span class="lineno"> 3135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3136</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3137</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3138</span><span class="stringliteral">    .. [1] &quot;Interquartile range&quot; https://en.wikipedia.org/wiki/Interquartile_range</span></div>
<div class="line"><span class="lineno"> 3139</span><span class="stringliteral">    .. [2] &quot;Robust measures of scale&quot; https://en.wikipedia.org/wiki/Robust_measures_of_scale</span></div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral">    .. [3] &quot;Quantile&quot; https://en.wikipedia.org/wiki/Quantile</span></div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3142</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3143</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3144</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import iqr</span></div>
<div class="line"><span class="lineno"> 3145</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[10, 7, 4], [3, 2, 1]])</span></div>
<div class="line"><span class="lineno"> 3146</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 3147</span><span class="stringliteral">    array([[10,  7,  4],</span></div>
<div class="line"><span class="lineno"> 3148</span><span class="stringliteral">           [ 3,  2,  1]])</span></div>
<div class="line"><span class="lineno"> 3149</span><span class="stringliteral">    &gt;&gt;&gt; iqr(x)</span></div>
<div class="line"><span class="lineno"> 3150</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno"> 3151</span><span class="stringliteral">    &gt;&gt;&gt; iqr(x, axis=0)</span></div>
<div class="line"><span class="lineno"> 3152</span><span class="stringliteral">    array([ 3.5,  2.5,  1.5])</span></div>
<div class="line"><span class="lineno"> 3153</span><span class="stringliteral">    &gt;&gt;&gt; iqr(x, axis=1)</span></div>
<div class="line"><span class="lineno"> 3154</span><span class="stringliteral">    array([ 3.,  1.])</span></div>
<div class="line"><span class="lineno"> 3155</span><span class="stringliteral">    &gt;&gt;&gt; iqr(x, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 3156</span><span class="stringliteral">    array([[ 3.],</span></div>
<div class="line"><span class="lineno"> 3157</span><span class="stringliteral">           [ 1.]])</span></div>
<div class="line"><span class="lineno"> 3158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3159</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3160</span>    x = asarray(x)</div>
<div class="line"><span class="lineno"> 3161</span> </div>
<div class="line"><span class="lineno"> 3162</span>    <span class="comment"># This check prevents percentile from raising an error later. Also, it is</span></div>
<div class="line"><span class="lineno"> 3163</span>    <span class="comment"># consistent with `np.var` and `np.std`.</span></div>
<div class="line"><span class="lineno"> 3164</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> x.size:</div>
<div class="line"><span class="lineno"> 3165</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 3166</span> </div>
<div class="line"><span class="lineno"> 3167</span>    <span class="comment"># An error may be raised here, so fail-fast, before doing lengthy</span></div>
<div class="line"><span class="lineno"> 3168</span>    <span class="comment"># computations, even though `scale` is not used until later</span></div>
<div class="line"><span class="lineno"> 3169</span>    <span class="keywordflow">if</span> isinstance(scale, str):</div>
<div class="line"><span class="lineno"> 3170</span>        scale_key = scale.lower()</div>
<div class="line"><span class="lineno"> 3171</span>        <span class="keywordflow">if</span> scale_key <span class="keywordflow">not</span> <span class="keywordflow">in</span> _scale_conversions:</div>
<div class="line"><span class="lineno"> 3172</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;{0} not a valid scale for `iqr`&quot;</span>.format(scale))</div>
<div class="line"><span class="lineno"> 3173</span>        <span class="keywordflow">if</span> scale_key == <span class="stringliteral">&#39;raw&#39;</span>:</div>
<div class="line"><span class="lineno"> 3174</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 3175</span>                <span class="stringliteral">&quot;use of scale=&#39;raw&#39; is deprecated, use scale=1.0 instead&quot;</span>,</div>
<div class="line"><span class="lineno"> 3176</span>                np.VisibleDeprecationWarning</div>
<div class="line"><span class="lineno"> 3177</span>            )</div>
<div class="line"><span class="lineno"> 3178</span>        scale = _scale_conversions[scale_key]</div>
<div class="line"><span class="lineno"> 3179</span> </div>
<div class="line"><span class="lineno"> 3180</span>    <span class="comment"># Select the percentile function to use based on nans and policy</span></div>
<div class="line"><span class="lineno"> 3181</span>    contains_nan, nan_policy = _contains_nan(x, nan_policy)</div>
<div class="line"><span class="lineno"> 3182</span> </div>
<div class="line"><span class="lineno"> 3183</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 3184</span>        percentile_func = np.nanpercentile</div>
<div class="line"><span class="lineno"> 3185</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3186</span>        percentile_func = np.percentile</div>
<div class="line"><span class="lineno"> 3187</span> </div>
<div class="line"><span class="lineno"> 3188</span>    <span class="keywordflow">if</span> len(rng) != 2:</div>
<div class="line"><span class="lineno"> 3189</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;quantile range must be two element sequence&quot;</span>)</div>
<div class="line"><span class="lineno"> 3190</span> </div>
<div class="line"><span class="lineno"> 3191</span>    <span class="keywordflow">if</span> np.isnan(rng).any():</div>
<div class="line"><span class="lineno"> 3192</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;range must not contain NaNs&quot;</span>)</div>
<div class="line"><span class="lineno"> 3193</span> </div>
<div class="line"><span class="lineno"> 3194</span>    rng = sorted(rng)</div>
<div class="line"><span class="lineno"> 3195</span>    <span class="keywordflow">if</span> NumpyVersion(np.__version__) &gt;= <span class="stringliteral">&#39;1.22.0&#39;</span>:</div>
<div class="line"><span class="lineno"> 3196</span>        pct = percentile_func(x, rng, axis=axis, method=interpolation,</div>
<div class="line"><span class="lineno"> 3197</span>                              keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 3198</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3199</span>        pct = percentile_func(x, rng, axis=axis, interpolation=interpolation,</div>
<div class="line"><span class="lineno"> 3200</span>                              keepdims=keepdims)</div>
<div class="line"><span class="lineno"> 3201</span>    out = np.subtract(pct[1], pct[0])</div>
<div class="line"><span class="lineno"> 3202</span> </div>
<div class="line"><span class="lineno"> 3203</span>    <span class="keywordflow">if</span> scale != 1.0:</div>
<div class="line"><span class="lineno"> 3204</span>        out /= scale</div>
<div class="line"><span class="lineno"> 3205</span> </div>
<div class="line"><span class="lineno"> 3206</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 3207</span> </div>
<div class="line"><span class="lineno"> 3208</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a90174889d2756209212a6c5974bd3057" name="a90174889d2756209212a6c5974bd3057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90174889d2756209212a6c5974bd3057">&#9670;&#160;</a></span>jarque_bera()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.jarque_bera </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the Jarque-Bera goodness of fit test on sample data.

The Jarque-Bera test tests whether the sample data has the skewness and
kurtosis matching a normal distribution.

Note that this test only works for a large enough number of data samples
(&gt;2000) as the test statistic asymptotically has a Chi-squared distribution
with 2 degrees of freedom.

Parameters
----------
x : array_like
    Observations of a random variable.

Returns
-------
jb_value : float
    The test statistic.
p : float
    The p-value for the hypothesis test.

References
----------
.. [1] Jarque, C. and Bera, A. (1980) "Efficient tests for normality,
       homoscedasticity and serial independence of regression residuals",
       6 Econometric Letters 255-259.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = rng.normal(0, 1, 100000)
&gt;&gt;&gt; jarque_bera_test = stats.jarque_bera(x)
&gt;&gt;&gt; jarque_bera_test
Jarque_beraResult(statistic=3.3415184718131554, pvalue=0.18810419594996775)
&gt;&gt;&gt; jarque_bera_test.statistic
3.3415184718131554
&gt;&gt;&gt; jarque_bera_test.pvalue
0.18810419594996775</pre> <div class="fragment"><div class="line"><span class="lineno"> 1878</span><span class="keyword">def </span>jarque_bera(x):</div>
<div class="line"><span class="lineno"> 1879</span>    <span class="stringliteral">&quot;&quot;&quot;Perform the Jarque-Bera goodness of fit test on sample data.</span></div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">    The Jarque-Bera test tests whether the sample data has the skewness and</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral">    kurtosis matching a normal distribution.</span></div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">    Note that this test only works for a large enough number of data samples</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">    (&gt;2000) as the test statistic asymptotically has a Chi-squared distribution</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    with 2 degrees of freedom.</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">        Observations of a random variable.</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">    jb_value : float</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">        The test statistic.</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    p : float</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">        The p-value for the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">    .. [1] Jarque, C. and Bera, A. (1980) &quot;Efficient tests for normality,</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">           homoscedasticity and serial independence of regression residuals&quot;,</span></div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">           6 Econometric Letters 255-259.</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">    &gt;&gt;&gt; x = rng.normal(0, 1, 100000)</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">    &gt;&gt;&gt; jarque_bera_test = stats.jarque_bera(x)</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">    &gt;&gt;&gt; jarque_bera_test</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">    Jarque_beraResult(statistic=3.3415184718131554, pvalue=0.18810419594996775)</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">    &gt;&gt;&gt; jarque_bera_test.statistic</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">    3.3415184718131554</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    &gt;&gt;&gt; jarque_bera_test.pvalue</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">    0.18810419594996775</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1920</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 1921</span>    n = x.size</div>
<div class="line"><span class="lineno"> 1922</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno"> 1923</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;At least one observation is required.&#39;</span>)</div>
<div class="line"><span class="lineno"> 1924</span> </div>
<div class="line"><span class="lineno"> 1925</span>    mu = x.mean()</div>
<div class="line"><span class="lineno"> 1926</span>    diffx = x - mu</div>
<div class="line"><span class="lineno"> 1927</span>    skewness = (1 / n * np.sum(diffx**3)) / (1 / n * np.sum(diffx**2))**(3 / 2.)</div>
<div class="line"><span class="lineno"> 1928</span>    kurtosis = (1 / n * np.sum(diffx**4)) / (1 / n * np.sum(diffx**2))**2</div>
<div class="line"><span class="lineno"> 1929</span>    jb_value = n / 6 * (skewness**2 + (kurtosis - 3)**2 / 4)</div>
<div class="line"><span class="lineno"> 1930</span>    p = 1 - distributions.chi2.cdf(jb_value, 2)</div>
<div class="line"><span class="lineno"> 1931</span> </div>
<div class="line"><span class="lineno"> 1932</span>    <span class="keywordflow">return</span> Jarque_beraResult(jb_value, p)</div>
<div class="line"><span class="lineno"> 1933</span> </div>
<div class="line"><span class="lineno"> 1934</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40ce454d71767fd548c3da8a056cbd35" name="a40ce454d71767fd548c3da8a056cbd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce454d71767fd548c3da8a056cbd35">&#9670;&#160;</a></span>kendalltau()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.kendalltau </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_lexsort</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>variant</em> = <code>'b'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate Kendall's tau, a correlation measure for ordinal data.

Kendall's tau is a measure of the correspondence between two rankings.
Values close to 1 indicate strong agreement, and values close to -1
indicate strong disagreement. This implements two variants of Kendall's
tau: tau-b (the default) and tau-c (also known as Stuart's tau-c). These
differ only in how they are normalized to lie within the range -1 to 1;
the hypothesis tests (their p-values) are identical. Kendall's original
tau-a is not implemented separately because both tau-b and tau-c reduce
to tau-a in the absence of ties.

Parameters
----------
x, y : array_like
    Arrays of rankings, of the same shape. If arrays are not 1-D, they
    will be flattened to 1-D.
initial_lexsort : bool, optional
    Unused (deprecated).
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

method : {'auto', 'asymptotic', 'exact'}, optional
    Defines which method is used to calculate the p-value [5]_.
    The following options are available (default is 'auto'):

      * 'auto': selects the appropriate method based on a trade-off
        between speed and accuracy
      * 'asymptotic': uses a normal approximation valid for large samples
      * 'exact': computes the exact p-value, but can only be used if no ties
        are present. As the sample size increases, the 'exact' computation
        time may grow and the result may lose some precision.
variant : {'b', 'c'}, optional
    Defines which variant of Kendall's tau is returned. Default is 'b'.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the rank correlation is nonzero
    * 'less': the rank correlation is negative (less than zero)
    * 'greater':  the rank correlation is positive (greater than zero)

Returns
-------
correlation : float
   The tau statistic.
pvalue : float
   The p-value for a hypothesis test whose null hypothesis is
   an absence of association, tau = 0.

See Also
--------
spearmanr : Calculates a Spearman rank-order correlation coefficient.
theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).
weightedtau : Computes a weighted version of Kendall's tau.

Notes
-----
The definition of Kendall's tau that is used is [2]_::

  tau_b = (P - Q) / sqrt((P + Q + T) * (P + Q + U))

  tau_c = 2 (P - Q) / (n**2 * (m - 1) / m)

where P is the number of concordant pairs, Q the number of discordant
pairs, T the number of ties only in `x`, and U the number of ties only in
`y`.  If a tie occurs for the same pair in both `x` and `y`, it is not
added to either T or U. n is the total number of samples, and m is the
number of unique values in either `x` or `y`, whichever is smaller.

References
----------
.. [1] Maurice G. Kendall, "A New Measure of Rank Correlation", Biometrika
       Vol. 30, No. 1/2, pp. 81-93, 1938.
.. [2] Maurice G. Kendall, "The treatment of ties in ranking problems",
       Biometrika Vol. 33, No. 3, pp. 239-251. 1945.
.. [3] Gottfried E. Noether, "Elements of Nonparametric Statistics", John
       Wiley &amp; Sons, 1967.
.. [4] Peter M. Fenwick, "A new data structure for cumulative frequency
       tables", Software: Practice and Experience, Vol. 24, No. 3,
       pp. 327-336, 1994.
.. [5] Maurice G. Kendall, "Rank Correlation Methods" (4th Edition),
       Charles Griffin &amp; Co., 1970.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x1 = [12, 2, 1, 12, 2]
&gt;&gt;&gt; x2 = [1, 4, 7, 1, 0]
&gt;&gt;&gt; tau, p_value = stats.kendalltau(x1, x2)
&gt;&gt;&gt; tau
-0.47140452079103173
&gt;&gt;&gt; p_value
0.2827454599327748</pre> <div class="fragment"><div class="line"><span class="lineno"> 5019</span>               method=<span class="stringliteral">&#39;auto&#39;</span>, variant=<span class="stringliteral">&#39;b&#39;</span>, alternative=<span class="stringliteral">&#39;two-sided&#39;</span>):</div>
<div class="line"><span class="lineno"> 5020</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate Kendall&#39;s tau, a correlation measure for ordinal data.</span></div>
<div class="line"><span class="lineno"> 5021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5022</span><span class="stringliteral">    Kendall&#39;s tau is a measure of the correspondence between two rankings.</span></div>
<div class="line"><span class="lineno"> 5023</span><span class="stringliteral">    Values close to 1 indicate strong agreement, and values close to -1</span></div>
<div class="line"><span class="lineno"> 5024</span><span class="stringliteral">    indicate strong disagreement. This implements two variants of Kendall&#39;s</span></div>
<div class="line"><span class="lineno"> 5025</span><span class="stringliteral">    tau: tau-b (the default) and tau-c (also known as Stuart&#39;s tau-c). These</span></div>
<div class="line"><span class="lineno"> 5026</span><span class="stringliteral">    differ only in how they are normalized to lie within the range -1 to 1;</span></div>
<div class="line"><span class="lineno"> 5027</span><span class="stringliteral">    the hypothesis tests (their p-values) are identical. Kendall&#39;s original</span></div>
<div class="line"><span class="lineno"> 5028</span><span class="stringliteral">    tau-a is not implemented separately because both tau-b and tau-c reduce</span></div>
<div class="line"><span class="lineno"> 5029</span><span class="stringliteral">    to tau-a in the absence of ties.</span></div>
<div class="line"><span class="lineno"> 5030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5031</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5032</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5033</span><span class="stringliteral">    x, y : array_like</span></div>
<div class="line"><span class="lineno"> 5034</span><span class="stringliteral">        Arrays of rankings, of the same shape. If arrays are not 1-D, they</span></div>
<div class="line"><span class="lineno"> 5035</span><span class="stringliteral">        will be flattened to 1-D.</span></div>
<div class="line"><span class="lineno"> 5036</span><span class="stringliteral">    initial_lexsort : bool, optional</span></div>
<div class="line"><span class="lineno"> 5037</span><span class="stringliteral">        Unused (deprecated).</span></div>
<div class="line"><span class="lineno"> 5038</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 5039</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 5040</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 5041</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5042</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 5043</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 5044</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 5045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5046</span><span class="stringliteral">    method : {&#39;auto&#39;, &#39;asymptotic&#39;, &#39;exact&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 5047</span><span class="stringliteral">        Defines which method is used to calculate the p-value [5]_.</span></div>
<div class="line"><span class="lineno"> 5048</span><span class="stringliteral">        The following options are available (default is &#39;auto&#39;):</span></div>
<div class="line"><span class="lineno"> 5049</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5050</span><span class="stringliteral">          * &#39;auto&#39;: selects the appropriate method based on a trade-off</span></div>
<div class="line"><span class="lineno"> 5051</span><span class="stringliteral">            between speed and accuracy</span></div>
<div class="line"><span class="lineno"> 5052</span><span class="stringliteral">          * &#39;asymptotic&#39;: uses a normal approximation valid for large samples</span></div>
<div class="line"><span class="lineno"> 5053</span><span class="stringliteral">          * &#39;exact&#39;: computes the exact p-value, but can only be used if no ties</span></div>
<div class="line"><span class="lineno"> 5054</span><span class="stringliteral">            are present. As the sample size increases, the &#39;exact&#39; computation</span></div>
<div class="line"><span class="lineno"> 5055</span><span class="stringliteral">            time may grow and the result may lose some precision.</span></div>
<div class="line"><span class="lineno"> 5056</span><span class="stringliteral">    variant : {&#39;b&#39;, &#39;c&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 5057</span><span class="stringliteral">        Defines which variant of Kendall&#39;s tau is returned. Default is &#39;b&#39;.</span></div>
<div class="line"><span class="lineno"> 5058</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 5059</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 5060</span><span class="stringliteral">        The following options are available:</span></div>
<div class="line"><span class="lineno"> 5061</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5062</span><span class="stringliteral">        * &#39;two-sided&#39;: the rank correlation is nonzero</span></div>
<div class="line"><span class="lineno"> 5063</span><span class="stringliteral">        * &#39;less&#39;: the rank correlation is negative (less than zero)</span></div>
<div class="line"><span class="lineno"> 5064</span><span class="stringliteral">        * &#39;greater&#39;:  the rank correlation is positive (greater than zero)</span></div>
<div class="line"><span class="lineno"> 5065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5066</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5067</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5068</span><span class="stringliteral">    correlation : float</span></div>
<div class="line"><span class="lineno"> 5069</span><span class="stringliteral">       The tau statistic.</span></div>
<div class="line"><span class="lineno"> 5070</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 5071</span><span class="stringliteral">       The p-value for a hypothesis test whose null hypothesis is</span></div>
<div class="line"><span class="lineno"> 5072</span><span class="stringliteral">       an absence of association, tau = 0.</span></div>
<div class="line"><span class="lineno"> 5073</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5074</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 5075</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5076</span><span class="stringliteral">    spearmanr : Calculates a Spearman rank-order correlation coefficient.</span></div>
<div class="line"><span class="lineno"> 5077</span><span class="stringliteral">    theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).</span></div>
<div class="line"><span class="lineno"> 5078</span><span class="stringliteral">    weightedtau : Computes a weighted version of Kendall&#39;s tau.</span></div>
<div class="line"><span class="lineno"> 5079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5080</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 5081</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 5082</span><span class="stringliteral">    The definition of Kendall&#39;s tau that is used is [2]_::</span></div>
<div class="line"><span class="lineno"> 5083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5084</span><span class="stringliteral">      tau_b = (P - Q) / sqrt((P + Q + T) * (P + Q + U))</span></div>
<div class="line"><span class="lineno"> 5085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5086</span><span class="stringliteral">      tau_c = 2 (P - Q) / (n**2 * (m - 1) / m)</span></div>
<div class="line"><span class="lineno"> 5087</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5088</span><span class="stringliteral">    where P is the number of concordant pairs, Q the number of discordant</span></div>
<div class="line"><span class="lineno"> 5089</span><span class="stringliteral">    pairs, T the number of ties only in `x`, and U the number of ties only in</span></div>
<div class="line"><span class="lineno"> 5090</span><span class="stringliteral">    `y`.  If a tie occurs for the same pair in both `x` and `y`, it is not</span></div>
<div class="line"><span class="lineno"> 5091</span><span class="stringliteral">    added to either T or U. n is the total number of samples, and m is the</span></div>
<div class="line"><span class="lineno"> 5092</span><span class="stringliteral">    number of unique values in either `x` or `y`, whichever is smaller.</span></div>
<div class="line"><span class="lineno"> 5093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5094</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 5095</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5096</span><span class="stringliteral">    .. [1] Maurice G. Kendall, &quot;A New Measure of Rank Correlation&quot;, Biometrika</span></div>
<div class="line"><span class="lineno"> 5097</span><span class="stringliteral">           Vol. 30, No. 1/2, pp. 81-93, 1938.</span></div>
<div class="line"><span class="lineno"> 5098</span><span class="stringliteral">    .. [2] Maurice G. Kendall, &quot;The treatment of ties in ranking problems&quot;,</span></div>
<div class="line"><span class="lineno"> 5099</span><span class="stringliteral">           Biometrika Vol. 33, No. 3, pp. 239-251. 1945.</span></div>
<div class="line"><span class="lineno"> 5100</span><span class="stringliteral">    .. [3] Gottfried E. Noether, &quot;Elements of Nonparametric Statistics&quot;, John</span></div>
<div class="line"><span class="lineno"> 5101</span><span class="stringliteral">           Wiley &amp; Sons, 1967.</span></div>
<div class="line"><span class="lineno"> 5102</span><span class="stringliteral">    .. [4] Peter M. Fenwick, &quot;A new data structure for cumulative frequency</span></div>
<div class="line"><span class="lineno"> 5103</span><span class="stringliteral">           tables&quot;, Software: Practice and Experience, Vol. 24, No. 3,</span></div>
<div class="line"><span class="lineno"> 5104</span><span class="stringliteral">           pp. 327-336, 1994.</span></div>
<div class="line"><span class="lineno"> 5105</span><span class="stringliteral">    .. [5] Maurice G. Kendall, &quot;Rank Correlation Methods&quot; (4th Edition),</span></div>
<div class="line"><span class="lineno"> 5106</span><span class="stringliteral">           Charles Griffin &amp; Co., 1970.</span></div>
<div class="line"><span class="lineno"> 5107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5108</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 5109</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5110</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 5111</span><span class="stringliteral">    &gt;&gt;&gt; x1 = [12, 2, 1, 12, 2]</span></div>
<div class="line"><span class="lineno"> 5112</span><span class="stringliteral">    &gt;&gt;&gt; x2 = [1, 4, 7, 1, 0]</span></div>
<div class="line"><span class="lineno"> 5113</span><span class="stringliteral">    &gt;&gt;&gt; tau, p_value = stats.kendalltau(x1, x2)</span></div>
<div class="line"><span class="lineno"> 5114</span><span class="stringliteral">    &gt;&gt;&gt; tau</span></div>
<div class="line"><span class="lineno"> 5115</span><span class="stringliteral">    -0.47140452079103173</span></div>
<div class="line"><span class="lineno"> 5116</span><span class="stringliteral">    &gt;&gt;&gt; p_value</span></div>
<div class="line"><span class="lineno"> 5117</span><span class="stringliteral">    0.2827454599327748</span></div>
<div class="line"><span class="lineno"> 5118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5119</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5120</span>    x = np.asarray(x).ravel()</div>
<div class="line"><span class="lineno"> 5121</span>    y = np.asarray(y).ravel()</div>
<div class="line"><span class="lineno"> 5122</span> </div>
<div class="line"><span class="lineno"> 5123</span>    <span class="keywordflow">if</span> x.size != y.size:</div>
<div class="line"><span class="lineno"> 5124</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All inputs to `kendalltau` must be of the same &quot;</span></div>
<div class="line"><span class="lineno"> 5125</span>                         f<span class="stringliteral">&quot;size, found x-size {x.size} and y-size {y.size}&quot;</span>)</div>
<div class="line"><span class="lineno"> 5126</span>    <span class="keywordflow">elif</span> <span class="keywordflow">not</span> x.size <span class="keywordflow">or</span> <span class="keywordflow">not</span> y.size:</div>
<div class="line"><span class="lineno"> 5127</span>        <span class="comment"># Return NaN if arrays are empty</span></div>
<div class="line"><span class="lineno"> 5128</span>        <span class="keywordflow">return</span> KendalltauResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 5129</span> </div>
<div class="line"><span class="lineno"> 5130</span>    <span class="comment"># check both x and y</span></div>
<div class="line"><span class="lineno"> 5131</span>    cnx, npx = _contains_nan(x, nan_policy)</div>
<div class="line"><span class="lineno"> 5132</span>    cny, npy = _contains_nan(y, nan_policy)</div>
<div class="line"><span class="lineno"> 5133</span>    contains_nan = cnx <span class="keywordflow">or</span> cny</div>
<div class="line"><span class="lineno"> 5134</span>    <span class="keywordflow">if</span> npx == <span class="stringliteral">&#39;omit&#39;</span> <span class="keywordflow">or</span> npy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 5135</span>        nan_policy = <span class="stringliteral">&#39;omit&#39;</span></div>
<div class="line"><span class="lineno"> 5136</span> </div>
<div class="line"><span class="lineno"> 5137</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;propagate&#39;</span>:</div>
<div class="line"><span class="lineno"> 5138</span>        <span class="keywordflow">return</span> KendalltauResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 5139</span> </div>
<div class="line"><span class="lineno"> 5140</span>    <span class="keywordflow">elif</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 5141</span>        x = ma.masked_invalid(x)</div>
<div class="line"><span class="lineno"> 5142</span>        y = ma.masked_invalid(y)</div>
<div class="line"><span class="lineno"> 5143</span>        <span class="keywordflow">if</span> variant == <span class="stringliteral">&#39;b&#39;</span>:</div>
<div class="line"><span class="lineno"> 5144</span>            <span class="keywordflow">return</span> mstats_basic.kendalltau(x, y, method=method, use_ties=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 5145</span>                                           alternative=alternative)</div>
<div class="line"><span class="lineno"> 5146</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5147</span>            message = (<span class="stringliteral">&quot;nan_policy=&#39;omit&#39; is currently compatible only with &quot;</span></div>
<div class="line"><span class="lineno"> 5148</span>                       <span class="stringliteral">&quot;variant=&#39;b&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5149</span>            <span class="keywordflow">raise</span> ValueError(message)</div>
<div class="line"><span class="lineno"> 5150</span> </div>
<div class="line"><span class="lineno"> 5151</span>    <span class="keywordflow">if</span> initial_lexsort <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:  <span class="comment"># deprecate to drop!</span></div>
<div class="line"><span class="lineno"> 5152</span>        warnings.warn(<span class="stringliteral">&#39;&quot;initial_lexsort&quot; is gone!&#39;</span>)</div>
<div class="line"><span class="lineno"> 5153</span> </div>
<div class="line"><span class="lineno"> 5154</span>    <span class="keyword">def </span>count_rank_tie(ranks):</div>
<div class="line"><span class="lineno"> 5155</span>        cnt = np.bincount(ranks).astype(<span class="stringliteral">&#39;int64&#39;</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 5156</span>        cnt = cnt[cnt &gt; 1]</div>
<div class="line"><span class="lineno"> 5157</span>        <span class="keywordflow">return</span> ((cnt * (cnt - 1) // 2).sum(),</div>
<div class="line"><span class="lineno"> 5158</span>                (cnt * (cnt - 1.) * (cnt - 2)).sum(),</div>
<div class="line"><span class="lineno"> 5159</span>                (cnt * (cnt - 1.) * (2*cnt + 5)).sum())</div>
<div class="line"><span class="lineno"> 5160</span> </div>
<div class="line"><span class="lineno"> 5161</span>    size = x.size</div>
<div class="line"><span class="lineno"> 5162</span>    perm = np.argsort(y)  <span class="comment"># sort on y and convert y to dense ranks</span></div>
<div class="line"><span class="lineno"> 5163</span>    x, y = x[perm], y[perm]</div>
<div class="line"><span class="lineno"> 5164</span>    y = np.r_[<span class="keyword">True</span>, y[1:] != y[:-1]].cumsum(dtype=np.intp)</div>
<div class="line"><span class="lineno"> 5165</span> </div>
<div class="line"><span class="lineno"> 5166</span>    <span class="comment"># stable sort on x and convert x to dense ranks</span></div>
<div class="line"><span class="lineno"> 5167</span>    perm = np.argsort(x, kind=<span class="stringliteral">&#39;mergesort&#39;</span>)</div>
<div class="line"><span class="lineno"> 5168</span>    x, y = x[perm], y[perm]</div>
<div class="line"><span class="lineno"> 5169</span>    x = np.r_[<span class="keyword">True</span>, x[1:] != x[:-1]].cumsum(dtype=np.intp)</div>
<div class="line"><span class="lineno"> 5170</span> </div>
<div class="line"><span class="lineno"> 5171</span>    dis = _kendall_dis(x, y)  <span class="comment"># discordant pairs</span></div>
<div class="line"><span class="lineno"> 5172</span> </div>
<div class="line"><span class="lineno"> 5173</span>    obs = np.r_[<span class="keyword">True</span>, (x[1:] != x[:-1]) | (y[1:] != y[:-1]), <span class="keyword">True</span>]</div>
<div class="line"><span class="lineno"> 5174</span>    cnt = np.diff(np.nonzero(obs)[0]).astype(<span class="stringliteral">&#39;int64&#39;</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 5175</span> </div>
<div class="line"><span class="lineno"> 5176</span>    ntie = (cnt * (cnt - 1) // 2).sum()  <span class="comment"># joint ties</span></div>
<div class="line"><span class="lineno"> 5177</span>    xtie, x0, x1 = count_rank_tie(x)     <span class="comment"># ties in x, stats</span></div>
<div class="line"><span class="lineno"> 5178</span>    ytie, y0, y1 = count_rank_tie(y)     <span class="comment"># ties in y, stats</span></div>
<div class="line"><span class="lineno"> 5179</span> </div>
<div class="line"><span class="lineno"> 5180</span>    tot = (size * (size - 1)) // 2</div>
<div class="line"><span class="lineno"> 5181</span> </div>
<div class="line"><span class="lineno"> 5182</span>    <span class="keywordflow">if</span> xtie == tot <span class="keywordflow">or</span> ytie == tot:</div>
<div class="line"><span class="lineno"> 5183</span>        <span class="keywordflow">return</span> KendalltauResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 5184</span> </div>
<div class="line"><span class="lineno"> 5185</span>    <span class="comment"># Note that tot = con + dis + (xtie - ntie) + (ytie - ntie) + ntie</span></div>
<div class="line"><span class="lineno"> 5186</span>    <span class="comment">#               = con + dis + xtie + ytie - ntie</span></div>
<div class="line"><span class="lineno"> 5187</span>    con_minus_dis = tot - xtie - ytie + ntie - 2 * dis</div>
<div class="line"><span class="lineno"> 5188</span>    <span class="keywordflow">if</span> variant == <span class="stringliteral">&#39;b&#39;</span>:</div>
<div class="line"><span class="lineno"> 5189</span>        tau = con_minus_dis / np.sqrt(tot - xtie) / np.sqrt(tot - ytie)</div>
<div class="line"><span class="lineno"> 5190</span>    <span class="keywordflow">elif</span> variant == <span class="stringliteral">&#39;c&#39;</span>:</div>
<div class="line"><span class="lineno"> 5191</span>        minclasses = min(len(set(x)), len(set(y)))</div>
<div class="line"><span class="lineno"> 5192</span>        tau = 2*con_minus_dis / (size**2 * (minclasses-1)/minclasses)</div>
<div class="line"><span class="lineno"> 5193</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5194</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Unknown variant of the method chosen: {variant}. &quot;</span></div>
<div class="line"><span class="lineno"> 5195</span>                         <span class="stringliteral">&quot;variant must be &#39;b&#39; or &#39;c&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5196</span> </div>
<div class="line"><span class="lineno"> 5197</span>    <span class="comment"># Limit range to fix computational errors</span></div>
<div class="line"><span class="lineno"> 5198</span>    tau = min(1., max(-1., tau))</div>
<div class="line"><span class="lineno"> 5199</span> </div>
<div class="line"><span class="lineno"> 5200</span>    <span class="comment"># The p-value calculation is the same for all variants since the p-value</span></div>
<div class="line"><span class="lineno"> 5201</span>    <span class="comment"># depends only on con_minus_dis.</span></div>
<div class="line"><span class="lineno"> 5202</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;exact&#39;</span> <span class="keywordflow">and</span> (xtie != 0 <span class="keywordflow">or</span> ytie != 0):</div>
<div class="line"><span class="lineno"> 5203</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Ties found, exact method cannot be used.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5204</span> </div>
<div class="line"><span class="lineno"> 5205</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;auto&#39;</span>:</div>
<div class="line"><span class="lineno"> 5206</span>        <span class="keywordflow">if</span> (xtie == 0 <span class="keywordflow">and</span> ytie == 0) <span class="keywordflow">and</span> (size &lt;= 33 <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno"> 5207</span>                                          min(dis, tot-dis) &lt;= 1):</div>
<div class="line"><span class="lineno"> 5208</span>            method = <span class="stringliteral">&#39;exact&#39;</span></div>
<div class="line"><span class="lineno"> 5209</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5210</span>            method = <span class="stringliteral">&#39;asymptotic&#39;</span></div>
<div class="line"><span class="lineno"> 5211</span> </div>
<div class="line"><span class="lineno"> 5212</span>    <span class="keywordflow">if</span> xtie == 0 <span class="keywordflow">and</span> ytie == 0 <span class="keywordflow">and</span> method == <span class="stringliteral">&#39;exact&#39;</span>:</div>
<div class="line"><span class="lineno"> 5213</span>        pvalue = mstats_basic._kendall_p_exact(size, tot-dis, alternative)</div>
<div class="line"><span class="lineno"> 5214</span>    <span class="keywordflow">elif</span> method == <span class="stringliteral">&#39;asymptotic&#39;</span>:</div>
<div class="line"><span class="lineno"> 5215</span>        <span class="comment"># con_minus_dis is approx normally distributed with this variance [3]_</span></div>
<div class="line"><span class="lineno"> 5216</span>        m = size * (size - 1.)</div>
<div class="line"><span class="lineno"> 5217</span>        var = ((m * (2*size + 5) - x1 - y1) / 18 +</div>
<div class="line"><span class="lineno"> 5218</span>               (2 * xtie * ytie) / m + x0 * y0 / (9 * m * (size - 2)))</div>
<div class="line"><span class="lineno"> 5219</span>        z = con_minus_dis / np.sqrt(var)</div>
<div class="line"><span class="lineno"> 5220</span>        _, pvalue = _normtest_finish(z, alternative)</div>
<div class="line"><span class="lineno"> 5221</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5222</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Unknown method {method} specified.  Use &#39;auto&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 5223</span>                         <span class="stringliteral">&quot;&#39;exact&#39; or &#39;asymptotic&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5224</span> </div>
<div class="line"><span class="lineno"> 5225</span>    <span class="keywordflow">return</span> KendalltauResult(tau, pvalue)</div>
<div class="line"><span class="lineno"> 5226</span> </div>
<div class="line"><span class="lineno"> 5227</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a15cf6e865d5b5a8be777b158f295610d" name="a15cf6e865d5b5a8be777b158f295610d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cf6e865d5b5a8be777b158f295610d">&#9670;&#160;</a></span>kruskal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.kruskal </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Kruskal-Wallis H-test for independent samples.

The Kruskal-Wallis H-test tests the null hypothesis that the population
median of all of the groups are equal.  It is a non-parametric version of
ANOVA.  The test works on 2 or more independent samples, which may have
different sizes.  Note that rejecting the null hypothesis does not
indicate which of the groups differs.  Post hoc comparisons between
groups are required to determine which groups are different.

Parameters
----------
sample1, sample2, ... : array_like
   Two or more arrays with the sample measurements can be given as
   arguments. Samples must be one-dimensional.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
statistic : float
   The Kruskal-Wallis H statistic, corrected for ties.
pvalue : float
   The p-value for the test using the assumption that H has a chi
   square distribution. The p-value returned is the survival function of
   the chi square distribution evaluated at H.

See Also
--------
f_oneway : 1-way ANOVA.
mannwhitneyu : Mann-Whitney rank test on two samples.
friedmanchisquare : Friedman test for repeated measurements.

Notes
-----
Due to the assumption that H has a chi square distribution, the number
of samples in each group must not be too small.  A typical rule is
that each sample must have at least 5 measurements.

References
----------
.. [1] W. H. Kruskal &amp; W. W. Wallis, "Use of Ranks in
   One-Criterion Variance Analysis", Journal of the American Statistical
   Association, Vol. 47, Issue 260, pp. 583-621, 1952.
.. [2] https://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = [1, 3, 5, 7, 9]
&gt;&gt;&gt; y = [2, 4, 6, 8, 10]
&gt;&gt;&gt; stats.kruskal(x, y)
KruskalResult(statistic=0.2727272727272734, pvalue=0.6015081344405895)

&gt;&gt;&gt; x = [1, 1, 1]
&gt;&gt;&gt; y = [2, 2, 2]
&gt;&gt;&gt; z = [2, 2]
&gt;&gt;&gt; stats.kruskal(x, y, z)
KruskalResult(statistic=7.0, pvalue=0.0301973834223185)</pre> <div class="fragment"><div class="line"><span class="lineno"> 8190</span><span class="keyword">def </span>kruskal(*samples, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 8191</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the Kruskal-Wallis H-test for independent samples.</span></div>
<div class="line"><span class="lineno"> 8192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8193</span><span class="stringliteral">    The Kruskal-Wallis H-test tests the null hypothesis that the population</span></div>
<div class="line"><span class="lineno"> 8194</span><span class="stringliteral">    median of all of the groups are equal.  It is a non-parametric version of</span></div>
<div class="line"><span class="lineno"> 8195</span><span class="stringliteral">    ANOVA.  The test works on 2 or more independent samples, which may have</span></div>
<div class="line"><span class="lineno"> 8196</span><span class="stringliteral">    different sizes.  Note that rejecting the null hypothesis does not</span></div>
<div class="line"><span class="lineno"> 8197</span><span class="stringliteral">    indicate which of the groups differs.  Post hoc comparisons between</span></div>
<div class="line"><span class="lineno"> 8198</span><span class="stringliteral">    groups are required to determine which groups are different.</span></div>
<div class="line"><span class="lineno"> 8199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8200</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8201</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8202</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 8203</span><span class="stringliteral">       Two or more arrays with the sample measurements can be given as</span></div>
<div class="line"><span class="lineno"> 8204</span><span class="stringliteral">       arguments. Samples must be one-dimensional.</span></div>
<div class="line"><span class="lineno"> 8205</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 8206</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 8207</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 8208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8209</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 8210</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 8211</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 8212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8213</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8214</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8215</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 8216</span><span class="stringliteral">       The Kruskal-Wallis H statistic, corrected for ties.</span></div>
<div class="line"><span class="lineno"> 8217</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 8218</span><span class="stringliteral">       The p-value for the test using the assumption that H has a chi</span></div>
<div class="line"><span class="lineno"> 8219</span><span class="stringliteral">       square distribution. The p-value returned is the survival function of</span></div>
<div class="line"><span class="lineno"> 8220</span><span class="stringliteral">       the chi square distribution evaluated at H.</span></div>
<div class="line"><span class="lineno"> 8221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8222</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 8223</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8224</span><span class="stringliteral">    f_oneway : 1-way ANOVA.</span></div>
<div class="line"><span class="lineno"> 8225</span><span class="stringliteral">    mannwhitneyu : Mann-Whitney rank test on two samples.</span></div>
<div class="line"><span class="lineno"> 8226</span><span class="stringliteral">    friedmanchisquare : Friedman test for repeated measurements.</span></div>
<div class="line"><span class="lineno"> 8227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8228</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8229</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8230</span><span class="stringliteral">    Due to the assumption that H has a chi square distribution, the number</span></div>
<div class="line"><span class="lineno"> 8231</span><span class="stringliteral">    of samples in each group must not be too small.  A typical rule is</span></div>
<div class="line"><span class="lineno"> 8232</span><span class="stringliteral">    that each sample must have at least 5 measurements.</span></div>
<div class="line"><span class="lineno"> 8233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8234</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8235</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8236</span><span class="stringliteral">    .. [1] W. H. Kruskal &amp; W. W. Wallis, &quot;Use of Ranks in</span></div>
<div class="line"><span class="lineno"> 8237</span><span class="stringliteral">       One-Criterion Variance Analysis&quot;, Journal of the American Statistical</span></div>
<div class="line"><span class="lineno"> 8238</span><span class="stringliteral">       Association, Vol. 47, Issue 260, pp. 583-621, 1952.</span></div>
<div class="line"><span class="lineno"> 8239</span><span class="stringliteral">    .. [2] https://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance</span></div>
<div class="line"><span class="lineno"> 8240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8241</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 8242</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8243</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 8244</span><span class="stringliteral">    &gt;&gt;&gt; x = [1, 3, 5, 7, 9]</span></div>
<div class="line"><span class="lineno"> 8245</span><span class="stringliteral">    &gt;&gt;&gt; y = [2, 4, 6, 8, 10]</span></div>
<div class="line"><span class="lineno"> 8246</span><span class="stringliteral">    &gt;&gt;&gt; stats.kruskal(x, y)</span></div>
<div class="line"><span class="lineno"> 8247</span><span class="stringliteral">    KruskalResult(statistic=0.2727272727272734, pvalue=0.6015081344405895)</span></div>
<div class="line"><span class="lineno"> 8248</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8249</span><span class="stringliteral">    &gt;&gt;&gt; x = [1, 1, 1]</span></div>
<div class="line"><span class="lineno"> 8250</span><span class="stringliteral">    &gt;&gt;&gt; y = [2, 2, 2]</span></div>
<div class="line"><span class="lineno"> 8251</span><span class="stringliteral">    &gt;&gt;&gt; z = [2, 2]</span></div>
<div class="line"><span class="lineno"> 8252</span><span class="stringliteral">    &gt;&gt;&gt; stats.kruskal(x, y, z)</span></div>
<div class="line"><span class="lineno"> 8253</span><span class="stringliteral">    KruskalResult(statistic=7.0, pvalue=0.0301973834223185)</span></div>
<div class="line"><span class="lineno"> 8254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8255</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8256</span>    samples = list(map(np.asarray, samples))</div>
<div class="line"><span class="lineno"> 8257</span> </div>
<div class="line"><span class="lineno"> 8258</span>    num_groups = len(samples)</div>
<div class="line"><span class="lineno"> 8259</span>    <span class="keywordflow">if</span> num_groups &lt; 2:</div>
<div class="line"><span class="lineno"> 8260</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Need at least two groups in stats.kruskal()&quot;</span>)</div>
<div class="line"><span class="lineno"> 8261</span> </div>
<div class="line"><span class="lineno"> 8262</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples:</div>
<div class="line"><span class="lineno"> 8263</span>        <span class="keywordflow">if</span> sample.size == 0:</div>
<div class="line"><span class="lineno"> 8264</span>            <span class="keywordflow">return</span> KruskalResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 8265</span>        <span class="keywordflow">elif</span> sample.ndim != 1:</div>
<div class="line"><span class="lineno"> 8266</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Samples must be one-dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno"> 8267</span> </div>
<div class="line"><span class="lineno"> 8268</span>    n = np.asarray(list(map(len, samples)))</div>
<div class="line"><span class="lineno"> 8269</span> </div>
<div class="line"><span class="lineno"> 8270</span>    <span class="keywordflow">if</span> nan_policy <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;propagate&#39;</span>, <span class="stringliteral">&#39;raise&#39;</span>, <span class="stringliteral">&#39;omit&#39;</span>):</div>
<div class="line"><span class="lineno"> 8271</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;nan_policy must be &#39;propagate&#39;, &#39;raise&#39; or &#39;omit&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 8272</span> </div>
<div class="line"><span class="lineno"> 8273</span>    contains_nan = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 8274</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples:</div>
<div class="line"><span class="lineno"> 8275</span>        cn = _contains_nan(sample, nan_policy)</div>
<div class="line"><span class="lineno"> 8276</span>        <span class="keywordflow">if</span> cn[0]:</div>
<div class="line"><span class="lineno"> 8277</span>            contains_nan = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 8278</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 8279</span> </div>
<div class="line"><span class="lineno"> 8280</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 8281</span>        <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples:</div>
<div class="line"><span class="lineno"> 8282</span>            sample = ma.masked_invalid(sample)</div>
<div class="line"><span class="lineno"> 8283</span>        <span class="keywordflow">return</span> mstats_basic.kruskal(*samples)</div>
<div class="line"><span class="lineno"> 8284</span> </div>
<div class="line"><span class="lineno"> 8285</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;propagate&#39;</span>:</div>
<div class="line"><span class="lineno"> 8286</span>        <span class="keywordflow">return</span> KruskalResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 8287</span> </div>
<div class="line"><span class="lineno"> 8288</span>    alldata = np.concatenate(samples)</div>
<div class="line"><span class="lineno"> 8289</span>    ranked = rankdata(alldata)</div>
<div class="line"><span class="lineno"> 8290</span>    ties = tiecorrect(ranked)</div>
<div class="line"><span class="lineno"> 8291</span>    <span class="keywordflow">if</span> ties == 0:</div>
<div class="line"><span class="lineno"> 8292</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;All numbers are identical in kruskal&#39;</span>)</div>
<div class="line"><span class="lineno"> 8293</span> </div>
<div class="line"><span class="lineno"> 8294</span>    <span class="comment"># Compute sum^2/n for each group and sum</span></div>
<div class="line"><span class="lineno"> 8295</span>    j = np.insert(np.cumsum(n), 0, 0)</div>
<div class="line"><span class="lineno"> 8296</span>    ssbn = 0</div>
<div class="line"><span class="lineno"> 8297</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(num_groups):</div>
<div class="line"><span class="lineno"> 8298</span>        ssbn += _square_of_sums(ranked[j[i]:j[i+1]]) / n[i]</div>
<div class="line"><span class="lineno"> 8299</span> </div>
<div class="line"><span class="lineno"> 8300</span>    totaln = np.sum(n, dtype=float)</div>
<div class="line"><span class="lineno"> 8301</span>    h = 12.0 / (totaln * (totaln + 1)) * ssbn - 3 * (totaln + 1)</div>
<div class="line"><span class="lineno"> 8302</span>    df = num_groups - 1</div>
<div class="line"><span class="lineno"> 8303</span>    h /= ties</div>
<div class="line"><span class="lineno"> 8304</span> </div>
<div class="line"><span class="lineno"> 8305</span>    <span class="keywordflow">return</span> KruskalResult(h, distributions.chi2.sf(h, df))</div>
<div class="line"><span class="lineno"> 8306</span> </div>
<div class="line"><span class="lineno"> 8307</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afd9c2533435c2d2b47aa429ee290ae43" name="afd9c2533435c2d2b47aa429ee290ae43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9c2533435c2d2b47aa429ee290ae43">&#9670;&#160;</a></span>ks_1samp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ks_1samp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the one-sample Kolmogorov-Smirnov test for goodness of fit.

This test compares the underlying distribution F(x) of a sample
against a given continuous distribution G(x). See Notes for a description
of the available null and alternative hypotheses.

Parameters
----------
x : array_like
    a 1-D array of observations of iid random variables.
cdf : callable
    callable used to calculate the cdf.
args : tuple, sequence, optional
    Distribution parameters, used with `cdf`.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes below.
method : {'auto', 'exact', 'approx', 'asymp'}, optional
    Defines the distribution used for calculating the p-value.
    The following options are available (default is 'auto'):

      * 'auto' : selects one of the other options.
      * 'exact' : uses the exact distribution of test statistic.
      * 'approx' : approximates the two-sided probability with twice
        the one-sided probability
      * 'asymp': uses asymptotic distribution of test statistic

Returns
-------
statistic : float
    KS test statistic, either D, D+ or D- (depending on the value
    of 'alternative')
pvalue : float
    One-tailed or two-tailed p-value.

See Also
--------
ks_2samp, kstest

Notes
-----
There are three options for the null and corresponding alternative
hypothesis that can be selected using the `alternative` parameter.

- `two-sided`: The null hypothesis is that the two distributions are
  identical, F(x)=G(x) for all x; the alternative is that they are not
  identical.

- `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the
  alternative is that F(x) &lt; G(x) for at least one x.

- `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the
  alternative is that F(x) &gt; G(x) for at least one x.

Note that the alternative hypotheses describe the *CDFs* of the
underlying distributions, not the observed values. For example,
suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in
x1 tend to be less than those in x2.

Examples
--------
Suppose we wish to test the null hypothesis that a sample is distributed
according to the standard normal.
We choose a confidence level of 95%; that is, we will reject the null
hypothesis in favor of the alternative if the p-value is less than 0.05.

When testing uniformly distributed data, we would expect the
null hypothesis to be rejected.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; stats.ks_1samp(stats.uniform.rvs(size=100, random_state=rng),
...                stats.norm.cdf)
KstestResult(statistic=0.5001899973268688, pvalue=1.1616392184763533e-23)

Indeed, the p-value is lower than our threshold of 0.05, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the data
are *not* distributed according to the standard normal.

When testing random variates from the standard normal distribution, we
expect the data to be consistent with the null hypothesis most of the time.

&gt;&gt;&gt; x = stats.norm.rvs(size=100, random_state=rng)
&gt;&gt;&gt; stats.ks_1samp(x, stats.norm.cdf)
KstestResult(statistic=0.05345882212970396, pvalue=0.9227159037744717)

As expected, the p-value of 0.92 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.

Suppose, however, that the random variates are distributed according to
a normal distribution that is shifted toward greater values. In this case,
the cumulative density function (CDF) of the underlying distribution tends
to be *less* than the CDF of the standard normal. Therefore, we would
expect the null hypothesis to be rejected with ``alternative='less'``:

&gt;&gt;&gt; x = stats.norm.rvs(size=100, loc=0.5, random_state=rng)
&gt;&gt;&gt; stats.ks_1samp(x, stats.norm.cdf, alternative='less')
KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743)

and indeed, with p-value smaller than our threshold, we reject the null
hypothesis in favor of the alternative.</pre> <div class="fragment"><div class="line"><span class="lineno"> 7352</span><span class="keyword">def </span>ks_1samp(x, cdf, args=(), alternative=<span class="stringliteral">&#39;two-sided&#39;</span>, method=<span class="stringliteral">&#39;auto&#39;</span>):</div>
<div class="line"><span class="lineno"> 7353</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7354</span><span class="stringliteral">    Performs the one-sample Kolmogorov-Smirnov test for goodness of fit.</span></div>
<div class="line"><span class="lineno"> 7355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7356</span><span class="stringliteral">    This test compares the underlying distribution F(x) of a sample</span></div>
<div class="line"><span class="lineno"> 7357</span><span class="stringliteral">    against a given continuous distribution G(x). See Notes for a description</span></div>
<div class="line"><span class="lineno"> 7358</span><span class="stringliteral">    of the available null and alternative hypotheses.</span></div>
<div class="line"><span class="lineno"> 7359</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7360</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7361</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7362</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 7363</span><span class="stringliteral">        a 1-D array of observations of iid random variables.</span></div>
<div class="line"><span class="lineno"> 7364</span><span class="stringliteral">    cdf : callable</span></div>
<div class="line"><span class="lineno"> 7365</span><span class="stringliteral">        callable used to calculate the cdf.</span></div>
<div class="line"><span class="lineno"> 7366</span><span class="stringliteral">    args : tuple, sequence, optional</span></div>
<div class="line"><span class="lineno"> 7367</span><span class="stringliteral">        Distribution parameters, used with `cdf`.</span></div>
<div class="line"><span class="lineno"> 7368</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 7369</span><span class="stringliteral">        Defines the null and alternative hypotheses. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 7370</span><span class="stringliteral">        Please see explanations in the Notes below.</span></div>
<div class="line"><span class="lineno"> 7371</span><span class="stringliteral">    method : {&#39;auto&#39;, &#39;exact&#39;, &#39;approx&#39;, &#39;asymp&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 7372</span><span class="stringliteral">        Defines the distribution used for calculating the p-value.</span></div>
<div class="line"><span class="lineno"> 7373</span><span class="stringliteral">        The following options are available (default is &#39;auto&#39;):</span></div>
<div class="line"><span class="lineno"> 7374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7375</span><span class="stringliteral">          * &#39;auto&#39; : selects one of the other options.</span></div>
<div class="line"><span class="lineno"> 7376</span><span class="stringliteral">          * &#39;exact&#39; : uses the exact distribution of test statistic.</span></div>
<div class="line"><span class="lineno"> 7377</span><span class="stringliteral">          * &#39;approx&#39; : approximates the two-sided probability with twice</span></div>
<div class="line"><span class="lineno"> 7378</span><span class="stringliteral">            the one-sided probability</span></div>
<div class="line"><span class="lineno"> 7379</span><span class="stringliteral">          * &#39;asymp&#39;: uses asymptotic distribution of test statistic</span></div>
<div class="line"><span class="lineno"> 7380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7381</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7382</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7383</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 7384</span><span class="stringliteral">        KS test statistic, either D, D+ or D- (depending on the value</span></div>
<div class="line"><span class="lineno"> 7385</span><span class="stringliteral">        of &#39;alternative&#39;)</span></div>
<div class="line"><span class="lineno"> 7386</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 7387</span><span class="stringliteral">        One-tailed or two-tailed p-value.</span></div>
<div class="line"><span class="lineno"> 7388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7389</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 7390</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7391</span><span class="stringliteral">    ks_2samp, kstest</span></div>
<div class="line"><span class="lineno"> 7392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7393</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 7394</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 7395</span><span class="stringliteral">    There are three options for the null and corresponding alternative</span></div>
<div class="line"><span class="lineno"> 7396</span><span class="stringliteral">    hypothesis that can be selected using the `alternative` parameter.</span></div>
<div class="line"><span class="lineno"> 7397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7398</span><span class="stringliteral">    - `two-sided`: The null hypothesis is that the two distributions are</span></div>
<div class="line"><span class="lineno"> 7399</span><span class="stringliteral">      identical, F(x)=G(x) for all x; the alternative is that they are not</span></div>
<div class="line"><span class="lineno"> 7400</span><span class="stringliteral">      identical.</span></div>
<div class="line"><span class="lineno"> 7401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7402</span><span class="stringliteral">    - `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the</span></div>
<div class="line"><span class="lineno"> 7403</span><span class="stringliteral">      alternative is that F(x) &lt; G(x) for at least one x.</span></div>
<div class="line"><span class="lineno"> 7404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7405</span><span class="stringliteral">    - `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the</span></div>
<div class="line"><span class="lineno"> 7406</span><span class="stringliteral">      alternative is that F(x) &gt; G(x) for at least one x.</span></div>
<div class="line"><span class="lineno"> 7407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7408</span><span class="stringliteral">    Note that the alternative hypotheses describe the *CDFs* of the</span></div>
<div class="line"><span class="lineno"> 7409</span><span class="stringliteral">    underlying distributions, not the observed values. For example,</span></div>
<div class="line"><span class="lineno"> 7410</span><span class="stringliteral">    suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in</span></div>
<div class="line"><span class="lineno"> 7411</span><span class="stringliteral">    x1 tend to be less than those in x2.</span></div>
<div class="line"><span class="lineno"> 7412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7413</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 7414</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7415</span><span class="stringliteral">    Suppose we wish to test the null hypothesis that a sample is distributed</span></div>
<div class="line"><span class="lineno"> 7416</span><span class="stringliteral">    according to the standard normal.</span></div>
<div class="line"><span class="lineno"> 7417</span><span class="stringliteral">    We choose a confidence level of 95%; that is, we will reject the null</span></div>
<div class="line"><span class="lineno"> 7418</span><span class="stringliteral">    hypothesis in favor of the alternative if the p-value is less than 0.05.</span></div>
<div class="line"><span class="lineno"> 7419</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7420</span><span class="stringliteral">    When testing uniformly distributed data, we would expect the</span></div>
<div class="line"><span class="lineno"> 7421</span><span class="stringliteral">    null hypothesis to be rejected.</span></div>
<div class="line"><span class="lineno"> 7422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7423</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 7424</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 7425</span><span class="stringliteral">    &gt;&gt;&gt; stats.ks_1samp(stats.uniform.rvs(size=100, random_state=rng),</span></div>
<div class="line"><span class="lineno"> 7426</span><span class="stringliteral">    ...                stats.norm.cdf)</span></div>
<div class="line"><span class="lineno"> 7427</span><span class="stringliteral">    KstestResult(statistic=0.5001899973268688, pvalue=1.1616392184763533e-23)</span></div>
<div class="line"><span class="lineno"> 7428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7429</span><span class="stringliteral">    Indeed, the p-value is lower than our threshold of 0.05, so we reject the</span></div>
<div class="line"><span class="lineno"> 7430</span><span class="stringliteral">    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the data</span></div>
<div class="line"><span class="lineno"> 7431</span><span class="stringliteral">    are *not* distributed according to the standard normal.</span></div>
<div class="line"><span class="lineno"> 7432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7433</span><span class="stringliteral">    When testing random variates from the standard normal distribution, we</span></div>
<div class="line"><span class="lineno"> 7434</span><span class="stringliteral">    expect the data to be consistent with the null hypothesis most of the time.</span></div>
<div class="line"><span class="lineno"> 7435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7436</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 7437</span><span class="stringliteral">    &gt;&gt;&gt; stats.ks_1samp(x, stats.norm.cdf)</span></div>
<div class="line"><span class="lineno"> 7438</span><span class="stringliteral">    KstestResult(statistic=0.05345882212970396, pvalue=0.9227159037744717)</span></div>
<div class="line"><span class="lineno"> 7439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7440</span><span class="stringliteral">    As expected, the p-value of 0.92 is not below our threshold of 0.05, so</span></div>
<div class="line"><span class="lineno"> 7441</span><span class="stringliteral">    we cannot reject the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 7442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7443</span><span class="stringliteral">    Suppose, however, that the random variates are distributed according to</span></div>
<div class="line"><span class="lineno"> 7444</span><span class="stringliteral">    a normal distribution that is shifted toward greater values. In this case,</span></div>
<div class="line"><span class="lineno"> 7445</span><span class="stringliteral">    the cumulative density function (CDF) of the underlying distribution tends</span></div>
<div class="line"><span class="lineno"> 7446</span><span class="stringliteral">    to be *less* than the CDF of the standard normal. Therefore, we would</span></div>
<div class="line"><span class="lineno"> 7447</span><span class="stringliteral">    expect the null hypothesis to be rejected with ``alternative=&#39;less&#39;``:</span></div>
<div class="line"><span class="lineno"> 7448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7449</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(size=100, loc=0.5, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 7450</span><span class="stringliteral">    &gt;&gt;&gt; stats.ks_1samp(x, stats.norm.cdf, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 7451</span><span class="stringliteral">    KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743)</span></div>
<div class="line"><span class="lineno"> 7452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7453</span><span class="stringliteral">    and indeed, with p-value smaller than our threshold, we reject the null</span></div>
<div class="line"><span class="lineno"> 7454</span><span class="stringliteral">    hypothesis in favor of the alternative.</span></div>
<div class="line"><span class="lineno"> 7455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7456</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7457</span>    mode = method</div>
<div class="line"><span class="lineno"> 7458</span> </div>
<div class="line"><span class="lineno"> 7459</span>    alternative = {<span class="stringliteral">&#39;t&#39;</span>: <span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;g&#39;</span>: <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;l&#39;</span>: <span class="stringliteral">&#39;less&#39;</span>}.get(</div>
<div class="line"><span class="lineno"> 7460</span>        alternative.lower()[0], alternative)</div>
<div class="line"><span class="lineno"> 7461</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>]:</div>
<div class="line"><span class="lineno"> 7462</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unexpected alternative %s&quot;</span> % alternative)</div>
<div class="line"><span class="lineno"> 7463</span>    <span class="keywordflow">if</span> np.ma.is_masked(x):</div>
<div class="line"><span class="lineno"> 7464</span>        x = x.compressed()</div>
<div class="line"><span class="lineno"> 7465</span> </div>
<div class="line"><span class="lineno"> 7466</span>    N = len(x)</div>
<div class="line"><span class="lineno"> 7467</span>    x = np.sort(x)</div>
<div class="line"><span class="lineno"> 7468</span>    cdfvals = cdf(x, *args)</div>
<div class="line"><span class="lineno"> 7469</span> </div>
<div class="line"><span class="lineno"> 7470</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;greater&#39;</span>:</div>
<div class="line"><span class="lineno"> 7471</span>        Dplus = _compute_dplus(cdfvals)</div>
<div class="line"><span class="lineno"> 7472</span>        <span class="keywordflow">return</span> KstestResult(Dplus, distributions.ksone.sf(Dplus, N))</div>
<div class="line"><span class="lineno"> 7473</span> </div>
<div class="line"><span class="lineno"> 7474</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;less&#39;</span>:</div>
<div class="line"><span class="lineno"> 7475</span>        Dminus = _compute_dminus(cdfvals)</div>
<div class="line"><span class="lineno"> 7476</span>        <span class="keywordflow">return</span> KstestResult(Dminus, distributions.ksone.sf(Dminus, N))</div>
<div class="line"><span class="lineno"> 7477</span> </div>
<div class="line"><span class="lineno"> 7478</span>    <span class="comment"># alternative == &#39;two-sided&#39;:</span></div>
<div class="line"><span class="lineno"> 7479</span>    Dplus = _compute_dplus(cdfvals)</div>
<div class="line"><span class="lineno"> 7480</span>    Dminus = _compute_dminus(cdfvals)</div>
<div class="line"><span class="lineno"> 7481</span>    D = np.max([Dplus, Dminus])</div>
<div class="line"><span class="lineno"> 7482</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;auto&#39;</span>:  <span class="comment"># Always select exact</span></div>
<div class="line"><span class="lineno"> 7483</span>        mode = <span class="stringliteral">&#39;exact&#39;</span></div>
<div class="line"><span class="lineno"> 7484</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;exact&#39;</span>:</div>
<div class="line"><span class="lineno"> 7485</span>        prob = distributions.kstwo.sf(D, N)</div>
<div class="line"><span class="lineno"> 7486</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&#39;asymp&#39;</span>:</div>
<div class="line"><span class="lineno"> 7487</span>        prob = distributions.kstwobign.sf(D * np.sqrt(N))</div>
<div class="line"><span class="lineno"> 7488</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7489</span>        <span class="comment"># mode == &#39;approx&#39;</span></div>
<div class="line"><span class="lineno"> 7490</span>        prob = 2 * distributions.ksone.sf(D, N)</div>
<div class="line"><span class="lineno"> 7491</span>    prob = np.clip(prob, 0, 1)</div>
<div class="line"><span class="lineno"> 7492</span>    <span class="keywordflow">return</span> KstestResult(D, prob)</div>
<div class="line"><span class="lineno"> 7493</span> </div>
<div class="line"><span class="lineno"> 7494</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a171a6b4426dbc47cdb093d05f3f1b969" name="a171a6b4426dbc47cdb093d05f3f1b969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171a6b4426dbc47cdb093d05f3f1b969">&#9670;&#160;</a></span>ks_2samp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ks_2samp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.

This test compares the underlying continuous distributions F(x) and G(x)
of two independent samples.  See Notes for a description
of the available null and alternative hypotheses.

Parameters
----------
data1, data2 : array_like, 1-Dimensional
    Two arrays of sample observations assumed to be drawn from a continuous
    distribution, sample sizes can be different.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes below.
method : {'auto', 'exact', 'asymp'}, optional
    Defines the method used for calculating the p-value.
    The following options are available (default is 'auto'):

      * 'auto' : use 'exact' for small size arrays, 'asymp' for large
      * 'exact' : use exact distribution of test statistic
      * 'asymp' : use asymptotic distribution of test statistic

Returns
-------
statistic : float
    KS statistic.
pvalue : float
    One-tailed or two-tailed p-value.

See Also
--------
kstest, ks_1samp, epps_singleton_2samp, anderson_ksamp

Notes
-----
There are three options for the null and corresponding alternative
hypothesis that can be selected using the `alternative` parameter.

- `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the
  alternative is that F(x) &lt; G(x) for at least one x. The statistic
  is the magnitude of the minimum (most negative) difference between the
  empirical distribution functions of the samples.

- `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the
  alternative is that F(x) &gt; G(x) for at least one x. The statistic
  is the maximum (most positive) difference between the empirical
  distribution functions of the samples.

- `two-sided`: The null hypothesis is that the two distributions are
  identical, F(x)=G(x) for all x; the alternative is that they are not
  identical. The statistic is the maximum absolute difference between the
  empirical distribution functions of the samples.

Note that the alternative hypotheses describe the *CDFs* of the
underlying distributions, not the observed values of the data. For example,
suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in
x1 tend to be less than those in x2.

If the KS statistic is large, then the p-value will be small, and this may
be taken as evidence against the null hypothesis in favor of the
alternative.

If ``method='exact'``, `ks_2samp` attempts to compute an exact p-value,
that is, the probability under the null hypothesis of obtaining a test
statistic value as extreme as the value computed from the data.
If ``method='asymp'``, the asymptotic Kolmogorov-Smirnov distribution is
used to compute an approximate p-value.
If ``method='auto'``, an exact p-value computation is attempted if both
sample sizes are less than 10000; otherwise, the asymptotic method is used.
In any case, if an exact p-value calculation is attempted and fails, a
warning will be emitted, and the asymptotic p-value will be returned.

The 'two-sided' 'exact' computation computes the complementary probability
and then subtracts from 1.  As such, the minimum probability it can return
is about 1e-16.  While the algorithm itself is exact, numerical
errors may accumulate for large sample sizes.   It is most suited to
situations in which one of the sample sizes is only a few thousand.

We generally follow Hodges' treatment of Drion/Gnedenko/Korolyuk [1]_.

References
----------
.. [1] Hodges, J.L. Jr.,  "The Significance Probability of the Smirnov
       Two-Sample Test," Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.

Examples
--------
Suppose we wish to test the null hypothesis that two samples were drawn
from the same distribution.
We choose a confidence level of 95%; that is, we will reject the null
hypothesis in favor of the alternative if the p-value is less than 0.05.

If the first sample were drawn from a uniform distribution and the second
were drawn from the standard normal, we would expect the null hypothesis
to be rejected.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; sample1 = stats.uniform.rvs(size=100, random_state=rng)
&gt;&gt;&gt; sample2 = stats.norm.rvs(size=110, random_state=rng)
&gt;&gt;&gt; stats.ks_2samp(sample1, sample2)
KstestResult(statistic=0.5454545454545454, pvalue=7.37417839555191e-15)

Indeed, the p-value is lower than our threshold of 0.05, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the data
were *not* drawn from the same distribution.

When both samples are drawn from the same distribution, we expect the data
to be consistent with the null hypothesis most of the time.

&gt;&gt;&gt; sample1 = stats.norm.rvs(size=105, random_state=rng)
&gt;&gt;&gt; sample2 = stats.norm.rvs(size=95, random_state=rng)
&gt;&gt;&gt; stats.ks_2samp(sample1, sample2)
KstestResult(statistic=0.10927318295739348, pvalue=0.5438289009927495)

As expected, the p-value of 0.54 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.

Suppose, however, that the first sample were drawn from
a normal distribution shifted toward greater values. In this case,
the cumulative density function (CDF) of the underlying distribution tends
to be *less* than the CDF underlying the second sample. Therefore, we would
expect the null hypothesis to be rejected with ``alternative='less'``:

&gt;&gt;&gt; sample1 = stats.norm.rvs(size=105, loc=0.5, random_state=rng)
&gt;&gt;&gt; stats.ks_2samp(sample1, sample2, alternative='less')
KstestResult(statistic=0.4055137844611529, pvalue=3.5474563068855554e-08)

and indeed, with p-value smaller than our threshold, we reject the null
hypothesis in favor of the alternative.</pre> <div class="fragment"><div class="line"><span class="lineno"> 7672</span><span class="keyword">def </span>ks_2samp(data1, data2, alternative=&#39;two-sided&#39;, method=&#39;auto&#39;):</div>
<div class="line"><span class="lineno"> 7673</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7674</span><span class="stringliteral">    Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.</span></div>
<div class="line"><span class="lineno"> 7675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7676</span><span class="stringliteral">    This test compares the underlying continuous distributions F(x) and G(x)</span></div>
<div class="line"><span class="lineno"> 7677</span><span class="stringliteral">    of two independent samples.  See Notes for a description</span></div>
<div class="line"><span class="lineno"> 7678</span><span class="stringliteral">    of the available null and alternative hypotheses.</span></div>
<div class="line"><span class="lineno"> 7679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7680</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7681</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7682</span><span class="stringliteral">    data1, data2 : array_like, 1-Dimensional</span></div>
<div class="line"><span class="lineno"> 7683</span><span class="stringliteral">        Two arrays of sample observations assumed to be drawn from a continuous</span></div>
<div class="line"><span class="lineno"> 7684</span><span class="stringliteral">        distribution, sample sizes can be different.</span></div>
<div class="line"><span class="lineno"> 7685</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 7686</span><span class="stringliteral">        Defines the null and alternative hypotheses. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 7687</span><span class="stringliteral">        Please see explanations in the Notes below.</span></div>
<div class="line"><span class="lineno"> 7688</span><span class="stringliteral">    method : {&#39;auto&#39;, &#39;exact&#39;, &#39;asymp&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 7689</span><span class="stringliteral">        Defines the method used for calculating the p-value.</span></div>
<div class="line"><span class="lineno"> 7690</span><span class="stringliteral">        The following options are available (default is &#39;auto&#39;):</span></div>
<div class="line"><span class="lineno"> 7691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7692</span><span class="stringliteral">          * &#39;auto&#39; : use &#39;exact&#39; for small size arrays, &#39;asymp&#39; for large</span></div>
<div class="line"><span class="lineno"> 7693</span><span class="stringliteral">          * &#39;exact&#39; : use exact distribution of test statistic</span></div>
<div class="line"><span class="lineno"> 7694</span><span class="stringliteral">          * &#39;asymp&#39; : use asymptotic distribution of test statistic</span></div>
<div class="line"><span class="lineno"> 7695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7696</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7697</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7698</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 7699</span><span class="stringliteral">        KS statistic.</span></div>
<div class="line"><span class="lineno"> 7700</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 7701</span><span class="stringliteral">        One-tailed or two-tailed p-value.</span></div>
<div class="line"><span class="lineno"> 7702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7703</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 7704</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7705</span><span class="stringliteral">    kstest, ks_1samp, epps_singleton_2samp, anderson_ksamp</span></div>
<div class="line"><span class="lineno"> 7706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7707</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 7708</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 7709</span><span class="stringliteral">    There are three options for the null and corresponding alternative</span></div>
<div class="line"><span class="lineno"> 7710</span><span class="stringliteral">    hypothesis that can be selected using the `alternative` parameter.</span></div>
<div class="line"><span class="lineno"> 7711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7712</span><span class="stringliteral">    - `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the</span></div>
<div class="line"><span class="lineno"> 7713</span><span class="stringliteral">      alternative is that F(x) &lt; G(x) for at least one x. The statistic</span></div>
<div class="line"><span class="lineno"> 7714</span><span class="stringliteral">      is the magnitude of the minimum (most negative) difference between the</span></div>
<div class="line"><span class="lineno"> 7715</span><span class="stringliteral">      empirical distribution functions of the samples.</span></div>
<div class="line"><span class="lineno"> 7716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7717</span><span class="stringliteral">    - `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the</span></div>
<div class="line"><span class="lineno"> 7718</span><span class="stringliteral">      alternative is that F(x) &gt; G(x) for at least one x. The statistic</span></div>
<div class="line"><span class="lineno"> 7719</span><span class="stringliteral">      is the maximum (most positive) difference between the empirical</span></div>
<div class="line"><span class="lineno"> 7720</span><span class="stringliteral">      distribution functions of the samples.</span></div>
<div class="line"><span class="lineno"> 7721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7722</span><span class="stringliteral">    - `two-sided`: The null hypothesis is that the two distributions are</span></div>
<div class="line"><span class="lineno"> 7723</span><span class="stringliteral">      identical, F(x)=G(x) for all x; the alternative is that they are not</span></div>
<div class="line"><span class="lineno"> 7724</span><span class="stringliteral">      identical. The statistic is the maximum absolute difference between the</span></div>
<div class="line"><span class="lineno"> 7725</span><span class="stringliteral">      empirical distribution functions of the samples.</span></div>
<div class="line"><span class="lineno"> 7726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7727</span><span class="stringliteral">    Note that the alternative hypotheses describe the *CDFs* of the</span></div>
<div class="line"><span class="lineno"> 7728</span><span class="stringliteral">    underlying distributions, not the observed values of the data. For example,</span></div>
<div class="line"><span class="lineno"> 7729</span><span class="stringliteral">    suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in</span></div>
<div class="line"><span class="lineno"> 7730</span><span class="stringliteral">    x1 tend to be less than those in x2.</span></div>
<div class="line"><span class="lineno"> 7731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7732</span><span class="stringliteral">    If the KS statistic is large, then the p-value will be small, and this may</span></div>
<div class="line"><span class="lineno"> 7733</span><span class="stringliteral">    be taken as evidence against the null hypothesis in favor of the</span></div>
<div class="line"><span class="lineno"> 7734</span><span class="stringliteral">    alternative.</span></div>
<div class="line"><span class="lineno"> 7735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7736</span><span class="stringliteral">    If ``method=&#39;exact&#39;``, `ks_2samp` attempts to compute an exact p-value,</span></div>
<div class="line"><span class="lineno"> 7737</span><span class="stringliteral">    that is, the probability under the null hypothesis of obtaining a test</span></div>
<div class="line"><span class="lineno"> 7738</span><span class="stringliteral">    statistic value as extreme as the value computed from the data.</span></div>
<div class="line"><span class="lineno"> 7739</span><span class="stringliteral">    If ``method=&#39;asymp&#39;``, the asymptotic Kolmogorov-Smirnov distribution is</span></div>
<div class="line"><span class="lineno"> 7740</span><span class="stringliteral">    used to compute an approximate p-value.</span></div>
<div class="line"><span class="lineno"> 7741</span><span class="stringliteral">    If ``method=&#39;auto&#39;``, an exact p-value computation is attempted if both</span></div>
<div class="line"><span class="lineno"> 7742</span><span class="stringliteral">    sample sizes are less than 10000; otherwise, the asymptotic method is used.</span></div>
<div class="line"><span class="lineno"> 7743</span><span class="stringliteral">    In any case, if an exact p-value calculation is attempted and fails, a</span></div>
<div class="line"><span class="lineno"> 7744</span><span class="stringliteral">    warning will be emitted, and the asymptotic p-value will be returned.</span></div>
<div class="line"><span class="lineno"> 7745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7746</span><span class="stringliteral">    The &#39;two-sided&#39; &#39;exact&#39; computation computes the complementary probability</span></div>
<div class="line"><span class="lineno"> 7747</span><span class="stringliteral">    and then subtracts from 1.  As such, the minimum probability it can return</span></div>
<div class="line"><span class="lineno"> 7748</span><span class="stringliteral">    is about 1e-16.  While the algorithm itself is exact, numerical</span></div>
<div class="line"><span class="lineno"> 7749</span><span class="stringliteral">    errors may accumulate for large sample sizes.   It is most suited to</span></div>
<div class="line"><span class="lineno"> 7750</span><span class="stringliteral">    situations in which one of the sample sizes is only a few thousand.</span></div>
<div class="line"><span class="lineno"> 7751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7752</span><span class="stringliteral">    We generally follow Hodges&#39; treatment of Drion/Gnedenko/Korolyuk [1]_.</span></div>
<div class="line"><span class="lineno"> 7753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7754</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 7755</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7756</span><span class="stringliteral">    .. [1] Hodges, J.L. Jr.,  &quot;The Significance Probability of the Smirnov</span></div>
<div class="line"><span class="lineno"> 7757</span><span class="stringliteral">           Two-Sample Test,&quot; Arkiv fiur Matematik, 3, No. 43 (1958), 469-86.</span></div>
<div class="line"><span class="lineno"> 7758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7759</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 7760</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7761</span><span class="stringliteral">    Suppose we wish to test the null hypothesis that two samples were drawn</span></div>
<div class="line"><span class="lineno"> 7762</span><span class="stringliteral">    from the same distribution.</span></div>
<div class="line"><span class="lineno"> 7763</span><span class="stringliteral">    We choose a confidence level of 95%; that is, we will reject the null</span></div>
<div class="line"><span class="lineno"> 7764</span><span class="stringliteral">    hypothesis in favor of the alternative if the p-value is less than 0.05.</span></div>
<div class="line"><span class="lineno"> 7765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7766</span><span class="stringliteral">    If the first sample were drawn from a uniform distribution and the second</span></div>
<div class="line"><span class="lineno"> 7767</span><span class="stringliteral">    were drawn from the standard normal, we would expect the null hypothesis</span></div>
<div class="line"><span class="lineno"> 7768</span><span class="stringliteral">    to be rejected.</span></div>
<div class="line"><span class="lineno"> 7769</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7770</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 7771</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 7772</span><span class="stringliteral">    &gt;&gt;&gt; sample1 = stats.uniform.rvs(size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 7773</span><span class="stringliteral">    &gt;&gt;&gt; sample2 = stats.norm.rvs(size=110, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 7774</span><span class="stringliteral">    &gt;&gt;&gt; stats.ks_2samp(sample1, sample2)</span></div>
<div class="line"><span class="lineno"> 7775</span><span class="stringliteral">    KstestResult(statistic=0.5454545454545454, pvalue=7.37417839555191e-15)</span></div>
<div class="line"><span class="lineno"> 7776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7777</span><span class="stringliteral">    Indeed, the p-value is lower than our threshold of 0.05, so we reject the</span></div>
<div class="line"><span class="lineno"> 7778</span><span class="stringliteral">    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the data</span></div>
<div class="line"><span class="lineno"> 7779</span><span class="stringliteral">    were *not* drawn from the same distribution.</span></div>
<div class="line"><span class="lineno"> 7780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7781</span><span class="stringliteral">    When both samples are drawn from the same distribution, we expect the data</span></div>
<div class="line"><span class="lineno"> 7782</span><span class="stringliteral">    to be consistent with the null hypothesis most of the time.</span></div>
<div class="line"><span class="lineno"> 7783</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7784</span><span class="stringliteral">    &gt;&gt;&gt; sample1 = stats.norm.rvs(size=105, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 7785</span><span class="stringliteral">    &gt;&gt;&gt; sample2 = stats.norm.rvs(size=95, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 7786</span><span class="stringliteral">    &gt;&gt;&gt; stats.ks_2samp(sample1, sample2)</span></div>
<div class="line"><span class="lineno"> 7787</span><span class="stringliteral">    KstestResult(statistic=0.10927318295739348, pvalue=0.5438289009927495)</span></div>
<div class="line"><span class="lineno"> 7788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7789</span><span class="stringliteral">    As expected, the p-value of 0.54 is not below our threshold of 0.05, so</span></div>
<div class="line"><span class="lineno"> 7790</span><span class="stringliteral">    we cannot reject the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 7791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7792</span><span class="stringliteral">    Suppose, however, that the first sample were drawn from</span></div>
<div class="line"><span class="lineno"> 7793</span><span class="stringliteral">    a normal distribution shifted toward greater values. In this case,</span></div>
<div class="line"><span class="lineno"> 7794</span><span class="stringliteral">    the cumulative density function (CDF) of the underlying distribution tends</span></div>
<div class="line"><span class="lineno"> 7795</span><span class="stringliteral">    to be *less* than the CDF underlying the second sample. Therefore, we would</span></div>
<div class="line"><span class="lineno"> 7796</span><span class="stringliteral">    expect the null hypothesis to be rejected with ``alternative=&#39;less&#39;``:</span></div>
<div class="line"><span class="lineno"> 7797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7798</span><span class="stringliteral">    &gt;&gt;&gt; sample1 = stats.norm.rvs(size=105, loc=0.5, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 7799</span><span class="stringliteral">    &gt;&gt;&gt; stats.ks_2samp(sample1, sample2, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 7800</span><span class="stringliteral">    KstestResult(statistic=0.4055137844611529, pvalue=3.5474563068855554e-08)</span></div>
<div class="line"><span class="lineno"> 7801</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7802</span><span class="stringliteral">    and indeed, with p-value smaller than our threshold, we reject the null</span></div>
<div class="line"><span class="lineno"> 7803</span><span class="stringliteral">    hypothesis in favor of the alternative.</span></div>
<div class="line"><span class="lineno"> 7804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7805</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7806</span>    mode = method</div>
<div class="line"><span class="lineno"> 7807</span> </div>
<div class="line"><span class="lineno"> 7808</span>    <span class="keywordflow">if</span> mode <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;auto&#39;</span>, <span class="stringliteral">&#39;exact&#39;</span>, <span class="stringliteral">&#39;asymp&#39;</span>]:</div>
<div class="line"><span class="lineno"> 7809</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;Invalid value for mode: {mode}&#39;</span>)</div>
<div class="line"><span class="lineno"> 7810</span>    alternative = {<span class="stringliteral">&#39;t&#39;</span>: <span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;g&#39;</span>: <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;l&#39;</span>: <span class="stringliteral">&#39;less&#39;</span>}.get(</div>
<div class="line"><span class="lineno"> 7811</span>        alternative.lower()[0], alternative)</div>
<div class="line"><span class="lineno"> 7812</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>]:</div>
<div class="line"><span class="lineno"> 7813</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;Invalid value for alternative: {alternative}&#39;</span>)</div>
<div class="line"><span class="lineno"> 7814</span>    MAX_AUTO_N = 10000  <span class="comment"># &#39;auto&#39; will attempt to be exact if n1,n2 &lt;= MAX_AUTO_N</span></div>
<div class="line"><span class="lineno"> 7815</span>    <span class="keywordflow">if</span> np.ma.is_masked(data1):</div>
<div class="line"><span class="lineno"> 7816</span>        data1 = data1.compressed()</div>
<div class="line"><span class="lineno"> 7817</span>    <span class="keywordflow">if</span> np.ma.is_masked(data2):</div>
<div class="line"><span class="lineno"> 7818</span>        data2 = data2.compressed()</div>
<div class="line"><span class="lineno"> 7819</span>    data1 = np.sort(data1)</div>
<div class="line"><span class="lineno"> 7820</span>    data2 = np.sort(data2)</div>
<div class="line"><span class="lineno"> 7821</span>    n1 = data1.shape[0]</div>
<div class="line"><span class="lineno"> 7822</span>    n2 = data2.shape[0]</div>
<div class="line"><span class="lineno"> 7823</span>    <span class="keywordflow">if</span> min(n1, n2) == 0:</div>
<div class="line"><span class="lineno"> 7824</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Data passed to ks_2samp must not be empty&#39;</span>)</div>
<div class="line"><span class="lineno"> 7825</span> </div>
<div class="line"><span class="lineno"> 7826</span>    data_all = np.concatenate([data1, data2])</div>
<div class="line"><span class="lineno"> 7827</span>    <span class="comment"># using searchsorted solves equal data problem</span></div>
<div class="line"><span class="lineno"> 7828</span>    cdf1 = np.searchsorted(data1, data_all, side=<span class="stringliteral">&#39;right&#39;</span>) / n1</div>
<div class="line"><span class="lineno"> 7829</span>    cdf2 = np.searchsorted(data2, data_all, side=<span class="stringliteral">&#39;right&#39;</span>) / n2</div>
<div class="line"><span class="lineno"> 7830</span>    cddiffs = cdf1 - cdf2</div>
<div class="line"><span class="lineno"> 7831</span>    <span class="comment"># Ensure sign of minS is not negative.</span></div>
<div class="line"><span class="lineno"> 7832</span>    minS = np.clip(-np.min(cddiffs), 0, 1)</div>
<div class="line"><span class="lineno"> 7833</span>    maxS = np.max(cddiffs)</div>
<div class="line"><span class="lineno"> 7834</span>    alt2Dvalue = {<span class="stringliteral">&#39;less&#39;</span>: minS, <span class="stringliteral">&#39;greater&#39;</span>: maxS, <span class="stringliteral">&#39;two-sided&#39;</span>: max(minS, maxS)}</div>
<div class="line"><span class="lineno"> 7835</span>    d = alt2Dvalue[alternative]</div>
<div class="line"><span class="lineno"> 7836</span>    g = gcd(n1, n2)</div>
<div class="line"><span class="lineno"> 7837</span>    n1g = n1 // g</div>
<div class="line"><span class="lineno"> 7838</span>    n2g = n2 // g</div>
<div class="line"><span class="lineno"> 7839</span>    prob = -np.inf</div>
<div class="line"><span class="lineno"> 7840</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;auto&#39;</span>:</div>
<div class="line"><span class="lineno"> 7841</span>        mode = <span class="stringliteral">&#39;exact&#39;</span> <span class="keywordflow">if</span> max(n1, n2) &lt;= MAX_AUTO_N <span class="keywordflow">else</span> <span class="stringliteral">&#39;asymp&#39;</span></div>
<div class="line"><span class="lineno"> 7842</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&#39;exact&#39;</span>:</div>
<div class="line"><span class="lineno"> 7843</span>        <span class="comment"># If lcm(n1, n2) is too big, switch from exact to asymp</span></div>
<div class="line"><span class="lineno"> 7844</span>        <span class="keywordflow">if</span> n1g &gt;= np.iinfo(np.int32).max / n2g:</div>
<div class="line"><span class="lineno"> 7845</span>            mode = <span class="stringliteral">&#39;asymp&#39;</span></div>
<div class="line"><span class="lineno"> 7846</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 7847</span>                f<span class="stringliteral">&quot;Exact ks_2samp calculation not possible with samples sizes &quot;</span></div>
<div class="line"><span class="lineno"> 7848</span>                f<span class="stringliteral">&quot;{n1} and {n2}. Switching to &#39;asymp&#39;.&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno"> 7849</span>                stacklevel=3)</div>
<div class="line"><span class="lineno"> 7850</span> </div>
<div class="line"><span class="lineno"> 7851</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;exact&#39;</span>:</div>
<div class="line"><span class="lineno"> 7852</span>        success, d, prob = _attempt_exact_2kssamp(n1, n2, g, d, alternative)</div>
<div class="line"><span class="lineno"> 7853</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> success:</div>
<div class="line"><span class="lineno"> 7854</span>            mode = <span class="stringliteral">&#39;asymp&#39;</span></div>
<div class="line"><span class="lineno"> 7855</span>            warnings.warn(f<span class="stringliteral">&quot;ks_2samp: Exact calculation unsuccessful. &quot;</span></div>
<div class="line"><span class="lineno"> 7856</span>                          f<span class="stringliteral">&quot;Switching to method={mode}.&quot;</span>, RuntimeWarning,</div>
<div class="line"><span class="lineno"> 7857</span>                          stacklevel=3)</div>
<div class="line"><span class="lineno"> 7858</span> </div>
<div class="line"><span class="lineno"> 7859</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&#39;asymp&#39;</span>:</div>
<div class="line"><span class="lineno"> 7860</span>        <span class="comment"># The product n1*n2 is large.  Use Smirnov&#39;s asymptoptic formula.</span></div>
<div class="line"><span class="lineno"> 7861</span>        <span class="comment"># Ensure float to avoid overflow in multiplication</span></div>
<div class="line"><span class="lineno"> 7862</span>        <span class="comment"># sorted because the one-sided formula is not symmetric in n1, n2</span></div>
<div class="line"><span class="lineno"> 7863</span>        m, n = sorted([float(n1), float(n2)], reverse=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 7864</span>        en = m * n / (m + n)</div>
<div class="line"><span class="lineno"> 7865</span>        <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;two-sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 7866</span>            prob = distributions.kstwo.sf(d, np.round(en))</div>
<div class="line"><span class="lineno"> 7867</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7868</span>            z = np.sqrt(en) * d</div>
<div class="line"><span class="lineno"> 7869</span>            <span class="comment"># Use Hodges&#39; suggested approximation Eqn 5.3</span></div>
<div class="line"><span class="lineno"> 7870</span>            <span class="comment"># Requires m to be the larger of (n1, n2)</span></div>
<div class="line"><span class="lineno"> 7871</span>            expt = -2 * z**2 - 2 * z * (m + 2*n)/np.sqrt(m*n*(m+n))/3.0</div>
<div class="line"><span class="lineno"> 7872</span>            prob = np.exp(expt)</div>
<div class="line"><span class="lineno"> 7873</span> </div>
<div class="line"><span class="lineno"> 7874</span>    prob = np.clip(prob, 0, 1)</div>
<div class="line"><span class="lineno"> 7875</span>    <span class="keywordflow">return</span> KstestResult(d, prob)</div>
<div class="line"><span class="lineno"> 7876</span> </div>
<div class="line"><span class="lineno"> 7877</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a918a98d18b72d14b9f81de22e21faa56" name="a918a98d18b72d14b9f81de22e21faa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918a98d18b72d14b9f81de22e21faa56">&#9670;&#160;</a></span>kstest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.kstest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'auto'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs the (one-sample or two-sample) Kolmogorov-Smirnov test for
goodness of fit.

The one-sample test compares the underlying distribution F(x) of a sample
against a given distribution G(x). The two-sample test compares the
underlying distributions of two independent samples. Both tests are valid
only for continuous distributions.

Parameters
----------
rvs : str, array_like, or callable
    If an array, it should be a 1-D array of observations of random
    variables.
    If a callable, it should be a function to generate random variables;
    it is required to have a keyword argument `size`.
    If a string, it should be the name of a distribution in `scipy.stats`,
    which will be used to generate random variables.
cdf : str, array_like or callable
    If array_like, it should be a 1-D array of observations of random
    variables, and the two-sample test is performed
    (and rvs must be array_like).
    If a callable, that callable is used to calculate the cdf.
    If a string, it should be the name of a distribution in `scipy.stats`,
    which will be used as the cdf function.
args : tuple, sequence, optional
    Distribution parameters, used if `rvs` or `cdf` are strings or
    callables.
N : int, optional
    Sample size if `rvs` is string or callable.  Default is 20.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the null and alternative hypotheses. Default is 'two-sided'.
    Please see explanations in the Notes below.
method : {'auto', 'exact', 'approx', 'asymp'}, optional
    Defines the distribution used for calculating the p-value.
    The following options are available (default is 'auto'):

      * 'auto' : selects one of the other options.
      * 'exact' : uses the exact distribution of test statistic.
      * 'approx' : approximates the two-sided probability with twice the
        one-sided probability
      * 'asymp': uses asymptotic distribution of test statistic

Returns
-------
statistic : float
    KS test statistic, either D, D+ or D-.
pvalue : float
    One-tailed or two-tailed p-value.

See Also
--------
ks_2samp

Notes
-----
There are three options for the null and corresponding alternative
hypothesis that can be selected using the `alternative` parameter.

- `two-sided`: The null hypothesis is that the two distributions are
  identical, F(x)=G(x) for all x; the alternative is that they are not
  identical.

- `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the
  alternative is that F(x) &lt; G(x) for at least one x.

- `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the
  alternative is that F(x) &gt; G(x) for at least one x.

Note that the alternative hypotheses describe the *CDFs* of the
underlying distributions, not the observed values. For example,
suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in
x1 tend to be less than those in x2.


Examples
--------
Suppose we wish to test the null hypothesis that a sample is distributed
according to the standard normal.
We choose a confidence level of 95%; that is, we will reject the null
hypothesis in favor of the alternative if the p-value is less than 0.05.

When testing uniformly distributed data, we would expect the
null hypothesis to be rejected.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; stats.kstest(stats.uniform.rvs(size=100, random_state=rng),
...              stats.norm.cdf)
KstestResult(statistic=0.5001899973268688, pvalue=1.1616392184763533e-23)

Indeed, the p-value is lower than our threshold of 0.05, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the data
are *not* distributed according to the standard normal.

When testing random variates from the standard normal distribution, we
expect the data to be consistent with the null hypothesis most of the time.

&gt;&gt;&gt; x = stats.norm.rvs(size=100, random_state=rng)
&gt;&gt;&gt; stats.kstest(x, stats.norm.cdf)
KstestResult(statistic=0.05345882212970396, pvalue=0.9227159037744717)

As expected, the p-value of 0.92 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.

Suppose, however, that the random variates are distributed according to
a normal distribution that is shifted toward greater values. In this case,
the cumulative density function (CDF) of the underlying distribution tends
to be *less* than the CDF of the standard normal. Therefore, we would
expect the null hypothesis to be rejected with ``alternative='less'``:

&gt;&gt;&gt; x = stats.norm.rvs(size=100, loc=0.5, random_state=rng)
&gt;&gt;&gt; stats.kstest(x, stats.norm.cdf, alternative='less')
KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743)

and indeed, with p-value smaller than our threshold, we reject the null
hypothesis in favor of the alternative.

For convenience, the previous test can be performed using the name of the
distribution as the second argument.

&gt;&gt;&gt; stats.kstest(x, "norm", alternative='less')
KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743)

The examples above have all been one-sample tests identical to those
performed by `ks_1samp`. Note that `kstest` can also perform two-sample
tests identical to those performed by `ks_2samp`. For example, when two
samples are drawn from the same distribution, we expect the data to be
consistent with the null hypothesis most of the time.

&gt;&gt;&gt; sample1 = stats.laplace.rvs(size=105, random_state=rng)
&gt;&gt;&gt; sample2 = stats.laplace.rvs(size=95, random_state=rng)
&gt;&gt;&gt; stats.kstest(sample1, sample2)
KstestResult(statistic=0.11779448621553884, pvalue=0.4494256912629795)

As expected, the p-value of 0.45 is not below our threshold of 0.05, so
we cannot reject the null hypothesis.</pre> <div class="fragment"><div class="line"><span class="lineno"> 7908</span><span class="keyword">def </span>kstest(rvs, cdf, args=(), N=20, alternative=<span class="stringliteral">&#39;two-sided&#39;</span>, method=<span class="stringliteral">&#39;auto&#39;</span>):</div>
<div class="line"><span class="lineno"> 7909</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7910</span><span class="stringliteral">    Performs the (one-sample or two-sample) Kolmogorov-Smirnov test for</span></div>
<div class="line"><span class="lineno"> 7911</span><span class="stringliteral">    goodness of fit.</span></div>
<div class="line"><span class="lineno"> 7912</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7913</span><span class="stringliteral">    The one-sample test compares the underlying distribution F(x) of a sample</span></div>
<div class="line"><span class="lineno"> 7914</span><span class="stringliteral">    against a given distribution G(x). The two-sample test compares the</span></div>
<div class="line"><span class="lineno"> 7915</span><span class="stringliteral">    underlying distributions of two independent samples. Both tests are valid</span></div>
<div class="line"><span class="lineno"> 7916</span><span class="stringliteral">    only for continuous distributions.</span></div>
<div class="line"><span class="lineno"> 7917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7918</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 7919</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7920</span><span class="stringliteral">    rvs : str, array_like, or callable</span></div>
<div class="line"><span class="lineno"> 7921</span><span class="stringliteral">        If an array, it should be a 1-D array of observations of random</span></div>
<div class="line"><span class="lineno"> 7922</span><span class="stringliteral">        variables.</span></div>
<div class="line"><span class="lineno"> 7923</span><span class="stringliteral">        If a callable, it should be a function to generate random variables;</span></div>
<div class="line"><span class="lineno"> 7924</span><span class="stringliteral">        it is required to have a keyword argument `size`.</span></div>
<div class="line"><span class="lineno"> 7925</span><span class="stringliteral">        If a string, it should be the name of a distribution in `scipy.stats`,</span></div>
<div class="line"><span class="lineno"> 7926</span><span class="stringliteral">        which will be used to generate random variables.</span></div>
<div class="line"><span class="lineno"> 7927</span><span class="stringliteral">    cdf : str, array_like or callable</span></div>
<div class="line"><span class="lineno"> 7928</span><span class="stringliteral">        If array_like, it should be a 1-D array of observations of random</span></div>
<div class="line"><span class="lineno"> 7929</span><span class="stringliteral">        variables, and the two-sample test is performed</span></div>
<div class="line"><span class="lineno"> 7930</span><span class="stringliteral">        (and rvs must be array_like).</span></div>
<div class="line"><span class="lineno"> 7931</span><span class="stringliteral">        If a callable, that callable is used to calculate the cdf.</span></div>
<div class="line"><span class="lineno"> 7932</span><span class="stringliteral">        If a string, it should be the name of a distribution in `scipy.stats`,</span></div>
<div class="line"><span class="lineno"> 7933</span><span class="stringliteral">        which will be used as the cdf function.</span></div>
<div class="line"><span class="lineno"> 7934</span><span class="stringliteral">    args : tuple, sequence, optional</span></div>
<div class="line"><span class="lineno"> 7935</span><span class="stringliteral">        Distribution parameters, used if `rvs` or `cdf` are strings or</span></div>
<div class="line"><span class="lineno"> 7936</span><span class="stringliteral">        callables.</span></div>
<div class="line"><span class="lineno"> 7937</span><span class="stringliteral">    N : int, optional</span></div>
<div class="line"><span class="lineno"> 7938</span><span class="stringliteral">        Sample size if `rvs` is string or callable.  Default is 20.</span></div>
<div class="line"><span class="lineno"> 7939</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 7940</span><span class="stringliteral">        Defines the null and alternative hypotheses. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 7941</span><span class="stringliteral">        Please see explanations in the Notes below.</span></div>
<div class="line"><span class="lineno"> 7942</span><span class="stringliteral">    method : {&#39;auto&#39;, &#39;exact&#39;, &#39;approx&#39;, &#39;asymp&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 7943</span><span class="stringliteral">        Defines the distribution used for calculating the p-value.</span></div>
<div class="line"><span class="lineno"> 7944</span><span class="stringliteral">        The following options are available (default is &#39;auto&#39;):</span></div>
<div class="line"><span class="lineno"> 7945</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7946</span><span class="stringliteral">          * &#39;auto&#39; : selects one of the other options.</span></div>
<div class="line"><span class="lineno"> 7947</span><span class="stringliteral">          * &#39;exact&#39; : uses the exact distribution of test statistic.</span></div>
<div class="line"><span class="lineno"> 7948</span><span class="stringliteral">          * &#39;approx&#39; : approximates the two-sided probability with twice the</span></div>
<div class="line"><span class="lineno"> 7949</span><span class="stringliteral">            one-sided probability</span></div>
<div class="line"><span class="lineno"> 7950</span><span class="stringliteral">          * &#39;asymp&#39;: uses asymptotic distribution of test statistic</span></div>
<div class="line"><span class="lineno"> 7951</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7952</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7953</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7954</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 7955</span><span class="stringliteral">        KS test statistic, either D, D+ or D-.</span></div>
<div class="line"><span class="lineno"> 7956</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 7957</span><span class="stringliteral">        One-tailed or two-tailed p-value.</span></div>
<div class="line"><span class="lineno"> 7958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7959</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 7960</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7961</span><span class="stringliteral">    ks_2samp</span></div>
<div class="line"><span class="lineno"> 7962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7963</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 7964</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 7965</span><span class="stringliteral">    There are three options for the null and corresponding alternative</span></div>
<div class="line"><span class="lineno"> 7966</span><span class="stringliteral">    hypothesis that can be selected using the `alternative` parameter.</span></div>
<div class="line"><span class="lineno"> 7967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7968</span><span class="stringliteral">    - `two-sided`: The null hypothesis is that the two distributions are</span></div>
<div class="line"><span class="lineno"> 7969</span><span class="stringliteral">      identical, F(x)=G(x) for all x; the alternative is that they are not</span></div>
<div class="line"><span class="lineno"> 7970</span><span class="stringliteral">      identical.</span></div>
<div class="line"><span class="lineno"> 7971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7972</span><span class="stringliteral">    - `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the</span></div>
<div class="line"><span class="lineno"> 7973</span><span class="stringliteral">      alternative is that F(x) &lt; G(x) for at least one x.</span></div>
<div class="line"><span class="lineno"> 7974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7975</span><span class="stringliteral">    - `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the</span></div>
<div class="line"><span class="lineno"> 7976</span><span class="stringliteral">      alternative is that F(x) &gt; G(x) for at least one x.</span></div>
<div class="line"><span class="lineno"> 7977</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7978</span><span class="stringliteral">    Note that the alternative hypotheses describe the *CDFs* of the</span></div>
<div class="line"><span class="lineno"> 7979</span><span class="stringliteral">    underlying distributions, not the observed values. For example,</span></div>
<div class="line"><span class="lineno"> 7980</span><span class="stringliteral">    suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in</span></div>
<div class="line"><span class="lineno"> 7981</span><span class="stringliteral">    x1 tend to be less than those in x2.</span></div>
<div class="line"><span class="lineno"> 7982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7984</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 7985</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7986</span><span class="stringliteral">    Suppose we wish to test the null hypothesis that a sample is distributed</span></div>
<div class="line"><span class="lineno"> 7987</span><span class="stringliteral">    according to the standard normal.</span></div>
<div class="line"><span class="lineno"> 7988</span><span class="stringliteral">    We choose a confidence level of 95%; that is, we will reject the null</span></div>
<div class="line"><span class="lineno"> 7989</span><span class="stringliteral">    hypothesis in favor of the alternative if the p-value is less than 0.05.</span></div>
<div class="line"><span class="lineno"> 7990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7991</span><span class="stringliteral">    When testing uniformly distributed data, we would expect the</span></div>
<div class="line"><span class="lineno"> 7992</span><span class="stringliteral">    null hypothesis to be rejected.</span></div>
<div class="line"><span class="lineno"> 7993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7994</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 7995</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 7996</span><span class="stringliteral">    &gt;&gt;&gt; stats.kstest(stats.uniform.rvs(size=100, random_state=rng),</span></div>
<div class="line"><span class="lineno"> 7997</span><span class="stringliteral">    ...              stats.norm.cdf)</span></div>
<div class="line"><span class="lineno"> 7998</span><span class="stringliteral">    KstestResult(statistic=0.5001899973268688, pvalue=1.1616392184763533e-23)</span></div>
<div class="line"><span class="lineno"> 7999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8000</span><span class="stringliteral">    Indeed, the p-value is lower than our threshold of 0.05, so we reject the</span></div>
<div class="line"><span class="lineno"> 8001</span><span class="stringliteral">    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the data</span></div>
<div class="line"><span class="lineno"> 8002</span><span class="stringliteral">    are *not* distributed according to the standard normal.</span></div>
<div class="line"><span class="lineno"> 8003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8004</span><span class="stringliteral">    When testing random variates from the standard normal distribution, we</span></div>
<div class="line"><span class="lineno"> 8005</span><span class="stringliteral">    expect the data to be consistent with the null hypothesis most of the time.</span></div>
<div class="line"><span class="lineno"> 8006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8007</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 8008</span><span class="stringliteral">    &gt;&gt;&gt; stats.kstest(x, stats.norm.cdf)</span></div>
<div class="line"><span class="lineno"> 8009</span><span class="stringliteral">    KstestResult(statistic=0.05345882212970396, pvalue=0.9227159037744717)</span></div>
<div class="line"><span class="lineno"> 8010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8011</span><span class="stringliteral">    As expected, the p-value of 0.92 is not below our threshold of 0.05, so</span></div>
<div class="line"><span class="lineno"> 8012</span><span class="stringliteral">    we cannot reject the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 8013</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8014</span><span class="stringliteral">    Suppose, however, that the random variates are distributed according to</span></div>
<div class="line"><span class="lineno"> 8015</span><span class="stringliteral">    a normal distribution that is shifted toward greater values. In this case,</span></div>
<div class="line"><span class="lineno"> 8016</span><span class="stringliteral">    the cumulative density function (CDF) of the underlying distribution tends</span></div>
<div class="line"><span class="lineno"> 8017</span><span class="stringliteral">    to be *less* than the CDF of the standard normal. Therefore, we would</span></div>
<div class="line"><span class="lineno"> 8018</span><span class="stringliteral">    expect the null hypothesis to be rejected with ``alternative=&#39;less&#39;``:</span></div>
<div class="line"><span class="lineno"> 8019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8020</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(size=100, loc=0.5, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 8021</span><span class="stringliteral">    &gt;&gt;&gt; stats.kstest(x, stats.norm.cdf, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 8022</span><span class="stringliteral">    KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743)</span></div>
<div class="line"><span class="lineno"> 8023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8024</span><span class="stringliteral">    and indeed, with p-value smaller than our threshold, we reject the null</span></div>
<div class="line"><span class="lineno"> 8025</span><span class="stringliteral">    hypothesis in favor of the alternative.</span></div>
<div class="line"><span class="lineno"> 8026</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8027</span><span class="stringliteral">    For convenience, the previous test can be performed using the name of the</span></div>
<div class="line"><span class="lineno"> 8028</span><span class="stringliteral">    distribution as the second argument.</span></div>
<div class="line"><span class="lineno"> 8029</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8030</span><span class="stringliteral">    &gt;&gt;&gt; stats.kstest(x, &quot;norm&quot;, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 8031</span><span class="stringliteral">    KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743)</span></div>
<div class="line"><span class="lineno"> 8032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8033</span><span class="stringliteral">    The examples above have all been one-sample tests identical to those</span></div>
<div class="line"><span class="lineno"> 8034</span><span class="stringliteral">    performed by `ks_1samp`. Note that `kstest` can also perform two-sample</span></div>
<div class="line"><span class="lineno"> 8035</span><span class="stringliteral">    tests identical to those performed by `ks_2samp`. For example, when two</span></div>
<div class="line"><span class="lineno"> 8036</span><span class="stringliteral">    samples are drawn from the same distribution, we expect the data to be</span></div>
<div class="line"><span class="lineno"> 8037</span><span class="stringliteral">    consistent with the null hypothesis most of the time.</span></div>
<div class="line"><span class="lineno"> 8038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8039</span><span class="stringliteral">    &gt;&gt;&gt; sample1 = stats.laplace.rvs(size=105, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 8040</span><span class="stringliteral">    &gt;&gt;&gt; sample2 = stats.laplace.rvs(size=95, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 8041</span><span class="stringliteral">    &gt;&gt;&gt; stats.kstest(sample1, sample2)</span></div>
<div class="line"><span class="lineno"> 8042</span><span class="stringliteral">    KstestResult(statistic=0.11779448621553884, pvalue=0.4494256912629795)</span></div>
<div class="line"><span class="lineno"> 8043</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8044</span><span class="stringliteral">    As expected, the p-value of 0.45 is not below our threshold of 0.05, so</span></div>
<div class="line"><span class="lineno"> 8045</span><span class="stringliteral">    we cannot reject the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 8046</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8047</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8048</span>    <span class="comment"># to not break compatibility with existing code</span></div>
<div class="line"><span class="lineno"> 8049</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;two_sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 8050</span>        alternative = <span class="stringliteral">&#39;two-sided&#39;</span></div>
<div class="line"><span class="lineno"> 8051</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>]:</div>
<div class="line"><span class="lineno"> 8052</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unexpected alternative %s&quot;</span> % alternative)</div>
<div class="line"><span class="lineno"> 8053</span>    xvals, yvals, cdf = _parse_kstest_args(rvs, cdf, args, N)</div>
<div class="line"><span class="lineno"> 8054</span>    <span class="keywordflow">if</span> cdf:</div>
<div class="line"><span class="lineno"> 8055</span>        <span class="keywordflow">return</span> ks_1samp(xvals, cdf, args=args, alternative=alternative,</div>
<div class="line"><span class="lineno"> 8056</span>                        method=method)</div>
<div class="line"><span class="lineno"> 8057</span>    <span class="keywordflow">return</span> ks_2samp(xvals, yvals, alternative=alternative, method=method)</div>
<div class="line"><span class="lineno"> 8058</span> </div>
<div class="line"><span class="lineno"> 8059</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9fd18adf3aba669d3c24c5d052097f73" name="a9fd18adf3aba669d3c24c5d052097f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd18adf3aba669d3c24c5d052097f73">&#9670;&#160;</a></span>kurtosis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.kurtosis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fisher</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bias</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the kurtosis (Fisher or Pearson) of a dataset.

Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.

If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators

Use `kurtosistest` to see if result is close enough to normal.

Parameters
----------
a : array
    Data for which the kurtosis is calculated.
axis : int or None, optional
    Axis along which the kurtosis is calculated. Default is 0.
    If None, compute over the whole array `a`.
fisher : bool, optional
    If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
    Pearson's definition is used (normal ==&gt; 3.0).
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
kurtosis : array
    The kurtosis of values along an axis, returning NaN where all values
    are equal.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.

Examples
--------
In Fisher's definiton, the kurtosis of the normal distribution is zero.
In the following example, the kurtosis is close to zero, because it was
calculated from the dataset, not from the continuous distribution.

&gt;&gt;&gt; from scipy.stats import norm, kurtosis
&gt;&gt;&gt; data = norm.rvs(size=1000, random_state=3)
&gt;&gt;&gt; kurtosis(data)
-0.06928694200380558

The distribution with a higher kurtosis has a heavier tail.
The zero valued kurtosis of the normal distribution in Fisher's definition
can serve as a reference point.

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import scipy.stats as stats
&gt;&gt;&gt; from scipy.stats import kurtosis

&gt;&gt;&gt; x = np.linspace(-5, 5, 100)
&gt;&gt;&gt; ax = plt.subplot()
&gt;&gt;&gt; distnames = ['laplace', 'norm', 'uniform']

&gt;&gt;&gt; for distname in distnames:
...     if distname == 'uniform':
...         dist = getattr(stats, distname)(loc=-2, scale=4)
...     else:
...         dist = getattr(stats, distname)
...     data = dist.rvs(size=1000)
...     kur = kurtosis(data, fisher=True)
...     y = dist.pdf(x)
...     ax.plot(x, y, label="{}, {}".format(distname, round(kur, 3)))
...     ax.legend()

The Laplace distribution has a heavier tail than the normal distribution.
The uniform distribution (which has negative kurtosis) has the thinnest
tail.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1366</span><span class="keyword">def </span>kurtosis(a, axis=0, fisher=True, bias=True, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 1367</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    Kurtosis is the fourth central moment divided by the square of the</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    variance. If Fisher&#39;s definition is used, then 3.0 is subtracted from</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    the result to give 0.0 for a normal distribution.</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    If bias is False then the kurtosis is calculated using k statistics to</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    eliminate bias coming from biased moment estimators</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    Use `kurtosistest` to see if result is close enough to normal.</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    a : array</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">        Data for which the kurtosis is calculated.</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">        Axis along which the kurtosis is calculated. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">        If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    fisher : bool, optional</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">        If True, Fisher&#39;s definition is used (normal ==&gt; 0.0). If False,</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">        Pearson&#39;s definition is used (normal ==&gt; 3.0).</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    bias : bool, optional</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">        If False, then the calculations are corrected for statistical bias.</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">        Defines how to handle when input contains nan. &#39;propagate&#39; returns nan,</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">        &#39;raise&#39; throws an error, &#39;omit&#39; performs the calculations ignoring nan</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">        values. Default is &#39;propagate&#39;.</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    kurtosis : array</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">        The kurtosis of values along an axis, returning NaN where all values</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">        are equal.</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">       Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">       York. 2000.</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    In Fisher&#39;s definiton, the kurtosis of the normal distribution is zero.</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral">    In the following example, the kurtosis is close to zero, because it was</span></div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    calculated from the dataset, not from the continuous distribution.</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import norm, kurtosis</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral">    &gt;&gt;&gt; data = norm.rvs(size=1000, random_state=3)</span></div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">    &gt;&gt;&gt; kurtosis(data)</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">    -0.06928694200380558</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral">    The distribution with a higher kurtosis has a heavier tail.</span></div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">    The zero valued kurtosis of the normal distribution in Fisher&#39;s definition</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">    can serve as a reference point.</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    &gt;&gt;&gt; import scipy.stats as stats</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import kurtosis</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(-5, 5, 100)</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    &gt;&gt;&gt; ax = plt.subplot()</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    &gt;&gt;&gt; distnames = [&#39;laplace&#39;, &#39;norm&#39;, &#39;uniform&#39;]</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    &gt;&gt;&gt; for distname in distnames:</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">    ...     if distname == &#39;uniform&#39;:</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">    ...         dist = getattr(stats, distname)(loc=-2, scale=4)</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral">    ...     else:</span></div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    ...         dist = getattr(stats, distname)</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    ...     data = dist.rvs(size=1000)</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral">    ...     kur = kurtosis(data, fisher=True)</span></div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">    ...     y = dist.pdf(x)</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    ...     ax.plot(x, y, label=&quot;{}, {}&quot;.format(distname, round(kur, 3)))</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral">    ...     ax.legend()</span></div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral">    The Laplace distribution has a heavier tail than the normal distribution.</span></div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    The uniform distribution (which has negative kurtosis) has the thinnest</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    tail.</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1446</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 1447</span> </div>
<div class="line"><span class="lineno"> 1448</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 1449</span> </div>
<div class="line"><span class="lineno"> 1450</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 1451</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 1452</span>        <span class="keywordflow">return</span> mstats_basic.kurtosis(a, axis, fisher, bias)</div>
<div class="line"><span class="lineno"> 1453</span> </div>
<div class="line"><span class="lineno"> 1454</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 1455</span>    mean = a.mean(axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1456</span>    m2 = _moment(a, 2, axis, mean=mean)</div>
<div class="line"><span class="lineno"> 1457</span>    m4 = _moment(a, 4, axis, mean=mean)</div>
<div class="line"><span class="lineno"> 1458</span>    <span class="keyword">with</span> np.errstate(all=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 1459</span>        zero = (m2 &lt;= (np.finfo(m2.dtype).resolution * mean.squeeze(axis))**2)</div>
<div class="line"><span class="lineno"> 1460</span>        vals = np.where(zero, np.nan, m4 / m2**2.0)</div>
<div class="line"><span class="lineno"> 1461</span> </div>
<div class="line"><span class="lineno"> 1462</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> bias:</div>
<div class="line"><span class="lineno"> 1463</span>        can_correct = ~zero &amp; (n &gt; 3)</div>
<div class="line"><span class="lineno"> 1464</span>        <span class="keywordflow">if</span> can_correct.any():</div>
<div class="line"><span class="lineno"> 1465</span>            m2 = np.extract(can_correct, m2)</div>
<div class="line"><span class="lineno"> 1466</span>            m4 = np.extract(can_correct, m4)</div>
<div class="line"><span class="lineno"> 1467</span>            nval = 1.0/(n-2)/(n-3) * ((n**2-1.0)*m4/m2**2.0 - 3*(n-1)**2.0)</div>
<div class="line"><span class="lineno"> 1468</span>            np.place(vals, can_correct, nval + 3.0)</div>
<div class="line"><span class="lineno"> 1469</span> </div>
<div class="line"><span class="lineno"> 1470</span>    <span class="keywordflow">if</span> vals.ndim == 0:</div>
<div class="line"><span class="lineno"> 1471</span>        vals = vals.item()  <span class="comment"># array scalar</span></div>
<div class="line"><span class="lineno"> 1472</span> </div>
<div class="line"><span class="lineno"> 1473</span>    <span class="keywordflow">return</span> vals - 3 <span class="keywordflow">if</span> fisher <span class="keywordflow">else</span> vals</div>
<div class="line"><span class="lineno"> 1474</span> </div>
<div class="line"><span class="lineno"> 1475</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8afd0b93401a2e4378a7f325e2b53cf0" name="a8afd0b93401a2e4378a7f325e2b53cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afd0b93401a2e4378a7f325e2b53cf0">&#9670;&#160;</a></span>kurtosistest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.kurtosistest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether a dataset has normal kurtosis.

This function tests the null hypothesis that the kurtosis
of the population from which the sample was drawn is that
of the normal distribution.

Parameters
----------
a : array
    Array of the sample data.
axis : int or None, optional
   Axis along which to compute test. Default is 0. If None,
   compute over the whole array `a`.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the kurtosis of the distribution underlying the sample
      is different from that of the normal distribution
    * 'less': the kurtosis of the distribution underlying the sample
      is less than that of the normal distribution
    * 'greater': the kurtosis of the distribution underlying the sample
      is greater than that of the normal distribution

    .. versionadded:: 1.7.0

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    The p-value for the hypothesis test.

Notes
-----
Valid only for n&gt;20. This function uses the method described in [1]_.

References
----------
.. [1] see e.g. F. J. Anscombe, W. J. Glynn, "Distribution of the kurtosis
   statistic b2 for normal samples", Biometrika, vol. 70, pp. 227-234, 1983.

Examples
--------
&gt;&gt;&gt; from scipy.stats import kurtosistest
&gt;&gt;&gt; kurtosistest(list(range(20)))
KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.08804338332528348)
&gt;&gt;&gt; kurtosistest(list(range(20)), alternative='less')
KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.04402169166264174)
&gt;&gt;&gt; kurtosistest(list(range(20)), alternative='greater')
KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.9559783083373583)

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; s = rng.normal(0, 1, 1000)
&gt;&gt;&gt; kurtosistest(s)
KurtosistestResult(statistic=-1.475047944490622, pvalue=0.14019965402996987)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1691</span><span class="keyword">def </span>kurtosistest(a, axis=0, nan_policy=&#39;propagate&#39;, alternative=&#39;two-sided&#39;):</div>
<div class="line"><span class="lineno"> 1692</span>    <span class="stringliteral">&quot;&quot;&quot;Test whether a dataset has normal kurtosis.</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral">    This function tests the null hypothesis that the kurtosis</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    of the population from which the sample was drawn is that</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    of the normal distribution.</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    a : array</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">        Array of the sample data.</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">       Axis along which to compute test. Default is 0. If None,</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral">       compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">        * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">        * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">        * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral">        Defines the alternative hypothesis.</span></div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral">        The following options are available (default is &#39;two-sided&#39;):</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral">        * &#39;two-sided&#39;: the kurtosis of the distribution underlying the sample</span></div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">          is different from that of the normal distribution</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">        * &#39;less&#39;: the kurtosis of the distribution underlying the sample</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral">          is less than that of the normal distribution</span></div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">        * &#39;greater&#39;: the kurtosis of the distribution underlying the sample</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">          is greater than that of the normal distribution</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1726</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1727</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1728</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 1729</span><span class="stringliteral">        The computed z-score for this test.</span></div>
<div class="line"><span class="lineno"> 1730</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 1731</span><span class="stringliteral">        The p-value for the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 1732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1733</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1734</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1735</span><span class="stringliteral">    Valid only for n&gt;20. This function uses the method described in [1]_.</span></div>
<div class="line"><span class="lineno"> 1736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1737</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">    .. [1] see e.g. F. J. Anscombe, W. J. Glynn, &quot;Distribution of the kurtosis</span></div>
<div class="line"><span class="lineno"> 1740</span><span class="stringliteral">       statistic b2 for normal samples&quot;, Biometrika, vol. 70, pp. 227-234, 1983.</span></div>
<div class="line"><span class="lineno"> 1741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1742</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1743</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1744</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import kurtosistest</span></div>
<div class="line"><span class="lineno"> 1745</span><span class="stringliteral">    &gt;&gt;&gt; kurtosistest(list(range(20)))</span></div>
<div class="line"><span class="lineno"> 1746</span><span class="stringliteral">    KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.08804338332528348)</span></div>
<div class="line"><span class="lineno"> 1747</span><span class="stringliteral">    &gt;&gt;&gt; kurtosistest(list(range(20)), alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 1748</span><span class="stringliteral">    KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.04402169166264174)</span></div>
<div class="line"><span class="lineno"> 1749</span><span class="stringliteral">    &gt;&gt;&gt; kurtosistest(list(range(20)), alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 1750</span><span class="stringliteral">    KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.9559783083373583)</span></div>
<div class="line"><span class="lineno"> 1751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1752</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1753</span><span class="stringliteral">    &gt;&gt;&gt; s = rng.normal(0, 1, 1000)</span></div>
<div class="line"><span class="lineno"> 1754</span><span class="stringliteral">    &gt;&gt;&gt; kurtosistest(s)</span></div>
<div class="line"><span class="lineno"> 1755</span><span class="stringliteral">    KurtosistestResult(statistic=-1.475047944490622, pvalue=0.14019965402996987)</span></div>
<div class="line"><span class="lineno"> 1756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1757</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1758</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 1759</span> </div>
<div class="line"><span class="lineno"> 1760</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 1761</span> </div>
<div class="line"><span class="lineno"> 1762</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 1763</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 1764</span>        <span class="keywordflow">return</span> mstats_basic.kurtosistest(a, axis, alternative)</div>
<div class="line"><span class="lineno"> 1765</span> </div>
<div class="line"><span class="lineno"> 1766</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 1767</span>    <span class="keywordflow">if</span> n &lt; 5:</div>
<div class="line"><span class="lineno"> 1768</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1769</span>            <span class="stringliteral">&quot;kurtosistest requires at least 5 observations; %i observations&quot;</span></div>
<div class="line"><span class="lineno"> 1770</span>            <span class="stringliteral">&quot; were given.&quot;</span> % int(n))</div>
<div class="line"><span class="lineno"> 1771</span>    <span class="keywordflow">if</span> n &lt; 20:</div>
<div class="line"><span class="lineno"> 1772</span>        warnings.warn(<span class="stringliteral">&quot;kurtosistest only valid for n&gt;=20 ... continuing &quot;</span></div>
<div class="line"><span class="lineno"> 1773</span>                      <span class="stringliteral">&quot;anyway, n=%i&quot;</span> % int(n))</div>
<div class="line"><span class="lineno"> 1774</span>    b2 = kurtosis(a, axis, fisher=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1775</span> </div>
<div class="line"><span class="lineno"> 1776</span>    E = 3.0*(n-1) / (n+1)</div>
<div class="line"><span class="lineno"> 1777</span>    varb2 = 24.0*n*(n-2)*(n-3) / ((n+1)*(n+1.)*(n+3)*(n+5))  <span class="comment"># [1]_ Eq. 1</span></div>
<div class="line"><span class="lineno"> 1778</span>    x = (b2-E) / np.sqrt(varb2)  <span class="comment"># [1]_ Eq. 4</span></div>
<div class="line"><span class="lineno"> 1779</span>    <span class="comment"># [1]_ Eq. 2:</span></div>
<div class="line"><span class="lineno"> 1780</span>    sqrtbeta1 = 6.0*(n*n-5*n+2)/((n+7)*(n+9)) * np.sqrt((6.0*(n+3)*(n+5)) /</div>
<div class="line"><span class="lineno"> 1781</span>                                                        (n*(n-2)*(n-3)))</div>
<div class="line"><span class="lineno"> 1782</span>    <span class="comment"># [1]_ Eq. 3:</span></div>
<div class="line"><span class="lineno"> 1783</span>    A = 6.0 + 8.0/sqrtbeta1 * (2.0/sqrtbeta1 + np.sqrt(1+4.0/(sqrtbeta1**2)))</div>
<div class="line"><span class="lineno"> 1784</span>    term1 = 1 - 2/(9.0*A)</div>
<div class="line"><span class="lineno"> 1785</span>    denom = 1 + x*np.sqrt(2/(A-4.0))</div>
<div class="line"><span class="lineno"> 1786</span>    term2 = np.sign(denom) * np.where(denom == 0.0, np.nan,</div>
<div class="line"><span class="lineno"> 1787</span>                                      np.power((1-2.0/A)/np.abs(denom), 1/3.0))</div>
<div class="line"><span class="lineno"> 1788</span>    <span class="keywordflow">if</span> np.any(denom == 0):</div>
<div class="line"><span class="lineno"> 1789</span>        msg = <span class="stringliteral">&quot;Test statistic not defined in some cases due to division by &quot;</span> \</div>
<div class="line"><span class="lineno"> 1790</span>              <span class="stringliteral">&quot;zero. Return nan in that case...&quot;</span></div>
<div class="line"><span class="lineno"> 1791</span>        warnings.warn(msg, RuntimeWarning)</div>
<div class="line"><span class="lineno"> 1792</span> </div>
<div class="line"><span class="lineno"> 1793</span>    Z = (term1 - term2) / np.sqrt(2/(9.0*A))  <span class="comment"># [1]_ Eq. 5</span></div>
<div class="line"><span class="lineno"> 1794</span> </div>
<div class="line"><span class="lineno"> 1795</span>    <span class="comment"># zprob uses upper tail, so Z needs to be positive</span></div>
<div class="line"><span class="lineno"> 1796</span>    <span class="keywordflow">return</span> KurtosistestResult(*_normtest_finish(Z, alternative))</div>
<div class="line"><span class="lineno"> 1797</span> </div>
<div class="line"><span class="lineno"> 1798</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3965fb8fb12386cc993ba9ea132af562" name="a3965fb8fb12386cc993ba9ea132af562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965fb8fb12386cc993ba9ea132af562">&#9670;&#160;</a></span>median_abs_deviation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.median_abs_deviation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>np.median</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the median absolute deviation of the data along the given axis.

The median absolute deviation (MAD, [1]_) computes the median over the
absolute deviations from the median. It is a measure of dispersion
similar to the standard deviation but more robust to outliers [2]_.

The MAD of an empty array is ``np.nan``.

.. versionadded:: 1.5.0

Parameters
----------
x : array_like
    Input array or object that can be converted to an array.
axis : int or None, optional
    Axis along which the range is computed. Default is 0. If None, compute
    the MAD over the entire array.
center : callable, optional
    A function that will return the central value. The default is to use
    np.median. Any user defined function used will need to have the
    function signature ``func(arr, axis)``.
scale : scalar or str, optional
    The numerical value of scale will be divided out of the final
    result. The default is 1.0. The string "normal" is also accepted,
    and results in `scale` being the inverse of the standard normal
    quantile function at 0.75, which is approximately 0.67449.
    Array-like scale is also allowed, as long as it broadcasts correctly
    to the output such that ``out / scale`` is a valid operation. The
    output dimensions depend on the input array, `x`, and the `axis`
    argument.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

Returns
-------
mad : scalar or ndarray
    If ``axis=None``, a scalar is returned. If the input contains
    integers or floats of smaller precision than ``np.float64``, then the
    output data-type is ``np.float64``. Otherwise, the output data-type is
    the same as that of the input.

See Also
--------
numpy.std, numpy.var, numpy.median, scipy.stats.iqr, scipy.stats.tmean,
scipy.stats.tstd, scipy.stats.tvar

Notes
-----
The `center` argument only affects the calculation of the central value
around which the MAD is calculated. That is, passing in ``center=np.mean``
will calculate the MAD around the mean - it will not calculate the *mean*
absolute deviation.

The input array may contain `inf`, but if `center` returns `inf`, the
corresponding MAD for that data will be `nan`.

References
----------
.. [1] "Median absolute deviation",
       https://en.wikipedia.org/wiki/Median_absolute_deviation
.. [2] "Robust measures of scale",
       https://en.wikipedia.org/wiki/Robust_measures_of_scale

Examples
--------
When comparing the behavior of `median_abs_deviation` with ``np.std``,
the latter is affected when we change a single value of an array to have an
outlier value while the MAD hardly changes:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = stats.norm.rvs(size=100, scale=1, random_state=123456)
&gt;&gt;&gt; x.std()
0.9973906394005013
&gt;&gt;&gt; stats.median_abs_deviation(x)
0.82832610097857
&gt;&gt;&gt; x[0] = 345.6
&gt;&gt;&gt; x.std()
34.42304872314415
&gt;&gt;&gt; stats.median_abs_deviation(x)
0.8323442311590675

Axis handling example:

&gt;&gt;&gt; x = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; x
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; stats.median_abs_deviation(x)
array([3.5, 2.5, 1.5])
&gt;&gt;&gt; stats.median_abs_deviation(x, axis=None)
2.0

Scale normal example:

&gt;&gt;&gt; x = stats.norm.rvs(size=1000000, scale=2, random_state=123456)
&gt;&gt;&gt; stats.median_abs_deviation(x)
1.3487398527041636
&gt;&gt;&gt; stats.median_abs_deviation(x, scale='normal')
1.9996446978061115</pre> <div class="fragment"><div class="line"><span class="lineno"> 3232</span>                         nan_policy=<span class="stringliteral">&#39;propagate&#39;</span>):</div>
<div class="line"><span class="lineno"> 3233</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3234</span><span class="stringliteral">    Compute the median absolute deviation of the data along the given axis.</span></div>
<div class="line"><span class="lineno"> 3235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3236</span><span class="stringliteral">    The median absolute deviation (MAD, [1]_) computes the median over the</span></div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral">    absolute deviations from the median. It is a measure of dispersion</span></div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral">    similar to the standard deviation but more robust to outliers [2]_.</span></div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">    The MAD of an empty array is ``np.nan``.</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral">    .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral">        Axis along which the range is computed. Default is 0. If None, compute</span></div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">        the MAD over the entire array.</span></div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral">    center : callable, optional</span></div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral">        A function that will return the central value. The default is to use</span></div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral">        np.median. Any user defined function used will need to have the</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">        function signature ``func(arr, axis)``.</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">    scale : scalar or str, optional</span></div>
<div class="line"><span class="lineno"> 3256</span><span class="stringliteral">        The numerical value of scale will be divided out of the final</span></div>
<div class="line"><span class="lineno"> 3257</span><span class="stringliteral">        result. The default is 1.0. The string &quot;normal&quot; is also accepted,</span></div>
<div class="line"><span class="lineno"> 3258</span><span class="stringliteral">        and results in `scale` being the inverse of the standard normal</span></div>
<div class="line"><span class="lineno"> 3259</span><span class="stringliteral">        quantile function at 0.75, which is approximately 0.67449.</span></div>
<div class="line"><span class="lineno"> 3260</span><span class="stringliteral">        Array-like scale is also allowed, as long as it broadcasts correctly</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">        to the output such that ``out / scale`` is a valid operation. The</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral">        output dimensions depend on the input array, `x`, and the `axis`</span></div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral">        argument.</span></div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3265</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 3266</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 3267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3268</span><span class="stringliteral">        * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral">        * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral">        * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 3271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3272</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3273</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3274</span><span class="stringliteral">    mad : scalar or ndarray</span></div>
<div class="line"><span class="lineno"> 3275</span><span class="stringliteral">        If ``axis=None``, a scalar is returned. If the input contains</span></div>
<div class="line"><span class="lineno"> 3276</span><span class="stringliteral">        integers or floats of smaller precision than ``np.float64``, then the</span></div>
<div class="line"><span class="lineno"> 3277</span><span class="stringliteral">        output data-type is ``np.float64``. Otherwise, the output data-type is</span></div>
<div class="line"><span class="lineno"> 3278</span><span class="stringliteral">        the same as that of the input.</span></div>
<div class="line"><span class="lineno"> 3279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3280</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3281</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3282</span><span class="stringliteral">    numpy.std, numpy.var, numpy.median, scipy.stats.iqr, scipy.stats.tmean,</span></div>
<div class="line"><span class="lineno"> 3283</span><span class="stringliteral">    scipy.stats.tstd, scipy.stats.tvar</span></div>
<div class="line"><span class="lineno"> 3284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3285</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3286</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3287</span><span class="stringliteral">    The `center` argument only affects the calculation of the central value</span></div>
<div class="line"><span class="lineno"> 3288</span><span class="stringliteral">    around which the MAD is calculated. That is, passing in ``center=np.mean``</span></div>
<div class="line"><span class="lineno"> 3289</span><span class="stringliteral">    will calculate the MAD around the mean - it will not calculate the *mean*</span></div>
<div class="line"><span class="lineno"> 3290</span><span class="stringliteral">    absolute deviation.</span></div>
<div class="line"><span class="lineno"> 3291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3292</span><span class="stringliteral">    The input array may contain `inf`, but if `center` returns `inf`, the</span></div>
<div class="line"><span class="lineno"> 3293</span><span class="stringliteral">    corresponding MAD for that data will be `nan`.</span></div>
<div class="line"><span class="lineno"> 3294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3295</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3296</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3297</span><span class="stringliteral">    .. [1] &quot;Median absolute deviation&quot;,</span></div>
<div class="line"><span class="lineno"> 3298</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Median_absolute_deviation</span></div>
<div class="line"><span class="lineno"> 3299</span><span class="stringliteral">    .. [2] &quot;Robust measures of scale&quot;,</span></div>
<div class="line"><span class="lineno"> 3300</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Robust_measures_of_scale</span></div>
<div class="line"><span class="lineno"> 3301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3302</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3303</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3304</span><span class="stringliteral">    When comparing the behavior of `median_abs_deviation` with ``np.std``,</span></div>
<div class="line"><span class="lineno"> 3305</span><span class="stringliteral">    the latter is affected when we change a single value of an array to have an</span></div>
<div class="line"><span class="lineno"> 3306</span><span class="stringliteral">    outlier value while the MAD hardly changes:</span></div>
<div class="line"><span class="lineno"> 3307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3308</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 3309</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(size=100, scale=1, random_state=123456)</span></div>
<div class="line"><span class="lineno"> 3310</span><span class="stringliteral">    &gt;&gt;&gt; x.std()</span></div>
<div class="line"><span class="lineno"> 3311</span><span class="stringliteral">    0.9973906394005013</span></div>
<div class="line"><span class="lineno"> 3312</span><span class="stringliteral">    &gt;&gt;&gt; stats.median_abs_deviation(x)</span></div>
<div class="line"><span class="lineno"> 3313</span><span class="stringliteral">    0.82832610097857</span></div>
<div class="line"><span class="lineno"> 3314</span><span class="stringliteral">    &gt;&gt;&gt; x[0] = 345.6</span></div>
<div class="line"><span class="lineno"> 3315</span><span class="stringliteral">    &gt;&gt;&gt; x.std()</span></div>
<div class="line"><span class="lineno"> 3316</span><span class="stringliteral">    34.42304872314415</span></div>
<div class="line"><span class="lineno"> 3317</span><span class="stringliteral">    &gt;&gt;&gt; stats.median_abs_deviation(x)</span></div>
<div class="line"><span class="lineno"> 3318</span><span class="stringliteral">    0.8323442311590675</span></div>
<div class="line"><span class="lineno"> 3319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3320</span><span class="stringliteral">    Axis handling example:</span></div>
<div class="line"><span class="lineno"> 3321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3322</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[10, 7, 4], [3, 2, 1]])</span></div>
<div class="line"><span class="lineno"> 3323</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 3324</span><span class="stringliteral">    array([[10,  7,  4],</span></div>
<div class="line"><span class="lineno"> 3325</span><span class="stringliteral">           [ 3,  2,  1]])</span></div>
<div class="line"><span class="lineno"> 3326</span><span class="stringliteral">    &gt;&gt;&gt; stats.median_abs_deviation(x)</span></div>
<div class="line"><span class="lineno"> 3327</span><span class="stringliteral">    array([3.5, 2.5, 1.5])</span></div>
<div class="line"><span class="lineno"> 3328</span><span class="stringliteral">    &gt;&gt;&gt; stats.median_abs_deviation(x, axis=None)</span></div>
<div class="line"><span class="lineno"> 3329</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 3330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3331</span><span class="stringliteral">    Scale normal example:</span></div>
<div class="line"><span class="lineno"> 3332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3333</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(size=1000000, scale=2, random_state=123456)</span></div>
<div class="line"><span class="lineno"> 3334</span><span class="stringliteral">    &gt;&gt;&gt; stats.median_abs_deviation(x)</span></div>
<div class="line"><span class="lineno"> 3335</span><span class="stringliteral">    1.3487398527041636</span></div>
<div class="line"><span class="lineno"> 3336</span><span class="stringliteral">    &gt;&gt;&gt; stats.median_abs_deviation(x, scale=&#39;normal&#39;)</span></div>
<div class="line"><span class="lineno"> 3337</span><span class="stringliteral">    1.9996446978061115</span></div>
<div class="line"><span class="lineno"> 3338</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3339</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3340</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(center):</div>
<div class="line"><span class="lineno"> 3341</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;The argument &#39;center&#39; must be callable. The given &quot;</span></div>
<div class="line"><span class="lineno"> 3342</span>                        f<span class="stringliteral">&quot;value {repr(center)} is not callable.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3343</span> </div>
<div class="line"><span class="lineno"> 3344</span>    <span class="comment"># An error may be raised here, so fail-fast, before doing lengthy</span></div>
<div class="line"><span class="lineno"> 3345</span>    <span class="comment"># computations, even though `scale` is not used until later</span></div>
<div class="line"><span class="lineno"> 3346</span>    <span class="keywordflow">if</span> isinstance(scale, str):</div>
<div class="line"><span class="lineno"> 3347</span>        <span class="keywordflow">if</span> scale.lower() == <span class="stringliteral">&#39;normal&#39;</span>:</div>
<div class="line"><span class="lineno"> 3348</span>            scale = 0.6744897501960817  <span class="comment"># special.ndtri(0.75)</span></div>
<div class="line"><span class="lineno"> 3349</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3350</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;{scale} is not a valid scale value.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3351</span> </div>
<div class="line"><span class="lineno"> 3352</span>    x = asarray(x)</div>
<div class="line"><span class="lineno"> 3353</span> </div>
<div class="line"><span class="lineno"> 3354</span>    <span class="comment"># Consistent with `np.var` and `np.std`.</span></div>
<div class="line"><span class="lineno"> 3355</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> x.size:</div>
<div class="line"><span class="lineno"> 3356</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3357</span>            <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 3358</span>        nan_shape = tuple(item <span class="keywordflow">for</span> i, item <span class="keywordflow">in</span> enumerate(x.shape) <span class="keywordflow">if</span> i != axis)</div>
<div class="line"><span class="lineno"> 3359</span>        <span class="keywordflow">if</span> nan_shape == ():</div>
<div class="line"><span class="lineno"> 3360</span>            <span class="comment"># Return nan, not array(nan)</span></div>
<div class="line"><span class="lineno"> 3361</span>            <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 3362</span>        <span class="keywordflow">return</span> np.full(nan_shape, np.nan)</div>
<div class="line"><span class="lineno"> 3363</span> </div>
<div class="line"><span class="lineno"> 3364</span>    contains_nan, nan_policy = _contains_nan(x, nan_policy)</div>
<div class="line"><span class="lineno"> 3365</span> </div>
<div class="line"><span class="lineno"> 3366</span>    <span class="keywordflow">if</span> contains_nan:</div>
<div class="line"><span class="lineno"> 3367</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3368</span>            mad = _mad_1d(x.ravel(), center, nan_policy)</div>
<div class="line"><span class="lineno"> 3369</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3370</span>            mad = np.apply_along_axis(_mad_1d, axis, x, center, nan_policy)</div>
<div class="line"><span class="lineno"> 3371</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3372</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3373</span>            med = center(x, axis=<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 3374</span>            mad = np.median(np.abs(x - med))</div>
<div class="line"><span class="lineno"> 3375</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3376</span>            <span class="comment"># Wrap the call to center() in expand_dims() so it acts like</span></div>
<div class="line"><span class="lineno"> 3377</span>            <span class="comment"># keepdims=True was used.</span></div>
<div class="line"><span class="lineno"> 3378</span>            med = np.expand_dims(center(x, axis=axis), axis)</div>
<div class="line"><span class="lineno"> 3379</span>            mad = np.median(np.abs(x - med), axis=axis)</div>
<div class="line"><span class="lineno"> 3380</span> </div>
<div class="line"><span class="lineno"> 3381</span>    <span class="keywordflow">return</span> mad / scale</div>
<div class="line"><span class="lineno"> 3382</span> </div>
<div class="line"><span class="lineno"> 3383</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7666823299f40b492d638a114d2fc91" name="ad7666823299f40b492d638a114d2fc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7666823299f40b492d638a114d2fc91">&#9670;&#160;</a></span>mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.mode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array of the modal (most common) value in the passed array.

If there is more than one such value, only one is returned.
The bin-count for the modal bins is also returned.

Parameters
----------
a : array_like
n-dimensional array of which to find mode(s).
axis : int or None, optional
Axis along which to operate. Default is 0. If None, compute over
the whole array `a`.
nan_policy : {'propagate', 'raise', 'omit'}, optional
Defines how to handle when input contains nan.
The following options are available (default is 'propagate'):

* 'propagate': treats nan as it would treat any other value
* 'raise': throws an error
* 'omit': performs the calculations ignoring nan values
keepdims : bool, optional
If set to ``False``, the `axis` over which the statistic is taken
is consumed (eliminated from the output array) like other reduction
functions (e.g. `skew`, `kurtosis`). If set to ``True``, the `axis` is
retained with size one, and the result will broadcast correctly
against the input array. The default, ``None``, is undefined legacy
behavior retained for backward compatibility.

.. warning::
Unlike other reduction functions (e.g. `skew`, `kurtosis`), the
default behavior of `mode` usually retains the the axis it acts
along. In SciPy 1.11.0, this behavior will change: the default
value of `keepdims` will become ``False``, the `axis` over which
the statistic is taken will be eliminated, and the value ``None``
will no longer be accepted.
.. versionadded:: 1.9.0

Returns
-------
mode : ndarray
Array of modal values.
count : ndarray
Array of counts for each mode.

Notes
-----
The mode of object arrays is calculated using `collections.Counter`, which
treats NaNs with different binary representations as distinct.

.. deprecated:: 1.9.0
Support for non-numeric arrays has been deprecated as of SciPy 1.9.0
and will be removed in 1.11.0. `pandas.DataFrame.mode`_ can
be used instead.

.. _pandas.DataFrame.mode: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html

The mode of arrays with other dtypes is calculated using `numpy.unique`.
In NumPy versions 1.21 and after, all NaNs - even those with different
binary representations - are treated as equivalent and counted as separate
instances of the same value.

Examples
--------
&gt;&gt;&gt; a = np.array([[6, 8, 3, 0],
...               [3, 2, 1, 7],
...               [8, 1, 8, 4],
...               [5, 3, 0, 5],
...               [4, 7, 5, 9]])
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.mode(a, keepdims=True)
ModeResult(mode=array([[3, 1, 0, 0]]), count=array([[1, 1, 1, 1]]))

To get mode of whole array, specify ``axis=None``:

&gt;&gt;&gt; stats.mode(a, axis=None, keepdims=True)
ModeResult(mode=array([3]), count=array([3]))
&gt;&gt;&gt; stats.mode(a, axis=None, keepdims=False)
ModeResult(mode=3, count=3)</pre> <div class="fragment"><div class="line"><span class="lineno">  542</span><span class="keyword">def </span>mode(a, axis=0, nan_policy=&#39;propagate&#39;, keepdims=None):</div>
<div class="line"><span class="lineno">  543</span>    <span class="stringliteral">r&quot;&quot;&quot;Return an array of the modal (most common) value in the passed array.</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    If there is more than one such value, only one is returned.</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    The bin-count for the modal bins is also returned.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        n-dimensional array of which to find mode(s).</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">          * &#39;propagate&#39;: treats nan as it would treat any other value</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">        If set to ``False``, the `axis` over which the statistic is taken</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">        is consumed (eliminated from the output array) like other reduction</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">        functions (e.g. `skew`, `kurtosis`). If set to ``True``, the `axis` is</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">        retained with size one, and the result will broadcast correctly</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        against the input array. The default, ``None``, is undefined legacy</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">        behavior retained for backward compatibility.</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        .. warning::</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">            Unlike other reduction functions (e.g. `skew`, `kurtosis`), the</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">            default behavior of `mode` usually retains the the axis it acts</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">            along. In SciPy 1.11.0, this behavior will change: the default</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">            value of `keepdims` will become ``False``, the `axis` over which</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">            the statistic is taken will be eliminated, and the value ``None``</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">            will no longer be accepted.</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    mode : ndarray</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        Array of modal values.</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    count : ndarray</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        Array of counts for each mode.</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    The mode of object arrays is calculated using `collections.Counter`, which</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    treats NaNs with different binary representations as distinct.</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    .. deprecated:: 1.9.0</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        Support for non-numeric arrays has been deprecated as of SciPy 1.9.0</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        and will be removed in 1.11.0. `pandas.DataFrame.mode`_ can</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        be used instead.</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        .. _pandas.DataFrame.mode: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    The mode of arrays with other dtypes is calculated using `numpy.unique`.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    In NumPy versions 1.21 and after, all NaNs - even those with different</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    binary representations - are treated as equivalent and counted as separate</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    instances of the same value.</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[6, 8, 3, 0],</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    ...               [3, 2, 1, 7],</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    ...               [8, 1, 8, 4],</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    ...               [5, 3, 0, 5],</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    ...               [4, 7, 5, 9]])</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    &gt;&gt;&gt; stats.mode(a, keepdims=True)</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    ModeResult(mode=array([[3, 1, 0, 0]]), count=array([[1, 1, 1, 1]]))</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    To get mode of whole array, specify ``axis=None``:</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    &gt;&gt;&gt; stats.mode(a, axis=None, keepdims=True)</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    ModeResult(mode=array([3]), count=array([3]))</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    &gt;&gt;&gt; stats.mode(a, axis=None, keepdims=False)</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    ModeResult(mode=3, count=3)</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    &quot;&quot;&quot;</span>  <span class="comment"># noqa: E501</span></div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  624</span>        message = (<span class="stringliteral">&quot;Unlike other reduction functions (e.g. `skew`, &quot;</span></div>
<div class="line"><span class="lineno">  625</span>                   <span class="stringliteral">&quot;`kurtosis`), the default behavior of `mode` typically &quot;</span></div>
<div class="line"><span class="lineno">  626</span>                   <span class="stringliteral">&quot;preserves the axis it acts along. In SciPy 1.11.0, &quot;</span></div>
<div class="line"><span class="lineno">  627</span>                   <span class="stringliteral">&quot;this behavior will change: the default value of &quot;</span></div>
<div class="line"><span class="lineno">  628</span>                   <span class="stringliteral">&quot;`keepdims` will become False, the `axis` over which &quot;</span></div>
<div class="line"><span class="lineno">  629</span>                   <span class="stringliteral">&quot;the statistic is taken will be eliminated, and the value &quot;</span></div>
<div class="line"><span class="lineno">  630</span>                   <span class="stringliteral">&quot;None will no longer be accepted. &quot;</span></div>
<div class="line"><span class="lineno">  631</span>                   <span class="stringliteral">&quot;Set `keepdims` to True or False to avoid this warning.&quot;</span>)</div>
<div class="line"><span class="lineno">  632</span>        warnings.warn(message, FutureWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno">  635</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno">  636</span>        <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  637</span>            <span class="keywordflow">return</span> ModeResult(np.array([]), np.array([]))</div>
<div class="line"><span class="lineno">  638</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  639</span>            <span class="comment"># this is tricky to get right; let np.mean do it</span></div>
<div class="line"><span class="lineno">  640</span>            out = np.mean(a, axis=axis, keepdims=keepdims)</div>
<div class="line"><span class="lineno">  641</span>            <span class="keywordflow">return</span> ModeResult(out, out.copy())</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno">  644</span> </div>
<div class="line"><span class="lineno">  645</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno">  646</span> </div>
<div class="line"><span class="lineno">  647</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno">  648</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno">  649</span>        <span class="keywordflow">return</span> mstats_basic.mode(a, axis, _keepdims=keepdims)</div>
<div class="line"><span class="lineno">  650</span> </div>
<div class="line"><span class="lineno">  651</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.issubdtype(a.dtype, np.number):</div>
<div class="line"><span class="lineno">  652</span>        warnings.warn(<span class="stringliteral">&quot;Support for non-numeric arrays has been deprecated &quot;</span></div>
<div class="line"><span class="lineno">  653</span>                      <span class="stringliteral">&quot;as of SciPy 1.9.0 and will be removed in &quot;</span></div>
<div class="line"><span class="lineno">  654</span>                      <span class="stringliteral">&quot;1.11.0. `pandas.DataFrame.mode` can be used instead, &quot;</span></div>
<div class="line"><span class="lineno">  655</span>                      <span class="stringliteral">&quot;see https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html.&quot;</span>,  <span class="comment"># noqa: E501</span></div>
<div class="line"><span class="lineno">  656</span>                      DeprecationWarning, stacklevel=2)</div>
<div class="line"><span class="lineno">  657</span> </div>
<div class="line"><span class="lineno">  658</span>    <span class="keywordflow">if</span> a.dtype == object:</div>
<div class="line"><span class="lineno">  659</span>        <span class="keyword">def </span>_mode1D(a):</div>
<div class="line"><span class="lineno">  660</span>            cntr = Counter(a)</div>
<div class="line"><span class="lineno">  661</span>            mode = max(cntr, key=<span class="keyword">lambda</span> x: cntr[x])</div>
<div class="line"><span class="lineno">  662</span>            <span class="keywordflow">return</span> mode, cntr[mode]</div>
<div class="line"><span class="lineno">  663</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  664</span>        <span class="keyword">def </span>_mode1D(a):</div>
<div class="line"><span class="lineno">  665</span>            vals, cnts = np.unique(a, return_counts=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  666</span>            <span class="keywordflow">return</span> vals[cnts.argmax()], cnts.max()</div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span>    <span class="comment"># np.apply_along_axis will convert the _mode1D tuples to a numpy array,</span></div>
<div class="line"><span class="lineno">  669</span>    <span class="comment"># casting types in the process.</span></div>
<div class="line"><span class="lineno">  670</span>    <span class="comment"># This recreates the results without that issue</span></div>
<div class="line"><span class="lineno">  671</span>    <span class="comment"># View of a, rotated so the requested axis is last</span></div>
<div class="line"><span class="lineno">  672</span>    a_view = np.moveaxis(a, axis, -1)</div>
<div class="line"><span class="lineno">  673</span> </div>
<div class="line"><span class="lineno">  674</span>    inds = np.ndindex(a_view.shape[:-1])</div>
<div class="line"><span class="lineno">  675</span>    modes = np.empty(a_view.shape[:-1], dtype=a.dtype)</div>
<div class="line"><span class="lineno">  676</span>    counts = np.empty(a_view.shape[:-1], dtype=np.int_)</div>
<div class="line"><span class="lineno">  677</span>    <span class="keywordflow">for</span> ind <span class="keywordflow">in</span> inds:</div>
<div class="line"><span class="lineno">  678</span>        modes[ind], counts[ind] = _mode1D(a_view[ind])</div>
<div class="line"><span class="lineno">  679</span> </div>
<div class="line"><span class="lineno">  680</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> keepdims:</div>
<div class="line"><span class="lineno">  681</span>        newshape = list(a.shape)</div>
<div class="line"><span class="lineno">  682</span>        newshape[axis] = 1</div>
<div class="line"><span class="lineno">  683</span>        <span class="keywordflow">return</span> ModeResult(modes.reshape(newshape), counts.reshape(newshape))</div>
<div class="line"><span class="lineno">  684</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  685</span>        <span class="keywordflow">return</span> ModeResult(modes[()], counts[()])</div>
<div class="line"><span class="lineno">  686</span> </div>
<div class="line"><span class="lineno">  687</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaaa153789d51dd95cfb2c8833fcfd60f" name="aaaa153789d51dd95cfb2c8833fcfd60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa153789d51dd95cfb2c8833fcfd60f">&#9670;&#160;</a></span>moment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.moment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>moment</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the nth moment about the mean for a sample.

A moment is a specific quantitative measure of the shape of a set of
points. It is often used to calculate coefficients of skewness and kurtosis
due to its close relationship with them.

Parameters
----------
a : array_like
Input array.
moment : int or array_like of ints, optional
Order of central moment that is returned. Default is 1.
axis : int or None, optional
Axis along which the central moment is computed. Default is 0.
If None, compute over the whole array `a`.
nan_policy : {'propagate', 'raise', 'omit'}, optional
Defines how to handle when input contains nan.
The following options are available (default is 'propagate'):

* 'propagate': returns nan
* 'raise': throws an error
* 'omit': performs the calculations ignoring nan values

Returns
-------
n-th central moment : ndarray or float
The appropriate moment along the given axis or over all values if axis
is None. The denominator for the moment calculation is the number of
observations, no degrees of freedom correction is done.

See Also
--------
kurtosis, skew, describe

Notes
-----
The k-th central moment of a data sample is:

.. math::

m_k = \frac{1}{n} \sum_{i = 1}^n (x_i - \bar{x})^k

Where n is the number of samples and x-bar is the mean. This function uses
exponentiation by squares [1]_ for efficiency.

Note that, if `a` is an empty array (``a.size == 0``), array `moment` with
one element (`moment.size == 1`) is treated the same as scalar `moment`
(``np.isscalar(moment)``). This might produce arrays of unexpected shape.

References
----------
.. [1] https://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms

Examples
--------
&gt;&gt;&gt; from scipy.stats import moment
&gt;&gt;&gt; moment([1, 2, 3, 4, 5], moment=1)
0.0
&gt;&gt;&gt; moment([1, 2, 3, 4, 5], moment=2)
2.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 1107</span><span class="keyword">def </span>moment(a, moment=1, axis=0, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 1108</span>    <span class="stringliteral">r&quot;&quot;&quot;Calculate the nth moment about the mean for a sample.</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    A moment is a specific quantitative measure of the shape of a set of</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    points. It is often used to calculate coefficients of skewness and kurtosis</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">    due to its close relationship with them.</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">       Input array.</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    moment : int or array_like of ints, optional</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">       Order of central moment that is returned. Default is 1.</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">       Axis along which the central moment is computed. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">       If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    n-th central moment : ndarray or float</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">       The appropriate moment along the given axis or over all values if axis</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">       is None. The denominator for the moment calculation is the number of</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">       observations, no degrees of freedom correction is done.</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    kurtosis, skew, describe</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">    The k-th central moment of a data sample is:</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">        m_k = \frac{1}{n} \sum_{i = 1}^n (x_i - \bar{x})^k</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    Where n is the number of samples and x-bar is the mean. This function uses</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    exponentiation by squares [1]_ for efficiency.</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    Note that, if `a` is an empty array (``a.size == 0``), array `moment` with</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    one element (`moment.size == 1`) is treated the same as scalar `moment`</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    (``np.isscalar(moment)``). This might produce arrays of unexpected shape.</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    .. [1] https://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import moment</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    &gt;&gt;&gt; moment([1, 2, 3, 4, 5], moment=1)</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    &gt;&gt;&gt; moment([1, 2, 3, 4, 5], moment=2)</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    2.0</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1170</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 1171</span> </div>
<div class="line"><span class="lineno"> 1172</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 1173</span> </div>
<div class="line"><span class="lineno"> 1174</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 1175</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 1176</span>        <span class="keywordflow">return</span> mstats_basic.moment(a, moment, axis)</div>
<div class="line"><span class="lineno"> 1177</span> </div>
<div class="line"><span class="lineno"> 1178</span>    <span class="comment"># for array_like moment input, return a value for each.</span></div>
<div class="line"><span class="lineno"> 1179</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isscalar(moment):</div>
<div class="line"><span class="lineno"> 1180</span>        mean = a.mean(axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1181</span>        mmnt = [_moment(a, i, axis, mean=mean) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> moment]</div>
<div class="line"><span class="lineno"> 1182</span>        <span class="keywordflow">return</span> np.array(mmnt)</div>
<div class="line"><span class="lineno"> 1183</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1184</span>        <span class="keywordflow">return</span> _moment(a, moment, axis)</div>
<div class="line"><span class="lineno"> 1185</span> </div>
<div class="line"><span class="lineno"> 1186</span> </div>
<div class="line"><span class="lineno"> 1187</span><span class="comment"># Moment with optional pre-computed mean, equal to a.mean(axis, keepdims=True)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5e6d4b63720d080eab70d14f43d74cd" name="aa5e6d4b63720d080eab70d14f43d74cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e6d4b63720d080eab70d14f43d74cd">&#9670;&#160;</a></span>multiscale_graphcorr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.multiscale_graphcorr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_distance</em> = <code><a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ac06697b36a6f3c2567d9e514a9147d59">_euclidean_dist</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reps</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>workers</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>is_twosamp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the Multiscale Graph Correlation (MGC) test statistic.

Specifically, for each point, MGC finds the :math:`k`-nearest neighbors for
one property (e.g. cloud density), and the :math:`l`-nearest neighbors for
the other property (e.g. grass wetness) [1]_. This pair :math:`(k, l)` is
called the "scale". A priori, however, it is not know which scales will be
most informative. So, MGC computes all distance pairs, and then efficiently
computes the distance correlations for all scales. The local correlations
illustrate which scales are relatively informative about the relationship.
The key, therefore, to successfully discover and decipher relationships
between disparate data modalities is to adaptively determine which scales
are the most informative, and the geometric implication for the most
informative scales. Doing so not only provides an estimate of whether the
modalities are related, but also provides insight into how the
determination was made. This is especially important in high-dimensional
data, where simple visualizations do not reveal relationships to the
unaided human eye. Characterizations of this implementation in particular
have been derived from and benchmarked within in [2]_.

Parameters
----------
x, y : ndarray
    If ``x`` and ``y`` have shapes ``(n, p)`` and ``(n, q)`` where `n` is
    the number of samples and `p` and `q` are the number of dimensions,
    then the MGC independence test will be run.  Alternatively, ``x`` and
    ``y`` can have shapes ``(n, n)`` if they are distance or similarity
    matrices, and ``compute_distance`` must be sent to ``None``. If ``x``
    and ``y`` have shapes ``(n, p)`` and ``(m, p)``, an unpaired
    two-sample MGC test will be run.
compute_distance : callable, optional
    A function that computes the distance or similarity among the samples
    within each data matrix. Set to ``None`` if ``x`` and ``y`` are
    already distance matrices. The default uses the euclidean norm metric.
    If you are calling a custom function, either create the distance
    matrix before-hand or create a function of the form
    ``compute_distance(x)`` where `x` is the data matrix for which
    pairwise distances are calculated.
reps : int, optional
    The number of replications used to estimate the null when using the
    permutation test. The default is ``1000``.
workers : int or map-like callable, optional
    If ``workers`` is an int the population is subdivided into ``workers``
    sections and evaluated in parallel (uses ``multiprocessing.Pool
    &lt;multiprocessing&gt;``). Supply ``-1`` to use all cores available to the
    Process. Alternatively supply a map-like callable, such as
    ``multiprocessing.Pool.map`` for evaluating the p-value in parallel.
    This evaluation is carried out as ``workers(func, iterable)``.
    Requires that `func` be pickleable. The default is ``1``.
is_twosamp : bool, optional
    If `True`, a two sample test will be run. If ``x`` and ``y`` have
    shapes ``(n, p)`` and ``(m, p)``, this optional will be overridden and
    set to ``True``. Set to ``True`` if ``x`` and ``y`` both have shapes
    ``(n, p)`` and a two sample test is desired. The default is ``False``.
    Note that this will not run if inputs are distance matrices.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.

Returns
-------
stat : float
    The sample MGC test statistic within `[-1, 1]`.
pvalue : float
    The p-value obtained via permutation.
mgc_dict : dict
    Contains additional useful additional returns containing the following
    keys:

        - mgc_map : ndarray
            A 2D representation of the latent geometry of the relationship.
            of the relationship.
        - opt_scale : (int, int)
            The estimated optimal scale as a `(x, y)` pair.
        - null_dist : list
            The null distribution derived from the permuted matrices

See Also
--------
pearsonr : Pearson correlation coefficient and p-value for testing
           non-correlation.
kendalltau : Calculates Kendall's tau.
spearmanr : Calculates a Spearman rank-order correlation coefficient.

Notes
-----
A description of the process of MGC and applications on neuroscience data
can be found in [1]_. It is performed using the following steps:

#. Two distance matrices :math:`D^X` and :math:`D^Y` are computed and
   modified to be mean zero columnwise. This results in two
   :math:`n \times n` distance matrices :math:`A` and :math:`B` (the
   centering and unbiased modification) [3]_.

#. For all values :math:`k` and :math:`l` from :math:`1, ..., n`,

   * The :math:`k`-nearest neighbor and :math:`l`-nearest neighbor graphs
     are calculated for each property. Here, :math:`G_k (i, j)` indicates
     the :math:`k`-smallest values of the :math:`i`-th row of :math:`A`
     and :math:`H_l (i, j)` indicates the :math:`l` smallested values of
     the :math:`i`-th row of :math:`B`

   * Let :math:`\circ` denotes the entry-wise matrix product, then local
     correlations are summed and normalized using the following statistic:

.. math::

    c^{kl} = \frac{\sum_{ij} A G_k B H_l}
                  {\sqrt{\sum_{ij} A^2 G_k \times \sum_{ij} B^2 H_l}}

#. The MGC test statistic is the smoothed optimal local correlation of
   :math:`\{ c^{kl} \}`. Denote the smoothing operation as :math:`R(\cdot)`
   (which essentially set all isolated large correlations) as 0 and
   connected large correlations the same as before, see [3]_.) MGC is,

.. math::

    MGC_n (x, y) = \max_{(k, l)} R \left(c^{kl} \left( x_n, y_n \right)
                                                \right)

The test statistic returns a value between :math:`(-1, 1)` since it is
normalized.

The p-value returned is calculated using a permutation test. This process
is completed by first randomly permuting :math:`y` to estimate the null
distribution and then calculating the probability of observing a test
statistic, under the null, at least as extreme as the observed test
statistic.

MGC requires at least 5 samples to run with reliable results. It can also
handle high-dimensional data sets.
In addition, by manipulating the input data matrices, the two-sample
testing problem can be reduced to the independence testing problem [4]_.
Given sample data :math:`U` and :math:`V` of sizes :math:`p \times n`
:math:`p \times m`, data matrix :math:`X` and :math:`Y` can be created as
follows:

.. math::

    X = [U | V] \in \mathcal{R}^{p \times (n + m)}
    Y = [0_{1 \times n} | 1_{1 \times m}] \in \mathcal{R}^{(n + m)}

Then, the MGC statistic can be calculated as normal. This methodology can
be extended to similar tests such as distance correlation [4]_.

.. versionadded:: 1.4.0

References
----------
.. [1] Vogelstein, J. T., Bridgeford, E. W., Wang, Q., Priebe, C. E.,
       Maggioni, M., &amp; Shen, C. (2019). Discovering and deciphering
       relationships across disparate data modalities. ELife.
.. [2] Panda, S., Palaniappan, S., Xiong, J., Swaminathan, A.,
       Ramachandran, S., Bridgeford, E. W., ... Vogelstein, J. T. (2019).
       mgcpy: A Comprehensive High Dimensional Independence Testing Python
       Package. :arXiv:`1907.02088`
.. [3] Shen, C., Priebe, C.E., &amp; Vogelstein, J. T. (2019). From distance
       correlation to multiscale graph correlation. Journal of the American
       Statistical Association.
.. [4] Shen, C. &amp; Vogelstein, J. T. (2018). The Exact Equivalence of
       Distance and Kernel Methods for Hypothesis Testing.
       :arXiv:`1806.05514`

Examples
--------
&gt;&gt;&gt; from scipy.stats import multiscale_graphcorr
&gt;&gt;&gt; x = np.arange(100)
&gt;&gt;&gt; y = x
&gt;&gt;&gt; stat, pvalue, _ = multiscale_graphcorr(x, y, workers=-1)
&gt;&gt;&gt; '%.1f, %.3f' % (stat, pvalue)
'1.0, 0.001'

Alternatively,

&gt;&gt;&gt; x = np.arange(100)
&gt;&gt;&gt; y = x
&gt;&gt;&gt; mgc = multiscale_graphcorr(x, y)
&gt;&gt;&gt; '%.1f, %.3f' % (mgc.stat, mgc.pvalue)
'1.0, 0.001'

To run an unpaired two-sample test,

&gt;&gt;&gt; x = np.arange(100)
&gt;&gt;&gt; y = np.arange(79)
&gt;&gt;&gt; mgc = multiscale_graphcorr(x, y)
&gt;&gt;&gt; '%.3f, %.2f' % (mgc.stat, mgc.pvalue)  # doctest: +SKIP
'0.033, 0.02'

or, if shape of the inputs are the same,

&gt;&gt;&gt; x = np.arange(100)
&gt;&gt;&gt; y = x
&gt;&gt;&gt; mgc = multiscale_graphcorr(x, y, is_twosamp=True)
&gt;&gt;&gt; '%.3f, %.1f' % (mgc.stat, mgc.pvalue)  # doctest: +SKIP
'-0.008, 1.0'</pre> <div class="fragment"><div class="line"><span class="lineno"> 5492</span>                         workers=1, is_twosamp=<span class="keyword">False</span>, random_state=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 5493</span>    <span class="stringliteral">r&quot;&quot;&quot;Computes the Multiscale Graph Correlation (MGC) test statistic.</span></div>
<div class="line"><span class="lineno"> 5494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5495</span><span class="stringliteral">    Specifically, for each point, MGC finds the :math:`k`-nearest neighbors for</span></div>
<div class="line"><span class="lineno"> 5496</span><span class="stringliteral">    one property (e.g. cloud density), and the :math:`l`-nearest neighbors for</span></div>
<div class="line"><span class="lineno"> 5497</span><span class="stringliteral">    the other property (e.g. grass wetness) [1]_. This pair :math:`(k, l)` is</span></div>
<div class="line"><span class="lineno"> 5498</span><span class="stringliteral">    called the &quot;scale&quot;. A priori, however, it is not know which scales will be</span></div>
<div class="line"><span class="lineno"> 5499</span><span class="stringliteral">    most informative. So, MGC computes all distance pairs, and then efficiently</span></div>
<div class="line"><span class="lineno"> 5500</span><span class="stringliteral">    computes the distance correlations for all scales. The local correlations</span></div>
<div class="line"><span class="lineno"> 5501</span><span class="stringliteral">    illustrate which scales are relatively informative about the relationship.</span></div>
<div class="line"><span class="lineno"> 5502</span><span class="stringliteral">    The key, therefore, to successfully discover and decipher relationships</span></div>
<div class="line"><span class="lineno"> 5503</span><span class="stringliteral">    between disparate data modalities is to adaptively determine which scales</span></div>
<div class="line"><span class="lineno"> 5504</span><span class="stringliteral">    are the most informative, and the geometric implication for the most</span></div>
<div class="line"><span class="lineno"> 5505</span><span class="stringliteral">    informative scales. Doing so not only provides an estimate of whether the</span></div>
<div class="line"><span class="lineno"> 5506</span><span class="stringliteral">    modalities are related, but also provides insight into how the</span></div>
<div class="line"><span class="lineno"> 5507</span><span class="stringliteral">    determination was made. This is especially important in high-dimensional</span></div>
<div class="line"><span class="lineno"> 5508</span><span class="stringliteral">    data, where simple visualizations do not reveal relationships to the</span></div>
<div class="line"><span class="lineno"> 5509</span><span class="stringliteral">    unaided human eye. Characterizations of this implementation in particular</span></div>
<div class="line"><span class="lineno"> 5510</span><span class="stringliteral">    have been derived from and benchmarked within in [2]_.</span></div>
<div class="line"><span class="lineno"> 5511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5512</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5513</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5514</span><span class="stringliteral">    x, y : ndarray</span></div>
<div class="line"><span class="lineno"> 5515</span><span class="stringliteral">        If ``x`` and ``y`` have shapes ``(n, p)`` and ``(n, q)`` where `n` is</span></div>
<div class="line"><span class="lineno"> 5516</span><span class="stringliteral">        the number of samples and `p` and `q` are the number of dimensions,</span></div>
<div class="line"><span class="lineno"> 5517</span><span class="stringliteral">        then the MGC independence test will be run.  Alternatively, ``x`` and</span></div>
<div class="line"><span class="lineno"> 5518</span><span class="stringliteral">        ``y`` can have shapes ``(n, n)`` if they are distance or similarity</span></div>
<div class="line"><span class="lineno"> 5519</span><span class="stringliteral">        matrices, and ``compute_distance`` must be sent to ``None``. If ``x``</span></div>
<div class="line"><span class="lineno"> 5520</span><span class="stringliteral">        and ``y`` have shapes ``(n, p)`` and ``(m, p)``, an unpaired</span></div>
<div class="line"><span class="lineno"> 5521</span><span class="stringliteral">        two-sample MGC test will be run.</span></div>
<div class="line"><span class="lineno"> 5522</span><span class="stringliteral">    compute_distance : callable, optional</span></div>
<div class="line"><span class="lineno"> 5523</span><span class="stringliteral">        A function that computes the distance or similarity among the samples</span></div>
<div class="line"><span class="lineno"> 5524</span><span class="stringliteral">        within each data matrix. Set to ``None`` if ``x`` and ``y`` are</span></div>
<div class="line"><span class="lineno"> 5525</span><span class="stringliteral">        already distance matrices. The default uses the euclidean norm metric.</span></div>
<div class="line"><span class="lineno"> 5526</span><span class="stringliteral">        If you are calling a custom function, either create the distance</span></div>
<div class="line"><span class="lineno"> 5527</span><span class="stringliteral">        matrix before-hand or create a function of the form</span></div>
<div class="line"><span class="lineno"> 5528</span><span class="stringliteral">        ``compute_distance(x)`` where `x` is the data matrix for which</span></div>
<div class="line"><span class="lineno"> 5529</span><span class="stringliteral">        pairwise distances are calculated.</span></div>
<div class="line"><span class="lineno"> 5530</span><span class="stringliteral">    reps : int, optional</span></div>
<div class="line"><span class="lineno"> 5531</span><span class="stringliteral">        The number of replications used to estimate the null when using the</span></div>
<div class="line"><span class="lineno"> 5532</span><span class="stringliteral">        permutation test. The default is ``1000``.</span></div>
<div class="line"><span class="lineno"> 5533</span><span class="stringliteral">    workers : int or map-like callable, optional</span></div>
<div class="line"><span class="lineno"> 5534</span><span class="stringliteral">        If ``workers`` is an int the population is subdivided into ``workers``</span></div>
<div class="line"><span class="lineno"> 5535</span><span class="stringliteral">        sections and evaluated in parallel (uses ``multiprocessing.Pool</span></div>
<div class="line"><span class="lineno"> 5536</span><span class="stringliteral">        &lt;multiprocessing&gt;``). Supply ``-1`` to use all cores available to the</span></div>
<div class="line"><span class="lineno"> 5537</span><span class="stringliteral">        Process. Alternatively supply a map-like callable, such as</span></div>
<div class="line"><span class="lineno"> 5538</span><span class="stringliteral">        ``multiprocessing.Pool.map`` for evaluating the p-value in parallel.</span></div>
<div class="line"><span class="lineno"> 5539</span><span class="stringliteral">        This evaluation is carried out as ``workers(func, iterable)``.</span></div>
<div class="line"><span class="lineno"> 5540</span><span class="stringliteral">        Requires that `func` be pickleable. The default is ``1``.</span></div>
<div class="line"><span class="lineno"> 5541</span><span class="stringliteral">    is_twosamp : bool, optional</span></div>
<div class="line"><span class="lineno"> 5542</span><span class="stringliteral">        If `True`, a two sample test will be run. If ``x`` and ``y`` have</span></div>
<div class="line"><span class="lineno"> 5543</span><span class="stringliteral">        shapes ``(n, p)`` and ``(m, p)``, this optional will be overridden and</span></div>
<div class="line"><span class="lineno"> 5544</span><span class="stringliteral">        set to ``True``. Set to ``True`` if ``x`` and ``y`` both have shapes</span></div>
<div class="line"><span class="lineno"> 5545</span><span class="stringliteral">        ``(n, p)`` and a two sample test is desired. The default is ``False``.</span></div>
<div class="line"><span class="lineno"> 5546</span><span class="stringliteral">        Note that this will not run if inputs are distance matrices.</span></div>
<div class="line"><span class="lineno"> 5547</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno"> 5548</span><span class="stringliteral">                    `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno"> 5549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5550</span><span class="stringliteral">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno"> 5551</span><span class="stringliteral">        singleton is used.</span></div>
<div class="line"><span class="lineno"> 5552</span><span class="stringliteral">        If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno"> 5553</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno"> 5554</span><span class="stringliteral">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno"> 5555</span><span class="stringliteral">        that instance is used.</span></div>
<div class="line"><span class="lineno"> 5556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5557</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5558</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5559</span><span class="stringliteral">    stat : float</span></div>
<div class="line"><span class="lineno"> 5560</span><span class="stringliteral">        The sample MGC test statistic within `[-1, 1]`.</span></div>
<div class="line"><span class="lineno"> 5561</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 5562</span><span class="stringliteral">        The p-value obtained via permutation.</span></div>
<div class="line"><span class="lineno"> 5563</span><span class="stringliteral">    mgc_dict : dict</span></div>
<div class="line"><span class="lineno"> 5564</span><span class="stringliteral">        Contains additional useful additional returns containing the following</span></div>
<div class="line"><span class="lineno"> 5565</span><span class="stringliteral">        keys:</span></div>
<div class="line"><span class="lineno"> 5566</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5567</span><span class="stringliteral">            - mgc_map : ndarray</span></div>
<div class="line"><span class="lineno"> 5568</span><span class="stringliteral">                A 2D representation of the latent geometry of the relationship.</span></div>
<div class="line"><span class="lineno"> 5569</span><span class="stringliteral">                of the relationship.</span></div>
<div class="line"><span class="lineno"> 5570</span><span class="stringliteral">            - opt_scale : (int, int)</span></div>
<div class="line"><span class="lineno"> 5571</span><span class="stringliteral">                The estimated optimal scale as a `(x, y)` pair.</span></div>
<div class="line"><span class="lineno"> 5572</span><span class="stringliteral">            - null_dist : list</span></div>
<div class="line"><span class="lineno"> 5573</span><span class="stringliteral">                The null distribution derived from the permuted matrices</span></div>
<div class="line"><span class="lineno"> 5574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5575</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 5576</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5577</span><span class="stringliteral">    pearsonr : Pearson correlation coefficient and p-value for testing</span></div>
<div class="line"><span class="lineno"> 5578</span><span class="stringliteral">               non-correlation.</span></div>
<div class="line"><span class="lineno"> 5579</span><span class="stringliteral">    kendalltau : Calculates Kendall&#39;s tau.</span></div>
<div class="line"><span class="lineno"> 5580</span><span class="stringliteral">    spearmanr : Calculates a Spearman rank-order correlation coefficient.</span></div>
<div class="line"><span class="lineno"> 5581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5582</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 5583</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 5584</span><span class="stringliteral">    A description of the process of MGC and applications on neuroscience data</span></div>
<div class="line"><span class="lineno"> 5585</span><span class="stringliteral">    can be found in [1]_. It is performed using the following steps:</span></div>
<div class="line"><span class="lineno"> 5586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5587</span><span class="stringliteral">    #. Two distance matrices :math:`D^X` and :math:`D^Y` are computed and</span></div>
<div class="line"><span class="lineno"> 5588</span><span class="stringliteral">       modified to be mean zero columnwise. This results in two</span></div>
<div class="line"><span class="lineno"> 5589</span><span class="stringliteral">       :math:`n \times n` distance matrices :math:`A` and :math:`B` (the</span></div>
<div class="line"><span class="lineno"> 5590</span><span class="stringliteral">       centering and unbiased modification) [3]_.</span></div>
<div class="line"><span class="lineno"> 5591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5592</span><span class="stringliteral">    #. For all values :math:`k` and :math:`l` from :math:`1, ..., n`,</span></div>
<div class="line"><span class="lineno"> 5593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5594</span><span class="stringliteral">       * The :math:`k`-nearest neighbor and :math:`l`-nearest neighbor graphs</span></div>
<div class="line"><span class="lineno"> 5595</span><span class="stringliteral">         are calculated for each property. Here, :math:`G_k (i, j)` indicates</span></div>
<div class="line"><span class="lineno"> 5596</span><span class="stringliteral">         the :math:`k`-smallest values of the :math:`i`-th row of :math:`A`</span></div>
<div class="line"><span class="lineno"> 5597</span><span class="stringliteral">         and :math:`H_l (i, j)` indicates the :math:`l` smallested values of</span></div>
<div class="line"><span class="lineno"> 5598</span><span class="stringliteral">         the :math:`i`-th row of :math:`B`</span></div>
<div class="line"><span class="lineno"> 5599</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5600</span><span class="stringliteral">       * Let :math:`\circ` denotes the entry-wise matrix product, then local</span></div>
<div class="line"><span class="lineno"> 5601</span><span class="stringliteral">         correlations are summed and normalized using the following statistic:</span></div>
<div class="line"><span class="lineno"> 5602</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5603</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 5604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5605</span><span class="stringliteral">        c^{kl} = \frac{\sum_{ij} A G_k B H_l}</span></div>
<div class="line"><span class="lineno"> 5606</span><span class="stringliteral">                      {\sqrt{\sum_{ij} A^2 G_k \times \sum_{ij} B^2 H_l}}</span></div>
<div class="line"><span class="lineno"> 5607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5608</span><span class="stringliteral">    #. The MGC test statistic is the smoothed optimal local correlation of</span></div>
<div class="line"><span class="lineno"> 5609</span><span class="stringliteral">       :math:`\{ c^{kl} \}`. Denote the smoothing operation as :math:`R(\cdot)`</span></div>
<div class="line"><span class="lineno"> 5610</span><span class="stringliteral">       (which essentially set all isolated large correlations) as 0 and</span></div>
<div class="line"><span class="lineno"> 5611</span><span class="stringliteral">       connected large correlations the same as before, see [3]_.) MGC is,</span></div>
<div class="line"><span class="lineno"> 5612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5613</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 5614</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5615</span><span class="stringliteral">        MGC_n (x, y) = \max_{(k, l)} R \left(c^{kl} \left( x_n, y_n \right)</span></div>
<div class="line"><span class="lineno"> 5616</span><span class="stringliteral">                                                    \right)</span></div>
<div class="line"><span class="lineno"> 5617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5618</span><span class="stringliteral">    The test statistic returns a value between :math:`(-1, 1)` since it is</span></div>
<div class="line"><span class="lineno"> 5619</span><span class="stringliteral">    normalized.</span></div>
<div class="line"><span class="lineno"> 5620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5621</span><span class="stringliteral">    The p-value returned is calculated using a permutation test. This process</span></div>
<div class="line"><span class="lineno"> 5622</span><span class="stringliteral">    is completed by first randomly permuting :math:`y` to estimate the null</span></div>
<div class="line"><span class="lineno"> 5623</span><span class="stringliteral">    distribution and then calculating the probability of observing a test</span></div>
<div class="line"><span class="lineno"> 5624</span><span class="stringliteral">    statistic, under the null, at least as extreme as the observed test</span></div>
<div class="line"><span class="lineno"> 5625</span><span class="stringliteral">    statistic.</span></div>
<div class="line"><span class="lineno"> 5626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5627</span><span class="stringliteral">    MGC requires at least 5 samples to run with reliable results. It can also</span></div>
<div class="line"><span class="lineno"> 5628</span><span class="stringliteral">    handle high-dimensional data sets.</span></div>
<div class="line"><span class="lineno"> 5629</span><span class="stringliteral">    In addition, by manipulating the input data matrices, the two-sample</span></div>
<div class="line"><span class="lineno"> 5630</span><span class="stringliteral">    testing problem can be reduced to the independence testing problem [4]_.</span></div>
<div class="line"><span class="lineno"> 5631</span><span class="stringliteral">    Given sample data :math:`U` and :math:`V` of sizes :math:`p \times n`</span></div>
<div class="line"><span class="lineno"> 5632</span><span class="stringliteral">    :math:`p \times m`, data matrix :math:`X` and :math:`Y` can be created as</span></div>
<div class="line"><span class="lineno"> 5633</span><span class="stringliteral">    follows:</span></div>
<div class="line"><span class="lineno"> 5634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5635</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 5636</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5637</span><span class="stringliteral">        X = [U | V] \in \mathcal{R}^{p \times (n + m)}</span></div>
<div class="line"><span class="lineno"> 5638</span><span class="stringliteral">        Y = [0_{1 \times n} | 1_{1 \times m}] \in \mathcal{R}^{(n + m)}</span></div>
<div class="line"><span class="lineno"> 5639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5640</span><span class="stringliteral">    Then, the MGC statistic can be calculated as normal. This methodology can</span></div>
<div class="line"><span class="lineno"> 5641</span><span class="stringliteral">    be extended to similar tests such as distance correlation [4]_.</span></div>
<div class="line"><span class="lineno"> 5642</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5643</span><span class="stringliteral">    .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 5644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5645</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 5646</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5647</span><span class="stringliteral">    .. [1] Vogelstein, J. T., Bridgeford, E. W., Wang, Q., Priebe, C. E.,</span></div>
<div class="line"><span class="lineno"> 5648</span><span class="stringliteral">           Maggioni, M., &amp; Shen, C. (2019). Discovering and deciphering</span></div>
<div class="line"><span class="lineno"> 5649</span><span class="stringliteral">           relationships across disparate data modalities. ELife.</span></div>
<div class="line"><span class="lineno"> 5650</span><span class="stringliteral">    .. [2] Panda, S., Palaniappan, S., Xiong, J., Swaminathan, A.,</span></div>
<div class="line"><span class="lineno"> 5651</span><span class="stringliteral">           Ramachandran, S., Bridgeford, E. W., ... Vogelstein, J. T. (2019).</span></div>
<div class="line"><span class="lineno"> 5652</span><span class="stringliteral">           mgcpy: A Comprehensive High Dimensional Independence Testing Python</span></div>
<div class="line"><span class="lineno"> 5653</span><span class="stringliteral">           Package. :arXiv:`1907.02088`</span></div>
<div class="line"><span class="lineno"> 5654</span><span class="stringliteral">    .. [3] Shen, C., Priebe, C.E., &amp; Vogelstein, J. T. (2019). From distance</span></div>
<div class="line"><span class="lineno"> 5655</span><span class="stringliteral">           correlation to multiscale graph correlation. Journal of the American</span></div>
<div class="line"><span class="lineno"> 5656</span><span class="stringliteral">           Statistical Association.</span></div>
<div class="line"><span class="lineno"> 5657</span><span class="stringliteral">    .. [4] Shen, C. &amp; Vogelstein, J. T. (2018). The Exact Equivalence of</span></div>
<div class="line"><span class="lineno"> 5658</span><span class="stringliteral">           Distance and Kernel Methods for Hypothesis Testing.</span></div>
<div class="line"><span class="lineno"> 5659</span><span class="stringliteral">           :arXiv:`1806.05514`</span></div>
<div class="line"><span class="lineno"> 5660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5661</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 5662</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5663</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import multiscale_graphcorr</span></div>
<div class="line"><span class="lineno"> 5664</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(100)</span></div>
<div class="line"><span class="lineno"> 5665</span><span class="stringliteral">    &gt;&gt;&gt; y = x</span></div>
<div class="line"><span class="lineno"> 5666</span><span class="stringliteral">    &gt;&gt;&gt; stat, pvalue, _ = multiscale_graphcorr(x, y, workers=-1)</span></div>
<div class="line"><span class="lineno"> 5667</span><span class="stringliteral">    &gt;&gt;&gt; &#39;%.1f, %.3f&#39; % (stat, pvalue)</span></div>
<div class="line"><span class="lineno"> 5668</span><span class="stringliteral">    &#39;1.0, 0.001&#39;</span></div>
<div class="line"><span class="lineno"> 5669</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5670</span><span class="stringliteral">    Alternatively,</span></div>
<div class="line"><span class="lineno"> 5671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5672</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(100)</span></div>
<div class="line"><span class="lineno"> 5673</span><span class="stringliteral">    &gt;&gt;&gt; y = x</span></div>
<div class="line"><span class="lineno"> 5674</span><span class="stringliteral">    &gt;&gt;&gt; mgc = multiscale_graphcorr(x, y)</span></div>
<div class="line"><span class="lineno"> 5675</span><span class="stringliteral">    &gt;&gt;&gt; &#39;%.1f, %.3f&#39; % (mgc.stat, mgc.pvalue)</span></div>
<div class="line"><span class="lineno"> 5676</span><span class="stringliteral">    &#39;1.0, 0.001&#39;</span></div>
<div class="line"><span class="lineno"> 5677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5678</span><span class="stringliteral">    To run an unpaired two-sample test,</span></div>
<div class="line"><span class="lineno"> 5679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5680</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(100)</span></div>
<div class="line"><span class="lineno"> 5681</span><span class="stringliteral">    &gt;&gt;&gt; y = np.arange(79)</span></div>
<div class="line"><span class="lineno"> 5682</span><span class="stringliteral">    &gt;&gt;&gt; mgc = multiscale_graphcorr(x, y)</span></div>
<div class="line"><span class="lineno"> 5683</span><span class="stringliteral">    &gt;&gt;&gt; &#39;%.3f, %.2f&#39; % (mgc.stat, mgc.pvalue)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 5684</span><span class="stringliteral">    &#39;0.033, 0.02&#39;</span></div>
<div class="line"><span class="lineno"> 5685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5686</span><span class="stringliteral">    or, if shape of the inputs are the same,</span></div>
<div class="line"><span class="lineno"> 5687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5688</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(100)</span></div>
<div class="line"><span class="lineno"> 5689</span><span class="stringliteral">    &gt;&gt;&gt; y = x</span></div>
<div class="line"><span class="lineno"> 5690</span><span class="stringliteral">    &gt;&gt;&gt; mgc = multiscale_graphcorr(x, y, is_twosamp=True)</span></div>
<div class="line"><span class="lineno"> 5691</span><span class="stringliteral">    &gt;&gt;&gt; &#39;%.3f, %.1f&#39; % (mgc.stat, mgc.pvalue)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno"> 5692</span><span class="stringliteral">    &#39;-0.008, 1.0&#39;</span></div>
<div class="line"><span class="lineno"> 5693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5694</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5695</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(x, np.ndarray) <span class="keywordflow">or</span> <span class="keywordflow">not</span> isinstance(y, np.ndarray):</div>
<div class="line"><span class="lineno"> 5696</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;x and y must be ndarrays&quot;</span>)</div>
<div class="line"><span class="lineno"> 5697</span> </div>
<div class="line"><span class="lineno"> 5698</span>    <span class="comment"># convert arrays of type (n,) to (n, 1)</span></div>
<div class="line"><span class="lineno"> 5699</span>    <span class="keywordflow">if</span> x.ndim == 1:</div>
<div class="line"><span class="lineno"> 5700</span>        x = x[:, np.newaxis]</div>
<div class="line"><span class="lineno"> 5701</span>    <span class="keywordflow">elif</span> x.ndim != 2:</div>
<div class="line"><span class="lineno"> 5702</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expected a 2-D array `x`, found shape &quot;</span></div>
<div class="line"><span class="lineno"> 5703</span>                         <span class="stringliteral">&quot;{}&quot;</span>.format(x.shape))</div>
<div class="line"><span class="lineno"> 5704</span>    <span class="keywordflow">if</span> y.ndim == 1:</div>
<div class="line"><span class="lineno"> 5705</span>        y = y[:, np.newaxis]</div>
<div class="line"><span class="lineno"> 5706</span>    <span class="keywordflow">elif</span> y.ndim != 2:</div>
<div class="line"><span class="lineno"> 5707</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expected a 2-D array `y`, found shape &quot;</span></div>
<div class="line"><span class="lineno"> 5708</span>                         <span class="stringliteral">&quot;{}&quot;</span>.format(y.shape))</div>
<div class="line"><span class="lineno"> 5709</span> </div>
<div class="line"><span class="lineno"> 5710</span>    nx, px = x.shape</div>
<div class="line"><span class="lineno"> 5711</span>    ny, py = y.shape</div>
<div class="line"><span class="lineno"> 5712</span> </div>
<div class="line"><span class="lineno"> 5713</span>    <span class="comment"># check for NaNs</span></div>
<div class="line"><span class="lineno"> 5714</span>    _contains_nan(x, nan_policy=<span class="stringliteral">&#39;raise&#39;</span>)</div>
<div class="line"><span class="lineno"> 5715</span>    _contains_nan(y, nan_policy=<span class="stringliteral">&#39;raise&#39;</span>)</div>
<div class="line"><span class="lineno"> 5716</span> </div>
<div class="line"><span class="lineno"> 5717</span>    <span class="comment"># check for positive or negative infinity and raise error</span></div>
<div class="line"><span class="lineno"> 5718</span>    <span class="keywordflow">if</span> np.sum(np.isinf(x)) &gt; 0 <span class="keywordflow">or</span> np.sum(np.isinf(y)) &gt; 0:</div>
<div class="line"><span class="lineno"> 5719</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Inputs contain infinities&quot;</span>)</div>
<div class="line"><span class="lineno"> 5720</span> </div>
<div class="line"><span class="lineno"> 5721</span>    <span class="keywordflow">if</span> nx != ny:</div>
<div class="line"><span class="lineno"> 5722</span>        <span class="keywordflow">if</span> px == py:</div>
<div class="line"><span class="lineno"> 5723</span>            <span class="comment"># reshape x and y for two sample testing</span></div>
<div class="line"><span class="lineno"> 5724</span>            is_twosamp = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 5725</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5726</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Shape mismatch, x and y must have shape [n, p] &quot;</span></div>
<div class="line"><span class="lineno"> 5727</span>                             <span class="stringliteral">&quot;and [n, q] or have shape [n, p] and [m, p].&quot;</span>)</div>
<div class="line"><span class="lineno"> 5728</span> </div>
<div class="line"><span class="lineno"> 5729</span>    <span class="keywordflow">if</span> nx &lt; 5 <span class="keywordflow">or</span> ny &lt; 5:</div>
<div class="line"><span class="lineno"> 5730</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;MGC requires at least 5 samples to give reasonable &quot;</span></div>
<div class="line"><span class="lineno"> 5731</span>                         <span class="stringliteral">&quot;results.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5732</span> </div>
<div class="line"><span class="lineno"> 5733</span>    <span class="comment"># convert x and y to float</span></div>
<div class="line"><span class="lineno"> 5734</span>    x = x.astype(np.float64)</div>
<div class="line"><span class="lineno"> 5735</span>    y = y.astype(np.float64)</div>
<div class="line"><span class="lineno"> 5736</span> </div>
<div class="line"><span class="lineno"> 5737</span>    <span class="comment"># check if compute_distance_matrix if a callable()</span></div>
<div class="line"><span class="lineno"> 5738</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(compute_distance) <span class="keywordflow">and</span> compute_distance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5739</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Compute_distance must be a function.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5740</span> </div>
<div class="line"><span class="lineno"> 5741</span>    <span class="comment"># check if number of reps exists, integer, or &gt; 0 (if under 1000 raises</span></div>
<div class="line"><span class="lineno"> 5742</span>    <span class="comment"># warning)</span></div>
<div class="line"><span class="lineno"> 5743</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(reps, int) <span class="keywordflow">or</span> reps &lt; 0:</div>
<div class="line"><span class="lineno"> 5744</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Number of reps must be an integer greater than 0.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5745</span>    <span class="keywordflow">elif</span> reps &lt; 1000:</div>
<div class="line"><span class="lineno"> 5746</span>        msg = (<span class="stringliteral">&quot;The number of replications is low (under 1000), and p-value &quot;</span></div>
<div class="line"><span class="lineno"> 5747</span>               <span class="stringliteral">&quot;calculations may be unreliable. Use the p-value result, with &quot;</span></div>
<div class="line"><span class="lineno"> 5748</span>               <span class="stringliteral">&quot;caution!&quot;</span>)</div>
<div class="line"><span class="lineno"> 5749</span>        warnings.warn(msg, RuntimeWarning)</div>
<div class="line"><span class="lineno"> 5750</span> </div>
<div class="line"><span class="lineno"> 5751</span>    <span class="keywordflow">if</span> is_twosamp:</div>
<div class="line"><span class="lineno"> 5752</span>        <span class="keywordflow">if</span> compute_distance <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5753</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Cannot run if inputs are distance matrices&quot;</span>)</div>
<div class="line"><span class="lineno"> 5754</span>        x, y = _two_sample_transform(x, y)</div>
<div class="line"><span class="lineno"> 5755</span> </div>
<div class="line"><span class="lineno"> 5756</span>    <span class="keywordflow">if</span> compute_distance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5757</span>        <span class="comment"># compute distance matrices for x and y</span></div>
<div class="line"><span class="lineno"> 5758</span>        x = compute_distance(x)</div>
<div class="line"><span class="lineno"> 5759</span>        y = compute_distance(y)</div>
<div class="line"><span class="lineno"> 5760</span> </div>
<div class="line"><span class="lineno"> 5761</span>    <span class="comment"># calculate MGC stat</span></div>
<div class="line"><span class="lineno"> 5762</span>    stat, stat_dict = _mgc_stat(x, y)</div>
<div class="line"><span class="lineno"> 5763</span>    stat_mgc_map = stat_dict[<span class="stringliteral">&quot;stat_mgc_map&quot;</span>]</div>
<div class="line"><span class="lineno"> 5764</span>    opt_scale = stat_dict[<span class="stringliteral">&quot;opt_scale&quot;</span>]</div>
<div class="line"><span class="lineno"> 5765</span> </div>
<div class="line"><span class="lineno"> 5766</span>    <span class="comment"># calculate permutation MGC p-value</span></div>
<div class="line"><span class="lineno"> 5767</span>    pvalue, null_dist = _perm_test(x, y, stat, reps=reps, workers=workers,</div>
<div class="line"><span class="lineno"> 5768</span>                                   random_state=random_state)</div>
<div class="line"><span class="lineno"> 5769</span> </div>
<div class="line"><span class="lineno"> 5770</span>    <span class="comment"># save all stats (other than stat/p-value) in dictionary</span></div>
<div class="line"><span class="lineno"> 5771</span>    mgc_dict = {<span class="stringliteral">&quot;mgc_map&quot;</span>: stat_mgc_map,</div>
<div class="line"><span class="lineno"> 5772</span>                <span class="stringliteral">&quot;opt_scale&quot;</span>: opt_scale,</div>
<div class="line"><span class="lineno"> 5773</span>                <span class="stringliteral">&quot;null_dist&quot;</span>: null_dist}</div>
<div class="line"><span class="lineno"> 5774</span> </div>
<div class="line"><span class="lineno"> 5775</span>    <span class="keywordflow">return</span> MGCResult(stat, pvalue, mgc_dict)</div>
<div class="line"><span class="lineno"> 5776</span> </div>
<div class="line"><span class="lineno"> 5777</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a04cd8218975e527a625046de8cf8004d" name="a04cd8218975e527a625046de8cf8004d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cd8218975e527a625046de8cf8004d">&#9670;&#160;</a></span>normaltest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.normaltest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether a sample differs from a normal distribution.

This function tests the null hypothesis that a sample comes
from a normal distribution.  It is based on D'Agostino and
Pearson's [1]_, [2]_ test that combines skew and kurtosis to
produce an omnibus test of normality.

Parameters
----------
a : array_like
    The array containing the sample to be tested.
axis : int or None, optional
    Axis along which to compute test. Default is 0. If None,
    compute over the whole array `a`.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
statistic : float or array
    ``s^2 + k^2``, where ``s`` is the z-score returned by `skewtest` and
    ``k`` is the z-score returned by `kurtosistest`.
pvalue : float or array
   A 2-sided chi squared probability for the hypothesis test.

References
----------
.. [1] D'Agostino, R. B. (1971), "An omnibus test of normality for
       moderate and large sample size", Biometrika, 58, 341-348

.. [2] D'Agostino, R. and Pearson, E. S. (1973), "Tests for departure from
       normality", Biometrika, 60, 613-622

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; pts = 1000
&gt;&gt;&gt; a = rng.normal(0, 1, size=pts)
&gt;&gt;&gt; b = rng.normal(2, 1, size=pts)
&gt;&gt;&gt; x = np.concatenate((a, b))
&gt;&gt;&gt; k2, p = stats.normaltest(x)
&gt;&gt;&gt; alpha = 1e-3
&gt;&gt;&gt; print("p = {:g}".format(p))
p = 8.4713e-19
&gt;&gt;&gt; if p &lt; alpha:  # null hypothesis: x comes from a normal distribution
...     print("The null hypothesis can be rejected")
... else:
...     print("The null hypothesis cannot be rejected")
The null hypothesis can be rejected</pre> <div class="fragment"><div class="line"><span class="lineno"> 1802</span><span class="keyword">def </span>normaltest(a, axis=0, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 1803</span>    <span class="stringliteral">&quot;&quot;&quot;Test whether a sample differs from a normal distribution.</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">    This function tests the null hypothesis that a sample comes</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    from a normal distribution.  It is based on D&#39;Agostino and</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">    Pearson&#39;s [1]_, [2]_ test that combines skew and kurtosis to</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">    produce an omnibus test of normality.</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral">        The array containing the sample to be tested.</span></div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">        Axis along which to compute test. Default is 0. If None,</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">        compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral">    statistic : float or array</span></div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">        ``s^2 + k^2``, where ``s`` is the z-score returned by `skewtest` and</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        ``k`` is the z-score returned by `kurtosistest`.</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    pvalue : float or array</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">       A 2-sided chi squared probability for the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral">    .. [1] D&#39;Agostino, R. B. (1971), &quot;An omnibus test of normality for</span></div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">           moderate and large sample size&quot;, Biometrika, 58, 341-348</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">    .. [2] D&#39;Agostino, R. and Pearson, E. S. (1973), &quot;Tests for departure from</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">           normality&quot;, Biometrika, 60, 613-622</span></div>
<div class="line"><span class="lineno"> 1840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1841</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1842</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1843</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1844</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1845</span><span class="stringliteral">    &gt;&gt;&gt; pts = 1000</span></div>
<div class="line"><span class="lineno"> 1846</span><span class="stringliteral">    &gt;&gt;&gt; a = rng.normal(0, 1, size=pts)</span></div>
<div class="line"><span class="lineno"> 1847</span><span class="stringliteral">    &gt;&gt;&gt; b = rng.normal(2, 1, size=pts)</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">    &gt;&gt;&gt; x = np.concatenate((a, b))</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">    &gt;&gt;&gt; k2, p = stats.normaltest(x)</span></div>
<div class="line"><span class="lineno"> 1850</span><span class="stringliteral">    &gt;&gt;&gt; alpha = 1e-3</span></div>
<div class="line"><span class="lineno"> 1851</span><span class="stringliteral">    &gt;&gt;&gt; print(&quot;p = {:g}&quot;.format(p))</span></div>
<div class="line"><span class="lineno"> 1852</span><span class="stringliteral">    p = 8.4713e-19</span></div>
<div class="line"><span class="lineno"> 1853</span><span class="stringliteral">    &gt;&gt;&gt; if p &lt; alpha:  # null hypothesis: x comes from a normal distribution</span></div>
<div class="line"><span class="lineno"> 1854</span><span class="stringliteral">    ...     print(&quot;The null hypothesis can be rejected&quot;)</span></div>
<div class="line"><span class="lineno"> 1855</span><span class="stringliteral">    ... else:</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">    ...     print(&quot;The null hypothesis cannot be rejected&quot;)</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral">    The null hypothesis can be rejected</span></div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1860</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 1861</span> </div>
<div class="line"><span class="lineno"> 1862</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 1863</span> </div>
<div class="line"><span class="lineno"> 1864</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 1865</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 1866</span>        <span class="keywordflow">return</span> mstats_basic.normaltest(a, axis)</div>
<div class="line"><span class="lineno"> 1867</span> </div>
<div class="line"><span class="lineno"> 1868</span>    s, _ = skewtest(a, axis)</div>
<div class="line"><span class="lineno"> 1869</span>    k, _ = kurtosistest(a, axis)</div>
<div class="line"><span class="lineno"> 1870</span>    k2 = s*s + k*k</div>
<div class="line"><span class="lineno"> 1871</span> </div>
<div class="line"><span class="lineno"> 1872</span>    <span class="keywordflow">return</span> NormaltestResult(k2, distributions.chi2.sf(k2, 2))</div>
<div class="line"><span class="lineno"> 1873</span> </div>
<div class="line"><span class="lineno"> 1874</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa080af52b52bdc1e1998e5f15eef174d" name="aa080af52b52bdc1e1998e5f15eef174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa080af52b52bdc1e1998e5f15eef174d">&#9670;&#160;</a></span>obrientransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.obrientransform </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VARIABILITY FUNCTIONS #. </p>
<pre class="fragment">Compute the O'Brien transform on input data (any number of arrays).

Used to test for homogeneity of variance prior to running one-way stats.
Each array in ``*samples`` is one level of a factor.
If `f_oneway` is run on the transformed data and found significant,
the variances are unequal.  From Maxwell and Delaney [1]_, p.112.

Parameters
----------
sample1, sample2, ... : array_like
    Any number of arrays.

Returns
-------
obrientransform : ndarray
    Transformed data for use in an ANOVA.  The first dimension
    of the result corresponds to the sequence of transformed
    arrays.  If the arrays given are all 1-D of the same length,
    the return value is a 2-D array; otherwise it is a 1-D array
    of type object, with each element being an ndarray.

References
----------
.. [1] S. E. Maxwell and H. D. Delaney, "Designing Experiments and
       Analyzing Data: A Model Comparison Perspective", Wadsworth, 1990.

Examples
--------
We'll test the following data sets for differences in their variance.

&gt;&gt;&gt; x = [10, 11, 13, 9, 7, 12, 12, 9, 10]
&gt;&gt;&gt; y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15]

Apply the O'Brien transform to the data.

&gt;&gt;&gt; from scipy.stats import obrientransform
&gt;&gt;&gt; tx, ty = obrientransform(x, y)

Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the
transformed data.

&gt;&gt;&gt; from scipy.stats import f_oneway
&gt;&gt;&gt; F, p = f_oneway(tx, ty)
&gt;&gt;&gt; p
0.1314139477040335

If we require that ``p &lt; 0.05`` for significance, we cannot conclude
that the variances are different.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2474</span><span class="keyword">def </span>obrientransform(*samples):</div>
<div class="line"><span class="lineno"> 2475</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the O&#39;Brien transform on input data (any number of arrays).</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral">    Used to test for homogeneity of variance prior to running one-way stats.</span></div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">    Each array in ``*samples`` is one level of a factor.</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">    If `f_oneway` is run on the transformed data and found significant,</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral">    the variances are unequal.  From Maxwell and Delaney [1]_, p.112.</span></div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">    sample1, sample2, ... : array_like</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral">        Any number of arrays.</span></div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">    obrientransform : ndarray</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral">        Transformed data for use in an ANOVA.  The first dimension</span></div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">        of the result corresponds to the sequence of transformed</span></div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral">        arrays.  If the arrays given are all 1-D of the same length,</span></div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">        the return value is a 2-D array; otherwise it is a 1-D array</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral">        of type object, with each element being an ndarray.</span></div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2496</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral">    .. [1] S. E. Maxwell and H. D. Delaney, &quot;Designing Experiments and</span></div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral">           Analyzing Data: A Model Comparison Perspective&quot;, Wadsworth, 1990.</span></div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">    We&#39;ll test the following data sets for differences in their variance.</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral">    &gt;&gt;&gt; x = [10, 11, 13, 9, 7, 12, 12, 9, 10]</span></div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">    &gt;&gt;&gt; y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15]</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral">    Apply the O&#39;Brien transform to the data.</span></div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import obrientransform</span></div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">    &gt;&gt;&gt; tx, ty = obrientransform(x, y)</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">    Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral">    transformed data.</span></div>
<div class="line"><span class="lineno"> 2515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import f_oneway</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral">    &gt;&gt;&gt; F, p = f_oneway(tx, ty)</span></div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral">    &gt;&gt;&gt; p</span></div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">    0.1314139477040335</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral">    If we require that ``p &lt; 0.05`` for significance, we cannot conclude</span></div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">    that the variances are different.</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2525</span>    TINY = np.sqrt(np.finfo(float).eps)</div>
<div class="line"><span class="lineno"> 2526</span> </div>
<div class="line"><span class="lineno"> 2527</span>    <span class="comment"># `arrays` will hold the transformed arguments.</span></div>
<div class="line"><span class="lineno"> 2528</span>    arrays = []</div>
<div class="line"><span class="lineno"> 2529</span>    sLast = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2530</span> </div>
<div class="line"><span class="lineno"> 2531</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> samples:</div>
<div class="line"><span class="lineno"> 2532</span>        a = np.asarray(sample)</div>
<div class="line"><span class="lineno"> 2533</span>        n = len(a)</div>
<div class="line"><span class="lineno"> 2534</span>        mu = np.mean(a)</div>
<div class="line"><span class="lineno"> 2535</span>        sq = (a - mu)**2</div>
<div class="line"><span class="lineno"> 2536</span>        sumsq = sq.sum()</div>
<div class="line"><span class="lineno"> 2537</span> </div>
<div class="line"><span class="lineno"> 2538</span>        <span class="comment"># The O&#39;Brien transform.</span></div>
<div class="line"><span class="lineno"> 2539</span>        t = ((n - 1.5) * n * sq - 0.5 * sumsq) / ((n - 1) * (n - 2))</div>
<div class="line"><span class="lineno"> 2540</span> </div>
<div class="line"><span class="lineno"> 2541</span>        <span class="comment"># Check that the mean of the transformed data is equal to the</span></div>
<div class="line"><span class="lineno"> 2542</span>        <span class="comment"># original variance.</span></div>
<div class="line"><span class="lineno"> 2543</span>        var = sumsq / (n - 1)</div>
<div class="line"><span class="lineno"> 2544</span>        <span class="keywordflow">if</span> abs(var - np.mean(t)) &gt; TINY:</div>
<div class="line"><span class="lineno"> 2545</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Lack of convergence in obrientransform.&#39;</span>)</div>
<div class="line"><span class="lineno"> 2546</span> </div>
<div class="line"><span class="lineno"> 2547</span>        arrays.append(t)</div>
<div class="line"><span class="lineno"> 2548</span>        sLast = a.shape</div>
<div class="line"><span class="lineno"> 2549</span> </div>
<div class="line"><span class="lineno"> 2550</span>    <span class="keywordflow">if</span> sLast:</div>
<div class="line"><span class="lineno"> 2551</span>        <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> arrays[:-1]:</div>
<div class="line"><span class="lineno"> 2552</span>            <span class="keywordflow">if</span> sLast != arr.shape:</div>
<div class="line"><span class="lineno"> 2553</span>                <span class="keywordflow">return</span> np.array(arrays, dtype=object)</div>
<div class="line"><span class="lineno"> 2554</span>    <span class="keywordflow">return</span> np.array(arrays)</div>
<div class="line"><span class="lineno"> 2555</span> </div>
<div class="line"><span class="lineno"> 2556</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a080f1bfe9c97c7a3f1e609349e4a6c" name="a7a080f1bfe9c97c7a3f1e609349e4a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a080f1bfe9c97c7a3f1e609349e4a6c">&#9670;&#160;</a></span>pearsonr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.pearsonr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pearson correlation coefficient and p-value for testing non-correlation.

The Pearson correlation coefficient [1]_ measures the linear relationship
between two datasets. Like other correlation
coefficients, this one varies between -1 and +1 with 0 implying no
correlation. Correlations of -1 or +1 imply an exact linear relationship.
Positive correlations imply that as x increases, so does y. Negative
correlations imply that as x increases, y decreases.

This function also performs a test of the null hypothesis that the
distributions underlying the samples are uncorrelated and normally
distributed. (See Kowalski [3]_
for a discussion of the effects of non-normality of the input on the
distribution of the correlation coefficient.)
The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Pearson correlation at least as extreme
as the one computed from these datasets.

Parameters
----------
x : (N,) array_like
Input array.
y : (N,) array_like
Input array.
alternative : {'two-sided', 'greater', 'less'}, optional
Defines the alternative hypothesis. Default is 'two-sided'.
The following options are available:

* 'two-sided': the correlation is nonzero
* 'less': the correlation is negative (less than zero)
* 'greater':  the correlation is positive (greater than zero)

.. versionadded:: 1.9.0

Returns
-------
result : `~scipy.stats._result_classes.PearsonRResult`
An object with the following attributes:

statistic : float
Pearson product-moment correlation coefficient.
pvalue : float
The p-value associated with the chosen alternative.

The object has the following method:

confidence_interval(confidence_level=0.95)
This method computes the confidence interval of the correlation
coefficient `statistic` for the given confidence level.
The confidence interval is returned in a ``namedtuple`` with
fields `low` and `high`.  See the Notes for more details.

Warns
-----
`~scipy.stats.ConstantInputWarning`
Raised if an input is a constant array.  The correlation coefficient
is not defined in this case, so ``np.nan`` is returned.

`~scipy.stats.NearConstantInputWarning`
Raised if an input is "nearly" constant.  The array ``x`` is considered
nearly constant if ``norm(x - mean(x)) &lt; 1e-13 * abs(mean(x))``.
Numerical errors in the calculation ``x - mean(x)`` in this case might
result in an inaccurate calculation of r.

See Also
--------
spearmanr : Spearman rank-order correlation coefficient.
kendalltau : Kendall's tau, a correlation measure for ordinal data.

Notes
-----
The correlation coefficient is calculated as follows:

.. math::

r = \frac{\sum (x - m_x) (y - m_y)}
{\sqrt{\sum (x - m_x)^2 \sum (y - m_y)^2}}

where :math:`m_x` is the mean of the vector x and :math:`m_y` is
the mean of the vector y.

Under the assumption that x and y are drawn from
independent normal distributions (so the population correlation coefficient
is 0), the probability density function of the sample correlation
coefficient r is ([1]_, [2]_):

.. math::
f(r) = \frac{{(1-r^2)}^{n/2-2}}{\mathrm{B}(\frac{1}{2},\frac{n}{2}-1)}

where n is the number of samples, and B is the beta function.  This
is sometimes referred to as the exact distribution of r.  This is
the distribution that is used in `pearsonr` to compute the p-value.
The distribution is a beta distribution on the interval [-1, 1],
with equal shape parameters a = b = n/2 - 1.  In terms of SciPy's
implementation of the beta distribution, the distribution of r is::

dist = scipy.stats.beta(n/2 - 1, n/2 - 1, loc=-1, scale=2)

The default p-value returned by `pearsonr` is a two-sided p-value. For a
given sample with correlation coefficient r, the p-value is
the probability that abs(r') of a random sample x' and y' drawn from
the population with zero correlation would be greater than or equal
to abs(r). In terms of the object ``dist`` shown above, the p-value
for a given r and length n can be computed as::

p = 2*dist.cdf(-abs(r))

When n is 2, the above continuous distribution is not well-defined.
One can interpret the limit of the beta distribution as the shape
parameters a and b approach a = b = 0 as a discrete distribution with
equal probability masses at r = 1 and r = -1.  More directly, one
can observe that, given the data x = [x1, x2] and y = [y1, y2], and
assuming x1 != x2 and y1 != y2, the only possible values for r are 1
and -1.  Because abs(r') for any sample x' and y' with length 2 will
be 1, the two-sided p-value for a sample of length 2 is always 1.

For backwards compatibility, the object that is returned also behaves
like a tuple of length two that holds the statistic and the p-value.

References
----------
.. [1] "Pearson correlation coefficient", Wikipedia,
https://en.wikipedia.org/wiki/Pearson_correlation_coefficient
.. [2] Student, "Probable error of a correlation coefficient",
Biometrika, Volume 6, Issue 2-3, 1 September 1908, pp. 302-310.
.. [3] C. J. Kowalski, "On the Effects of Non-Normality on the Distribution
of the Sample Product-Moment Correlation Coefficient"
Journal of the Royal Statistical Society. Series C (Applied
Statistics), Vol. 21, No. 1 (1972), pp. 1-12.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; res = stats.pearsonr([1, 2, 3, 4, 5], [10, 9, 2.5, 6, 4])
&gt;&gt;&gt; res
PearsonRResult(statistic=-0.7426106572325056, pvalue=0.15055580885344558)
&gt;&gt;&gt; res.confidence_interval()
ConfidenceInterval(low=-0.9816918044786463, high=0.40501116769030976)

There is a linear dependence between x and y if y = a + b*x + e, where
a,b are constants and e is a random error term, assumed to be independent
of x. For simplicity, assume that x is standard normal, a=0, b=1 and let
e follow a normal distribution with mean zero and standard deviation s&gt;0.

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; s = 0.5
&gt;&gt;&gt; x = stats.norm.rvs(size=500, random_state=rng)
&gt;&gt;&gt; e = stats.norm.rvs(scale=s, size=500, random_state=rng)
&gt;&gt;&gt; y = x + e
&gt;&gt;&gt; stats.pearsonr(x, y).statistic
0.9001942438244763

This should be close to the exact value given by

&gt;&gt;&gt; 1/np.sqrt(1 + s**2)
0.8944271909999159

For s=0.5, we observe a high level of correlation. In general, a large
variance of the noise reduces the correlation, while the correlation
approaches one as the variance of the error goes to zero.

It is important to keep in mind that no correlation does not imply
independence unless (x, y) is jointly normal. Correlation can even be zero
when there is a very simple dependence structure: if X follows a
standard normal distribution, let y = abs(x). Note that the correlation
between x and y is zero. Indeed, since the expectation of x is zero,
cov(x, y) = E[x*y]. By definition, this equals E[x*abs(x)] which is zero
by symmetry. The following lines of code illustrate this observation:

&gt;&gt;&gt; y = np.abs(x)
&gt;&gt;&gt; stats.pearsonr(x, y)
PearsonRResult(statistic=-0.05444919272687482, pvalue=0.22422294836207743)

A non-zero correlation coefficient can be misleading. For example, if X has
a standard normal distribution, define y = x if x &lt; 0 and y = 0 otherwise.
A simple calculation shows that corr(x, y) = sqrt(2/Pi) = 0.797...,
implying a high level of correlation:

&gt;&gt;&gt; y = np.where(x &lt; 0, x, 0)
&gt;&gt;&gt; stats.pearsonr(x, y)
PearsonRResult(statistic=0.861985781588, pvalue=4.813432002751103e-149)

This is unintuitive since there is no dependence of x and y if x is larger
than zero which happens in about half of the cases if we sample x and y.</pre> <div class="fragment"><div class="line"><span class="lineno"> 4225</span><span class="keyword">def </span>pearsonr(x, y, *, alternative=&#39;two-sided&#39;):</div>
<div class="line"><span class="lineno"> 4226</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4227</span><span class="stringliteral">    Pearson correlation coefficient and p-value for testing non-correlation.</span></div>
<div class="line"><span class="lineno"> 4228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4229</span><span class="stringliteral">    The Pearson correlation coefficient [1]_ measures the linear relationship</span></div>
<div class="line"><span class="lineno"> 4230</span><span class="stringliteral">    between two datasets. Like other correlation</span></div>
<div class="line"><span class="lineno"> 4231</span><span class="stringliteral">    coefficients, this one varies between -1 and +1 with 0 implying no</span></div>
<div class="line"><span class="lineno"> 4232</span><span class="stringliteral">    correlation. Correlations of -1 or +1 imply an exact linear relationship.</span></div>
<div class="line"><span class="lineno"> 4233</span><span class="stringliteral">    Positive correlations imply that as x increases, so does y. Negative</span></div>
<div class="line"><span class="lineno"> 4234</span><span class="stringliteral">    correlations imply that as x increases, y decreases.</span></div>
<div class="line"><span class="lineno"> 4235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4236</span><span class="stringliteral">    This function also performs a test of the null hypothesis that the</span></div>
<div class="line"><span class="lineno"> 4237</span><span class="stringliteral">    distributions underlying the samples are uncorrelated and normally</span></div>
<div class="line"><span class="lineno"> 4238</span><span class="stringliteral">    distributed. (See Kowalski [3]_</span></div>
<div class="line"><span class="lineno"> 4239</span><span class="stringliteral">    for a discussion of the effects of non-normality of the input on the</span></div>
<div class="line"><span class="lineno"> 4240</span><span class="stringliteral">    distribution of the correlation coefficient.)</span></div>
<div class="line"><span class="lineno"> 4241</span><span class="stringliteral">    The p-value roughly indicates the probability of an uncorrelated system</span></div>
<div class="line"><span class="lineno"> 4242</span><span class="stringliteral">    producing datasets that have a Pearson correlation at least as extreme</span></div>
<div class="line"><span class="lineno"> 4243</span><span class="stringliteral">    as the one computed from these datasets.</span></div>
<div class="line"><span class="lineno"> 4244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4245</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4246</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4247</span><span class="stringliteral">    x : (N,) array_like</span></div>
<div class="line"><span class="lineno"> 4248</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 4249</span><span class="stringliteral">    y : (N,) array_like</span></div>
<div class="line"><span class="lineno"> 4250</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 4251</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;greater&#39;, &#39;less&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 4252</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 4253</span><span class="stringliteral">        The following options are available:</span></div>
<div class="line"><span class="lineno"> 4254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4255</span><span class="stringliteral">        * &#39;two-sided&#39;: the correlation is nonzero</span></div>
<div class="line"><span class="lineno"> 4256</span><span class="stringliteral">        * &#39;less&#39;: the correlation is negative (less than zero)</span></div>
<div class="line"><span class="lineno"> 4257</span><span class="stringliteral">        * &#39;greater&#39;:  the correlation is positive (greater than zero)</span></div>
<div class="line"><span class="lineno"> 4258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4259</span><span class="stringliteral">        .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno"> 4260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4261</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4262</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4263</span><span class="stringliteral">    result : `~scipy.stats._result_classes.PearsonRResult`</span></div>
<div class="line"><span class="lineno"> 4264</span><span class="stringliteral">        An object with the following attributes:</span></div>
<div class="line"><span class="lineno"> 4265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4266</span><span class="stringliteral">        statistic : float</span></div>
<div class="line"><span class="lineno"> 4267</span><span class="stringliteral">            Pearson product-moment correlation coefficient.</span></div>
<div class="line"><span class="lineno"> 4268</span><span class="stringliteral">        pvalue : float</span></div>
<div class="line"><span class="lineno"> 4269</span><span class="stringliteral">            The p-value associated with the chosen alternative.</span></div>
<div class="line"><span class="lineno"> 4270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4271</span><span class="stringliteral">        The object has the following method:</span></div>
<div class="line"><span class="lineno"> 4272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4273</span><span class="stringliteral">        confidence_interval(confidence_level=0.95)</span></div>
<div class="line"><span class="lineno"> 4274</span><span class="stringliteral">            This method computes the confidence interval of the correlation</span></div>
<div class="line"><span class="lineno"> 4275</span><span class="stringliteral">            coefficient `statistic` for the given confidence level.</span></div>
<div class="line"><span class="lineno"> 4276</span><span class="stringliteral">            The confidence interval is returned in a ``namedtuple`` with</span></div>
<div class="line"><span class="lineno"> 4277</span><span class="stringliteral">            fields `low` and `high`.  See the Notes for more details.</span></div>
<div class="line"><span class="lineno"> 4278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4279</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno"> 4280</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4281</span><span class="stringliteral">    `~scipy.stats.ConstantInputWarning`</span></div>
<div class="line"><span class="lineno"> 4282</span><span class="stringliteral">        Raised if an input is a constant array.  The correlation coefficient</span></div>
<div class="line"><span class="lineno"> 4283</span><span class="stringliteral">        is not defined in this case, so ``np.nan`` is returned.</span></div>
<div class="line"><span class="lineno"> 4284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4285</span><span class="stringliteral">    `~scipy.stats.NearConstantInputWarning`</span></div>
<div class="line"><span class="lineno"> 4286</span><span class="stringliteral">        Raised if an input is &quot;nearly&quot; constant.  The array ``x`` is considered</span></div>
<div class="line"><span class="lineno"> 4287</span><span class="stringliteral">        nearly constant if ``norm(x - mean(x)) &lt; 1e-13 * abs(mean(x))``.</span></div>
<div class="line"><span class="lineno"> 4288</span><span class="stringliteral">        Numerical errors in the calculation ``x - mean(x)`` in this case might</span></div>
<div class="line"><span class="lineno"> 4289</span><span class="stringliteral">        result in an inaccurate calculation of r.</span></div>
<div class="line"><span class="lineno"> 4290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4291</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4292</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4293</span><span class="stringliteral">    spearmanr : Spearman rank-order correlation coefficient.</span></div>
<div class="line"><span class="lineno"> 4294</span><span class="stringliteral">    kendalltau : Kendall&#39;s tau, a correlation measure for ordinal data.</span></div>
<div class="line"><span class="lineno"> 4295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4296</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4297</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4298</span><span class="stringliteral">    The correlation coefficient is calculated as follows:</span></div>
<div class="line"><span class="lineno"> 4299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4300</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 4301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4302</span><span class="stringliteral">        r = \frac{\sum (x - m_x) (y - m_y)}</span></div>
<div class="line"><span class="lineno"> 4303</span><span class="stringliteral">                 {\sqrt{\sum (x - m_x)^2 \sum (y - m_y)^2}}</span></div>
<div class="line"><span class="lineno"> 4304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4305</span><span class="stringliteral">    where :math:`m_x` is the mean of the vector x and :math:`m_y` is</span></div>
<div class="line"><span class="lineno"> 4306</span><span class="stringliteral">    the mean of the vector y.</span></div>
<div class="line"><span class="lineno"> 4307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4308</span><span class="stringliteral">    Under the assumption that x and y are drawn from</span></div>
<div class="line"><span class="lineno"> 4309</span><span class="stringliteral">    independent normal distributions (so the population correlation coefficient</span></div>
<div class="line"><span class="lineno"> 4310</span><span class="stringliteral">    is 0), the probability density function of the sample correlation</span></div>
<div class="line"><span class="lineno"> 4311</span><span class="stringliteral">    coefficient r is ([1]_, [2]_):</span></div>
<div class="line"><span class="lineno"> 4312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4313</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 4314</span><span class="stringliteral">        f(r) = \frac{{(1-r^2)}^{n/2-2}}{\mathrm{B}(\frac{1}{2},\frac{n}{2}-1)}</span></div>
<div class="line"><span class="lineno"> 4315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4316</span><span class="stringliteral">    where n is the number of samples, and B is the beta function.  This</span></div>
<div class="line"><span class="lineno"> 4317</span><span class="stringliteral">    is sometimes referred to as the exact distribution of r.  This is</span></div>
<div class="line"><span class="lineno"> 4318</span><span class="stringliteral">    the distribution that is used in `pearsonr` to compute the p-value.</span></div>
<div class="line"><span class="lineno"> 4319</span><span class="stringliteral">    The distribution is a beta distribution on the interval [-1, 1],</span></div>
<div class="line"><span class="lineno"> 4320</span><span class="stringliteral">    with equal shape parameters a = b = n/2 - 1.  In terms of SciPy&#39;s</span></div>
<div class="line"><span class="lineno"> 4321</span><span class="stringliteral">    implementation of the beta distribution, the distribution of r is::</span></div>
<div class="line"><span class="lineno"> 4322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4323</span><span class="stringliteral">        dist = scipy.stats.beta(n/2 - 1, n/2 - 1, loc=-1, scale=2)</span></div>
<div class="line"><span class="lineno"> 4324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4325</span><span class="stringliteral">    The default p-value returned by `pearsonr` is a two-sided p-value. For a</span></div>
<div class="line"><span class="lineno"> 4326</span><span class="stringliteral">    given sample with correlation coefficient r, the p-value is</span></div>
<div class="line"><span class="lineno"> 4327</span><span class="stringliteral">    the probability that abs(r&#39;) of a random sample x&#39; and y&#39; drawn from</span></div>
<div class="line"><span class="lineno"> 4328</span><span class="stringliteral">    the population with zero correlation would be greater than or equal</span></div>
<div class="line"><span class="lineno"> 4329</span><span class="stringliteral">    to abs(r). In terms of the object ``dist`` shown above, the p-value</span></div>
<div class="line"><span class="lineno"> 4330</span><span class="stringliteral">    for a given r and length n can be computed as::</span></div>
<div class="line"><span class="lineno"> 4331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4332</span><span class="stringliteral">        p = 2*dist.cdf(-abs(r))</span></div>
<div class="line"><span class="lineno"> 4333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4334</span><span class="stringliteral">    When n is 2, the above continuous distribution is not well-defined.</span></div>
<div class="line"><span class="lineno"> 4335</span><span class="stringliteral">    One can interpret the limit of the beta distribution as the shape</span></div>
<div class="line"><span class="lineno"> 4336</span><span class="stringliteral">    parameters a and b approach a = b = 0 as a discrete distribution with</span></div>
<div class="line"><span class="lineno"> 4337</span><span class="stringliteral">    equal probability masses at r = 1 and r = -1.  More directly, one</span></div>
<div class="line"><span class="lineno"> 4338</span><span class="stringliteral">    can observe that, given the data x = [x1, x2] and y = [y1, y2], and</span></div>
<div class="line"><span class="lineno"> 4339</span><span class="stringliteral">    assuming x1 != x2 and y1 != y2, the only possible values for r are 1</span></div>
<div class="line"><span class="lineno"> 4340</span><span class="stringliteral">    and -1.  Because abs(r&#39;) for any sample x&#39; and y&#39; with length 2 will</span></div>
<div class="line"><span class="lineno"> 4341</span><span class="stringliteral">    be 1, the two-sided p-value for a sample of length 2 is always 1.</span></div>
<div class="line"><span class="lineno"> 4342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4343</span><span class="stringliteral">    For backwards compatibility, the object that is returned also behaves</span></div>
<div class="line"><span class="lineno"> 4344</span><span class="stringliteral">    like a tuple of length two that holds the statistic and the p-value.</span></div>
<div class="line"><span class="lineno"> 4345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4346</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 4347</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4348</span><span class="stringliteral">    .. [1] &quot;Pearson correlation coefficient&quot;, Wikipedia,</span></div>
<div class="line"><span class="lineno"> 4349</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Pearson_correlation_coefficient</span></div>
<div class="line"><span class="lineno"> 4350</span><span class="stringliteral">    .. [2] Student, &quot;Probable error of a correlation coefficient&quot;,</span></div>
<div class="line"><span class="lineno"> 4351</span><span class="stringliteral">           Biometrika, Volume 6, Issue 2-3, 1 September 1908, pp. 302-310.</span></div>
<div class="line"><span class="lineno"> 4352</span><span class="stringliteral">    .. [3] C. J. Kowalski, &quot;On the Effects of Non-Normality on the Distribution</span></div>
<div class="line"><span class="lineno"> 4353</span><span class="stringliteral">           of the Sample Product-Moment Correlation Coefficient&quot;</span></div>
<div class="line"><span class="lineno"> 4354</span><span class="stringliteral">           Journal of the Royal Statistical Society. Series C (Applied</span></div>
<div class="line"><span class="lineno"> 4355</span><span class="stringliteral">           Statistics), Vol. 21, No. 1 (1972), pp. 1-12.</span></div>
<div class="line"><span class="lineno"> 4356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4357</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4358</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4359</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 4360</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.pearsonr([1, 2, 3, 4, 5], [10, 9, 2.5, 6, 4])</span></div>
<div class="line"><span class="lineno"> 4361</span><span class="stringliteral">    &gt;&gt;&gt; res</span></div>
<div class="line"><span class="lineno"> 4362</span><span class="stringliteral">    PearsonRResult(statistic=-0.7426106572325056, pvalue=0.15055580885344558)</span></div>
<div class="line"><span class="lineno"> 4363</span><span class="stringliteral">    &gt;&gt;&gt; res.confidence_interval()</span></div>
<div class="line"><span class="lineno"> 4364</span><span class="stringliteral">    ConfidenceInterval(low=-0.9816918044786463, high=0.40501116769030976)</span></div>
<div class="line"><span class="lineno"> 4365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4366</span><span class="stringliteral">    There is a linear dependence between x and y if y = a + b*x + e, where</span></div>
<div class="line"><span class="lineno"> 4367</span><span class="stringliteral">    a,b are constants and e is a random error term, assumed to be independent</span></div>
<div class="line"><span class="lineno"> 4368</span><span class="stringliteral">    of x. For simplicity, assume that x is standard normal, a=0, b=1 and let</span></div>
<div class="line"><span class="lineno"> 4369</span><span class="stringliteral">    e follow a normal distribution with mean zero and standard deviation s&gt;0.</span></div>
<div class="line"><span class="lineno"> 4370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4371</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 4372</span><span class="stringliteral">    &gt;&gt;&gt; s = 0.5</span></div>
<div class="line"><span class="lineno"> 4373</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.norm.rvs(size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 4374</span><span class="stringliteral">    &gt;&gt;&gt; e = stats.norm.rvs(scale=s, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 4375</span><span class="stringliteral">    &gt;&gt;&gt; y = x + e</span></div>
<div class="line"><span class="lineno"> 4376</span><span class="stringliteral">    &gt;&gt;&gt; stats.pearsonr(x, y).statistic</span></div>
<div class="line"><span class="lineno"> 4377</span><span class="stringliteral">    0.9001942438244763</span></div>
<div class="line"><span class="lineno"> 4378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4379</span><span class="stringliteral">    This should be close to the exact value given by</span></div>
<div class="line"><span class="lineno"> 4380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4381</span><span class="stringliteral">    &gt;&gt;&gt; 1/np.sqrt(1 + s**2)</span></div>
<div class="line"><span class="lineno"> 4382</span><span class="stringliteral">    0.8944271909999159</span></div>
<div class="line"><span class="lineno"> 4383</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4384</span><span class="stringliteral">    For s=0.5, we observe a high level of correlation. In general, a large</span></div>
<div class="line"><span class="lineno"> 4385</span><span class="stringliteral">    variance of the noise reduces the correlation, while the correlation</span></div>
<div class="line"><span class="lineno"> 4386</span><span class="stringliteral">    approaches one as the variance of the error goes to zero.</span></div>
<div class="line"><span class="lineno"> 4387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4388</span><span class="stringliteral">    It is important to keep in mind that no correlation does not imply</span></div>
<div class="line"><span class="lineno"> 4389</span><span class="stringliteral">    independence unless (x, y) is jointly normal. Correlation can even be zero</span></div>
<div class="line"><span class="lineno"> 4390</span><span class="stringliteral">    when there is a very simple dependence structure: if X follows a</span></div>
<div class="line"><span class="lineno"> 4391</span><span class="stringliteral">    standard normal distribution, let y = abs(x). Note that the correlation</span></div>
<div class="line"><span class="lineno"> 4392</span><span class="stringliteral">    between x and y is zero. Indeed, since the expectation of x is zero,</span></div>
<div class="line"><span class="lineno"> 4393</span><span class="stringliteral">    cov(x, y) = E[x*y]. By definition, this equals E[x*abs(x)] which is zero</span></div>
<div class="line"><span class="lineno"> 4394</span><span class="stringliteral">    by symmetry. The following lines of code illustrate this observation:</span></div>
<div class="line"><span class="lineno"> 4395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4396</span><span class="stringliteral">    &gt;&gt;&gt; y = np.abs(x)</span></div>
<div class="line"><span class="lineno"> 4397</span><span class="stringliteral">    &gt;&gt;&gt; stats.pearsonr(x, y)</span></div>
<div class="line"><span class="lineno"> 4398</span><span class="stringliteral">    PearsonRResult(statistic=-0.05444919272687482, pvalue=0.22422294836207743)</span></div>
<div class="line"><span class="lineno"> 4399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4400</span><span class="stringliteral">    A non-zero correlation coefficient can be misleading. For example, if X has</span></div>
<div class="line"><span class="lineno"> 4401</span><span class="stringliteral">    a standard normal distribution, define y = x if x &lt; 0 and y = 0 otherwise.</span></div>
<div class="line"><span class="lineno"> 4402</span><span class="stringliteral">    A simple calculation shows that corr(x, y) = sqrt(2/Pi) = 0.797...,</span></div>
<div class="line"><span class="lineno"> 4403</span><span class="stringliteral">    implying a high level of correlation:</span></div>
<div class="line"><span class="lineno"> 4404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4405</span><span class="stringliteral">    &gt;&gt;&gt; y = np.where(x &lt; 0, x, 0)</span></div>
<div class="line"><span class="lineno"> 4406</span><span class="stringliteral">    &gt;&gt;&gt; stats.pearsonr(x, y)</span></div>
<div class="line"><span class="lineno"> 4407</span><span class="stringliteral">    PearsonRResult(statistic=0.861985781588, pvalue=4.813432002751103e-149)</span></div>
<div class="line"><span class="lineno"> 4408</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4409</span><span class="stringliteral">    This is unintuitive since there is no dependence of x and y if x is larger</span></div>
<div class="line"><span class="lineno"> 4410</span><span class="stringliteral">    than zero which happens in about half of the cases if we sample x and y.</span></div>
<div class="line"><span class="lineno"> 4411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4412</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4413</span>    n = len(x)</div>
<div class="line"><span class="lineno"> 4414</span>    <span class="keywordflow">if</span> n != len(y):</div>
<div class="line"><span class="lineno"> 4415</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;x and y must have the same length.&#39;</span>)</div>
<div class="line"><span class="lineno"> 4416</span> </div>
<div class="line"><span class="lineno"> 4417</span>    <span class="keywordflow">if</span> n &lt; 2:</div>
<div class="line"><span class="lineno"> 4418</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;x and y must have length at least 2.&#39;</span>)</div>
<div class="line"><span class="lineno"> 4419</span> </div>
<div class="line"><span class="lineno"> 4420</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno"> 4421</span>    y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 4422</span> </div>
<div class="line"><span class="lineno"> 4423</span>    <span class="comment"># If an input is constant, the correlation coefficient is not defined.</span></div>
<div class="line"><span class="lineno"> 4424</span>    <span class="keywordflow">if</span> (x == x[0]).all() <span class="keywordflow">or</span> (y == y[0]).all():</div>
<div class="line"><span class="lineno"> 4425</span>        msg = (<span class="stringliteral">&quot;An input array is constant; the correlation coefficient &quot;</span></div>
<div class="line"><span class="lineno"> 4426</span>               <span class="stringliteral">&quot;is not defined.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4427</span>        warnings.warn(stats.ConstantInputWarning(msg))</div>
<div class="line"><span class="lineno"> 4428</span>        result = PearsonRResult(statistic=np.nan, pvalue=np.nan, n=n,</div>
<div class="line"><span class="lineno"> 4429</span>                                alternative=alternative)</div>
<div class="line"><span class="lineno"> 4430</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 4431</span> </div>
<div class="line"><span class="lineno"> 4432</span>    <span class="comment"># dtype is the data type for the calculations.  This expression ensures</span></div>
<div class="line"><span class="lineno"> 4433</span>    <span class="comment"># that the data type is at least 64 bit floating point.  It might have</span></div>
<div class="line"><span class="lineno"> 4434</span>    <span class="comment"># more precision if the input is, for example, np.longdouble.</span></div>
<div class="line"><span class="lineno"> 4435</span>    dtype = type(1.0 + x[0] + y[0])</div>
<div class="line"><span class="lineno"> 4436</span> </div>
<div class="line"><span class="lineno"> 4437</span>    <span class="keywordflow">if</span> n == 2:</div>
<div class="line"><span class="lineno"> 4438</span>        r = <a class="code hl_namespace" href="namespacedtype.html">dtype</a>(np.sign(x[1] - x[0])*np.sign(y[1] - y[0]))</div>
<div class="line"><span class="lineno"> 4439</span>        result = PearsonRResult(statistic=r, pvalue=1.0, n=n,</div>
<div class="line"><span class="lineno"> 4440</span>                                alternative=alternative)</div>
<div class="line"><span class="lineno"> 4441</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 4442</span> </div>
<div class="line"><span class="lineno"> 4443</span>    xmean = x.mean(dtype=dtype)</div>
<div class="line"><span class="lineno"> 4444</span>    ymean = y.mean(dtype=dtype)</div>
<div class="line"><span class="lineno"> 4445</span> </div>
<div class="line"><span class="lineno"> 4446</span>    <span class="comment"># By using `astype(dtype)`, we ensure that the intermediate calculations</span></div>
<div class="line"><span class="lineno"> 4447</span>    <span class="comment"># use at least 64 bit floating point.</span></div>
<div class="line"><span class="lineno"> 4448</span>    xm = x.astype(dtype) - xmean</div>
<div class="line"><span class="lineno"> 4449</span>    ym = y.astype(dtype) - ymean</div>
<div class="line"><span class="lineno"> 4450</span> </div>
<div class="line"><span class="lineno"> 4451</span>    <span class="comment"># Unlike np.linalg.norm or the expression sqrt((xm*xm).sum()),</span></div>
<div class="line"><span class="lineno"> 4452</span>    <span class="comment"># scipy.linalg.norm(xm) does not overflow if xm is, for example,</span></div>
<div class="line"><span class="lineno"> 4453</span>    <span class="comment"># [-5e210, 5e210, 3e200, -3e200]</span></div>
<div class="line"><span class="lineno"> 4454</span>    normxm = linalg.norm(xm)</div>
<div class="line"><span class="lineno"> 4455</span>    normym = linalg.norm(ym)</div>
<div class="line"><span class="lineno"> 4456</span> </div>
<div class="line"><span class="lineno"> 4457</span>    threshold = 1e-13</div>
<div class="line"><span class="lineno"> 4458</span>    <span class="keywordflow">if</span> normxm &lt; threshold*abs(xmean) <span class="keywordflow">or</span> normym &lt; threshold*abs(ymean):</div>
<div class="line"><span class="lineno"> 4459</span>        <span class="comment"># If all the values in x (likewise y) are very close to the mean,</span></div>
<div class="line"><span class="lineno"> 4460</span>        <span class="comment"># the loss of precision that occurs in the subtraction xm = x - xmean</span></div>
<div class="line"><span class="lineno"> 4461</span>        <span class="comment"># might result in large errors in r.</span></div>
<div class="line"><span class="lineno"> 4462</span>        msg = (<span class="stringliteral">&quot;An input array is nearly constant; the computed &quot;</span></div>
<div class="line"><span class="lineno"> 4463</span>               <span class="stringliteral">&quot;correlation coefficient may be inaccurate.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4464</span>        warnings.warn(stats.NearConstantInputWarning(msg))</div>
<div class="line"><span class="lineno"> 4465</span> </div>
<div class="line"><span class="lineno"> 4466</span>    r = np.dot(xm/normxm, ym/normym)</div>
<div class="line"><span class="lineno"> 4467</span> </div>
<div class="line"><span class="lineno"> 4468</span>    <span class="comment"># Presumably, if abs(r) &gt; 1, then it is only some small artifact of</span></div>
<div class="line"><span class="lineno"> 4469</span>    <span class="comment"># floating point arithmetic.</span></div>
<div class="line"><span class="lineno"> 4470</span>    r = max(min(r, 1.0), -1.0)</div>
<div class="line"><span class="lineno"> 4471</span> </div>
<div class="line"><span class="lineno"> 4472</span>    <span class="comment"># As explained in the docstring, the p-value can be computed as</span></div>
<div class="line"><span class="lineno"> 4473</span>    <span class="comment">#     p = 2*dist.cdf(-abs(r))</span></div>
<div class="line"><span class="lineno"> 4474</span>    <span class="comment"># where dist is the beta distribution on [-1, 1] with shape parameters</span></div>
<div class="line"><span class="lineno"> 4475</span>    <span class="comment"># a = b = n/2 - 1.  `special.btdtr` is the CDF for the beta distribution</span></div>
<div class="line"><span class="lineno"> 4476</span>    <span class="comment"># on [0, 1].  To use it, we make the transformation  x = (r + 1)/2; the</span></div>
<div class="line"><span class="lineno"> 4477</span>    <span class="comment"># shape parameters do not change.  Then -abs(r) used in `cdf(-abs(r))`</span></div>
<div class="line"><span class="lineno"> 4478</span>    <span class="comment"># becomes x = (-abs(r) + 1)/2 = 0.5*(1 - abs(r)).  (r is cast to float64</span></div>
<div class="line"><span class="lineno"> 4479</span>    <span class="comment"># to avoid a TypeError raised by btdtr when r is higher precision.)</span></div>
<div class="line"><span class="lineno"> 4480</span>    ab = n/2 - 1</div>
<div class="line"><span class="lineno"> 4481</span>    <span class="keywordflow">if</span> alternative == <span class="stringliteral">&#39;two-sided&#39;</span>:</div>
<div class="line"><span class="lineno"> 4482</span>        prob = 2*special.btdtr(ab, ab, 0.5*(1 - abs(np.float64(r))))</div>
<div class="line"><span class="lineno"> 4483</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;less&#39;</span>:</div>
<div class="line"><span class="lineno"> 4484</span>        prob = 1 - special.btdtr(ab, ab, 0.5*(1 - abs(np.float64(r))))</div>
<div class="line"><span class="lineno"> 4485</span>    <span class="keywordflow">elif</span> alternative == <span class="stringliteral">&#39;greater&#39;</span>:</div>
<div class="line"><span class="lineno"> 4486</span>        prob = special.btdtr(ab, ab, 0.5*(1 - abs(np.float64(r))))</div>
<div class="line"><span class="lineno"> 4487</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4488</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;alternative must be one of &#39;</span></div>
<div class="line"><span class="lineno"> 4489</span>                         <span class="stringliteral">&#39;[&quot;two-sided&quot;, &quot;less&quot;, &quot;greater&quot;]&#39;</span>)</div>
<div class="line"><span class="lineno"> 4490</span> </div>
<div class="line"><span class="lineno"> 4491</span>    <span class="keywordflow">return</span> PearsonRResult(statistic=r, pvalue=prob, n=n,</div>
<div class="line"><span class="lineno"> 4492</span>                          alternative=alternative)</div>
<div class="line"><span class="lineno"> 4493</span> </div>
<div class="line"><span class="lineno"> 4494</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af139493d2638b97ca3345692a7835fd4" name="af139493d2638b97ca3345692a7835fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af139493d2638b97ca3345692a7835fd4">&#9670;&#160;</a></span>percentileofscore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.percentileofscore </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>'rank'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the percentile rank of a score relative to a list of scores.

A `percentileofscore` of, for example, 80% means that 80% of the
scores in `a` are below the given score. In the case of gaps or
ties, the exact definition depends on the optional keyword, `kind`.

Parameters
----------
a : array_like
    Array to which `score` is compared.
score : array_like
    Scores to compute percentiles for.
kind : {'rank', 'weak', 'strict', 'mean'}, optional
    Specifies the interpretation of the resulting score.
    The following options are available (default is 'rank'):

      * 'rank': Average percentage ranking of score.  In case of multiple
        matches, average the percentage rankings of all matching scores.
      * 'weak': This kind corresponds to the definition of a cumulative
        distribution function.  A percentileofscore of 80% means that 80%
        of values are less than or equal to the provided score.
      * 'strict': Similar to "weak", except that only values that are
        strictly less than the given score are counted.
      * 'mean': The average of the "weak" and "strict" scores, often used
        in testing.  See https://en.wikipedia.org/wiki/Percentile_rank
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Specifies how to treat `nan` values in `a`.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan (for each value in `score`).
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
pcos : float
    Percentile-position of score (0-100) relative to `a`.

See Also
--------
numpy.percentile
scipy.stats.scoreatpercentile, scipy.stats.rankdata

Examples
--------
Three-quarters of the given values lie below a given score:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 4], 3)
75.0

With multiple matches, note how the scores of the two matches, 0.6
and 0.8 respectively, are averaged:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3)
70.0

Only 2/5 values are strictly less than 3:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='strict')
40.0

But 4/5 values are less than or equal to 3:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='weak')
80.0

The average between the weak and the strict scores is:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='mean')
60.0

Score arrays (of any dimensionality) are supported:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], [2, 3])
array([40., 70.])

The inputs can be infinite:

&gt;&gt;&gt; stats.percentileofscore([-np.inf, 0, 1, np.inf], [1, 2, np.inf])
array([75., 75., 100.])

If `a` is empty, then the resulting percentiles are all `nan`:

&gt;&gt;&gt; stats.percentileofscore([], [1, 2])
array([nan, nan])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2063</span><span class="keyword">def </span>percentileofscore(a, score, kind=&#39;rank&#39;, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 2064</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the percentile rank of a score relative to a list of scores.</span></div>
<div class="line"><span class="lineno"> 2065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2066</span><span class="stringliteral">    A `percentileofscore` of, for example, 80% means that 80% of the</span></div>
<div class="line"><span class="lineno"> 2067</span><span class="stringliteral">    scores in `a` are below the given score. In the case of gaps or</span></div>
<div class="line"><span class="lineno"> 2068</span><span class="stringliteral">    ties, the exact definition depends on the optional keyword, `kind`.</span></div>
<div class="line"><span class="lineno"> 2069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2070</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2071</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2072</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2073</span><span class="stringliteral">        Array to which `score` is compared.</span></div>
<div class="line"><span class="lineno"> 2074</span><span class="stringliteral">    score : array_like</span></div>
<div class="line"><span class="lineno"> 2075</span><span class="stringliteral">        Scores to compute percentiles for.</span></div>
<div class="line"><span class="lineno"> 2076</span><span class="stringliteral">    kind : {&#39;rank&#39;, &#39;weak&#39;, &#39;strict&#39;, &#39;mean&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2077</span><span class="stringliteral">        Specifies the interpretation of the resulting score.</span></div>
<div class="line"><span class="lineno"> 2078</span><span class="stringliteral">        The following options are available (default is &#39;rank&#39;):</span></div>
<div class="line"><span class="lineno"> 2079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2080</span><span class="stringliteral">          * &#39;rank&#39;: Average percentage ranking of score.  In case of multiple</span></div>
<div class="line"><span class="lineno"> 2081</span><span class="stringliteral">            matches, average the percentage rankings of all matching scores.</span></div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">          * &#39;weak&#39;: This kind corresponds to the definition of a cumulative</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral">            distribution function.  A percentileofscore of 80% means that 80%</span></div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">            of values are less than or equal to the provided score.</span></div>
<div class="line"><span class="lineno"> 2085</span><span class="stringliteral">          * &#39;strict&#39;: Similar to &quot;weak&quot;, except that only values that are</span></div>
<div class="line"><span class="lineno"> 2086</span><span class="stringliteral">            strictly less than the given score are counted.</span></div>
<div class="line"><span class="lineno"> 2087</span><span class="stringliteral">          * &#39;mean&#39;: The average of the &quot;weak&quot; and &quot;strict&quot; scores, often used</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral">            in testing.  See https://en.wikipedia.org/wiki/Percentile_rank</span></div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral">        Specifies how to treat `nan` values in `a`.</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan (for each value in `score`).</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">    pcos : float</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">        Percentile-position of score (0-100) relative to `a`.</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral">    numpy.percentile</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">    scipy.stats.scoreatpercentile, scipy.stats.rankdata</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">    Three-quarters of the given values lie below a given score:</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 4], 3)</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">    75.0</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">    With multiple matches, note how the scores of the two matches, 0.6</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral">    and 0.8 respectively, are averaged:</span></div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3)</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral">    70.0</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">    Only 2/5 values are strictly less than 3:</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind=&#39;strict&#39;)</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral">    40.0</span></div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">    But 4/5 values are less than or equal to 3:</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind=&#39;weak&#39;)</span></div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">    80.0</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral">    The average between the weak and the strict scores is:</span></div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind=&#39;mean&#39;)</span></div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral">    60.0</span></div>
<div class="line"><span class="lineno"> 2135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral">    Score arrays (of any dimensionality) are supported:</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], [2, 3])</span></div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">    array([40., 70.])</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">    The inputs can be infinite:</span></div>
<div class="line"><span class="lineno"> 2142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2143</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([-np.inf, 0, 1, np.inf], [1, 2, np.inf])</span></div>
<div class="line"><span class="lineno"> 2144</span><span class="stringliteral">    array([75., 75., 100.])</span></div>
<div class="line"><span class="lineno"> 2145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2146</span><span class="stringliteral">    If `a` is empty, then the resulting percentiles are all `nan`:</span></div>
<div class="line"><span class="lineno"> 2147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2148</span><span class="stringliteral">    &gt;&gt;&gt; stats.percentileofscore([], [1, 2])</span></div>
<div class="line"><span class="lineno"> 2149</span><span class="stringliteral">    array([nan, nan])</span></div>
<div class="line"><span class="lineno"> 2150</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2151</span> </div>
<div class="line"><span class="lineno"> 2152</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 2153</span>    n = len(a)</div>
<div class="line"><span class="lineno"> 2154</span>    score = np.asarray(score)</div>
<div class="line"><span class="lineno"> 2155</span> </div>
<div class="line"><span class="lineno"> 2156</span>    <span class="comment"># Nan treatment</span></div>
<div class="line"><span class="lineno"> 2157</span>    cna, npa = _contains_nan(a, nan_policy, use_summation=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2158</span>    cns, nps = _contains_nan(score, nan_policy, use_summation=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2159</span> </div>
<div class="line"><span class="lineno"> 2160</span>    <span class="keywordflow">if</span> (cna <span class="keywordflow">or</span> cns) <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;raise&#39;</span>:</div>
<div class="line"><span class="lineno"> 2161</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The input contains nan values&quot;</span>)</div>
<div class="line"><span class="lineno"> 2162</span> </div>
<div class="line"><span class="lineno"> 2163</span>    <span class="keywordflow">if</span> cns:</div>
<div class="line"><span class="lineno"> 2164</span>        <span class="comment"># If a score is nan, then the output should be nan</span></div>
<div class="line"><span class="lineno"> 2165</span>        <span class="comment"># (also if nan_policy is &quot;omit&quot;, because it only applies to `a`)</span></div>
<div class="line"><span class="lineno"> 2166</span>        score = ma.masked_where(np.isnan(score), score)</div>
<div class="line"><span class="lineno"> 2167</span> </div>
<div class="line"><span class="lineno"> 2168</span>    <span class="keywordflow">if</span> cna:</div>
<div class="line"><span class="lineno"> 2169</span>        <span class="keywordflow">if</span> nan_policy == <span class="stringliteral">&quot;omit&quot;</span>:</div>
<div class="line"><span class="lineno"> 2170</span>            <span class="comment"># Don&#39;t count nans</span></div>
<div class="line"><span class="lineno"> 2171</span>            a = ma.masked_where(np.isnan(a), a)</div>
<div class="line"><span class="lineno"> 2172</span>            n = a.count()</div>
<div class="line"><span class="lineno"> 2173</span> </div>
<div class="line"><span class="lineno"> 2174</span>        <span class="keywordflow">if</span> nan_policy == <span class="stringliteral">&quot;propagate&quot;</span>:</div>
<div class="line"><span class="lineno"> 2175</span>            <span class="comment"># All outputs should be nans</span></div>
<div class="line"><span class="lineno"> 2176</span>            n = 0</div>
<div class="line"><span class="lineno"> 2177</span> </div>
<div class="line"><span class="lineno"> 2178</span>    <span class="comment"># Cannot compare to empty list ==&gt; nan</span></div>
<div class="line"><span class="lineno"> 2179</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno"> 2180</span>        perct = np.full_like(score, np.nan, dtype=np.float64)</div>
<div class="line"><span class="lineno"> 2181</span> </div>
<div class="line"><span class="lineno"> 2182</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2183</span>        <span class="comment"># Prepare broadcasting</span></div>
<div class="line"><span class="lineno"> 2184</span>        score = score[..., <span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno"> 2185</span> </div>
<div class="line"><span class="lineno"> 2186</span>        <span class="keyword">def </span>count(x):</div>
<div class="line"><span class="lineno"> 2187</span>            <span class="keywordflow">return</span> np.count_nonzero(x, -1)</div>
<div class="line"><span class="lineno"> 2188</span> </div>
<div class="line"><span class="lineno"> 2189</span>        <span class="comment"># Despite using masked_array to omit nan values from processing,</span></div>
<div class="line"><span class="lineno"> 2190</span>        <span class="comment"># the CI tests on &quot;Azure pipelines&quot; (but not on the other CI servers)</span></div>
<div class="line"><span class="lineno"> 2191</span>        <span class="comment"># emits warnings when there are nan values, contrarily to the purpose</span></div>
<div class="line"><span class="lineno"> 2192</span>        <span class="comment"># of masked_arrays. As a fix, we simply suppress the warnings.</span></div>
<div class="line"><span class="lineno"> 2193</span>        <span class="keyword">with</span> suppress_warnings() <span class="keyword">as</span> sup:</div>
<div class="line"><span class="lineno"> 2194</span>            sup.filter(RuntimeWarning,</div>
<div class="line"><span class="lineno"> 2195</span>                       <span class="stringliteral">&quot;invalid value encountered in less&quot;</span>)</div>
<div class="line"><span class="lineno"> 2196</span>            sup.filter(RuntimeWarning,</div>
<div class="line"><span class="lineno"> 2197</span>                       <span class="stringliteral">&quot;invalid value encountered in greater&quot;</span>)</div>
<div class="line"><span class="lineno"> 2198</span> </div>
<div class="line"><span class="lineno"> 2199</span>            <span class="comment"># Main computations/logic</span></div>
<div class="line"><span class="lineno"> 2200</span>            <span class="keywordflow">if</span> kind == <span class="stringliteral">&#39;rank&#39;</span>:</div>
<div class="line"><span class="lineno"> 2201</span>                left = count(a &lt; score)</div>
<div class="line"><span class="lineno"> 2202</span>                right = count(a &lt;= score)</div>
<div class="line"><span class="lineno"> 2203</span>                plus1 = left &lt; right</div>
<div class="line"><span class="lineno"> 2204</span>                perct = (left + right + plus1) * (50.0 / n)</div>
<div class="line"><span class="lineno"> 2205</span>            <span class="keywordflow">elif</span> kind == <span class="stringliteral">&#39;strict&#39;</span>:</div>
<div class="line"><span class="lineno"> 2206</span>                perct = count(a &lt; score) * (100.0 / n)</div>
<div class="line"><span class="lineno"> 2207</span>            <span class="keywordflow">elif</span> kind == <span class="stringliteral">&#39;weak&#39;</span>:</div>
<div class="line"><span class="lineno"> 2208</span>                perct = count(a &lt;= score) * (100.0 / n)</div>
<div class="line"><span class="lineno"> 2209</span>            <span class="keywordflow">elif</span> kind == <span class="stringliteral">&#39;mean&#39;</span>:</div>
<div class="line"><span class="lineno"> 2210</span>                left = count(a &lt; score)</div>
<div class="line"><span class="lineno"> 2211</span>                right = count(a &lt;= score)</div>
<div class="line"><span class="lineno"> 2212</span>                perct = (left + right) * (50.0 / n)</div>
<div class="line"><span class="lineno"> 2213</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2214</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2215</span>                    <span class="stringliteral">&quot;kind can only be &#39;rank&#39;, &#39;strict&#39;, &#39;weak&#39; or &#39;mean&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 2216</span> </div>
<div class="line"><span class="lineno"> 2217</span>    <span class="comment"># Re-insert nan values</span></div>
<div class="line"><span class="lineno"> 2218</span>    perct = ma.filled(perct, np.nan)</div>
<div class="line"><span class="lineno"> 2219</span> </div>
<div class="line"><span class="lineno"> 2220</span>    <span class="keywordflow">if</span> perct.ndim == 0:</div>
<div class="line"><span class="lineno"> 2221</span>        <span class="keywordflow">return</span> perct[()]</div>
<div class="line"><span class="lineno"> 2222</span>    <span class="keywordflow">return</span> perct</div>
<div class="line"><span class="lineno"> 2223</span> </div>
<div class="line"><span class="lineno"> 2224</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7452f929f20900003c3bb82a929a08fe" name="a7452f929f20900003c3bb82a929a08fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7452f929f20900003c3bb82a929a08fe">&#9670;&#160;</a></span>pmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.pmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the weighted power mean along the specified axis.

The weighted power mean of the array :math:`a_i` associated to weights
:math:`w_i` is:

.. math::

\left( \frac{ \sum_{i=1}^n w_i a_i^p }{ \sum_{i=1}^n w_i }
\right)^{ 1 / p } \, ,

and, with equal weights, it gives:

.. math::

\left( \frac{ 1 }{ n } \sum_{i=1}^n a_i^p \right)^{ 1 / p }  \, .

This mean is also called generalized mean or Hlder mean, and must not be
confused with the Kolmogorov generalized mean, also called
quasi-arithmetic mean or generalized f-mean [3]_.

Parameters
----------
a : array_like
Input array, masked array or object that can be converted to an array.
p : int or float
Exponent.
axis : int or None, optional
Axis along which the power mean is computed. Default is 0.
If None, compute over the whole array `a`.
dtype : dtype, optional
Type of the returned array and of the accumulator in which the
elements are summed. If `dtype` is not specified, it defaults to the
dtype of `a`, unless `a` has an integer `dtype` with a precision less
than that of the default platform integer. In that case, the default
platform integer is used.
weights : array_like, optional
The weights array can either be 1-D (in which case its length must be
the size of `a` along the given `axis`) or of the same shape as `a`.
Default is None, which gives each value a weight of 1.0.

Returns
-------
pmean : ndarray, see `dtype` parameter above.
Output array containing the power mean values.

See Also
--------
numpy.average : Weighted average
gmean : Geometric mean
hmean : Harmonic mean

Notes
-----
The power mean is computed over a single dimension of the input
array, ``axis=0`` by default, or all values in the array if ``axis=None``.
float64 intermediate and return values are used for integer inputs.

.. versionadded:: 1.9

References
----------
.. [1] "Generalized Mean", *Wikipedia*,
https://en.wikipedia.org/wiki/Generalized_mean
.. [2] Norris, N., "Convexity properties of generalized mean value
functions", The Annals of Mathematical Statistics, vol. 8,
pp. 118-120, 1937
.. [3] Bullen, P.S., Handbook of Means and Their Inequalities, 2003

Examples
--------
&gt;&gt;&gt; from scipy.stats import pmean, hmean, gmean
&gt;&gt;&gt; pmean([1, 4], 1.3)
2.639372938300652
&gt;&gt;&gt; pmean([1, 2, 3, 4, 5, 6, 7], 1.3)
4.157111214492084
&gt;&gt;&gt; pmean([1, 4, 7], -2, weights=[3, 1, 3])
1.4969684896631954

For p=-1, power mean is equal to harmonic mean:

&gt;&gt;&gt; pmean([1, 4, 7], -1, weights=[3, 1, 3])
1.9029126213592233
&gt;&gt;&gt; hmean([1, 4, 7], weights=[3, 1, 3])
1.9029126213592233

For p=0, power mean is defined as the geometric mean:

&gt;&gt;&gt; pmean([1, 4, 7], 0, weights=[3, 1, 3])
2.80668351922014
&gt;&gt;&gt; gmean([1, 4, 7], weights=[3, 1, 3])
2.80668351922014</pre> <div class="fragment"><div class="line"><span class="lineno">  416</span><span class="keyword">def </span>pmean(a, p, *, axis=0, dtype=None, weights=None):</div>
<div class="line"><span class="lineno">  417</span>    <span class="stringliteral">r&quot;&quot;&quot;Calculate the weighted power mean along the specified axis.</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    The weighted power mean of the array :math:`a_i` associated to weights</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    :math:`w_i` is:</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        \left( \frac{ \sum_{i=1}^n w_i a_i^p }{ \sum_{i=1}^n w_i }</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">              \right)^{ 1 / p } \, ,</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    and, with equal weights, it gives:</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        \left( \frac{ 1 }{ n } \sum_{i=1}^n a_i^p \right)^{ 1 / p }  \, .</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    This mean is also called generalized mean or Hlder mean, and must not be</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    confused with the Kolmogorov generalized mean, also called</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    quasi-arithmetic mean or generalized f-mean [3]_.</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        Input array, masked array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    p : int or float</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">        Exponent.</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">        Axis along which the power mean is computed. Default is 0.</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    dtype : dtype, optional</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        Type of the returned array and of the accumulator in which the</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        elements are summed. If `dtype` is not specified, it defaults to the</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        dtype of `a`, unless `a` has an integer `dtype` with a precision less</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        than that of the default platform integer. In that case, the default</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        platform integer is used.</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        The weights array can either be 1-D (in which case its length must be</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">        the size of `a` along the given `axis`) or of the same shape as `a`.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">        Default is None, which gives each value a weight of 1.0.</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    pmean : ndarray, see `dtype` parameter above.</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        Output array containing the power mean values.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    numpy.average : Weighted average</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    gmean : Geometric mean</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    hmean : Harmonic mean</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    The power mean is computed over a single dimension of the input</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    array, ``axis=0`` by default, or all values in the array if ``axis=None``.</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    float64 intermediate and return values are used for integer inputs.</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    .. versionadded:: 1.9</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    .. [1] &quot;Generalized Mean&quot;, *Wikipedia*,</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Generalized_mean</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    .. [2] Norris, N., &quot;Convexity properties of generalized mean value</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">           functions&quot;, The Annals of Mathematical Statistics, vol. 8,</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">           pp. 118-120, 1937</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    .. [3] Bullen, P.S., Handbook of Means and Their Inequalities, 2003</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import pmean, hmean, gmean</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    &gt;&gt;&gt; pmean([1, 4], 1.3)</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    2.639372938300652</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    &gt;&gt;&gt; pmean([1, 2, 3, 4, 5, 6, 7], 1.3)</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    4.157111214492084</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    &gt;&gt;&gt; pmean([1, 4, 7], -2, weights=[3, 1, 3])</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    1.4969684896631954</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    For p=-1, power mean is equal to harmonic mean:</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    &gt;&gt;&gt; pmean([1, 4, 7], -1, weights=[3, 1, 3])</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    1.9029126213592233</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    &gt;&gt;&gt; hmean([1, 4, 7], weights=[3, 1, 3])</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    1.9029126213592233</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    For p=0, power mean is defined as the geometric mean:</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    &gt;&gt;&gt; pmean([1, 4, 7], 0, weights=[3, 1, 3])</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    2.80668351922014</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    &gt;&gt;&gt; gmean([1, 4, 7], weights=[3, 1, 3])</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    2.80668351922014</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  510</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(p, (int, float)):</div>
<div class="line"><span class="lineno">  511</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Power mean only defined for exponent of type int or &quot;</span></div>
<div class="line"><span class="lineno">  512</span>                         <span class="stringliteral">&quot;float.&quot;</span>)</div>
<div class="line"><span class="lineno">  513</span>    <span class="keywordflow">if</span> p == 0:</div>
<div class="line"><span class="lineno">  514</span>        <span class="keywordflow">return</span> gmean(a, axis=axis, dtype=dtype, weights=weights)</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(a, np.ndarray):</div>
<div class="line"><span class="lineno">  517</span>        a = np.array(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  518</span>    <span class="keywordflow">elif</span> dtype:</div>
<div class="line"><span class="lineno">  519</span>        <span class="comment"># Must change the default dtype allowing array type</span></div>
<div class="line"><span class="lineno">  520</span>        <span class="keywordflow">if</span> isinstance(a, np.ma.MaskedArray):</div>
<div class="line"><span class="lineno">  521</span>            a = np.ma.asarray(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  522</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  523</span>            a = np.asarray(a, dtype=dtype)</div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span>    <span class="keywordflow">if</span> np.all(a &gt;= 0):</div>
<div class="line"><span class="lineno">  526</span>        <span class="comment"># Power mean only defined if greater than or equal to zero</span></div>
<div class="line"><span class="lineno">  527</span>        <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  528</span>            weights = np.asanyarray(weights, dtype=dtype)</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span>        <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno">  531</span>            <span class="keywordflow">return</span> np.float_power(</div>
<div class="line"><span class="lineno">  532</span>                np.average(np.float_power(a, p), axis=axis, weights=weights),</div>
<div class="line"><span class="lineno">  533</span>                1/p)</div>
<div class="line"><span class="lineno">  534</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  535</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Power mean only defined if all elements greater &quot;</span></div>
<div class="line"><span class="lineno">  536</span>                         <span class="stringliteral">&quot;than or equal to zero&quot;</span>)</div>
<div class="line"><span class="lineno">  537</span> </div>
<div class="line"><span class="lineno">  538</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a92e6eba419d8ef505e1e48f9333d995b" name="a92e6eba419d8ef505e1e48f9333d995b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e6eba419d8ef505e1e48f9333d995b">&#9670;&#160;</a></span>pointbiserialr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.pointbiserialr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate a point biserial correlation coefficient and its p-value.

The point biserial correlation is used to measure the relationship
between a binary variable, x, and a continuous variable, y. Like other
correlation coefficients, this one varies between -1 and +1 with 0
implying no correlation. Correlations of -1 or +1 imply a determinative
relationship.

This function uses a shortcut formula but produces the same result as
`pearsonr`.

Parameters
----------
x : array_like of bools
    Input array.
y : array_like
    Input array.

Returns
-------
correlation : float
    R value.
pvalue : float
    Two-sided p-value.

Notes
-----
`pointbiserialr` uses a t-test with ``n-1`` degrees of freedom.
It is equivalent to `pearsonr`.

The value of the point-biserial correlation can be calculated from:

.. math::

    r_{pb} = \frac{\overline{Y_{1}} -
             \overline{Y_{0}}}{s_{y}}\sqrt{\frac{N_{1} N_{2}}{N (N - 1))}}

Where :math:`Y_{0}` and :math:`Y_{1}` are means of the metric
observations coded 0 and 1 respectively; :math:`N_{0}` and :math:`N_{1}`
are number of observations coded 0 and 1 respectively; :math:`N` is the
total number of observations and :math:`s_{y}` is the standard
deviation of all the metric observations.

A value of :math:`r_{pb}` that is significantly different from zero is
completely equivalent to a significant difference in means between the two
groups. Thus, an independent groups t Test with :math:`N-2` degrees of
freedom may be used to test whether :math:`r_{pb}` is nonzero. The
relation between the t-statistic for comparing two independent groups and
:math:`r_{pb}` is given by:

.. math::

    t = \sqrt{N - 2}\frac{r_{pb}}{\sqrt{1 - r^{2}_{pb}}}

References
----------
.. [1] J. Lev, "The Point Biserial Coefficient of Correlation", Ann. Math.
       Statist., Vol. 20, no.1, pp. 125-126, 1949.

.. [2] R.F. Tate, "Correlation Between a Discrete and a Continuous
       Variable. Point-Biserial Correlation.", Ann. Math. Statist., Vol. 25,
       np. 3, pp. 603-607, 1954.

.. [3] D. Kornbrot "Point Biserial Correlation", In Wiley StatsRef:
       Statistics Reference Online (eds N. Balakrishnan, et al.), 2014.
       :doi:`10.1002/9781118445112.stat06227`

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.array([0, 0, 0, 1, 1, 1, 1])
&gt;&gt;&gt; b = np.arange(7)
&gt;&gt;&gt; stats.pointbiserialr(a, b)
(0.8660254037844386, 0.011724811003954652)
&gt;&gt;&gt; stats.pearsonr(a, b)
(0.86602540378443871, 0.011724811003954626)
&gt;&gt;&gt; np.corrcoef(a, b)
array([[ 1.       ,  0.8660254],
       [ 0.8660254,  1.       ]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 4929</span><span class="keyword">def </span>pointbiserialr(x, y):</div>
<div class="line"><span class="lineno"> 4930</span>    <span class="stringliteral">r&quot;&quot;&quot;Calculate a point biserial correlation coefficient and its p-value.</span></div>
<div class="line"><span class="lineno"> 4931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4932</span><span class="stringliteral">    The point biserial correlation is used to measure the relationship</span></div>
<div class="line"><span class="lineno"> 4933</span><span class="stringliteral">    between a binary variable, x, and a continuous variable, y. Like other</span></div>
<div class="line"><span class="lineno"> 4934</span><span class="stringliteral">    correlation coefficients, this one varies between -1 and +1 with 0</span></div>
<div class="line"><span class="lineno"> 4935</span><span class="stringliteral">    implying no correlation. Correlations of -1 or +1 imply a determinative</span></div>
<div class="line"><span class="lineno"> 4936</span><span class="stringliteral">    relationship.</span></div>
<div class="line"><span class="lineno"> 4937</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4938</span><span class="stringliteral">    This function uses a shortcut formula but produces the same result as</span></div>
<div class="line"><span class="lineno"> 4939</span><span class="stringliteral">    `pearsonr`.</span></div>
<div class="line"><span class="lineno"> 4940</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4941</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4942</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4943</span><span class="stringliteral">    x : array_like of bools</span></div>
<div class="line"><span class="lineno"> 4944</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 4945</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno"> 4946</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 4947</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4948</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4949</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4950</span><span class="stringliteral">    correlation : float</span></div>
<div class="line"><span class="lineno"> 4951</span><span class="stringliteral">        R value.</span></div>
<div class="line"><span class="lineno"> 4952</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 4953</span><span class="stringliteral">        Two-sided p-value.</span></div>
<div class="line"><span class="lineno"> 4954</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4955</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4956</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4957</span><span class="stringliteral">    `pointbiserialr` uses a t-test with ``n-1`` degrees of freedom.</span></div>
<div class="line"><span class="lineno"> 4958</span><span class="stringliteral">    It is equivalent to `pearsonr`.</span></div>
<div class="line"><span class="lineno"> 4959</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4960</span><span class="stringliteral">    The value of the point-biserial correlation can be calculated from:</span></div>
<div class="line"><span class="lineno"> 4961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4962</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 4963</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4964</span><span class="stringliteral">        r_{pb} = \frac{\overline{Y_{1}} -</span></div>
<div class="line"><span class="lineno"> 4965</span><span class="stringliteral">                 \overline{Y_{0}}}{s_{y}}\sqrt{\frac{N_{1} N_{2}}{N (N - 1))}}</span></div>
<div class="line"><span class="lineno"> 4966</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4967</span><span class="stringliteral">    Where :math:`Y_{0}` and :math:`Y_{1}` are means of the metric</span></div>
<div class="line"><span class="lineno"> 4968</span><span class="stringliteral">    observations coded 0 and 1 respectively; :math:`N_{0}` and :math:`N_{1}`</span></div>
<div class="line"><span class="lineno"> 4969</span><span class="stringliteral">    are number of observations coded 0 and 1 respectively; :math:`N` is the</span></div>
<div class="line"><span class="lineno"> 4970</span><span class="stringliteral">    total number of observations and :math:`s_{y}` is the standard</span></div>
<div class="line"><span class="lineno"> 4971</span><span class="stringliteral">    deviation of all the metric observations.</span></div>
<div class="line"><span class="lineno"> 4972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4973</span><span class="stringliteral">    A value of :math:`r_{pb}` that is significantly different from zero is</span></div>
<div class="line"><span class="lineno"> 4974</span><span class="stringliteral">    completely equivalent to a significant difference in means between the two</span></div>
<div class="line"><span class="lineno"> 4975</span><span class="stringliteral">    groups. Thus, an independent groups t Test with :math:`N-2` degrees of</span></div>
<div class="line"><span class="lineno"> 4976</span><span class="stringliteral">    freedom may be used to test whether :math:`r_{pb}` is nonzero. The</span></div>
<div class="line"><span class="lineno"> 4977</span><span class="stringliteral">    relation between the t-statistic for comparing two independent groups and</span></div>
<div class="line"><span class="lineno"> 4978</span><span class="stringliteral">    :math:`r_{pb}` is given by:</span></div>
<div class="line"><span class="lineno"> 4979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4980</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 4981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4982</span><span class="stringliteral">        t = \sqrt{N - 2}\frac{r_{pb}}{\sqrt{1 - r^{2}_{pb}}}</span></div>
<div class="line"><span class="lineno"> 4983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4984</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 4985</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4986</span><span class="stringliteral">    .. [1] J. Lev, &quot;The Point Biserial Coefficient of Correlation&quot;, Ann. Math.</span></div>
<div class="line"><span class="lineno"> 4987</span><span class="stringliteral">           Statist., Vol. 20, no.1, pp. 125-126, 1949.</span></div>
<div class="line"><span class="lineno"> 4988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4989</span><span class="stringliteral">    .. [2] R.F. Tate, &quot;Correlation Between a Discrete and a Continuous</span></div>
<div class="line"><span class="lineno"> 4990</span><span class="stringliteral">           Variable. Point-Biserial Correlation.&quot;, Ann. Math. Statist., Vol. 25,</span></div>
<div class="line"><span class="lineno"> 4991</span><span class="stringliteral">           np. 3, pp. 603-607, 1954.</span></div>
<div class="line"><span class="lineno"> 4992</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4993</span><span class="stringliteral">    .. [3] D. Kornbrot &quot;Point Biserial Correlation&quot;, In Wiley StatsRef:</span></div>
<div class="line"><span class="lineno"> 4994</span><span class="stringliteral">           Statistics Reference Online (eds N. Balakrishnan, et al.), 2014.</span></div>
<div class="line"><span class="lineno"> 4995</span><span class="stringliteral">           :doi:`10.1002/9781118445112.stat06227`</span></div>
<div class="line"><span class="lineno"> 4996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4997</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4998</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4999</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 5000</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([0, 0, 0, 1, 1, 1, 1])</span></div>
<div class="line"><span class="lineno"> 5001</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(7)</span></div>
<div class="line"><span class="lineno"> 5002</span><span class="stringliteral">    &gt;&gt;&gt; stats.pointbiserialr(a, b)</span></div>
<div class="line"><span class="lineno"> 5003</span><span class="stringliteral">    (0.8660254037844386, 0.011724811003954652)</span></div>
<div class="line"><span class="lineno"> 5004</span><span class="stringliteral">    &gt;&gt;&gt; stats.pearsonr(a, b)</span></div>
<div class="line"><span class="lineno"> 5005</span><span class="stringliteral">    (0.86602540378443871, 0.011724811003954626)</span></div>
<div class="line"><span class="lineno"> 5006</span><span class="stringliteral">    &gt;&gt;&gt; np.corrcoef(a, b)</span></div>
<div class="line"><span class="lineno"> 5007</span><span class="stringliteral">    array([[ 1.       ,  0.8660254],</span></div>
<div class="line"><span class="lineno"> 5008</span><span class="stringliteral">           [ 0.8660254,  1.       ]])</span></div>
<div class="line"><span class="lineno"> 5009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5010</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5011</span>    rpb, prob = pearsonr(x, y)</div>
<div class="line"><span class="lineno"> 5012</span>    <span class="keywordflow">return</span> PointbiserialrResult(rpb, prob)</div>
<div class="line"><span class="lineno"> 5013</span> </div>
<div class="line"><span class="lineno"> 5014</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a13bf3d4c0145bfe43a1b40826651ea3f" name="a13bf3d4c0145bfe43a1b40826651ea3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bf3d4c0145bfe43a1b40826651ea3f">&#9670;&#160;</a></span>power_divergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.power_divergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f_exp</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lambda_</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cressie-Read power divergence statistic and goodness of fit test.

This function tests the null hypothesis that the categorical data
has the given frequencies, using the Cressie-Read power divergence
statistic.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.
lambda_ : float or str, optional
    The power in the Cressie-Read power divergence statistic.  The default
    is 1.  For convenience, `lambda_` may be assigned one of the following
    strings, in which case the corresponding numerical value is used:

    * ``"pearson"`` (value 1)
        Pearson's chi-squared statistic. In this case, the function is
        equivalent to `chisquare`.
    * ``"log-likelihood"`` (value 0)
        Log-likelihood ratio. Also known as the G-test [3]_.
    * ``"freeman-tukey"`` (value -1/2)
        Freeman-Tukey statistic.
    * ``"mod-log-likelihood"`` (value -1)
        Modified log-likelihood ratio.
    * ``"neyman"`` (value -2)
        Neyman's statistic.
    * ``"cressie-read"`` (value 2/3)
        The power recommended in [5]_.

Returns
-------
statistic : float or ndarray
    The Cressie-Read power divergence test statistic.  The value is
    a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D.
pvalue : float or ndarray
    The p-value of the test.  The value is a float if `ddof` and the
    return value `stat` are scalars.

See Also
--------
chisquare

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.

Also, the sum of the observed and expected frequencies must be the same
for the test to be valid; `power_divergence` raises an error if the sums
do not agree within a relative tolerance of ``1e-8``.

When `lambda_` is less than zero, the formula for the statistic involves
dividing by `f_obs`, so a warning or error may be generated if any value
in `f_obs` is 0.

Similarly, a warning or error may be generated if any value in `f_exp` is
zero when `lambda_` &gt;= 0.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.

This function handles masked arrays.  If an element of `f_obs` or `f_exp`
is masked, then data at that position is ignored, and does not count
towards the size of the data set.

.. versionadded:: 0.13.0

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8.
       https://web.archive.org/web/20171015035606/http://faculty.vassar.edu/lowry/ch8pt1.html
.. [2] "Chi-squared test", https://en.wikipedia.org/wiki/Chi-squared_test
.. [3] "G-test", https://en.wikipedia.org/wiki/G-test
.. [4] Sokal, R. R. and Rohlf, F. J. "Biometry: the principles and
       practice of statistics in biological research", New York: Freeman
       (1981)
.. [5] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
       Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
       pp. 440-464.

Examples
--------
(See `chisquare` for more examples.)

When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.  Here we
perform a G-test (i.e. use the log-likelihood ratio statistic):

&gt;&gt;&gt; from scipy.stats import power_divergence
&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], lambda_='log-likelihood')
(2.006573162632538, 0.84823476779463769)

The expected frequencies can be given with the `f_exp` argument:

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[16, 16, 16, 16, 16, 8],
...                  lambda_='log-likelihood')
(3.3281031458963746, 0.6495419288047497)

When `f_obs` is 2-D, by default the test is applied to each column.

&gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
&gt;&gt;&gt; obs.shape
(6, 2)
&gt;&gt;&gt; power_divergence(obs, lambda_="log-likelihood")
(array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

&gt;&gt;&gt; power_divergence(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
&gt;&gt;&gt; power_divergence(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
test statistic with `ddof`.

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we must use ``axis=1``:

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[[16, 16, 16, 16, 16, 8],
...                         [8, 20, 20, 16, 12, 12]],
...                  axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</pre> <div class="fragment"><div class="line"><span class="lineno"> 6963</span><span class="keyword">def </span>power_divergence(f_obs, f_exp=None, ddof=0, axis=0, lambda_=None):</div>
<div class="line"><span class="lineno"> 6964</span>    <span class="stringliteral">&quot;&quot;&quot;Cressie-Read power divergence statistic and goodness of fit test.</span></div>
<div class="line"><span class="lineno"> 6965</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6966</span><span class="stringliteral">    This function tests the null hypothesis that the categorical data</span></div>
<div class="line"><span class="lineno"> 6967</span><span class="stringliteral">    has the given frequencies, using the Cressie-Read power divergence</span></div>
<div class="line"><span class="lineno"> 6968</span><span class="stringliteral">    statistic.</span></div>
<div class="line"><span class="lineno"> 6969</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6970</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 6971</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6972</span><span class="stringliteral">    f_obs : array_like</span></div>
<div class="line"><span class="lineno"> 6973</span><span class="stringliteral">        Observed frequencies in each category.</span></div>
<div class="line"><span class="lineno"> 6974</span><span class="stringliteral">    f_exp : array_like, optional</span></div>
<div class="line"><span class="lineno"> 6975</span><span class="stringliteral">        Expected frequencies in each category.  By default the categories are</span></div>
<div class="line"><span class="lineno"> 6976</span><span class="stringliteral">        assumed to be equally likely.</span></div>
<div class="line"><span class="lineno"> 6977</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 6978</span><span class="stringliteral">        &quot;Delta degrees of freedom&quot;: adjustment to the degrees of freedom</span></div>
<div class="line"><span class="lineno"> 6979</span><span class="stringliteral">        for the p-value.  The p-value is computed using a chi-squared</span></div>
<div class="line"><span class="lineno"> 6980</span><span class="stringliteral">        distribution with ``k - 1 - ddof`` degrees of freedom, where `k`</span></div>
<div class="line"><span class="lineno"> 6981</span><span class="stringliteral">        is the number of observed frequencies.  The default value of `ddof`</span></div>
<div class="line"><span class="lineno"> 6982</span><span class="stringliteral">        is 0.</span></div>
<div class="line"><span class="lineno"> 6983</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 6984</span><span class="stringliteral">        The axis of the broadcast result of `f_obs` and `f_exp` along which to</span></div>
<div class="line"><span class="lineno"> 6985</span><span class="stringliteral">        apply the test.  If axis is None, all values in `f_obs` are treated</span></div>
<div class="line"><span class="lineno"> 6986</span><span class="stringliteral">        as a single data set.  Default is 0.</span></div>
<div class="line"><span class="lineno"> 6987</span><span class="stringliteral">    lambda_ : float or str, optional</span></div>
<div class="line"><span class="lineno"> 6988</span><span class="stringliteral">        The power in the Cressie-Read power divergence statistic.  The default</span></div>
<div class="line"><span class="lineno"> 6989</span><span class="stringliteral">        is 1.  For convenience, `lambda_` may be assigned one of the following</span></div>
<div class="line"><span class="lineno"> 6990</span><span class="stringliteral">        strings, in which case the corresponding numerical value is used:</span></div>
<div class="line"><span class="lineno"> 6991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6992</span><span class="stringliteral">        * ``&quot;pearson&quot;`` (value 1)</span></div>
<div class="line"><span class="lineno"> 6993</span><span class="stringliteral">            Pearson&#39;s chi-squared statistic. In this case, the function is</span></div>
<div class="line"><span class="lineno"> 6994</span><span class="stringliteral">            equivalent to `chisquare`.</span></div>
<div class="line"><span class="lineno"> 6995</span><span class="stringliteral">        * ``&quot;log-likelihood&quot;`` (value 0)</span></div>
<div class="line"><span class="lineno"> 6996</span><span class="stringliteral">            Log-likelihood ratio. Also known as the G-test [3]_.</span></div>
<div class="line"><span class="lineno"> 6997</span><span class="stringliteral">        * ``&quot;freeman-tukey&quot;`` (value -1/2)</span></div>
<div class="line"><span class="lineno"> 6998</span><span class="stringliteral">            Freeman-Tukey statistic.</span></div>
<div class="line"><span class="lineno"> 6999</span><span class="stringliteral">        * ``&quot;mod-log-likelihood&quot;`` (value -1)</span></div>
<div class="line"><span class="lineno"> 7000</span><span class="stringliteral">            Modified log-likelihood ratio.</span></div>
<div class="line"><span class="lineno"> 7001</span><span class="stringliteral">        * ``&quot;neyman&quot;`` (value -2)</span></div>
<div class="line"><span class="lineno"> 7002</span><span class="stringliteral">            Neyman&#39;s statistic.</span></div>
<div class="line"><span class="lineno"> 7003</span><span class="stringliteral">        * ``&quot;cressie-read&quot;`` (value 2/3)</span></div>
<div class="line"><span class="lineno"> 7004</span><span class="stringliteral">            The power recommended in [5]_.</span></div>
<div class="line"><span class="lineno"> 7005</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7006</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 7007</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 7008</span><span class="stringliteral">    statistic : float or ndarray</span></div>
<div class="line"><span class="lineno"> 7009</span><span class="stringliteral">        The Cressie-Read power divergence test statistic.  The value is</span></div>
<div class="line"><span class="lineno"> 7010</span><span class="stringliteral">        a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D.</span></div>
<div class="line"><span class="lineno"> 7011</span><span class="stringliteral">    pvalue : float or ndarray</span></div>
<div class="line"><span class="lineno"> 7012</span><span class="stringliteral">        The p-value of the test.  The value is a float if `ddof` and the</span></div>
<div class="line"><span class="lineno"> 7013</span><span class="stringliteral">        return value `stat` are scalars.</span></div>
<div class="line"><span class="lineno"> 7014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7015</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 7016</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7017</span><span class="stringliteral">    chisquare</span></div>
<div class="line"><span class="lineno"> 7018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7019</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 7020</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 7021</span><span class="stringliteral">    This test is invalid when the observed or expected frequencies in each</span></div>
<div class="line"><span class="lineno"> 7022</span><span class="stringliteral">    category are too small.  A typical rule is that all of the observed</span></div>
<div class="line"><span class="lineno"> 7023</span><span class="stringliteral">    and expected frequencies should be at least 5.</span></div>
<div class="line"><span class="lineno"> 7024</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7025</span><span class="stringliteral">    Also, the sum of the observed and expected frequencies must be the same</span></div>
<div class="line"><span class="lineno"> 7026</span><span class="stringliteral">    for the test to be valid; `power_divergence` raises an error if the sums</span></div>
<div class="line"><span class="lineno"> 7027</span><span class="stringliteral">    do not agree within a relative tolerance of ``1e-8``.</span></div>
<div class="line"><span class="lineno"> 7028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7029</span><span class="stringliteral">    When `lambda_` is less than zero, the formula for the statistic involves</span></div>
<div class="line"><span class="lineno"> 7030</span><span class="stringliteral">    dividing by `f_obs`, so a warning or error may be generated if any value</span></div>
<div class="line"><span class="lineno"> 7031</span><span class="stringliteral">    in `f_obs` is 0.</span></div>
<div class="line"><span class="lineno"> 7032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7033</span><span class="stringliteral">    Similarly, a warning or error may be generated if any value in `f_exp` is</span></div>
<div class="line"><span class="lineno"> 7034</span><span class="stringliteral">    zero when `lambda_` &gt;= 0.</span></div>
<div class="line"><span class="lineno"> 7035</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7036</span><span class="stringliteral">    The default degrees of freedom, k-1, are for the case when no parameters</span></div>
<div class="line"><span class="lineno"> 7037</span><span class="stringliteral">    of the distribution are estimated. If p parameters are estimated by</span></div>
<div class="line"><span class="lineno"> 7038</span><span class="stringliteral">    efficient maximum likelihood then the correct degrees of freedom are</span></div>
<div class="line"><span class="lineno"> 7039</span><span class="stringliteral">    k-1-p. If the parameters are estimated in a different way, then the</span></div>
<div class="line"><span class="lineno"> 7040</span><span class="stringliteral">    dof can be between k-1-p and k-1. However, it is also possible that</span></div>
<div class="line"><span class="lineno"> 7041</span><span class="stringliteral">    the asymptotic distribution is not a chisquare, in which case this</span></div>
<div class="line"><span class="lineno"> 7042</span><span class="stringliteral">    test is not appropriate.</span></div>
<div class="line"><span class="lineno"> 7043</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7044</span><span class="stringliteral">    This function handles masked arrays.  If an element of `f_obs` or `f_exp`</span></div>
<div class="line"><span class="lineno"> 7045</span><span class="stringliteral">    is masked, then data at that position is ignored, and does not count</span></div>
<div class="line"><span class="lineno"> 7046</span><span class="stringliteral">    towards the size of the data set.</span></div>
<div class="line"><span class="lineno"> 7047</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7048</span><span class="stringliteral">    .. versionadded:: 0.13.0</span></div>
<div class="line"><span class="lineno"> 7049</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7050</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 7051</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 7052</span><span class="stringliteral">    .. [1] Lowry, Richard.  &quot;Concepts and Applications of Inferential</span></div>
<div class="line"><span class="lineno"> 7053</span><span class="stringliteral">           Statistics&quot;. Chapter 8.</span></div>
<div class="line"><span class="lineno"> 7054</span><span class="stringliteral">           https://web.archive.org/web/20171015035606/http://faculty.vassar.edu/lowry/ch8pt1.html</span></div>
<div class="line"><span class="lineno"> 7055</span><span class="stringliteral">    .. [2] &quot;Chi-squared test&quot;, https://en.wikipedia.org/wiki/Chi-squared_test</span></div>
<div class="line"><span class="lineno"> 7056</span><span class="stringliteral">    .. [3] &quot;G-test&quot;, https://en.wikipedia.org/wiki/G-test</span></div>
<div class="line"><span class="lineno"> 7057</span><span class="stringliteral">    .. [4] Sokal, R. R. and Rohlf, F. J. &quot;Biometry: the principles and</span></div>
<div class="line"><span class="lineno"> 7058</span><span class="stringliteral">           practice of statistics in biological research&quot;, New York: Freeman</span></div>
<div class="line"><span class="lineno"> 7059</span><span class="stringliteral">           (1981)</span></div>
<div class="line"><span class="lineno"> 7060</span><span class="stringliteral">    .. [5] Cressie, N. and Read, T. R. C., &quot;Multinomial Goodness-of-Fit</span></div>
<div class="line"><span class="lineno"> 7061</span><span class="stringliteral">           Tests&quot;, J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),</span></div>
<div class="line"><span class="lineno"> 7062</span><span class="stringliteral">           pp. 440-464.</span></div>
<div class="line"><span class="lineno"> 7063</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7064</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 7065</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 7066</span><span class="stringliteral">    (See `chisquare` for more examples.)</span></div>
<div class="line"><span class="lineno"> 7067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7068</span><span class="stringliteral">    When just `f_obs` is given, it is assumed that the expected frequencies</span></div>
<div class="line"><span class="lineno"> 7069</span><span class="stringliteral">    are uniform and given by the mean of the observed frequencies.  Here we</span></div>
<div class="line"><span class="lineno"> 7070</span><span class="stringliteral">    perform a G-test (i.e. use the log-likelihood ratio statistic):</span></div>
<div class="line"><span class="lineno"> 7071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7072</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import power_divergence</span></div>
<div class="line"><span class="lineno"> 7073</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], lambda_=&#39;log-likelihood&#39;)</span></div>
<div class="line"><span class="lineno"> 7074</span><span class="stringliteral">    (2.006573162632538, 0.84823476779463769)</span></div>
<div class="line"><span class="lineno"> 7075</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7076</span><span class="stringliteral">    The expected frequencies can be given with the `f_exp` argument:</span></div>
<div class="line"><span class="lineno"> 7077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7078</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12],</span></div>
<div class="line"><span class="lineno"> 7079</span><span class="stringliteral">    ...                  f_exp=[16, 16, 16, 16, 16, 8],</span></div>
<div class="line"><span class="lineno"> 7080</span><span class="stringliteral">    ...                  lambda_=&#39;log-likelihood&#39;)</span></div>
<div class="line"><span class="lineno"> 7081</span><span class="stringliteral">    (3.3281031458963746, 0.6495419288047497)</span></div>
<div class="line"><span class="lineno"> 7082</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7083</span><span class="stringliteral">    When `f_obs` is 2-D, by default the test is applied to each column.</span></div>
<div class="line"><span class="lineno"> 7084</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7085</span><span class="stringliteral">    &gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T</span></div>
<div class="line"><span class="lineno"> 7086</span><span class="stringliteral">    &gt;&gt;&gt; obs.shape</span></div>
<div class="line"><span class="lineno"> 7087</span><span class="stringliteral">    (6, 2)</span></div>
<div class="line"><span class="lineno"> 7088</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence(obs, lambda_=&quot;log-likelihood&quot;)</span></div>
<div class="line"><span class="lineno"> 7089</span><span class="stringliteral">    (array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225]))</span></div>
<div class="line"><span class="lineno"> 7090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7091</span><span class="stringliteral">    By setting ``axis=None``, the test is applied to all data in the array,</span></div>
<div class="line"><span class="lineno"> 7092</span><span class="stringliteral">    which is equivalent to applying the test to the flattened array.</span></div>
<div class="line"><span class="lineno"> 7093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7094</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence(obs, axis=None)</span></div>
<div class="line"><span class="lineno"> 7095</span><span class="stringliteral">    (23.31034482758621, 0.015975692534127565)</span></div>
<div class="line"><span class="lineno"> 7096</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence(obs.ravel())</span></div>
<div class="line"><span class="lineno"> 7097</span><span class="stringliteral">    (23.31034482758621, 0.015975692534127565)</span></div>
<div class="line"><span class="lineno"> 7098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7099</span><span class="stringliteral">    `ddof` is the change to make to the default degrees of freedom.</span></div>
<div class="line"><span class="lineno"> 7100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7101</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=1)</span></div>
<div class="line"><span class="lineno"> 7102</span><span class="stringliteral">    (2.0, 0.73575888234288467)</span></div>
<div class="line"><span class="lineno"> 7103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7104</span><span class="stringliteral">    The calculation of the p-values is done by broadcasting the</span></div>
<div class="line"><span class="lineno"> 7105</span><span class="stringliteral">    test statistic with `ddof`.</span></div>
<div class="line"><span class="lineno"> 7106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7107</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=[0,1,2])</span></div>
<div class="line"><span class="lineno"> 7108</span><span class="stringliteral">    (2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))</span></div>
<div class="line"><span class="lineno"> 7109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7110</span><span class="stringliteral">    `f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has</span></div>
<div class="line"><span class="lineno"> 7111</span><span class="stringliteral">    shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting</span></div>
<div class="line"><span class="lineno"> 7112</span><span class="stringliteral">    `f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared</span></div>
<div class="line"><span class="lineno"> 7113</span><span class="stringliteral">    statistics, we must use ``axis=1``:</span></div>
<div class="line"><span class="lineno"> 7114</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7115</span><span class="stringliteral">    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12],</span></div>
<div class="line"><span class="lineno"> 7116</span><span class="stringliteral">    ...                  f_exp=[[16, 16, 16, 16, 16, 8],</span></div>
<div class="line"><span class="lineno"> 7117</span><span class="stringliteral">    ...                         [8, 20, 20, 16, 12, 12]],</span></div>
<div class="line"><span class="lineno"> 7118</span><span class="stringliteral">    ...                  axis=1)</span></div>
<div class="line"><span class="lineno"> 7119</span><span class="stringliteral">    (array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</span></div>
<div class="line"><span class="lineno"> 7120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7121</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7122</span>    <span class="comment"># Convert the input argument `lambda_` to a numerical value.</span></div>
<div class="line"><span class="lineno"> 7123</span>    <span class="keywordflow">if</span> isinstance(lambda_, str):</div>
<div class="line"><span class="lineno"> 7124</span>        <span class="keywordflow">if</span> lambda_ <span class="keywordflow">not</span> <span class="keywordflow">in</span> _power_div_lambda_names:</div>
<div class="line"><span class="lineno"> 7125</span>            names = repr(list(_power_div_lambda_names.keys()))[1:-1]</div>
<div class="line"><span class="lineno"> 7126</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;invalid string for lambda_: {0!r}. &quot;</span></div>
<div class="line"><span class="lineno"> 7127</span>                             <span class="stringliteral">&quot;Valid strings are {1}&quot;</span>.format(lambda_, names))</div>
<div class="line"><span class="lineno"> 7128</span>        lambda_ = _power_div_lambda_names[lambda_]</div>
<div class="line"><span class="lineno"> 7129</span>    <span class="keywordflow">elif</span> lambda_ <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 7130</span>        lambda_ = 1</div>
<div class="line"><span class="lineno"> 7131</span> </div>
<div class="line"><span class="lineno"> 7132</span>    f_obs = np.asanyarray(f_obs)</div>
<div class="line"><span class="lineno"> 7133</span>    f_obs_float = f_obs.astype(np.float64)</div>
<div class="line"><span class="lineno"> 7134</span> </div>
<div class="line"><span class="lineno"> 7135</span>    <span class="keywordflow">if</span> f_exp <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 7136</span>        f_exp = np.asanyarray(f_exp)</div>
<div class="line"><span class="lineno"> 7137</span>        bshape = _broadcast_shapes(f_obs_float.shape, f_exp.shape)</div>
<div class="line"><span class="lineno"> 7138</span>        f_obs_float = _m_broadcast_to(f_obs_float, bshape)</div>
<div class="line"><span class="lineno"> 7139</span>        f_exp = _m_broadcast_to(f_exp, bshape)</div>
<div class="line"><span class="lineno"> 7140</span>        rtol = 1e-8  <span class="comment"># to pass existing tests</span></div>
<div class="line"><span class="lineno"> 7141</span>        <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 7142</span>            f_obs_sum = f_obs_float.sum(axis=axis)</div>
<div class="line"><span class="lineno"> 7143</span>            f_exp_sum = f_exp.sum(axis=axis)</div>
<div class="line"><span class="lineno"> 7144</span>            relative_diff = (np.abs(f_obs_sum - f_exp_sum) /</div>
<div class="line"><span class="lineno"> 7145</span>                             np.minimum(f_obs_sum, f_exp_sum))</div>
<div class="line"><span class="lineno"> 7146</span>            diff_gt_tol = (relative_diff &gt; rtol).any()</div>
<div class="line"><span class="lineno"> 7147</span>        <span class="keywordflow">if</span> diff_gt_tol:</div>
<div class="line"><span class="lineno"> 7148</span>            msg = (f<span class="stringliteral">&quot;For each axis slice, the sum of the observed &quot;</span></div>
<div class="line"><span class="lineno"> 7149</span>                   f<span class="stringliteral">&quot;frequencies must agree with the sum of the &quot;</span></div>
<div class="line"><span class="lineno"> 7150</span>                   f<span class="stringliteral">&quot;expected frequencies to a relative tolerance &quot;</span></div>
<div class="line"><span class="lineno"> 7151</span>                   f<span class="stringliteral">&quot;of {rtol}, but the percent differences are:\n&quot;</span></div>
<div class="line"><span class="lineno"> 7152</span>                   f<span class="stringliteral">&quot;{relative_diff}&quot;</span>)</div>
<div class="line"><span class="lineno"> 7153</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 7154</span> </div>
<div class="line"><span class="lineno"> 7155</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7156</span>        <span class="comment"># Ignore &#39;invalid&#39; errors so the edge case of a data set with length 0</span></div>
<div class="line"><span class="lineno"> 7157</span>        <span class="comment"># is handled without spurious warnings.</span></div>
<div class="line"><span class="lineno"> 7158</span>        <span class="keyword">with</span> np.errstate(invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 7159</span>            f_exp = f_obs.mean(axis=axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 7160</span> </div>
<div class="line"><span class="lineno"> 7161</span>    <span class="comment"># `terms` is the array of terms that are summed along `axis` to create</span></div>
<div class="line"><span class="lineno"> 7162</span>    <span class="comment"># the test statistic.  We use some specialized code for a few special</span></div>
<div class="line"><span class="lineno"> 7163</span>    <span class="comment"># cases of lambda_.</span></div>
<div class="line"><span class="lineno"> 7164</span>    <span class="keywordflow">if</span> lambda_ == 1:</div>
<div class="line"><span class="lineno"> 7165</span>        <span class="comment"># Pearson&#39;s chi-squared statistic</span></div>
<div class="line"><span class="lineno"> 7166</span>        terms = (f_obs_float - f_exp)**2 / f_exp</div>
<div class="line"><span class="lineno"> 7167</span>    <span class="keywordflow">elif</span> lambda_ == 0:</div>
<div class="line"><span class="lineno"> 7168</span>        <span class="comment"># Log-likelihood ratio (i.e. G-test)</span></div>
<div class="line"><span class="lineno"> 7169</span>        terms = 2.0 * special.xlogy(f_obs, f_obs / f_exp)</div>
<div class="line"><span class="lineno"> 7170</span>    <span class="keywordflow">elif</span> lambda_ == -1:</div>
<div class="line"><span class="lineno"> 7171</span>        <span class="comment"># Modified log-likelihood ratio</span></div>
<div class="line"><span class="lineno"> 7172</span>        terms = 2.0 * special.xlogy(f_exp, f_exp / f_obs)</div>
<div class="line"><span class="lineno"> 7173</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7174</span>        <span class="comment"># General Cressie-Read power divergence.</span></div>
<div class="line"><span class="lineno"> 7175</span>        terms = f_obs * ((f_obs / f_exp)**lambda_ - 1)</div>
<div class="line"><span class="lineno"> 7176</span>        terms /= 0.5 * lambda_ * (lambda_ + 1)</div>
<div class="line"><span class="lineno"> 7177</span> </div>
<div class="line"><span class="lineno"> 7178</span>    stat = terms.sum(axis=axis)</div>
<div class="line"><span class="lineno"> 7179</span> </div>
<div class="line"><span class="lineno"> 7180</span>    num_obs = _count(terms, axis=axis)</div>
<div class="line"><span class="lineno"> 7181</span>    ddof = asarray(ddof)</div>
<div class="line"><span class="lineno"> 7182</span>    p = distributions.chi2.sf(stat, num_obs - 1 - ddof)</div>
<div class="line"><span class="lineno"> 7183</span> </div>
<div class="line"><span class="lineno"> 7184</span>    <span class="keywordflow">return</span> Power_divergenceResult(stat, p)</div>
<div class="line"><span class="lineno"> 7185</span> </div>
<div class="line"><span class="lineno"> 7186</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae086c216e46ddf283e278492955e93b6" name="ae086c216e46ddf283e278492955e93b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae086c216e46ddf283e278492955e93b6">&#9670;&#160;</a></span>rankdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.rankdata </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'average'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assign ranks to data, dealing with ties appropriately.

By default (``axis=None``), the data array is first flattened, and a flat
array of ranks is returned. Separately reshape the rank array to the
shape of the data array if desired (see Examples).

Ranks begin at 1.  The `method` argument controls how ranks are assigned
to equal values.  See [1]_ for further discussion of ranking methods.

Parameters
----------
a : array_like
    The array of values to be ranked.
method : {'average', 'min', 'max', 'dense', 'ordinal'}, optional
    The method used to assign ranks to tied elements.
    The following methods are available (default is 'average'):

      * 'average': The average of the ranks that would have been assigned to
        all the tied values is assigned to each value.
      * 'min': The minimum of the ranks that would have been assigned to all
        the tied values is assigned to each value.  (This is also
        referred to as "competition" ranking.)
      * 'max': The maximum of the ranks that would have been assigned to all
        the tied values is assigned to each value.
      * 'dense': Like 'min', but the rank of the next highest element is
        assigned the rank immediately after those assigned to the tied
        elements.
      * 'ordinal': All values are given a distinct rank, corresponding to
        the order that the values occur in `a`.
axis : {None, int}, optional
    Axis along which to perform the ranking. If ``None``, the data array
    is first flattened.

Returns
-------
ranks : ndarray
     An array of size equal to the size of `a`, containing rank
     scores.

References
----------
.. [1] "Ranking", https://en.wikipedia.org/wiki/Ranking

Examples
--------
&gt;&gt;&gt; from scipy.stats import rankdata
&gt;&gt;&gt; rankdata([0, 2, 3, 2])
array([ 1. ,  2.5,  4. ,  2.5])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='min')
array([ 1,  2,  4,  2])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='max')
array([ 1,  3,  4,  3])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='dense')
array([ 1,  2,  3,  2])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='ordinal')
array([ 1,  2,  4,  3])
&gt;&gt;&gt; rankdata([[0, 2], [3, 2]]).reshape(2,2)
array([[1. , 2.5],
      [4. , 2.5]])
&gt;&gt;&gt; rankdata([[0, 2, 2], [3, 2, 5]], axis=1)
array([[1. , 2.5, 2.5],
       [2. , 1. , 3. ]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 9065</span><span class="keyword">def </span>rankdata(a, method=&#39;average&#39;, *, axis=None):</div>
<div class="line"><span class="lineno"> 9066</span>    <span class="stringliteral">&quot;&quot;&quot;Assign ranks to data, dealing with ties appropriately.</span></div>
<div class="line"><span class="lineno"> 9067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9068</span><span class="stringliteral">    By default (``axis=None``), the data array is first flattened, and a flat</span></div>
<div class="line"><span class="lineno"> 9069</span><span class="stringliteral">    array of ranks is returned. Separately reshape the rank array to the</span></div>
<div class="line"><span class="lineno"> 9070</span><span class="stringliteral">    shape of the data array if desired (see Examples).</span></div>
<div class="line"><span class="lineno"> 9071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9072</span><span class="stringliteral">    Ranks begin at 1.  The `method` argument controls how ranks are assigned</span></div>
<div class="line"><span class="lineno"> 9073</span><span class="stringliteral">    to equal values.  See [1]_ for further discussion of ranking methods.</span></div>
<div class="line"><span class="lineno"> 9074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9075</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 9076</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 9077</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 9078</span><span class="stringliteral">        The array of values to be ranked.</span></div>
<div class="line"><span class="lineno"> 9079</span><span class="stringliteral">    method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;dense&#39;, &#39;ordinal&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 9080</span><span class="stringliteral">        The method used to assign ranks to tied elements.</span></div>
<div class="line"><span class="lineno"> 9081</span><span class="stringliteral">        The following methods are available (default is &#39;average&#39;):</span></div>
<div class="line"><span class="lineno"> 9082</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9083</span><span class="stringliteral">          * &#39;average&#39;: The average of the ranks that would have been assigned to</span></div>
<div class="line"><span class="lineno"> 9084</span><span class="stringliteral">            all the tied values is assigned to each value.</span></div>
<div class="line"><span class="lineno"> 9085</span><span class="stringliteral">          * &#39;min&#39;: The minimum of the ranks that would have been assigned to all</span></div>
<div class="line"><span class="lineno"> 9086</span><span class="stringliteral">            the tied values is assigned to each value.  (This is also</span></div>
<div class="line"><span class="lineno"> 9087</span><span class="stringliteral">            referred to as &quot;competition&quot; ranking.)</span></div>
<div class="line"><span class="lineno"> 9088</span><span class="stringliteral">          * &#39;max&#39;: The maximum of the ranks that would have been assigned to all</span></div>
<div class="line"><span class="lineno"> 9089</span><span class="stringliteral">            the tied values is assigned to each value.</span></div>
<div class="line"><span class="lineno"> 9090</span><span class="stringliteral">          * &#39;dense&#39;: Like &#39;min&#39;, but the rank of the next highest element is</span></div>
<div class="line"><span class="lineno"> 9091</span><span class="stringliteral">            assigned the rank immediately after those assigned to the tied</span></div>
<div class="line"><span class="lineno"> 9092</span><span class="stringliteral">            elements.</span></div>
<div class="line"><span class="lineno"> 9093</span><span class="stringliteral">          * &#39;ordinal&#39;: All values are given a distinct rank, corresponding to</span></div>
<div class="line"><span class="lineno"> 9094</span><span class="stringliteral">            the order that the values occur in `a`.</span></div>
<div class="line"><span class="lineno"> 9095</span><span class="stringliteral">    axis : {None, int}, optional</span></div>
<div class="line"><span class="lineno"> 9096</span><span class="stringliteral">        Axis along which to perform the ranking. If ``None``, the data array</span></div>
<div class="line"><span class="lineno"> 9097</span><span class="stringliteral">        is first flattened.</span></div>
<div class="line"><span class="lineno"> 9098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9099</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 9100</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 9101</span><span class="stringliteral">    ranks : ndarray</span></div>
<div class="line"><span class="lineno"> 9102</span><span class="stringliteral">         An array of size equal to the size of `a`, containing rank</span></div>
<div class="line"><span class="lineno"> 9103</span><span class="stringliteral">         scores.</span></div>
<div class="line"><span class="lineno"> 9104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9105</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 9106</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 9107</span><span class="stringliteral">    .. [1] &quot;Ranking&quot;, https://en.wikipedia.org/wiki/Ranking</span></div>
<div class="line"><span class="lineno"> 9108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9109</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 9110</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 9111</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import rankdata</span></div>
<div class="line"><span class="lineno"> 9112</span><span class="stringliteral">    &gt;&gt;&gt; rankdata([0, 2, 3, 2])</span></div>
<div class="line"><span class="lineno"> 9113</span><span class="stringliteral">    array([ 1. ,  2.5,  4. ,  2.5])</span></div>
<div class="line"><span class="lineno"> 9114</span><span class="stringliteral">    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method=&#39;min&#39;)</span></div>
<div class="line"><span class="lineno"> 9115</span><span class="stringliteral">    array([ 1,  2,  4,  2])</span></div>
<div class="line"><span class="lineno"> 9116</span><span class="stringliteral">    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method=&#39;max&#39;)</span></div>
<div class="line"><span class="lineno"> 9117</span><span class="stringliteral">    array([ 1,  3,  4,  3])</span></div>
<div class="line"><span class="lineno"> 9118</span><span class="stringliteral">    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method=&#39;dense&#39;)</span></div>
<div class="line"><span class="lineno"> 9119</span><span class="stringliteral">    array([ 1,  2,  3,  2])</span></div>
<div class="line"><span class="lineno"> 9120</span><span class="stringliteral">    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method=&#39;ordinal&#39;)</span></div>
<div class="line"><span class="lineno"> 9121</span><span class="stringliteral">    array([ 1,  2,  4,  3])</span></div>
<div class="line"><span class="lineno"> 9122</span><span class="stringliteral">    &gt;&gt;&gt; rankdata([[0, 2], [3, 2]]).reshape(2,2)</span></div>
<div class="line"><span class="lineno"> 9123</span><span class="stringliteral">    array([[1. , 2.5],</span></div>
<div class="line"><span class="lineno"> 9124</span><span class="stringliteral">          [4. , 2.5]])</span></div>
<div class="line"><span class="lineno"> 9125</span><span class="stringliteral">    &gt;&gt;&gt; rankdata([[0, 2, 2], [3, 2, 5]], axis=1)</span></div>
<div class="line"><span class="lineno"> 9126</span><span class="stringliteral">    array([[1. , 2.5, 2.5],</span></div>
<div class="line"><span class="lineno"> 9127</span><span class="stringliteral">           [2. , 1. , 3. ]])</span></div>
<div class="line"><span class="lineno"> 9128</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 9129</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 9130</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&#39;average&#39;</span>, <span class="stringliteral">&#39;min&#39;</span>, <span class="stringliteral">&#39;max&#39;</span>, <span class="stringliteral">&#39;dense&#39;</span>, <span class="stringliteral">&#39;ordinal&#39;</span>):</div>
<div class="line"><span class="lineno"> 9131</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;unknown method &quot;{0}&quot;&#39;</span>.format(method))</div>
<div class="line"><span class="lineno"> 9132</span> </div>
<div class="line"><span class="lineno"> 9133</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 9134</span>        a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 9135</span>        <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 9136</span>            <span class="comment"># The return values of `normalize_axis_index` are ignored.  The</span></div>
<div class="line"><span class="lineno"> 9137</span>            <span class="comment"># call validates `axis`, even though we won&#39;t use it.</span></div>
<div class="line"><span class="lineno"> 9138</span>            <span class="comment"># use scipy._lib._util._normalize_axis_index when available</span></div>
<div class="line"><span class="lineno"> 9139</span>            np.core.multiarray.normalize_axis_index(axis, a.ndim)</div>
<div class="line"><span class="lineno"> 9140</span>            dt = np.float64 <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;average&#39;</span> <span class="keywordflow">else</span> np.int_</div>
<div class="line"><span class="lineno"> 9141</span>            <span class="keywordflow">return</span> np.empty(a.shape, dtype=dt)</div>
<div class="line"><span class="lineno"> 9142</span>        <span class="keywordflow">return</span> np.apply_along_axis(rankdata, axis, a, method)</div>
<div class="line"><span class="lineno"> 9143</span> </div>
<div class="line"><span class="lineno"> 9144</span>    arr = np.ravel(np.asarray(a))</div>
<div class="line"><span class="lineno"> 9145</span>    algo = <span class="stringliteral">&#39;mergesort&#39;</span> <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;ordinal&#39;</span> <span class="keywordflow">else</span> <span class="stringliteral">&#39;quicksort&#39;</span></div>
<div class="line"><span class="lineno"> 9146</span>    sorter = np.argsort(arr, kind=algo)</div>
<div class="line"><span class="lineno"> 9147</span> </div>
<div class="line"><span class="lineno"> 9148</span>    inv = np.empty(sorter.size, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 9149</span>    inv[sorter] = np.arange(sorter.size, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 9150</span> </div>
<div class="line"><span class="lineno"> 9151</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;ordinal&#39;</span>:</div>
<div class="line"><span class="lineno"> 9152</span>        <span class="keywordflow">return</span> inv + 1</div>
<div class="line"><span class="lineno"> 9153</span> </div>
<div class="line"><span class="lineno"> 9154</span>    arr = arr[sorter]</div>
<div class="line"><span class="lineno"> 9155</span>    obs = np.r_[<span class="keyword">True</span>, arr[1:] != arr[:-1]]</div>
<div class="line"><span class="lineno"> 9156</span>    dense = obs.cumsum()[inv]</div>
<div class="line"><span class="lineno"> 9157</span> </div>
<div class="line"><span class="lineno"> 9158</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;dense&#39;</span>:</div>
<div class="line"><span class="lineno"> 9159</span>        <span class="keywordflow">return</span> dense</div>
<div class="line"><span class="lineno"> 9160</span> </div>
<div class="line"><span class="lineno"> 9161</span>    <span class="comment"># cumulative counts of each unique value</span></div>
<div class="line"><span class="lineno"> 9162</span>    count = np.r_[np.nonzero(obs)[0], len(obs)]</div>
<div class="line"><span class="lineno"> 9163</span> </div>
<div class="line"><span class="lineno"> 9164</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;max&#39;</span>:</div>
<div class="line"><span class="lineno"> 9165</span>        <span class="keywordflow">return</span> count[dense]</div>
<div class="line"><span class="lineno"> 9166</span> </div>
<div class="line"><span class="lineno"> 9167</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;min&#39;</span>:</div>
<div class="line"><span class="lineno"> 9168</span>        <span class="keywordflow">return</span> count[dense - 1] + 1</div>
<div class="line"><span class="lineno"> 9169</span> </div>
<div class="line"><span class="lineno"> 9170</span>    <span class="comment"># average method</span></div>
<div class="line"><span class="lineno"> 9171</span>    <span class="keywordflow">return</span> .5 * (count[dense] + count[dense - 1] + 1)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c9e3566461d8bb479cb9507e9a1bd2e" name="a5c9e3566461d8bb479cb9507e9a1bd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9e3566461d8bb479cb9507e9a1bd2e">&#9670;&#160;</a></span>ranksums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ranksums </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Wilcoxon rank-sum statistic for two samples.

The Wilcoxon rank-sum test tests the null hypothesis that two sets
of measurements are drawn from the same distribution.  The alternative
hypothesis is that values in one sample are more likely to be
larger than the values in the other sample.

This test should be used to compare two samples from continuous
distributions.  It does not handle ties between measurements
in x and y.  For tie-handling and an optional continuity correction
see `scipy.stats.mannwhitneyu`.

Parameters
----------
x,y : array_like
    The data from the two samples.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': one of the distributions (underlying `x` or `y`) is
      stochastically greater than the other.
    * 'less': the distribution underlying `x` is stochastically less
      than the distribution underlying `y`.
    * 'greater': the distribution underlying `x` is stochastically greater
      than the distribution underlying `y`.

    .. versionadded:: 1.7.0

Returns
-------
statistic : float
    The test statistic under the large-sample approximation that the
    rank sum statistic is normally distributed.
pvalue : float
    The p-value of the test.

References
----------
.. [1] https://en.wikipedia.org/wiki/Wilcoxon_rank-sum_test

Examples
--------
We can test the hypothesis that two independent unequal-sized samples are
drawn from the same distribution with computing the Wilcoxon rank-sum
statistic.

&gt;&gt;&gt; from scipy.stats import ranksums
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; sample1 = rng.uniform(-1, 1, 200)
&gt;&gt;&gt; sample2 = rng.uniform(-0.5, 1.5, 300) # a shifted distribution
&gt;&gt;&gt; ranksums(sample1, sample2)
RanksumsResult(statistic=-7.887059, pvalue=3.09390448e-15)  # may vary
&gt;&gt;&gt; ranksums(sample1, sample2, alternative='less')
RanksumsResult(statistic=-7.750585297581713, pvalue=4.573497606342543e-15) # may vary
&gt;&gt;&gt; ranksums(sample1, sample2, alternative='greater')
RanksumsResult(statistic=-7.750585297581713, pvalue=0.9999999999999954) # may vary

The p-value of less than ``0.05`` indicates that this test rejects the
hypothesis at the 5% significance level.</pre> <div class="fragment"><div class="line"><span class="lineno"> 8109</span><span class="keyword">def </span>ranksums(x, y, alternative=&#39;two-sided&#39;):</div>
<div class="line"><span class="lineno"> 8110</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the Wilcoxon rank-sum statistic for two samples.</span></div>
<div class="line"><span class="lineno"> 8111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8112</span><span class="stringliteral">    The Wilcoxon rank-sum test tests the null hypothesis that two sets</span></div>
<div class="line"><span class="lineno"> 8113</span><span class="stringliteral">    of measurements are drawn from the same distribution.  The alternative</span></div>
<div class="line"><span class="lineno"> 8114</span><span class="stringliteral">    hypothesis is that values in one sample are more likely to be</span></div>
<div class="line"><span class="lineno"> 8115</span><span class="stringliteral">    larger than the values in the other sample.</span></div>
<div class="line"><span class="lineno"> 8116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8117</span><span class="stringliteral">    This test should be used to compare two samples from continuous</span></div>
<div class="line"><span class="lineno"> 8118</span><span class="stringliteral">    distributions.  It does not handle ties between measurements</span></div>
<div class="line"><span class="lineno"> 8119</span><span class="stringliteral">    in x and y.  For tie-handling and an optional continuity correction</span></div>
<div class="line"><span class="lineno"> 8120</span><span class="stringliteral">    see `scipy.stats.mannwhitneyu`.</span></div>
<div class="line"><span class="lineno"> 8121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8122</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8123</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8124</span><span class="stringliteral">    x,y : array_like</span></div>
<div class="line"><span class="lineno"> 8125</span><span class="stringliteral">        The data from the two samples.</span></div>
<div class="line"><span class="lineno"> 8126</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 8127</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 8128</span><span class="stringliteral">        The following options are available:</span></div>
<div class="line"><span class="lineno"> 8129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8130</span><span class="stringliteral">        * &#39;two-sided&#39;: one of the distributions (underlying `x` or `y`) is</span></div>
<div class="line"><span class="lineno"> 8131</span><span class="stringliteral">          stochastically greater than the other.</span></div>
<div class="line"><span class="lineno"> 8132</span><span class="stringliteral">        * &#39;less&#39;: the distribution underlying `x` is stochastically less</span></div>
<div class="line"><span class="lineno"> 8133</span><span class="stringliteral">          than the distribution underlying `y`.</span></div>
<div class="line"><span class="lineno"> 8134</span><span class="stringliteral">        * &#39;greater&#39;: the distribution underlying `x` is stochastically greater</span></div>
<div class="line"><span class="lineno"> 8135</span><span class="stringliteral">          than the distribution underlying `y`.</span></div>
<div class="line"><span class="lineno"> 8136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8137</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 8138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8139</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8140</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8141</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 8142</span><span class="stringliteral">        The test statistic under the large-sample approximation that the</span></div>
<div class="line"><span class="lineno"> 8143</span><span class="stringliteral">        rank sum statistic is normally distributed.</span></div>
<div class="line"><span class="lineno"> 8144</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 8145</span><span class="stringliteral">        The p-value of the test.</span></div>
<div class="line"><span class="lineno"> 8146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8147</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8148</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8149</span><span class="stringliteral">    .. [1] https://en.wikipedia.org/wiki/Wilcoxon_rank-sum_test</span></div>
<div class="line"><span class="lineno"> 8150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8151</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 8152</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8153</span><span class="stringliteral">    We can test the hypothesis that two independent unequal-sized samples are</span></div>
<div class="line"><span class="lineno"> 8154</span><span class="stringliteral">    drawn from the same distribution with computing the Wilcoxon rank-sum</span></div>
<div class="line"><span class="lineno"> 8155</span><span class="stringliteral">    statistic.</span></div>
<div class="line"><span class="lineno"> 8156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8157</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import ranksums</span></div>
<div class="line"><span class="lineno"> 8158</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 8159</span><span class="stringliteral">    &gt;&gt;&gt; sample1 = rng.uniform(-1, 1, 200)</span></div>
<div class="line"><span class="lineno"> 8160</span><span class="stringliteral">    &gt;&gt;&gt; sample2 = rng.uniform(-0.5, 1.5, 300) # a shifted distribution</span></div>
<div class="line"><span class="lineno"> 8161</span><span class="stringliteral">    &gt;&gt;&gt; ranksums(sample1, sample2)</span></div>
<div class="line"><span class="lineno"> 8162</span><span class="stringliteral">    RanksumsResult(statistic=-7.887059, pvalue=3.09390448e-15)  # may vary</span></div>
<div class="line"><span class="lineno"> 8163</span><span class="stringliteral">    &gt;&gt;&gt; ranksums(sample1, sample2, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 8164</span><span class="stringliteral">    RanksumsResult(statistic=-7.750585297581713, pvalue=4.573497606342543e-15) # may vary</span></div>
<div class="line"><span class="lineno"> 8165</span><span class="stringliteral">    &gt;&gt;&gt; ranksums(sample1, sample2, alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 8166</span><span class="stringliteral">    RanksumsResult(statistic=-7.750585297581713, pvalue=0.9999999999999954) # may vary</span></div>
<div class="line"><span class="lineno"> 8167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8168</span><span class="stringliteral">    The p-value of less than ``0.05`` indicates that this test rejects the</span></div>
<div class="line"><span class="lineno"> 8169</span><span class="stringliteral">    hypothesis at the 5% significance level.</span></div>
<div class="line"><span class="lineno"> 8170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8171</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8172</span>    x, y = map(np.asarray, (x, y))</div>
<div class="line"><span class="lineno"> 8173</span>    n1 = len(x)</div>
<div class="line"><span class="lineno"> 8174</span>    n2 = len(y)</div>
<div class="line"><span class="lineno"> 8175</span>    alldata = np.concatenate((x, y))</div>
<div class="line"><span class="lineno"> 8176</span>    ranked = rankdata(alldata)</div>
<div class="line"><span class="lineno"> 8177</span>    x = ranked[:n1]</div>
<div class="line"><span class="lineno"> 8178</span>    s = np.sum(x, axis=0)</div>
<div class="line"><span class="lineno"> 8179</span>    expected = n1 * (n1+n2+1) / 2.0</div>
<div class="line"><span class="lineno"> 8180</span>    z = (s - expected) / np.sqrt(n1*n2*(n1+n2+1)/12.0)</div>
<div class="line"><span class="lineno"> 8181</span>    z, prob = _normtest_finish(z, alternative)</div>
<div class="line"><span class="lineno"> 8182</span> </div>
<div class="line"><span class="lineno"> 8183</span>    <span class="keywordflow">return</span> RanksumsResult(z, prob)</div>
<div class="line"><span class="lineno"> 8184</span> </div>
<div class="line"><span class="lineno"> 8185</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad241a1e1cd58da4789b3217d42536d0b" name="ad241a1e1cd58da4789b3217d42536d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad241a1e1cd58da4789b3217d42536d0b">&#9670;&#160;</a></span>relfreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.relfreq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numbins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaultreallimits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a relative frequency histogram, using the histogram function.

A relative frequency  histogram is a mapping of the number of
observations in each of the bins relative to the total of observations.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultreallimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
frequency : ndarray
    Binned values of relative frequency.
lowerlimit : float
    Lower real limit.
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; a = np.array([2, 4, 1, 2, 3, 2])
&gt;&gt;&gt; res = stats.relfreq(a, numbins=4)
&gt;&gt;&gt; res.frequency
array([ 0.16666667, 0.5       , 0.16666667,  0.16666667])
&gt;&gt;&gt; np.sum(res.frequency)  # relative frequencies should add up to 1
1.0

Create a normal distribution with 1000 random values

&gt;&gt;&gt; samples = stats.norm.rvs(size=1000, random_state=rng)

Calculate relative frequencies

&gt;&gt;&gt; res = stats.relfreq(samples, numbins=25)

Calculate space of values for x

&gt;&gt;&gt; x = res.lowerlimit + np.linspace(0, res.binsize*res.frequency.size,
...                                  res.frequency.size)

Plot relative frequency histogram

&gt;&gt;&gt; fig = plt.figure(figsize=(5, 4))
&gt;&gt;&gt; ax = fig.add_subplot(1, 1, 1)
&gt;&gt;&gt; ax.bar(x, res.frequency, width=res.binsize)
&gt;&gt;&gt; ax.set_title('Relative frequency histogram')
&gt;&gt;&gt; ax.set_xlim([x.min(), x.max()])

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2394</span><span class="keyword">def </span>relfreq(a, numbins=10, defaultreallimits=None, weights=None):</div>
<div class="line"><span class="lineno"> 2395</span>    <span class="stringliteral">&quot;&quot;&quot;Return a relative frequency histogram, using the histogram function.</span></div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral">    A relative frequency  histogram is a mapping of the number of</span></div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">    observations in each of the bins relative to the total of observations.</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">    numbins : int, optional</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral">        The number of bins to use for the histogram. Default is 10.</span></div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">    defaultreallimits : tuple (lower, upper), optional</span></div>
<div class="line"><span class="lineno"> 2407</span><span class="stringliteral">        The lower and upper values for the range of the histogram.</span></div>
<div class="line"><span class="lineno"> 2408</span><span class="stringliteral">        If no value is given, a range slightly larger than the range of the</span></div>
<div class="line"><span class="lineno"> 2409</span><span class="stringliteral">        values in a is used. Specifically ``(a.min() - s, a.max() + s)``,</span></div>
<div class="line"><span class="lineno"> 2410</span><span class="stringliteral">        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.</span></div>
<div class="line"><span class="lineno"> 2411</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral">        The weights for each value in `a`. Default is None, which gives each</span></div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral">        value a weight of 1.0</span></div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral">    frequency : ndarray</span></div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral">        Binned values of relative frequency.</span></div>
<div class="line"><span class="lineno"> 2419</span><span class="stringliteral">    lowerlimit : float</span></div>
<div class="line"><span class="lineno"> 2420</span><span class="stringliteral">        Lower real limit.</span></div>
<div class="line"><span class="lineno"> 2421</span><span class="stringliteral">    binsize : float</span></div>
<div class="line"><span class="lineno"> 2422</span><span class="stringliteral">        Width of each bin.</span></div>
<div class="line"><span class="lineno"> 2423</span><span class="stringliteral">    extrapoints : int</span></div>
<div class="line"><span class="lineno"> 2424</span><span class="stringliteral">        Extra points.</span></div>
<div class="line"><span class="lineno"> 2425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2426</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2427</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2428</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2429</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([2, 4, 1, 2, 3, 2])</span></div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.relfreq(a, numbins=4)</span></div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">    &gt;&gt;&gt; res.frequency</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">    array([ 0.16666667, 0.5       , 0.16666667,  0.16666667])</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">    &gt;&gt;&gt; np.sum(res.frequency)  # relative frequencies should add up to 1</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">    Create a normal distribution with 1000 random values</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    &gt;&gt;&gt; samples = stats.norm.rvs(size=1000, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">    Calculate relative frequencies</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.relfreq(samples, numbins=25)</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral">    Calculate space of values for x</span></div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">    &gt;&gt;&gt; x = res.lowerlimit + np.linspace(0, res.binsize*res.frequency.size,</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">    ...                                  res.frequency.size)</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">    Plot relative frequency histogram</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">    &gt;&gt;&gt; fig = plt.figure(figsize=(5, 4))</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">    &gt;&gt;&gt; ax = fig.add_subplot(1, 1, 1)</span></div>
<div class="line"><span class="lineno"> 2456</span><span class="stringliteral">    &gt;&gt;&gt; ax.bar(x, res.frequency, width=res.binsize)</span></div>
<div class="line"><span class="lineno"> 2457</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_title(&#39;Relative frequency histogram&#39;)</span></div>
<div class="line"><span class="lineno"> 2458</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_xlim([x.min(), x.max()])</span></div>
<div class="line"><span class="lineno"> 2459</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2460</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2463</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 2464</span>    h, l, b, e = _histogram(a, numbins, defaultreallimits, weights=weights)</div>
<div class="line"><span class="lineno"> 2465</span>    h = h / a.shape[0]</div>
<div class="line"><span class="lineno"> 2466</span> </div>
<div class="line"><span class="lineno"> 2467</span>    <span class="keywordflow">return</span> RelfreqResult(h, l, b, e)</div>
<div class="line"><span class="lineno"> 2468</span> </div>
<div class="line"><span class="lineno"> 2469</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a50b35c4e412f628c2f7e90a36bdabf25" name="a50b35c4e412f628c2f7e90a36bdabf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b35c4e412f628c2f7e90a36bdabf25">&#9670;&#160;</a></span>scoreatpercentile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.scoreatpercentile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>per</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolation_method</em> = <code>'fraction'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FREQUENCY FUNCTIONS #. </p>
<pre class="fragment">Calculate the score at a given percentile of the input sequence.

For example, the score at `per=50` is the median. If the desired quantile
lies between two data points, we interpolate between them, according to
the value of `interpolation`. If the parameter `limit` is provided, it
should be a tuple (lower, upper) of two values.

Parameters
----------
a : array_like
    A 1-D array of values from which to extract score.
per : array_like
    Percentile(s) at which to extract score.  Values should be in range
    [0,100].
limit : tuple, optional
    Tuple of two scalars, the lower and upper limits within which to
    compute the percentile. Values of `a` outside
    this (closed) interval will be ignored.
interpolation_method : {'fraction', 'lower', 'higher'}, optional
    Specifies the interpolation method to use,
    when the desired quantile lies between two data points `i` and `j`
    The following options are available (default is 'fraction'):

      * 'fraction': ``i + (j - i) * fraction`` where ``fraction`` is the
        fractional part of the index surrounded by ``i`` and ``j``
      * 'lower': ``i``
      * 'higher': ``j``

axis : int, optional
    Axis along which the percentiles are computed. Default is None. If
    None, compute over the whole array `a`.

Returns
-------
score : float or ndarray
    Score at percentile(s).

See Also
--------
percentileofscore, numpy.percentile

Notes
-----
This function will become obsolete in the future.
For NumPy 1.9 and higher, `numpy.percentile` provides all the functionality
that `scoreatpercentile` provides.  And it's significantly faster.
Therefore it's recommended to use `numpy.percentile` for users that have
numpy &gt;= 1.9.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(100)
&gt;&gt;&gt; stats.scoreatpercentile(a, 50)
49.5</pre> <div class="fragment"><div class="line"><span class="lineno"> 1941</span>                      axis=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1942</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the score at a given percentile of the input sequence.</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">    For example, the score at `per=50` is the median. If the desired quantile</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">    lies between two data points, we interpolate between them, according to</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">    the value of `interpolation`. If the parameter `limit` is provided, it</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">    should be a tuple (lower, upper) of two values.</span></div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1950</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1951</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1952</span><span class="stringliteral">        A 1-D array of values from which to extract score.</span></div>
<div class="line"><span class="lineno"> 1953</span><span class="stringliteral">    per : array_like</span></div>
<div class="line"><span class="lineno"> 1954</span><span class="stringliteral">        Percentile(s) at which to extract score.  Values should be in range</span></div>
<div class="line"><span class="lineno"> 1955</span><span class="stringliteral">        [0,100].</span></div>
<div class="line"><span class="lineno"> 1956</span><span class="stringliteral">    limit : tuple, optional</span></div>
<div class="line"><span class="lineno"> 1957</span><span class="stringliteral">        Tuple of two scalars, the lower and upper limits within which to</span></div>
<div class="line"><span class="lineno"> 1958</span><span class="stringliteral">        compute the percentile. Values of `a` outside</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">        this (closed) interval will be ignored.</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral">    interpolation_method : {&#39;fraction&#39;, &#39;lower&#39;, &#39;higher&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">        Specifies the interpolation method to use,</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">        when the desired quantile lies between two data points `i` and `j`</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">        The following options are available (default is &#39;fraction&#39;):</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">          * &#39;fraction&#39;: ``i + (j - i) * fraction`` where ``fraction`` is the</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">            fractional part of the index surrounded by ``i`` and ``j``</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">          * &#39;lower&#39;: ``i``</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">          * &#39;higher&#39;: ``j``</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">        Axis along which the percentiles are computed. Default is None. If</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">        None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">    score : float or ndarray</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">        Score at percentile(s).</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">    percentileofscore, numpy.percentile</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">    This function will become obsolete in the future.</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">    For NumPy 1.9 and higher, `numpy.percentile` provides all the functionality</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral">    that `scoreatpercentile` provides.  And it&#39;s significantly faster.</span></div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    Therefore it&#39;s recommended to use `numpy.percentile` for users that have</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral">    numpy &gt;= 1.9.</span></div>
<div class="line"><span class="lineno"> 1990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1993</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(100)</span></div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral">    &gt;&gt;&gt; stats.scoreatpercentile(a, 50)</span></div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">    49.5</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1999</span>    <span class="comment"># adapted from NumPy&#39;s percentile function.  When we require numpy &gt;= 1.8,</span></div>
<div class="line"><span class="lineno"> 2000</span>    <span class="comment"># the implementation of this function can be replaced by np.percentile.</span></div>
<div class="line"><span class="lineno"> 2001</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 2002</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 2003</span>        <span class="comment"># empty array, return nan(s) with shape matching `per`</span></div>
<div class="line"><span class="lineno"> 2004</span>        <span class="keywordflow">if</span> np.isscalar(per):</div>
<div class="line"><span class="lineno"> 2005</span>            <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 2006</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2007</span>            <span class="keywordflow">return</span> np.full(np.asarray(per).shape, np.nan, dtype=np.float64)</div>
<div class="line"><span class="lineno"> 2008</span> </div>
<div class="line"><span class="lineno"> 2009</span>    <span class="keywordflow">if</span> limit:</div>
<div class="line"><span class="lineno"> 2010</span>        a = a[(limit[0] &lt;= a) &amp; (a &lt;= limit[1])]</div>
<div class="line"><span class="lineno"> 2011</span> </div>
<div class="line"><span class="lineno"> 2012</span>    sorted_ = np.sort(a, axis=axis)</div>
<div class="line"><span class="lineno"> 2013</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2014</span>        axis = 0</div>
<div class="line"><span class="lineno"> 2015</span> </div>
<div class="line"><span class="lineno"> 2016</span>    <span class="keywordflow">return</span> _compute_qth_percentile(sorted_, per, interpolation_method, axis)</div>
<div class="line"><span class="lineno"> 2017</span> </div>
<div class="line"><span class="lineno"> 2018</span> </div>
<div class="line"><span class="lineno"> 2019</span><span class="comment"># handle sequence of per&#39;s without calling sort multiple times</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac92d7d58643573008b4ddc6dfad7447a" name="ac92d7d58643573008b4ddc6dfad7447a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92d7d58643573008b4ddc6dfad7447a">&#9670;&#160;</a></span>sem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.sem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute standard error of the mean.

Calculate the standard error of the mean (or standard error of
measurement) of the values in the input array.

Parameters
----------
a : array_like
    An array containing the values for which the standard error is
    returned.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Delta degrees-of-freedom. How many degrees of freedom to adjust
    for bias in limited samples relative to the population estimate
    of variance. Defaults to 1.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
s : ndarray or float
    The standard error of the mean in the sample(s), along the input axis.

Notes
-----
The default value for `ddof` is different to the default (0) used by other
ddof containing routines, such as np.std and np.nanstd.

Examples
--------
Find standard error along the first axis:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(20).reshape(5,4)
&gt;&gt;&gt; stats.sem(a)
array([ 2.8284,  2.8284,  2.8284,  2.8284])

Find standard error across the whole array, using n degrees of freedom:

&gt;&gt;&gt; stats.sem(a, axis=None, ddof=0)
1.2893796958227628</pre> <div class="fragment"><div class="line"><span class="lineno"> 2557</span><span class="keyword">def </span>sem(a, axis=0, ddof=1, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 2558</span>    <span class="stringliteral">&quot;&quot;&quot;Compute standard error of the mean.</span></div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral">    Calculate the standard error of the mean (or standard error of</span></div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral">    measurement) of the values in the input array.</span></div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">        An array containing the values for which the standard error is</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">        returned.</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral">        Delta degrees-of-freedom. How many degrees of freedom to adjust</span></div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">        for bias in limited samples relative to the population estimate</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral">        of variance. Defaults to 1.</span></div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 2577</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 2578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2579</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 2580</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 2581</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 2582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2583</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2584</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral">    s : ndarray or float</span></div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral">        The standard error of the mean in the sample(s), along the input axis.</span></div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">    The default value for `ddof` is different to the default (0) used by other</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral">    ddof containing routines, such as np.std and np.nanstd.</span></div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2593</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2594</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2595</span><span class="stringliteral">    Find standard error along the first axis:</span></div>
<div class="line"><span class="lineno"> 2596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2597</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 2598</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(20).reshape(5,4)</span></div>
<div class="line"><span class="lineno"> 2599</span><span class="stringliteral">    &gt;&gt;&gt; stats.sem(a)</span></div>
<div class="line"><span class="lineno"> 2600</span><span class="stringliteral">    array([ 2.8284,  2.8284,  2.8284,  2.8284])</span></div>
<div class="line"><span class="lineno"> 2601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2602</span><span class="stringliteral">    Find standard error across the whole array, using n degrees of freedom:</span></div>
<div class="line"><span class="lineno"> 2603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2604</span><span class="stringliteral">    &gt;&gt;&gt; stats.sem(a, axis=None, ddof=0)</span></div>
<div class="line"><span class="lineno"> 2605</span><span class="stringliteral">    1.2893796958227628</span></div>
<div class="line"><span class="lineno"> 2606</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2607</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2608</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 2609</span> </div>
<div class="line"><span class="lineno"> 2610</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 2611</span> </div>
<div class="line"><span class="lineno"> 2612</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 2613</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 2614</span>        <span class="keywordflow">return</span> mstats_basic.sem(a, axis, ddof)</div>
<div class="line"><span class="lineno"> 2615</span> </div>
<div class="line"><span class="lineno"> 2616</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 2617</span>    s = np.std(a, axis=axis, ddof=ddof) / np.sqrt(n)</div>
<div class="line"><span class="lineno"> 2618</span>    <span class="keywordflow">return</span> s</div>
<div class="line"><span class="lineno"> 2619</span> </div>
<div class="line"><span class="lineno"> 2620</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40c059cb94ceb8ed4b4573bca8b8024f" name="a40c059cb94ceb8ed4b4573bca8b8024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c059cb94ceb8ed4b4573bca8b8024f">&#9670;&#160;</a></span>sigmaclip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.sigmaclip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>low</em> = <code>4.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>high</em> = <code>4.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform iterative sigma-clipping of array elements.

Starting from the full sample, all elements outside the critical range are
removed, i.e. all elements of the input array `c` that satisfy either of
the following conditions::

    c &lt; mean(c) - std(c)*low
    c &gt; mean(c) + std(c)*high

The iteration continues with the updated sample until no
elements are outside the (updated) range.

Parameters
----------
a : array_like
    Data array, will be raveled if not 1-D.
low : float, optional
    Lower bound factor of sigma clipping. Default is 4.
high : float, optional
    Upper bound factor of sigma clipping. Default is 4.

Returns
-------
clipped : ndarray
    Input array with clipped elements removed.
lower : float
    Lower threshold value use for clipping.
upper : float
    Upper threshold value use for clipping.

Examples
--------
&gt;&gt;&gt; from scipy.stats import sigmaclip
&gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 31),
...                     np.linspace(0, 20, 5)))
&gt;&gt;&gt; fact = 1.5
&gt;&gt;&gt; c, low, upp = sigmaclip(a, fact, fact)
&gt;&gt;&gt; c
array([  9.96666667,  10.        ,  10.03333333,  10.        ])
&gt;&gt;&gt; c.var(), c.std()
(0.00055555555555555165, 0.023570226039551501)
&gt;&gt;&gt; low, c.mean() - fact*c.std(), c.min()
(9.9646446609406727, 9.9646446609406727, 9.9666666666666668)
&gt;&gt;&gt; upp, c.mean() + fact*c.std(), c.max()
(10.035355339059327, 10.035355339059327, 10.033333333333333)

&gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 11),
...                     np.linspace(-100, -50, 3)))
&gt;&gt;&gt; c, low, upp = sigmaclip(a, 1.8, 1.8)
&gt;&gt;&gt; (c == np.linspace(9.5, 10.5, 11)).all()
True</pre> <div class="fragment"><div class="line"><span class="lineno"> 3392</span><span class="keyword">def </span>sigmaclip(a, low=4., high=4.):</div>
<div class="line"><span class="lineno"> 3393</span>    <span class="stringliteral">&quot;&quot;&quot;Perform iterative sigma-clipping of array elements.</span></div>
<div class="line"><span class="lineno"> 3394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3395</span><span class="stringliteral">    Starting from the full sample, all elements outside the critical range are</span></div>
<div class="line"><span class="lineno"> 3396</span><span class="stringliteral">    removed, i.e. all elements of the input array `c` that satisfy either of</span></div>
<div class="line"><span class="lineno"> 3397</span><span class="stringliteral">    the following conditions::</span></div>
<div class="line"><span class="lineno"> 3398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3399</span><span class="stringliteral">        c &lt; mean(c) - std(c)*low</span></div>
<div class="line"><span class="lineno"> 3400</span><span class="stringliteral">        c &gt; mean(c) + std(c)*high</span></div>
<div class="line"><span class="lineno"> 3401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3402</span><span class="stringliteral">    The iteration continues with the updated sample until no</span></div>
<div class="line"><span class="lineno"> 3403</span><span class="stringliteral">    elements are outside the (updated) range.</span></div>
<div class="line"><span class="lineno"> 3404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3405</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3406</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3407</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3408</span><span class="stringliteral">        Data array, will be raveled if not 1-D.</span></div>
<div class="line"><span class="lineno"> 3409</span><span class="stringliteral">    low : float, optional</span></div>
<div class="line"><span class="lineno"> 3410</span><span class="stringliteral">        Lower bound factor of sigma clipping. Default is 4.</span></div>
<div class="line"><span class="lineno"> 3411</span><span class="stringliteral">    high : float, optional</span></div>
<div class="line"><span class="lineno"> 3412</span><span class="stringliteral">        Upper bound factor of sigma clipping. Default is 4.</span></div>
<div class="line"><span class="lineno"> 3413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3414</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3415</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3416</span><span class="stringliteral">    clipped : ndarray</span></div>
<div class="line"><span class="lineno"> 3417</span><span class="stringliteral">        Input array with clipped elements removed.</span></div>
<div class="line"><span class="lineno"> 3418</span><span class="stringliteral">    lower : float</span></div>
<div class="line"><span class="lineno"> 3419</span><span class="stringliteral">        Lower threshold value use for clipping.</span></div>
<div class="line"><span class="lineno"> 3420</span><span class="stringliteral">    upper : float</span></div>
<div class="line"><span class="lineno"> 3421</span><span class="stringliteral">        Upper threshold value use for clipping.</span></div>
<div class="line"><span class="lineno"> 3422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3423</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3424</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3425</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import sigmaclip</span></div>
<div class="line"><span class="lineno"> 3426</span><span class="stringliteral">    &gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 31),</span></div>
<div class="line"><span class="lineno"> 3427</span><span class="stringliteral">    ...                     np.linspace(0, 20, 5)))</span></div>
<div class="line"><span class="lineno"> 3428</span><span class="stringliteral">    &gt;&gt;&gt; fact = 1.5</span></div>
<div class="line"><span class="lineno"> 3429</span><span class="stringliteral">    &gt;&gt;&gt; c, low, upp = sigmaclip(a, fact, fact)</span></div>
<div class="line"><span class="lineno"> 3430</span><span class="stringliteral">    &gt;&gt;&gt; c</span></div>
<div class="line"><span class="lineno"> 3431</span><span class="stringliteral">    array([  9.96666667,  10.        ,  10.03333333,  10.        ])</span></div>
<div class="line"><span class="lineno"> 3432</span><span class="stringliteral">    &gt;&gt;&gt; c.var(), c.std()</span></div>
<div class="line"><span class="lineno"> 3433</span><span class="stringliteral">    (0.00055555555555555165, 0.023570226039551501)</span></div>
<div class="line"><span class="lineno"> 3434</span><span class="stringliteral">    &gt;&gt;&gt; low, c.mean() - fact*c.std(), c.min()</span></div>
<div class="line"><span class="lineno"> 3435</span><span class="stringliteral">    (9.9646446609406727, 9.9646446609406727, 9.9666666666666668)</span></div>
<div class="line"><span class="lineno"> 3436</span><span class="stringliteral">    &gt;&gt;&gt; upp, c.mean() + fact*c.std(), c.max()</span></div>
<div class="line"><span class="lineno"> 3437</span><span class="stringliteral">    (10.035355339059327, 10.035355339059327, 10.033333333333333)</span></div>
<div class="line"><span class="lineno"> 3438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3439</span><span class="stringliteral">    &gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 11),</span></div>
<div class="line"><span class="lineno"> 3440</span><span class="stringliteral">    ...                     np.linspace(-100, -50, 3)))</span></div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral">    &gt;&gt;&gt; c, low, upp = sigmaclip(a, 1.8, 1.8)</span></div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral">    &gt;&gt;&gt; (c == np.linspace(9.5, 10.5, 11)).all()</span></div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3446</span>    c = np.asarray(a).ravel()</div>
<div class="line"><span class="lineno"> 3447</span>    delta = 1</div>
<div class="line"><span class="lineno"> 3448</span>    <span class="keywordflow">while</span> delta:</div>
<div class="line"><span class="lineno"> 3449</span>        c_std = c.std()</div>
<div class="line"><span class="lineno"> 3450</span>        c_mean = c.mean()</div>
<div class="line"><span class="lineno"> 3451</span>        size = c.size</div>
<div class="line"><span class="lineno"> 3452</span>        critlower = c_mean - c_std * low</div>
<div class="line"><span class="lineno"> 3453</span>        critupper = c_mean + c_std * high</div>
<div class="line"><span class="lineno"> 3454</span>        c = c[(c &gt;= critlower) &amp; (c &lt;= critupper)]</div>
<div class="line"><span class="lineno"> 3455</span>        delta = size - c.size</div>
<div class="line"><span class="lineno"> 3456</span> </div>
<div class="line"><span class="lineno"> 3457</span>    <span class="keywordflow">return</span> SigmaclipResult(c, critlower, critupper)</div>
<div class="line"><span class="lineno"> 3458</span> </div>
<div class="line"><span class="lineno"> 3459</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a57e56bc1f28e285175aa52cd9a8dccec" name="a57e56bc1f28e285175aa52cd9a8dccec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e56bc1f28e285175aa52cd9a8dccec">&#9670;&#160;</a></span>skew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.skew </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bias</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the sample skewness of a data set.

For normally distributed data, the skewness should be about zero. For
unimodal continuous distributions, a skewness value greater than zero means
that there is more weight in the right tail of the distribution. The
function `skewtest` can be used to determine if the skewness value
is close enough to zero, statistically speaking.

Parameters
----------
a : ndarray
    Input array.
axis : int or None, optional
    Axis along which skewness is calculated. Default is 0.
    If None, compute over the whole array `a`.
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
skewness : ndarray
    The skewness of values along an axis, returning NaN where all values
    are equal.

Notes
-----
The sample skewness is computed as the Fisher-Pearson coefficient
of skewness, i.e.

.. math::

    g_1=\frac{m_3}{m_2^{3/2}}

where

.. math::

    m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i

is the biased sample :math:`i\texttt{th}` central moment, and
:math:`\bar{x}` is
the sample mean.  If ``bias`` is False, the calculations are
corrected for bias and the value computed is the adjusted
Fisher-Pearson standardized moment coefficient, i.e.

.. math::

    G_1=\frac{k_3}{k_2^{3/2}}=
        \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.
   Section 2.2.24.1

Examples
--------
&gt;&gt;&gt; from scipy.stats import skew
&gt;&gt;&gt; skew([1, 2, 3, 4, 5])
0.0
&gt;&gt;&gt; skew([2, 8, 0, 4, 1, 9, 9, 0])
0.2650554122698573</pre> <div class="fragment"><div class="line"><span class="lineno"> 1260</span><span class="keyword">def </span>skew(a, axis=0, bias=True, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 1261</span>    <span class="stringliteral">r&quot;&quot;&quot;Compute the sample skewness of a data set.</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    For normally distributed data, the skewness should be about zero. For</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    unimodal continuous distributions, a skewness value greater than zero means</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">    that there is more weight in the right tail of the distribution. The</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">    function `skewtest` can be used to determine if the skewness value</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">    is close enough to zero, statistically speaking.</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    a : ndarray</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">        Axis along which skewness is calculated. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">        If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">    bias : bool, optional</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">        If False, then the calculations are corrected for statistical bias.</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    skewness : ndarray</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">        The skewness of values along an axis, returning NaN where all values</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">        are equal.</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    The sample skewness is computed as the Fisher-Pearson coefficient</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    of skewness, i.e.</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">        g_1=\frac{m_3}{m_2^{3/2}}</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    where</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">        m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    is the biased sample :math:`i\texttt{th}` central moment, and</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">    :math:`\bar{x}` is</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">    the sample mean.  If ``bias`` is False, the calculations are</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    corrected for bias and the value computed is the adjusted</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    Fisher-Pearson standardized moment coefficient, i.e.</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">        G_1=\frac{k_3}{k_2^{3/2}}=</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">            \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">       Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">       York. 2000.</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">       Section 2.2.24.1</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import skew</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    &gt;&gt;&gt; skew([1, 2, 3, 4, 5])</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">    0.0</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    &gt;&gt;&gt; skew([2, 8, 0, 4, 1, 9, 9, 0])</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    0.2650554122698573</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1334</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 1335</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 1336</span> </div>
<div class="line"><span class="lineno"> 1337</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 1338</span> </div>
<div class="line"><span class="lineno"> 1339</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 1340</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 1341</span>        <span class="keywordflow">return</span> mstats_basic.skew(a, axis, bias)</div>
<div class="line"><span class="lineno"> 1342</span> </div>
<div class="line"><span class="lineno"> 1343</span>    mean = a.mean(axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1344</span>    m2 = _moment(a, 2, axis, mean=mean)</div>
<div class="line"><span class="lineno"> 1345</span>    m3 = _moment(a, 3, axis, mean=mean)</div>
<div class="line"><span class="lineno"> 1346</span>    <span class="keyword">with</span> np.errstate(all=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 1347</span>        zero = (m2 &lt;= (np.finfo(m2.dtype).resolution * mean.squeeze(axis))**2)</div>
<div class="line"><span class="lineno"> 1348</span>        vals = np.where(zero, np.nan, m3 / m2**1.5)</div>
<div class="line"><span class="lineno"> 1349</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> bias:</div>
<div class="line"><span class="lineno"> 1350</span>        can_correct = ~zero &amp; (n &gt; 2)</div>
<div class="line"><span class="lineno"> 1351</span>        <span class="keywordflow">if</span> can_correct.any():</div>
<div class="line"><span class="lineno"> 1352</span>            m2 = np.extract(can_correct, m2)</div>
<div class="line"><span class="lineno"> 1353</span>            m3 = np.extract(can_correct, m3)</div>
<div class="line"><span class="lineno"> 1354</span>            nval = np.sqrt((n - 1.0) * n) / (n - 2.0) * m3 / m2**1.5</div>
<div class="line"><span class="lineno"> 1355</span>            np.place(vals, can_correct, nval)</div>
<div class="line"><span class="lineno"> 1356</span> </div>
<div class="line"><span class="lineno"> 1357</span>    <span class="keywordflow">if</span> vals.ndim == 0:</div>
<div class="line"><span class="lineno"> 1358</span>        <span class="keywordflow">return</span> vals.item()</div>
<div class="line"><span class="lineno"> 1359</span> </div>
<div class="line"><span class="lineno"> 1360</span>    <span class="keywordflow">return</span> vals</div>
<div class="line"><span class="lineno"> 1361</span> </div>
<div class="line"><span class="lineno"> 1362</span> </div>
<div class="line"><span class="lineno"> 1363</span><span class="preprocessor">@_axis_nan_policy_factory</span>(</div>
<div class="line"><span class="lineno"> 1364</span>    <span class="keyword">lambda</span> x: x, result_to_tuple=<span class="keyword">lambda</span> x: (x,), n_outputs=1</div>
<div class="line"><span class="lineno"> 1365</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ba4fbe391d511f26a5715213741ce19" name="a7ba4fbe391d511f26a5715213741ce19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba4fbe391d511f26a5715213741ce19">&#9670;&#160;</a></span>skewtest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.skewtest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Test whether the skew is different from the normal distribution.

This function tests the null hypothesis that the skewness of
the population that the sample was drawn from is the same
as that of a corresponding normal distribution.

Parameters
----------
a : array
    The data to be tested.
axis : int or None, optional
   Axis along which statistics are calculated. Default is 0.
   If None, compute over the whole array `a`.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the skewness of the distribution underlying the sample
      is different from that of the normal distribution (i.e. 0)
    * 'less': the skewness of the distribution underlying the sample
      is less than that of the normal distribution
    * 'greater': the skewness of the distribution underlying the sample
      is greater than that of the normal distribution

    .. versionadded:: 1.7.0

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    The p-value for the hypothesis test.

Notes
-----
The sample size must be at least 8.

References
----------
.. [1] R. B. D'Agostino, A. J. Belanger and R. B. D'Agostino Jr.,
        "A suggestion for using powerful and informative tests of
        normality", American Statistician 44, pp. 316-321, 1990.

Examples
--------
&gt;&gt;&gt; from scipy.stats import skewtest
&gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8])
SkewtestResult(statistic=1.0108048609177787, pvalue=0.3121098361421897)
&gt;&gt;&gt; skewtest([2, 8, 0, 4, 1, 9, 9, 0])
SkewtestResult(statistic=0.44626385374196975, pvalue=0.6554066631275459)
&gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8000])
SkewtestResult(statistic=3.571773510360407, pvalue=0.0003545719905823133)
&gt;&gt;&gt; skewtest([100, 100, 100, 100, 100, 100, 100, 101])
SkewtestResult(statistic=3.5717766638478072, pvalue=0.000354567720281634)
&gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8], alternative='less')
SkewtestResult(statistic=1.0108048609177787, pvalue=0.8439450819289052)
&gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8], alternative='greater')
SkewtestResult(statistic=1.0108048609177787, pvalue=0.15605491807109484)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1590</span><span class="keyword">def </span>skewtest(a, axis=0, nan_policy=&#39;propagate&#39;, alternative=&#39;two-sided&#39;):</div>
<div class="line"><span class="lineno"> 1591</span>    <span class="stringliteral">&quot;&quot;&quot;Test whether the skew is different from the normal distribution.</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">    This function tests the null hypothesis that the skewness of</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">    the population that the sample was drawn from is the same</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral">    as that of a corresponding normal distribution.</span></div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">    a : array</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        The data to be tested.</span></div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral">       Axis along which statistics are calculated. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">       If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">        * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">        * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">        * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">        The following options are available:</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        * &#39;two-sided&#39;: the skewness of the distribution underlying the sample</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">          is different from that of the normal distribution (i.e. 0)</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">        * &#39;less&#39;: the skewness of the distribution underlying the sample</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">          is less than that of the normal distribution</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">        * &#39;greater&#39;: the skewness of the distribution underlying the sample</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">          is greater than that of the normal distribution</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    statistic : float</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">        The computed z-score for this test.</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">        The p-value for the hypothesis test.</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    The sample size must be at least 8.</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">    .. [1] R. B. D&#39;Agostino, A. J. Belanger and R. B. D&#39;Agostino Jr.,</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">            &quot;A suggestion for using powerful and informative tests of</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">            normality&quot;, American Statistician 44, pp. 316-321, 1990.</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import skewtest</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">    &gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8])</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">    SkewtestResult(statistic=1.0108048609177787, pvalue=0.3121098361421897)</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">    &gt;&gt;&gt; skewtest([2, 8, 0, 4, 1, 9, 9, 0])</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">    SkewtestResult(statistic=0.44626385374196975, pvalue=0.6554066631275459)</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">    &gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8000])</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">    SkewtestResult(statistic=3.571773510360407, pvalue=0.0003545719905823133)</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral">    &gt;&gt;&gt; skewtest([100, 100, 100, 100, 100, 100, 100, 101])</span></div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral">    SkewtestResult(statistic=3.5717766638478072, pvalue=0.000354567720281634)</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">    &gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8], alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral">    SkewtestResult(statistic=1.0108048609177787, pvalue=0.8439450819289052)</span></div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">    &gt;&gt;&gt; skewtest([1, 2, 3, 4, 5, 6, 7, 8], alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 1656</span><span class="stringliteral">    SkewtestResult(statistic=1.0108048609177787, pvalue=0.15605491807109484)</span></div>
<div class="line"><span class="lineno"> 1657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1658</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1659</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 1660</span> </div>
<div class="line"><span class="lineno"> 1661</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 1662</span> </div>
<div class="line"><span class="lineno"> 1663</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 1664</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 1665</span>        <span class="keywordflow">return</span> mstats_basic.skewtest(a, axis, alternative)</div>
<div class="line"><span class="lineno"> 1666</span> </div>
<div class="line"><span class="lineno"> 1667</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1668</span>        a = np.ravel(a)</div>
<div class="line"><span class="lineno"> 1669</span>        axis = 0</div>
<div class="line"><span class="lineno"> 1670</span>    b2 = skew(a, axis)</div>
<div class="line"><span class="lineno"> 1671</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 1672</span>    <span class="keywordflow">if</span> n &lt; 8:</div>
<div class="line"><span class="lineno"> 1673</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1674</span>            <span class="stringliteral">&quot;skewtest is not valid with less than 8 samples; %i samples&quot;</span></div>
<div class="line"><span class="lineno"> 1675</span>            <span class="stringliteral">&quot; were given.&quot;</span> % int(n))</div>
<div class="line"><span class="lineno"> 1676</span>    y = b2 * math.sqrt(((n + 1) * (n + 3)) / (6.0 * (n - 2)))</div>
<div class="line"><span class="lineno"> 1677</span>    beta2 = (3.0 * (n**2 + 27*n - 70) * (n+1) * (n+3) /</div>
<div class="line"><span class="lineno"> 1678</span>             ((n-2.0) * (n+5) * (n+7) * (n+9)))</div>
<div class="line"><span class="lineno"> 1679</span>    W2 = -1 + math.sqrt(2 * (beta2 - 1))</div>
<div class="line"><span class="lineno"> 1680</span>    delta = 1 / math.sqrt(0.5 * math.log(W2))</div>
<div class="line"><span class="lineno"> 1681</span>    alpha = math.sqrt(2.0 / (W2 - 1))</div>
<div class="line"><span class="lineno"> 1682</span>    y = np.where(y == 0, 1, y)</div>
<div class="line"><span class="lineno"> 1683</span>    Z = delta * np.log(y / alpha + np.sqrt((y / alpha)**2 + 1))</div>
<div class="line"><span class="lineno"> 1684</span> </div>
<div class="line"><span class="lineno"> 1685</span>    <span class="keywordflow">return</span> SkewtestResult(*_normtest_finish(Z, alternative))</div>
<div class="line"><span class="lineno"> 1686</span> </div>
<div class="line"><span class="lineno"> 1687</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a38625835ee2b2814b8dd9ce450b73bde" name="a38625835ee2b2814b8dd9ce450b73bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38625835ee2b2814b8dd9ce450b73bde">&#9670;&#160;</a></span>spearmanr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.spearmanr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>'two-sided'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate a Spearman correlation coefficient with associated p-value.

The Spearman rank-order correlation coefficient is a nonparametric measure
of the monotonicity of the relationship between two datasets. Unlike the
Pearson correlation, the Spearman correlation does not assume that both
datasets are normally distributed. Like other correlation coefficients,
this one varies between -1 and +1 with 0 implying no correlation.
Correlations of -1 or +1 imply an exact monotonic relationship. Positive
correlations imply that as x increases, so does y. Negative correlations
imply that as x increases, y decreases.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Spearman correlation at least as extreme
as the one computed from these datasets. The p-values are not entirely
reliable but are probably reasonable for datasets larger than 500 or so.

Parameters
----------
a, b : 1D or 2D array_like, b is optional
    One or two 1-D or 2-D arrays containing multiple variables and
    observations. When these are 1-D, each represents a vector of
    observations of a single variable. For the behavior in the 2-D case,
    see under ``axis``, below.
    Both arrays need to have the same length in the ``axis`` dimension.
axis : int or None, optional
    If axis=0 (default), then each column represents a variable, with
    observations in the rows. If axis=1, the relationship is transposed:
    each row represents a variable, while the columns contain observations.
    If axis=None, then both arrays will be raveled.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

    * 'propagate': returns nan
    * 'raise': throws an error
    * 'omit': performs the calculations ignoring nan values

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the correlation is nonzero
    * 'less': the correlation is negative (less than zero)
    * 'greater':  the correlation is positive (greater than zero)

    .. versionadded:: 1.7.0

Returns
-------
correlation : float or ndarray (2-D square)
    Spearman correlation matrix or correlation coefficient (if only 2
    variables are given as parameters. Correlation matrix is square with
    length equal to total number of variables (columns or rows) in ``a``
    and ``b`` combined.
pvalue : float
    The p-value for a hypothesis test whose null hypotheisis
    is that two sets of data are uncorrelated. See `alternative` above
    for alternative hypotheses. `pvalue` has the same
    shape as `correlation`.

Warns
-----
`~scipy.stats.ConstantInputWarning`
    Raised if an input is a constant array.  The correlation coefficient
    is not defined in this case, so ``np.nan`` is returned.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.
   Section  14.7

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.spearmanr([1,2,3,4,5], [5,6,7,8,7])
SpearmanrResult(correlation=0.82078..., pvalue=0.08858...)
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x2n = rng.standard_normal((100, 2))
&gt;&gt;&gt; y2n = rng.standard_normal((100, 2))
&gt;&gt;&gt; stats.spearmanr(x2n)
SpearmanrResult(correlation=-0.07960396039603959, pvalue=0.4311168705769747)
&gt;&gt;&gt; stats.spearmanr(x2n[:,0], x2n[:,1])
SpearmanrResult(correlation=-0.07960396039603959, pvalue=0.4311168705769747)
&gt;&gt;&gt; rho, pval = stats.spearmanr(x2n, y2n)
&gt;&gt;&gt; rho
array([[ 1.        , -0.07960396, -0.08314431,  0.09662166],
       [-0.07960396,  1.        , -0.14448245,  0.16738074],
       [-0.08314431, -0.14448245,  1.        ,  0.03234323],
       [ 0.09662166,  0.16738074,  0.03234323,  1.        ]])
&gt;&gt;&gt; pval
array([[0.        , 0.43111687, 0.41084066, 0.33891628],
       [0.43111687, 0.        , 0.15151618, 0.09600687],
       [0.41084066, 0.15151618, 0.        , 0.74938561],
       [0.33891628, 0.09600687, 0.74938561, 0.        ]])
&gt;&gt;&gt; rho, pval = stats.spearmanr(x2n.T, y2n.T, axis=1)
&gt;&gt;&gt; rho
array([[ 1.        , -0.07960396, -0.08314431,  0.09662166],
       [-0.07960396,  1.        , -0.14448245,  0.16738074],
       [-0.08314431, -0.14448245,  1.        ,  0.03234323],
       [ 0.09662166,  0.16738074,  0.03234323,  1.        ]])
&gt;&gt;&gt; stats.spearmanr(x2n, y2n, axis=None)
SpearmanrResult(correlation=0.044981624540613524, pvalue=0.5270803651336189)
&gt;&gt;&gt; stats.spearmanr(x2n.ravel(), y2n.ravel())
SpearmanrResult(correlation=0.044981624540613524, pvalue=0.5270803651336189)

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; xint = rng.integers(10, size=(100, 2))
&gt;&gt;&gt; stats.spearmanr(xint)
SpearmanrResult(correlation=0.09800224850707953, pvalue=0.3320271757932076)</pre> <div class="fragment"><div class="line"><span class="lineno"> 4733</span>              alternative=<span class="stringliteral">&#39;two-sided&#39;</span>):</div>
<div class="line"><span class="lineno"> 4734</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate a Spearman correlation coefficient with associated p-value.</span></div>
<div class="line"><span class="lineno"> 4735</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4736</span><span class="stringliteral">    The Spearman rank-order correlation coefficient is a nonparametric measure</span></div>
<div class="line"><span class="lineno"> 4737</span><span class="stringliteral">    of the monotonicity of the relationship between two datasets. Unlike the</span></div>
<div class="line"><span class="lineno"> 4738</span><span class="stringliteral">    Pearson correlation, the Spearman correlation does not assume that both</span></div>
<div class="line"><span class="lineno"> 4739</span><span class="stringliteral">    datasets are normally distributed. Like other correlation coefficients,</span></div>
<div class="line"><span class="lineno"> 4740</span><span class="stringliteral">    this one varies between -1 and +1 with 0 implying no correlation.</span></div>
<div class="line"><span class="lineno"> 4741</span><span class="stringliteral">    Correlations of -1 or +1 imply an exact monotonic relationship. Positive</span></div>
<div class="line"><span class="lineno"> 4742</span><span class="stringliteral">    correlations imply that as x increases, so does y. Negative correlations</span></div>
<div class="line"><span class="lineno"> 4743</span><span class="stringliteral">    imply that as x increases, y decreases.</span></div>
<div class="line"><span class="lineno"> 4744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4745</span><span class="stringliteral">    The p-value roughly indicates the probability of an uncorrelated system</span></div>
<div class="line"><span class="lineno"> 4746</span><span class="stringliteral">    producing datasets that have a Spearman correlation at least as extreme</span></div>
<div class="line"><span class="lineno"> 4747</span><span class="stringliteral">    as the one computed from these datasets. The p-values are not entirely</span></div>
<div class="line"><span class="lineno"> 4748</span><span class="stringliteral">    reliable but are probably reasonable for datasets larger than 500 or so.</span></div>
<div class="line"><span class="lineno"> 4749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4750</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4751</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4752</span><span class="stringliteral">    a, b : 1D or 2D array_like, b is optional</span></div>
<div class="line"><span class="lineno"> 4753</span><span class="stringliteral">        One or two 1-D or 2-D arrays containing multiple variables and</span></div>
<div class="line"><span class="lineno"> 4754</span><span class="stringliteral">        observations. When these are 1-D, each represents a vector of</span></div>
<div class="line"><span class="lineno"> 4755</span><span class="stringliteral">        observations of a single variable. For the behavior in the 2-D case,</span></div>
<div class="line"><span class="lineno"> 4756</span><span class="stringliteral">        see under ``axis``, below.</span></div>
<div class="line"><span class="lineno"> 4757</span><span class="stringliteral">        Both arrays need to have the same length in the ``axis`` dimension.</span></div>
<div class="line"><span class="lineno"> 4758</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 4759</span><span class="stringliteral">        If axis=0 (default), then each column represents a variable, with</span></div>
<div class="line"><span class="lineno"> 4760</span><span class="stringliteral">        observations in the rows. If axis=1, the relationship is transposed:</span></div>
<div class="line"><span class="lineno"> 4761</span><span class="stringliteral">        each row represents a variable, while the columns contain observations.</span></div>
<div class="line"><span class="lineno"> 4762</span><span class="stringliteral">        If axis=None, then both arrays will be raveled.</span></div>
<div class="line"><span class="lineno"> 4763</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 4764</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 4765</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 4766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4767</span><span class="stringliteral">        * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 4768</span><span class="stringliteral">        * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 4769</span><span class="stringliteral">        * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 4770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4771</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 4772</span><span class="stringliteral">        Defines the alternative hypothesis. Default is &#39;two-sided&#39;.</span></div>
<div class="line"><span class="lineno"> 4773</span><span class="stringliteral">        The following options are available:</span></div>
<div class="line"><span class="lineno"> 4774</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4775</span><span class="stringliteral">        * &#39;two-sided&#39;: the correlation is nonzero</span></div>
<div class="line"><span class="lineno"> 4776</span><span class="stringliteral">        * &#39;less&#39;: the correlation is negative (less than zero)</span></div>
<div class="line"><span class="lineno"> 4777</span><span class="stringliteral">        * &#39;greater&#39;:  the correlation is positive (greater than zero)</span></div>
<div class="line"><span class="lineno"> 4778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4779</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 4780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4781</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4782</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4783</span><span class="stringliteral">    correlation : float or ndarray (2-D square)</span></div>
<div class="line"><span class="lineno"> 4784</span><span class="stringliteral">        Spearman correlation matrix or correlation coefficient (if only 2</span></div>
<div class="line"><span class="lineno"> 4785</span><span class="stringliteral">        variables are given as parameters. Correlation matrix is square with</span></div>
<div class="line"><span class="lineno"> 4786</span><span class="stringliteral">        length equal to total number of variables (columns or rows) in ``a``</span></div>
<div class="line"><span class="lineno"> 4787</span><span class="stringliteral">        and ``b`` combined.</span></div>
<div class="line"><span class="lineno"> 4788</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 4789</span><span class="stringliteral">        The p-value for a hypothesis test whose null hypotheisis</span></div>
<div class="line"><span class="lineno"> 4790</span><span class="stringliteral">        is that two sets of data are uncorrelated. See `alternative` above</span></div>
<div class="line"><span class="lineno"> 4791</span><span class="stringliteral">        for alternative hypotheses. `pvalue` has the same</span></div>
<div class="line"><span class="lineno"> 4792</span><span class="stringliteral">        shape as `correlation`.</span></div>
<div class="line"><span class="lineno"> 4793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4794</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno"> 4795</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4796</span><span class="stringliteral">    `~scipy.stats.ConstantInputWarning`</span></div>
<div class="line"><span class="lineno"> 4797</span><span class="stringliteral">        Raised if an input is a constant array.  The correlation coefficient</span></div>
<div class="line"><span class="lineno"> 4798</span><span class="stringliteral">        is not defined in this case, so ``np.nan`` is returned.</span></div>
<div class="line"><span class="lineno"> 4799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4800</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 4801</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4802</span><span class="stringliteral">    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard</span></div>
<div class="line"><span class="lineno"> 4803</span><span class="stringliteral">       Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New</span></div>
<div class="line"><span class="lineno"> 4804</span><span class="stringliteral">       York. 2000.</span></div>
<div class="line"><span class="lineno"> 4805</span><span class="stringliteral">       Section  14.7</span></div>
<div class="line"><span class="lineno"> 4806</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4807</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4808</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4809</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 4810</span><span class="stringliteral">    &gt;&gt;&gt; stats.spearmanr([1,2,3,4,5], [5,6,7,8,7])</span></div>
<div class="line"><span class="lineno"> 4811</span><span class="stringliteral">    SpearmanrResult(correlation=0.82078..., pvalue=0.08858...)</span></div>
<div class="line"><span class="lineno"> 4812</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 4813</span><span class="stringliteral">    &gt;&gt;&gt; x2n = rng.standard_normal((100, 2))</span></div>
<div class="line"><span class="lineno"> 4814</span><span class="stringliteral">    &gt;&gt;&gt; y2n = rng.standard_normal((100, 2))</span></div>
<div class="line"><span class="lineno"> 4815</span><span class="stringliteral">    &gt;&gt;&gt; stats.spearmanr(x2n)</span></div>
<div class="line"><span class="lineno"> 4816</span><span class="stringliteral">    SpearmanrResult(correlation=-0.07960396039603959, pvalue=0.4311168705769747)</span></div>
<div class="line"><span class="lineno"> 4817</span><span class="stringliteral">    &gt;&gt;&gt; stats.spearmanr(x2n[:,0], x2n[:,1])</span></div>
<div class="line"><span class="lineno"> 4818</span><span class="stringliteral">    SpearmanrResult(correlation=-0.07960396039603959, pvalue=0.4311168705769747)</span></div>
<div class="line"><span class="lineno"> 4819</span><span class="stringliteral">    &gt;&gt;&gt; rho, pval = stats.spearmanr(x2n, y2n)</span></div>
<div class="line"><span class="lineno"> 4820</span><span class="stringliteral">    &gt;&gt;&gt; rho</span></div>
<div class="line"><span class="lineno"> 4821</span><span class="stringliteral">    array([[ 1.        , -0.07960396, -0.08314431,  0.09662166],</span></div>
<div class="line"><span class="lineno"> 4822</span><span class="stringliteral">           [-0.07960396,  1.        , -0.14448245,  0.16738074],</span></div>
<div class="line"><span class="lineno"> 4823</span><span class="stringliteral">           [-0.08314431, -0.14448245,  1.        ,  0.03234323],</span></div>
<div class="line"><span class="lineno"> 4824</span><span class="stringliteral">           [ 0.09662166,  0.16738074,  0.03234323,  1.        ]])</span></div>
<div class="line"><span class="lineno"> 4825</span><span class="stringliteral">    &gt;&gt;&gt; pval</span></div>
<div class="line"><span class="lineno"> 4826</span><span class="stringliteral">    array([[0.        , 0.43111687, 0.41084066, 0.33891628],</span></div>
<div class="line"><span class="lineno"> 4827</span><span class="stringliteral">           [0.43111687, 0.        , 0.15151618, 0.09600687],</span></div>
<div class="line"><span class="lineno"> 4828</span><span class="stringliteral">           [0.41084066, 0.15151618, 0.        , 0.74938561],</span></div>
<div class="line"><span class="lineno"> 4829</span><span class="stringliteral">           [0.33891628, 0.09600687, 0.74938561, 0.        ]])</span></div>
<div class="line"><span class="lineno"> 4830</span><span class="stringliteral">    &gt;&gt;&gt; rho, pval = stats.spearmanr(x2n.T, y2n.T, axis=1)</span></div>
<div class="line"><span class="lineno"> 4831</span><span class="stringliteral">    &gt;&gt;&gt; rho</span></div>
<div class="line"><span class="lineno"> 4832</span><span class="stringliteral">    array([[ 1.        , -0.07960396, -0.08314431,  0.09662166],</span></div>
<div class="line"><span class="lineno"> 4833</span><span class="stringliteral">           [-0.07960396,  1.        , -0.14448245,  0.16738074],</span></div>
<div class="line"><span class="lineno"> 4834</span><span class="stringliteral">           [-0.08314431, -0.14448245,  1.        ,  0.03234323],</span></div>
<div class="line"><span class="lineno"> 4835</span><span class="stringliteral">           [ 0.09662166,  0.16738074,  0.03234323,  1.        ]])</span></div>
<div class="line"><span class="lineno"> 4836</span><span class="stringliteral">    &gt;&gt;&gt; stats.spearmanr(x2n, y2n, axis=None)</span></div>
<div class="line"><span class="lineno"> 4837</span><span class="stringliteral">    SpearmanrResult(correlation=0.044981624540613524, pvalue=0.5270803651336189)</span></div>
<div class="line"><span class="lineno"> 4838</span><span class="stringliteral">    &gt;&gt;&gt; stats.spearmanr(x2n.ravel(), y2n.ravel())</span></div>
<div class="line"><span class="lineno"> 4839</span><span class="stringliteral">    SpearmanrResult(correlation=0.044981624540613524, pvalue=0.5270803651336189)</span></div>
<div class="line"><span class="lineno"> 4840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4841</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 4842</span><span class="stringliteral">    &gt;&gt;&gt; xint = rng.integers(10, size=(100, 2))</span></div>
<div class="line"><span class="lineno"> 4843</span><span class="stringliteral">    &gt;&gt;&gt; stats.spearmanr(xint)</span></div>
<div class="line"><span class="lineno"> 4844</span><span class="stringliteral">    SpearmanrResult(correlation=0.09800224850707953, pvalue=0.3320271757932076)</span></div>
<div class="line"><span class="lineno"> 4845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4846</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4847</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> axis &gt; 1:</div>
<div class="line"><span class="lineno"> 4848</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;spearmanr only handles 1-D or 2-D arrays, &quot;</span></div>
<div class="line"><span class="lineno"> 4849</span>                         <span class="stringliteral">&quot;supplied axis argument {}, please use only &quot;</span></div>
<div class="line"><span class="lineno"> 4850</span>                         <span class="stringliteral">&quot;values 0, 1 or None for axis&quot;</span>.format(axis))</div>
<div class="line"><span class="lineno"> 4851</span> </div>
<div class="line"><span class="lineno"> 4852</span>    a, axisout = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 4853</span>    <span class="keywordflow">if</span> a.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 4854</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;spearmanr only handles 1-D or 2-D arrays&quot;</span>)</div>
<div class="line"><span class="lineno"> 4855</span> </div>
<div class="line"><span class="lineno"> 4856</span>    <span class="keywordflow">if</span> b <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4857</span>        <span class="keywordflow">if</span> a.ndim &lt; 2:</div>
<div class="line"><span class="lineno"> 4858</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`spearmanr` needs at least 2 &quot;</span></div>
<div class="line"><span class="lineno"> 4859</span>                             <span class="stringliteral">&quot;variables to compare&quot;</span>)</div>
<div class="line"><span class="lineno"> 4860</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4861</span>        <span class="comment"># Concatenate a and b, so that we now only have to handle the case</span></div>
<div class="line"><span class="lineno"> 4862</span>        <span class="comment"># of a 2-D `a`.</span></div>
<div class="line"><span class="lineno"> 4863</span>        b, _ = _chk_asarray(b, axis)</div>
<div class="line"><span class="lineno"> 4864</span>        <span class="keywordflow">if</span> axisout == 0:</div>
<div class="line"><span class="lineno"> 4865</span>            a = np.column_stack((a, b))</div>
<div class="line"><span class="lineno"> 4866</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4867</span>            a = np.row_stack((a, b))</div>
<div class="line"><span class="lineno"> 4868</span> </div>
<div class="line"><span class="lineno"> 4869</span>    n_vars = a.shape[1 - axisout]</div>
<div class="line"><span class="lineno"> 4870</span>    n_obs = a.shape[axisout]</div>
<div class="line"><span class="lineno"> 4871</span>    <span class="keywordflow">if</span> n_obs &lt;= 1:</div>
<div class="line"><span class="lineno"> 4872</span>        <span class="comment"># Handle empty arrays or single observations.</span></div>
<div class="line"><span class="lineno"> 4873</span>        <span class="keywordflow">return</span> SpearmanrResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 4874</span> </div>
<div class="line"><span class="lineno"> 4875</span>    warn_msg = (<span class="stringliteral">&quot;An input array is constant; the correlation coefficient &quot;</span></div>
<div class="line"><span class="lineno"> 4876</span>                <span class="stringliteral">&quot;is not defined.&quot;</span>)</div>
<div class="line"><span class="lineno"> 4877</span>    <span class="keywordflow">if</span> axisout == 0:</div>
<div class="line"><span class="lineno"> 4878</span>        <span class="keywordflow">if</span> (a[:, 0][0] == a[:, 0]).all() <span class="keywordflow">or</span> (a[:, 1][0] == a[:, 1]).all():</div>
<div class="line"><span class="lineno"> 4879</span>            <span class="comment"># If an input is constant, the correlation coefficient</span></div>
<div class="line"><span class="lineno"> 4880</span>            <span class="comment"># is not defined.</span></div>
<div class="line"><span class="lineno"> 4881</span>            warnings.warn(stats.ConstantInputWarning(warn_msg))</div>
<div class="line"><span class="lineno"> 4882</span>            <span class="keywordflow">return</span> SpearmanrResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 4883</span>    <span class="keywordflow">else</span>:  <span class="comment"># case when axisout == 1 b/c a is 2 dim only</span></div>
<div class="line"><span class="lineno"> 4884</span>        <span class="keywordflow">if</span> (a[0, :][0] == a[0, :]).all() <span class="keywordflow">or</span> (a[1, :][0] == a[1, :]).all():</div>
<div class="line"><span class="lineno"> 4885</span>            <span class="comment"># If an input is constant, the correlation coefficient</span></div>
<div class="line"><span class="lineno"> 4886</span>            <span class="comment"># is not defined.</span></div>
<div class="line"><span class="lineno"> 4887</span>            warnings.warn(stats.ConstantInputWarning(warn_msg))</div>
<div class="line"><span class="lineno"> 4888</span>            <span class="keywordflow">return</span> SpearmanrResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 4889</span> </div>
<div class="line"><span class="lineno"> 4890</span>    a_contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 4891</span>    variable_has_nan = np.zeros(n_vars, dtype=bool)</div>
<div class="line"><span class="lineno"> 4892</span>    <span class="keywordflow">if</span> a_contains_nan:</div>
<div class="line"><span class="lineno"> 4893</span>        <span class="keywordflow">if</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 4894</span>            <span class="keywordflow">return</span> mstats_basic.spearmanr(a, axis=axis, nan_policy=nan_policy,</div>
<div class="line"><span class="lineno"> 4895</span>                                          alternative=alternative)</div>
<div class="line"><span class="lineno"> 4896</span>        <span class="keywordflow">elif</span> nan_policy == <span class="stringliteral">&#39;propagate&#39;</span>:</div>
<div class="line"><span class="lineno"> 4897</span>            <span class="keywordflow">if</span> a.ndim == 1 <span class="keywordflow">or</span> n_vars &lt;= 2:</div>
<div class="line"><span class="lineno"> 4898</span>                <span class="keywordflow">return</span> SpearmanrResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 4899</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4900</span>                <span class="comment"># Keep track of variables with NaNs, set the outputs to NaN</span></div>
<div class="line"><span class="lineno"> 4901</span>                <span class="comment"># only for those variables</span></div>
<div class="line"><span class="lineno"> 4902</span>                variable_has_nan = np.isnan(a).any(axis=axisout)</div>
<div class="line"><span class="lineno"> 4903</span> </div>
<div class="line"><span class="lineno"> 4904</span>    a_ranked = np.apply_along_axis(rankdata, axisout, a)</div>
<div class="line"><span class="lineno"> 4905</span>    rs = np.corrcoef(a_ranked, rowvar=axisout)</div>
<div class="line"><span class="lineno"> 4906</span>    dof = n_obs - 2  <span class="comment"># degrees of freedom</span></div>
<div class="line"><span class="lineno"> 4907</span> </div>
<div class="line"><span class="lineno"> 4908</span>    <span class="comment"># rs can have elements equal to 1, so avoid zero division warnings</span></div>
<div class="line"><span class="lineno"> 4909</span>    <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 4910</span>        <span class="comment"># clip the small negative values possibly caused by rounding</span></div>
<div class="line"><span class="lineno"> 4911</span>        <span class="comment"># errors before taking the square root</span></div>
<div class="line"><span class="lineno"> 4912</span>        t = rs * np.sqrt((dof/((rs+1.0)*(1.0-rs))).clip(0))</div>
<div class="line"><span class="lineno"> 4913</span> </div>
<div class="line"><span class="lineno"> 4914</span>    t, prob = _ttest_finish(dof, t, alternative)</div>
<div class="line"><span class="lineno"> 4915</span> </div>
<div class="line"><span class="lineno"> 4916</span>    <span class="comment"># For backwards compatibility, return scalars when comparing 2 columns</span></div>
<div class="line"><span class="lineno"> 4917</span>    <span class="keywordflow">if</span> rs.shape == (2, 2):</div>
<div class="line"><span class="lineno"> 4918</span>        <span class="keywordflow">return</span> SpearmanrResult(rs[1, 0], prob[1, 0])</div>
<div class="line"><span class="lineno"> 4919</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4920</span>        rs[variable_has_nan, :] = np.nan</div>
<div class="line"><span class="lineno"> 4921</span>        rs[:, variable_has_nan] = np.nan</div>
<div class="line"><span class="lineno"> 4922</span>        <span class="keywordflow">return</span> SpearmanrResult(rs, prob)</div>
<div class="line"><span class="lineno"> 4923</span> </div>
<div class="line"><span class="lineno"> 4924</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1e457e8eecfa8d5e63416bd9fbf04af" name="aa1e457e8eecfa8d5e63416bd9fbf04af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e457e8eecfa8d5e63416bd9fbf04af">&#9670;&#160;</a></span>tiecorrect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.tiecorrect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rankvals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tie correction factor for Mann-Whitney U and Kruskal-Wallis H tests.

Parameters
----------
rankvals : array_like
    A 1-D sequence of ranks.  Typically this will be the array
    returned by `~scipy.stats.rankdata`.

Returns
-------
factor : float
    Correction factor for U or H.

See Also
--------
rankdata : Assign ranks to the data
mannwhitneyu : Mann-Whitney rank test
kruskal : Kruskal-Wallis H test

References
----------
.. [1] Siegel, S. (1956) Nonparametric Statistics for the Behavioral
       Sciences.  New York: McGraw-Hill.

Examples
--------
&gt;&gt;&gt; from scipy.stats import tiecorrect, rankdata
&gt;&gt;&gt; tiecorrect([1, 2.5, 2.5, 4])
0.9
&gt;&gt;&gt; ranks = rankdata([1, 3, 2, 4, 5, 7, 2, 8, 4])
&gt;&gt;&gt; ranks
array([ 1. ,  4. ,  2.5,  5.5,  7. ,  8. ,  2.5,  9. ,  5.5])
&gt;&gt;&gt; tiecorrect(ranks)
0.9833333333333333</pre> <div class="fragment"><div class="line"><span class="lineno"> 8060</span><span class="keyword">def </span>tiecorrect(rankvals):</div>
<div class="line"><span class="lineno"> 8061</span>    <span class="stringliteral">&quot;&quot;&quot;Tie correction factor for Mann-Whitney U and Kruskal-Wallis H tests.</span></div>
<div class="line"><span class="lineno"> 8062</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8063</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8064</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8065</span><span class="stringliteral">    rankvals : array_like</span></div>
<div class="line"><span class="lineno"> 8066</span><span class="stringliteral">        A 1-D sequence of ranks.  Typically this will be the array</span></div>
<div class="line"><span class="lineno"> 8067</span><span class="stringliteral">        returned by `~scipy.stats.rankdata`.</span></div>
<div class="line"><span class="lineno"> 8068</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8069</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8070</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8071</span><span class="stringliteral">    factor : float</span></div>
<div class="line"><span class="lineno"> 8072</span><span class="stringliteral">        Correction factor for U or H.</span></div>
<div class="line"><span class="lineno"> 8073</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8074</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 8075</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8076</span><span class="stringliteral">    rankdata : Assign ranks to the data</span></div>
<div class="line"><span class="lineno"> 8077</span><span class="stringliteral">    mannwhitneyu : Mann-Whitney rank test</span></div>
<div class="line"><span class="lineno"> 8078</span><span class="stringliteral">    kruskal : Kruskal-Wallis H test</span></div>
<div class="line"><span class="lineno"> 8079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8080</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8081</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8082</span><span class="stringliteral">    .. [1] Siegel, S. (1956) Nonparametric Statistics for the Behavioral</span></div>
<div class="line"><span class="lineno"> 8083</span><span class="stringliteral">           Sciences.  New York: McGraw-Hill.</span></div>
<div class="line"><span class="lineno"> 8084</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8085</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 8086</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8087</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import tiecorrect, rankdata</span></div>
<div class="line"><span class="lineno"> 8088</span><span class="stringliteral">    &gt;&gt;&gt; tiecorrect([1, 2.5, 2.5, 4])</span></div>
<div class="line"><span class="lineno"> 8089</span><span class="stringliteral">    0.9</span></div>
<div class="line"><span class="lineno"> 8090</span><span class="stringliteral">    &gt;&gt;&gt; ranks = rankdata([1, 3, 2, 4, 5, 7, 2, 8, 4])</span></div>
<div class="line"><span class="lineno"> 8091</span><span class="stringliteral">    &gt;&gt;&gt; ranks</span></div>
<div class="line"><span class="lineno"> 8092</span><span class="stringliteral">    array([ 1. ,  4. ,  2.5,  5.5,  7. ,  8. ,  2.5,  9. ,  5.5])</span></div>
<div class="line"><span class="lineno"> 8093</span><span class="stringliteral">    &gt;&gt;&gt; tiecorrect(ranks)</span></div>
<div class="line"><span class="lineno"> 8094</span><span class="stringliteral">    0.9833333333333333</span></div>
<div class="line"><span class="lineno"> 8095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8096</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8097</span>    arr = np.sort(rankvals)</div>
<div class="line"><span class="lineno"> 8098</span>    idx = np.nonzero(np.r_[<span class="keyword">True</span>, arr[1:] != arr[:-1], <span class="keyword">True</span>])[0]</div>
<div class="line"><span class="lineno"> 8099</span>    cnt = np.diff(idx).astype(np.float64)</div>
<div class="line"><span class="lineno"> 8100</span> </div>
<div class="line"><span class="lineno"> 8101</span>    size = np.float64(arr.size)</div>
<div class="line"><span class="lineno"> 8102</span>    <span class="keywordflow">return</span> 1.0 <span class="keywordflow">if</span> size &lt; 2 <span class="keywordflow">else</span> 1.0 - (cnt**3 - cnt).sum() / (size**3 - size)</div>
<div class="line"><span class="lineno"> 8103</span> </div>
<div class="line"><span class="lineno"> 8104</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3a2094871a926390297df45c2c23902e" name="a3a2094871a926390297df45c2c23902e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2094871a926390297df45c2c23902e">&#9670;&#160;</a></span>tmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.tmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>upperlimit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the trimmed maximum.

This function computes the maximum value of an array along a given axis,
while ignoring values larger than a specified upper limit.

Parameters
----------
a : array_like
    Array of values.
upperlimit : None or float, optional
    Values in the input array greater than the given limit will be ignored.
    When upperlimit is None, then all values are used. The default value
    is None.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the
    whole array `a`.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the upper limit
    are included.  The default value is True.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
tmax : float, int or ndarray
    Trimmed maximum.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.tmax(x)
19

&gt;&gt;&gt; stats.tmax(x, 13)
13

&gt;&gt;&gt; stats.tmax(x, 13, inclusive=False)
12</pre> <div class="fragment"><div class="line"><span class="lineno">  899</span><span class="keyword">def </span>tmax(a, upperlimit=None, axis=0, inclusive=True, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno">  900</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the trimmed maximum.</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    This function computes the maximum value of an array along a given axis,</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    while ignoring values larger than a specified upper limit.</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">        Array of values.</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    upperlimit : None or float, optional</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        Values in the input array greater than the given limit will be ignored.</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        When upperlimit is None, then all values are used. The default value</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        is None.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over the</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">        whole array `a`.</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    inclusive : {True, False}, optional</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">        This flag determines whether values exactly equal to the upper limit</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">        are included.  The default value is True.</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    tmax : float, int or ndarray</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">        Trimmed maximum.</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(20)</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmax(x)</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    19</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmax(x, 13)</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    13</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmax(x, 13, inclusive=False)</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    12</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  946</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno">  947</span>    am = _mask_to_limits(a, (<span class="keywordtype">None</span>, upperlimit), (<span class="keyword">False</span>, inclusive))</div>
<div class="line"><span class="lineno">  948</span> </div>
<div class="line"><span class="lineno">  949</span>    contains_nan, nan_policy = _contains_nan(am, nan_policy)</div>
<div class="line"><span class="lineno">  950</span> </div>
<div class="line"><span class="lineno">  951</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno">  952</span>        am = ma.masked_invalid(am)</div>
<div class="line"><span class="lineno">  953</span> </div>
<div class="line"><span class="lineno">  954</span>    res = ma.maximum.reduce(am, axis).data</div>
<div class="line"><span class="lineno">  955</span>    <span class="keywordflow">if</span> res.ndim == 0:</div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordflow">return</span> res[()]</div>
<div class="line"><span class="lineno">  957</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a429c8fac38c7f007f95416b907858513" name="a429c8fac38c7f007f95416b907858513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429c8fac38c7f007f95416b907858513">&#9670;&#160;</a></span>tmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.tmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>(True,&#160;True)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the trimmed mean.

This function finds the arithmetic mean of given values, ignoring values
outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored.  When limits is None (default), then all
    values are used.  Either of the limit values in the tuple can also be
    None representing a half-open interval.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, optional
    Axis along which to compute test. Default is None.

Returns
-------
tmean : ndarray
    Trimmed mean.

See Also
--------
trim_mean : Returns mean after trimming a proportion from both tails.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.tmean(x)
9.5
&gt;&gt;&gt; stats.tmean(x, (3,17))
10.0</pre> <div class="fragment"><div class="line"><span class="lineno">  734</span><span class="keyword">def </span>tmean(a, limits=None, inclusive=(<span class="keyword">True</span>, <span class="keyword">True</span>), axis=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  735</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the trimmed mean.</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    This function finds the arithmetic mean of given values, ignoring values</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    outside the given `limits`.</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        Array of values.</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    limits : None or (lower limit, upper limit), optional</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        Values in the input array less than the lower limit or greater than the</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        upper limit will be ignored.  When limits is None (default), then all</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        values are used.  Either of the limit values in the tuple can also be</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">        None representing a half-open interval.</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    inclusive : (bool, bool), optional</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        A tuple consisting of the (lower flag, upper flag).  These flags</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        determine whether values exactly equal to the lower or upper limits</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        are included.  The default value is (True, True).</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        Axis along which to compute test. Default is None.</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    tmean : ndarray</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        Trimmed mean.</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    trim_mean : Returns mean after trimming a proportion from both tails.</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(20)</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmean(x)</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    9.5</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmean(x, (3,17))</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    10.0</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  775</span>    a = asarray(a)</div>
<div class="line"><span class="lineno">  776</span>    <span class="keywordflow">if</span> limits <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  777</span>        <span class="keywordflow">return</span> np.mean(a, axis)</div>
<div class="line"><span class="lineno">  778</span>    am = _mask_to_limits(a, limits, inclusive)</div>
<div class="line"><span class="lineno">  779</span>    mean = np.ma.filled(am.mean(axis=axis), fill_value=np.nan)</div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">return</span> mean <span class="keywordflow">if</span> mean.ndim &gt; 0 <span class="keywordflow">else</span> mean.item()</div>
<div class="line"><span class="lineno">  781</span> </div>
<div class="line"><span class="lineno">  782</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5fced7efb0eda0d00485572e5cd317d" name="ad5fced7efb0eda0d00485572e5cd317d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fced7efb0eda0d00485572e5cd317d">&#9670;&#160;</a></span>tmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.tmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lowerlimit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the trimmed minimum.

This function finds the miminum value of an array `a` along the
specified axis, but only considering values greater than a specified
lower limit.

Parameters
----------
a : array_like
    Array of values.
lowerlimit : None or float, optional
    Values in the input array less than the given limit will be ignored.
    When lowerlimit is None, then all values are used. The default value
    is None.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the
    whole array `a`.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the lower limit
    are included.  The default value is True.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

Returns
-------
tmin : float, int or ndarray
    Trimmed minimum.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.tmin(x)
0

&gt;&gt;&gt; stats.tmin(x, 13)
13

&gt;&gt;&gt; stats.tmin(x, 13, inclusive=False)
14</pre> <div class="fragment"><div class="line"><span class="lineno">  837</span><span class="keyword">def </span>tmin(a, lowerlimit=None, axis=0, inclusive=True, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno">  838</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the trimmed minimum.</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    This function finds the miminum value of an array `a` along the</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    specified axis, but only considering values greater than a specified</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    lower limit.</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        Array of values.</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    lowerlimit : None or float, optional</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">        Values in the input array less than the given limit will be ignored.</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">        When lowerlimit is None, then all values are used. The default value</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">        is None.</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over the</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">        whole array `a`.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    inclusive : {True, False}, optional</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">        This flag determines whether values exactly equal to the lower limit</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">        are included.  The default value is True.</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    tmin : float, int or ndarray</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">        Trimmed minimum.</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(20)</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmin(x)</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    0</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmin(x, 13)</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    13</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    &gt;&gt;&gt; stats.tmin(x, 13, inclusive=False)</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    14</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  885</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno">  886</span>    am = _mask_to_limits(a, (lowerlimit, <span class="keywordtype">None</span>), (inclusive, <span class="keyword">False</span>))</div>
<div class="line"><span class="lineno">  887</span> </div>
<div class="line"><span class="lineno">  888</span>    contains_nan, nan_policy = _contains_nan(am, nan_policy)</div>
<div class="line"><span class="lineno">  889</span> </div>
<div class="line"><span class="lineno">  890</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno">  891</span>        am = ma.masked_invalid(am)</div>
<div class="line"><span class="lineno">  892</span> </div>
<div class="line"><span class="lineno">  893</span>    res = ma.minimum.reduce(am, axis).data</div>
<div class="line"><span class="lineno">  894</span>    <span class="keywordflow">if</span> res.ndim == 0:</div>
<div class="line"><span class="lineno">  895</span>        <span class="keywordflow">return</span> res[()]</div>
<div class="line"><span class="lineno">  896</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  897</span> </div>
<div class="line"><span class="lineno">  898</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a133a4a1cf3127cc59ab529a6342e4e3b" name="a133a4a1cf3127cc59ab529a6342e4e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133a4a1cf3127cc59ab529a6342e4e3b">&#9670;&#160;</a></span>trim1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.trim1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proportiontocut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tail</em> = <code>'right'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Slice off a proportion from ONE end of the passed array distribution.

If `proportiontocut` = 0.1, slices off 'leftmost' or 'rightmost'
10% of scores. The lowest or highest values are trimmed (depending on
the tail).
Slice off less if proportion results in a non-integer slice index
(i.e. conservatively slices off `proportiontocut` ).

Parameters
----------
a : array_like
    Input array.
proportiontocut : float
    Fraction to cut off of 'left' or 'right' of distribution.
tail : {'left', 'right'}, optional
    Defaults to 'right'.
axis : int or None, optional
    Axis along which to trim data. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
trim1 : ndarray
    Trimmed version of array `a`. The order of the trimmed content is
    undefined.

Examples
--------
Create an array of 10 values and trim 20% of its lowest values:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; stats.trim1(a, 0.2, 'left')
array([2, 4, 3, 5, 6, 7, 8, 9])

Note that the elements of the input array are trimmed by value, but the
output array is not necessarily sorted.

The proportion to trim is rounded down to the nearest integer. For
instance, trimming 25% of the values from an array of 10 values will
return an array of 8 values:

&gt;&gt;&gt; b = np.arange(10)
&gt;&gt;&gt; stats.trim1(b, 1/4).shape
(8,)

Multidimensional arrays can be trimmed along any axis or across the entire
array:

&gt;&gt;&gt; c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9]
&gt;&gt;&gt; d = np.array([a, b, c])
&gt;&gt;&gt; stats.trim1(d, 0.8, axis=0).shape
(1, 10)
&gt;&gt;&gt; stats.trim1(d, 0.8, axis=1).shape
(3, 2)
&gt;&gt;&gt; stats.trim1(d, 0.8, axis=None).shape
(6,)</pre> <div class="fragment"><div class="line"><span class="lineno"> 3545</span><span class="keyword">def </span>trim1(a, proportiontocut, tail=&#39;right&#39;, axis=0):</div>
<div class="line"><span class="lineno"> 3546</span>    <span class="stringliteral">&quot;&quot;&quot;Slice off a proportion from ONE end of the passed array distribution.</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral">    If `proportiontocut` = 0.1, slices off &#39;leftmost&#39; or &#39;rightmost&#39;</span></div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">    10% of scores. The lowest or highest values are trimmed (depending on</span></div>
<div class="line"><span class="lineno"> 3550</span><span class="stringliteral">    the tail).</span></div>
<div class="line"><span class="lineno"> 3551</span><span class="stringliteral">    Slice off less if proportion results in a non-integer slice index</span></div>
<div class="line"><span class="lineno"> 3552</span><span class="stringliteral">    (i.e. conservatively slices off `proportiontocut` ).</span></div>
<div class="line"><span class="lineno"> 3553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3554</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3555</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3556</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3557</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 3558</span><span class="stringliteral">    proportiontocut : float</span></div>
<div class="line"><span class="lineno"> 3559</span><span class="stringliteral">        Fraction to cut off of &#39;left&#39; or &#39;right&#39; of distribution.</span></div>
<div class="line"><span class="lineno"> 3560</span><span class="stringliteral">    tail : {&#39;left&#39;, &#39;right&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3561</span><span class="stringliteral">        Defaults to &#39;right&#39;.</span></div>
<div class="line"><span class="lineno"> 3562</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 3563</span><span class="stringliteral">        Axis along which to trim data. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 3564</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 3565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3568</span><span class="stringliteral">    trim1 : ndarray</span></div>
<div class="line"><span class="lineno"> 3569</span><span class="stringliteral">        Trimmed version of array `a`. The order of the trimmed content is</span></div>
<div class="line"><span class="lineno"> 3570</span><span class="stringliteral">        undefined.</span></div>
<div class="line"><span class="lineno"> 3571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3572</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3573</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral">    Create an array of 10 values and trim 20% of its lowest values:</span></div>
<div class="line"><span class="lineno"> 3575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3576</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 3577</span><span class="stringliteral">    &gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></div>
<div class="line"><span class="lineno"> 3578</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim1(a, 0.2, &#39;left&#39;)</span></div>
<div class="line"><span class="lineno"> 3579</span><span class="stringliteral">    array([2, 4, 3, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 3580</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3581</span><span class="stringliteral">    Note that the elements of the input array are trimmed by value, but the</span></div>
<div class="line"><span class="lineno"> 3582</span><span class="stringliteral">    output array is not necessarily sorted.</span></div>
<div class="line"><span class="lineno"> 3583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3584</span><span class="stringliteral">    The proportion to trim is rounded down to the nearest integer. For</span></div>
<div class="line"><span class="lineno"> 3585</span><span class="stringliteral">    instance, trimming 25% of the values from an array of 10 values will</span></div>
<div class="line"><span class="lineno"> 3586</span><span class="stringliteral">    return an array of 8 values:</span></div>
<div class="line"><span class="lineno"> 3587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3588</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(10)</span></div>
<div class="line"><span class="lineno"> 3589</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim1(b, 1/4).shape</span></div>
<div class="line"><span class="lineno"> 3590</span><span class="stringliteral">    (8,)</span></div>
<div class="line"><span class="lineno"> 3591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3592</span><span class="stringliteral">    Multidimensional arrays can be trimmed along any axis or across the entire</span></div>
<div class="line"><span class="lineno"> 3593</span><span class="stringliteral">    array:</span></div>
<div class="line"><span class="lineno"> 3594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3595</span><span class="stringliteral">    &gt;&gt;&gt; c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9]</span></div>
<div class="line"><span class="lineno"> 3596</span><span class="stringliteral">    &gt;&gt;&gt; d = np.array([a, b, c])</span></div>
<div class="line"><span class="lineno"> 3597</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim1(d, 0.8, axis=0).shape</span></div>
<div class="line"><span class="lineno"> 3598</span><span class="stringliteral">    (1, 10)</span></div>
<div class="line"><span class="lineno"> 3599</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim1(d, 0.8, axis=1).shape</span></div>
<div class="line"><span class="lineno"> 3600</span><span class="stringliteral">    (3, 2)</span></div>
<div class="line"><span class="lineno"> 3601</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim1(d, 0.8, axis=None).shape</span></div>
<div class="line"><span class="lineno"> 3602</span><span class="stringliteral">    (6,)</span></div>
<div class="line"><span class="lineno"> 3603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3604</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3605</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 3606</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3607</span>        a = a.ravel()</div>
<div class="line"><span class="lineno"> 3608</span>        axis = 0</div>
<div class="line"><span class="lineno"> 3609</span> </div>
<div class="line"><span class="lineno"> 3610</span>    nobs = a.shape[axis]</div>
<div class="line"><span class="lineno"> 3611</span> </div>
<div class="line"><span class="lineno"> 3612</span>    <span class="comment"># avoid possible corner case</span></div>
<div class="line"><span class="lineno"> 3613</span>    <span class="keywordflow">if</span> proportiontocut &gt;= 1:</div>
<div class="line"><span class="lineno"> 3614</span>        <span class="keywordflow">return</span> []</div>
<div class="line"><span class="lineno"> 3615</span> </div>
<div class="line"><span class="lineno"> 3616</span>    <span class="keywordflow">if</span> tail.lower() == <span class="stringliteral">&#39;right&#39;</span>:</div>
<div class="line"><span class="lineno"> 3617</span>        lowercut = 0</div>
<div class="line"><span class="lineno"> 3618</span>        uppercut = nobs - int(proportiontocut * nobs)</div>
<div class="line"><span class="lineno"> 3619</span> </div>
<div class="line"><span class="lineno"> 3620</span>    <span class="keywordflow">elif</span> tail.lower() == <span class="stringliteral">&#39;left&#39;</span>:</div>
<div class="line"><span class="lineno"> 3621</span>        lowercut = int(proportiontocut * nobs)</div>
<div class="line"><span class="lineno"> 3622</span>        uppercut = nobs</div>
<div class="line"><span class="lineno"> 3623</span> </div>
<div class="line"><span class="lineno"> 3624</span>    atmp = np.partition(a, (lowercut, uppercut - 1), axis)</div>
<div class="line"><span class="lineno"> 3625</span> </div>
<div class="line"><span class="lineno"> 3626</span>    sl = [slice(<span class="keywordtype">None</span>)] * atmp.ndim</div>
<div class="line"><span class="lineno"> 3627</span>    sl[axis] = slice(lowercut, uppercut)</div>
<div class="line"><span class="lineno"> 3628</span>    <span class="keywordflow">return</span> atmp[tuple(sl)]</div>
<div class="line"><span class="lineno"> 3629</span> </div>
<div class="line"><span class="lineno"> 3630</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a692b1677d3e31fb991495d59a7378aff" name="a692b1677d3e31fb991495d59a7378aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692b1677d3e31fb991495d59a7378aff">&#9670;&#160;</a></span>trim_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.trim_mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proportiontocut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return mean of array after trimming distribution from both tails.

If `proportiontocut` = 0.1, slices off 'leftmost' and 'rightmost' 10% of
scores. The input is sorted before slicing. Slices off less if proportion
results in a non-integer slice index (i.e., conservatively slices off
`proportiontocut` ).

Parameters
----------
a : array_like
    Input array.
proportiontocut : float
    Fraction to cut off of both tails of the distribution.
axis : int or None, optional
    Axis along which the trimmed means are computed. Default is 0.
    If None, compute over the whole array `a`.

Returns
-------
trim_mean : ndarray
    Mean of trimmed array.

See Also
--------
trimboth
tmean : Compute the trimmed mean ignoring values outside given `limits`.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.trim_mean(x, 0.1)
9.5
&gt;&gt;&gt; x2 = x.reshape(5, 4)
&gt;&gt;&gt; x2
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19]])
&gt;&gt;&gt; stats.trim_mean(x2, 0.25)
array([  8.,   9.,  10.,  11.])
&gt;&gt;&gt; stats.trim_mean(x2, 0.25, axis=1)
array([  1.5,   5.5,   9.5,  13.5,  17.5])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3631</span><span class="keyword">def </span>trim_mean(a, proportiontocut, axis=0):</div>
<div class="line"><span class="lineno"> 3632</span>    <span class="stringliteral">&quot;&quot;&quot;Return mean of array after trimming distribution from both tails.</span></div>
<div class="line"><span class="lineno"> 3633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3634</span><span class="stringliteral">    If `proportiontocut` = 0.1, slices off &#39;leftmost&#39; and &#39;rightmost&#39; 10% of</span></div>
<div class="line"><span class="lineno"> 3635</span><span class="stringliteral">    scores. The input is sorted before slicing. Slices off less if proportion</span></div>
<div class="line"><span class="lineno"> 3636</span><span class="stringliteral">    results in a non-integer slice index (i.e., conservatively slices off</span></div>
<div class="line"><span class="lineno"> 3637</span><span class="stringliteral">    `proportiontocut` ).</span></div>
<div class="line"><span class="lineno"> 3638</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3639</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3640</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3641</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3642</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 3643</span><span class="stringliteral">    proportiontocut : float</span></div>
<div class="line"><span class="lineno"> 3644</span><span class="stringliteral">        Fraction to cut off of both tails of the distribution.</span></div>
<div class="line"><span class="lineno"> 3645</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 3646</span><span class="stringliteral">        Axis along which the trimmed means are computed. Default is 0.</span></div>
<div class="line"><span class="lineno"> 3647</span><span class="stringliteral">        If None, compute over the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 3648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3649</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3650</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3651</span><span class="stringliteral">    trim_mean : ndarray</span></div>
<div class="line"><span class="lineno"> 3652</span><span class="stringliteral">        Mean of trimmed array.</span></div>
<div class="line"><span class="lineno"> 3653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3654</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3655</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3656</span><span class="stringliteral">    trimboth</span></div>
<div class="line"><span class="lineno"> 3657</span><span class="stringliteral">    tmean : Compute the trimmed mean ignoring values outside given `limits`.</span></div>
<div class="line"><span class="lineno"> 3658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3659</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3660</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3661</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 3662</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(20)</span></div>
<div class="line"><span class="lineno"> 3663</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim_mean(x, 0.1)</span></div>
<div class="line"><span class="lineno"> 3664</span><span class="stringliteral">    9.5</span></div>
<div class="line"><span class="lineno"> 3665</span><span class="stringliteral">    &gt;&gt;&gt; x2 = x.reshape(5, 4)</span></div>
<div class="line"><span class="lineno"> 3666</span><span class="stringliteral">    &gt;&gt;&gt; x2</span></div>
<div class="line"><span class="lineno"> 3667</span><span class="stringliteral">    array([[ 0,  1,  2,  3],</span></div>
<div class="line"><span class="lineno"> 3668</span><span class="stringliteral">           [ 4,  5,  6,  7],</span></div>
<div class="line"><span class="lineno"> 3669</span><span class="stringliteral">           [ 8,  9, 10, 11],</span></div>
<div class="line"><span class="lineno"> 3670</span><span class="stringliteral">           [12, 13, 14, 15],</span></div>
<div class="line"><span class="lineno"> 3671</span><span class="stringliteral">           [16, 17, 18, 19]])</span></div>
<div class="line"><span class="lineno"> 3672</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim_mean(x2, 0.25)</span></div>
<div class="line"><span class="lineno"> 3673</span><span class="stringliteral">    array([  8.,   9.,  10.,  11.])</span></div>
<div class="line"><span class="lineno"> 3674</span><span class="stringliteral">    &gt;&gt;&gt; stats.trim_mean(x2, 0.25, axis=1)</span></div>
<div class="line"><span class="lineno"> 3675</span><span class="stringliteral">    array([  1.5,   5.5,   9.5,  13.5,  17.5])</span></div>
<div class="line"><span class="lineno"> 3676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3677</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3678</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 3679</span> </div>
<div class="line"><span class="lineno"> 3680</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 3681</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 3682</span> </div>
<div class="line"><span class="lineno"> 3683</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3684</span>        a = a.ravel()</div>
<div class="line"><span class="lineno"> 3685</span>        axis = 0</div>
<div class="line"><span class="lineno"> 3686</span> </div>
<div class="line"><span class="lineno"> 3687</span>    nobs = a.shape[axis]</div>
<div class="line"><span class="lineno"> 3688</span>    lowercut = int(proportiontocut * nobs)</div>
<div class="line"><span class="lineno"> 3689</span>    uppercut = nobs - lowercut</div>
<div class="line"><span class="lineno"> 3690</span>    <span class="keywordflow">if</span> (lowercut &gt; uppercut):</div>
<div class="line"><span class="lineno"> 3691</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Proportion too big.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3692</span> </div>
<div class="line"><span class="lineno"> 3693</span>    atmp = np.partition(a, (lowercut, uppercut - 1), axis)</div>
<div class="line"><span class="lineno"> 3694</span> </div>
<div class="line"><span class="lineno"> 3695</span>    sl = [slice(<span class="keywordtype">None</span>)] * atmp.ndim</div>
<div class="line"><span class="lineno"> 3696</span>    sl[axis] = slice(lowercut, uppercut)</div>
<div class="line"><span class="lineno"> 3697</span>    <span class="keywordflow">return</span> np.mean(atmp[tuple(sl)], axis=axis)</div>
<div class="line"><span class="lineno"> 3698</span> </div>
<div class="line"><span class="lineno"> 3699</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af1b232b8ef2a078a8bda0f808ca871b0" name="af1b232b8ef2a078a8bda0f808ca871b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b232b8ef2a078a8bda0f808ca871b0">&#9670;&#160;</a></span>trimboth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.trimboth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proportiontocut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Slice off a proportion of items from both ends of an array.

Slice off the passed proportion of items from both ends of the passed
array (i.e., with `proportiontocut` = 0.1, slices leftmost 10% **and**
rightmost 10% of scores). The trimmed values are the lowest and
highest ones.
Slice off less if proportion results in a non-integer slice index (i.e.
conservatively slices off `proportiontocut`).

Parameters
----------
a : array_like
    Data to trim.
proportiontocut : float
    Proportion (in range 0-1) of total data set to trim of each end.
axis : int or None, optional
    Axis along which to trim data. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
out : ndarray
    Trimmed version of array `a`. The order of the trimmed content
    is undefined.

See Also
--------
trim_mean

Examples
--------
Create an array of 10 values and trim 10% of those values from each end:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; stats.trimboth(a, 0.1)
array([1, 3, 2, 4, 5, 6, 7, 8])

Note that the elements of the input array are trimmed by value, but the
output array is not necessarily sorted.

The proportion to trim is rounded down to the nearest integer. For
instance, trimming 25% of the values from each end of an array of 10
values will return an array of 6 values:

&gt;&gt;&gt; b = np.arange(10)
&gt;&gt;&gt; stats.trimboth(b, 1/4).shape
(6,)

Multidimensional arrays can be trimmed along any axis or across the entire
array:

&gt;&gt;&gt; c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9]
&gt;&gt;&gt; d = np.array([a, b, c])
&gt;&gt;&gt; stats.trimboth(d, 0.4, axis=0).shape
(1, 10)
&gt;&gt;&gt; stats.trimboth(d, 0.4, axis=1).shape
(3, 2)
&gt;&gt;&gt; stats.trimboth(d, 0.4, axis=None).shape
(6,)</pre> <div class="fragment"><div class="line"><span class="lineno"> 3460</span><span class="keyword">def </span>trimboth(a, proportiontocut, axis=0):</div>
<div class="line"><span class="lineno"> 3461</span>    <span class="stringliteral">&quot;&quot;&quot;Slice off a proportion of items from both ends of an array.</span></div>
<div class="line"><span class="lineno"> 3462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3463</span><span class="stringliteral">    Slice off the passed proportion of items from both ends of the passed</span></div>
<div class="line"><span class="lineno"> 3464</span><span class="stringliteral">    array (i.e., with `proportiontocut` = 0.1, slices leftmost 10% **and**</span></div>
<div class="line"><span class="lineno"> 3465</span><span class="stringliteral">    rightmost 10% of scores). The trimmed values are the lowest and</span></div>
<div class="line"><span class="lineno"> 3466</span><span class="stringliteral">    highest ones.</span></div>
<div class="line"><span class="lineno"> 3467</span><span class="stringliteral">    Slice off less if proportion results in a non-integer slice index (i.e.</span></div>
<div class="line"><span class="lineno"> 3468</span><span class="stringliteral">    conservatively slices off `proportiontocut`).</span></div>
<div class="line"><span class="lineno"> 3469</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3470</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3471</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3472</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3473</span><span class="stringliteral">        Data to trim.</span></div>
<div class="line"><span class="lineno"> 3474</span><span class="stringliteral">    proportiontocut : float</span></div>
<div class="line"><span class="lineno"> 3475</span><span class="stringliteral">        Proportion (in range 0-1) of total data set to trim of each end.</span></div>
<div class="line"><span class="lineno"> 3476</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 3477</span><span class="stringliteral">        Axis along which to trim data. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 3478</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 3479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3480</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3481</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3482</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 3483</span><span class="stringliteral">        Trimmed version of array `a`. The order of the trimmed content</span></div>
<div class="line"><span class="lineno"> 3484</span><span class="stringliteral">        is undefined.</span></div>
<div class="line"><span class="lineno"> 3485</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3486</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3487</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3488</span><span class="stringliteral">    trim_mean</span></div>
<div class="line"><span class="lineno"> 3489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3490</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3491</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3492</span><span class="stringliteral">    Create an array of 10 values and trim 10% of those values from each end:</span></div>
<div class="line"><span class="lineno"> 3493</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3494</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 3495</span><span class="stringliteral">    &gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></div>
<div class="line"><span class="lineno"> 3496</span><span class="stringliteral">    &gt;&gt;&gt; stats.trimboth(a, 0.1)</span></div>
<div class="line"><span class="lineno"> 3497</span><span class="stringliteral">    array([1, 3, 2, 4, 5, 6, 7, 8])</span></div>
<div class="line"><span class="lineno"> 3498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3499</span><span class="stringliteral">    Note that the elements of the input array are trimmed by value, but the</span></div>
<div class="line"><span class="lineno"> 3500</span><span class="stringliteral">    output array is not necessarily sorted.</span></div>
<div class="line"><span class="lineno"> 3501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3502</span><span class="stringliteral">    The proportion to trim is rounded down to the nearest integer. For</span></div>
<div class="line"><span class="lineno"> 3503</span><span class="stringliteral">    instance, trimming 25% of the values from each end of an array of 10</span></div>
<div class="line"><span class="lineno"> 3504</span><span class="stringliteral">    values will return an array of 6 values:</span></div>
<div class="line"><span class="lineno"> 3505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3506</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(10)</span></div>
<div class="line"><span class="lineno"> 3507</span><span class="stringliteral">    &gt;&gt;&gt; stats.trimboth(b, 1/4).shape</span></div>
<div class="line"><span class="lineno"> 3508</span><span class="stringliteral">    (6,)</span></div>
<div class="line"><span class="lineno"> 3509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3510</span><span class="stringliteral">    Multidimensional arrays can be trimmed along any axis or across the entire</span></div>
<div class="line"><span class="lineno"> 3511</span><span class="stringliteral">    array:</span></div>
<div class="line"><span class="lineno"> 3512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3513</span><span class="stringliteral">    &gt;&gt;&gt; c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9]</span></div>
<div class="line"><span class="lineno"> 3514</span><span class="stringliteral">    &gt;&gt;&gt; d = np.array([a, b, c])</span></div>
<div class="line"><span class="lineno"> 3515</span><span class="stringliteral">    &gt;&gt;&gt; stats.trimboth(d, 0.4, axis=0).shape</span></div>
<div class="line"><span class="lineno"> 3516</span><span class="stringliteral">    (1, 10)</span></div>
<div class="line"><span class="lineno"> 3517</span><span class="stringliteral">    &gt;&gt;&gt; stats.trimboth(d, 0.4, axis=1).shape</span></div>
<div class="line"><span class="lineno"> 3518</span><span class="stringliteral">    (3, 2)</span></div>
<div class="line"><span class="lineno"> 3519</span><span class="stringliteral">    &gt;&gt;&gt; stats.trimboth(d, 0.4, axis=None).shape</span></div>
<div class="line"><span class="lineno"> 3520</span><span class="stringliteral">    (6,)</span></div>
<div class="line"><span class="lineno"> 3521</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3522</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3523</span>    a = np.asarray(a)</div>
<div class="line"><span class="lineno"> 3524</span> </div>
<div class="line"><span class="lineno"> 3525</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 3526</span>        <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno"> 3527</span> </div>
<div class="line"><span class="lineno"> 3528</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3529</span>        a = a.ravel()</div>
<div class="line"><span class="lineno"> 3530</span>        axis = 0</div>
<div class="line"><span class="lineno"> 3531</span> </div>
<div class="line"><span class="lineno"> 3532</span>    nobs = a.shape[axis]</div>
<div class="line"><span class="lineno"> 3533</span>    lowercut = int(proportiontocut * nobs)</div>
<div class="line"><span class="lineno"> 3534</span>    uppercut = nobs - lowercut</div>
<div class="line"><span class="lineno"> 3535</span>    <span class="keywordflow">if</span> (lowercut &gt;= uppercut):</div>
<div class="line"><span class="lineno"> 3536</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Proportion too big.&quot;</span>)</div>
<div class="line"><span class="lineno"> 3537</span> </div>
<div class="line"><span class="lineno"> 3538</span>    atmp = np.partition(a, (lowercut, uppercut - 1), axis)</div>
<div class="line"><span class="lineno"> 3539</span> </div>
<div class="line"><span class="lineno"> 3540</span>    sl = [slice(<span class="keywordtype">None</span>)] * atmp.ndim</div>
<div class="line"><span class="lineno"> 3541</span>    sl[axis] = slice(lowercut, uppercut)</div>
<div class="line"><span class="lineno"> 3542</span>    <span class="keywordflow">return</span> atmp[tuple(sl)]</div>
<div class="line"><span class="lineno"> 3543</span> </div>
<div class="line"><span class="lineno"> 3544</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad31c6b6ef9f91a6dfc8e174a87c0e190" name="ad31c6b6ef9f91a6dfc8e174a87c0e190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31c6b6ef9f91a6dfc8e174a87c0e190">&#9670;&#160;</a></span>tsem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.tsem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>(True,&#160;True)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the trimmed standard error of the mean.

This function finds the standard error of the mean for given
values, ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the
    whole array `a`.
ddof : int, optional
    Delta degrees of freedom.  Default is 1.

Returns
-------
tsem : float
    Trimmed standard error of the mean.

Notes
-----
`tsem` uses unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.tsem(x)
1.3228756555322954
&gt;&gt;&gt; stats.tsem(x, (3,17))
1.1547005383792515</pre> <div class="fragment"><div class="line"><span class="lineno"> 1008</span><span class="keyword">def </span>tsem(a, limits=None, inclusive=(<span class="keyword">True</span>, <span class="keyword">True</span>), axis=0, ddof=1):</div>
<div class="line"><span class="lineno"> 1009</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the trimmed standard error of the mean.</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    This function finds the standard error of the mean for given</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    values, ignoring values outside the given `limits`.</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        Array of values.</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    limits : None or (lower limit, upper limit), optional</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">        Values in the input array less than the lower limit or greater than the</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">        upper limit will be ignored. When limits is None, then all values are</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">        used. Either of the limit values in the tuple can also be None</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">        representing a half-open interval.  The default value is None.</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    inclusive : (bool, bool), optional</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">        A tuple consisting of the (lower flag, upper flag).  These flags</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">        determine whether values exactly equal to the lower or upper limits</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">        are included.  The default value is (True, True).</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over the</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">        whole array `a`.</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">        Delta degrees of freedom.  Default is 1.</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    tsem : float</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">        Trimmed standard error of the mean.</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    `tsem` uses unbiased sample standard deviation, i.e. it uses a</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    correction factor ``n / (n - 1)``.</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(20)</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    &gt;&gt;&gt; stats.tsem(x)</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">    1.3228756555322954</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    &gt;&gt;&gt; stats.tsem(x, (3,17))</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">    1.1547005383792515</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1053</span>    a = np.asarray(a).ravel()</div>
<div class="line"><span class="lineno"> 1054</span>    <span class="keywordflow">if</span> limits <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1055</span>        <span class="keywordflow">return</span> a.std(ddof=ddof) / np.sqrt(a.size)</div>
<div class="line"><span class="lineno"> 1056</span> </div>
<div class="line"><span class="lineno"> 1057</span>    am = _mask_to_limits(a, limits, inclusive)</div>
<div class="line"><span class="lineno"> 1058</span>    sd = np.sqrt(np.ma.var(am, ddof=ddof, axis=axis))</div>
<div class="line"><span class="lineno"> 1059</span>    <span class="keywordflow">return</span> sd / np.sqrt(am.count())</div>
<div class="line"><span class="lineno"> 1060</span> </div>
<div class="line"><span class="lineno"> 1061</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a556a06abd7478c8d2c7500b2992c51c3" name="a556a06abd7478c8d2c7500b2992c51c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556a06abd7478c8d2c7500b2992c51c3">&#9670;&#160;</a></span>tstd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.tstd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>(True,&#160;True)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the trimmed sample standard deviation.

This function finds the sample standard deviation of given values,
ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the
    whole array `a`.
ddof : int, optional
    Delta degrees of freedom.  Default is 1.

Returns
-------
tstd : float
    Trimmed sample standard deviation.

Notes
-----
`tstd` computes the unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.tstd(x)
5.9160797830996161
&gt;&gt;&gt; stats.tstd(x, (3,17))
4.4721359549995796</pre> <div class="fragment"><div class="line"><span class="lineno">  960</span><span class="keyword">def </span>tstd(a, limits=None, inclusive=(<span class="keyword">True</span>, <span class="keyword">True</span>), axis=0, ddof=1):</div>
<div class="line"><span class="lineno">  961</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the trimmed sample standard deviation.</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    This function finds the sample standard deviation of given values,</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    ignoring values outside the given `limits`.</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">        Array of values.</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral">    limits : None or (lower limit, upper limit), optional</span></div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">        Values in the input array less than the lower limit or greater than the</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">        upper limit will be ignored. When limits is None, then all values are</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">        used. Either of the limit values in the tuple can also be None</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        representing a half-open interval.  The default value is None.</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    inclusive : (bool, bool), optional</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">        A tuple consisting of the (lower flag, upper flag).  These flags</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">        determine whether values exactly equal to the lower or upper limits</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">        are included.  The default value is (True, True).</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over the</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">        whole array `a`.</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">        Delta degrees of freedom.  Default is 1.</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">    tstd : float</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">        Trimmed sample standard deviation.</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    `tstd` computes the unbiased sample standard deviation, i.e. it uses a</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    correction factor ``n / (n - 1)``.</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(20)</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    &gt;&gt;&gt; stats.tstd(x)</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    5.9160797830996161</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    &gt;&gt;&gt; stats.tstd(x, (3,17))</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    4.4721359549995796</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1005</span>    <span class="keywordflow">return</span> np.sqrt(tvar(a, limits, inclusive, axis, ddof))</div>
<div class="line"><span class="lineno"> 1006</span> </div>
<div class="line"><span class="lineno"> 1007</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b40cba4553c34430dc8745cc657d107" name="a0b40cba4553c34430dc8745cc657d107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b40cba4553c34430dc8745cc657d107">&#9670;&#160;</a></span>ttest_1samp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ttest_1samp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>popmean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the T-test for the mean of ONE group of scores.

This is a test for the null hypothesis that the expected value
(mean) of a sample of independent observations `a` is equal to the given
population mean, `popmean`.

Parameters
----------
a : array_like
    Sample observation.
popmean : float or array_like
    Expected value in null hypothesis. If array_like, then it must have the
    same shape as `a` excluding the axis dimension.
axis : int or None, optional
    Axis along which to compute test; default is 0. If None, compute over
    the whole array `a`.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the mean of the underlying distribution of the sample
      is different than the given population mean (`popmean`)
    * 'less': the mean of the underlying distribution of the sample is
      less than the given population mean (`popmean`)
    * 'greater': the mean of the underlying distribution of the sample is
      greater than the given population mean (`popmean`)

    .. versionadded:: 1.6.0

Returns
-------
statistic : float or array
    t-statistic.
pvalue : float or array
    Two-sided p-value.

Notes
-----
The statistic is calculated as ``(np.mean(a) - popmean)/se``, where
``se`` is the standard error. Therefore, the statistic will be positive
when the sample mean is greater than the population mean and negative when
the sample mean is less than the population mean.

Examples
--------
Suppose we wish to test the null hypothesis that the mean of a population
is equal to 0.5. We choose a confidence level of 99%; that is, we will
reject the null hypothesis in favor of the alternative if the p-value is
less than 0.01.

When testing random variates from the standard uniform distribution, which
has a mean of 0.5, we expect the data to be consistent with the null
hypothesis most of the time.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; rvs = stats.uniform.rvs(size=50, random_state=rng)
&gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5)
Ttest_1sampResult(statistic=2.456308468440, pvalue=0.017628209047638)

As expected, the p-value of 0.017 is not below our threshold of 0.01, so
we cannot reject the null hypothesis.

When testing data from the standard *normal* distribution, which has a mean
of 0, we would expect the null hypothesis to be rejected.

&gt;&gt;&gt; rvs = stats.norm.rvs(size=50, random_state=rng)
&gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5)
Ttest_1sampResult(statistic=-7.433605518875, pvalue=1.416760157221e-09)

Indeed, the p-value is lower than our threshold of 0.01, so we reject the
null hypothesis in favor of the default "two-sided" alternative: the mean
of the population is *not* equal to 0.5.

However, suppose we were to test the null hypothesis against the
one-sided alternative that the mean of the population is *greater* than
0.5. Since the mean of the standard normal is less than 0.5, we would not
expect the null hypothesis to be rejected.

&gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5, alternative='greater')
Ttest_1sampResult(statistic=-7.433605518875, pvalue=0.99999999929)

Unsurprisingly, with a p-value greater than our threshold, we would not
reject the null hypothesis.

Note that when working with a confidence level of 99%, a true null
hypothesis will be rejected approximately 1% of the time.

&gt;&gt;&gt; rvs = stats.uniform.rvs(size=(100, 50), random_state=rng)
&gt;&gt;&gt; res = stats.ttest_1samp(rvs, popmean=0.5, axis=1)
&gt;&gt;&gt; np.sum(res.pvalue &lt; 0.01)
1

Indeed, even though all 100 samples above were drawn from the standard
uniform distribution, which *does* have a population mean of 0.5, we would
mistakenly reject the null hypothesis for one of them.</pre> <div class="fragment"><div class="line"><span class="lineno"> 5958</span>                alternative=<span class="stringliteral">&quot;two-sided&quot;</span>):</div>
<div class="line"><span class="lineno"> 5959</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the T-test for the mean of ONE group of scores.</span></div>
<div class="line"><span class="lineno"> 5960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5961</span><span class="stringliteral">    This is a test for the null hypothesis that the expected value</span></div>
<div class="line"><span class="lineno"> 5962</span><span class="stringliteral">    (mean) of a sample of independent observations `a` is equal to the given</span></div>
<div class="line"><span class="lineno"> 5963</span><span class="stringliteral">    population mean, `popmean`.</span></div>
<div class="line"><span class="lineno"> 5964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5965</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5966</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5967</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 5968</span><span class="stringliteral">        Sample observation.</span></div>
<div class="line"><span class="lineno"> 5969</span><span class="stringliteral">    popmean : float or array_like</span></div>
<div class="line"><span class="lineno"> 5970</span><span class="stringliteral">        Expected value in null hypothesis. If array_like, then it must have the</span></div>
<div class="line"><span class="lineno"> 5971</span><span class="stringliteral">        same shape as `a` excluding the axis dimension.</span></div>
<div class="line"><span class="lineno"> 5972</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 5973</span><span class="stringliteral">        Axis along which to compute test; default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 5974</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 5975</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 5976</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 5977</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 5978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5979</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 5980</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 5981</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 5982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5983</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 5984</span><span class="stringliteral">        Defines the alternative hypothesis.</span></div>
<div class="line"><span class="lineno"> 5985</span><span class="stringliteral">        The following options are available (default is &#39;two-sided&#39;):</span></div>
<div class="line"><span class="lineno"> 5986</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5987</span><span class="stringliteral">        * &#39;two-sided&#39;: the mean of the underlying distribution of the sample</span></div>
<div class="line"><span class="lineno"> 5988</span><span class="stringliteral">          is different than the given population mean (`popmean`)</span></div>
<div class="line"><span class="lineno"> 5989</span><span class="stringliteral">        * &#39;less&#39;: the mean of the underlying distribution of the sample is</span></div>
<div class="line"><span class="lineno"> 5990</span><span class="stringliteral">          less than the given population mean (`popmean`)</span></div>
<div class="line"><span class="lineno"> 5991</span><span class="stringliteral">        * &#39;greater&#39;: the mean of the underlying distribution of the sample is</span></div>
<div class="line"><span class="lineno"> 5992</span><span class="stringliteral">          greater than the given population mean (`popmean`)</span></div>
<div class="line"><span class="lineno"> 5993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5994</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 5995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5996</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5997</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5998</span><span class="stringliteral">    statistic : float or array</span></div>
<div class="line"><span class="lineno"> 5999</span><span class="stringliteral">        t-statistic.</span></div>
<div class="line"><span class="lineno"> 6000</span><span class="stringliteral">    pvalue : float or array</span></div>
<div class="line"><span class="lineno"> 6001</span><span class="stringliteral">        Two-sided p-value.</span></div>
<div class="line"><span class="lineno"> 6002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6003</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 6004</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 6005</span><span class="stringliteral">    The statistic is calculated as ``(np.mean(a) - popmean)/se``, where</span></div>
<div class="line"><span class="lineno"> 6006</span><span class="stringliteral">    ``se`` is the standard error. Therefore, the statistic will be positive</span></div>
<div class="line"><span class="lineno"> 6007</span><span class="stringliteral">    when the sample mean is greater than the population mean and negative when</span></div>
<div class="line"><span class="lineno"> 6008</span><span class="stringliteral">    the sample mean is less than the population mean.</span></div>
<div class="line"><span class="lineno"> 6009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6010</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 6011</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 6012</span><span class="stringliteral">    Suppose we wish to test the null hypothesis that the mean of a population</span></div>
<div class="line"><span class="lineno"> 6013</span><span class="stringliteral">    is equal to 0.5. We choose a confidence level of 99%; that is, we will</span></div>
<div class="line"><span class="lineno"> 6014</span><span class="stringliteral">    reject the null hypothesis in favor of the alternative if the p-value is</span></div>
<div class="line"><span class="lineno"> 6015</span><span class="stringliteral">    less than 0.01.</span></div>
<div class="line"><span class="lineno"> 6016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6017</span><span class="stringliteral">    When testing random variates from the standard uniform distribution, which</span></div>
<div class="line"><span class="lineno"> 6018</span><span class="stringliteral">    has a mean of 0.5, we expect the data to be consistent with the null</span></div>
<div class="line"><span class="lineno"> 6019</span><span class="stringliteral">    hypothesis most of the time.</span></div>
<div class="line"><span class="lineno"> 6020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6021</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 6022</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 6023</span><span class="stringliteral">    &gt;&gt;&gt; rvs = stats.uniform.rvs(size=50, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6024</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5)</span></div>
<div class="line"><span class="lineno"> 6025</span><span class="stringliteral">    Ttest_1sampResult(statistic=2.456308468440, pvalue=0.017628209047638)</span></div>
<div class="line"><span class="lineno"> 6026</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6027</span><span class="stringliteral">    As expected, the p-value of 0.017 is not below our threshold of 0.01, so</span></div>
<div class="line"><span class="lineno"> 6028</span><span class="stringliteral">    we cannot reject the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 6029</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6030</span><span class="stringliteral">    When testing data from the standard *normal* distribution, which has a mean</span></div>
<div class="line"><span class="lineno"> 6031</span><span class="stringliteral">    of 0, we would expect the null hypothesis to be rejected.</span></div>
<div class="line"><span class="lineno"> 6032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6033</span><span class="stringliteral">    &gt;&gt;&gt; rvs = stats.norm.rvs(size=50, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6034</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5)</span></div>
<div class="line"><span class="lineno"> 6035</span><span class="stringliteral">    Ttest_1sampResult(statistic=-7.433605518875, pvalue=1.416760157221e-09)</span></div>
<div class="line"><span class="lineno"> 6036</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6037</span><span class="stringliteral">    Indeed, the p-value is lower than our threshold of 0.01, so we reject the</span></div>
<div class="line"><span class="lineno"> 6038</span><span class="stringliteral">    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the mean</span></div>
<div class="line"><span class="lineno"> 6039</span><span class="stringliteral">    of the population is *not* equal to 0.5.</span></div>
<div class="line"><span class="lineno"> 6040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6041</span><span class="stringliteral">    However, suppose we were to test the null hypothesis against the</span></div>
<div class="line"><span class="lineno"> 6042</span><span class="stringliteral">    one-sided alternative that the mean of the population is *greater* than</span></div>
<div class="line"><span class="lineno"> 6043</span><span class="stringliteral">    0.5. Since the mean of the standard normal is less than 0.5, we would not</span></div>
<div class="line"><span class="lineno"> 6044</span><span class="stringliteral">    expect the null hypothesis to be rejected.</span></div>
<div class="line"><span class="lineno"> 6045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6046</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5, alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 6047</span><span class="stringliteral">    Ttest_1sampResult(statistic=-7.433605518875, pvalue=0.99999999929)</span></div>
<div class="line"><span class="lineno"> 6048</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6049</span><span class="stringliteral">    Unsurprisingly, with a p-value greater than our threshold, we would not</span></div>
<div class="line"><span class="lineno"> 6050</span><span class="stringliteral">    reject the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 6051</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6052</span><span class="stringliteral">    Note that when working with a confidence level of 99%, a true null</span></div>
<div class="line"><span class="lineno"> 6053</span><span class="stringliteral">    hypothesis will be rejected approximately 1% of the time.</span></div>
<div class="line"><span class="lineno"> 6054</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6055</span><span class="stringliteral">    &gt;&gt;&gt; rvs = stats.uniform.rvs(size=(100, 50), random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6056</span><span class="stringliteral">    &gt;&gt;&gt; res = stats.ttest_1samp(rvs, popmean=0.5, axis=1)</span></div>
<div class="line"><span class="lineno"> 6057</span><span class="stringliteral">    &gt;&gt;&gt; np.sum(res.pvalue &lt; 0.01)</span></div>
<div class="line"><span class="lineno"> 6058</span><span class="stringliteral">    1</span></div>
<div class="line"><span class="lineno"> 6059</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6060</span><span class="stringliteral">    Indeed, even though all 100 samples above were drawn from the standard</span></div>
<div class="line"><span class="lineno"> 6061</span><span class="stringliteral">    uniform distribution, which *does* have a population mean of 0.5, we would</span></div>
<div class="line"><span class="lineno"> 6062</span><span class="stringliteral">    mistakenly reject the null hypothesis for one of them.</span></div>
<div class="line"><span class="lineno"> 6063</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6064</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6065</span>    a, axis = _chk_asarray(a, axis)</div>
<div class="line"><span class="lineno"> 6066</span> </div>
<div class="line"><span class="lineno"> 6067</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 6068</span> </div>
<div class="line"><span class="lineno"> 6069</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 6070</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 6071</span>        <span class="keywordflow">return</span> mstats_basic.ttest_1samp(a, popmean, axis, alternative)</div>
<div class="line"><span class="lineno"> 6072</span> </div>
<div class="line"><span class="lineno"> 6073</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6074</span>    df = n - 1</div>
<div class="line"><span class="lineno"> 6075</span> </div>
<div class="line"><span class="lineno"> 6076</span>    d = np.mean(a, axis) - popmean</div>
<div class="line"><span class="lineno"> 6077</span>    v = _var(a, axis, ddof=1)</div>
<div class="line"><span class="lineno"> 6078</span>    denom = np.sqrt(v / n)</div>
<div class="line"><span class="lineno"> 6079</span> </div>
<div class="line"><span class="lineno"> 6080</span>    <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>, invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 6081</span>        t = np.divide(d, denom)</div>
<div class="line"><span class="lineno"> 6082</span>    t, prob = _ttest_finish(df, t, alternative)</div>
<div class="line"><span class="lineno"> 6083</span> </div>
<div class="line"><span class="lineno"> 6084</span>    <span class="keywordflow">return</span> Ttest_1sampResult(t, prob)</div>
<div class="line"><span class="lineno"> 6085</span> </div>
<div class="line"><span class="lineno"> 6086</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1021af752b49ceb9383493994d38eaef" name="a1021af752b49ceb9383493994d38eaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1021af752b49ceb9383493994d38eaef">&#9670;&#160;</a></span>ttest_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ttest_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_var</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permutations</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the T-test for the means of *two independent* samples of scores.

This is a test for the null hypothesis that 2 independent samples
have identical average (expected) values. This test assumes that the
populations have identical variances by default.

Parameters
----------
a, b : array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    arrays, `a`, and `b`.
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.

    .. versionadded:: 0.11.0

nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values

    The 'omit' option is not currently available for permutation tests or
    one-sided asympyotic tests.

permutations : non-negative int, np.inf, or None (default), optional
    If 0 or None (default), use the t-distribution to calculate p-values.
    Otherwise, `permutations` is  the number of random permutations that
    will be used to estimate p-values using a permutation test. If
    `permutations` equals or exceeds the number of distinct partitions of
    the pooled data, an exact test is performed instead (i.e. each
    distinct partition is used exactly once). See Notes for details.

    .. versionadded:: 1.7.0

random_state : {None, int, `numpy.random.Generator`,
        `numpy.random.RandomState`}, optional

    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.

    Pseudorandom number generator state used to generate permutations
    (used only when `permutations` is not None).

    .. versionadded:: 1.7.0

alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the means of the distributions underlying the samples
      are unequal.
    * 'less': the mean of the distribution underlying the first sample
      is less than the mean of the distribution underlying the second
      sample.
    * 'greater': the mean of the distribution underlying the first
      sample is greater than the mean of the distribution underlying
      the second sample.

    .. versionadded:: 1.6.0

trim : float, optional
    If nonzero, performs a trimmed (Yuen's) t-test.
    Defines the fraction of elements to be trimmed from each end of the
    input samples. If 0 (default), no elements will be trimmed from either
    side. The number of trimmed elements from each tail is the floor of the
    trim times the number of elements. Valid range is [0, .5).

    .. versionadded:: 1.7

Returns
-------
statistic : float or array
    The calculated t-statistic.
pvalue : float or array
    The p-value.

Notes
-----
Suppose we observe two independent samples, e.g. flower petal lengths, and
we are considering whether the two samples were drawn from the same
population (e.g. the same species of flower or two species with similar
petal characteristics) or two different populations.

The t-test quantifies the difference between the arithmetic means
of the two samples. The p-value quantifies the probability of observing
as or more extreme values assuming the null hypothesis, that the
samples are drawn from populations with the same population means, is true.
A p-value larger than a chosen threshold (e.g. 5% or 1%) indicates that
our observation is not so unlikely to have occurred by chance. Therefore,
we do not reject the null hypothesis of equal population means.
If the p-value is smaller than our threshold, then we have evidence
against the null hypothesis of equal population means.

By default, the p-value is determined by comparing the t-statistic of the
observed data against a theoretical t-distribution.
When ``1 &lt; permutations &lt; binom(n, k)``, where

* ``k`` is the number of observations in `a`,
* ``n`` is the total number of observations in `a` and `b`, and
* ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``),

the data are pooled (concatenated), randomly assigned to either group `a`
or `b`, and the t-statistic is calculated. This process is performed
repeatedly (`permutation` times), generating a distribution of the
t-statistic under the null hypothesis, and the t-statistic of the observed
data is compared to this distribution to determine the p-value.
Specifically, the p-value reported is the "achieved significance level"
(ASL) as defined in 4.4 of [3]_. Note that there are other ways of
estimating p-values using randomized permutation tests; for other
options, see the more general `permutation_test`.

When ``permutations &gt;= binom(n, k)``, an exact test is performed: the data
are partitioned between the groups in each distinct way exactly once.

The permutation test can be computationally expensive and not necessarily
more accurate than the analytical test, but it does not make strong
assumptions about the shape of the underlying distribution.

Use of trimming is commonly referred to as the trimmed t-test. At times
called Yuen's t-test, this is an extension of Welch's t-test, with the
difference being the use of winsorized means in calculation of the variance
and the trimmed sample size in calculation of the statistic. Trimming is
recommended if the underlying distribution is long-tailed or contaminated
with outliers [4]_.

The statistic is calculated as ``(np.mean(a) - np.mean(b))/se``, where
``se`` is the standard error. Therefore, the statistic will be positive
when the sample mean of `a` is greater than the sample mean of `b` and
negative when the sample mean of `a` is less than the sample mean of
`b`.

References
----------
.. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test

.. [3] B. Efron and T. Hastie. Computer Age Statistical Inference. (2016).

.. [4] Yuen, Karen K. "The Two-Sample Trimmed t for Unequal Population
       Variances." Biometrika, vol. 61, no. 1, 1974, pp. 165-170. JSTOR,
       www.jstor.org/stable/2334299. Accessed 30 Mar. 2021.

.. [5] Yuen, Karen K., and W. J. Dixon. "The Approximate Behaviour and
       Performance of the Two-Sample Trimmed t." Biometrika, vol. 60,
       no. 2, 1973, pp. 369-374. JSTOR, www.jstor.org/stable/2334550.
       Accessed 30 Mar. 2021.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()

Test with sample with identical means:

&gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
&gt;&gt;&gt; rvs2 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs2)
Ttest_indResult(statistic=-0.4390847099199348, pvalue=0.6606952038870015)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs2, equal_var=False)
Ttest_indResult(statistic=-0.4390847099199348, pvalue=0.6606952553131064)

`ttest_ind` underestimates p for unequal variances:

&gt;&gt;&gt; rvs3 = stats.norm.rvs(loc=5, scale=20, size=500, random_state=rng)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3)
Ttest_indResult(statistic=-1.6370984482905417, pvalue=0.1019251574705033)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3, equal_var=False)
Ttest_indResult(statistic=-1.637098448290542, pvalue=0.10202110497954867)

When ``n1 != n2``, the equal variance t-statistic is no longer equal to the
unequal variance t-statistic:

&gt;&gt;&gt; rvs4 = stats.norm.rvs(loc=5, scale=20, size=100, random_state=rng)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4)
Ttest_indResult(statistic=-1.9481646859513422, pvalue=0.05186270935842703)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4, equal_var=False)
Ttest_indResult(statistic=-1.3146566100751664, pvalue=0.1913495266513811)

T-test with different means, variance, and n:

&gt;&gt;&gt; rvs5 = stats.norm.rvs(loc=8, scale=20, size=100, random_state=rng)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5)
Ttest_indResult(statistic=-2.8415950600298774, pvalue=0.0046418707568707885)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, equal_var=False)
Ttest_indResult(statistic=-1.8686598649188084, pvalue=0.06434714193919686)

When performing a permutation test, more permutations typically yields
more accurate results. Use a ``np.random.Generator`` to ensure
reproducibility:

&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, permutations=10000,
...                 random_state=rng)
Ttest_indResult(statistic=-2.8415950600298774, pvalue=0.0052994700529947)

Take these two samples, one of which has an extreme tail.

&gt;&gt;&gt; a = (56, 128.6, 12, 123.8, 64.34, 78, 763.3)
&gt;&gt;&gt; b = (1.1, 2.9, 4.2)

Use the `trim` keyword to perform a trimmed (Yuen) t-test. For example,
using 20% trimming, ``trim=.2``, the test will reduce the impact of one
(``np.floor(trim*len(a))``) element from each tail of sample `a`. It will
have no effect on sample `b` because ``np.floor(trim*len(b))`` is 0.

&gt;&gt;&gt; stats.ttest_ind(a, b, trim=.2)
Ttest_indResult(statistic=3.4463884028073513,
                pvalue=0.01369338726499547)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6319</span>              trim=0):</div>
<div class="line"><span class="lineno"> 6320</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6321</span><span class="stringliteral">    Calculate the T-test for the means of *two independent* samples of scores.</span></div>
<div class="line"><span class="lineno"> 6322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6323</span><span class="stringliteral">    This is a test for the null hypothesis that 2 independent samples</span></div>
<div class="line"><span class="lineno"> 6324</span><span class="stringliteral">    have identical average (expected) values. This test assumes that the</span></div>
<div class="line"><span class="lineno"> 6325</span><span class="stringliteral">    populations have identical variances by default.</span></div>
<div class="line"><span class="lineno"> 6326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6327</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 6328</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6329</span><span class="stringliteral">    a, b : array_like</span></div>
<div class="line"><span class="lineno"> 6330</span><span class="stringliteral">        The arrays must have the same shape, except in the dimension</span></div>
<div class="line"><span class="lineno"> 6331</span><span class="stringliteral">        corresponding to `axis` (the first, by default).</span></div>
<div class="line"><span class="lineno"> 6332</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 6333</span><span class="stringliteral">        Axis along which to compute test. If None, compute over the whole</span></div>
<div class="line"><span class="lineno"> 6334</span><span class="stringliteral">        arrays, `a`, and `b`.</span></div>
<div class="line"><span class="lineno"> 6335</span><span class="stringliteral">    equal_var : bool, optional</span></div>
<div class="line"><span class="lineno"> 6336</span><span class="stringliteral">        If True (default), perform a standard independent 2 sample test</span></div>
<div class="line"><span class="lineno"> 6337</span><span class="stringliteral">        that assumes equal population variances [1]_.</span></div>
<div class="line"><span class="lineno"> 6338</span><span class="stringliteral">        If False, perform Welch&#39;s t-test, which does not assume equal</span></div>
<div class="line"><span class="lineno"> 6339</span><span class="stringliteral">        population variance [2]_.</span></div>
<div class="line"><span class="lineno"> 6340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6341</span><span class="stringliteral">        .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno"> 6342</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6343</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 6344</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 6345</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 6346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6347</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 6348</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 6349</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 6350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6351</span><span class="stringliteral">        The &#39;omit&#39; option is not currently available for permutation tests or</span></div>
<div class="line"><span class="lineno"> 6352</span><span class="stringliteral">        one-sided asympyotic tests.</span></div>
<div class="line"><span class="lineno"> 6353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6354</span><span class="stringliteral">    permutations : non-negative int, np.inf, or None (default), optional</span></div>
<div class="line"><span class="lineno"> 6355</span><span class="stringliteral">        If 0 or None (default), use the t-distribution to calculate p-values.</span></div>
<div class="line"><span class="lineno"> 6356</span><span class="stringliteral">        Otherwise, `permutations` is  the number of random permutations that</span></div>
<div class="line"><span class="lineno"> 6357</span><span class="stringliteral">        will be used to estimate p-values using a permutation test. If</span></div>
<div class="line"><span class="lineno"> 6358</span><span class="stringliteral">        `permutations` equals or exceeds the number of distinct partitions of</span></div>
<div class="line"><span class="lineno"> 6359</span><span class="stringliteral">        the pooled data, an exact test is performed instead (i.e. each</span></div>
<div class="line"><span class="lineno"> 6360</span><span class="stringliteral">        distinct partition is used exactly once). See Notes for details.</span></div>
<div class="line"><span class="lineno"> 6361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6362</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 6363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6364</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno"> 6365</span><span class="stringliteral">            `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno"> 6366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6367</span><span class="stringliteral">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno"> 6368</span><span class="stringliteral">        singleton is used.</span></div>
<div class="line"><span class="lineno"> 6369</span><span class="stringliteral">        If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno"> 6370</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno"> 6371</span><span class="stringliteral">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno"> 6372</span><span class="stringliteral">        that instance is used.</span></div>
<div class="line"><span class="lineno"> 6373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6374</span><span class="stringliteral">        Pseudorandom number generator state used to generate permutations</span></div>
<div class="line"><span class="lineno"> 6375</span><span class="stringliteral">        (used only when `permutations` is not None).</span></div>
<div class="line"><span class="lineno"> 6376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6377</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 6378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6379</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 6380</span><span class="stringliteral">        Defines the alternative hypothesis.</span></div>
<div class="line"><span class="lineno"> 6381</span><span class="stringliteral">        The following options are available (default is &#39;two-sided&#39;):</span></div>
<div class="line"><span class="lineno"> 6382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6383</span><span class="stringliteral">        * &#39;two-sided&#39;: the means of the distributions underlying the samples</span></div>
<div class="line"><span class="lineno"> 6384</span><span class="stringliteral">          are unequal.</span></div>
<div class="line"><span class="lineno"> 6385</span><span class="stringliteral">        * &#39;less&#39;: the mean of the distribution underlying the first sample</span></div>
<div class="line"><span class="lineno"> 6386</span><span class="stringliteral">          is less than the mean of the distribution underlying the second</span></div>
<div class="line"><span class="lineno"> 6387</span><span class="stringliteral">          sample.</span></div>
<div class="line"><span class="lineno"> 6388</span><span class="stringliteral">        * &#39;greater&#39;: the mean of the distribution underlying the first</span></div>
<div class="line"><span class="lineno"> 6389</span><span class="stringliteral">          sample is greater than the mean of the distribution underlying</span></div>
<div class="line"><span class="lineno"> 6390</span><span class="stringliteral">          the second sample.</span></div>
<div class="line"><span class="lineno"> 6391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6392</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 6393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6394</span><span class="stringliteral">    trim : float, optional</span></div>
<div class="line"><span class="lineno"> 6395</span><span class="stringliteral">        If nonzero, performs a trimmed (Yuen&#39;s) t-test.</span></div>
<div class="line"><span class="lineno"> 6396</span><span class="stringliteral">        Defines the fraction of elements to be trimmed from each end of the</span></div>
<div class="line"><span class="lineno"> 6397</span><span class="stringliteral">        input samples. If 0 (default), no elements will be trimmed from either</span></div>
<div class="line"><span class="lineno"> 6398</span><span class="stringliteral">        side. The number of trimmed elements from each tail is the floor of the</span></div>
<div class="line"><span class="lineno"> 6399</span><span class="stringliteral">        trim times the number of elements. Valid range is [0, .5).</span></div>
<div class="line"><span class="lineno"> 6400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6401</span><span class="stringliteral">        .. versionadded:: 1.7</span></div>
<div class="line"><span class="lineno"> 6402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6403</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 6404</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 6405</span><span class="stringliteral">    statistic : float or array</span></div>
<div class="line"><span class="lineno"> 6406</span><span class="stringliteral">        The calculated t-statistic.</span></div>
<div class="line"><span class="lineno"> 6407</span><span class="stringliteral">    pvalue : float or array</span></div>
<div class="line"><span class="lineno"> 6408</span><span class="stringliteral">        The p-value.</span></div>
<div class="line"><span class="lineno"> 6409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6410</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 6411</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 6412</span><span class="stringliteral">    Suppose we observe two independent samples, e.g. flower petal lengths, and</span></div>
<div class="line"><span class="lineno"> 6413</span><span class="stringliteral">    we are considering whether the two samples were drawn from the same</span></div>
<div class="line"><span class="lineno"> 6414</span><span class="stringliteral">    population (e.g. the same species of flower or two species with similar</span></div>
<div class="line"><span class="lineno"> 6415</span><span class="stringliteral">    petal characteristics) or two different populations.</span></div>
<div class="line"><span class="lineno"> 6416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6417</span><span class="stringliteral">    The t-test quantifies the difference between the arithmetic means</span></div>
<div class="line"><span class="lineno"> 6418</span><span class="stringliteral">    of the two samples. The p-value quantifies the probability of observing</span></div>
<div class="line"><span class="lineno"> 6419</span><span class="stringliteral">    as or more extreme values assuming the null hypothesis, that the</span></div>
<div class="line"><span class="lineno"> 6420</span><span class="stringliteral">    samples are drawn from populations with the same population means, is true.</span></div>
<div class="line"><span class="lineno"> 6421</span><span class="stringliteral">    A p-value larger than a chosen threshold (e.g. 5% or 1%) indicates that</span></div>
<div class="line"><span class="lineno"> 6422</span><span class="stringliteral">    our observation is not so unlikely to have occurred by chance. Therefore,</span></div>
<div class="line"><span class="lineno"> 6423</span><span class="stringliteral">    we do not reject the null hypothesis of equal population means.</span></div>
<div class="line"><span class="lineno"> 6424</span><span class="stringliteral">    If the p-value is smaller than our threshold, then we have evidence</span></div>
<div class="line"><span class="lineno"> 6425</span><span class="stringliteral">    against the null hypothesis of equal population means.</span></div>
<div class="line"><span class="lineno"> 6426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6427</span><span class="stringliteral">    By default, the p-value is determined by comparing the t-statistic of the</span></div>
<div class="line"><span class="lineno"> 6428</span><span class="stringliteral">    observed data against a theoretical t-distribution.</span></div>
<div class="line"><span class="lineno"> 6429</span><span class="stringliteral">    When ``1 &lt; permutations &lt; binom(n, k)``, where</span></div>
<div class="line"><span class="lineno"> 6430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6431</span><span class="stringliteral">    * ``k`` is the number of observations in `a`,</span></div>
<div class="line"><span class="lineno"> 6432</span><span class="stringliteral">    * ``n`` is the total number of observations in `a` and `b`, and</span></div>
<div class="line"><span class="lineno"> 6433</span><span class="stringliteral">    * ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``),</span></div>
<div class="line"><span class="lineno"> 6434</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6435</span><span class="stringliteral">    the data are pooled (concatenated), randomly assigned to either group `a`</span></div>
<div class="line"><span class="lineno"> 6436</span><span class="stringliteral">    or `b`, and the t-statistic is calculated. This process is performed</span></div>
<div class="line"><span class="lineno"> 6437</span><span class="stringliteral">    repeatedly (`permutation` times), generating a distribution of the</span></div>
<div class="line"><span class="lineno"> 6438</span><span class="stringliteral">    t-statistic under the null hypothesis, and the t-statistic of the observed</span></div>
<div class="line"><span class="lineno"> 6439</span><span class="stringliteral">    data is compared to this distribution to determine the p-value.</span></div>
<div class="line"><span class="lineno"> 6440</span><span class="stringliteral">    Specifically, the p-value reported is the &quot;achieved significance level&quot;</span></div>
<div class="line"><span class="lineno"> 6441</span><span class="stringliteral">    (ASL) as defined in 4.4 of [3]_. Note that there are other ways of</span></div>
<div class="line"><span class="lineno"> 6442</span><span class="stringliteral">    estimating p-values using randomized permutation tests; for other</span></div>
<div class="line"><span class="lineno"> 6443</span><span class="stringliteral">    options, see the more general `permutation_test`.</span></div>
<div class="line"><span class="lineno"> 6444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6445</span><span class="stringliteral">    When ``permutations &gt;= binom(n, k)``, an exact test is performed: the data</span></div>
<div class="line"><span class="lineno"> 6446</span><span class="stringliteral">    are partitioned between the groups in each distinct way exactly once.</span></div>
<div class="line"><span class="lineno"> 6447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6448</span><span class="stringliteral">    The permutation test can be computationally expensive and not necessarily</span></div>
<div class="line"><span class="lineno"> 6449</span><span class="stringliteral">    more accurate than the analytical test, but it does not make strong</span></div>
<div class="line"><span class="lineno"> 6450</span><span class="stringliteral">    assumptions about the shape of the underlying distribution.</span></div>
<div class="line"><span class="lineno"> 6451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6452</span><span class="stringliteral">    Use of trimming is commonly referred to as the trimmed t-test. At times</span></div>
<div class="line"><span class="lineno"> 6453</span><span class="stringliteral">    called Yuen&#39;s t-test, this is an extension of Welch&#39;s t-test, with the</span></div>
<div class="line"><span class="lineno"> 6454</span><span class="stringliteral">    difference being the use of winsorized means in calculation of the variance</span></div>
<div class="line"><span class="lineno"> 6455</span><span class="stringliteral">    and the trimmed sample size in calculation of the statistic. Trimming is</span></div>
<div class="line"><span class="lineno"> 6456</span><span class="stringliteral">    recommended if the underlying distribution is long-tailed or contaminated</span></div>
<div class="line"><span class="lineno"> 6457</span><span class="stringliteral">    with outliers [4]_.</span></div>
<div class="line"><span class="lineno"> 6458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6459</span><span class="stringliteral">    The statistic is calculated as ``(np.mean(a) - np.mean(b))/se``, where</span></div>
<div class="line"><span class="lineno"> 6460</span><span class="stringliteral">    ``se`` is the standard error. Therefore, the statistic will be positive</span></div>
<div class="line"><span class="lineno"> 6461</span><span class="stringliteral">    when the sample mean of `a` is greater than the sample mean of `b` and</span></div>
<div class="line"><span class="lineno"> 6462</span><span class="stringliteral">    negative when the sample mean of `a` is less than the sample mean of</span></div>
<div class="line"><span class="lineno"> 6463</span><span class="stringliteral">    `b`.</span></div>
<div class="line"><span class="lineno"> 6464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6465</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 6466</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6467</span><span class="stringliteral">    .. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test</span></div>
<div class="line"><span class="lineno"> 6468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6469</span><span class="stringliteral">    .. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test</span></div>
<div class="line"><span class="lineno"> 6470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6471</span><span class="stringliteral">    .. [3] B. Efron and T. Hastie. Computer Age Statistical Inference. (2016).</span></div>
<div class="line"><span class="lineno"> 6472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6473</span><span class="stringliteral">    .. [4] Yuen, Karen K. &quot;The Two-Sample Trimmed t for Unequal Population</span></div>
<div class="line"><span class="lineno"> 6474</span><span class="stringliteral">           Variances.&quot; Biometrika, vol. 61, no. 1, 1974, pp. 165-170. JSTOR,</span></div>
<div class="line"><span class="lineno"> 6475</span><span class="stringliteral">           www.jstor.org/stable/2334299. Accessed 30 Mar. 2021.</span></div>
<div class="line"><span class="lineno"> 6476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6477</span><span class="stringliteral">    .. [5] Yuen, Karen K., and W. J. Dixon. &quot;The Approximate Behaviour and</span></div>
<div class="line"><span class="lineno"> 6478</span><span class="stringliteral">           Performance of the Two-Sample Trimmed t.&quot; Biometrika, vol. 60,</span></div>
<div class="line"><span class="lineno"> 6479</span><span class="stringliteral">           no. 2, 1973, pp. 369-374. JSTOR, www.jstor.org/stable/2334550.</span></div>
<div class="line"><span class="lineno"> 6480</span><span class="stringliteral">           Accessed 30 Mar. 2021.</span></div>
<div class="line"><span class="lineno"> 6481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6482</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 6483</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 6484</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 6485</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 6486</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6487</span><span class="stringliteral">    Test with sample with identical means:</span></div>
<div class="line"><span class="lineno"> 6488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6489</span><span class="stringliteral">    &gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6490</span><span class="stringliteral">    &gt;&gt;&gt; rvs2 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6491</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs2)</span></div>
<div class="line"><span class="lineno"> 6492</span><span class="stringliteral">    Ttest_indResult(statistic=-0.4390847099199348, pvalue=0.6606952038870015)</span></div>
<div class="line"><span class="lineno"> 6493</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs2, equal_var=False)</span></div>
<div class="line"><span class="lineno"> 6494</span><span class="stringliteral">    Ttest_indResult(statistic=-0.4390847099199348, pvalue=0.6606952553131064)</span></div>
<div class="line"><span class="lineno"> 6495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6496</span><span class="stringliteral">    `ttest_ind` underestimates p for unequal variances:</span></div>
<div class="line"><span class="lineno"> 6497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6498</span><span class="stringliteral">    &gt;&gt;&gt; rvs3 = stats.norm.rvs(loc=5, scale=20, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6499</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3)</span></div>
<div class="line"><span class="lineno"> 6500</span><span class="stringliteral">    Ttest_indResult(statistic=-1.6370984482905417, pvalue=0.1019251574705033)</span></div>
<div class="line"><span class="lineno"> 6501</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3, equal_var=False)</span></div>
<div class="line"><span class="lineno"> 6502</span><span class="stringliteral">    Ttest_indResult(statistic=-1.637098448290542, pvalue=0.10202110497954867)</span></div>
<div class="line"><span class="lineno"> 6503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6504</span><span class="stringliteral">    When ``n1 != n2``, the equal variance t-statistic is no longer equal to the</span></div>
<div class="line"><span class="lineno"> 6505</span><span class="stringliteral">    unequal variance t-statistic:</span></div>
<div class="line"><span class="lineno"> 6506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6507</span><span class="stringliteral">    &gt;&gt;&gt; rvs4 = stats.norm.rvs(loc=5, scale=20, size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6508</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4)</span></div>
<div class="line"><span class="lineno"> 6509</span><span class="stringliteral">    Ttest_indResult(statistic=-1.9481646859513422, pvalue=0.05186270935842703)</span></div>
<div class="line"><span class="lineno"> 6510</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4, equal_var=False)</span></div>
<div class="line"><span class="lineno"> 6511</span><span class="stringliteral">    Ttest_indResult(statistic=-1.3146566100751664, pvalue=0.1913495266513811)</span></div>
<div class="line"><span class="lineno"> 6512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6513</span><span class="stringliteral">    T-test with different means, variance, and n:</span></div>
<div class="line"><span class="lineno"> 6514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6515</span><span class="stringliteral">    &gt;&gt;&gt; rvs5 = stats.norm.rvs(loc=8, scale=20, size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6516</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5)</span></div>
<div class="line"><span class="lineno"> 6517</span><span class="stringliteral">    Ttest_indResult(statistic=-2.8415950600298774, pvalue=0.0046418707568707885)</span></div>
<div class="line"><span class="lineno"> 6518</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, equal_var=False)</span></div>
<div class="line"><span class="lineno"> 6519</span><span class="stringliteral">    Ttest_indResult(statistic=-1.8686598649188084, pvalue=0.06434714193919686)</span></div>
<div class="line"><span class="lineno"> 6520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6521</span><span class="stringliteral">    When performing a permutation test, more permutations typically yields</span></div>
<div class="line"><span class="lineno"> 6522</span><span class="stringliteral">    more accurate results. Use a ``np.random.Generator`` to ensure</span></div>
<div class="line"><span class="lineno"> 6523</span><span class="stringliteral">    reproducibility:</span></div>
<div class="line"><span class="lineno"> 6524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6525</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, permutations=10000,</span></div>
<div class="line"><span class="lineno"> 6526</span><span class="stringliteral">    ...                 random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6527</span><span class="stringliteral">    Ttest_indResult(statistic=-2.8415950600298774, pvalue=0.0052994700529947)</span></div>
<div class="line"><span class="lineno"> 6528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6529</span><span class="stringliteral">    Take these two samples, one of which has an extreme tail.</span></div>
<div class="line"><span class="lineno"> 6530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6531</span><span class="stringliteral">    &gt;&gt;&gt; a = (56, 128.6, 12, 123.8, 64.34, 78, 763.3)</span></div>
<div class="line"><span class="lineno"> 6532</span><span class="stringliteral">    &gt;&gt;&gt; b = (1.1, 2.9, 4.2)</span></div>
<div class="line"><span class="lineno"> 6533</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6534</span><span class="stringliteral">    Use the `trim` keyword to perform a trimmed (Yuen) t-test. For example,</span></div>
<div class="line"><span class="lineno"> 6535</span><span class="stringliteral">    using 20% trimming, ``trim=.2``, the test will reduce the impact of one</span></div>
<div class="line"><span class="lineno"> 6536</span><span class="stringliteral">    (``np.floor(trim*len(a))``) element from each tail of sample `a`. It will</span></div>
<div class="line"><span class="lineno"> 6537</span><span class="stringliteral">    have no effect on sample `b` because ``np.floor(trim*len(b))`` is 0.</span></div>
<div class="line"><span class="lineno"> 6538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6539</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_ind(a, b, trim=.2)</span></div>
<div class="line"><span class="lineno"> 6540</span><span class="stringliteral">    Ttest_indResult(statistic=3.4463884028073513,</span></div>
<div class="line"><span class="lineno"> 6541</span><span class="stringliteral">                    pvalue=0.01369338726499547)</span></div>
<div class="line"><span class="lineno"> 6542</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6543</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (0 &lt;= trim &lt; .5):</div>
<div class="line"><span class="lineno"> 6544</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Trimming percentage should be 0 &lt;= `trim` &lt; .5.&quot;</span>)</div>
<div class="line"><span class="lineno"> 6545</span> </div>
<div class="line"><span class="lineno"> 6546</span>    a, b, axis = _chk2_asarray(a, b, axis)</div>
<div class="line"><span class="lineno"> 6547</span> </div>
<div class="line"><span class="lineno"> 6548</span>    <span class="comment"># check both a and b</span></div>
<div class="line"><span class="lineno"> 6549</span>    cna, npa = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 6550</span>    cnb, npb = _contains_nan(b, nan_policy)</div>
<div class="line"><span class="lineno"> 6551</span>    contains_nan = cna <span class="keywordflow">or</span> cnb</div>
<div class="line"><span class="lineno"> 6552</span>    <span class="keywordflow">if</span> npa == <span class="stringliteral">&#39;omit&#39;</span> <span class="keywordflow">or</span> npb == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 6553</span>        nan_policy = <span class="stringliteral">&#39;omit&#39;</span></div>
<div class="line"><span class="lineno"> 6554</span> </div>
<div class="line"><span class="lineno"> 6555</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 6556</span>        <span class="keywordflow">if</span> permutations <span class="keywordflow">or</span> trim != 0:</div>
<div class="line"><span class="lineno"> 6557</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;nan-containing/masked inputs with &quot;</span></div>
<div class="line"><span class="lineno"> 6558</span>                             <span class="stringliteral">&quot;nan_policy=&#39;omit&#39; are currently not &quot;</span></div>
<div class="line"><span class="lineno"> 6559</span>                             <span class="stringliteral">&quot;supported by permutation tests or &quot;</span></div>
<div class="line"><span class="lineno"> 6560</span>                             <span class="stringliteral">&quot;trimmed tests.&quot;</span>)</div>
<div class="line"><span class="lineno"> 6561</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 6562</span>        b = ma.masked_invalid(b)</div>
<div class="line"><span class="lineno"> 6563</span>        <span class="keywordflow">return</span> mstats_basic.ttest_ind(a, b, axis, equal_var, alternative)</div>
<div class="line"><span class="lineno"> 6564</span> </div>
<div class="line"><span class="lineno"> 6565</span>    <span class="keywordflow">if</span> a.size == 0 <span class="keywordflow">or</span> b.size == 0:</div>
<div class="line"><span class="lineno"> 6566</span>        <span class="keywordflow">return</span> _ttest_nans(a, b, axis, Ttest_indResult)</div>
<div class="line"><span class="lineno"> 6567</span> </div>
<div class="line"><span class="lineno"> 6568</span>    <span class="keywordflow">if</span> permutations <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> permutations != 0:</div>
<div class="line"><span class="lineno"> 6569</span>        <span class="keywordflow">if</span> trim != 0:</div>
<div class="line"><span class="lineno"> 6570</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Permutations are currently not supported &quot;</span></div>
<div class="line"><span class="lineno"> 6571</span>                             <span class="stringliteral">&quot;with trimming.&quot;</span>)</div>
<div class="line"><span class="lineno"> 6572</span>        <span class="keywordflow">if</span> permutations &lt; 0 <span class="keywordflow">or</span> (np.isfinite(permutations) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno"> 6573</span>                                int(permutations) != permutations):</div>
<div class="line"><span class="lineno"> 6574</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Permutations must be a non-negative integer.&quot;</span>)</div>
<div class="line"><span class="lineno"> 6575</span> </div>
<div class="line"><span class="lineno"> 6576</span>        res = _permutation_ttest(a, b, permutations=permutations,</div>
<div class="line"><span class="lineno"> 6577</span>                                 axis=axis, equal_var=equal_var,</div>
<div class="line"><span class="lineno"> 6578</span>                                 nan_policy=nan_policy,</div>
<div class="line"><span class="lineno"> 6579</span>                                 random_state=random_state,</div>
<div class="line"><span class="lineno"> 6580</span>                                 alternative=alternative)</div>
<div class="line"><span class="lineno"> 6581</span> </div>
<div class="line"><span class="lineno"> 6582</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6583</span>        n1 = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6584</span>        n2 = b.shape[axis]</div>
<div class="line"><span class="lineno"> 6585</span> </div>
<div class="line"><span class="lineno"> 6586</span>        <span class="keywordflow">if</span> trim == 0:</div>
<div class="line"><span class="lineno"> 6587</span>            v1 = _var(a, axis, ddof=1)</div>
<div class="line"><span class="lineno"> 6588</span>            v2 = _var(b, axis, ddof=1)</div>
<div class="line"><span class="lineno"> 6589</span>            m1 = np.mean(a, axis)</div>
<div class="line"><span class="lineno"> 6590</span>            m2 = np.mean(b, axis)</div>
<div class="line"><span class="lineno"> 6591</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6592</span>            v1, m1, n1 = _ttest_trim_var_mean_len(a, trim, axis)</div>
<div class="line"><span class="lineno"> 6593</span>            v2, m2, n2 = _ttest_trim_var_mean_len(b, trim, axis)</div>
<div class="line"><span class="lineno"> 6594</span> </div>
<div class="line"><span class="lineno"> 6595</span>        <span class="keywordflow">if</span> equal_var:</div>
<div class="line"><span class="lineno"> 6596</span>            df, denom = _equal_var_ttest_denom(v1, n1, v2, n2)</div>
<div class="line"><span class="lineno"> 6597</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6598</span>            df, denom = _unequal_var_ttest_denom(v1, n1, v2, n2)</div>
<div class="line"><span class="lineno"> 6599</span>        res = _ttest_ind_from_stats(m1, m2, denom, df, alternative)</div>
<div class="line"><span class="lineno"> 6600</span>    <span class="keywordflow">return</span> Ttest_indResult(*res)</div>
<div class="line"><span class="lineno"> 6601</span> </div>
<div class="line"><span class="lineno"> 6602</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b98b9c4e131fb2b6d72da0ec90092f9" name="a3b98b9c4e131fb2b6d72da0ec90092f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b98b9c4e131fb2b6d72da0ec90092f9">&#9670;&#160;</a></span>ttest_ind_from_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ttest_ind_from_stats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>std1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nobs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>std2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nobs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_var</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">T-test for means of two independent samples from descriptive statistics.

This is a test for the null hypothesis that two independent
samples have identical average (expected) values.

Parameters
----------
mean1 : array_like
    The mean(s) of sample 1.
std1 : array_like
    The corrected sample standard deviation of sample 1 (i.e. ``ddof=1``).
nobs1 : array_like
    The number(s) of observations of sample 1.
mean2 : array_like
    The mean(s) of sample 2.
std2 : array_like
    The corrected sample standard deviation of sample 2 (i.e. ``ddof=1``).
nobs2 : array_like
    The number(s) of observations of sample 2.
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the means of the distributions are unequal.
    * 'less': the mean of the first distribution is less than the
      mean of the second distribution.
    * 'greater': the mean of the first distribution is greater than the
      mean of the second distribution.

    .. versionadded:: 1.6.0

Returns
-------
statistic : float or array
    The calculated t-statistics.
pvalue : float or array
    The two-tailed p-value.

See Also
--------
scipy.stats.ttest_ind

Notes
-----
The statistic is calculated as ``(mean1 - mean2)/se``, where ``se`` is the
standard error. Therefore, the statistic will be positive when `mean1` is
greater than `mean2` and negative when `mean1` is less than `mean2`.

References
----------
.. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test

Examples
--------
Suppose we have the summary data for two samples, as follows (with the
Sample Variance being the corrected sample variance)::

                     Sample   Sample
               Size   Mean   Variance
    Sample 1    13    15.0     87.5
    Sample 2    11    12.0     39.0

Apply the t-test to this data (with the assumption that the population
variances are equal):

&gt;&gt;&gt; from scipy.stats import ttest_ind_from_stats
&gt;&gt;&gt; ttest_ind_from_stats(mean1=15.0, std1=np.sqrt(87.5), nobs1=13,
...                      mean2=12.0, std2=np.sqrt(39.0), nobs2=11)
Ttest_indResult(statistic=0.9051358093310269, pvalue=0.3751996797581487)

For comparison, here is the data from which those summary statistics
were taken.  With this data, we can compute the same result using
`scipy.stats.ttest_ind`:

&gt;&gt;&gt; a = np.array([1, 3, 4, 6, 11, 13, 15, 19, 22, 24, 25, 26, 26])
&gt;&gt;&gt; b = np.array([2, 4, 6, 9, 11, 13, 14, 15, 18, 19, 21])
&gt;&gt;&gt; from scipy.stats import ttest_ind
&gt;&gt;&gt; ttest_ind(a, b)
Ttest_indResult(statistic=0.905135809331027, pvalue=0.3751996797581486)

Suppose we instead have binary data and would like to apply a t-test to
compare the proportion of 1s in two independent groups::

                      Number of    Sample     Sample
                Size    ones        Mean     Variance
    Sample 1    150      30         0.2        0.161073
    Sample 2    200      45         0.225      0.175251

The sample mean :math:`\hat{p}` is the proportion of ones in the sample
and the variance for a binary observation is estimated by
:math:`\hat{p}(1-\hat{p})`.

&gt;&gt;&gt; ttest_ind_from_stats(mean1=0.2, std1=np.sqrt(0.161073), nobs1=150,
...                      mean2=0.225, std2=np.sqrt(0.175251), nobs2=200)
Ttest_indResult(statistic=-0.5627187905196761, pvalue=0.5739887114209541)

For comparison, we could compute the t statistic and p-value using
arrays of 0s and 1s and `scipy.stat.ttest_ind`, as above.

&gt;&gt;&gt; group1 = np.array([1]*30 + [0]*(150-30))
&gt;&gt;&gt; group2 = np.array([1]*45 + [0]*(200-45))
&gt;&gt;&gt; ttest_ind(group1, group2)
Ttest_indResult(statistic=-0.5627179589855622, pvalue=0.573989277115258)</pre> <div class="fragment"><div class="line"><span class="lineno"> 6146</span>                         equal_var=<span class="keyword">True</span>, alternative=<span class="stringliteral">&quot;two-sided&quot;</span>):</div>
<div class="line"><span class="lineno"> 6147</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6148</span><span class="stringliteral">    T-test for means of two independent samples from descriptive statistics.</span></div>
<div class="line"><span class="lineno"> 6149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6150</span><span class="stringliteral">    This is a test for the null hypothesis that two independent</span></div>
<div class="line"><span class="lineno"> 6151</span><span class="stringliteral">    samples have identical average (expected) values.</span></div>
<div class="line"><span class="lineno"> 6152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6153</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 6154</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6155</span><span class="stringliteral">    mean1 : array_like</span></div>
<div class="line"><span class="lineno"> 6156</span><span class="stringliteral">        The mean(s) of sample 1.</span></div>
<div class="line"><span class="lineno"> 6157</span><span class="stringliteral">    std1 : array_like</span></div>
<div class="line"><span class="lineno"> 6158</span><span class="stringliteral">        The corrected sample standard deviation of sample 1 (i.e. ``ddof=1``).</span></div>
<div class="line"><span class="lineno"> 6159</span><span class="stringliteral">    nobs1 : array_like</span></div>
<div class="line"><span class="lineno"> 6160</span><span class="stringliteral">        The number(s) of observations of sample 1.</span></div>
<div class="line"><span class="lineno"> 6161</span><span class="stringliteral">    mean2 : array_like</span></div>
<div class="line"><span class="lineno"> 6162</span><span class="stringliteral">        The mean(s) of sample 2.</span></div>
<div class="line"><span class="lineno"> 6163</span><span class="stringliteral">    std2 : array_like</span></div>
<div class="line"><span class="lineno"> 6164</span><span class="stringliteral">        The corrected sample standard deviation of sample 2 (i.e. ``ddof=1``).</span></div>
<div class="line"><span class="lineno"> 6165</span><span class="stringliteral">    nobs2 : array_like</span></div>
<div class="line"><span class="lineno"> 6166</span><span class="stringliteral">        The number(s) of observations of sample 2.</span></div>
<div class="line"><span class="lineno"> 6167</span><span class="stringliteral">    equal_var : bool, optional</span></div>
<div class="line"><span class="lineno"> 6168</span><span class="stringliteral">        If True (default), perform a standard independent 2 sample test</span></div>
<div class="line"><span class="lineno"> 6169</span><span class="stringliteral">        that assumes equal population variances [1]_.</span></div>
<div class="line"><span class="lineno"> 6170</span><span class="stringliteral">        If False, perform Welch&#39;s t-test, which does not assume equal</span></div>
<div class="line"><span class="lineno"> 6171</span><span class="stringliteral">        population variance [2]_.</span></div>
<div class="line"><span class="lineno"> 6172</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 6173</span><span class="stringliteral">        Defines the alternative hypothesis.</span></div>
<div class="line"><span class="lineno"> 6174</span><span class="stringliteral">        The following options are available (default is &#39;two-sided&#39;):</span></div>
<div class="line"><span class="lineno"> 6175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6176</span><span class="stringliteral">        * &#39;two-sided&#39;: the means of the distributions are unequal.</span></div>
<div class="line"><span class="lineno"> 6177</span><span class="stringliteral">        * &#39;less&#39;: the mean of the first distribution is less than the</span></div>
<div class="line"><span class="lineno"> 6178</span><span class="stringliteral">          mean of the second distribution.</span></div>
<div class="line"><span class="lineno"> 6179</span><span class="stringliteral">        * &#39;greater&#39;: the mean of the first distribution is greater than the</span></div>
<div class="line"><span class="lineno"> 6180</span><span class="stringliteral">          mean of the second distribution.</span></div>
<div class="line"><span class="lineno"> 6181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6182</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 6183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6184</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 6185</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 6186</span><span class="stringliteral">    statistic : float or array</span></div>
<div class="line"><span class="lineno"> 6187</span><span class="stringliteral">        The calculated t-statistics.</span></div>
<div class="line"><span class="lineno"> 6188</span><span class="stringliteral">    pvalue : float or array</span></div>
<div class="line"><span class="lineno"> 6189</span><span class="stringliteral">        The two-tailed p-value.</span></div>
<div class="line"><span class="lineno"> 6190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6191</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 6192</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 6193</span><span class="stringliteral">    scipy.stats.ttest_ind</span></div>
<div class="line"><span class="lineno"> 6194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6195</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 6196</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 6197</span><span class="stringliteral">    The statistic is calculated as ``(mean1 - mean2)/se``, where ``se`` is the</span></div>
<div class="line"><span class="lineno"> 6198</span><span class="stringliteral">    standard error. Therefore, the statistic will be positive when `mean1` is</span></div>
<div class="line"><span class="lineno"> 6199</span><span class="stringliteral">    greater than `mean2` and negative when `mean1` is less than `mean2`.</span></div>
<div class="line"><span class="lineno"> 6200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6201</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 6202</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6203</span><span class="stringliteral">    .. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test</span></div>
<div class="line"><span class="lineno"> 6204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6205</span><span class="stringliteral">    .. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test</span></div>
<div class="line"><span class="lineno"> 6206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6207</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 6208</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 6209</span><span class="stringliteral">    Suppose we have the summary data for two samples, as follows (with the</span></div>
<div class="line"><span class="lineno"> 6210</span><span class="stringliteral">    Sample Variance being the corrected sample variance)::</span></div>
<div class="line"><span class="lineno"> 6211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6212</span><span class="stringliteral">                         Sample   Sample</span></div>
<div class="line"><span class="lineno"> 6213</span><span class="stringliteral">                   Size   Mean   Variance</span></div>
<div class="line"><span class="lineno"> 6214</span><span class="stringliteral">        Sample 1    13    15.0     87.5</span></div>
<div class="line"><span class="lineno"> 6215</span><span class="stringliteral">        Sample 2    11    12.0     39.0</span></div>
<div class="line"><span class="lineno"> 6216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6217</span><span class="stringliteral">    Apply the t-test to this data (with the assumption that the population</span></div>
<div class="line"><span class="lineno"> 6218</span><span class="stringliteral">    variances are equal):</span></div>
<div class="line"><span class="lineno"> 6219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6220</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import ttest_ind_from_stats</span></div>
<div class="line"><span class="lineno"> 6221</span><span class="stringliteral">    &gt;&gt;&gt; ttest_ind_from_stats(mean1=15.0, std1=np.sqrt(87.5), nobs1=13,</span></div>
<div class="line"><span class="lineno"> 6222</span><span class="stringliteral">    ...                      mean2=12.0, std2=np.sqrt(39.0), nobs2=11)</span></div>
<div class="line"><span class="lineno"> 6223</span><span class="stringliteral">    Ttest_indResult(statistic=0.9051358093310269, pvalue=0.3751996797581487)</span></div>
<div class="line"><span class="lineno"> 6224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6225</span><span class="stringliteral">    For comparison, here is the data from which those summary statistics</span></div>
<div class="line"><span class="lineno"> 6226</span><span class="stringliteral">    were taken.  With this data, we can compute the same result using</span></div>
<div class="line"><span class="lineno"> 6227</span><span class="stringliteral">    `scipy.stats.ttest_ind`:</span></div>
<div class="line"><span class="lineno"> 6228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6229</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 3, 4, 6, 11, 13, 15, 19, 22, 24, 25, 26, 26])</span></div>
<div class="line"><span class="lineno"> 6230</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([2, 4, 6, 9, 11, 13, 14, 15, 18, 19, 21])</span></div>
<div class="line"><span class="lineno"> 6231</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import ttest_ind</span></div>
<div class="line"><span class="lineno"> 6232</span><span class="stringliteral">    &gt;&gt;&gt; ttest_ind(a, b)</span></div>
<div class="line"><span class="lineno"> 6233</span><span class="stringliteral">    Ttest_indResult(statistic=0.905135809331027, pvalue=0.3751996797581486)</span></div>
<div class="line"><span class="lineno"> 6234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6235</span><span class="stringliteral">    Suppose we instead have binary data and would like to apply a t-test to</span></div>
<div class="line"><span class="lineno"> 6236</span><span class="stringliteral">    compare the proportion of 1s in two independent groups::</span></div>
<div class="line"><span class="lineno"> 6237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6238</span><span class="stringliteral">                          Number of    Sample     Sample</span></div>
<div class="line"><span class="lineno"> 6239</span><span class="stringliteral">                    Size    ones        Mean     Variance</span></div>
<div class="line"><span class="lineno"> 6240</span><span class="stringliteral">        Sample 1    150      30         0.2        0.161073</span></div>
<div class="line"><span class="lineno"> 6241</span><span class="stringliteral">        Sample 2    200      45         0.225      0.175251</span></div>
<div class="line"><span class="lineno"> 6242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6243</span><span class="stringliteral">    The sample mean :math:`\hat{p}` is the proportion of ones in the sample</span></div>
<div class="line"><span class="lineno"> 6244</span><span class="stringliteral">    and the variance for a binary observation is estimated by</span></div>
<div class="line"><span class="lineno"> 6245</span><span class="stringliteral">    :math:`\hat{p}(1-\hat{p})`.</span></div>
<div class="line"><span class="lineno"> 6246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6247</span><span class="stringliteral">    &gt;&gt;&gt; ttest_ind_from_stats(mean1=0.2, std1=np.sqrt(0.161073), nobs1=150,</span></div>
<div class="line"><span class="lineno"> 6248</span><span class="stringliteral">    ...                      mean2=0.225, std2=np.sqrt(0.175251), nobs2=200)</span></div>
<div class="line"><span class="lineno"> 6249</span><span class="stringliteral">    Ttest_indResult(statistic=-0.5627187905196761, pvalue=0.5739887114209541)</span></div>
<div class="line"><span class="lineno"> 6250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6251</span><span class="stringliteral">    For comparison, we could compute the t statistic and p-value using</span></div>
<div class="line"><span class="lineno"> 6252</span><span class="stringliteral">    arrays of 0s and 1s and `scipy.stat.ttest_ind`, as above.</span></div>
<div class="line"><span class="lineno"> 6253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6254</span><span class="stringliteral">    &gt;&gt;&gt; group1 = np.array([1]*30 + [0]*(150-30))</span></div>
<div class="line"><span class="lineno"> 6255</span><span class="stringliteral">    &gt;&gt;&gt; group2 = np.array([1]*45 + [0]*(200-45))</span></div>
<div class="line"><span class="lineno"> 6256</span><span class="stringliteral">    &gt;&gt;&gt; ttest_ind(group1, group2)</span></div>
<div class="line"><span class="lineno"> 6257</span><span class="stringliteral">    Ttest_indResult(statistic=-0.5627179589855622, pvalue=0.573989277115258)</span></div>
<div class="line"><span class="lineno"> 6258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6259</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6260</span>    mean1 = np.asarray(mean1)</div>
<div class="line"><span class="lineno"> 6261</span>    std1 = np.asarray(std1)</div>
<div class="line"><span class="lineno"> 6262</span>    mean2 = np.asarray(mean2)</div>
<div class="line"><span class="lineno"> 6263</span>    std2 = np.asarray(std2)</div>
<div class="line"><span class="lineno"> 6264</span>    <span class="keywordflow">if</span> equal_var:</div>
<div class="line"><span class="lineno"> 6265</span>        df, denom = _equal_var_ttest_denom(std1**2, nobs1, std2**2, nobs2)</div>
<div class="line"><span class="lineno"> 6266</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6267</span>        df, denom = _unequal_var_ttest_denom(std1**2, nobs1,</div>
<div class="line"><span class="lineno"> 6268</span>                                             std2**2, nobs2)</div>
<div class="line"><span class="lineno"> 6269</span> </div>
<div class="line"><span class="lineno"> 6270</span>    res = _ttest_ind_from_stats(mean1, mean2, denom, df, alternative)</div>
<div class="line"><span class="lineno"> 6271</span>    <span class="keywordflow">return</span> Ttest_indResult(*res)</div>
<div class="line"><span class="lineno"> 6272</span> </div>
<div class="line"><span class="lineno"> 6273</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40e1ede0be1d6f44d3aa61aa9e1be55f" name="a40e1ede0be1d6f44d3aa61aa9e1be55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e1ede0be1d6f44d3aa61aa9e1be55f">&#9670;&#160;</a></span>ttest_rel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ttest_rel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the t-test on TWO RELATED samples of scores, a and b.

This is a test for the null hypothesis that two related or
repeated samples have identical average (expected) values.

Parameters
----------
a, b : array_like
    The arrays must have the same shape.
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    arrays, `a`, and `b`.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan.
    The following options are available (default is 'propagate'):

      * 'propagate': returns nan
      * 'raise': throws an error
      * 'omit': performs the calculations ignoring nan values
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis.
    The following options are available (default is 'two-sided'):

    * 'two-sided': the means of the distributions underlying the samples
      are unequal.
    * 'less': the mean of the distribution underlying the first sample
      is less than the mean of the distribution underlying the second
      sample.
    * 'greater': the mean of the distribution underlying the first
      sample is greater than the mean of the distribution underlying
      the second sample.

    .. versionadded:: 1.6.0

Returns
-------
statistic : float or array
    t-statistic.
pvalue : float or array
    The p-value.

Notes
-----
Examples for use are scores of the same set of student in
different exams, or repeated sampling from the same units. The
test measures whether the average score differs significantly
across samples (e.g. exams). If we observe a large p-value, for
example greater than 0.05 or 0.1 then we cannot reject the null
hypothesis of identical average scores. If the p-value is smaller
than the threshold, e.g. 1%, 5% or 10%, then we reject the null
hypothesis of equal averages. Small p-values are associated with
large t-statistics.

The statistic is calculated as ``np.mean(a - b)/se``, where ``se`` is the
standard error. Therefore, the statistic will be positive when the sample
mean of ``a - b`` is greater than zero and negative when the sample mean of
``a - b`` is less than zero.

References
----------
https://en.wikipedia.org/wiki/T-test#Dependent_t-test_for_paired_samples

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()

&gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
&gt;&gt;&gt; rvs2 = (stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)
...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng))
&gt;&gt;&gt; stats.ttest_rel(rvs1, rvs2)
Ttest_relResult(statistic=-0.4549717054410304, pvalue=0.6493274702088672)
&gt;&gt;&gt; rvs3 = (stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)
...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng))
&gt;&gt;&gt; stats.ttest_rel(rvs1, rvs3)
Ttest_relResult(statistic=-5.879467544540889, pvalue=7.540777129099917e-09)</pre> <div class="fragment"><div class="line"><span class="lineno"> 6803</span><span class="keyword">def </span>ttest_rel(a, b, axis=0, nan_policy=&#39;propagate&#39;, alternative=&quot;two-sided&quot;):</div>
<div class="line"><span class="lineno"> 6804</span>    <span class="stringliteral">&quot;&quot;&quot;Calculate the t-test on TWO RELATED samples of scores, a and b.</span></div>
<div class="line"><span class="lineno"> 6805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6806</span><span class="stringliteral">    This is a test for the null hypothesis that two related or</span></div>
<div class="line"><span class="lineno"> 6807</span><span class="stringliteral">    repeated samples have identical average (expected) values.</span></div>
<div class="line"><span class="lineno"> 6808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6809</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 6810</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6811</span><span class="stringliteral">    a, b : array_like</span></div>
<div class="line"><span class="lineno"> 6812</span><span class="stringliteral">        The arrays must have the same shape.</span></div>
<div class="line"><span class="lineno"> 6813</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 6814</span><span class="stringliteral">        Axis along which to compute test. If None, compute over the whole</span></div>
<div class="line"><span class="lineno"> 6815</span><span class="stringliteral">        arrays, `a`, and `b`.</span></div>
<div class="line"><span class="lineno"> 6816</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 6817</span><span class="stringliteral">        Defines how to handle when input contains nan.</span></div>
<div class="line"><span class="lineno"> 6818</span><span class="stringliteral">        The following options are available (default is &#39;propagate&#39;):</span></div>
<div class="line"><span class="lineno"> 6819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6820</span><span class="stringliteral">          * &#39;propagate&#39;: returns nan</span></div>
<div class="line"><span class="lineno"> 6821</span><span class="stringliteral">          * &#39;raise&#39;: throws an error</span></div>
<div class="line"><span class="lineno"> 6822</span><span class="stringliteral">          * &#39;omit&#39;: performs the calculations ignoring nan values</span></div>
<div class="line"><span class="lineno"> 6823</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 6824</span><span class="stringliteral">        Defines the alternative hypothesis.</span></div>
<div class="line"><span class="lineno"> 6825</span><span class="stringliteral">        The following options are available (default is &#39;two-sided&#39;):</span></div>
<div class="line"><span class="lineno"> 6826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6827</span><span class="stringliteral">        * &#39;two-sided&#39;: the means of the distributions underlying the samples</span></div>
<div class="line"><span class="lineno"> 6828</span><span class="stringliteral">          are unequal.</span></div>
<div class="line"><span class="lineno"> 6829</span><span class="stringliteral">        * &#39;less&#39;: the mean of the distribution underlying the first sample</span></div>
<div class="line"><span class="lineno"> 6830</span><span class="stringliteral">          is less than the mean of the distribution underlying the second</span></div>
<div class="line"><span class="lineno"> 6831</span><span class="stringliteral">          sample.</span></div>
<div class="line"><span class="lineno"> 6832</span><span class="stringliteral">        * &#39;greater&#39;: the mean of the distribution underlying the first</span></div>
<div class="line"><span class="lineno"> 6833</span><span class="stringliteral">          sample is greater than the mean of the distribution underlying</span></div>
<div class="line"><span class="lineno"> 6834</span><span class="stringliteral">          the second sample.</span></div>
<div class="line"><span class="lineno"> 6835</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6836</span><span class="stringliteral">        .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 6837</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6838</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 6839</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 6840</span><span class="stringliteral">    statistic : float or array</span></div>
<div class="line"><span class="lineno"> 6841</span><span class="stringliteral">        t-statistic.</span></div>
<div class="line"><span class="lineno"> 6842</span><span class="stringliteral">    pvalue : float or array</span></div>
<div class="line"><span class="lineno"> 6843</span><span class="stringliteral">        The p-value.</span></div>
<div class="line"><span class="lineno"> 6844</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6845</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 6846</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 6847</span><span class="stringliteral">    Examples for use are scores of the same set of student in</span></div>
<div class="line"><span class="lineno"> 6848</span><span class="stringliteral">    different exams, or repeated sampling from the same units. The</span></div>
<div class="line"><span class="lineno"> 6849</span><span class="stringliteral">    test measures whether the average score differs significantly</span></div>
<div class="line"><span class="lineno"> 6850</span><span class="stringliteral">    across samples (e.g. exams). If we observe a large p-value, for</span></div>
<div class="line"><span class="lineno"> 6851</span><span class="stringliteral">    example greater than 0.05 or 0.1 then we cannot reject the null</span></div>
<div class="line"><span class="lineno"> 6852</span><span class="stringliteral">    hypothesis of identical average scores. If the p-value is smaller</span></div>
<div class="line"><span class="lineno"> 6853</span><span class="stringliteral">    than the threshold, e.g. 1%, 5% or 10%, then we reject the null</span></div>
<div class="line"><span class="lineno"> 6854</span><span class="stringliteral">    hypothesis of equal averages. Small p-values are associated with</span></div>
<div class="line"><span class="lineno"> 6855</span><span class="stringliteral">    large t-statistics.</span></div>
<div class="line"><span class="lineno"> 6856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6857</span><span class="stringliteral">    The statistic is calculated as ``np.mean(a - b)/se``, where ``se`` is the</span></div>
<div class="line"><span class="lineno"> 6858</span><span class="stringliteral">    standard error. Therefore, the statistic will be positive when the sample</span></div>
<div class="line"><span class="lineno"> 6859</span><span class="stringliteral">    mean of ``a - b`` is greater than zero and negative when the sample mean of</span></div>
<div class="line"><span class="lineno"> 6860</span><span class="stringliteral">    ``a - b`` is less than zero.</span></div>
<div class="line"><span class="lineno"> 6861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6862</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 6863</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 6864</span><span class="stringliteral">    https://en.wikipedia.org/wiki/T-test#Dependent_t-test_for_paired_samples</span></div>
<div class="line"><span class="lineno"> 6865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6866</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 6867</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 6868</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 6869</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 6870</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6871</span><span class="stringliteral">    &gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6872</span><span class="stringliteral">    &gt;&gt;&gt; rvs2 = (stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6873</span><span class="stringliteral">    ...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng))</span></div>
<div class="line"><span class="lineno"> 6874</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_rel(rvs1, rvs2)</span></div>
<div class="line"><span class="lineno"> 6875</span><span class="stringliteral">    Ttest_relResult(statistic=-0.4549717054410304, pvalue=0.6493274702088672)</span></div>
<div class="line"><span class="lineno"> 6876</span><span class="stringliteral">    &gt;&gt;&gt; rvs3 = (stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 6877</span><span class="stringliteral">    ...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng))</span></div>
<div class="line"><span class="lineno"> 6878</span><span class="stringliteral">    &gt;&gt;&gt; stats.ttest_rel(rvs1, rvs3)</span></div>
<div class="line"><span class="lineno"> 6879</span><span class="stringliteral">    Ttest_relResult(statistic=-5.879467544540889, pvalue=7.540777129099917e-09)</span></div>
<div class="line"><span class="lineno"> 6880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6881</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6882</span>    a, b, axis = _chk2_asarray(a, b, axis)</div>
<div class="line"><span class="lineno"> 6883</span> </div>
<div class="line"><span class="lineno"> 6884</span>    cna, npa = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 6885</span>    cnb, npb = _contains_nan(b, nan_policy)</div>
<div class="line"><span class="lineno"> 6886</span>    contains_nan = cna <span class="keywordflow">or</span> cnb</div>
<div class="line"><span class="lineno"> 6887</span>    <span class="keywordflow">if</span> npa == <span class="stringliteral">&#39;omit&#39;</span> <span class="keywordflow">or</span> npb == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 6888</span>        nan_policy = <span class="stringliteral">&#39;omit&#39;</span></div>
<div class="line"><span class="lineno"> 6889</span> </div>
<div class="line"><span class="lineno"> 6890</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 6891</span>        a = ma.masked_invalid(a)</div>
<div class="line"><span class="lineno"> 6892</span>        b = ma.masked_invalid(b)</div>
<div class="line"><span class="lineno"> 6893</span>        m = ma.mask_or(ma.getmask(a), ma.getmask(b))</div>
<div class="line"><span class="lineno"> 6894</span>        aa = ma.array(a, mask=m, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 6895</span>        bb = ma.array(b, mask=m, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 6896</span>        <span class="keywordflow">return</span> mstats_basic.ttest_rel(aa, bb, axis, alternative)</div>
<div class="line"><span class="lineno"> 6897</span> </div>
<div class="line"><span class="lineno"> 6898</span>    na = _get_len(a, axis, <span class="stringliteral">&quot;first argument&quot;</span>)</div>
<div class="line"><span class="lineno"> 6899</span>    nb = _get_len(b, axis, <span class="stringliteral">&quot;second argument&quot;</span>)</div>
<div class="line"><span class="lineno"> 6900</span>    <span class="keywordflow">if</span> na != nb:</div>
<div class="line"><span class="lineno"> 6901</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;unequal length arrays&#39;</span>)</div>
<div class="line"><span class="lineno"> 6902</span> </div>
<div class="line"><span class="lineno"> 6903</span>    <span class="keywordflow">if</span> na == 0:</div>
<div class="line"><span class="lineno"> 6904</span>        <span class="keywordflow">return</span> _ttest_nans(a, b, axis, Ttest_relResult)</div>
<div class="line"><span class="lineno"> 6905</span> </div>
<div class="line"><span class="lineno"> 6906</span>    n = a.shape[axis]</div>
<div class="line"><span class="lineno"> 6907</span>    df = n - 1</div>
<div class="line"><span class="lineno"> 6908</span> </div>
<div class="line"><span class="lineno"> 6909</span>    d = (a - b).astype(np.float64)</div>
<div class="line"><span class="lineno"> 6910</span>    v = _var(d, axis, ddof=1)</div>
<div class="line"><span class="lineno"> 6911</span>    dm = np.mean(d, axis)</div>
<div class="line"><span class="lineno"> 6912</span>    denom = np.sqrt(v / n)</div>
<div class="line"><span class="lineno"> 6913</span> </div>
<div class="line"><span class="lineno"> 6914</span>    <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&#39;ignore&#39;</span>, invalid=<span class="stringliteral">&#39;ignore&#39;</span>):</div>
<div class="line"><span class="lineno"> 6915</span>        t = np.divide(dm, denom)</div>
<div class="line"><span class="lineno"> 6916</span>    t, prob = _ttest_finish(df, t, alternative)</div>
<div class="line"><span class="lineno"> 6917</span> </div>
<div class="line"><span class="lineno"> 6918</span>    <span class="keywordflow">return</span> Ttest_relResult(t, prob)</div>
<div class="line"><span class="lineno"> 6919</span> </div>
<div class="line"><span class="lineno"> 6920</span> </div>
<div class="line"><span class="lineno"> 6921</span><span class="comment"># Map from names to lambda_ values used in power_divergence().</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a26ec33f46d65449e3c4e90f85e6f3928" name="a26ec33f46d65449e3c4e90f85e6f3928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ec33f46d65449e3c4e90f85e6f3928">&#9670;&#160;</a></span>tvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.tvar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limits</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>(True,&#160;True)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the trimmed variance.

This function computes the sample variance of an array of values,
while ignoring values which are outside of given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the
    whole array `a`.
ddof : int, optional
    Delta degrees of freedom.  Default is 1.

Returns
-------
tvar : float
    Trimmed variance.

Notes
-----
`tvar` computes the unbiased sample variance, i.e. it uses a correction
factor ``n / (n - 1)``.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.tvar(x)
35.0
&gt;&gt;&gt; stats.tvar(x, (3,17))
20.0</pre> <div class="fragment"><div class="line"><span class="lineno">  783</span><span class="keyword">def </span>tvar(a, limits=None, inclusive=(<span class="keyword">True</span>, <span class="keyword">True</span>), axis=0, ddof=1):</div>
<div class="line"><span class="lineno">  784</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the trimmed variance.</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    This function computes the sample variance of an array of values,</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    while ignoring values which are outside of given `limits`.</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        Array of values.</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    limits : None or (lower limit, upper limit), optional</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        Values in the input array less than the lower limit or greater than the</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        upper limit will be ignored. When limits is None, then all values are</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">        used. Either of the limit values in the tuple can also be None</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">        representing a half-open interval.  The default value is None.</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    inclusive : (bool, bool), optional</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        A tuple consisting of the (lower flag, upper flag).  These flags</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">        determine whether values exactly equal to the lower or upper limits</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">        are included.  The default value is (True, True).</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over the</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">        whole array `a`.</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        Delta degrees of freedom.  Default is 1.</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    tvar : float</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        Trimmed variance.</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    `tvar` computes the unbiased sample variance, i.e. it uses a correction</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    factor ``n / (n - 1)``.</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(20)</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    &gt;&gt;&gt; stats.tvar(x)</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    35.0</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    &gt;&gt;&gt; stats.tvar(x, (3,17))</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    20.0</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  828</span>    a = asarray(a)</div>
<div class="line"><span class="lineno">  829</span>    a = a.astype(float)</div>
<div class="line"><span class="lineno">  830</span>    <span class="keywordflow">if</span> limits <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  831</span>        <span class="keywordflow">return</span> a.var(ddof=ddof, axis=axis)</div>
<div class="line"><span class="lineno">  832</span>    am = _mask_to_limits(a, limits, inclusive)</div>
<div class="line"><span class="lineno">  833</span>    amnan = am.filled(fill_value=np.nan)</div>
<div class="line"><span class="lineno">  834</span>    <span class="keywordflow">return</span> np.nanvar(amnan, ddof=ddof, axis=axis)</div>
<div class="line"><span class="lineno">  835</span> </div>
<div class="line"><span class="lineno">  836</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a030f7a94530750520b7f11137b0f88c6" name="a030f7a94530750520b7f11137b0f88c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030f7a94530750520b7f11137b0f88c6">&#9670;&#160;</a></span>wasserstein_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.wasserstein_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u_weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v_weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STATISTICAL DISTANCES #. </p>
<pre class="fragment">    Compute the first Wasserstein distance between two 1D distributions.

    This distance is also known as the earth mover's distance, since it can be
    seen as the minimum amount of "work" required to transform :math:`u` into
    :math:`v`, where "work" is measured as the amount of distribution weight
    that must be moved, multiplied by the distance it has to be moved.

    .. versionadded:: 1.0.0

    Parameters
    ----------
    u_values, v_values : array_like
        Values observed in the (empirical) distribution.
    u_weights, v_weights : array_like, optional
        Weight for each value. If unspecified, each value is assigned the same
        weight.
        `u_weights` (resp. `v_weights`) must have the same length as
        `u_values` (resp. `v_values`). If the weight sum differs from 1, it
        must still be positive and finite so that the weights can be normalized
        to sum to 1.

    Returns
    -------
    distance : float
        The computed distance between the distributions.

    Notes
    -----
    The first Wasserstein distance between the distributions :math:`u` and
    :math:`v` is:

    .. math::

        l_1 (u, v) = \inf_{\pi \in \Gamma (u, v)} \int_{\mathbb{R} \times
        \mathbb{R}} |x-y| \mathrm{d} \pi (x, y)

    where :math:`\Gamma (u, v)` is the set of (probability) distributions on
    :math:`\mathbb{R} \times \mathbb{R}` whose marginals are :math:`u` and
    :math:`v` on the first and second factors respectively.

    If :math:`U` and :math:`V` are the respective CDFs of :math:`u` and
    :math:`v`, this distance also equals to:

    .. math::

        l_1(u, v) = \int_{-\infty}^{+\infty} |U-V|

    See [2]_ for a proof of the equivalence of both definitions.

    The input distributions can be empirical, therefore coming from samples
    whose values are effectively inputs of the function, or they can be seen as
    generalized functions, in which case they are weighted sums of Dirac delta
    functions located at the specified values.

    References
    ----------
    .. [1] "Wasserstein metric", https://en.wikipedia.org/wiki/Wasserstein_metric
    .. [2] Ramdas, Garcia, Cuturi "On Wasserstein Two Sample Testing and Related
           Families of Nonparametric Tests" (2015). :arXiv:`1509.02237`.

    Examples
    --------
    &gt;&gt;&gt; from scipy.stats import wasserstein_distance
    &gt;&gt;&gt; wasserstein_distance([0, 1, 3], [5, 6, 8])
    5.0
    &gt;&gt;&gt; wasserstein_distance([0, 1], [0, 1], [3, 1], [2, 2])
    0.25
    &gt;&gt;&gt; wasserstein_distance([3.4, 3.9, 7.5, 7.8], [4.5, 1.4],
    ...                      [1.4, 0.9, 3.1, 7.2], [3.2, 3.5])
    4.0781331438047861</pre> <div class="fragment"><div class="line"><span class="lineno"> 8675</span><span class="keyword">def </span>wasserstein_distance(u_values, v_values, u_weights=None, v_weights=None):</div>
<div class="line"><span class="lineno"> 8676</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8677</span><span class="stringliteral">    Compute the first Wasserstein distance between two 1D distributions.</span></div>
<div class="line"><span class="lineno"> 8678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8679</span><span class="stringliteral">    This distance is also known as the earth mover&#39;s distance, since it can be</span></div>
<div class="line"><span class="lineno"> 8680</span><span class="stringliteral">    seen as the minimum amount of &quot;work&quot; required to transform :math:`u` into</span></div>
<div class="line"><span class="lineno"> 8681</span><span class="stringliteral">    :math:`v`, where &quot;work&quot; is measured as the amount of distribution weight</span></div>
<div class="line"><span class="lineno"> 8682</span><span class="stringliteral">    that must be moved, multiplied by the distance it has to be moved.</span></div>
<div class="line"><span class="lineno"> 8683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8684</span><span class="stringliteral">    .. versionadded:: 1.0.0</span></div>
<div class="line"><span class="lineno"> 8685</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8686</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 8687</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8688</span><span class="stringliteral">    u_values, v_values : array_like</span></div>
<div class="line"><span class="lineno"> 8689</span><span class="stringliteral">        Values observed in the (empirical) distribution.</span></div>
<div class="line"><span class="lineno"> 8690</span><span class="stringliteral">    u_weights, v_weights : array_like, optional</span></div>
<div class="line"><span class="lineno"> 8691</span><span class="stringliteral">        Weight for each value. If unspecified, each value is assigned the same</span></div>
<div class="line"><span class="lineno"> 8692</span><span class="stringliteral">        weight.</span></div>
<div class="line"><span class="lineno"> 8693</span><span class="stringliteral">        `u_weights` (resp. `v_weights`) must have the same length as</span></div>
<div class="line"><span class="lineno"> 8694</span><span class="stringliteral">        `u_values` (resp. `v_values`). If the weight sum differs from 1, it</span></div>
<div class="line"><span class="lineno"> 8695</span><span class="stringliteral">        must still be positive and finite so that the weights can be normalized</span></div>
<div class="line"><span class="lineno"> 8696</span><span class="stringliteral">        to sum to 1.</span></div>
<div class="line"><span class="lineno"> 8697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8698</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 8699</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 8700</span><span class="stringliteral">    distance : float</span></div>
<div class="line"><span class="lineno"> 8701</span><span class="stringliteral">        The computed distance between the distributions.</span></div>
<div class="line"><span class="lineno"> 8702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8703</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 8704</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 8705</span><span class="stringliteral">    The first Wasserstein distance between the distributions :math:`u` and</span></div>
<div class="line"><span class="lineno"> 8706</span><span class="stringliteral">    :math:`v` is:</span></div>
<div class="line"><span class="lineno"> 8707</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8708</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 8709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8710</span><span class="stringliteral">        l_1 (u, v) = \inf_{\pi \in \Gamma (u, v)} \int_{\mathbb{R} \times</span></div>
<div class="line"><span class="lineno"> 8711</span><span class="stringliteral">        \mathbb{R}} |x-y| \mathrm{d} \pi (x, y)</span></div>
<div class="line"><span class="lineno"> 8712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8713</span><span class="stringliteral">    where :math:`\Gamma (u, v)` is the set of (probability) distributions on</span></div>
<div class="line"><span class="lineno"> 8714</span><span class="stringliteral">    :math:`\mathbb{R} \times \mathbb{R}` whose marginals are :math:`u` and</span></div>
<div class="line"><span class="lineno"> 8715</span><span class="stringliteral">    :math:`v` on the first and second factors respectively.</span></div>
<div class="line"><span class="lineno"> 8716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8717</span><span class="stringliteral">    If :math:`U` and :math:`V` are the respective CDFs of :math:`u` and</span></div>
<div class="line"><span class="lineno"> 8718</span><span class="stringliteral">    :math:`v`, this distance also equals to:</span></div>
<div class="line"><span class="lineno"> 8719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8720</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 8721</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8722</span><span class="stringliteral">        l_1(u, v) = \int_{-\infty}^{+\infty} |U-V|</span></div>
<div class="line"><span class="lineno"> 8723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8724</span><span class="stringliteral">    See [2]_ for a proof of the equivalence of both definitions.</span></div>
<div class="line"><span class="lineno"> 8725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8726</span><span class="stringliteral">    The input distributions can be empirical, therefore coming from samples</span></div>
<div class="line"><span class="lineno"> 8727</span><span class="stringliteral">    whose values are effectively inputs of the function, or they can be seen as</span></div>
<div class="line"><span class="lineno"> 8728</span><span class="stringliteral">    generalized functions, in which case they are weighted sums of Dirac delta</span></div>
<div class="line"><span class="lineno"> 8729</span><span class="stringliteral">    functions located at the specified values.</span></div>
<div class="line"><span class="lineno"> 8730</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8731</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 8732</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 8733</span><span class="stringliteral">    .. [1] &quot;Wasserstein metric&quot;, https://en.wikipedia.org/wiki/Wasserstein_metric</span></div>
<div class="line"><span class="lineno"> 8734</span><span class="stringliteral">    .. [2] Ramdas, Garcia, Cuturi &quot;On Wasserstein Two Sample Testing and Related</span></div>
<div class="line"><span class="lineno"> 8735</span><span class="stringliteral">           Families of Nonparametric Tests&quot; (2015). :arXiv:`1509.02237`.</span></div>
<div class="line"><span class="lineno"> 8736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8737</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 8738</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 8739</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import wasserstein_distance</span></div>
<div class="line"><span class="lineno"> 8740</span><span class="stringliteral">    &gt;&gt;&gt; wasserstein_distance([0, 1, 3], [5, 6, 8])</span></div>
<div class="line"><span class="lineno"> 8741</span><span class="stringliteral">    5.0</span></div>
<div class="line"><span class="lineno"> 8742</span><span class="stringliteral">    &gt;&gt;&gt; wasserstein_distance([0, 1], [0, 1], [3, 1], [2, 2])</span></div>
<div class="line"><span class="lineno"> 8743</span><span class="stringliteral">    0.25</span></div>
<div class="line"><span class="lineno"> 8744</span><span class="stringliteral">    &gt;&gt;&gt; wasserstein_distance([3.4, 3.9, 7.5, 7.8], [4.5, 1.4],</span></div>
<div class="line"><span class="lineno"> 8745</span><span class="stringliteral">    ...                      [1.4, 0.9, 3.1, 7.2], [3.2, 3.5])</span></div>
<div class="line"><span class="lineno"> 8746</span><span class="stringliteral">    4.0781331438047861</span></div>
<div class="line"><span class="lineno"> 8747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 8748</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 8749</span>    <span class="keywordflow">return</span> _cdf_distance(1, u_values, v_values, u_weights, v_weights)</div>
<div class="line"><span class="lineno"> 8750</span> </div>
<div class="line"><span class="lineno"> 8751</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ba4662b53e915f8ac0f275bb2199d4f" name="a6ba4662b53e915f8ac0f275bb2199d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba4662b53e915f8ac0f275bb2199d4f">&#9670;&#160;</a></span>weightedtau()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.weightedtau </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rank</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weigher</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>additive</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a weighted version of Kendall's :math:`\tau`.

The weighted :math:`\tau` is a weighted version of Kendall's
:math:`\tau` in which exchanges of high weight are more influential than
exchanges of low weight. The default parameters compute the additive
hyperbolic version of the index, :math:`\tau_\mathrm h`, which has
been shown to provide the best balance between important and
unimportant elements [1]_.

The weighting is defined by means of a rank array, which assigns a
nonnegative rank to each element (higher importance ranks being
associated with smaller values, e.g., 0 is the highest possible rank),
and a weigher function, which assigns a weight based on the rank to
each element. The weight of an exchange is then the sum or the product
of the weights of the ranks of the exchanged elements. The default
parameters compute :math:`\tau_\mathrm h`: an exchange between
elements with rank :math:`r` and :math:`s` (starting from zero) has
weight :math:`1/(r+1) + 1/(s+1)`.

Specifying a rank array is meaningful only if you have in mind an
external criterion of importance. If, as it usually happens, you do
not have in mind a specific rank, the weighted :math:`\tau` is
defined by averaging the values obtained using the decreasing
lexicographical rank by (`x`, `y`) and by (`y`, `x`). This is the
behavior with default parameters. Note that the convention used
here for ranking (lower values imply higher importance) is opposite
to that used by other SciPy statistical functions.

Parameters
----------
x, y : array_like
Arrays of scores, of the same shape. If arrays are not 1-D, they will
be flattened to 1-D.
rank : array_like of ints or bool, optional
A nonnegative rank assigned to each element. If it is None, the
decreasing lexicographical rank by (`x`, `y`) will be used: elements of
higher rank will be those with larger `x`-values, using `y`-values to
break ties (in particular, swapping `x` and `y` will give a different
result). If it is False, the element indices will be used
directly as ranks. The default is True, in which case this
function returns the average of the values obtained using the
decreasing lexicographical rank by (`x`, `y`) and by (`y`, `x`).
weigher : callable, optional
The weigher function. Must map nonnegative integers (zero
representing the most important element) to a nonnegative weight.
The default, None, provides hyperbolic weighing, that is,
rank :math:`r` is mapped to weight :math:`1/(r+1)`.
additive : bool, optional
If True, the weight of an exchange is computed by adding the
weights of the ranks of the exchanged elements; otherwise, the weights
are multiplied. The default is True.

Returns
-------
correlation : float
The weighted :math:`\tau` correlation index.
pvalue : float
Presently ``np.nan``, as the null statistics is unknown (even in the
additive hyperbolic case).

See Also
--------
kendalltau : Calculates Kendall's tau.
spearmanr : Calculates a Spearman rank-order correlation coefficient.
theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).

Notes
-----
This function uses an :math:`O(n \log n)`, mergesort-based algorithm
[1]_ that is a weighted extension of Knight's algorithm for Kendall's
:math:`\tau` [2]_. It can compute Shieh's weighted :math:`\tau` [3]_
between rankings without ties (i.e., permutations) by setting
`additive` and `rank` to False, as the definition given in [1]_ is a
generalization of Shieh's.

NaNs are considered the smallest possible score.

.. versionadded:: 0.19.0

References
----------
.. [1] Sebastiano Vigna, "A weighted correlation index for rankings with
ties", Proceedings of the 24th international conference on World
Wide Web, pp. 1166-1176, ACM, 2015.
.. [2] W.R. Knight, "A Computer Method for Calculating Kendall's Tau with
Ungrouped Data", Journal of the American Statistical Association,
Vol. 61, No. 314, Part 1, pp. 436-439, 1966.
.. [3] Grace S. Shieh. "A weighted Kendall's tau statistic", Statistics &amp;
Probability Letters, Vol. 39, No. 1, pp. 17-24, 1998.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = [12, 2, 1, 12, 2]
&gt;&gt;&gt; y = [1, 4, 7, 1, 0]
&gt;&gt;&gt; tau, p_value = stats.weightedtau(x, y)
&gt;&gt;&gt; tau
-0.56694968153682723
&gt;&gt;&gt; p_value
nan
&gt;&gt;&gt; tau, p_value = stats.weightedtau(x, y, additive=False)
&gt;&gt;&gt; tau
-0.62205716951801038

NaNs are considered the smallest possible score:

&gt;&gt;&gt; x = [12, 2, 1, 12, 2]
&gt;&gt;&gt; y = [1, 4, 7, 1, np.nan]
&gt;&gt;&gt; tau, _ = stats.weightedtau(x, y)
&gt;&gt;&gt; tau
-0.56694968153682723

This is exactly Kendall's tau:

&gt;&gt;&gt; x = [12, 2, 1, 12, 2]
&gt;&gt;&gt; y = [1, 4, 7, 1, 0]
&gt;&gt;&gt; tau, _ = stats.weightedtau(x, y, weigher=lambda x: 1)
&gt;&gt;&gt; tau
-0.47140452079103173

&gt;&gt;&gt; x = [12, 2, 1, 12, 2]
&gt;&gt;&gt; y = [1, 4, 7, 1, 0]
&gt;&gt;&gt; stats.weightedtau(x, y, rank=None)
WeightedTauResult(correlation=-0.4157652301037516, pvalue=nan)
&gt;&gt;&gt; stats.weightedtau(y, x, rank=None)
WeightedTauResult(correlation=-0.7181341329699028, pvalue=nan)</pre> <div class="fragment"><div class="line"><span class="lineno"> 5231</span><span class="keyword">def </span>weightedtau(x, y, rank=True, weigher=None, additive=True):</div>
<div class="line"><span class="lineno"> 5232</span>    <span class="stringliteral">r&quot;&quot;&quot;Compute a weighted version of Kendall&#39;s :math:`\tau`.</span></div>
<div class="line"><span class="lineno"> 5233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5234</span><span class="stringliteral">    The weighted :math:`\tau` is a weighted version of Kendall&#39;s</span></div>
<div class="line"><span class="lineno"> 5235</span><span class="stringliteral">    :math:`\tau` in which exchanges of high weight are more influential than</span></div>
<div class="line"><span class="lineno"> 5236</span><span class="stringliteral">    exchanges of low weight. The default parameters compute the additive</span></div>
<div class="line"><span class="lineno"> 5237</span><span class="stringliteral">    hyperbolic version of the index, :math:`\tau_\mathrm h`, which has</span></div>
<div class="line"><span class="lineno"> 5238</span><span class="stringliteral">    been shown to provide the best balance between important and</span></div>
<div class="line"><span class="lineno"> 5239</span><span class="stringliteral">    unimportant elements [1]_.</span></div>
<div class="line"><span class="lineno"> 5240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5241</span><span class="stringliteral">    The weighting is defined by means of a rank array, which assigns a</span></div>
<div class="line"><span class="lineno"> 5242</span><span class="stringliteral">    nonnegative rank to each element (higher importance ranks being</span></div>
<div class="line"><span class="lineno"> 5243</span><span class="stringliteral">    associated with smaller values, e.g., 0 is the highest possible rank),</span></div>
<div class="line"><span class="lineno"> 5244</span><span class="stringliteral">    and a weigher function, which assigns a weight based on the rank to</span></div>
<div class="line"><span class="lineno"> 5245</span><span class="stringliteral">    each element. The weight of an exchange is then the sum or the product</span></div>
<div class="line"><span class="lineno"> 5246</span><span class="stringliteral">    of the weights of the ranks of the exchanged elements. The default</span></div>
<div class="line"><span class="lineno"> 5247</span><span class="stringliteral">    parameters compute :math:`\tau_\mathrm h`: an exchange between</span></div>
<div class="line"><span class="lineno"> 5248</span><span class="stringliteral">    elements with rank :math:`r` and :math:`s` (starting from zero) has</span></div>
<div class="line"><span class="lineno"> 5249</span><span class="stringliteral">    weight :math:`1/(r+1) + 1/(s+1)`.</span></div>
<div class="line"><span class="lineno"> 5250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5251</span><span class="stringliteral">    Specifying a rank array is meaningful only if you have in mind an</span></div>
<div class="line"><span class="lineno"> 5252</span><span class="stringliteral">    external criterion of importance. If, as it usually happens, you do</span></div>
<div class="line"><span class="lineno"> 5253</span><span class="stringliteral">    not have in mind a specific rank, the weighted :math:`\tau` is</span></div>
<div class="line"><span class="lineno"> 5254</span><span class="stringliteral">    defined by averaging the values obtained using the decreasing</span></div>
<div class="line"><span class="lineno"> 5255</span><span class="stringliteral">    lexicographical rank by (`x`, `y`) and by (`y`, `x`). This is the</span></div>
<div class="line"><span class="lineno"> 5256</span><span class="stringliteral">    behavior with default parameters. Note that the convention used</span></div>
<div class="line"><span class="lineno"> 5257</span><span class="stringliteral">    here for ranking (lower values imply higher importance) is opposite</span></div>
<div class="line"><span class="lineno"> 5258</span><span class="stringliteral">    to that used by other SciPy statistical functions.</span></div>
<div class="line"><span class="lineno"> 5259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5260</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5261</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5262</span><span class="stringliteral">    x, y : array_like</span></div>
<div class="line"><span class="lineno"> 5263</span><span class="stringliteral">        Arrays of scores, of the same shape. If arrays are not 1-D, they will</span></div>
<div class="line"><span class="lineno"> 5264</span><span class="stringliteral">        be flattened to 1-D.</span></div>
<div class="line"><span class="lineno"> 5265</span><span class="stringliteral">    rank : array_like of ints or bool, optional</span></div>
<div class="line"><span class="lineno"> 5266</span><span class="stringliteral">        A nonnegative rank assigned to each element. If it is None, the</span></div>
<div class="line"><span class="lineno"> 5267</span><span class="stringliteral">        decreasing lexicographical rank by (`x`, `y`) will be used: elements of</span></div>
<div class="line"><span class="lineno"> 5268</span><span class="stringliteral">        higher rank will be those with larger `x`-values, using `y`-values to</span></div>
<div class="line"><span class="lineno"> 5269</span><span class="stringliteral">        break ties (in particular, swapping `x` and `y` will give a different</span></div>
<div class="line"><span class="lineno"> 5270</span><span class="stringliteral">        result). If it is False, the element indices will be used</span></div>
<div class="line"><span class="lineno"> 5271</span><span class="stringliteral">        directly as ranks. The default is True, in which case this</span></div>
<div class="line"><span class="lineno"> 5272</span><span class="stringliteral">        function returns the average of the values obtained using the</span></div>
<div class="line"><span class="lineno"> 5273</span><span class="stringliteral">        decreasing lexicographical rank by (`x`, `y`) and by (`y`, `x`).</span></div>
<div class="line"><span class="lineno"> 5274</span><span class="stringliteral">    weigher : callable, optional</span></div>
<div class="line"><span class="lineno"> 5275</span><span class="stringliteral">        The weigher function. Must map nonnegative integers (zero</span></div>
<div class="line"><span class="lineno"> 5276</span><span class="stringliteral">        representing the most important element) to a nonnegative weight.</span></div>
<div class="line"><span class="lineno"> 5277</span><span class="stringliteral">        The default, None, provides hyperbolic weighing, that is,</span></div>
<div class="line"><span class="lineno"> 5278</span><span class="stringliteral">        rank :math:`r` is mapped to weight :math:`1/(r+1)`.</span></div>
<div class="line"><span class="lineno"> 5279</span><span class="stringliteral">    additive : bool, optional</span></div>
<div class="line"><span class="lineno"> 5280</span><span class="stringliteral">        If True, the weight of an exchange is computed by adding the</span></div>
<div class="line"><span class="lineno"> 5281</span><span class="stringliteral">        weights of the ranks of the exchanged elements; otherwise, the weights</span></div>
<div class="line"><span class="lineno"> 5282</span><span class="stringliteral">        are multiplied. The default is True.</span></div>
<div class="line"><span class="lineno"> 5283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5284</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5285</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5286</span><span class="stringliteral">    correlation : float</span></div>
<div class="line"><span class="lineno"> 5287</span><span class="stringliteral">       The weighted :math:`\tau` correlation index.</span></div>
<div class="line"><span class="lineno"> 5288</span><span class="stringliteral">    pvalue : float</span></div>
<div class="line"><span class="lineno"> 5289</span><span class="stringliteral">       Presently ``np.nan``, as the null statistics is unknown (even in the</span></div>
<div class="line"><span class="lineno"> 5290</span><span class="stringliteral">       additive hyperbolic case).</span></div>
<div class="line"><span class="lineno"> 5291</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5292</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 5293</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5294</span><span class="stringliteral">    kendalltau : Calculates Kendall&#39;s tau.</span></div>
<div class="line"><span class="lineno"> 5295</span><span class="stringliteral">    spearmanr : Calculates a Spearman rank-order correlation coefficient.</span></div>
<div class="line"><span class="lineno"> 5296</span><span class="stringliteral">    theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).</span></div>
<div class="line"><span class="lineno"> 5297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5298</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 5299</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 5300</span><span class="stringliteral">    This function uses an :math:`O(n \log n)`, mergesort-based algorithm</span></div>
<div class="line"><span class="lineno"> 5301</span><span class="stringliteral">    [1]_ that is a weighted extension of Knight&#39;s algorithm for Kendall&#39;s</span></div>
<div class="line"><span class="lineno"> 5302</span><span class="stringliteral">    :math:`\tau` [2]_. It can compute Shieh&#39;s weighted :math:`\tau` [3]_</span></div>
<div class="line"><span class="lineno"> 5303</span><span class="stringliteral">    between rankings without ties (i.e., permutations) by setting</span></div>
<div class="line"><span class="lineno"> 5304</span><span class="stringliteral">    `additive` and `rank` to False, as the definition given in [1]_ is a</span></div>
<div class="line"><span class="lineno"> 5305</span><span class="stringliteral">    generalization of Shieh&#39;s.</span></div>
<div class="line"><span class="lineno"> 5306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5307</span><span class="stringliteral">    NaNs are considered the smallest possible score.</span></div>
<div class="line"><span class="lineno"> 5308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5309</span><span class="stringliteral">    .. versionadded:: 0.19.0</span></div>
<div class="line"><span class="lineno"> 5310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5311</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 5312</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5313</span><span class="stringliteral">    .. [1] Sebastiano Vigna, &quot;A weighted correlation index for rankings with</span></div>
<div class="line"><span class="lineno"> 5314</span><span class="stringliteral">           ties&quot;, Proceedings of the 24th international conference on World</span></div>
<div class="line"><span class="lineno"> 5315</span><span class="stringliteral">           Wide Web, pp. 1166-1176, ACM, 2015.</span></div>
<div class="line"><span class="lineno"> 5316</span><span class="stringliteral">    .. [2] W.R. Knight, &quot;A Computer Method for Calculating Kendall&#39;s Tau with</span></div>
<div class="line"><span class="lineno"> 5317</span><span class="stringliteral">           Ungrouped Data&quot;, Journal of the American Statistical Association,</span></div>
<div class="line"><span class="lineno"> 5318</span><span class="stringliteral">           Vol. 61, No. 314, Part 1, pp. 436-439, 1966.</span></div>
<div class="line"><span class="lineno"> 5319</span><span class="stringliteral">    .. [3] Grace S. Shieh. &quot;A weighted Kendall&#39;s tau statistic&quot;, Statistics &amp;</span></div>
<div class="line"><span class="lineno"> 5320</span><span class="stringliteral">           Probability Letters, Vol. 39, No. 1, pp. 17-24, 1998.</span></div>
<div class="line"><span class="lineno"> 5321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5322</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 5323</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5324</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 5325</span><span class="stringliteral">    &gt;&gt;&gt; x = [12, 2, 1, 12, 2]</span></div>
<div class="line"><span class="lineno"> 5326</span><span class="stringliteral">    &gt;&gt;&gt; y = [1, 4, 7, 1, 0]</span></div>
<div class="line"><span class="lineno"> 5327</span><span class="stringliteral">    &gt;&gt;&gt; tau, p_value = stats.weightedtau(x, y)</span></div>
<div class="line"><span class="lineno"> 5328</span><span class="stringliteral">    &gt;&gt;&gt; tau</span></div>
<div class="line"><span class="lineno"> 5329</span><span class="stringliteral">    -0.56694968153682723</span></div>
<div class="line"><span class="lineno"> 5330</span><span class="stringliteral">    &gt;&gt;&gt; p_value</span></div>
<div class="line"><span class="lineno"> 5331</span><span class="stringliteral">    nan</span></div>
<div class="line"><span class="lineno"> 5332</span><span class="stringliteral">    &gt;&gt;&gt; tau, p_value = stats.weightedtau(x, y, additive=False)</span></div>
<div class="line"><span class="lineno"> 5333</span><span class="stringliteral">    &gt;&gt;&gt; tau</span></div>
<div class="line"><span class="lineno"> 5334</span><span class="stringliteral">    -0.62205716951801038</span></div>
<div class="line"><span class="lineno"> 5335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5336</span><span class="stringliteral">    NaNs are considered the smallest possible score:</span></div>
<div class="line"><span class="lineno"> 5337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5338</span><span class="stringliteral">    &gt;&gt;&gt; x = [12, 2, 1, 12, 2]</span></div>
<div class="line"><span class="lineno"> 5339</span><span class="stringliteral">    &gt;&gt;&gt; y = [1, 4, 7, 1, np.nan]</span></div>
<div class="line"><span class="lineno"> 5340</span><span class="stringliteral">    &gt;&gt;&gt; tau, _ = stats.weightedtau(x, y)</span></div>
<div class="line"><span class="lineno"> 5341</span><span class="stringliteral">    &gt;&gt;&gt; tau</span></div>
<div class="line"><span class="lineno"> 5342</span><span class="stringliteral">    -0.56694968153682723</span></div>
<div class="line"><span class="lineno"> 5343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5344</span><span class="stringliteral">    This is exactly Kendall&#39;s tau:</span></div>
<div class="line"><span class="lineno"> 5345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5346</span><span class="stringliteral">    &gt;&gt;&gt; x = [12, 2, 1, 12, 2]</span></div>
<div class="line"><span class="lineno"> 5347</span><span class="stringliteral">    &gt;&gt;&gt; y = [1, 4, 7, 1, 0]</span></div>
<div class="line"><span class="lineno"> 5348</span><span class="stringliteral">    &gt;&gt;&gt; tau, _ = stats.weightedtau(x, y, weigher=lambda x: 1)</span></div>
<div class="line"><span class="lineno"> 5349</span><span class="stringliteral">    &gt;&gt;&gt; tau</span></div>
<div class="line"><span class="lineno"> 5350</span><span class="stringliteral">    -0.47140452079103173</span></div>
<div class="line"><span class="lineno"> 5351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5352</span><span class="stringliteral">    &gt;&gt;&gt; x = [12, 2, 1, 12, 2]</span></div>
<div class="line"><span class="lineno"> 5353</span><span class="stringliteral">    &gt;&gt;&gt; y = [1, 4, 7, 1, 0]</span></div>
<div class="line"><span class="lineno"> 5354</span><span class="stringliteral">    &gt;&gt;&gt; stats.weightedtau(x, y, rank=None)</span></div>
<div class="line"><span class="lineno"> 5355</span><span class="stringliteral">    WeightedTauResult(correlation=-0.4157652301037516, pvalue=nan)</span></div>
<div class="line"><span class="lineno"> 5356</span><span class="stringliteral">    &gt;&gt;&gt; stats.weightedtau(y, x, rank=None)</span></div>
<div class="line"><span class="lineno"> 5357</span><span class="stringliteral">    WeightedTauResult(correlation=-0.7181341329699028, pvalue=nan)</span></div>
<div class="line"><span class="lineno"> 5358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5359</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5360</span>    x = np.asarray(x).ravel()</div>
<div class="line"><span class="lineno"> 5361</span>    y = np.asarray(y).ravel()</div>
<div class="line"><span class="lineno"> 5362</span> </div>
<div class="line"><span class="lineno"> 5363</span>    <span class="keywordflow">if</span> x.size != y.size:</div>
<div class="line"><span class="lineno"> 5364</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;All inputs to `weightedtau` must be &quot;</span></div>
<div class="line"><span class="lineno"> 5365</span>                         <span class="stringliteral">&quot;of the same size, &quot;</span></div>
<div class="line"><span class="lineno"> 5366</span>                         <span class="stringliteral">&quot;found x-size %s and y-size %s&quot;</span> % (x.size, y.size))</div>
<div class="line"><span class="lineno"> 5367</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> x.size:</div>
<div class="line"><span class="lineno"> 5368</span>        <span class="comment"># Return NaN if arrays are empty</span></div>
<div class="line"><span class="lineno"> 5369</span>        <span class="keywordflow">return</span> WeightedTauResult(np.nan, np.nan)</div>
<div class="line"><span class="lineno"> 5370</span> </div>
<div class="line"><span class="lineno"> 5371</span>    <span class="comment"># If there are NaNs we apply _toint64()</span></div>
<div class="line"><span class="lineno"> 5372</span>    <span class="keywordflow">if</span> np.isnan(np.sum(x)):</div>
<div class="line"><span class="lineno"> 5373</span>        x = _toint64(x)</div>
<div class="line"><span class="lineno"> 5374</span>    <span class="keywordflow">if</span> np.isnan(np.sum(y)):</div>
<div class="line"><span class="lineno"> 5375</span>        y = _toint64(y)</div>
<div class="line"><span class="lineno"> 5376</span> </div>
<div class="line"><span class="lineno"> 5377</span>    <span class="comment"># Reduce to ranks unsupported types</span></div>
<div class="line"><span class="lineno"> 5378</span>    <span class="keywordflow">if</span> x.dtype != y.dtype:</div>
<div class="line"><span class="lineno"> 5379</span>        <span class="keywordflow">if</span> x.dtype != np.int64:</div>
<div class="line"><span class="lineno"> 5380</span>            x = _toint64(x)</div>
<div class="line"><span class="lineno"> 5381</span>        <span class="keywordflow">if</span> y.dtype != np.int64:</div>
<div class="line"><span class="lineno"> 5382</span>            y = _toint64(y)</div>
<div class="line"><span class="lineno"> 5383</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5384</span>        <span class="keywordflow">if</span> x.dtype <span class="keywordflow">not</span> <span class="keywordflow">in</span> (np.int32, np.int64, np.float32, np.float64):</div>
<div class="line"><span class="lineno"> 5385</span>            x = _toint64(x)</div>
<div class="line"><span class="lineno"> 5386</span>            y = _toint64(y)</div>
<div class="line"><span class="lineno"> 5387</span> </div>
<div class="line"><span class="lineno"> 5388</span>    <span class="keywordflow">if</span> rank <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno"> 5389</span>        <span class="keywordflow">return</span> WeightedTauResult((</div>
<div class="line"><span class="lineno"> 5390</span>            _weightedrankedtau(x, y, <span class="keywordtype">None</span>, weigher, additive) +</div>
<div class="line"><span class="lineno"> 5391</span>            _weightedrankedtau(y, x, <span class="keywordtype">None</span>, weigher, additive)</div>
<div class="line"><span class="lineno"> 5392</span>        ) / 2, np.nan)</div>
<div class="line"><span class="lineno"> 5393</span> </div>
<div class="line"><span class="lineno"> 5394</span>    <span class="keywordflow">if</span> rank <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno"> 5395</span>        rank = np.arange(x.size, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 5396</span>    <span class="keywordflow">elif</span> rank <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5397</span>        rank = np.asarray(rank).ravel()</div>
<div class="line"><span class="lineno"> 5398</span>        <span class="keywordflow">if</span> rank.size != x.size:</div>
<div class="line"><span class="lineno"> 5399</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 5400</span>                <span class="stringliteral">&quot;All inputs to `weightedtau` must be of the same size, &quot;</span></div>
<div class="line"><span class="lineno"> 5401</span>                <span class="stringliteral">&quot;found x-size %s and rank-size %s&quot;</span> % (x.size, rank.size)</div>
<div class="line"><span class="lineno"> 5402</span>            )</div>
<div class="line"><span class="lineno"> 5403</span> </div>
<div class="line"><span class="lineno"> 5404</span>    <span class="keywordflow">return</span> WeightedTauResult(_weightedrankedtau(x, y, rank, weigher, additive),</div>
<div class="line"><span class="lineno"> 5405</span>                             np.nan)</div>
<div class="line"><span class="lineno"> 5406</span> </div>
<div class="line"><span class="lineno"> 5407</span> </div>
<div class="line"><span class="lineno"> 5408</span><span class="comment"># FROM MGCPY: https://github.com/neurodata/mgcpy</span></div>
<div class="line"><span class="lineno"> 5409</span> </div>
<div class="line"><span class="lineno"> 5410</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abecb96afa85e562e14f2ff4f301a0ef9" name="abecb96afa85e562e14f2ff4f301a0ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecb96afa85e562e14f2ff4f301a0ef9">&#9670;&#160;</a></span>zmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.zmap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the relative z-scores.

Return an array of z-scores, i.e., scores that are standardized to
zero mean and unit variance, where mean and variance are calculated
from the comparison array.

Parameters
----------
scores : array_like
    The input for which z-scores are calculated.
compare : array_like
    The input from which the mean and standard deviation of the
    normalization are taken; assumed to have the same dimension as
    `scores`.
axis : int or None, optional
    Axis over which mean and variance of `compare` are calculated.
    Default is 0. If None, compute over the whole array `scores`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle the occurrence of nans in `compare`.
    'propagate' returns nan, 'raise' raises an exception, 'omit'
    performs the calculations ignoring nan values. Default is
    'propagate'. Note that when the value is 'omit', nans in `scores`
    also propagate to the output, but they do not affect the z-scores
    computed for the non-nan values.

Returns
-------
zscore : array_like
    Z-scores, in the same shape as `scores`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of
`asarray` for parameters).

Examples
--------
&gt;&gt;&gt; from scipy.stats import zmap
&gt;&gt;&gt; a = [0.5, 2.0, 2.5, 3]
&gt;&gt;&gt; b = [0, 1, 2, 3, 4]
&gt;&gt;&gt; zmap(a, b)
array([-1.06066017,  0.        ,  0.35355339,  0.70710678])</pre> <div class="fragment"><div class="line"><span class="lineno"> 2824</span><span class="keyword">def </span>zmap(scores, compare, axis=0, ddof=0, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 2825</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2826</span><span class="stringliteral">    Calculate the relative z-scores.</span></div>
<div class="line"><span class="lineno"> 2827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2828</span><span class="stringliteral">    Return an array of z-scores, i.e., scores that are standardized to</span></div>
<div class="line"><span class="lineno"> 2829</span><span class="stringliteral">    zero mean and unit variance, where mean and variance are calculated</span></div>
<div class="line"><span class="lineno"> 2830</span><span class="stringliteral">    from the comparison array.</span></div>
<div class="line"><span class="lineno"> 2831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2832</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2833</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2834</span><span class="stringliteral">    scores : array_like</span></div>
<div class="line"><span class="lineno"> 2835</span><span class="stringliteral">        The input for which z-scores are calculated.</span></div>
<div class="line"><span class="lineno"> 2836</span><span class="stringliteral">    compare : array_like</span></div>
<div class="line"><span class="lineno"> 2837</span><span class="stringliteral">        The input from which the mean and standard deviation of the</span></div>
<div class="line"><span class="lineno"> 2838</span><span class="stringliteral">        normalization are taken; assumed to have the same dimension as</span></div>
<div class="line"><span class="lineno"> 2839</span><span class="stringliteral">        `scores`.</span></div>
<div class="line"><span class="lineno"> 2840</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 2841</span><span class="stringliteral">        Axis over which mean and variance of `compare` are calculated.</span></div>
<div class="line"><span class="lineno"> 2842</span><span class="stringliteral">        Default is 0. If None, compute over the whole array `scores`.</span></div>
<div class="line"><span class="lineno"> 2843</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 2844</span><span class="stringliteral">        Degrees of freedom correction in the calculation of the</span></div>
<div class="line"><span class="lineno"> 2845</span><span class="stringliteral">        standard deviation. Default is 0.</span></div>
<div class="line"><span class="lineno"> 2846</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2847</span><span class="stringliteral">        Defines how to handle the occurrence of nans in `compare`.</span></div>
<div class="line"><span class="lineno"> 2848</span><span class="stringliteral">        &#39;propagate&#39; returns nan, &#39;raise&#39; raises an exception, &#39;omit&#39;</span></div>
<div class="line"><span class="lineno"> 2849</span><span class="stringliteral">        performs the calculations ignoring nan values. Default is</span></div>
<div class="line"><span class="lineno"> 2850</span><span class="stringliteral">        &#39;propagate&#39;. Note that when the value is &#39;omit&#39;, nans in `scores`</span></div>
<div class="line"><span class="lineno"> 2851</span><span class="stringliteral">        also propagate to the output, but they do not affect the z-scores</span></div>
<div class="line"><span class="lineno"> 2852</span><span class="stringliteral">        computed for the non-nan values.</span></div>
<div class="line"><span class="lineno"> 2853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2854</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2855</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2856</span><span class="stringliteral">    zscore : array_like</span></div>
<div class="line"><span class="lineno"> 2857</span><span class="stringliteral">        Z-scores, in the same shape as `scores`.</span></div>
<div class="line"><span class="lineno"> 2858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2859</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2860</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2861</span><span class="stringliteral">    This function preserves ndarray subclasses, and works also with</span></div>
<div class="line"><span class="lineno"> 2862</span><span class="stringliteral">    matrices and masked arrays (it uses `asanyarray` instead of</span></div>
<div class="line"><span class="lineno"> 2863</span><span class="stringliteral">    `asarray` for parameters).</span></div>
<div class="line"><span class="lineno"> 2864</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2865</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2866</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2867</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import zmap</span></div>
<div class="line"><span class="lineno"> 2868</span><span class="stringliteral">    &gt;&gt;&gt; a = [0.5, 2.0, 2.5, 3]</span></div>
<div class="line"><span class="lineno"> 2869</span><span class="stringliteral">    &gt;&gt;&gt; b = [0, 1, 2, 3, 4]</span></div>
<div class="line"><span class="lineno"> 2870</span><span class="stringliteral">    &gt;&gt;&gt; zmap(a, b)</span></div>
<div class="line"><span class="lineno"> 2871</span><span class="stringliteral">    array([-1.06066017,  0.        ,  0.35355339,  0.70710678])</span></div>
<div class="line"><span class="lineno"> 2872</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2873</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2874</span>    a = np.asanyarray(compare)</div>
<div class="line"><span class="lineno"> 2875</span> </div>
<div class="line"><span class="lineno"> 2876</span>    <span class="keywordflow">if</span> a.size == 0:</div>
<div class="line"><span class="lineno"> 2877</span>        <span class="keywordflow">return</span> np.empty(a.shape)</div>
<div class="line"><span class="lineno"> 2878</span> </div>
<div class="line"><span class="lineno"> 2879</span>    contains_nan, nan_policy = _contains_nan(a, nan_policy)</div>
<div class="line"><span class="lineno"> 2880</span> </div>
<div class="line"><span class="lineno"> 2881</span>    <span class="keywordflow">if</span> contains_nan <span class="keywordflow">and</span> nan_policy == <span class="stringliteral">&#39;omit&#39;</span>:</div>
<div class="line"><span class="lineno"> 2882</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2883</span>            mn = _quiet_nanmean(a.ravel())</div>
<div class="line"><span class="lineno"> 2884</span>            std = _quiet_nanstd(a.ravel(), ddof=ddof)</div>
<div class="line"><span class="lineno"> 2885</span>            isconst = _isconst(a.ravel())</div>
<div class="line"><span class="lineno"> 2886</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2887</span>            mn = np.apply_along_axis(_quiet_nanmean, axis, a)</div>
<div class="line"><span class="lineno"> 2888</span>            std = np.apply_along_axis(_quiet_nanstd, axis, a, ddof=ddof)</div>
<div class="line"><span class="lineno"> 2889</span>            isconst = np.apply_along_axis(_isconst, axis, a)</div>
<div class="line"><span class="lineno"> 2890</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2891</span>        mn = a.mean(axis=axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2892</span>        std = a.std(axis=axis, ddof=ddof, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2893</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2894</span>            isconst = (a.item(0) == a).all()</div>
<div class="line"><span class="lineno"> 2895</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2896</span>            isconst = (_first(a, axis) == a).all(axis=axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2897</span> </div>
<div class="line"><span class="lineno"> 2898</span>    <span class="comment"># Set std deviations that are 0 to 1 to avoid division by 0.</span></div>
<div class="line"><span class="lineno"> 2899</span>    std[isconst] = 1.0</div>
<div class="line"><span class="lineno"> 2900</span>    z = (scores - mn) / std</div>
<div class="line"><span class="lineno"> 2901</span>    <span class="comment"># Set the outputs associated with a constant input to nan.</span></div>
<div class="line"><span class="lineno"> 2902</span>    z[np.broadcast_to(isconst, z.shape)] = np.nan</div>
<div class="line"><span class="lineno"> 2903</span>    <span class="keywordflow">return</span> z</div>
<div class="line"><span class="lineno"> 2904</span> </div>
<div class="line"><span class="lineno"> 2905</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a40557c1c2fd14506e84aa782a7382f68" name="a40557c1c2fd14506e84aa782a7382f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40557c1c2fd14506e84aa782a7382f68">&#9670;&#160;</a></span>zscore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.zscore </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nan_policy</em> = <code>'propagate'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the z score.

Compute the z score of each value in the sample, relative to the
sample mean and standard deviation.

Parameters
----------
a : array_like
    An array like object containing the sample data.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.  Note that when the value is 'omit',
    nans in the input also propagate to the output, but they do not affect
    the z-scores computed for the non-nan values.

Returns
-------
zscore : array_like
    The z-scores, standardized by mean and standard deviation of
    input array `a`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of
`asarray` for parameters).

Examples
--------
&gt;&gt;&gt; a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,
...                0.1954,  0.6307,  0.6599,  0.1065,  0.0508])
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.zscore(a)
array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,
        0.6748, -1.1488, -1.3324])

Computing along a specified axis, using n-1 degrees of freedom
(``ddof=1``) to calculate the standard deviation:

&gt;&gt;&gt; b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],
...               [ 0.7149,  0.0775,  0.6072,  0.9656],
...               [ 0.6341,  0.1403,  0.9759,  0.4064],
...               [ 0.5918,  0.6948,  0.904 ,  0.3721],
...               [ 0.0921,  0.2481,  0.1188,  0.1366]])
&gt;&gt;&gt; stats.zscore(b, axis=1, ddof=1)
array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358],
       [ 0.33048416, -1.37380874,  0.04251374,  1.00081084],
       [ 0.26796377, -1.12598418,  1.23283094, -0.37481053],
       [-0.22095197,  0.24468594,  1.19042819, -1.21416216],
       [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]])

An example with `nan_policy='omit'`:

&gt;&gt;&gt; x = np.array([[25.11, 30.10, np.nan, 32.02, 43.15],
...               [14.95, 16.06, 121.25, 94.35, 29.81]])
&gt;&gt;&gt; stats.zscore(x, axis=1, nan_policy='omit')
array([[-1.13490897, -0.37830299,         nan, -0.08718406,  1.60039602],
       [-0.91611681, -0.89090508,  1.4983032 ,  0.88731639, -0.5785977 ]])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2665</span><span class="keyword">def </span>zscore(a, axis=0, ddof=0, nan_policy=&#39;propagate&#39;):</div>
<div class="line"><span class="lineno"> 2666</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2667</span><span class="stringliteral">    Compute the z score.</span></div>
<div class="line"><span class="lineno"> 2668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2669</span><span class="stringliteral">    Compute the z score of each value in the sample, relative to the</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral">    sample mean and standard deviation.</span></div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">        An array like object containing the sample data.</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral">    axis : int or None, optional</span></div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral">        Axis along which to operate. Default is 0. If None, compute over</span></div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral">        the whole array `a`.</span></div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">        Degrees of freedom correction in the calculation of the</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral">        standard deviation. Default is 0.</span></div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral">    nan_policy : {&#39;propagate&#39;, &#39;raise&#39;, &#39;omit&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral">        Defines how to handle when input contains nan. &#39;propagate&#39; returns nan,</span></div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">        &#39;raise&#39; throws an error, &#39;omit&#39; performs the calculations ignoring nan</span></div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral">        values. Default is &#39;propagate&#39;.  Note that when the value is &#39;omit&#39;,</span></div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral">        nans in the input also propagate to the output, but they do not affect</span></div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral">        the z-scores computed for the non-nan values.</span></div>
<div class="line"><span class="lineno"> 2688</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2689</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2690</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2691</span><span class="stringliteral">    zscore : array_like</span></div>
<div class="line"><span class="lineno"> 2692</span><span class="stringliteral">        The z-scores, standardized by mean and standard deviation of</span></div>
<div class="line"><span class="lineno"> 2693</span><span class="stringliteral">        input array `a`.</span></div>
<div class="line"><span class="lineno"> 2694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2695</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2696</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2697</span><span class="stringliteral">    This function preserves ndarray subclasses, and works also with</span></div>
<div class="line"><span class="lineno"> 2698</span><span class="stringliteral">    matrices and masked arrays (it uses `asanyarray` instead of</span></div>
<div class="line"><span class="lineno"> 2699</span><span class="stringliteral">    `asarray` for parameters).</span></div>
<div class="line"><span class="lineno"> 2700</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2701</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2702</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2703</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,</span></div>
<div class="line"><span class="lineno"> 2704</span><span class="stringliteral">    ...                0.1954,  0.6307,  0.6599,  0.1065,  0.0508])</span></div>
<div class="line"><span class="lineno"> 2705</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno"> 2706</span><span class="stringliteral">    &gt;&gt;&gt; stats.zscore(a)</span></div>
<div class="line"><span class="lineno"> 2707</span><span class="stringliteral">    array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,</span></div>
<div class="line"><span class="lineno"> 2708</span><span class="stringliteral">            0.6748, -1.1488, -1.3324])</span></div>
<div class="line"><span class="lineno"> 2709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2710</span><span class="stringliteral">    Computing along a specified axis, using n-1 degrees of freedom</span></div>
<div class="line"><span class="lineno"> 2711</span><span class="stringliteral">    (``ddof=1``) to calculate the standard deviation:</span></div>
<div class="line"><span class="lineno"> 2712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2713</span><span class="stringliteral">    &gt;&gt;&gt; b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],</span></div>
<div class="line"><span class="lineno"> 2714</span><span class="stringliteral">    ...               [ 0.7149,  0.0775,  0.6072,  0.9656],</span></div>
<div class="line"><span class="lineno"> 2715</span><span class="stringliteral">    ...               [ 0.6341,  0.1403,  0.9759,  0.4064],</span></div>
<div class="line"><span class="lineno"> 2716</span><span class="stringliteral">    ...               [ 0.5918,  0.6948,  0.904 ,  0.3721],</span></div>
<div class="line"><span class="lineno"> 2717</span><span class="stringliteral">    ...               [ 0.0921,  0.2481,  0.1188,  0.1366]])</span></div>
<div class="line"><span class="lineno"> 2718</span><span class="stringliteral">    &gt;&gt;&gt; stats.zscore(b, axis=1, ddof=1)</span></div>
<div class="line"><span class="lineno"> 2719</span><span class="stringliteral">    array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358],</span></div>
<div class="line"><span class="lineno"> 2720</span><span class="stringliteral">           [ 0.33048416, -1.37380874,  0.04251374,  1.00081084],</span></div>
<div class="line"><span class="lineno"> 2721</span><span class="stringliteral">           [ 0.26796377, -1.12598418,  1.23283094, -0.37481053],</span></div>
<div class="line"><span class="lineno"> 2722</span><span class="stringliteral">           [-0.22095197,  0.24468594,  1.19042819, -1.21416216],</span></div>
<div class="line"><span class="lineno"> 2723</span><span class="stringliteral">           [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]])</span></div>
<div class="line"><span class="lineno"> 2724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral">    An example with `nan_policy=&#39;omit&#39;`:</span></div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[25.11, 30.10, np.nan, 32.02, 43.15],</span></div>
<div class="line"><span class="lineno"> 2728</span><span class="stringliteral">    ...               [14.95, 16.06, 121.25, 94.35, 29.81]])</span></div>
<div class="line"><span class="lineno"> 2729</span><span class="stringliteral">    &gt;&gt;&gt; stats.zscore(x, axis=1, nan_policy=&#39;omit&#39;)</span></div>
<div class="line"><span class="lineno"> 2730</span><span class="stringliteral">    array([[-1.13490897, -0.37830299,         nan, -0.08718406,  1.60039602],</span></div>
<div class="line"><span class="lineno"> 2731</span><span class="stringliteral">           [-0.91611681, -0.89090508,  1.4983032 ,  0.88731639, -0.5785977 ]])</span></div>
<div class="line"><span class="lineno"> 2732</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2733</span>    <span class="keywordflow">return</span> zmap(a, a, axis=axis, ddof=ddof, nan_policy=nan_policy)</div>
<div class="line"><span class="lineno"> 2734</span> </div>
<div class="line"><span class="lineno"> 2735</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8a1eac21b5e82f9848b2523b6b90995e" name="a8a1eac21b5e82f9848b2523b6b90995e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1eac21b5e82f9848b2523b6b90995e">&#9670;&#160;</a></span>_power_div_lambda_names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.stats._stats_py._power_div_lambda_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;pearson&quot;</span>: 1,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;log-likelihood&quot;</span>: 0,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;freeman-tukey&quot;</span>: -0.5,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;mod-log-likelihood&quot;</span>: -1,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;neyman&quot;</span>: -2,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;cressie-read&quot;</span>: 2/3,</div>
<div class="line"><span class="lineno">    8</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d8ab9655add9064cf78ddbfc338cbb2" name="a1d8ab9655add9064cf78ddbfc338cbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8ab9655add9064cf78ddbfc338cbb2">&#9670;&#160;</a></span>_scale_conversions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.stats._stats_py._scale_conversions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {<span class="stringliteral">&#39;raw&#39;</span>: 1.0,</div>
<div class="line"><span class="lineno">    2</span>                      <span class="stringliteral">&#39;normal&#39;</span>: special.erfinv(0.5) * 2.0 * math.sqrt(2.0)}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7648a89e048475c07fbb825533e786c" name="ae7648a89e048475c07fbb825533e786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7648a89e048475c07fbb825533e786c">&#9670;&#160;</a></span>AlexanderGovernResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.AlexanderGovernResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  make_dataclass(<span class="stringliteral">&quot;AlexanderGovernResult&quot;</span>, (<span class="stringliteral">&quot;statistic&quot;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                                                 <span class="stringliteral">&quot;pvalue&quot;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a084547535521fc8a4e2ca13da7ccf236" name="a084547535521fc8a4e2ca13da7ccf236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084547535521fc8a4e2ca13da7ccf236">&#9670;&#160;</a></span>BrunnerMunzelResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.BrunnerMunzelResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;BrunnerMunzelResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                 (<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;pvalue&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4b1ccd5e913ab32dee4d40b27b90992" name="ae4b1ccd5e913ab32dee4d40b27b90992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1ccd5e913ab32dee4d40b27b90992">&#9670;&#160;</a></span>ConfidenceInterval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ConfidenceInterval = namedtuple('ConfidenceInterval', ['low', 'high'])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a75604ce103a4f3a8661da14b41ba21" name="a1a75604ce103a4f3a8661da14b41ba21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a75604ce103a4f3a8661da14b41ba21">&#9670;&#160;</a></span>CumfreqResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.CumfreqResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;CumfreqResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                           (<span class="stringliteral">&#39;cumcount&#39;</span>, <span class="stringliteral">&#39;lowerlimit&#39;</span>, <span class="stringliteral">&#39;binsize&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                            <span class="stringliteral">&#39;extrapoints&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad17cbb60a06b3b961b8d3dec3f75f571" name="ad17cbb60a06b3b961b8d3dec3f75f571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17cbb60a06b3b961b8d3dec3f75f571">&#9670;&#160;</a></span>DescribeResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.DescribeResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;DescribeResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                            (<span class="stringliteral">&#39;nobs&#39;</span>, <span class="stringliteral">&#39;minmax&#39;</span>, <span class="stringliteral">&#39;mean&#39;</span>, <span class="stringliteral">&#39;variance&#39;</span>, <span class="stringliteral">&#39;skewness&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                             <span class="stringliteral">&#39;kurtosis&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a55dd91ad97a133a4f1c4014a850145ea" name="a55dd91ad97a133a4f1c4014a850145ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dd91ad97a133a4f1c4014a850145ea">&#9670;&#160;</a></span>F_onewayResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.F_onewayResult = namedtuple('F_onewayResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf31b33400d148f6ef0e0f3b66f5d2be" name="acf31b33400d148f6ef0e0f3b66f5d2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf31b33400d148f6ef0e0f3b66f5d2be">&#9670;&#160;</a></span>FriedmanchisquareResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.FriedmanchisquareResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;FriedmanchisquareResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                     (<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;pvalue&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a159d3500af93794f6cb4a9f959924bb5" name="a159d3500af93794f6cb4a9f959924bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159d3500af93794f6cb4a9f959924bb5">&#9670;&#160;</a></span>HistogramResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.HistogramResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;HistogramResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                             (<span class="stringliteral">&#39;count&#39;</span>, <span class="stringliteral">&#39;lowerlimit&#39;</span>, <span class="stringliteral">&#39;binsize&#39;</span>, <span class="stringliteral">&#39;extrapoints&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f439a7f7f10dd8205b17d45c2fb86b2" name="a1f439a7f7f10dd8205b17d45c2fb86b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f439a7f7f10dd8205b17d45c2fb86b2">&#9670;&#160;</a></span>Jarque_beraResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.Jarque_beraResult = namedtuple('Jarque_beraResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aec35f18fcad0d467a2f475f4e88e5b" name="a4aec35f18fcad0d467a2f475f4e88e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aec35f18fcad0d467a2f475f4e88e5b">&#9670;&#160;</a></span>KendalltauResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.KendalltauResult = namedtuple('KendalltauResult', ('correlation', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9cba6ca5b344ceda11181bcd5f6adea" name="ac9cba6ca5b344ceda11181bcd5f6adea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cba6ca5b344ceda11181bcd5f6adea">&#9670;&#160;</a></span>KruskalResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.KruskalResult = namedtuple('KruskalResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c3e4d7762108939709c279fff05dcb4" name="a4c3e4d7762108939709c279fff05dcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3e4d7762108939709c279fff05dcb4">&#9670;&#160;</a></span>Ks_2sampResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.Ks_2sampResult = <a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#af6c2563e8e2c6e7d3e19fa32131a6796">KstestResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6c2563e8e2c6e7d3e19fa32131a6796" name="af6c2563e8e2c6e7d3e19fa32131a6796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c2563e8e2c6e7d3e19fa32131a6796">&#9670;&#160;</a></span>KstestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.KstestResult = namedtuple('KstestResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4db485cb945393c294a5defd286e49bb" name="a4db485cb945393c294a5defd286e49bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db485cb945393c294a5defd286e49bb">&#9670;&#160;</a></span>KurtosistestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.KurtosistestResult = namedtuple('KurtosistestResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79b67a68f52e541cf43ed09574e13108" name="a79b67a68f52e541cf43ed09574e13108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b67a68f52e541cf43ed09574e13108">&#9670;&#160;</a></span>MGCResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.MGCResult = namedtuple('MGCResult', ('stat', 'pvalue', 'mgc_dict'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8276a1473f84d29df1cfb05a798c6c86" name="a8276a1473f84d29df1cfb05a798c6c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8276a1473f84d29df1cfb05a798c6c86">&#9670;&#160;</a></span>ModeResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.ModeResult = namedtuple('ModeResult', ('<a class="el" href="namespacescipy_1_1stats_1_1__stats__py.html#ad7666823299f40b492d638a114d2fc91">mode</a>', 'count'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ecccad49a9bf1d4db7baeba60ed6c54" name="a7ecccad49a9bf1d4db7baeba60ed6c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecccad49a9bf1d4db7baeba60ed6c54">&#9670;&#160;</a></span>NormaltestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.NormaltestResult = namedtuple('NormaltestResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad063c82a38b3f71d713793c4565ca702" name="ad063c82a38b3f71d713793c4565ca702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad063c82a38b3f71d713793c4565ca702">&#9670;&#160;</a></span>PearsonRResultBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.PearsonRResultBase</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  _make_tuple_bunch(<span class="stringliteral">&#39;PearsonRResultBase&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                       [<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;pvalue&#39;</span>], [])</div>
</div><!-- fragment -->
</div>
</div>
<a id="a913606dcc240c37cbf6afcf2792f5953" name="a913606dcc240c37cbf6afcf2792f5953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913606dcc240c37cbf6afcf2792f5953">&#9670;&#160;</a></span>PointbiserialrResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.PointbiserialrResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;PointbiserialrResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                  (<span class="stringliteral">&#39;correlation&#39;</span>, <span class="stringliteral">&#39;pvalue&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b74f644917a36fcd23aa95f48810815" name="a0b74f644917a36fcd23aa95f48810815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b74f644917a36fcd23aa95f48810815">&#9670;&#160;</a></span>Power_divergenceResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.Power_divergenceResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;Power_divergenceResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                    (<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;pvalue&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13929c3e11b3aea010483ae368fdeeea" name="a13929c3e11b3aea010483ae368fdeeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13929c3e11b3aea010483ae368fdeeea">&#9670;&#160;</a></span>RanksumsResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.RanksumsResult = namedtuple('RanksumsResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0739c0c0192b367b27d6d1fc6b076469" name="a0739c0c0192b367b27d6d1fc6b076469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0739c0c0192b367b27d6d1fc6b076469">&#9670;&#160;</a></span>RelfreqResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.RelfreqResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  namedtuple(<span class="stringliteral">&#39;RelfreqResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                           (<span class="stringliteral">&#39;frequency&#39;</span>, <span class="stringliteral">&#39;lowerlimit&#39;</span>, <span class="stringliteral">&#39;binsize&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                            <span class="stringliteral">&#39;extrapoints&#39;</span>))</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5abc71d3f4e3d43499eea3985b7d2bd9" name="a5abc71d3f4e3d43499eea3985b7d2bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abc71d3f4e3d43499eea3985b7d2bd9">&#9670;&#160;</a></span>RepeatedResults</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.RepeatedResults = namedtuple('RepeatedResults', ('values', 'counts'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPORT FUNCTIONS #. </p>

</div>
</div>
<a id="ade3bb71bac397106f36f0ebe2f76ff8e" name="ade3bb71bac397106f36f0ebe2f76ff8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3bb71bac397106f36f0ebe2f76ff8e">&#9670;&#160;</a></span>SigmaclipResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.SigmaclipResult = namedtuple('SigmaclipResult', ('clipped', 'lower', 'upper'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRIMMING FUNCTIONS #. </p>

</div>
</div>
<a id="a517833de500c51cf8468fe2ccee2b20d" name="a517833de500c51cf8468fe2ccee2b20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517833de500c51cf8468fe2ccee2b20d">&#9670;&#160;</a></span>SkewtestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.SkewtestResult = namedtuple('SkewtestResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af65c21aa9410cca040a193a63e87a6d7" name="af65c21aa9410cca040a193a63e87a6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65c21aa9410cca040a193a63e87a6d7">&#9670;&#160;</a></span>SpearmanrResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.SpearmanrResult = namedtuple('SpearmanrResult', ('correlation', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea14330e23d04b115bb0ff1ea380077b" name="aea14330e23d04b115bb0ff1ea380077b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea14330e23d04b115bb0ff1ea380077b">&#9670;&#160;</a></span>Ttest_1sampResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.Ttest_1sampResult = namedtuple('Ttest_1sampResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INFERENTIAL STATISTICS #. </p>

</div>
</div>
<a id="ab6b754f522c03e7fccd72c806de40407" name="ab6b754f522c03e7fccd72c806de40407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b754f522c03e7fccd72c806de40407">&#9670;&#160;</a></span>Ttest_indResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.Ttest_indResult = namedtuple('Ttest_indResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38f00b9b1e4a728af7bbdd4d515a7cf3" name="a38f00b9b1e4a728af7bbdd4d515a7cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f00b9b1e4a728af7bbdd4d515a7cf3">&#9670;&#160;</a></span>Ttest_relResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.Ttest_relResult = namedtuple('Ttest_relResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a930e1fabe137790d52534b714cb17086" name="a930e1fabe137790d52534b714cb17086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930e1fabe137790d52534b714cb17086">&#9670;&#160;</a></span>WeightedTauResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._stats_py.WeightedTauResult = namedtuple('WeightedTauResult', ('correlation', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
