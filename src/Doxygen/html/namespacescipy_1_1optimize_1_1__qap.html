<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.optimize._qap Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize.html">optimize</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html">_qap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.optimize._qap Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2959c444bf05aae8a053622af4604225" id="r_a2959c444bf05aae8a053622af4604225"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#a2959c444bf05aae8a053622af4604225">quadratic_assignment</a> (A, B, method=&quot;faq&quot;, options=None)</td></tr>
<tr class="separator:a2959c444bf05aae8a053622af4604225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d86e2d1d800e47ad5cd633795402136" id="r_a2d86e2d1d800e47ad5cd633795402136"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#a2d86e2d1d800e47ad5cd633795402136">_calc_score</a> (A, B, <a class="el" href="__lapack__subroutines_8h.html#a9e6462b0eba13e8719a5f38757e3e4bf">perm</a>)</td></tr>
<tr class="separator:a2d86e2d1d800e47ad5cd633795402136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809166fe4f0d79150501f209db683b1e" id="r_a809166fe4f0d79150501f209db683b1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#a809166fe4f0d79150501f209db683b1e">_common_input_validation</a> (A, B, partial_match)</td></tr>
<tr class="separator:a809166fe4f0d79150501f209db683b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132c802ac6681b031289b29b4fb174ab" id="r_a132c802ac6681b031289b29b4fb174ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#a132c802ac6681b031289b29b4fb174ab">_quadratic_assignment_faq</a> (A, B, maximize=False, partial_match=None, rng=None, P0=&quot;barycenter&quot;, shuffle_input=False, maxiter=30, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=0.03, **unknown_options)</td></tr>
<tr class="separator:a132c802ac6681b031289b29b4fb174ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9da94c34932b2d0fc5bd81eef491fc4" id="r_ac9da94c34932b2d0fc5bd81eef491fc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#ac9da94c34932b2d0fc5bd81eef491fc4">_split_matrix</a> (X, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>)</td></tr>
<tr class="separator:ac9da94c34932b2d0fc5bd81eef491fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b00250f299ca97b1105e4b2c377612" id="r_a24b00250f299ca97b1105e4b2c377612"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#a24b00250f299ca97b1105e4b2c377612">_doubly_stochastic</a> (P, <a class="el" href="__lapack__subroutines_8h.html#a0357339a1a1f7b51953875ca01447445">tol</a>=1e-3)</td></tr>
<tr class="separator:a24b00250f299ca97b1105e4b2c377612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906721e33d99994257bbc8b669be9bbc" id="r_a906721e33d99994257bbc8b669be9bbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#a906721e33d99994257bbc8b669be9bbc">_quadratic_assignment_2opt</a> (A, B, maximize=False, rng=None, partial_match=None, partial_guess=None, **unknown_options)</td></tr>
<tr class="separator:a906721e33d99994257bbc8b669be9bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad84a6142cd672b33e901655df3c15f61" id="r_ad84a6142cd672b33e901655df3c15f61"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__qap.html#ad84a6142cd672b33e901655df3c15f61">QUADRATIC_ASSIGNMENT_METHODS</a> = ['faq', '2opt']</td></tr>
<tr class="separator:ad84a6142cd672b33e901655df3c15f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d86e2d1d800e47ad5cd633795402136" name="a2d86e2d1d800e47ad5cd633795402136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d86e2d1d800e47ad5cd633795402136">&#9670;&#160;</a></span>_calc_score()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._qap._calc_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  194</span><span class="keyword">def </span>_calc_score(A, B, perm):</div>
<div class="line"><span class="lineno">  195</span>    <span class="comment"># equivalent to objective function but avoids matmul</span></div>
<div class="line"><span class="lineno">  196</span>    <span class="keywordflow">return</span> np.sum(A * B[perm][:, perm])</div>
<div class="line"><span class="lineno">  197</span> </div>
<div class="line"><span class="lineno">  198</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a809166fe4f0d79150501f209db683b1e" name="a809166fe4f0d79150501f209db683b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809166fe4f0d79150501f209db683b1e">&#9670;&#160;</a></span>_common_input_validation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._qap._common_input_validation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partial_match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  199</span><span class="keyword">def </span>_common_input_validation(A, B, partial_match):</div>
<div class="line"><span class="lineno">  200</span>    A = np.atleast_2d(A)</div>
<div class="line"><span class="lineno">  201</span>    B = np.atleast_2d(B)</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">if</span> partial_match <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  204</span>        partial_match = np.array([[], []]).T</div>
<div class="line"><span class="lineno">  205</span>    partial_match = np.atleast_2d(partial_match).astype(int)</div>
<div class="line"><span class="lineno">  206</span> </div>
<div class="line"><span class="lineno">  207</span>    msg = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordflow">if</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  209</span>        msg = <span class="stringliteral">&quot;`A` must be square&quot;</span></div>
<div class="line"><span class="lineno">  210</span>    <span class="keywordflow">elif</span> B.shape[0] != B.shape[1]:</div>
<div class="line"><span class="lineno">  211</span>        msg = <span class="stringliteral">&quot;`B` must be square&quot;</span></div>
<div class="line"><span class="lineno">  212</span>    <span class="keywordflow">elif</span> A.ndim != 2 <span class="keywordflow">or</span> B.ndim != 2:</div>
<div class="line"><span class="lineno">  213</span>        msg = <span class="stringliteral">&quot;`A` and `B` must have exactly two dimensions&quot;</span></div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">elif</span> A.shape != B.shape:</div>
<div class="line"><span class="lineno">  215</span>        msg = <span class="stringliteral">&quot;`A` and `B` matrices must be of equal size&quot;</span></div>
<div class="line"><span class="lineno">  216</span>    <span class="keywordflow">elif</span> partial_match.shape[0] &gt; A.shape[0]:</div>
<div class="line"><span class="lineno">  217</span>        msg = <span class="stringliteral">&quot;`partial_match` can have only as many seeds as there are nodes&quot;</span></div>
<div class="line"><span class="lineno">  218</span>    <span class="keywordflow">elif</span> partial_match.shape[1] != 2:</div>
<div class="line"><span class="lineno">  219</span>        msg = <span class="stringliteral">&quot;`partial_match` must have two columns&quot;</span></div>
<div class="line"><span class="lineno">  220</span>    <span class="keywordflow">elif</span> partial_match.ndim != 2:</div>
<div class="line"><span class="lineno">  221</span>        msg = <span class="stringliteral">&quot;`partial_match` must have exactly two dimensions&quot;</span></div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">elif</span> (partial_match &lt; 0).any():</div>
<div class="line"><span class="lineno">  223</span>        msg = <span class="stringliteral">&quot;`partial_match` must contain only positive indices&quot;</span></div>
<div class="line"><span class="lineno">  224</span>    <span class="keywordflow">elif</span> (partial_match &gt;= len(A)).any():</div>
<div class="line"><span class="lineno">  225</span>        msg = <span class="stringliteral">&quot;`partial_match` entries must be less than number of nodes&quot;</span></div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">elif</span> (<span class="keywordflow">not</span> len(set(partial_match[:, 0])) == len(partial_match[:, 0]) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  227</span>          <span class="keywordflow">not</span> len(set(partial_match[:, 1])) == len(partial_match[:, 1])):</div>
<div class="line"><span class="lineno">  228</span>        msg = <span class="stringliteral">&quot;`partial_match` column entries must be unique&quot;</span></div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>    <span class="keywordflow">if</span> msg <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  231</span>        <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  232</span> </div>
<div class="line"><span class="lineno">  233</span>    <span class="keywordflow">return</span> A, B, partial_match</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a24b00250f299ca97b1105e4b2c377612" name="a24b00250f299ca97b1105e4b2c377612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b00250f299ca97b1105e4b2c377612">&#9670;&#160;</a></span>_doubly_stochastic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._qap._doubly_stochastic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  517</span><span class="keyword">def </span>_doubly_stochastic(P, tol=1e-3):</div>
<div class="line"><span class="lineno">  518</span>    <span class="comment"># Adapted from @btaba implementation</span></div>
<div class="line"><span class="lineno">  519</span>    <span class="comment"># https://github.com/btaba/sinkhorn_knopp</span></div>
<div class="line"><span class="lineno">  520</span>    <span class="comment"># of Sinkhorn-Knopp algorithm</span></div>
<div class="line"><span class="lineno">  521</span>    <span class="comment"># https://projecteuclid.org/euclid.pjm/1102992505</span></div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span>    max_iter = 1000</div>
<div class="line"><span class="lineno">  524</span>    c = 1 / P.sum(axis=0)</div>
<div class="line"><span class="lineno">  525</span>    r = 1 / (P @ c)</div>
<div class="line"><span class="lineno">  526</span>    P_eps = P</div>
<div class="line"><span class="lineno">  527</span> </div>
<div class="line"><span class="lineno">  528</span>    <span class="keywordflow">for</span> it <span class="keywordflow">in</span> range(max_iter):</div>
<div class="line"><span class="lineno">  529</span>        <span class="keywordflow">if</span> ((np.abs(P_eps.sum(axis=1) - 1) &lt; tol).all() <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  530</span>                (np.abs(P_eps.sum(axis=0) - 1) &lt; tol).all()):</div>
<div class="line"><span class="lineno">  531</span>            <span class="comment"># All column/row sums ~= 1 within threshold</span></div>
<div class="line"><span class="lineno">  532</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  533</span> </div>
<div class="line"><span class="lineno">  534</span>        c = 1 / (r @ P)</div>
<div class="line"><span class="lineno">  535</span>        r = 1 / (P @ c)</div>
<div class="line"><span class="lineno">  536</span>        P_eps = r[:, <span class="keywordtype">None</span>] * P * c</div>
<div class="line"><span class="lineno">  537</span> </div>
<div class="line"><span class="lineno">  538</span>    <span class="keywordflow">return</span> P_eps</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a906721e33d99994257bbc8b669be9bbc" name="a906721e33d99994257bbc8b669be9bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906721e33d99994257bbc8b669be9bbc">&#9670;&#160;</a></span>_quadratic_assignment_2opt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._qap._quadratic_assignment_2opt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maximize</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partial_match</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partial_guess</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>unknown_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Solve the quadratic assignment problem (approximately).

This function solves the Quadratic Assignment Problem (QAP) and the
Graph Matching Problem (GMP) using the 2-opt algorithm [1]_.

Quadratic assignment solves problems of the following form:

.. math::

\min_P &amp; \ {\ \text{trace}(A^T P B P^T)}\\
\mbox{s.t. } &amp; {P \ \epsilon \ \mathcal{P}}\\

where :math:`\mathcal{P}` is the set of all permutation matrices,
and :math:`A` and :math:`B` are square matrices.

Graph matching tries to *maximize* the same objective function.
This algorithm can be thought of as finding the alignment of the
nodes of two graphs that minimizes the number of induced edge
disagreements, or, in the case of weighted graphs, the sum of squared
edge weight differences.

Note that the quadratic assignment problem is NP-hard. The results given
here are approximations and are not guaranteed to be optimal.

Parameters
----------
A : 2-D array, square
The square matrix :math:`A` in the objective function above.
B : 2-D array, square
The square matrix :math:`B` in the objective function above.
method :  str in {'faq', '2opt'} (default: 'faq')
The algorithm used to solve the problem. This is the method-specific
documentation for '2opt'.
:ref:`'faq' &lt;optimize.qap-faq&gt;` is also available.

Options
-------
maximize : bool (default: False)
Maximizes the objective function if ``True``.
rng : {None, int, `numpy.random.Generator`,
`numpy.random.RandomState`}, optional

If `seed` is None (or `np.random`), the `numpy.random.RandomState`
singleton is used.
If `seed` is an int, a new ``RandomState`` instance is used,
seeded with `seed`.
If `seed` is already a ``Generator`` or ``RandomState`` instance then
that instance is used.
partial_match : 2-D array of integers, optional (default: None)
Fixes part of the matching. Also known as a "seed" [2]_.

Each row of `partial_match` specifies a pair of matched nodes: node
``partial_match[i, 0]`` of `A` is matched to node
``partial_match[i, 1]`` of `B`. The array has shape ``(m, 2)``,
where ``m`` is not greater than the number of nodes, :math:`n`.
partial_guess : 2-D array of integers, optional (default: None)
A guess for the matching between the two matrices. Unlike
`partial_match`, `partial_guess` does not fix the indices; they are
still free to be optimized.

Each row of `partial_guess` specifies a pair of matched nodes: node
``partial_guess[i, 0]`` of `A` is matched to node
``partial_guess[i, 1]`` of `B`. The array has shape ``(m, 2)``,
where ``m`` is not greater than the number of nodes, :math:`n`.

Returns
-------
res : OptimizeResult
`OptimizeResult` containing the following fields.

col_ind : 1-D array
Column indices corresponding to the best permutation found of the
nodes of `B`.
fun : float
The objective value of the solution.
nit : int
The number of iterations performed during optimization.

Notes
-----
This is a greedy algorithm that works similarly to bubble sort: beginning
with an initial permutation, it iteratively swaps pairs of indices to
improve the objective function until no such improvements are possible.

References
----------
.. [1] "2-opt," Wikipedia.
https://en.wikipedia.org/wiki/2-opt

.. [2] D. Fishkind, S. Adali, H. Patsolic, L. Meng, D. Singh, V. Lyzinski,
C. Priebe, "Seeded graph matching", Pattern Recognit. 87 (2019):
203-215, https://doi.org/10.1016/j.patcog.2018.09.014</pre> <div class="fragment"><div class="line"><span class="lineno">  544</span>                               **unknown_options):</div>
<div class="line"><span class="lineno">  545</span>    <span class="stringliteral">r&quot;&quot;&quot;Solve the quadratic assignment problem (approximately).</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    This function solves the Quadratic Assignment Problem (QAP) and the</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    Graph Matching Problem (GMP) using the 2-opt algorithm [1]_.</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    Quadratic assignment solves problems of the following form:</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">        \min_P &amp; \ {\ \text{trace}(A^T P B P^T)}\\</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">        \mbox{s.t. } &amp; {P \ \epsilon \ \mathcal{P}}\\</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    where :math:`\mathcal{P}` is the set of all permutation matrices,</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    and :math:`A` and :math:`B` are square matrices.</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    Graph matching tries to *maximize* the same objective function.</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    This algorithm can be thought of as finding the alignment of the</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    nodes of two graphs that minimizes the number of induced edge</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    disagreements, or, in the case of weighted graphs, the sum of squared</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    edge weight differences.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    Note that the quadratic assignment problem is NP-hard. The results given</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    here are approximations and are not guaranteed to be optimal.</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    A : 2-D array, square</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        The square matrix :math:`A` in the objective function above.</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    B : 2-D array, square</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        The square matrix :math:`B` in the objective function above.</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    method :  str in {&#39;faq&#39;, &#39;2opt&#39;} (default: &#39;faq&#39;)</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        The algorithm used to solve the problem. This is the method-specific</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        documentation for &#39;2opt&#39;.</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        :ref:`&#39;faq&#39; &lt;optimize.qap-faq&gt;` is also available.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    Options</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    maximize : bool (default: False)</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        Maximizes the objective function if ``True``.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    rng : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">           `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">        singleton is used.</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        that instance is used.</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">    partial_match : 2-D array of integers, optional (default: None)</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        Fixes part of the matching. Also known as a &quot;seed&quot; [2]_.</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        Each row of `partial_match` specifies a pair of matched nodes: node</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        ``partial_match[i, 0]`` of `A` is matched to node</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">        ``partial_match[i, 1]`` of `B`. The array has shape ``(m, 2)``,</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        where ``m`` is not greater than the number of nodes, :math:`n`.</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    partial_guess : 2-D array of integers, optional (default: None)</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        A guess for the matching between the two matrices. Unlike</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        `partial_match`, `partial_guess` does not fix the indices; they are</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">        still free to be optimized.</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        Each row of `partial_guess` specifies a pair of matched nodes: node</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        ``partial_guess[i, 0]`` of `A` is matched to node</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">        ``partial_guess[i, 1]`` of `B`. The array has shape ``(m, 2)``,</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">        where ``m`` is not greater than the number of nodes, :math:`n`.</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    res : OptimizeResult</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">        `OptimizeResult` containing the following fields.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        col_ind : 1-D array</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">            Column indices corresponding to the best permutation found of the</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">            nodes of `B`.</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        fun : float</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">            The objective value of the solution.</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">        nit : int</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">            The number of iterations performed during optimization.</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    This is a greedy algorithm that works similarly to bubble sort: beginning</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    with an initial permutation, it iteratively swaps pairs of indices to</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    improve the objective function until no such improvements are possible.</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    .. [1] &quot;2-opt,&quot; Wikipedia.</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">           https://en.wikipedia.org/wiki/2-opt</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    .. [2] D. Fishkind, S. Adali, H. Patsolic, L. Meng, D. Singh, V. Lyzinski,</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">           C. Priebe, &quot;Seeded graph matching&quot;, Pattern Recognit. 87 (2019):</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">           203-215, https://doi.org/10.1016/j.patcog.2018.09.014</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  639</span>    _check_unknown_options(unknown_options)</div>
<div class="line"><span class="lineno">  640</span>    rng = check_random_state(rng)</div>
<div class="line"><span class="lineno">  641</span>    A, B, partial_match = _common_input_validation(A, B, partial_match)</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>    N = len(A)</div>
<div class="line"><span class="lineno">  644</span>    <span class="comment"># check trivial cases</span></div>
<div class="line"><span class="lineno">  645</span>    <span class="keywordflow">if</span> N == 0 <span class="keywordflow">or</span> partial_match.shape[0] == N:</div>
<div class="line"><span class="lineno">  646</span>        score = _calc_score(A, B, partial_match[:, 1])</div>
<div class="line"><span class="lineno">  647</span>        res = {<span class="stringliteral">&quot;col_ind&quot;</span>: partial_match[:, 1], <span class="stringliteral">&quot;fun&quot;</span>: score, <span class="stringliteral">&quot;nit&quot;</span>: 0}</div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">return</span> OptimizeResult(res)</div>
<div class="line"><span class="lineno">  649</span> </div>
<div class="line"><span class="lineno">  650</span>    <span class="keywordflow">if</span> partial_guess <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  651</span>        partial_guess = np.array([[], []]).T</div>
<div class="line"><span class="lineno">  652</span>    partial_guess = np.atleast_2d(partial_guess).astype(int)</div>
<div class="line"><span class="lineno">  653</span> </div>
<div class="line"><span class="lineno">  654</span>    msg = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  655</span>    <span class="keywordflow">if</span> partial_guess.shape[0] &gt; A.shape[0]:</div>
<div class="line"><span class="lineno">  656</span>        msg = (<span class="stringliteral">&quot;`partial_guess` can have only as &quot;</span></div>
<div class="line"><span class="lineno">  657</span>               <span class="stringliteral">&quot;many entries as there are nodes&quot;</span>)</div>
<div class="line"><span class="lineno">  658</span>    <span class="keywordflow">elif</span> partial_guess.shape[1] != 2:</div>
<div class="line"><span class="lineno">  659</span>        msg = <span class="stringliteral">&quot;`partial_guess` must have two columns&quot;</span></div>
<div class="line"><span class="lineno">  660</span>    <span class="keywordflow">elif</span> partial_guess.ndim != 2:</div>
<div class="line"><span class="lineno">  661</span>        msg = <span class="stringliteral">&quot;`partial_guess` must have exactly two dimensions&quot;</span></div>
<div class="line"><span class="lineno">  662</span>    <span class="keywordflow">elif</span> (partial_guess &lt; 0).any():</div>
<div class="line"><span class="lineno">  663</span>        msg = <span class="stringliteral">&quot;`partial_guess` must contain only positive indices&quot;</span></div>
<div class="line"><span class="lineno">  664</span>    <span class="keywordflow">elif</span> (partial_guess &gt;= len(A)).any():</div>
<div class="line"><span class="lineno">  665</span>        msg = <span class="stringliteral">&quot;`partial_guess` entries must be less than number of nodes&quot;</span></div>
<div class="line"><span class="lineno">  666</span>    <span class="keywordflow">elif</span> (<span class="keywordflow">not</span> len(set(partial_guess[:, 0])) == len(partial_guess[:, 0]) <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  667</span>          <span class="keywordflow">not</span> len(set(partial_guess[:, 1])) == len(partial_guess[:, 1])):</div>
<div class="line"><span class="lineno">  668</span>        msg = <span class="stringliteral">&quot;`partial_guess` column entries must be unique&quot;</span></div>
<div class="line"><span class="lineno">  669</span>    <span class="keywordflow">if</span> msg <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  670</span>        <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  671</span> </div>
<div class="line"><span class="lineno">  672</span>    fixed_rows = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  673</span>    <span class="keywordflow">if</span> partial_match.size <span class="keywordflow">or</span> partial_guess.size:</div>
<div class="line"><span class="lineno">  674</span>        <span class="comment"># use partial_match and partial_guess for initial permutation,</span></div>
<div class="line"><span class="lineno">  675</span>        <span class="comment"># but randomly permute the rest.</span></div>
<div class="line"><span class="lineno">  676</span>        guess_rows = np.zeros(N, dtype=bool)</div>
<div class="line"><span class="lineno">  677</span>        guess_cols = np.zeros(N, dtype=bool)</div>
<div class="line"><span class="lineno">  678</span>        fixed_rows = np.zeros(N, dtype=bool)</div>
<div class="line"><span class="lineno">  679</span>        fixed_cols = np.zeros(N, dtype=bool)</div>
<div class="line"><span class="lineno">  680</span>        perm = np.zeros(N, dtype=int)</div>
<div class="line"><span class="lineno">  681</span> </div>
<div class="line"><span class="lineno">  682</span>        rg, cg = partial_guess.T</div>
<div class="line"><span class="lineno">  683</span>        guess_rows[rg] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  684</span>        guess_cols[cg] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  685</span>        perm[guess_rows] = cg</div>
<div class="line"><span class="lineno">  686</span> </div>
<div class="line"><span class="lineno">  687</span>        <span class="comment"># match overrides guess</span></div>
<div class="line"><span class="lineno">  688</span>        rf, cf = partial_match.T</div>
<div class="line"><span class="lineno">  689</span>        fixed_rows[rf] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  690</span>        fixed_cols[cf] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  691</span>        perm[fixed_rows] = cf</div>
<div class="line"><span class="lineno">  692</span> </div>
<div class="line"><span class="lineno">  693</span>        random_rows = ~fixed_rows &amp; ~guess_rows</div>
<div class="line"><span class="lineno">  694</span>        random_cols = ~fixed_cols &amp; ~guess_cols</div>
<div class="line"><span class="lineno">  695</span>        perm[random_rows] = rng.permutation(np.arange(N)[random_cols])</div>
<div class="line"><span class="lineno">  696</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  697</span>        perm = rng.permutation(np.arange(N))</div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>    best_score = _calc_score(A, B, perm)</div>
<div class="line"><span class="lineno">  700</span> </div>
<div class="line"><span class="lineno">  701</span>    i_free = np.arange(N)</div>
<div class="line"><span class="lineno">  702</span>    <span class="keywordflow">if</span> fixed_rows <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  703</span>        i_free = i_free[~fixed_rows]</div>
<div class="line"><span class="lineno">  704</span> </div>
<div class="line"><span class="lineno">  705</span>    better = operator.gt <span class="keywordflow">if</span> maximize <span class="keywordflow">else</span> operator.lt</div>
<div class="line"><span class="lineno">  706</span>    n_iter = 0</div>
<div class="line"><span class="lineno">  707</span>    done = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  708</span>    <span class="keywordflow">while</span> <span class="keywordflow">not</span> done:</div>
<div class="line"><span class="lineno">  709</span>        <span class="comment"># equivalent to nested for loops i in range(N), j in range(i, N)</span></div>
<div class="line"><span class="lineno">  710</span>        <span class="keywordflow">for</span> i, j <span class="keywordflow">in</span> itertools.combinations_with_replacement(i_free, 2):</div>
<div class="line"><span class="lineno">  711</span>            n_iter += 1</div>
<div class="line"><span class="lineno">  712</span>            perm[i], perm[j] = perm[j], perm[i]</div>
<div class="line"><span class="lineno">  713</span>            score = _calc_score(A, B, perm)</div>
<div class="line"><span class="lineno">  714</span>            <span class="keywordflow">if</span> better(score, best_score):</div>
<div class="line"><span class="lineno">  715</span>                best_score = score</div>
<div class="line"><span class="lineno">  716</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  717</span>            <span class="comment"># faster to swap back than to create a new list every time</span></div>
<div class="line"><span class="lineno">  718</span>            perm[i], perm[j] = perm[j], perm[i]</div>
<div class="line"><span class="lineno">  719</span>        <span class="keywordflow">else</span>:  <span class="comment"># no swaps made</span></div>
<div class="line"><span class="lineno">  720</span>            done = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  721</span> </div>
<div class="line"><span class="lineno">  722</span>    res = {<span class="stringliteral">&quot;col_ind&quot;</span>: perm, <span class="stringliteral">&quot;fun&quot;</span>: best_score, <span class="stringliteral">&quot;nit&quot;</span>: n_iter}</div>
<div class="line"><span class="lineno">  723</span>    <span class="keywordflow">return</span> OptimizeResult(res)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a132c802ac6681b031289b29b4fb174ab" name="a132c802ac6681b031289b29b4fb174ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132c802ac6681b031289b29b4fb174ab">&#9670;&#160;</a></span>_quadratic_assignment_faq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._qap._quadratic_assignment_faq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maximize</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partial_match</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>P0</em> = <code>&quot;barycenter&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shuffle_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.03</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>unknown_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Solve the quadratic assignment problem (approximately).

This function solves the Quadratic Assignment Problem (QAP) and the
Graph Matching Problem (GMP) using the Fast Approximate QAP Algorithm
(FAQ) [1]_.

Quadratic assignment solves problems of the following form:

.. math::

    \min_P &amp; \ {\ \text{trace}(A^T P B P^T)}\\
    \mbox{s.t. } &amp; {P \ \epsilon \ \mathcal{P}}\\

where :math:`\mathcal{P}` is the set of all permutation matrices,
and :math:`A` and :math:`B` are square matrices.

Graph matching tries to *maximize* the same objective function.
This algorithm can be thought of as finding the alignment of the
nodes of two graphs that minimizes the number of induced edge
disagreements, or, in the case of weighted graphs, the sum of squared
edge weight differences.

Note that the quadratic assignment problem is NP-hard. The results given
here are approximations and are not guaranteed to be optimal.

Parameters
----------
A : 2-D array, square
    The square matrix :math:`A` in the objective function above.
B : 2-D array, square
    The square matrix :math:`B` in the objective function above.
method :  str in {'faq', '2opt'} (default: 'faq')
    The algorithm used to solve the problem. This is the method-specific
    documentation for 'faq'.
    :ref:`'2opt' &lt;optimize.qap-2opt&gt;` is also available.

Options
-------
maximize : bool (default: False)
    Maximizes the objective function if ``True``.
partial_match : 2-D array of integers, optional (default: None)
    Fixes part of the matching. Also known as a "seed" [2]_.

    Each row of `partial_match` specifies a pair of matched nodes:
    node ``partial_match[i, 0]`` of `A` is matched to node
    ``partial_match[i, 1]`` of `B`. The array has shape ``(m, 2)``, where
    ``m`` is not greater than the number of nodes, :math:`n`.

rng : {None, int, `numpy.random.Generator`,
       `numpy.random.RandomState`}, optional

    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.
P0 : 2-D array, "barycenter", or "randomized" (default: "barycenter")
    Initial position. Must be a doubly-stochastic matrix [3]_.

    If the initial position is an array, it must be a doubly stochastic
    matrix of size :math:`m' \times m'` where :math:`m' = n - m`.

    If ``"barycenter"`` (default), the initial position is the barycenter
    of the Birkhoff polytope (the space of doubly stochastic matrices).
    This is a :math:`m' \times m'` matrix with all entries equal to
    :math:`1 / m'`.

    If ``"randomized"`` the initial search position is
    :math:`P_0 = (J + K) / 2`, where :math:`J` is the barycenter and
    :math:`K` is a random doubly stochastic matrix.
shuffle_input : bool (default: False)
    Set to `True` to resolve degenerate gradients randomly. For
    non-degenerate gradients this option has no effect.
maxiter : int, positive (default: 30)
    Integer specifying the max number of Frank-Wolfe iterations performed.
tol : float (default: 0.03)
    Tolerance for termination. Frank-Wolfe iteration terminates when
    :math:`\frac{||P_{i}-P_{i+1}||_F}{\sqrt{m')}} \leq tol`,
    where :math:`i` is the iteration number.

Returns
-------
res : OptimizeResult
    `OptimizeResult` containing the following fields.

    col_ind : 1-D array
        Column indices corresponding to the best permutation found of the
        nodes of `B`.
    fun : float
        The objective value of the solution.
    nit : int
        The number of Frank-Wolfe iterations performed.

Notes
-----
The algorithm may be sensitive to the initial permutation matrix (or
search "position") due to the possibility of several local minima
within the feasible region. A barycenter initialization is more likely to
result in a better solution than a single random initialization. However,
calling ``quadratic_assignment`` several times with different random
initializations may result in a better optimum at the cost of longer
total execution time.

Examples
--------
As mentioned above, a barycenter initialization often results in a better
solution than a single random initialization.

&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; n = 15
&gt;&gt;&gt; A = rng.random((n, n))
&gt;&gt;&gt; B = rng.random((n, n))
&gt;&gt;&gt; res = quadratic_assignment(A, B)  # FAQ is default method
&gt;&gt;&gt; print(res.fun)
46.871483385480545  # may vary

&gt;&gt;&gt; options = {"P0": "randomized"}  # use randomized initialization
&gt;&gt;&gt; res = quadratic_assignment(A, B, options=options)
&gt;&gt;&gt; print(res.fun)
47.224831071310625 # may vary

However, consider running from several randomized initializations and
keeping the best result.

&gt;&gt;&gt; res = min([quadratic_assignment(A, B, options=options)
...            for i in range(30)], key=lambda x: x.fun)
&gt;&gt;&gt; print(res.fun)
46.671852533681516 # may vary

The '2-opt' method can be used to further refine the results.

&gt;&gt;&gt; options = {"partial_guess": np.array([np.arange(n), res.col_ind]).T}
&gt;&gt;&gt; res = quadratic_assignment(A, B, method="2opt", options=options)
&gt;&gt;&gt; print(res.fun)
46.47160735721583 # may vary

References
----------
.. [1] J.T. Vogelstein, J.M. Conroy, V. Lyzinski, L.J. Podrazik,
       S.G. Kratzer, E.T. Harley, D.E. Fishkind, R.J. Vogelstein, and
       C.E. Priebe, "Fast approximate quadratic programming for graph
       matching," PLOS one, vol. 10, no. 4, p. e0121002, 2015,
       :doi:`10.1371/journal.pone.0121002`

.. [2] D. Fishkind, S. Adali, H. Patsolic, L. Meng, D. Singh, V. Lyzinski,
       C. Priebe, "Seeded graph matching", Pattern Recognit. 87 (2019):
       203-215, :doi:`10.1016/j.patcog.2018.09.014`

.. [3] "Doubly stochastic Matrix," Wikipedia.
       https://en.wikipedia.org/wiki/Doubly_stochastic_matrix</pre> <div class="fragment"><div class="line"><span class="lineno">  239</span>                              tol=0.03, **unknown_options):</div>
<div class="line"><span class="lineno">  240</span>    <span class="stringliteral">r&quot;&quot;&quot;Solve the quadratic assignment problem (approximately).</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    This function solves the Quadratic Assignment Problem (QAP) and the</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    Graph Matching Problem (GMP) using the Fast Approximate QAP Algorithm</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    (FAQ) [1]_.</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    Quadratic assignment solves problems of the following form:</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">        \min_P &amp; \ {\ \text{trace}(A^T P B P^T)}\\</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        \mbox{s.t. } &amp; {P \ \epsilon \ \mathcal{P}}\\</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    where :math:`\mathcal{P}` is the set of all permutation matrices,</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    and :math:`A` and :math:`B` are square matrices.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    Graph matching tries to *maximize* the same objective function.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    This algorithm can be thought of as finding the alignment of the</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    nodes of two graphs that minimizes the number of induced edge</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    disagreements, or, in the case of weighted graphs, the sum of squared</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    edge weight differences.</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    Note that the quadratic assignment problem is NP-hard. The results given</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    here are approximations and are not guaranteed to be optimal.</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    A : 2-D array, square</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        The square matrix :math:`A` in the objective function above.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    B : 2-D array, square</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">        The square matrix :math:`B` in the objective function above.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    method :  str in {&#39;faq&#39;, &#39;2opt&#39;} (default: &#39;faq&#39;)</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        The algorithm used to solve the problem. This is the method-specific</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">        documentation for &#39;faq&#39;.</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        :ref:`&#39;2opt&#39; &lt;optimize.qap-2opt&gt;` is also available.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    Options</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    maximize : bool (default: False)</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        Maximizes the objective function if ``True``.</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    partial_match : 2-D array of integers, optional (default: None)</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        Fixes part of the matching. Also known as a &quot;seed&quot; [2]_.</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        Each row of `partial_match` specifies a pair of matched nodes:</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        node ``partial_match[i, 0]`` of `A` is matched to node</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        ``partial_match[i, 1]`` of `B`. The array has shape ``(m, 2)``, where</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        ``m`` is not greater than the number of nodes, :math:`n`.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    rng : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">           `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        singleton is used.</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        seeded with `seed`.</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        that instance is used.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    P0 : 2-D array, &quot;barycenter&quot;, or &quot;randomized&quot; (default: &quot;barycenter&quot;)</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        Initial position. Must be a doubly-stochastic matrix [3]_.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        If the initial position is an array, it must be a doubly stochastic</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        matrix of size :math:`m&#39; \times m&#39;` where :math:`m&#39; = n - m`.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        If ``&quot;barycenter&quot;`` (default), the initial position is the barycenter</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        of the Birkhoff polytope (the space of doubly stochastic matrices).</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        This is a :math:`m&#39; \times m&#39;` matrix with all entries equal to</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">        :math:`1 / m&#39;`.</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">        If ``&quot;randomized&quot;`` the initial search position is</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">        :math:`P_0 = (J + K) / 2`, where :math:`J` is the barycenter and</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        :math:`K` is a random doubly stochastic matrix.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    shuffle_input : bool (default: False)</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        Set to `True` to resolve degenerate gradients randomly. For</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        non-degenerate gradients this option has no effect.</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    maxiter : int, positive (default: 30)</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        Integer specifying the max number of Frank-Wolfe iterations performed.</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    tol : float (default: 0.03)</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        Tolerance for termination. Frank-Wolfe iteration terminates when</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        :math:`\frac{||P_{i}-P_{i+1}||_F}{\sqrt{m&#39;)}} \leq tol`,</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        where :math:`i` is the iteration number.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    res : OptimizeResult</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        `OptimizeResult` containing the following fields.</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">        col_ind : 1-D array</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">            Column indices corresponding to the best permutation found of the</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">            nodes of `B`.</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        fun : float</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">            The objective value of the solution.</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        nit : int</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">            The number of Frank-Wolfe iterations performed.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    The algorithm may be sensitive to the initial permutation matrix (or</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    search &quot;position&quot;) due to the possibility of several local minima</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    within the feasible region. A barycenter initialization is more likely to</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    result in a better solution than a single random initialization. However,</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    calling ``quadratic_assignment`` several times with different random</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    initializations may result in a better optimum at the cost of longer</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    total execution time.</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    As mentioned above, a barycenter initialization often results in a better</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    solution than a single random initialization.</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.random import default_rng</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    &gt;&gt;&gt; rng = default_rng()</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    &gt;&gt;&gt; n = 15</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    &gt;&gt;&gt; A = rng.random((n, n))</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    &gt;&gt;&gt; B = rng.random((n, n))</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    &gt;&gt;&gt; res = quadratic_assignment(A, B)  # FAQ is default method</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    &gt;&gt;&gt; print(res.fun)</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    46.871483385480545  # may vary</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    &gt;&gt;&gt; options = {&quot;P0&quot;: &quot;randomized&quot;}  # use randomized initialization</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    &gt;&gt;&gt; res = quadratic_assignment(A, B, options=options)</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    &gt;&gt;&gt; print(res.fun)</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    47.224831071310625 # may vary</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    However, consider running from several randomized initializations and</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    keeping the best result.</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    &gt;&gt;&gt; res = min([quadratic_assignment(A, B, options=options)</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    ...            for i in range(30)], key=lambda x: x.fun)</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    &gt;&gt;&gt; print(res.fun)</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    46.671852533681516 # may vary</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    The &#39;2-opt&#39; method can be used to further refine the results.</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    &gt;&gt;&gt; options = {&quot;partial_guess&quot;: np.array([np.arange(n), res.col_ind]).T}</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    &gt;&gt;&gt; res = quadratic_assignment(A, B, method=&quot;2opt&quot;, options=options)</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    &gt;&gt;&gt; print(res.fun)</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    46.47160735721583 # may vary</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    .. [1] J.T. Vogelstein, J.M. Conroy, V. Lyzinski, L.J. Podrazik,</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">           S.G. Kratzer, E.T. Harley, D.E. Fishkind, R.J. Vogelstein, and</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">           C.E. Priebe, &quot;Fast approximate quadratic programming for graph</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">           matching,&quot; PLOS one, vol. 10, no. 4, p. e0121002, 2015,</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">           :doi:`10.1371/journal.pone.0121002`</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    .. [2] D. Fishkind, S. Adali, H. Patsolic, L. Meng, D. Singh, V. Lyzinski,</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">           C. Priebe, &quot;Seeded graph matching&quot;, Pattern Recognit. 87 (2019):</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">           203-215, :doi:`10.1016/j.patcog.2018.09.014`</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    .. [3] &quot;Doubly stochastic Matrix,&quot; Wikipedia.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Doubly_stochastic_matrix</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span>    _check_unknown_options(unknown_options)</div>
<div class="line"><span class="lineno">  396</span> </div>
<div class="line"><span class="lineno">  397</span>    maxiter = operator.index(maxiter)</div>
<div class="line"><span class="lineno">  398</span> </div>
<div class="line"><span class="lineno">  399</span>    <span class="comment"># ValueError check</span></div>
<div class="line"><span class="lineno">  400</span>    A, B, partial_match = _common_input_validation(A, B, partial_match)</div>
<div class="line"><span class="lineno">  401</span> </div>
<div class="line"><span class="lineno">  402</span>    msg = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  403</span>    <span class="keywordflow">if</span> isinstance(P0, str) <span class="keywordflow">and</span> P0 <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="stringliteral">&#39;barycenter&#39;</span>, <span class="stringliteral">&#39;randomized&#39;</span>}:</div>
<div class="line"><span class="lineno">  404</span>        msg = <span class="stringliteral">&quot;Invalid &#39;P0&#39; parameter string&quot;</span></div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordflow">elif</span> maxiter &lt;= 0:</div>
<div class="line"><span class="lineno">  406</span>        msg = <span class="stringliteral">&quot;&#39;maxiter&#39; must be a positive integer&quot;</span></div>
<div class="line"><span class="lineno">  407</span>    <span class="keywordflow">elif</span> tol &lt;= 0:</div>
<div class="line"><span class="lineno">  408</span>        msg = <span class="stringliteral">&quot;&#39;tol&#39; must be a positive float&quot;</span></div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">if</span> msg <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span>    rng = check_random_state(rng)</div>
<div class="line"><span class="lineno">  413</span>    n = len(A)  <span class="comment"># number of vertices in graphs</span></div>
<div class="line"><span class="lineno">  414</span>    n_seeds = len(partial_match)  <span class="comment"># number of seeds</span></div>
<div class="line"><span class="lineno">  415</span>    n_unseed = n - n_seeds</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>    <span class="comment"># [1] Algorithm 1 Line 1 - choose initialization</span></div>
<div class="line"><span class="lineno">  418</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(P0, str):</div>
<div class="line"><span class="lineno">  419</span>        P0 = np.atleast_2d(P0)</div>
<div class="line"><span class="lineno">  420</span>        <span class="keywordflow">if</span> P0.shape != (n_unseed, n_unseed):</div>
<div class="line"><span class="lineno">  421</span>            msg = <span class="stringliteral">&quot;`P0` matrix must have shape m&#39; x m&#39;, where m&#39;=n-m&quot;</span></div>
<div class="line"><span class="lineno">  422</span>        <span class="keywordflow">elif</span> ((P0 &lt; 0).any() <span class="keywordflow">or</span> <span class="keywordflow">not</span> np.allclose(np.sum(P0, axis=0), 1)</div>
<div class="line"><span class="lineno">  423</span>              <span class="keywordflow">or</span> <span class="keywordflow">not</span> np.allclose(np.sum(P0, axis=1), 1)):</div>
<div class="line"><span class="lineno">  424</span>            msg = <span class="stringliteral">&quot;`P0` matrix must be doubly stochastic&quot;</span></div>
<div class="line"><span class="lineno">  425</span>        <span class="keywordflow">if</span> msg <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  426</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">elif</span> P0 == <span class="stringliteral">&#39;barycenter&#39;</span>:</div>
<div class="line"><span class="lineno">  428</span>        P0 = np.ones((n_unseed, n_unseed)) / n_unseed</div>
<div class="line"><span class="lineno">  429</span>    <span class="keywordflow">elif</span> P0 == <span class="stringliteral">&#39;randomized&#39;</span>:</div>
<div class="line"><span class="lineno">  430</span>        J = np.ones((n_unseed, n_unseed)) / n_unseed</div>
<div class="line"><span class="lineno">  431</span>        <span class="comment"># generate a nxn matrix where each entry is a random number [0, 1]</span></div>
<div class="line"><span class="lineno">  432</span>        <span class="comment"># would use rand, but Generators don&#39;t have it</span></div>
<div class="line"><span class="lineno">  433</span>        <span class="comment"># would use random, but old mtrand.RandomStates don&#39;t have it</span></div>
<div class="line"><span class="lineno">  434</span>        K = _doubly_stochastic(rng.uniform(size=(n_unseed, n_unseed)))</div>
<div class="line"><span class="lineno">  435</span>        P0 = (J + K) / 2</div>
<div class="line"><span class="lineno">  436</span> </div>
<div class="line"><span class="lineno">  437</span>    <span class="comment"># check trivial cases</span></div>
<div class="line"><span class="lineno">  438</span>    <span class="keywordflow">if</span> n == 0 <span class="keywordflow">or</span> n_seeds == n:</div>
<div class="line"><span class="lineno">  439</span>        score = _calc_score(A, B, partial_match[:, 1])</div>
<div class="line"><span class="lineno">  440</span>        res = {<span class="stringliteral">&quot;col_ind&quot;</span>: partial_match[:, 1], <span class="stringliteral">&quot;fun&quot;</span>: score, <span class="stringliteral">&quot;nit&quot;</span>: 0}</div>
<div class="line"><span class="lineno">  441</span>        <span class="keywordflow">return</span> OptimizeResult(res)</div>
<div class="line"><span class="lineno">  442</span> </div>
<div class="line"><span class="lineno">  443</span>    obj_func_scalar = 1</div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">if</span> maximize:</div>
<div class="line"><span class="lineno">  445</span>        obj_func_scalar = -1</div>
<div class="line"><span class="lineno">  446</span> </div>
<div class="line"><span class="lineno">  447</span>    nonseed_B = np.setdiff1d(range(n), partial_match[:, 1])</div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">if</span> shuffle_input:</div>
<div class="line"><span class="lineno">  449</span>        nonseed_B = rng.permutation(nonseed_B)</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span>    nonseed_A = np.setdiff1d(range(n), partial_match[:, 0])</div>
<div class="line"><span class="lineno">  452</span>    perm_A = np.concatenate([partial_match[:, 0], nonseed_A])</div>
<div class="line"><span class="lineno">  453</span>    perm_B = np.concatenate([partial_match[:, 1], nonseed_B])</div>
<div class="line"><span class="lineno">  454</span> </div>
<div class="line"><span class="lineno">  455</span>    <span class="comment"># definitions according to Seeded Graph Matching [2].</span></div>
<div class="line"><span class="lineno">  456</span>    A11, A12, A21, A22 = _split_matrix(A[perm_A][:, perm_A], n_seeds)</div>
<div class="line"><span class="lineno">  457</span>    B11, B12, B21, B22 = _split_matrix(B[perm_B][:, perm_B], n_seeds)</div>
<div class="line"><span class="lineno">  458</span>    const_sum = A21 @ B21.T + A12.T @ B12</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    P = P0</div>
<div class="line"><span class="lineno">  461</span>    <span class="comment"># [1] Algorithm 1 Line 2 - loop while stopping criteria not met</span></div>
<div class="line"><span class="lineno">  462</span>    <span class="keywordflow">for</span> n_iter <span class="keywordflow">in</span> range(1, maxiter+1):</div>
<div class="line"><span class="lineno">  463</span>        <span class="comment"># [1] Algorithm 1 Line 3 - compute the gradient of f(P) = -tr(APB^tP^t)</span></div>
<div class="line"><span class="lineno">  464</span>        grad_fp = (const_sum + A22 @ P @ B22.T + A22.T @ P @ B22)</div>
<div class="line"><span class="lineno">  465</span>        <span class="comment"># [1] Algorithm 1 Line 4 - get direction Q by solving Eq. 8</span></div>
<div class="line"><span class="lineno">  466</span>        _, cols = linear_sum_assignment(grad_fp, maximize=maximize)</div>
<div class="line"><span class="lineno">  467</span>        Q = np.eye(n_unseed)[cols]</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>        <span class="comment"># [1] Algorithm 1 Line 5 - compute the step size</span></div>
<div class="line"><span class="lineno">  470</span>        <span class="comment"># Noting that e.g. trace(Ax) = trace(A)*x, expand and re-collect</span></div>
<div class="line"><span class="lineno">  471</span>        <span class="comment"># terms as ax**2 + bx + c. c does not affect location of minimum</span></div>
<div class="line"><span class="lineno">  472</span>        <span class="comment"># and can be ignored. Also, note that trace(A@B) = (A.T*B).sum();</span></div>
<div class="line"><span class="lineno">  473</span>        <span class="comment"># apply where possible for efficiency.</span></div>
<div class="line"><span class="lineno">  474</span>        R = P - Q</div>
<div class="line"><span class="lineno">  475</span>        b21 = ((R.T @ A21) * B21).sum()</div>
<div class="line"><span class="lineno">  476</span>        b12 = ((R.T @ A12.T) * B12.T).sum()</div>
<div class="line"><span class="lineno">  477</span>        AR22 = A22.T @ R</div>
<div class="line"><span class="lineno">  478</span>        BR22 = B22 @ R.T</div>
<div class="line"><span class="lineno">  479</span>        b22a = (AR22 * B22.T[cols]).sum()</div>
<div class="line"><span class="lineno">  480</span>        b22b = (A22 * BR22[cols]).sum()</div>
<div class="line"><span class="lineno">  481</span>        a = (AR22.T * BR22).sum()</div>
<div class="line"><span class="lineno">  482</span>        b = b21 + b12 + b22a + b22b</div>
<div class="line"><span class="lineno">  483</span>        <span class="comment"># critical point of ax^2 + bx + c is at x = -d/(2*e)</span></div>
<div class="line"><span class="lineno">  484</span>        <span class="comment"># if a * obj_func_scalar &gt; 0, it is a minimum</span></div>
<div class="line"><span class="lineno">  485</span>        <span class="comment"># if minimum is not in [0, 1], only endpoints need to be considered</span></div>
<div class="line"><span class="lineno">  486</span>        <span class="keywordflow">if</span> a*obj_func_scalar &gt; 0 <span class="keywordflow">and</span> 0 &lt;= -b/(2*a) &lt;= 1:</div>
<div class="line"><span class="lineno">  487</span>            alpha = -b/(2*a)</div>
<div class="line"><span class="lineno">  488</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  489</span>            alpha = np.argmin([0, (b + a)*obj_func_scalar])</div>
<div class="line"><span class="lineno">  490</span> </div>
<div class="line"><span class="lineno">  491</span>        <span class="comment"># [1] Algorithm 1 Line 6 - Update P</span></div>
<div class="line"><span class="lineno">  492</span>        P_i1 = alpha * P + (1 - alpha) * Q</div>
<div class="line"><span class="lineno">  493</span>        <span class="keywordflow">if</span> np.linalg.norm(P - P_i1) / np.sqrt(n_unseed) &lt; tol:</div>
<div class="line"><span class="lineno">  494</span>            P = P_i1</div>
<div class="line"><span class="lineno">  495</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  496</span>        P = P_i1</div>
<div class="line"><span class="lineno">  497</span>    <span class="comment"># [1] Algorithm 1 Line 7 - end main loop</span></div>
<div class="line"><span class="lineno">  498</span> </div>
<div class="line"><span class="lineno">  499</span>    <span class="comment"># [1] Algorithm 1 Line 8 - project onto the set of permutation matrices</span></div>
<div class="line"><span class="lineno">  500</span>    _, col = linear_sum_assignment(P, maximize=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  501</span>    perm = np.concatenate((np.arange(n_seeds), col + n_seeds))</div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span>    unshuffled_perm = np.zeros(n, dtype=int)</div>
<div class="line"><span class="lineno">  504</span>    unshuffled_perm[perm_A] = perm_B[perm]</div>
<div class="line"><span class="lineno">  505</span> </div>
<div class="line"><span class="lineno">  506</span>    score = _calc_score(A, B, unshuffled_perm)</div>
<div class="line"><span class="lineno">  507</span>    res = {<span class="stringliteral">&quot;col_ind&quot;</span>: unshuffled_perm, <span class="stringliteral">&quot;fun&quot;</span>: score, <span class="stringliteral">&quot;nit&quot;</span>: n_iter}</div>
<div class="line"><span class="lineno">  508</span>    <span class="keywordflow">return</span> OptimizeResult(res)</div>
<div class="line"><span class="lineno">  509</span> </div>
<div class="line"><span class="lineno">  510</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac9da94c34932b2d0fc5bd81eef491fc4" name="ac9da94c34932b2d0fc5bd81eef491fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9da94c34932b2d0fc5bd81eef491fc4">&#9670;&#160;</a></span>_split_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._qap._split_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  511</span><span class="keyword">def </span>_split_matrix(X, n):</div>
<div class="line"><span class="lineno">  512</span>    <span class="comment"># definitions according to Seeded Graph Matching [2].</span></div>
<div class="line"><span class="lineno">  513</span>    upper, lower = X[:n], X[n:]</div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">return</span> upper[:, :n], upper[:, n:], lower[:, :n], lower[:, n:]</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2959c444bf05aae8a053622af4604225" name="a2959c444bf05aae8a053622af4604225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2959c444bf05aae8a053622af4604225">&#9670;&#160;</a></span>quadratic_assignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.optimize._qap.quadratic_assignment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;faq&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Approximates solution to the quadratic assignment problem and
    the graph matching problem.

    Quadratic assignment solves problems of the following form:

    .. math::

        \min_P &amp; \ {\ \text{trace}(A^T P B P^T)}\\
        \mbox{s.t. } &amp; {P \ \epsilon \ \mathcal{P}}\\

    where :math:`\mathcal{P}` is the set of all permutation matrices,
    and :math:`A` and :math:`B` are square matrices.

    Graph matching tries to *maximize* the same objective function.
    This algorithm can be thought of as finding the alignment of the
    nodes of two graphs that minimizes the number of induced edge
    disagreements, or, in the case of weighted graphs, the sum of squared
    edge weight differences.

    Note that the quadratic assignment problem is NP-hard. The results given
    here are approximations and are not guaranteed to be optimal.


    Parameters
    ----------
    A : 2-D array, square
        The square matrix :math:`A` in the objective function above.

    B : 2-D array, square
        The square matrix :math:`B` in the objective function above.

    method :  str in {'faq', '2opt'} (default: 'faq')
        The algorithm used to solve the problem.
        :ref:`'faq' &lt;optimize.qap-faq&gt;` (default) and
        :ref:`'2opt' &lt;optimize.qap-2opt&gt;` are available.

    options : dict, optional
        A dictionary of solver options. All solvers support the following:

        maximize : bool (default: False)
            Maximizes the objective function if ``True``.

        partial_match : 2-D array of integers, optional (default: None)
            Fixes part of the matching. Also known as a "seed" [2]_.

            Each row of `partial_match` specifies a pair of matched nodes:
            node ``partial_match[i, 0]`` of `A` is matched to node
            ``partial_match[i, 1]`` of `B`. The array has shape ``(m, 2)``,
            where ``m`` is not greater than the number of nodes, :math:`n`.

        rng : {None, int, `numpy.random.Generator`,
               `numpy.random.RandomState`}, optional

            If `seed` is None (or `np.random`), the `numpy.random.RandomState`
            singleton is used.
            If `seed` is an int, a new ``RandomState`` instance is used,
            seeded with `seed`.
            If `seed` is already a ``Generator`` or ``RandomState`` instance then
            that instance is used.

        For method-specific options, see
        :func:`show_options('quadratic_assignment') &lt;show_options&gt;`.

    Returns
    -------
    res : OptimizeResult
        `OptimizeResult` containing the following fields.

        col_ind : 1-D array
            Column indices corresponding to the best permutation found of the
            nodes of `B`.
        fun : float
            The objective value of the solution.
        nit : int
            The number of iterations performed during optimization.

    Notes
    -----
    The default method :ref:`'faq' &lt;optimize.qap-faq&gt;` uses the Fast
    Approximate QAP algorithm [1]_; it typically offers the best combination of
    speed and accuracy.
    Method :ref:`'2opt' &lt;optimize.qap-2opt&gt;` can be computationally expensive,
    but may be a useful alternative, or it can be used to refine the solution
    returned by another method.

    References
    ----------
    .. [1] J.T. Vogelstein, J.M. Conroy, V. Lyzinski, L.J. Podrazik,
           S.G. Kratzer, E.T. Harley, D.E. Fishkind, R.J. Vogelstein, and
           C.E. Priebe, "Fast approximate quadratic programming for graph
           matching," PLOS one, vol. 10, no. 4, p. e0121002, 2015,
           :doi:`10.1371/journal.pone.0121002`

    .. [2] D. Fishkind, S. Adali, H. Patsolic, L. Meng, D. Singh, V. Lyzinski,
           C. Priebe, "Seeded graph matching", Pattern Recognit. 87 (2019):
           203-215, :doi:`10.1016/j.patcog.2018.09.014`

    .. [3] "2-opt," Wikipedia.
           https://en.wikipedia.org/wiki/2-opt

    Examples
    --------
    &gt;&gt;&gt; from scipy.optimize import quadratic_assignment
    &gt;&gt;&gt; A = np.array([[0, 80, 150, 170], [80, 0, 130, 100],
    ...               [150, 130, 0, 120], [170, 100, 120, 0]])
    &gt;&gt;&gt; B = np.array([[0, 5, 2, 7], [0, 0, 3, 8],
    ...               [0, 0, 0, 3], [0, 0, 0, 0]])
    &gt;&gt;&gt; res = quadratic_assignment(A, B)
    &gt;&gt;&gt; print(res)
     col_ind: array([0, 3, 2, 1])
         fun: 3260
         nit: 9

    The see the relationship between the returned ``col_ind`` and ``fun``,
    use ``col_ind`` to form the best permutation matrix found, then evaluate
    the objective function :math:`f(P) = trace(A^T P B P^T )`.

    &gt;&gt;&gt; perm = res['col_ind']
    &gt;&gt;&gt; P = np.eye(len(A), dtype=int)[perm]
    &gt;&gt;&gt; fun = np.trace(A.T @ P @ B @ P.T)
    &gt;&gt;&gt; print(fun)
    3260

    Alternatively, to avoid constructing the permutation matrix explicitly,
    directly permute the rows and columns of the distance matrix.

    &gt;&gt;&gt; fun = np.trace(A.T @ B[perm][:, perm])
    &gt;&gt;&gt; print(fun)
    3260

    Although not guaranteed in general, ``quadratic_assignment`` happens to
    have found the globally optimal solution.

    &gt;&gt;&gt; from itertools import permutations
    &gt;&gt;&gt; perm_opt, fun_opt = None, np.inf
    &gt;&gt;&gt; for perm in permutations([0, 1, 2, 3]):
    ...     perm = np.array(perm)
    ...     fun = np.trace(A.T @ B[perm][:, perm])
    ...     if fun &lt; fun_opt:
    ...         fun_opt, perm_opt = fun, perm
    &gt;&gt;&gt; print(np.array_equal(perm_opt, res['col_ind']))
    True

    Here is an example for which the default method,
    :ref:`'faq' &lt;optimize.qap-faq&gt;`, does not find the global optimum.

    &gt;&gt;&gt; A = np.array([[0, 5, 8, 6], [5, 0, 5, 1],
    ...               [8, 5, 0, 2], [6, 1, 2, 0]])
    &gt;&gt;&gt; B = np.array([[0, 1, 8, 4], [1, 0, 5, 2],
    ...               [8, 5, 0, 5], [4, 2, 5, 0]])
    &gt;&gt;&gt; res = quadratic_assignment(A, B)
    &gt;&gt;&gt; print(res)
     col_ind: array([1, 0, 3, 2])
         fun: 178
         nit: 13

    If accuracy is important, consider using  :ref:`'2opt' &lt;optimize.qap-2opt&gt;`
    to refine the solution.

    &gt;&gt;&gt; guess = np.array([np.arange(len(A)), res.col_ind]).T
    &gt;&gt;&gt; res = quadratic_assignment(A, B, method="2opt",
    ...                            options = {'partial_guess': guess})
    &gt;&gt;&gt; print(res)
     col_ind: array([1, 2, 3, 0])
         fun: 176
         nit: 17</pre> <div class="fragment"><div class="line"><span class="lineno">   11</span><span class="keyword">def </span>quadratic_assignment(A, B, method=&quot;faq&quot;, options=None):</div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   13</span><span class="stringliteral">    Approximates solution to the quadratic assignment problem and</span></div>
<div class="line"><span class="lineno">   14</span><span class="stringliteral">    the graph matching problem.</span></div>
<div class="line"><span class="lineno">   15</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   16</span><span class="stringliteral">    Quadratic assignment solves problems of the following form:</span></div>
<div class="line"><span class="lineno">   17</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   18</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno">   19</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral">        \min_P &amp; \ {\ \text{trace}(A^T P B P^T)}\\</span></div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral">        \mbox{s.t. } &amp; {P \ \epsilon \ \mathcal{P}}\\</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    where :math:`\mathcal{P}` is the set of all permutation matrices,</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">    and :math:`A` and :math:`B` are square matrices.</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    Graph matching tries to *maximize* the same objective function.</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    This algorithm can be thought of as finding the alignment of the</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    nodes of two graphs that minimizes the number of induced edge</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">    disagreements, or, in the case of weighted graphs, the sum of squared</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    edge weight differences.</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    Note that the quadratic assignment problem is NP-hard. The results given</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    here are approximations and are not guaranteed to be optimal.</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    A : 2-D array, square</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        The square matrix :math:`A` in the objective function above.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    B : 2-D array, square</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        The square matrix :math:`B` in the objective function above.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    method :  str in {&#39;faq&#39;, &#39;2opt&#39;} (default: &#39;faq&#39;)</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        The algorithm used to solve the problem.</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        :ref:`&#39;faq&#39; &lt;optimize.qap-faq&gt;` (default) and</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">        :ref:`&#39;2opt&#39; &lt;optimize.qap-2opt&gt;` are available.</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">    options : dict, optional</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        A dictionary of solver options. All solvers support the following:</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">        maximize : bool (default: False)</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">            Maximizes the objective function if ``True``.</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">        partial_match : 2-D array of integers, optional (default: None)</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">            Fixes part of the matching. Also known as a &quot;seed&quot; [2]_.</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">            Each row of `partial_match` specifies a pair of matched nodes:</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">            node ``partial_match[i, 0]`` of `A` is matched to node</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">            ``partial_match[i, 1]`` of `B`. The array has shape ``(m, 2)``,</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">            where ``m`` is not greater than the number of nodes, :math:`n`.</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">        rng : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">               `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">            singleton is used.</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">            If `seed` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">            seeded with `seed`.</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">            If `seed` is already a ``Generator`` or ``RandomState`` instance then</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">            that instance is used.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">        For method-specific options, see</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">        :func:`show_options(&#39;quadratic_assignment&#39;) &lt;show_options&gt;`.</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    res : OptimizeResult</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        `OptimizeResult` containing the following fields.</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">        col_ind : 1-D array</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">            Column indices corresponding to the best permutation found of the</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">            nodes of `B`.</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        fun : float</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">            The objective value of the solution.</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        nit : int</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">            The number of iterations performed during optimization.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    The default method :ref:`&#39;faq&#39; &lt;optimize.qap-faq&gt;` uses the Fast</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    Approximate QAP algorithm [1]_; it typically offers the best combination of</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    speed and accuracy.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    Method :ref:`&#39;2opt&#39; &lt;optimize.qap-2opt&gt;` can be computationally expensive,</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    but may be a useful alternative, or it can be used to refine the solution</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    returned by another method.</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    .. [1] J.T. Vogelstein, J.M. Conroy, V. Lyzinski, L.J. Podrazik,</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">           S.G. Kratzer, E.T. Harley, D.E. Fishkind, R.J. Vogelstein, and</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">           C.E. Priebe, &quot;Fast approximate quadratic programming for graph</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">           matching,&quot; PLOS one, vol. 10, no. 4, p. e0121002, 2015,</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">           :doi:`10.1371/journal.pone.0121002`</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    .. [2] D. Fishkind, S. Adali, H. Patsolic, L. Meng, D. Singh, V. Lyzinski,</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">           C. Priebe, &quot;Seeded graph matching&quot;, Pattern Recognit. 87 (2019):</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">           203-215, :doi:`10.1016/j.patcog.2018.09.014`</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    .. [3] &quot;2-opt,&quot; Wikipedia.</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">           https://en.wikipedia.org/wiki/2-opt</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.optimize import quadratic_assignment</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[0, 80, 150, 170], [80, 0, 130, 100],</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    ...               [150, 130, 0, 120], [170, 100, 120, 0]])</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    &gt;&gt;&gt; B = np.array([[0, 5, 2, 7], [0, 0, 3, 8],</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    ...               [0, 0, 0, 3], [0, 0, 0, 0]])</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; res = quadratic_assignment(A, B)</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    &gt;&gt;&gt; print(res)</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">     col_ind: array([0, 3, 2, 1])</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">         fun: 3260</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">         nit: 9</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    The see the relationship between the returned ``col_ind`` and ``fun``,</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    use ``col_ind`` to form the best permutation matrix found, then evaluate</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    the objective function :math:`f(P) = trace(A^T P B P^T )`.</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    &gt;&gt;&gt; perm = res[&#39;col_ind&#39;]</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    &gt;&gt;&gt; P = np.eye(len(A), dtype=int)[perm]</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    &gt;&gt;&gt; fun = np.trace(A.T @ P @ B @ P.T)</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    &gt;&gt;&gt; print(fun)</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    3260</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    Alternatively, to avoid constructing the permutation matrix explicitly,</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    directly permute the rows and columns of the distance matrix.</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    &gt;&gt;&gt; fun = np.trace(A.T @ B[perm][:, perm])</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    &gt;&gt;&gt; print(fun)</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    3260</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    Although not guaranteed in general, ``quadratic_assignment`` happens to</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    have found the globally optimal solution.</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    &gt;&gt;&gt; from itertools import permutations</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    &gt;&gt;&gt; perm_opt, fun_opt = None, np.inf</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    &gt;&gt;&gt; for perm in permutations([0, 1, 2, 3]):</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    ...     perm = np.array(perm)</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    ...     fun = np.trace(A.T @ B[perm][:, perm])</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    ...     if fun &lt; fun_opt:</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    ...         fun_opt, perm_opt = fun, perm</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    &gt;&gt;&gt; print(np.array_equal(perm_opt, res[&#39;col_ind&#39;]))</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    Here is an example for which the default method,</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    :ref:`&#39;faq&#39; &lt;optimize.qap-faq&gt;`, does not find the global optimum.</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    &gt;&gt;&gt; A = np.array([[0, 5, 8, 6], [5, 0, 5, 1],</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    ...               [8, 5, 0, 2], [6, 1, 2, 0]])</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    &gt;&gt;&gt; B = np.array([[0, 1, 8, 4], [1, 0, 5, 2],</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    ...               [8, 5, 0, 5], [4, 2, 5, 0]])</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    &gt;&gt;&gt; res = quadratic_assignment(A, B)</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    &gt;&gt;&gt; print(res)</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">     col_ind: array([1, 0, 3, 2])</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">         fun: 178</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">         nit: 13</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    If accuracy is important, consider using  :ref:`&#39;2opt&#39; &lt;optimize.qap-2opt&gt;`</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    to refine the solution.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    &gt;&gt;&gt; guess = np.array([np.arange(len(A)), res.col_ind]).T</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    &gt;&gt;&gt; res = quadratic_assignment(A, B, method=&quot;2opt&quot;,</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    ...                            options = {&#39;partial_guess&#39;: guess})</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    &gt;&gt;&gt; print(res)</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">     col_ind: array([1, 2, 3, 0])</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">         fun: 176</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">         nit: 17</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordflow">if</span> options <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  183</span>        options = {}</div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span>    method = method.lower()</div>
<div class="line"><span class="lineno">  186</span>    methods = {<span class="stringliteral">&quot;faq&quot;</span>: _quadratic_assignment_faq,</div>
<div class="line"><span class="lineno">  187</span>               <span class="stringliteral">&quot;2opt&quot;</span>: _quadratic_assignment_2opt}</div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> methods:</div>
<div class="line"><span class="lineno">  189</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;method {method} must be in {methods}.&quot;</span>)</div>
<div class="line"><span class="lineno">  190</span>    res = methods[method](A, B, **options)</div>
<div class="line"><span class="lineno">  191</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad84a6142cd672b33e901655df3c15f61" name="ad84a6142cd672b33e901655df3c15f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84a6142cd672b33e901655df3c15f61">&#9670;&#160;</a></span>QUADRATIC_ASSIGNMENT_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.optimize._qap.QUADRATIC_ASSIGNMENT_METHODS = ['faq', '2opt']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
