<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.linalg._matfuncs_inv_ssq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html">_matfuncs_inv_ssq</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg._matfuncs_inv_ssq Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1linalg_1_1__matfuncs__inv__ssq_1_1___matrix_m1_power_operator.html">_MatrixM1PowerOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1linalg_1_1__matfuncs__inv__ssq_1_1_fractional_matrix_power_error.html">FractionalMatrixPowerError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1linalg_1_1__matfuncs__inv__ssq_1_1_logm_error.html">LogmError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1linalg_1_1__matfuncs__inv__ssq_1_1_logm_exactly_singular_warning.html">LogmExactlySingularWarning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1linalg_1_1__matfuncs__inv__ssq_1_1_logm_nearly_singular_warning.html">LogmNearlySingularWarning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1linalg_1_1__matfuncs__inv__ssq_1_1_logm_rank_warning.html">LogmRankWarning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae9af913812a20e1ab68630945a6a8e61" id="r_ae9af913812a20e1ab68630945a6a8e61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#ae9af913812a20e1ab68630945a6a8e61">_onenormest_m1_power</a> (A, p, t=2, itmax=5, compute_v=False, compute_w=False)</td></tr>
<tr class="separator:ae9af913812a20e1ab68630945a6a8e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd484a868b441270003b228f44e5ae" id="r_afdcd484a868b441270003b228f44e5ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#afdcd484a868b441270003b228f44e5ae">_unwindk</a> (<a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>)</td></tr>
<tr class="separator:afdcd484a868b441270003b228f44e5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c54d620e3929a790b5219a05fe9c46" id="r_a08c54d620e3929a790b5219a05fe9c46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a08c54d620e3929a790b5219a05fe9c46">_briggs_helper_function</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:a08c54d620e3929a790b5219a05fe9c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574357951ad33a0295891a44e8365125" id="r_a574357951ad33a0295891a44e8365125"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a574357951ad33a0295891a44e8365125">_fractional_power_superdiag_entry</a> (l1, l2, t12, p)</td></tr>
<tr class="separator:a574357951ad33a0295891a44e8365125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f220305e79b81a20497409f6c5e9ef0" id="r_a5f220305e79b81a20497409f6c5e9ef0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a5f220305e79b81a20497409f6c5e9ef0">_logm_superdiag_entry</a> (l1, l2, t12)</td></tr>
<tr class="separator:a5f220305e79b81a20497409f6c5e9ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb08005fb1f2c5242360d16f4ee53fd5" id="r_afb08005fb1f2c5242360d16f4ee53fd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#afb08005fb1f2c5242360d16f4ee53fd5">_inverse_squaring_helper</a> (T0, <a class="el" href="__lapack__subroutines_8h.html#a68abd7cf2689a313136b50c232300582">theta</a>)</td></tr>
<tr class="separator:afb08005fb1f2c5242360d16f4ee53fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d5fd466236b491515a1a0257c1a6ef" id="r_a14d5fd466236b491515a1a0257c1a6ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a14d5fd466236b491515a1a0257c1a6ef">_fractional_power_pade_constant</a> (<a class="el" href="__lapack__subroutines_8h.html#a5325f1842789194c441b272cbf424674">i</a>, t)</td></tr>
<tr class="separator:a14d5fd466236b491515a1a0257c1a6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bda4c4fe0eaa1ca0bcc59e0223c675a" id="r_a8bda4c4fe0eaa1ca0bcc59e0223c675a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a8bda4c4fe0eaa1ca0bcc59e0223c675a">_fractional_power_pade</a> (R, t, m)</td></tr>
<tr class="separator:a8bda4c4fe0eaa1ca0bcc59e0223c675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da3e36b452eb945e08726f1576eb5a8" id="r_a7da3e36b452eb945e08726f1576eb5a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a7da3e36b452eb945e08726f1576eb5a8">_remainder_matrix_power_triu</a> (T, t)</td></tr>
<tr class="separator:a7da3e36b452eb945e08726f1576eb5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883e1aad2ca2ad3e091e6a0367ae589a" id="r_a883e1aad2ca2ad3e091e6a0367ae589a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a883e1aad2ca2ad3e091e6a0367ae589a">_remainder_matrix_power</a> (A, t)</td></tr>
<tr class="separator:a883e1aad2ca2ad3e091e6a0367ae589a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42f8a958adba7d7dc6afcb8d006823e" id="r_ad42f8a958adba7d7dc6afcb8d006823e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#ad42f8a958adba7d7dc6afcb8d006823e">_fractional_matrix_power</a> (A, p)</td></tr>
<tr class="separator:ad42f8a958adba7d7dc6afcb8d006823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194bc215e25f22bbcd3dde89306bb8ab" id="r_a194bc215e25f22bbcd3dde89306bb8ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a194bc215e25f22bbcd3dde89306bb8ab">_logm_triu</a> (T)</td></tr>
<tr class="separator:a194bc215e25f22bbcd3dde89306bb8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ba8b9673122fb320eb88d52a1e9d1d" id="r_af3ba8b9673122fb320eb88d52a1e9d1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#af3ba8b9673122fb320eb88d52a1e9d1d">_logm_force_nonsingular_triangular_matrix</a> (T, inplace=False)</td></tr>
<tr class="separator:af3ba8b9673122fb320eb88d52a1e9d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f65c2252da70eeedd5e2a66036df70d" id="r_a8f65c2252da70eeedd5e2a66036df70d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__matfuncs__inv__ssq.html#a8f65c2252da70eeedd5e2a66036df70d">_logm</a> (A)</td></tr>
<tr class="separator:a8f65c2252da70eeedd5e2a66036df70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Matrix functions that use Pade approximation with inverse scaling and squaring.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a08c54d620e3929a790b5219a05fe9c46" name="a08c54d620e3929a790b5219a05fe9c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c54d620e3929a790b5219a05fe9c46">&#9670;&#160;</a></span>_briggs_helper_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._briggs_helper_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computes r = a^(1 / (2^k)) - 1.

This is algorithm (2) of [1]_.
The purpose is to avoid a danger of subtractive cancellation.
For more computational efficiency it should probably be cythonized.

Parameters
----------
a : complex
    A complex number.
k : integer
    A nonnegative integer.

Returns
-------
r : complex
    The value r = a^(1 / (2^k)) - 1 computed with less cancellation.

Notes
-----
The algorithm as formulated in the reference does not handle k=0 or k=1
correctly, so these are special-cased in this implementation.
This function is intended to not allow `a` to belong to the closed
negative real axis, but this constraint is relaxed.

References
----------
.. [1] Awad H. Al-Mohy (2012)
       "A more accurate Briggs method for the logarithm",
       Numerical Algorithms, 59 : 393--402.</pre> <div class="fragment"><div class="line"><span class="lineno">  154</span><span class="keyword">def </span>_briggs_helper_function(a, k):</div>
<div class="line"><span class="lineno">  155</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    Computes r = a^(1 / (2^k)) - 1.</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    This is algorithm (2) of [1]_.</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    The purpose is to avoid a danger of subtractive cancellation.</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    For more computational efficiency it should probably be cythonized.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    a : complex</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        A complex number.</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    k : integer</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">        A nonnegative integer.</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    r : complex</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        The value r = a^(1 / (2^k)) - 1 computed with less cancellation.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    The algorithm as formulated in the reference does not handle k=0 or k=1</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    correctly, so these are special-cased in this implementation.</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    This function is intended to not allow `a` to belong to the closed</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    negative real axis, but this constraint is relaxed.</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    .. [1] Awad H. Al-Mohy (2012)</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">           &quot;A more accurate Briggs method for the logarithm&quot;,</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">           Numerical Algorithms, 59 : 393--402.</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">if</span> k &lt; 0 <span class="keywordflow">or</span> int(k) != k:</div>
<div class="line"><span class="lineno">  189</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected a nonnegative integer k&#39;</span>)</div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno">  191</span>        <span class="keywordflow">return</span> a - 1</div>
<div class="line"><span class="lineno">  192</span>    <span class="keywordflow">elif</span> k == 1:</div>
<div class="line"><span class="lineno">  193</span>        <span class="keywordflow">return</span> np.sqrt(a) - 1</div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  195</span>        k_hat = k</div>
<div class="line"><span class="lineno">  196</span>        <span class="keywordflow">if</span> np.angle(a) &gt;= np.pi / 2:</div>
<div class="line"><span class="lineno">  197</span>            a = np.sqrt(a)</div>
<div class="line"><span class="lineno">  198</span>            k_hat = k - 1</div>
<div class="line"><span class="lineno">  199</span>        z0 = a - 1</div>
<div class="line"><span class="lineno">  200</span>        a = np.sqrt(a)</div>
<div class="line"><span class="lineno">  201</span>        r = 1 + a</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(1, k_hat):</div>
<div class="line"><span class="lineno">  203</span>            a = np.sqrt(a)</div>
<div class="line"><span class="lineno">  204</span>            r = r * (1 + a)</div>
<div class="line"><span class="lineno">  205</span>        r = z0 / r</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno">  207</span> </div>
<div class="line"><span class="lineno">  208</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad42f8a958adba7d7dc6afcb8d006823e" name="ad42f8a958adba7d7dc6afcb8d006823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42f8a958adba7d7dc6afcb8d006823e">&#9670;&#160;</a></span>_fractional_matrix_power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._fractional_matrix_power </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the fractional power of a matrix.

See the fractional_matrix_power docstring in matfuncs.py for more info.</pre> <div class="fragment"><div class="line"><span class="lineno">  671</span><span class="keyword">def </span>_fractional_matrix_power(A, p):</div>
<div class="line"><span class="lineno">  672</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    Compute the fractional power of a matrix.</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    See the fractional_matrix_power docstring in matfuncs.py for more info.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  678</span>    A = np.asarray(A)</div>
<div class="line"><span class="lineno">  679</span>    <span class="keywordflow">if</span> len(A.shape) != 2 <span class="keywordflow">or</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  680</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected a square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  681</span>    <span class="keywordflow">if</span> p == int(p):</div>
<div class="line"><span class="lineno">  682</span>        <span class="keywordflow">return</span> np.linalg.matrix_power(A, int(p))</div>
<div class="line"><span class="lineno">  683</span>    <span class="comment"># Compute singular values.</span></div>
<div class="line"><span class="lineno">  684</span>    s = svdvals(A)</div>
<div class="line"><span class="lineno">  685</span>    <span class="comment"># Inverse scaling and squaring cannot deal with a singular matrix,</span></div>
<div class="line"><span class="lineno">  686</span>    <span class="comment"># because the process of repeatedly taking square roots</span></div>
<div class="line"><span class="lineno">  687</span>    <span class="comment"># would not converge to the identity matrix.</span></div>
<div class="line"><span class="lineno">  688</span>    <span class="keywordflow">if</span> s[-1]:</div>
<div class="line"><span class="lineno">  689</span>        <span class="comment"># Compute the condition number relative to matrix inversion,</span></div>
<div class="line"><span class="lineno">  690</span>        <span class="comment"># and use this to decide between floor(p) and ceil(p).</span></div>
<div class="line"><span class="lineno">  691</span>        k2 = s[0] / s[-1]</div>
<div class="line"><span class="lineno">  692</span>        p1 = p - np.floor(p)</div>
<div class="line"><span class="lineno">  693</span>        p2 = p - np.ceil(p)</div>
<div class="line"><span class="lineno">  694</span>        <span class="keywordflow">if</span> p1 * k2 ** (1 - p1) &lt;= -p2 * k2:</div>
<div class="line"><span class="lineno">  695</span>            a = int(np.floor(p))</div>
<div class="line"><span class="lineno">  696</span>            b = p1</div>
<div class="line"><span class="lineno">  697</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  698</span>            a = int(np.ceil(p))</div>
<div class="line"><span class="lineno">  699</span>            b = p2</div>
<div class="line"><span class="lineno">  700</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  701</span>            R = _remainder_matrix_power(A, b)</div>
<div class="line"><span class="lineno">  702</span>            Q = np.linalg.matrix_power(A, a)</div>
<div class="line"><span class="lineno">  703</span>            <span class="keywordflow">return</span> Q.dot(R)</div>
<div class="line"><span class="lineno">  704</span>        <span class="keywordflow">except</span> np.linalg.LinAlgError:</div>
<div class="line"><span class="lineno">  705</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  706</span>    <span class="comment"># If p is negative then we are going to give up.</span></div>
<div class="line"><span class="lineno">  707</span>    <span class="comment"># If p is non-negative then we can fall back to generic funm.</span></div>
<div class="line"><span class="lineno">  708</span>    <span class="keywordflow">if</span> p &lt; 0:</div>
<div class="line"><span class="lineno">  709</span>        X = np.empty_like(A)</div>
<div class="line"><span class="lineno">  710</span>        X.fill(np.nan)</div>
<div class="line"><span class="lineno">  711</span>        <span class="keywordflow">return</span> X</div>
<div class="line"><span class="lineno">  712</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  713</span>        p1 = p - np.floor(p)</div>
<div class="line"><span class="lineno">  714</span>        a = int(np.floor(p))</div>
<div class="line"><span class="lineno">  715</span>        b = p1</div>
<div class="line"><span class="lineno">  716</span>        R, info = funm(A, <span class="keyword">lambda</span> x: pow(x, b), disp=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  717</span>        Q = np.linalg.matrix_power(A, a)</div>
<div class="line"><span class="lineno">  718</span>        <span class="keywordflow">return</span> Q.dot(R)</div>
<div class="line"><span class="lineno">  719</span> </div>
<div class="line"><span class="lineno">  720</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8bda4c4fe0eaa1ca0bcc59e0223c675a" name="a8bda4c4fe0eaa1ca0bcc59e0223c675a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bda4c4fe0eaa1ca0bcc59e0223c675a">&#9670;&#160;</a></span>_fractional_power_pade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._fractional_power_pade </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Evaluate the Pade approximation of a fractional matrix power.

Evaluate the degree-m Pade approximation of R
to the fractional matrix power t using the continued fraction
in bottom-up fashion using algorithm (4.1) in [1]_.

Parameters
----------
R : (N, N) array_like
    Upper triangular matrix whose fractional power to evaluate.
t : float
    Fractional power between -1 and 1 exclusive.
m : positive integer
    Degree of Pade approximation.

Returns
-------
U : (N, N) array_like
    The degree-m Pade approximation of R to the fractional power t.
    This matrix will be upper triangular.

References
----------
.. [1] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</pre> <div class="fragment"><div class="line"><span class="lineno">  467</span><span class="keyword">def </span>_fractional_power_pade(R, t, m):</div>
<div class="line"><span class="lineno">  468</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    Evaluate the Pade approximation of a fractional matrix power.</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    Evaluate the degree-m Pade approximation of R</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    to the fractional matrix power t using the continued fraction</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    in bottom-up fashion using algorithm (4.1) in [1]_.</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    R : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        Upper triangular matrix whose fractional power to evaluate.</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    t : float</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        Fractional power between -1 and 1 exclusive.</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    m : positive integer</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        Degree of Pade approximation.</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    U : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        The degree-m Pade approximation of R to the fractional power t.</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">        This matrix will be upper triangular.</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    .. [1] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  498</span>    <span class="keywordflow">if</span> m &lt; 1 <span class="keywordflow">or</span> int(m) != m:</div>
<div class="line"><span class="lineno">  499</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected a positive integer m&#39;</span>)</div>
<div class="line"><span class="lineno">  500</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (-1 &lt; t &lt; 1):</div>
<div class="line"><span class="lineno">  501</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected -1 &lt; t &lt; 1&#39;</span>)</div>
<div class="line"><span class="lineno">  502</span>    R = np.asarray(R)</div>
<div class="line"><span class="lineno">  503</span>    <span class="keywordflow">if</span> len(R.shape) != 2 <span class="keywordflow">or</span> R.shape[0] != R.shape[1]:</div>
<div class="line"><span class="lineno">  504</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected an upper triangular square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  505</span>    n, n = R.shape</div>
<div class="line"><span class="lineno">  506</span>    ident = np.identity(n)</div>
<div class="line"><span class="lineno">  507</span>    Y = R * _fractional_power_pade_constant(2*m, t)</div>
<div class="line"><span class="lineno">  508</span>    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(2*m - 1, 0, -1):</div>
<div class="line"><span class="lineno">  509</span>        rhs = R * _fractional_power_pade_constant(j, t)</div>
<div class="line"><span class="lineno">  510</span>        Y = solve_triangular(ident + Y, rhs)</div>
<div class="line"><span class="lineno">  511</span>    U = ident + Y</div>
<div class="line"><span class="lineno">  512</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.array_equal(U, np.triu(U)):</div>
<div class="line"><span class="lineno">  513</span>        <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;U is not upper triangular&#39;</span>)</div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">return</span> U</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a14d5fd466236b491515a1a0257c1a6ef" name="a14d5fd466236b491515a1a0257c1a6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d5fd466236b491515a1a0257c1a6ef">&#9670;&#160;</a></span>_fractional_power_pade_constant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._fractional_power_pade_constant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  449</span><span class="keyword">def </span>_fractional_power_pade_constant(i, t):</div>
<div class="line"><span class="lineno">  450</span>    <span class="comment"># A helper function for matrix fractional power.</span></div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">if</span> i &lt; 1:</div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected a positive integer i&#39;</span>)</div>
<div class="line"><span class="lineno">  453</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (-1 &lt; t &lt; 1):</div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected -1 &lt; t &lt; 1&#39;</span>)</div>
<div class="line"><span class="lineno">  455</span>    <span class="keywordflow">if</span> i == 1:</div>
<div class="line"><span class="lineno">  456</span>        <span class="keywordflow">return</span> -t</div>
<div class="line"><span class="lineno">  457</span>    <span class="keywordflow">elif</span> i % 2 == 0:</div>
<div class="line"><span class="lineno">  458</span>        j = i // 2</div>
<div class="line"><span class="lineno">  459</span>        <span class="keywordflow">return</span> (-j + t) / (2 * (2*j - 1))</div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">elif</span> i % 2 == 1:</div>
<div class="line"><span class="lineno">  461</span>        j = (i - 1) // 2</div>
<div class="line"><span class="lineno">  462</span>        <span class="keywordflow">return</span> (-j - t) / (2 * (2*j + 1))</div>
<div class="line"><span class="lineno">  463</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  464</span>        <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;unnexpected value of i, i = {}&#39;</span>.format(i))</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a574357951ad33a0295891a44e8365125" name="a574357951ad33a0295891a44e8365125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574357951ad33a0295891a44e8365125">&#9670;&#160;</a></span>_fractional_power_superdiag_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._fractional_power_superdiag_entry </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a superdiagonal entry of a fractional matrix power.

This is Eq. (5.6) in [1]_.

Parameters
----------
l1 : complex
    A diagonal entry of the matrix.
l2 : complex
    A diagonal entry of the matrix.
t12 : complex
    A superdiagonal entry of the matrix.
p : float
    A fractional power.

Returns
-------
f12 : complex
    A superdiagonal entry of the fractional matrix power.

Notes
-----
Care has been taken to return a real number if possible when
all of the inputs are real numbers.

References
----------
.. [1] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</pre> <div class="fragment"><div class="line"><span class="lineno">  209</span><span class="keyword">def </span>_fractional_power_superdiag_entry(l1, l2, t12, p):</div>
<div class="line"><span class="lineno">  210</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    Compute a superdiagonal entry of a fractional matrix power.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    This is Eq. (5.6) in [1]_.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    l1 : complex</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        A diagonal entry of the matrix.</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    l2 : complex</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        A diagonal entry of the matrix.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    t12 : complex</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        A superdiagonal entry of the matrix.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    p : float</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">        A fractional power.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    f12 : complex</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        A superdiagonal entry of the fractional matrix power.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    Care has been taken to return a real number if possible when</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    all of the inputs are real numbers.</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    .. [1] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  244</span>    <span class="keywordflow">if</span> l1 == l2:</div>
<div class="line"><span class="lineno">  245</span>        f12 = t12 * p * l1**(p-1)</div>
<div class="line"><span class="lineno">  246</span>    <span class="keywordflow">elif</span> abs(l2 - l1) &gt; abs(l1 + l2) / 2:</div>
<div class="line"><span class="lineno">  247</span>        f12 = t12 * ((l2**p) - (l1**p)) / (l2 - l1)</div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  249</span>        <span class="comment"># This is Eq. (5.5) in [1].</span></div>
<div class="line"><span class="lineno">  250</span>        z = (l2 - l1) / (l2 + l1)</div>
<div class="line"><span class="lineno">  251</span>        log_l1 = np.log(l1)</div>
<div class="line"><span class="lineno">  252</span>        log_l2 = np.log(l2)</div>
<div class="line"><span class="lineno">  253</span>        arctanh_z = np.arctanh(z)</div>
<div class="line"><span class="lineno">  254</span>        tmp_a = t12 * np.exp((p/2)*(log_l2 + log_l1))</div>
<div class="line"><span class="lineno">  255</span>        tmp_u = _unwindk(log_l2 - log_l1)</div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordflow">if</span> tmp_u:</div>
<div class="line"><span class="lineno">  257</span>            tmp_b = p * (arctanh_z + np.pi * 1j * tmp_u)</div>
<div class="line"><span class="lineno">  258</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  259</span>            tmp_b = p * arctanh_z</div>
<div class="line"><span class="lineno">  260</span>        tmp_c = 2 * np.sinh(tmp_b) / (l2 - l1)</div>
<div class="line"><span class="lineno">  261</span>        f12 = tmp_a * tmp_c</div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">return</span> f12</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afb08005fb1f2c5242360d16f4ee53fd5" name="afb08005fb1f2c5242360d16f4ee53fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb08005fb1f2c5242360d16f4ee53fd5">&#9670;&#160;</a></span>_inverse_squaring_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._inverse_squaring_helper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A helper function for inverse scaling and squaring for Pade approximation.

Parameters
----------
T0 : (N, N) array_like upper triangular
    Matrix involved in inverse scaling and squaring.
theta : indexable
    The values theta[1] .. theta[7] must be available.
    They represent bounds related to Pade approximation, and they depend
    on the matrix function which is being computed.
    For example, different values of theta are required for
    matrix logarithm than for fractional matrix power.

Returns
-------
R : (N, N) array_like upper triangular
    Composition of zero or more matrix square roots of T0, minus I.
s : non-negative integer
    Number of square roots taken.
m : positive integer
    The degree of the Pade approximation.

Notes
-----
This subroutine appears as a chunk of lines within
a couple of published algorithms; for example it appears
as lines 4--35 in algorithm (3.1) of [1]_, and
as lines 3--34 in algorithm (4.1) of [2]_.
The instances of 'goto line 38' in algorithm (3.1) of [1]_
probably mean 'goto line 36' and have been intepreted accordingly.

References
----------
.. [1] Nicholas J. Higham and Lijing Lin (2013)
       "An Improved Schur-Pade Algorithm for Fractional Powers
       of a Matrix and their Frechet Derivatives."

.. [2] Awad H. Al-Mohy and Nicholas J. Higham (2012)
       "Improved Inverse Scaling and Squaring Algorithms
       for the Matrix Logarithm."
       SIAM Journal on Scientific Computing, 34 (4). C152-C169.
       ISSN 1095-7197</pre> <div class="fragment"><div class="line"><span class="lineno">  312</span><span class="keyword">def </span>_inverse_squaring_helper(T0, theta):</div>
<div class="line"><span class="lineno">  313</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    A helper function for inverse scaling and squaring for Pade approximation.</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    T0 : (N, N) array_like upper triangular</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        Matrix involved in inverse scaling and squaring.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    theta : indexable</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">        The values theta[1] .. theta[7] must be available.</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">        They represent bounds related to Pade approximation, and they depend</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">        on the matrix function which is being computed.</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        For example, different values of theta are required for</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        matrix logarithm than for fractional matrix power.</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    R : (N, N) array_like upper triangular</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">        Composition of zero or more matrix square roots of T0, minus I.</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    s : non-negative integer</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        Number of square roots taken.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    m : positive integer</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        The degree of the Pade approximation.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    This subroutine appears as a chunk of lines within</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    a couple of published algorithms; for example it appears</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    as lines 4--35 in algorithm (3.1) of [1]_, and</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    as lines 3--34 in algorithm (4.1) of [2]_.</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    The instances of &#39;goto line 38&#39; in algorithm (3.1) of [1]_</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    probably mean &#39;goto line 36&#39; and have been intepreted accordingly.</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    .. [1] Nicholas J. Higham and Lijing Lin (2013)</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">           &quot;An Improved Schur-Pade Algorithm for Fractional Powers</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">           of a Matrix and their Frechet Derivatives.&quot;</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    .. [2] Awad H. Al-Mohy and Nicholas J. Higham (2012)</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">           &quot;Improved Inverse Scaling and Squaring Algorithms</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">           for the Matrix Logarithm.&quot;</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">           SIAM Journal on Scientific Computing, 34 (4). C152-C169.</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">           ISSN 1095-7197</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  358</span>    <span class="keywordflow">if</span> len(T0.shape) != 2 <span class="keywordflow">or</span> T0.shape[0] != T0.shape[1]:</div>
<div class="line"><span class="lineno">  359</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected an upper triangular square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  360</span>    n, n = T0.shape</div>
<div class="line"><span class="lineno">  361</span>    T = T0</div>
<div class="line"><span class="lineno">  362</span> </div>
<div class="line"><span class="lineno">  363</span>    <span class="comment"># Find s0, the smallest s such that the spectral radius</span></div>
<div class="line"><span class="lineno">  364</span>    <span class="comment"># of a certain diagonal matrix is at most theta[7].</span></div>
<div class="line"><span class="lineno">  365</span>    <span class="comment"># Note that because theta[7] &lt; 1,</span></div>
<div class="line"><span class="lineno">  366</span>    <span class="comment"># this search will not terminate if any diagonal entry of T is zero.</span></div>
<div class="line"><span class="lineno">  367</span>    s0 = 0</div>
<div class="line"><span class="lineno">  368</span>    tmp_diag = np.diag(T)</div>
<div class="line"><span class="lineno">  369</span>    <span class="keywordflow">if</span> np.count_nonzero(tmp_diag) != n:</div>
<div class="line"><span class="lineno">  370</span>        <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;Diagonal entries of T must be nonzero&#39;</span>)</div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordflow">while</span> np.max(np.absolute(tmp_diag - 1)) &gt; theta[7]:</div>
<div class="line"><span class="lineno">  372</span>        tmp_diag = np.sqrt(tmp_diag)</div>
<div class="line"><span class="lineno">  373</span>        s0 += 1</div>
<div class="line"><span class="lineno">  374</span> </div>
<div class="line"><span class="lineno">  375</span>    <span class="comment"># Take matrix square roots of T.</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(s0):</div>
<div class="line"><span class="lineno">  377</span>        T = _sqrtm_triu(T)</div>
<div class="line"><span class="lineno">  378</span> </div>
<div class="line"><span class="lineno">  379</span>    <span class="comment"># Flow control in this section is a little odd.</span></div>
<div class="line"><span class="lineno">  380</span>    <span class="comment"># This is because I am translating algorithm descriptions</span></div>
<div class="line"><span class="lineno">  381</span>    <span class="comment"># which have GOTOs in the publication.</span></div>
<div class="line"><span class="lineno">  382</span>    s = s0</div>
<div class="line"><span class="lineno">  383</span>    k = 0</div>
<div class="line"><span class="lineno">  384</span>    d2 = _onenormest_m1_power(T, 2) ** (1/2)</div>
<div class="line"><span class="lineno">  385</span>    d3 = _onenormest_m1_power(T, 3) ** (1/3)</div>
<div class="line"><span class="lineno">  386</span>    a2 = max(d2, d3)</div>
<div class="line"><span class="lineno">  387</span>    m = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> (1, 2):</div>
<div class="line"><span class="lineno">  389</span>        <span class="keywordflow">if</span> a2 &lt;= theta[i]:</div>
<div class="line"><span class="lineno">  390</span>            m = i</div>
<div class="line"><span class="lineno">  391</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordflow">while</span> m <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  393</span>        <span class="keywordflow">if</span> s &gt; s0:</div>
<div class="line"><span class="lineno">  394</span>            d3 = _onenormest_m1_power(T, 3) ** (1/3)</div>
<div class="line"><span class="lineno">  395</span>        d4 = _onenormest_m1_power(T, 4) ** (1/4)</div>
<div class="line"><span class="lineno">  396</span>        a3 = max(d3, d4)</div>
<div class="line"><span class="lineno">  397</span>        <span class="keywordflow">if</span> a3 &lt;= theta[7]:</div>
<div class="line"><span class="lineno">  398</span>            j1 = min(i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> (3, 4, 5, 6, 7) <span class="keywordflow">if</span> a3 &lt;= theta[i])</div>
<div class="line"><span class="lineno">  399</span>            <span class="keywordflow">if</span> j1 &lt;= 6:</div>
<div class="line"><span class="lineno">  400</span>                m = j1</div>
<div class="line"><span class="lineno">  401</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  402</span>            <span class="keywordflow">elif</span> a3 / 2 &lt;= theta[5] <span class="keywordflow">and</span> k &lt; 2:</div>
<div class="line"><span class="lineno">  403</span>                k += 1</div>
<div class="line"><span class="lineno">  404</span>                T = _sqrtm_triu(T)</div>
<div class="line"><span class="lineno">  405</span>                s += 1</div>
<div class="line"><span class="lineno">  406</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  407</span>        d5 = _onenormest_m1_power(T, 5) ** (1/5)</div>
<div class="line"><span class="lineno">  408</span>        a4 = max(d4, d5)</div>
<div class="line"><span class="lineno">  409</span>        eta = min(a3, a4)</div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> (6, 7):</div>
<div class="line"><span class="lineno">  411</span>            <span class="keywordflow">if</span> eta &lt;= theta[i]:</div>
<div class="line"><span class="lineno">  412</span>                m = i</div>
<div class="line"><span class="lineno">  413</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  414</span>        <span class="keywordflow">if</span> m <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  415</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  416</span>        T = _sqrtm_triu(T)</div>
<div class="line"><span class="lineno">  417</span>        s += 1</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span>    <span class="comment"># The subtraction of the identity is redundant here,</span></div>
<div class="line"><span class="lineno">  420</span>    <span class="comment"># because the diagonal will be replaced for improved numerical accuracy,</span></div>
<div class="line"><span class="lineno">  421</span>    <span class="comment"># but this formulation should help clarify the meaning of R.</span></div>
<div class="line"><span class="lineno">  422</span>    R = T - np.identity(n)</div>
<div class="line"><span class="lineno">  423</span> </div>
<div class="line"><span class="lineno">  424</span>    <span class="comment"># Replace the diagonal and first superdiagonal of T0^(1/(2^s)) - I</span></div>
<div class="line"><span class="lineno">  425</span>    <span class="comment"># using formulas that have less subtractive cancellation.</span></div>
<div class="line"><span class="lineno">  426</span>    <span class="comment"># Skip this step if the principal branch</span></div>
<div class="line"><span class="lineno">  427</span>    <span class="comment"># does not exist at T0; this happens when a diagonal entry of T0</span></div>
<div class="line"><span class="lineno">  428</span>    <span class="comment"># is negative with imaginary part 0.</span></div>
<div class="line"><span class="lineno">  429</span>    has_principal_branch = all(x.real &gt; 0 <span class="keywordflow">or</span> x.imag != 0 <span class="keywordflow">for</span> x <span class="keywordflow">in</span> np.diag(T0))</div>
<div class="line"><span class="lineno">  430</span>    <span class="keywordflow">if</span> has_principal_branch:</div>
<div class="line"><span class="lineno">  431</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">  432</span>            a = T0[j, j]</div>
<div class="line"><span class="lineno">  433</span>            r = _briggs_helper_function(a, s)</div>
<div class="line"><span class="lineno">  434</span>            R[j, j] = r</div>
<div class="line"><span class="lineno">  435</span>        p = np.exp2(-s)</div>
<div class="line"><span class="lineno">  436</span>        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(n-1):</div>
<div class="line"><span class="lineno">  437</span>            l1 = T0[j, j]</div>
<div class="line"><span class="lineno">  438</span>            l2 = T0[j+1, j+1]</div>
<div class="line"><span class="lineno">  439</span>            t12 = T0[j, j+1]</div>
<div class="line"><span class="lineno">  440</span>            f12 = _fractional_power_superdiag_entry(l1, l2, t12, p)</div>
<div class="line"><span class="lineno">  441</span>            R[j, j+1] = f12</div>
<div class="line"><span class="lineno">  442</span> </div>
<div class="line"><span class="lineno">  443</span>    <span class="comment"># Return the T-I matrix, the number of square roots, and the Pade degree.</span></div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.array_equal(R, np.triu(R)):</div>
<div class="line"><span class="lineno">  445</span>        <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;R is not upper triangular&#39;</span>)</div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordflow">return</span> R, s, m</div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f65c2252da70eeedd5e2a66036df70d" name="a8f65c2252da70eeedd5e2a66036df70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f65c2252da70eeedd5e2a66036df70d">&#9670;&#160;</a></span>_logm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._logm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the matrix logarithm.

See the logm docstring in matfuncs.py for more info.

Notes
-----
In this function we look at triangular matrices that are similar
to the input matrix. If any diagonal entry of such a triangular matrix
is exactly zero then the original matrix is singular.
The matrix logarithm does not exist for such matrices,
but in such cases we will pretend that the diagonal entries that are zero
are actually slightly positive by an ad-hoc amount, in the interest
of returning something more useful than NaN. This will cause a warning.</pre> <div class="fragment"><div class="line"><span class="lineno">  840</span><span class="keyword">def </span>_logm(A):</div>
<div class="line"><span class="lineno">  841</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    Compute the matrix logarithm.</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    See the logm docstring in matfuncs.py for more info.</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    In this function we look at triangular matrices that are similar</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    to the input matrix. If any diagonal entry of such a triangular matrix</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    is exactly zero then the original matrix is singular.</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    The matrix logarithm does not exist for such matrices,</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    but in such cases we will pretend that the diagonal entries that are zero</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    are actually slightly positive by an ad-hoc amount, in the interest</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    of returning something more useful than NaN. This will cause a warning.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  857</span>    A = np.asarray(A)</div>
<div class="line"><span class="lineno">  858</span>    <span class="keywordflow">if</span> len(A.shape) != 2 <span class="keywordflow">or</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  859</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected a square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  860</span> </div>
<div class="line"><span class="lineno">  861</span>    <span class="comment"># If the input matrix dtype is integer then copy to a float dtype matrix.</span></div>
<div class="line"><span class="lineno">  862</span>    <span class="keywordflow">if</span> issubclass(A.dtype.type, np.integer):</div>
<div class="line"><span class="lineno">  863</span>        A = np.asarray(A, dtype=float)</div>
<div class="line"><span class="lineno">  864</span> </div>
<div class="line"><span class="lineno">  865</span>    keep_it_real = np.isrealobj(A)</div>
<div class="line"><span class="lineno">  866</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  867</span>        <span class="keywordflow">if</span> np.array_equal(A, np.triu(A)):</div>
<div class="line"><span class="lineno">  868</span>            A = _logm_force_nonsingular_triangular_matrix(A)</div>
<div class="line"><span class="lineno">  869</span>            <span class="keywordflow">if</span> np.min(np.diag(A)) &lt; 0:</div>
<div class="line"><span class="lineno">  870</span>                A = A.astype(complex)</div>
<div class="line"><span class="lineno">  871</span>            <span class="keywordflow">return</span> _logm_triu(A)</div>
<div class="line"><span class="lineno">  872</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  873</span>            <span class="keywordflow">if</span> keep_it_real:</div>
<div class="line"><span class="lineno">  874</span>                T, Z = schur(A)</div>
<div class="line"><span class="lineno">  875</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.array_equal(T, np.triu(T)):</div>
<div class="line"><span class="lineno">  876</span>                    T, Z = rsf2csf(T, Z)</div>
<div class="line"><span class="lineno">  877</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  878</span>                T, Z = schur(A, output=<span class="stringliteral">&#39;complex&#39;</span>)</div>
<div class="line"><span class="lineno">  879</span>            T = _logm_force_nonsingular_triangular_matrix(T, inplace=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  880</span>            U = _logm_triu(T)</div>
<div class="line"><span class="lineno">  881</span>            ZH = np.conjugate(Z).T</div>
<div class="line"><span class="lineno">  882</span>            <span class="keywordflow">return</span> Z.dot(U).dot(ZH)</div>
<div class="line"><span class="lineno">  883</span>    <span class="keywordflow">except</span> (SqrtmError, LogmError):</div>
<div class="line"><span class="lineno">  884</span>        X = np.empty_like(A)</div>
<div class="line"><span class="lineno">  885</span>        X.fill(np.nan)</div>
<div class="line"><span class="lineno">  886</span>        <span class="keywordflow">return</span> X</div>
</div><!-- fragment -->
</div>
</div>
<a id="af3ba8b9673122fb320eb88d52a1e9d1d" name="af3ba8b9673122fb320eb88d52a1e9d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ba8b9673122fb320eb88d52a1e9d1d">&#9670;&#160;</a></span>_logm_force_nonsingular_triangular_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._logm_force_nonsingular_triangular_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inplace</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  820</span><span class="keyword">def </span>_logm_force_nonsingular_triangular_matrix(T, inplace=False):</div>
<div class="line"><span class="lineno">  821</span>    <span class="comment"># The input matrix should be upper triangular.</span></div>
<div class="line"><span class="lineno">  822</span>    <span class="comment"># The eps is ad hoc and is not meant to be machine precision.</span></div>
<div class="line"><span class="lineno">  823</span>    tri_eps = 1e-20</div>
<div class="line"><span class="lineno">  824</span>    abs_diag = np.absolute(np.diag(T))</div>
<div class="line"><span class="lineno">  825</span>    <span class="keywordflow">if</span> np.any(abs_diag == 0):</div>
<div class="line"><span class="lineno">  826</span>        exact_singularity_msg = <span class="stringliteral">&#39;The logm input matrix is exactly singular.&#39;</span></div>
<div class="line"><span class="lineno">  827</span>        warnings.warn(exact_singularity_msg, LogmExactlySingularWarning)</div>
<div class="line"><span class="lineno">  828</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> inplace:</div>
<div class="line"><span class="lineno">  829</span>            T = T.copy()</div>
<div class="line"><span class="lineno">  830</span>        n = T.shape[0]</div>
<div class="line"><span class="lineno">  831</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">  832</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> T[i, i]:</div>
<div class="line"><span class="lineno">  833</span>                T[i, i] = tri_eps</div>
<div class="line"><span class="lineno">  834</span>    <span class="keywordflow">elif</span> np.any(abs_diag &lt; tri_eps):</div>
<div class="line"><span class="lineno">  835</span>        near_singularity_msg = <span class="stringliteral">&#39;The logm input matrix may be nearly singular.&#39;</span></div>
<div class="line"><span class="lineno">  836</span>        warnings.warn(near_singularity_msg, LogmNearlySingularWarning)</div>
<div class="line"><span class="lineno">  837</span>    <span class="keywordflow">return</span> T</div>
<div class="line"><span class="lineno">  838</span> </div>
<div class="line"><span class="lineno">  839</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f220305e79b81a20497409f6c5e9ef0" name="a5f220305e79b81a20497409f6c5e9ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f220305e79b81a20497409f6c5e9ef0">&#9670;&#160;</a></span>_logm_superdiag_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._logm_superdiag_entry </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t12</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a superdiagonal entry of a matrix logarithm.

This is like Eq. (11.28) in [1]_, except the determination of whether
l1 and l2 are sufficiently far apart has been modified.

Parameters
----------
l1 : complex
    A diagonal entry of the matrix.
l2 : complex
    A diagonal entry of the matrix.
t12 : complex
    A superdiagonal entry of the matrix.

Returns
-------
f12 : complex
    A superdiagonal entry of the matrix logarithm.

Notes
-----
Care has been taken to return a real number if possible when
all of the inputs are real numbers.

References
----------
.. [1] Nicholas J. Higham (2008)
       "Functions of Matrices: Theory and Computation"
       ISBN 978-0-898716-46-7</pre> <div class="fragment"><div class="line"><span class="lineno">  265</span><span class="keyword">def </span>_logm_superdiag_entry(l1, l2, t12):</div>
<div class="line"><span class="lineno">  266</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    Compute a superdiagonal entry of a matrix logarithm.</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    This is like Eq. (11.28) in [1]_, except the determination of whether</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    l1 and l2 are sufficiently far apart has been modified.</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    l1 : complex</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        A diagonal entry of the matrix.</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    l2 : complex</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">        A diagonal entry of the matrix.</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    t12 : complex</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        A superdiagonal entry of the matrix.</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    f12 : complex</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        A superdiagonal entry of the matrix logarithm.</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    Care has been taken to return a real number if possible when</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    all of the inputs are real numbers.</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    .. [1] Nicholas J. Higham (2008)</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">           &quot;Functions of Matrices: Theory and Computation&quot;</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">           ISBN 978-0-898716-46-7</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  298</span>    <span class="keywordflow">if</span> l1 == l2:</div>
<div class="line"><span class="lineno">  299</span>        f12 = t12 / l1</div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">elif</span> abs(l2 - l1) &gt; abs(l1 + l2) / 2:</div>
<div class="line"><span class="lineno">  301</span>        f12 = t12 * (np.log(l2) - np.log(l1)) / (l2 - l1)</div>
<div class="line"><span class="lineno">  302</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  303</span>        z = (l2 - l1) / (l2 + l1)</div>
<div class="line"><span class="lineno">  304</span>        u = _unwindk(np.log(l2) - np.log(l1))</div>
<div class="line"><span class="lineno">  305</span>        <span class="keywordflow">if</span> u:</div>
<div class="line"><span class="lineno">  306</span>            f12 = t12 * 2 * (np.arctanh(z) + np.pi*1j*u) / (l2 - l1)</div>
<div class="line"><span class="lineno">  307</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  308</span>            f12 = t12 * 2 * np.arctanh(z) / (l2 - l1)</div>
<div class="line"><span class="lineno">  309</span>    <span class="keywordflow">return</span> f12</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a194bc215e25f22bbcd3dde89306bb8ab" name="a194bc215e25f22bbcd3dde89306bb8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194bc215e25f22bbcd3dde89306bb8ab">&#9670;&#160;</a></span>_logm_triu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._logm_triu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute matrix logarithm of an upper triangular matrix.

The matrix logarithm is the inverse of
expm: expm(logm(`T`)) == `T`

Parameters
----------
T : (N, N) array_like
    Upper triangular matrix whose logarithm to evaluate

Returns
-------
logm : (N, N) ndarray
    Matrix logarithm of `T`

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
       "Improved Inverse Scaling and Squaring Algorithms
       for the Matrix Logarithm."
       SIAM Journal on Scientific Computing, 34 (4). C152-C169.
       ISSN 1095-7197

.. [2] Nicholas J. Higham (2008)
       "Functions of Matrices: Theory and Computation"
       ISBN 978-0-898716-46-7

.. [3] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</pre> <div class="fragment"><div class="line"><span class="lineno">  721</span><span class="keyword">def </span>_logm_triu(T):</div>
<div class="line"><span class="lineno">  722</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    Compute matrix logarithm of an upper triangular matrix.</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    The matrix logarithm is the inverse of</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    expm: expm(logm(`T`)) == `T`</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    T : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">        Upper triangular matrix whose logarithm to evaluate</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    logm : (N, N) ndarray</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        Matrix logarithm of `T`</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">           &quot;Improved Inverse Scaling and Squaring Algorithms</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">           for the Matrix Logarithm.&quot;</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">           SIAM Journal on Scientific Computing, 34 (4). C152-C169.</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">           ISSN 1095-7197</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    .. [2] Nicholas J. Higham (2008)</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">           &quot;Functions of Matrices: Theory and Computation&quot;</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">           ISBN 978-0-898716-46-7</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    .. [3] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  756</span>    T = np.asarray(T)</div>
<div class="line"><span class="lineno">  757</span>    <span class="keywordflow">if</span> len(T.shape) != 2 <span class="keywordflow">or</span> T.shape[0] != T.shape[1]:</div>
<div class="line"><span class="lineno">  758</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;expected an upper triangular square matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  759</span>    n, n = T.shape</div>
<div class="line"><span class="lineno">  760</span> </div>
<div class="line"><span class="lineno">  761</span>    <span class="comment"># Construct T0 with the appropriate type,</span></div>
<div class="line"><span class="lineno">  762</span>    <span class="comment"># depending on the dtype and the spectrum of T.</span></div>
<div class="line"><span class="lineno">  763</span>    T_diag = np.diag(T)</div>
<div class="line"><span class="lineno">  764</span>    keep_it_real = np.isrealobj(T) <span class="keywordflow">and</span> np.min(T_diag) &gt;= 0</div>
<div class="line"><span class="lineno">  765</span>    <span class="keywordflow">if</span> keep_it_real:</div>
<div class="line"><span class="lineno">  766</span>        T0 = T</div>
<div class="line"><span class="lineno">  767</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  768</span>        T0 = T.astype(complex)</div>
<div class="line"><span class="lineno">  769</span> </div>
<div class="line"><span class="lineno">  770</span>    <span class="comment"># Define bounds given in Table (2.1).</span></div>
<div class="line"><span class="lineno">  771</span>    theta = (<span class="keywordtype">None</span>,</div>
<div class="line"><span class="lineno">  772</span>            1.59e-5, 2.31e-3, 1.94e-2, 6.21e-2,</div>
<div class="line"><span class="lineno">  773</span>            1.28e-1, 2.06e-1, 2.88e-1, 3.67e-1,</div>
<div class="line"><span class="lineno">  774</span>            4.39e-1, 5.03e-1, 5.60e-1, 6.09e-1,</div>
<div class="line"><span class="lineno">  775</span>            6.52e-1, 6.89e-1, 7.21e-1, 7.49e-1)</div>
<div class="line"><span class="lineno">  776</span> </div>
<div class="line"><span class="lineno">  777</span>    R, s, m = _inverse_squaring_helper(T0, theta)</div>
<div class="line"><span class="lineno">  778</span> </div>
<div class="line"><span class="lineno">  779</span>    <span class="comment"># Evaluate U = 2**s r_m(T - I) using the partial fraction expansion (1.1).</span></div>
<div class="line"><span class="lineno">  780</span>    <span class="comment"># This requires the nodes and weights</span></div>
<div class="line"><span class="lineno">  781</span>    <span class="comment"># corresponding to degree-m Gauss-Legendre quadrature.</span></div>
<div class="line"><span class="lineno">  782</span>    <span class="comment"># These quadrature arrays need to be transformed from the [-1, 1] interval</span></div>
<div class="line"><span class="lineno">  783</span>    <span class="comment"># to the [0, 1] interval.</span></div>
<div class="line"><span class="lineno">  784</span>    nodes, weights = scipy.special.p_roots(m)</div>
<div class="line"><span class="lineno">  785</span>    nodes = nodes.real</div>
<div class="line"><span class="lineno">  786</span>    <span class="keywordflow">if</span> nodes.shape != (m,) <span class="keywordflow">or</span> weights.shape != (m,):</div>
<div class="line"><span class="lineno">  787</span>        <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;internal error&#39;</span>)</div>
<div class="line"><span class="lineno">  788</span>    nodes = 0.5 + 0.5 * nodes</div>
<div class="line"><span class="lineno">  789</span>    weights = 0.5 * weights</div>
<div class="line"><span class="lineno">  790</span>    ident = np.identity(n)</div>
<div class="line"><span class="lineno">  791</span>    U = np.zeros_like(R)</div>
<div class="line"><span class="lineno">  792</span>    <span class="keywordflow">for</span> alpha, beta <span class="keywordflow">in</span> zip(weights, nodes):</div>
<div class="line"><span class="lineno">  793</span>        U += solve_triangular(ident + beta*R, alpha*R)</div>
<div class="line"><span class="lineno">  794</span>    U *= np.exp2(s)</div>
<div class="line"><span class="lineno">  795</span> </div>
<div class="line"><span class="lineno">  796</span>    <span class="comment"># Skip this step if the principal branch</span></div>
<div class="line"><span class="lineno">  797</span>    <span class="comment"># does not exist at T0; this happens when a diagonal entry of T0</span></div>
<div class="line"><span class="lineno">  798</span>    <span class="comment"># is negative with imaginary part 0.</span></div>
<div class="line"><span class="lineno">  799</span>    has_principal_branch = all(x.real &gt; 0 <span class="keywordflow">or</span> x.imag != 0 <span class="keywordflow">for</span> x <span class="keywordflow">in</span> np.diag(T0))</div>
<div class="line"><span class="lineno">  800</span>    <span class="keywordflow">if</span> has_principal_branch:</div>
<div class="line"><span class="lineno">  801</span> </div>
<div class="line"><span class="lineno">  802</span>        <span class="comment"># Recompute diagonal entries of U.</span></div>
<div class="line"><span class="lineno">  803</span>        U[np.diag_indices(n)] = np.log(np.diag(T0))</div>
<div class="line"><span class="lineno">  804</span> </div>
<div class="line"><span class="lineno">  805</span>        <span class="comment"># Recompute superdiagonal entries of U.</span></div>
<div class="line"><span class="lineno">  806</span>        <span class="comment"># This indexing of this code should be renovated</span></div>
<div class="line"><span class="lineno">  807</span>        <span class="comment"># when newer np.diagonal() becomes available.</span></div>
<div class="line"><span class="lineno">  808</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n-1):</div>
<div class="line"><span class="lineno">  809</span>            l1 = T0[i, i]</div>
<div class="line"><span class="lineno">  810</span>            l2 = T0[i+1, i+1]</div>
<div class="line"><span class="lineno">  811</span>            t12 = T0[i, i+1]</div>
<div class="line"><span class="lineno">  812</span>            U[i, i+1] = _logm_superdiag_entry(l1, l2, t12)</div>
<div class="line"><span class="lineno">  813</span> </div>
<div class="line"><span class="lineno">  814</span>    <span class="comment"># Return the logm of the upper triangular matrix.</span></div>
<div class="line"><span class="lineno">  815</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.array_equal(U, np.triu(U)):</div>
<div class="line"><span class="lineno">  816</span>        <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;U is not upper triangular&#39;</span>)</div>
<div class="line"><span class="lineno">  817</span>    <span class="keywordflow">return</span> U</div>
<div class="line"><span class="lineno">  818</span> </div>
<div class="line"><span class="lineno">  819</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9af913812a20e1ab68630945a6a8e61" name="ae9af913812a20e1ab68630945a6a8e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9af913812a20e1ab68630945a6a8e61">&#9670;&#160;</a></span>_onenormest_m1_power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._onenormest_m1_power </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>itmax</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_v</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_w</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Efficiently estimate the 1-norm of (A - I)^p.

Parameters
----------
A : ndarray
    Matrix whose 1-norm of a power is to be computed.
p : int
    Non-negative integer power.
t : int, optional
    A positive parameter controlling the tradeoff between
    accuracy versus time and memory usage.
    Larger values take longer and use more memory
    but give more accurate output.
itmax : int, optional
    Use at most this many iterations.
compute_v : bool, optional
    Request a norm-maximizing linear operator input vector if True.
compute_w : bool, optional
    Request a norm-maximizing linear operator output vector if True.

Returns
-------
est : float
    An underestimate of the 1-norm of the sparse matrix.
v : ndarray, optional
    The vector such that ||Av||_1 == est*||v||_1.
    It can be thought of as an input to the linear operator
    that gives an output with particularly large norm.
w : ndarray, optional
    The vector Av which has relatively large 1-norm.
    It can be thought of as an output of the linear operator
    that is relatively large in norm compared to the input.</pre> <div class="fragment"><div class="line"><span class="lineno">   75</span>        t=2, itmax=5, compute_v=<span class="keyword">False</span>, compute_w=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">   76</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    Efficiently estimate the 1-norm of (A - I)^p.</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    A : ndarray</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        Matrix whose 1-norm of a power is to be computed.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    p : int</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">        Non-negative integer power.</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    t : int, optional</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        A positive parameter controlling the tradeoff between</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        accuracy versus time and memory usage.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        Larger values take longer and use more memory</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">        but give more accurate output.</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    itmax : int, optional</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">        Use at most this many iterations.</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    compute_v : bool, optional</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        Request a norm-maximizing linear operator input vector if True.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    compute_w : bool, optional</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        Request a norm-maximizing linear operator output vector if True.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    est : float</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        An underestimate of the 1-norm of the sparse matrix.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    v : ndarray, optional</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">        The vector such that ||Av||_1 == est*||v||_1.</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        It can be thought of as an input to the linear operator</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        that gives an output with particularly large norm.</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    w : ndarray, optional</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        The vector Av which has relatively large 1-norm.</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">        It can be thought of as an output of the linear operator</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        that is relatively large in norm compared to the input.</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  111</span>    <span class="keywordflow">return</span> onenormest(_MatrixM1PowerOperator(A, p),</div>
<div class="line"><span class="lineno">  112</span>            t=t, itmax=itmax, compute_v=compute_v, compute_w=compute_w)</div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a883e1aad2ca2ad3e091e6a0367ae589a" name="a883e1aad2ca2ad3e091e6a0367ae589a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883e1aad2ca2ad3e091e6a0367ae589a">&#9670;&#160;</a></span>_remainder_matrix_power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._remainder_matrix_power </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the fractional power of a matrix, for fractions -1 &lt; t &lt; 1.

This uses algorithm (3.1) of [1]_.
The Pade approximation itself uses algorithm (4.1) of [2]_.

Parameters
----------
A : (N, N) array_like
    Matrix whose fractional power to evaluate.
t : float
    Fractional power between -1 and 1 exclusive.

Returns
-------
X : (N, N) array_like
    The fractional power of the matrix.

References
----------
.. [1] Nicholas J. Higham and Lijing Lin (2013)
       "An Improved Schur-Pade Algorithm for Fractional Powers
       of a Matrix and their Frechet Derivatives."

.. [2] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</pre> <div class="fragment"><div class="line"><span class="lineno">  596</span><span class="keyword">def </span>_remainder_matrix_power(A, t):</div>
<div class="line"><span class="lineno">  597</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    Compute the fractional power of a matrix, for fractions -1 &lt; t &lt; 1.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    This uses algorithm (3.1) of [1]_.</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    The Pade approximation itself uses algorithm (4.1) of [2]_.</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    A : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        Matrix whose fractional power to evaluate.</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    t : float</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">        Fractional power between -1 and 1 exclusive.</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    X : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">        The fractional power of the matrix.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    .. [1] Nicholas J. Higham and Lijing Lin (2013)</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">           &quot;An Improved Schur-Pade Algorithm for Fractional Powers</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">           of a Matrix and their Frechet Derivatives.&quot;</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    .. [2] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  627</span>    <span class="comment"># This code block is copied from numpy.matrix_power().</span></div>
<div class="line"><span class="lineno">  628</span>    A = np.asarray(A)</div>
<div class="line"><span class="lineno">  629</span>    <span class="keywordflow">if</span> len(A.shape) != 2 <span class="keywordflow">or</span> A.shape[0] != A.shape[1]:</div>
<div class="line"><span class="lineno">  630</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;input must be a square array&#39;</span>)</div>
<div class="line"><span class="lineno">  631</span> </div>
<div class="line"><span class="lineno">  632</span>    <span class="comment"># Get the number of rows and columns.</span></div>
<div class="line"><span class="lineno">  633</span>    n, n = A.shape</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span>    <span class="comment"># Triangularize the matrix if necessary,</span></div>
<div class="line"><span class="lineno">  636</span>    <span class="comment"># attempting to preserve dtype if possible.</span></div>
<div class="line"><span class="lineno">  637</span>    <span class="keywordflow">if</span> np.array_equal(A, np.triu(A)):</div>
<div class="line"><span class="lineno">  638</span>        Z = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  639</span>        T = A</div>
<div class="line"><span class="lineno">  640</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  641</span>        <span class="keywordflow">if</span> np.isrealobj(A):</div>
<div class="line"><span class="lineno">  642</span>            T, Z = schur(A)</div>
<div class="line"><span class="lineno">  643</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.array_equal(T, np.triu(T)):</div>
<div class="line"><span class="lineno">  644</span>                T, Z = rsf2csf(T, Z)</div>
<div class="line"><span class="lineno">  645</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  646</span>            T, Z = schur(A, output=<span class="stringliteral">&#39;complex&#39;</span>)</div>
<div class="line"><span class="lineno">  647</span> </div>
<div class="line"><span class="lineno">  648</span>    <span class="comment"># Zeros on the diagonal of the triangular matrix are forbidden,</span></div>
<div class="line"><span class="lineno">  649</span>    <span class="comment"># because the inverse scaling and squaring cannot deal with it.</span></div>
<div class="line"><span class="lineno">  650</span>    T_diag = np.diag(T)</div>
<div class="line"><span class="lineno">  651</span>    <span class="keywordflow">if</span> np.count_nonzero(T_diag) != n:</div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">raise</span> FractionalMatrixPowerError(</div>
<div class="line"><span class="lineno">  653</span>                <span class="stringliteral">&#39;cannot use inverse scaling and squaring to find &#39;</span></div>
<div class="line"><span class="lineno">  654</span>                <span class="stringliteral">&#39;the fractional matrix power of a singular matrix&#39;</span>)</div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span>    <span class="comment"># If the triangular matrix is real and has a negative</span></div>
<div class="line"><span class="lineno">  657</span>    <span class="comment"># entry on the diagonal, then force the matrix to be complex.</span></div>
<div class="line"><span class="lineno">  658</span>    <span class="keywordflow">if</span> np.isrealobj(T) <span class="keywordflow">and</span> np.min(T_diag) &lt; 0:</div>
<div class="line"><span class="lineno">  659</span>        T = T.astype(complex)</div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span>    <span class="comment"># Get the fractional power of the triangular matrix,</span></div>
<div class="line"><span class="lineno">  662</span>    <span class="comment"># and de-triangularize it if necessary.</span></div>
<div class="line"><span class="lineno">  663</span>    U = _remainder_matrix_power_triu(T, t)</div>
<div class="line"><span class="lineno">  664</span>    <span class="keywordflow">if</span> Z <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  665</span>        ZH = np.conjugate(Z).T</div>
<div class="line"><span class="lineno">  666</span>        <span class="keywordflow">return</span> Z.dot(U).dot(ZH)</div>
<div class="line"><span class="lineno">  667</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  668</span>        <span class="keywordflow">return</span> U</div>
<div class="line"><span class="lineno">  669</span> </div>
<div class="line"><span class="lineno">  670</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7da3e36b452eb945e08726f1576eb5a8" name="a7da3e36b452eb945e08726f1576eb5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da3e36b452eb945e08726f1576eb5a8">&#9670;&#160;</a></span>_remainder_matrix_power_triu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._remainder_matrix_power_triu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a fractional power of an upper triangular matrix.

The fractional power is restricted to fractions -1 &lt; t &lt; 1.
This uses algorithm (3.1) of [1]_.
The Pade approximation itself uses algorithm (4.1) of [2]_.

Parameters
----------
T : (N, N) array_like
    Upper triangular matrix whose fractional power to evaluate.
t : float
    Fractional power between -1 and 1 exclusive.

Returns
-------
X : (N, N) array_like
    The fractional power of the matrix.

References
----------
.. [1] Nicholas J. Higham and Lijing Lin (2013)
       "An Improved Schur-Pade Algorithm for Fractional Powers
       of a Matrix and their Frechet Derivatives."

.. [2] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</pre> <div class="fragment"><div class="line"><span class="lineno">  517</span><span class="keyword">def </span>_remainder_matrix_power_triu(T, t):</div>
<div class="line"><span class="lineno">  518</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    Compute a fractional power of an upper triangular matrix.</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    The fractional power is restricted to fractions -1 &lt; t &lt; 1.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    This uses algorithm (3.1) of [1]_.</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    The Pade approximation itself uses algorithm (4.1) of [2]_.</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    T : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">        Upper triangular matrix whose fractional power to evaluate.</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    t : float</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        Fractional power between -1 and 1 exclusive.</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    X : (N, N) array_like</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        The fractional power of the matrix.</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    .. [1] Nicholas J. Higham and Lijing Lin (2013)</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">           &quot;An Improved Schur-Pade Algorithm for Fractional Powers</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">           of a Matrix and their Frechet Derivatives.&quot;</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    .. [2] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  549</span>    m_to_theta = {</div>
<div class="line"><span class="lineno">  550</span>            1: 1.51e-5,</div>
<div class="line"><span class="lineno">  551</span>            2: 2.24e-3,</div>
<div class="line"><span class="lineno">  552</span>            3: 1.88e-2,</div>
<div class="line"><span class="lineno">  553</span>            4: 6.04e-2,</div>
<div class="line"><span class="lineno">  554</span>            5: 1.24e-1,</div>
<div class="line"><span class="lineno">  555</span>            6: 2.00e-1,</div>
<div class="line"><span class="lineno">  556</span>            7: 2.79e-1,</div>
<div class="line"><span class="lineno">  557</span>            }</div>
<div class="line"><span class="lineno">  558</span>    n, n = T.shape</div>
<div class="line"><span class="lineno">  559</span>    T0 = T</div>
<div class="line"><span class="lineno">  560</span>    T0_diag = np.diag(T0)</div>
<div class="line"><span class="lineno">  561</span>    <span class="keywordflow">if</span> np.array_equal(T0, np.diag(T0_diag)):</div>
<div class="line"><span class="lineno">  562</span>        U = np.diag(T0_diag ** t)</div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  564</span>        R, s, m = _inverse_squaring_helper(T0, m_to_theta)</div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span>        <span class="comment"># Evaluate the Pade approximation.</span></div>
<div class="line"><span class="lineno">  567</span>        <span class="comment"># Note that this function expects the negative of the matrix</span></div>
<div class="line"><span class="lineno">  568</span>        <span class="comment"># returned by the inverse squaring helper.</span></div>
<div class="line"><span class="lineno">  569</span>        U = _fractional_power_pade(-R, t, m)</div>
<div class="line"><span class="lineno">  570</span> </div>
<div class="line"><span class="lineno">  571</span>        <span class="comment"># Undo the inverse scaling and squaring.</span></div>
<div class="line"><span class="lineno">  572</span>        <span class="comment"># Be less clever about this</span></div>
<div class="line"><span class="lineno">  573</span>        <span class="comment"># if the principal branch does not exist at T0;</span></div>
<div class="line"><span class="lineno">  574</span>        <span class="comment"># this happens when a diagonal entry of T0</span></div>
<div class="line"><span class="lineno">  575</span>        <span class="comment"># is negative with imaginary part 0.</span></div>
<div class="line"><span class="lineno">  576</span>        eivals = np.diag(T0)</div>
<div class="line"><span class="lineno">  577</span>        has_principal_branch = all(x.real &gt; 0 <span class="keywordflow">or</span> x.imag != 0 <span class="keywordflow">for</span> x <span class="keywordflow">in</span> eivals)</div>
<div class="line"><span class="lineno">  578</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(s, -1, -1):</div>
<div class="line"><span class="lineno">  579</span>            <span class="keywordflow">if</span> i &lt; s:</div>
<div class="line"><span class="lineno">  580</span>                U = U.dot(U)</div>
<div class="line"><span class="lineno">  581</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  582</span>                <span class="keywordflow">if</span> has_principal_branch:</div>
<div class="line"><span class="lineno">  583</span>                    p = t * np.exp2(-i)</div>
<div class="line"><span class="lineno">  584</span>                    U[np.diag_indices(n)] = T0_diag ** p</div>
<div class="line"><span class="lineno">  585</span>                    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(n-1):</div>
<div class="line"><span class="lineno">  586</span>                        l1 = T0[j, j]</div>
<div class="line"><span class="lineno">  587</span>                        l2 = T0[j+1, j+1]</div>
<div class="line"><span class="lineno">  588</span>                        t12 = T0[j, j+1]</div>
<div class="line"><span class="lineno">  589</span>                        f12 = _fractional_power_superdiag_entry(l1, l2, t12, p)</div>
<div class="line"><span class="lineno">  590</span>                        U[j, j+1] = f12</div>
<div class="line"><span class="lineno">  591</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.array_equal(U, np.triu(U)):</div>
<div class="line"><span class="lineno">  592</span>        <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&#39;U is not upper triangular&#39;</span>)</div>
<div class="line"><span class="lineno">  593</span>    <span class="keywordflow">return</span> U</div>
<div class="line"><span class="lineno">  594</span> </div>
<div class="line"><span class="lineno">  595</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afdcd484a868b441270003b228f44e5ae" name="afdcd484a868b441270003b228f44e5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd484a868b441270003b228f44e5ae">&#9670;&#160;</a></span>_unwindk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._matfuncs_inv_ssq._unwindk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the scalar unwinding number.

Uses Eq. (5.3) in [1]_, and should be equal to (z - log(exp(z)) / (2 pi i).
Note that this definition differs in sign from the original definition
in equations (5, 6) in [2]_.  The sign convention is justified in [3]_.

Parameters
----------
z : complex
    A complex number.

Returns
-------
unwinding_number : integer
    The scalar unwinding number of z.

References
----------
.. [1] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798

.. [2] Robert M. Corless and David J. Jeffrey,
       "The unwinding number." Newsletter ACM SIGSAM Bulletin
       Volume 30, Issue 2, June 1996, Pages 28-35.

.. [3] Russell Bradford and Robert M. Corless and James H. Davenport and
       David J. Jeffrey and Stephen M. Watt,
       "Reasoning about the elementary functions of complex analysis"
       Annals of Mathematics and Artificial Intelligence,
       36: 303-318, 2002.</pre> <div class="fragment"><div class="line"><span class="lineno">  115</span><span class="keyword">def </span>_unwindk(z):</div>
<div class="line"><span class="lineno">  116</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    Compute the scalar unwinding number.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    Uses Eq. (5.3) in [1]_, and should be equal to (z - log(exp(z)) / (2 pi i).</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    Note that this definition differs in sign from the original definition</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    in equations (5, 6) in [2]_.  The sign convention is justified in [3]_.</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    z : complex</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">        A complex number.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    unwinding_number : integer</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">        The scalar unwinding number of z.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    .. [1] Nicholas J. Higham and Lijing lin (2011)</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot;</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">           SIAM Journal on Matrix Analysis and Applications,</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">           32 (3). pp. 1056-1078. ISSN 0895-4798</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    .. [2] Robert M. Corless and David J. Jeffrey,</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">           &quot;The unwinding number.&quot; Newsletter ACM SIGSAM Bulletin</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">           Volume 30, Issue 2, June 1996, Pages 28-35.</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    .. [3] Russell Bradford and Robert M. Corless and James H. Davenport and</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">           David J. Jeffrey and Stephen M. Watt,</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">           &quot;Reasoning about the elementary functions of complex analysis&quot;</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">           Annals of Mathematics and Artificial Intelligence,</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">           36: 303-318, 2002.</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordflow">return</span> int(np.ceil((z.imag - np.pi) / (2*np.pi)))</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
