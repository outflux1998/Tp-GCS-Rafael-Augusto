<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.groupby.groupby.GroupBy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1groupby.html">groupby</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html">groupby</a></li><li class="navelem"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html">GroupBy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.groupby.groupby.GroupBy Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for pandas.core.groupby.groupby.GroupBy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.png" usemap="#pandas.core.groupby.groupby.GroupBy_map" alt=""/>
  <map id="pandas.core.groupby.groupby.GroupBy_map" name="pandas.core.groupby.groupby.GroupBy_map">
<area href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html" alt="pandas.core.groupby.groupby.BaseGroupBy" shape="rect" coords="652,112,968,136"/>
<area href="classpandas_1_1core_1_1base_1_1_pandas_object.html" alt="pandas.core.base.PandasObject" shape="rect" coords="0,56,316,80"/>
<area href="classpandas_1_1core_1_1base_1_1_selection_mixin.html" alt="pandas.core.base.SelectionMixin" shape="rect" coords="489,56,805,80"/>
<area href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html" alt="pandas.core.groupby.indexing.GroupByIndexingMixin" shape="rect" coords="1141,56,1457,80"/>
<area href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html" alt="pandas.core.accessor.DirNamesMixin" shape="rect" coords="0,0,316,24"/>
<area href="classpandas_1_1core_1_1groupby_1_1generic_1_1_data_frame_group_by.html" alt="pandas.core.groupby.generic.DataFrameGroupBy" shape="rect" coords="652,224,968,248"/>
<area href="classpandas_1_1core_1_1groupby_1_1generic_1_1_series_group_by.html" alt="pandas.core.groupby.generic.SeriesGroupBy" shape="rect" coords="978,224,1294,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a428c03b38a8e631b520eb73065457ddf" id="r_a428c03b38a8e631b520eb73065457ddf"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a428c03b38a8e631b520eb73065457ddf">__init__</a> (self, NDFrameT <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a1e8befeb0c9e7da25600d0119af3f726">obj</a>, <a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a34ab6708bf412008a6c49f719c219280">_KeysArgType</a>|None <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ab885b4c07c7081d8f3bd8bfd51d9cad5">keys</a>=None, int <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0, IndexLabel|None <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a2a5c3daddc0cd71d53ae1703376ba230">level</a>=None, <a class="el" href="classpandas_1_1core_1_1groupby_1_1ops_1_1_base_grouper.html">ops.BaseGrouper</a>|None <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a0d2ac167a7fdcb6e19af4f6f27a12389">grouper</a>=None, frozenset[Hashable]|None <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aba8874c98a4d0fc618ae3ab735d83798">exclusions</a>=None, IndexLabel|None selection=None, bool <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a95f69def69abf91e4ed27e2f215b6645">as_index</a>=True, bool <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aa716330d6113b7f0d85e594d84f7c83a">sort</a>=True, bool|lib.NoDefault <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae43cf53a5fc86038b9ae1fcb50353232">group_keys</a>=True, bool <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aa824c16a2c4172ecca99029f7947fb95">squeeze</a>=False, bool <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aad235e29e75ce0c2ea71fc58f3833d4a">observed</a>=False, bool <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a9db815a5bbf93811613940f59ba04c92">mutated</a>=False, bool <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a27e6d7322e8c242ea87594807d342c6b">dropna</a>=True)</td></tr>
<tr class="separator:a428c03b38a8e631b520eb73065457ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75caced3d083bf6a25e21388c79b8d76" id="r_a75caced3d083bf6a25e21388c79b8d76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a75caced3d083bf6a25e21388c79b8d76">__getattr__</a> (self, str attr)</td></tr>
<tr class="separator:a75caced3d083bf6a25e21388c79b8d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dc3e65e8535fa5140908580c8ce555" id="r_ad0dc3e65e8535fa5140908580c8ce555"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ad0dc3e65e8535fa5140908580c8ce555">apply</a> (self, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *args, **kwargs)</td></tr>
<tr class="separator:ad0dc3e65e8535fa5140908580c8ce555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb225d01333635a4d2a7c89098a8a665" id="r_adb225d01333635a4d2a7c89098a8a665"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#adb225d01333635a4d2a7c89098a8a665">any</a> (self, bool skipna=True)</td></tr>
<tr class="separator:adb225d01333635a4d2a7c89098a8a665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ec2cda59b14da99f075a6e0890765e" id="r_ad2ec2cda59b14da99f075a6e0890765e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ad2ec2cda59b14da99f075a6e0890765e">all</a> (self, bool skipna=True)</td></tr>
<tr class="separator:ad2ec2cda59b14da99f075a6e0890765e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0e94b2416991aed9f5aef0be1ea312" id="r_a7f0e94b2416991aed9f5aef0be1ea312"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a7f0e94b2416991aed9f5aef0be1ea312">count</a> (self)</td></tr>
<tr class="separator:a7f0e94b2416991aed9f5aef0be1ea312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1d83f9ba2d0d7187c2cc270476bd7f" id="r_afc1d83f9ba2d0d7187c2cc270476bd7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#afc1d83f9ba2d0d7187c2cc270476bd7f">mean</a> (self, bool|lib.NoDefault numeric_only=lib.no_default, str engine=&quot;cython&quot;, dict[str, bool]|None engine_kwargs=None)</td></tr>
<tr class="separator:afc1d83f9ba2d0d7187c2cc270476bd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebfc333d04f0a16c69ed336cc95338a" id="r_a8ebfc333d04f0a16c69ed336cc95338a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a8ebfc333d04f0a16c69ed336cc95338a">median</a> (self, bool|lib.NoDefault numeric_only=lib.no_default)</td></tr>
<tr class="separator:a8ebfc333d04f0a16c69ed336cc95338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902038000da231faea3dbb14016e287e" id="r_a902038000da231faea3dbb14016e287e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a902038000da231faea3dbb14016e287e">std</a> (self, int ddof=1, str|None engine=None, dict[str, bool]|None engine_kwargs=None, bool|lib.NoDefault numeric_only=lib.no_default)</td></tr>
<tr class="separator:a902038000da231faea3dbb14016e287e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280b92347376a05d27cf8e614410bee1" id="r_a280b92347376a05d27cf8e614410bee1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a280b92347376a05d27cf8e614410bee1">var</a> (self, int ddof=1, str|None engine=None, dict[str, bool]|None engine_kwargs=None, bool|lib.NoDefault numeric_only=lib.no_default)</td></tr>
<tr class="separator:a280b92347376a05d27cf8e614410bee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf988d343f659a546a1d9ad6621245fd" id="r_abf988d343f659a546a1d9ad6621245fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#abf988d343f659a546a1d9ad6621245fd">sem</a> (self, int ddof=1, bool|lib.NoDefault numeric_only=lib.no_default)</td></tr>
<tr class="separator:abf988d343f659a546a1d9ad6621245fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf144a9cf62fed56f15f1cfb77c0a263" id="r_abf144a9cf62fed56f15f1cfb77c0a263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#abf144a9cf62fed56f15f1cfb77c0a263">size</a> (self)</td></tr>
<tr class="separator:abf144a9cf62fed56f15f1cfb77c0a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce0f2f8317be6a231bc624cf865a6b" id="r_a29ce0f2f8317be6a231bc624cf865a6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a29ce0f2f8317be6a231bc624cf865a6b">sum</a> (self, bool|lib.NoDefault numeric_only=lib.no_default, int min_count=0, str|None engine=None, dict[str, bool]|None engine_kwargs=None)</td></tr>
<tr class="separator:a29ce0f2f8317be6a231bc624cf865a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63487cbbe0689953baab3bcef598288" id="r_aa63487cbbe0689953baab3bcef598288"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aa63487cbbe0689953baab3bcef598288">prod</a> (self, bool|lib.NoDefault numeric_only=lib.no_default, int min_count=0)</td></tr>
<tr class="separator:aa63487cbbe0689953baab3bcef598288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c716cac1d88960ad119d16601c5ab55" id="r_a7c716cac1d88960ad119d16601c5ab55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a7c716cac1d88960ad119d16601c5ab55">min</a> (self, bool numeric_only=False, int min_count=-1, str|None engine=None, dict[str, bool]|None engine_kwargs=None)</td></tr>
<tr class="separator:a7c716cac1d88960ad119d16601c5ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995fffc13f0e2705bfe369942592c8c2" id="r_a995fffc13f0e2705bfe369942592c8c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a995fffc13f0e2705bfe369942592c8c2">max</a> (self, bool numeric_only=False, int min_count=-1, str|None engine=None, dict[str, bool]|None engine_kwargs=None)</td></tr>
<tr class="separator:a995fffc13f0e2705bfe369942592c8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9ffe53710ea4a6d45c95679279c68f" id="r_a3b9ffe53710ea4a6d45c95679279c68f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a3b9ffe53710ea4a6d45c95679279c68f">first</a> (self, bool numeric_only=False, int min_count=-1)</td></tr>
<tr class="separator:a3b9ffe53710ea4a6d45c95679279c68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde1107f7b563ee416464242ffd06918" id="r_abde1107f7b563ee416464242ffd06918"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#abde1107f7b563ee416464242ffd06918">last</a> (self, bool numeric_only=False, int min_count=-1)</td></tr>
<tr class="separator:abde1107f7b563ee416464242ffd06918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9ea883682f3e31624abd0170195a3" id="r_a94e9ea883682f3e31624abd0170195a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a94e9ea883682f3e31624abd0170195a3">ohlc</a> (self)</td></tr>
<tr class="separator:a94e9ea883682f3e31624abd0170195a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d35b107f398970a5b1a98f684f525de" id="r_a7d35b107f398970a5b1a98f684f525de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a7d35b107f398970a5b1a98f684f525de">describe</a> (self, **kwargs)</td></tr>
<tr class="separator:a7d35b107f398970a5b1a98f684f525de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8c61e42721b5c838b9fd3439599ac0" id="r_aff8c61e42721b5c838b9fd3439599ac0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aff8c61e42721b5c838b9fd3439599ac0">resample</a> (self, rule, *args, **kwargs)</td></tr>
<tr class="separator:aff8c61e42721b5c838b9fd3439599ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad123d631afc14e83b31e7384cbd4a158" id="r_ad123d631afc14e83b31e7384cbd4a158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1window_1_1rolling_1_1_rolling_groupby.html">RollingGroupby</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ad123d631afc14e83b31e7384cbd4a158">rolling</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:ad123d631afc14e83b31e7384cbd4a158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a310c9e138f254a8dc75b9b00fac63e" id="r_a5a310c9e138f254a8dc75b9b00fac63e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1window_1_1expanding_1_1_expanding_groupby.html">ExpandingGroupby</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a5a310c9e138f254a8dc75b9b00fac63e">expanding</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:a5a310c9e138f254a8dc75b9b00fac63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2aca5c66474b38ec1460b90c787568" id="r_aaa2aca5c66474b38ec1460b90c787568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1window_1_1ewm_1_1_exponential_moving_window_groupby.html">ExponentialMovingWindowGroupby</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aaa2aca5c66474b38ec1460b90c787568">ewm</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:aaa2aca5c66474b38ec1460b90c787568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009da5b1693c64f17dccd6916c534e75" id="r_a009da5b1693c64f17dccd6916c534e75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a009da5b1693c64f17dccd6916c534e75">ffill</a> (self, limit=None)</td></tr>
<tr class="separator:a009da5b1693c64f17dccd6916c534e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b63a7756867fcf6d9923b31c177158" id="r_a06b63a7756867fcf6d9923b31c177158"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a06b63a7756867fcf6d9923b31c177158">pad</a> (self, limit=None)</td></tr>
<tr class="separator:a06b63a7756867fcf6d9923b31c177158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab522014f60e0dda6683098724cd2cf72" id="r_ab522014f60e0dda6683098724cd2cf72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ab522014f60e0dda6683098724cd2cf72">bfill</a> (self, limit=None)</td></tr>
<tr class="separator:ab522014f60e0dda6683098724cd2cf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daa2f507b10a89023a89f5be2140c82" id="r_a2daa2f507b10a89023a89f5be2140c82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a2daa2f507b10a89023a89f5be2140c82">backfill</a> (self, limit=None)</td></tr>
<tr class="separator:a2daa2f507b10a89023a89f5be2140c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dc3aa9708151309c8e76d075ae458a" id="r_a99dc3aa9708151309c8e76d075ae458a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_nth_selector.html">GroupByNthSelector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a99dc3aa9708151309c8e76d075ae458a">nth</a> (self)</td></tr>
<tr class="separator:a99dc3aa9708151309c8e76d075ae458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18e71ddc461771884209ddf5e199369" id="r_af18e71ddc461771884209ddf5e199369"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#af18e71ddc461771884209ddf5e199369">quantile</a> (self, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>=0.5, str interpolation=&quot;linear&quot;, bool|lib.NoDefault numeric_only=lib.no_default)</td></tr>
<tr class="separator:af18e71ddc461771884209ddf5e199369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0ab5f350005e94a5ff7a77874a9bde" id="r_a4e0ab5f350005e94a5ff7a77874a9bde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a4e0ab5f350005e94a5ff7a77874a9bde">ngroup</a> (self, bool ascending=True)</td></tr>
<tr class="separator:a4e0ab5f350005e94a5ff7a77874a9bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69f343f46d328e9ff7f92c48167bd9d" id="r_ab69f343f46d328e9ff7f92c48167bd9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ab69f343f46d328e9ff7f92c48167bd9d">cumcount</a> (self, bool ascending=True)</td></tr>
<tr class="separator:ab69f343f46d328e9ff7f92c48167bd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af26294b299effab221f75776492586" id="r_a9af26294b299effab221f75776492586"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a9af26294b299effab221f75776492586">rank</a> (self, str method=&quot;average&quot;, bool ascending=True, str na_option=&quot;keep&quot;, bool pct=False, int <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0)</td></tr>
<tr class="separator:a9af26294b299effab221f75776492586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3293c5ecf5d70d63b09bde1ce92f0bd6" id="r_a3293c5ecf5d70d63b09bde1ce92f0bd6"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a3293c5ecf5d70d63b09bde1ce92f0bd6">cumprod</a> (self, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0, *args, **kwargs)</td></tr>
<tr class="separator:a3293c5ecf5d70d63b09bde1ce92f0bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae982f07ae1d9a9cad06f3c171388c19c" id="r_ae982f07ae1d9a9cad06f3c171388c19c"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae982f07ae1d9a9cad06f3c171388c19c">cumsum</a> (self, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0, *args, **kwargs)</td></tr>
<tr class="separator:ae982f07ae1d9a9cad06f3c171388c19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8038f2e1440fa9fa797cfc881cbf31ae" id="r_a8038f2e1440fa9fa797cfc881cbf31ae"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a8038f2e1440fa9fa797cfc881cbf31ae">cummin</a> (self, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0, numeric_only=False, **kwargs)</td></tr>
<tr class="separator:a8038f2e1440fa9fa797cfc881cbf31ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f9d3df6838dce31c947e4a6a4b481" id="r_a865f9d3df6838dce31c947e4a6a4b481"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a865f9d3df6838dce31c947e4a6a4b481">cummax</a> (self, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0, numeric_only=False, **kwargs)</td></tr>
<tr class="separator:a865f9d3df6838dce31c947e4a6a4b481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659eefaf1a7c641536630b970d9b2d74" id="r_a659eefaf1a7c641536630b970d9b2d74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a659eefaf1a7c641536630b970d9b2d74">shift</a> (self, periods=1, freq=None, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0, fill_value=None)</td></tr>
<tr class="separator:a659eefaf1a7c641536630b970d9b2d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add436d2f4a8444bcfe3dbfc49ed29fe0" id="r_add436d2f4a8444bcfe3dbfc49ed29fe0"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#add436d2f4a8444bcfe3dbfc49ed29fe0">diff</a> (self, int periods=1, int <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0)</td></tr>
<tr class="separator:add436d2f4a8444bcfe3dbfc49ed29fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025ca8bbcf1e6600ae14b1aa34dea5cd" id="r_a025ca8bbcf1e6600ae14b1aa34dea5cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a025ca8bbcf1e6600ae14b1aa34dea5cd">pct_change</a> (self, periods=1, fill_method=&quot;ffill&quot;, limit=None, freq=None, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0)</td></tr>
<tr class="separator:a025ca8bbcf1e6600ae14b1aa34dea5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f1160675cd14ffa2152d7892ed0408" id="r_a78f1160675cd14ffa2152d7892ed0408"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a78f1160675cd14ffa2152d7892ed0408">head</a> (self, int <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=5)</td></tr>
<tr class="separator:a78f1160675cd14ffa2152d7892ed0408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763a9595f945252ec15615cf0165dc26" id="r_a763a9595f945252ec15615cf0165dc26"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a763a9595f945252ec15615cf0165dc26">tail</a> (self, int <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=5)</td></tr>
<tr class="separator:a763a9595f945252ec15615cf0165dc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36848017b67bb140e005f24888fb9fc1" id="r_a36848017b67bb140e005f24888fb9fc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a36848017b67bb140e005f24888fb9fc1">sample</a> (self, int|None <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, float|None frac=None, bool replace=False, Sequence|<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>|None weights=None, RandomState|None random_state=None)</td></tr>
<tr class="separator:a36848017b67bb140e005f24888fb9fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html">pandas.core.groupby.groupby.BaseGroupBy</a></td></tr>
<tr class="memitem:a8337410d52f544362ee647ab1a502b01 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a8337410d52f544362ee647ab1a502b01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a8337410d52f544362ee647ab1a502b01">__len__</a> (self)</td></tr>
<tr class="separator:a8337410d52f544362ee647ab1a502b01 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b952c92d9fdda32cdcd7b6db3eb3fa8 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a8b952c92d9fdda32cdcd7b6db3eb3fa8"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a8b952c92d9fdda32cdcd7b6db3eb3fa8">__repr__</a> (self)</td></tr>
<tr class="separator:a8b952c92d9fdda32cdcd7b6db3eb3fa8 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd0a55d97fcab26f8df25e67e9bea0b inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a4bd0a55d97fcab26f8df25e67e9bea0b"><td class="memItemLeft" align="right" valign="top">dict[Hashable, np.ndarray]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a4bd0a55d97fcab26f8df25e67e9bea0b">groups</a> (self)</td></tr>
<tr class="separator:a4bd0a55d97fcab26f8df25e67e9bea0b inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aae1b1de1e558515d979282899845c inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a10aae1b1de1e558515d979282899845c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a10aae1b1de1e558515d979282899845c">ngroups</a> (self)</td></tr>
<tr class="separator:a10aae1b1de1e558515d979282899845c inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69170c122250520eae9635882820c3d3 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a69170c122250520eae9635882820c3d3"><td class="memItemLeft" align="right" valign="top">dict[Hashable, npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a69170c122250520eae9635882820c3d3">indices</a> (self)</td></tr>
<tr class="separator:a69170c122250520eae9635882820c3d3 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f305e6758cd10d99d0389bf68b45011 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a9f305e6758cd10d99d0389bf68b45011"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a9f305e6758cd10d99d0389bf68b45011">pipe</a> (self, Callable[..., T]|tuple[Callable[..., T], str] <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *args, **kwargs)</td></tr>
<tr class="separator:a9f305e6758cd10d99d0389bf68b45011 inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91fe7eafca224e3204260639512406d inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_af91fe7eafca224e3204260639512406d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#af91fe7eafca224e3204260639512406d">get_group</a> (self, name, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#aac4094c67077964fa95bb915942d224c">obj</a>=None)</td></tr>
<tr class="separator:af91fe7eafca224e3204260639512406d inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e47304f229dd92531696371b9be253e inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a9e47304f229dd92531696371b9be253e"><td class="memItemLeft" align="right" valign="top">Iterator[tuple[Hashable, NDFrameT]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a9e47304f229dd92531696371b9be253e">__iter__</a> (self)</td></tr>
<tr class="separator:a9e47304f229dd92531696371b9be253e inherit pub_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html">pandas.core.base.PandasObject</a></td></tr>
<tr class="memitem:ad5b15e942fb2d2dcfb12fa1667404aeb inherit pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object" id="r_ad5b15e942fb2d2dcfb12fa1667404aeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#ad5b15e942fb2d2dcfb12fa1667404aeb">__sizeof__</a> (self)</td></tr>
<tr class="separator:ad5b15e942fb2d2dcfb12fa1667404aeb inherit pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html">pandas.core.accessor.DirNamesMixin</a></td></tr>
<tr class="memitem:ac86361dc5b262c58dcdf818d410136e4 inherit pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_ac86361dc5b262c58dcdf818d410136e4"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#ac86361dc5b262c58dcdf818d410136e4">__dir__</a> (self)</td></tr>
<tr class="separator:ac86361dc5b262c58dcdf818d410136e4 inherit pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html">pandas.core.base.SelectionMixin</a></td></tr>
<tr class="memitem:ae71168779b11e49ff704d8e1252625ba inherit pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_ae71168779b11e49ff704d8e1252625ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#ae71168779b11e49ff704d8e1252625ba">ndim</a> (self)</td></tr>
<tr class="separator:ae71168779b11e49ff704d8e1252625ba inherit pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3c986de316f6c45ec1d2f161b001a1 inherit pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_aad3c986de316f6c45ec1d2f161b001a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#aad3c986de316f6c45ec1d2f161b001a1">__getitem__</a> (self, key)</td></tr>
<tr class="separator:aad3c986de316f6c45ec1d2f161b001a1 inherit pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae485d4e476e4284dee050eb5245f4862 inherit pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_ae485d4e476e4284dee050eb5245f4862"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#ae485d4e476e4284dee050eb5245f4862">aggregate</a> (self, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *args, **kwargs)</td></tr>
<tr class="separator:ae485d4e476e4284dee050eb5245f4862 inherit pub_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2a5c3daddc0cd71d53ae1703376ba230" id="r_a2a5c3daddc0cd71d53ae1703376ba230"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a2a5c3daddc0cd71d53ae1703376ba230">level</a></td></tr>
<tr class="separator:a2a5c3daddc0cd71d53ae1703376ba230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fb589411ebb1a7c1a8babfe74987d1" id="r_a92fb589411ebb1a7c1a8babfe74987d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a92fb589411ebb1a7c1a8babfe74987d1">as_index</a></td></tr>
<tr class="separator:a92fb589411ebb1a7c1a8babfe74987d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab885b4c07c7081d8f3bd8bfd51d9cad5" id="r_ab885b4c07c7081d8f3bd8bfd51d9cad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ab885b4c07c7081d8f3bd8bfd51d9cad5">keys</a></td></tr>
<tr class="separator:ab885b4c07c7081d8f3bd8bfd51d9cad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa716330d6113b7f0d85e594d84f7c83a" id="r_aa716330d6113b7f0d85e594d84f7c83a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aa716330d6113b7f0d85e594d84f7c83a">sort</a></td></tr>
<tr class="separator:aa716330d6113b7f0d85e594d84f7c83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43cf53a5fc86038b9ae1fcb50353232" id="r_ae43cf53a5fc86038b9ae1fcb50353232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae43cf53a5fc86038b9ae1fcb50353232">group_keys</a></td></tr>
<tr class="separator:ae43cf53a5fc86038b9ae1fcb50353232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa824c16a2c4172ecca99029f7947fb95" id="r_aa824c16a2c4172ecca99029f7947fb95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aa824c16a2c4172ecca99029f7947fb95">squeeze</a></td></tr>
<tr class="separator:aa824c16a2c4172ecca99029f7947fb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad235e29e75ce0c2ea71fc58f3833d4a" id="r_aad235e29e75ce0c2ea71fc58f3833d4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aad235e29e75ce0c2ea71fc58f3833d4a">observed</a></td></tr>
<tr class="separator:aad235e29e75ce0c2ea71fc58f3833d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db815a5bbf93811613940f59ba04c92" id="r_a9db815a5bbf93811613940f59ba04c92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a9db815a5bbf93811613940f59ba04c92">mutated</a></td></tr>
<tr class="separator:a9db815a5bbf93811613940f59ba04c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e6d7322e8c242ea87594807d342c6b" id="r_a27e6d7322e8c242ea87594807d342c6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a27e6d7322e8c242ea87594807d342c6b">dropna</a></td></tr>
<tr class="separator:a27e6d7322e8c242ea87594807d342c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8befeb0c9e7da25600d0119af3f726" id="r_a1e8befeb0c9e7da25600d0119af3f726"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a1e8befeb0c9e7da25600d0119af3f726">obj</a></td></tr>
<tr class="separator:a1e8befeb0c9e7da25600d0119af3f726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cb972cc96e0e06c7d409ebed5dcf88" id="r_ae9cb972cc96e0e06c7d409ebed5dcf88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a></td></tr>
<tr class="separator:ae9cb972cc96e0e06c7d409ebed5dcf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566c441bac194b364f4fd6f9a8dd54ac" id="r_a566c441bac194b364f4fd6f9a8dd54ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a566c441bac194b364f4fd6f9a8dd54ac">grouper</a></td></tr>
<tr class="separator:a566c441bac194b364f4fd6f9a8dd54ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8874c98a4d0fc618ae3ab735d83798" id="r_aba8874c98a4d0fc618ae3ab735d83798"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aba8874c98a4d0fc618ae3ab735d83798">exclusions</a></td></tr>
<tr class="separator:aba8874c98a4d0fc618ae3ab735d83798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91097da9d4d374715a4d041be326bae0" id="r_a91097da9d4d374715a4d041be326bae0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a91097da9d4d374715a4d041be326bae0">ngroups</a></td></tr>
<tr class="separator:a91097da9d4d374715a4d041be326bae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html">pandas.core.groupby.groupby.BaseGroupBy</a></td></tr>
<tr class="memitem:a8cd00befecc935b7ab0c04017fa5f4a7 inherit pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a8cd00befecc935b7ab0c04017fa5f4a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a8cd00befecc935b7ab0c04017fa5f4a7">groups</a></td></tr>
<tr class="separator:a8cd00befecc935b7ab0c04017fa5f4a7 inherit pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382def7764ebcaf70d26e83645db0e59 inherit pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a382def7764ebcaf70d26e83645db0e59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a382def7764ebcaf70d26e83645db0e59">indices</a></td></tr>
<tr class="separator:a382def7764ebcaf70d26e83645db0e59 inherit pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4094c67077964fa95bb915942d224c inherit pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_aac4094c67077964fa95bb915942d224c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#aac4094c67077964fa95bb915942d224c">obj</a></td></tr>
<tr class="separator:aac4094c67077964fa95bb915942d224c inherit pub_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html">pandas.core.base.SelectionMixin</a></td></tr>
<tr class="memitem:a5207a79fc68d7810cc3a907a49eaf556 inherit pub_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a5207a79fc68d7810cc3a907a49eaf556"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a5207a79fc68d7810cc3a907a49eaf556">obj</a></td></tr>
<tr class="separator:a5207a79fc68d7810cc3a907a49eaf556 inherit pub_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740e931e362229a193cc2b827ac039e7 inherit pub_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a740e931e362229a193cc2b827ac039e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a740e931e362229a193cc2b827ac039e7">exclusions</a></td></tr>
<tr class="separator:a740e931e362229a193cc2b827ac039e7 inherit pub_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0d2ac167a7fdcb6e19af4f6f27a12389" id="r_a0d2ac167a7fdcb6e19af4f6f27a12389"><td class="memItemLeft" align="right" valign="top">ops&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a0d2ac167a7fdcb6e19af4f6f27a12389">grouper</a> .BaseGrouper</td></tr>
<tr class="separator:a0d2ac167a7fdcb6e19af4f6f27a12389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f69def69abf91e4ed27e2f215b6645" id="r_a95f69def69abf91e4ed27e2f215b6645"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a95f69def69abf91e4ed27e2f215b6645">as_index</a></td></tr>
<tr class="separator:a95f69def69abf91e4ed27e2f215b6645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html">pandas.core.groupby.groupby.BaseGroupBy</a></td></tr>
<tr class="memitem:a0abb977824a0a59d3af2364bda4a8057 inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a0abb977824a0a59d3af2364bda4a8057"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a0abb977824a0a59d3af2364bda4a8057">axis</a></td></tr>
<tr class="separator:a0abb977824a0a59d3af2364bda4a8057 inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0a54cb1793eeddfdc9b27d77c0a62c inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a8d0a54cb1793eeddfdc9b27d77c0a62c"><td class="memItemLeft" align="right" valign="top">ops&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a8d0a54cb1793eeddfdc9b27d77c0a62c">grouper</a> .BaseGrouper</td></tr>
<tr class="separator:a8d0a54cb1793eeddfdc9b27d77c0a62c inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ac204416264c8e1af84f43300bba61 inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a03ac204416264c8e1af84f43300bba61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a34ab6708bf412008a6c49f719c219280">_KeysArgType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a03ac204416264c8e1af84f43300bba61">keys</a> = None</td></tr>
<tr class="separator:a03ac204416264c8e1af84f43300bba61 inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a78667f6d1b18a9ea35fd12c878380 inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_ad6a78667f6d1b18a9ea35fd12c878380"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#ad6a78667f6d1b18a9ea35fd12c878380">group_keys</a> | lib.NoDefault</td></tr>
<tr class="separator:ad6a78667f6d1b18a9ea35fd12c878380 inherit pub_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html">pandas.core.base.SelectionMixin</a></td></tr>
<tr class="memitem:a35b32ba83d07b2d612b80a3bb8b54c40 inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a35b32ba83d07b2d612b80a3bb8b54c40"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a35b32ba83d07b2d612b80a3bb8b54c40">obj</a></td></tr>
<tr class="separator:a35b32ba83d07b2d612b80a3bb8b54c40 inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eee2f6959c9fcab6d8b57d166c81d45 inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a1eee2f6959c9fcab6d8b57d166c81d45"><td class="memItemLeft" align="right" valign="top">frozenset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a1eee2f6959c9fcab6d8b57d166c81d45">exclusions</a> [Hashable]</td></tr>
<tr class="separator:a1eee2f6959c9fcab6d8b57d166c81d45 inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3539bc11e3abeff5e0f5a31bfbc5c7 inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a1f3539bc11e3abeff5e0f5a31bfbc5c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a1f3539bc11e3abeff5e0f5a31bfbc5c7">agg</a> = <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#ae485d4e476e4284dee050eb5245f4862">aggregate</a></td></tr>
<tr class="separator:a1f3539bc11e3abeff5e0f5a31bfbc5c7 inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8b9f732b71012fa0bb8536d92a4a9a58" id="r_a8b9f732b71012fa0bb8536d92a4a9a58"><td class="memItemLeft" align="right" valign="top">Callable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a8b9f732b71012fa0bb8536d92a4a9a58">_make_wrapper</a> (self, str name)</td></tr>
<tr class="separator:a8b9f732b71012fa0bb8536d92a4a9a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0d7bbfff21a8fd204ef792ebcde526" id="r_a0e0d7bbfff21a8fd204ef792ebcde526"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a0e0d7bbfff21a8fd204ef792ebcde526">_set_group_selection</a> (self)</td></tr>
<tr class="separator:a0e0d7bbfff21a8fd204ef792ebcde526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3412e1599dfe3fd3b2a7d11e898235" id="r_a8b3412e1599dfe3fd3b2a7d11e898235"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a8b3412e1599dfe3fd3b2a7d11e898235">_reset_group_selection</a> (self)</td></tr>
<tr class="separator:a8b3412e1599dfe3fd3b2a7d11e898235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f8512420b9ff6a6542e8486ffa34fb" id="r_a61f8512420b9ff6a6542e8486ffa34fb"><td class="memItemLeft" align="right" valign="top">Iterator[<a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html">GroupBy</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a61f8512420b9ff6a6542e8486ffa34fb">_group_selection_context</a> (self)</td></tr>
<tr class="separator:a61f8512420b9ff6a6542e8486ffa34fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831f287a1285ba7913d7586ba7688aba" id="r_a831f287a1285ba7913d7586ba7688aba"><td class="memItemLeft" align="right" valign="top">Iterable[<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a831f287a1285ba7913d7586ba7688aba">_iterate_slices</a> (self)</td></tr>
<tr class="separator:a831f287a1285ba7913d7586ba7688aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b52b4a05f444874a884d158d3da8f93" id="r_a0b52b4a05f444874a884d158d3da8f93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a0b52b4a05f444874a884d158d3da8f93">_concat_objects</a> (self, values, bool not_indexed_same=False, bool override_group_keys=False)</td></tr>
<tr class="separator:a0b52b4a05f444874a884d158d3da8f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6b6af581a5671c827e89968aa0538" id="r_ad3d6b6af581a5671c827e89968aa0538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ad3d6b6af581a5671c827e89968aa0538">_set_result_index_ordered</a> (self, <a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a> result)</td></tr>
<tr class="separator:ad3d6b6af581a5671c827e89968aa0538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d6aef348ced9cc5cab50928b4315f7" id="r_a30d6aef348ced9cc5cab50928b4315f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>|<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a30d6aef348ced9cc5cab50928b4315f7">_indexed_output_to_ndframe</a> (self, Mapping[<a class="el" href="classpandas_1_1core_1_1groupby_1_1base_1_1_output_key.html">base.OutputKey</a>, ArrayLike] result)</td></tr>
<tr class="separator:a30d6aef348ced9cc5cab50928b4315f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccf9ccdf5c08799c946111ed987f8f5" id="r_abccf9ccdf5c08799c946111ed987f8f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#abccf9ccdf5c08799c946111ed987f8f5">_wrap_aggregated_output</a> (self, <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>|<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|Mapping[<a class="el" href="classpandas_1_1core_1_1groupby_1_1base_1_1_output_key.html">base.OutputKey</a>, ArrayLike] output, npt.NDArray[np.float64]|None qs=None)</td></tr>
<tr class="separator:abccf9ccdf5c08799c946111ed987f8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcb1df4792ba902486d6f381b8a86e5" id="r_aabcb1df4792ba902486d6f381b8a86e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>|<a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aabcb1df4792ba902486d6f381b8a86e5">_wrap_transformed_output</a> (self, Mapping[<a class="el" href="classpandas_1_1core_1_1groupby_1_1base_1_1_output_key.html">base.OutputKey</a>, ArrayLike] output)</td></tr>
<tr class="separator:aabcb1df4792ba902486d6f381b8a86e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee76f55dbe28d70c0200aa1e1445240f" id="r_aee76f55dbe28d70c0200aa1e1445240f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aee76f55dbe28d70c0200aa1e1445240f">_wrap_applied_output</a> (self, data, list values, bool not_indexed_same=False, bool override_group_keys=False)</td></tr>
<tr class="separator:aee76f55dbe28d70c0200aa1e1445240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d4f7353558af547198e4b1a1241987" id="r_ab1d4f7353558af547198e4b1a1241987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ab1d4f7353558af547198e4b1a1241987">_resolve_numeric_only</a> (self, str how, bool|lib.NoDefault numeric_only, int <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>)</td></tr>
<tr class="separator:ab1d4f7353558af547198e4b1a1241987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb36b34707fadb002e190330665c619" id="r_acdb36b34707fadb002e190330665c619"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#acdb36b34707fadb002e190330665c619">_maybe_warn_numeric_only_depr</a> (self, str how, <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> result, bool|lib.NoDefault numeric_only)</td></tr>
<tr class="separator:acdb36b34707fadb002e190330665c619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4addbd51bc8d613fae2841d94c27d295" id="r_a4addbd51bc8d613fae2841d94c27d295"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a4addbd51bc8d613fae2841d94c27d295">_numba_prep</a> (self, data)</td></tr>
<tr class="separator:a4addbd51bc8d613fae2841d94c27d295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec4b2be84825263fb17a1ca2ac56baa" id="r_a4ec4b2be84825263fb17a1ca2ac56baa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a4ec4b2be84825263fb17a1ca2ac56baa">_numba_agg_general</a> (self, Callable <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, dict[str, bool]|None engine_kwargs, *aggregator_args)</td></tr>
<tr class="separator:a4ec4b2be84825263fb17a1ca2ac56baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ec1d562112a04515b8d40120c26df4" id="r_a70ec1d562112a04515b8d40120c26df4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a70ec1d562112a04515b8d40120c26df4">_transform_with_numba</a> (self, data, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *args, engine_kwargs=None, **kwargs)</td></tr>
<tr class="separator:a70ec1d562112a04515b8d40120c26df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d512d66c9b4cd678481b0333940b7f" id="r_a56d512d66c9b4cd678481b0333940b7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a56d512d66c9b4cd678481b0333940b7f">_aggregate_with_numba</a> (self, data, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *args, engine_kwargs=None, **kwargs)</td></tr>
<tr class="separator:a56d512d66c9b4cd678481b0333940b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b26dccbffe8fc844cec39230938a94" id="r_a70b26dccbffe8fc844cec39230938a94"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a70b26dccbffe8fc844cec39230938a94">_python_apply_general</a> (self, Callable <a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a>|<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> data, bool|None not_indexed_same=None, bool is_transform=False, bool is_agg=False)</td></tr>
<tr class="separator:a70b26dccbffe8fc844cec39230938a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40939c6ff6ab88ee3a42b3c60b84263" id="r_ac40939c6ff6ab88ee3a42b3c60b84263"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ac40939c6ff6ab88ee3a42b3c60b84263">_python_agg_general</a> (self, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *args, raise_on_typeerror=False, **kwargs)</td></tr>
<tr class="separator:ac40939c6ff6ab88ee3a42b3c60b84263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1ef78759435da21e572e4c267260ea" id="r_a7c1ef78759435da21e572e4c267260ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a7c1ef78759435da21e572e4c267260ea">_agg_general</a> (self, bool|lib.NoDefault numeric_only=True, int min_count=-1, *str alias, Callable npfunc)</td></tr>
<tr class="separator:a7c1ef78759435da21e572e4c267260ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674c277dc7d1d668684f3cfc5b4abe65" id="r_a674c277dc7d1d668684f3cfc5b4abe65"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a674c277dc7d1d668684f3cfc5b4abe65">_agg_py_fallback</a> (self, ArrayLike values, int <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#ae71168779b11e49ff704d8e1252625ba">ndim</a>, Callable alt)</td></tr>
<tr class="separator:a674c277dc7d1d668684f3cfc5b4abe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c8a3809df7bb3ba545722053ab4a8b" id="r_a64c8a3809df7bb3ba545722053ab4a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a64c8a3809df7bb3ba545722053ab4a8b">_cython_agg_general</a> (self, str how, Callable alt, bool|lib.NoDefault numeric_only, int min_count=-1, bool ignore_failures=True, **kwargs)</td></tr>
<tr class="separator:a64c8a3809df7bb3ba545722053ab4a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52338f17622f5eb324ce8a654d41901" id="r_ac52338f17622f5eb324ce8a654d41901"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ac52338f17622f5eb324ce8a654d41901">_cython_transform</a> (self, str how, bool numeric_only=True, int <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae9cb972cc96e0e06c7d409ebed5dcf88">axis</a>=0, **kwargs)</td></tr>
<tr class="separator:ac52338f17622f5eb324ce8a654d41901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6091d4c7f024ed33ef4d07b06cead74a" id="r_a6091d4c7f024ed33ef4d07b06cead74a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a6091d4c7f024ed33ef4d07b06cead74a">_transform</a> (self, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *args, engine=None, engine_kwargs=None, **kwargs)</td></tr>
<tr class="separator:a6091d4c7f024ed33ef4d07b06cead74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fd76cecac1af72652720dd31b8f64c" id="r_a81fd76cecac1af72652720dd31b8f64c"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a81fd76cecac1af72652720dd31b8f64c">_wrap_transform_fast_result</a> (self, NDFrameT result)</td></tr>
<tr class="separator:a81fd76cecac1af72652720dd31b8f64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcc837b955e5cc03775a395cdcff47a" id="r_a9dcc837b955e5cc03775a395cdcff47a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a9dcc837b955e5cc03775a395cdcff47a">_apply_filter</a> (self, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a382def7764ebcaf70d26e83645db0e59">indices</a>, <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a27e6d7322e8c242ea87594807d342c6b">dropna</a>)</td></tr>
<tr class="separator:a9dcc837b955e5cc03775a395cdcff47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9680888ef1890f81ef62ea64a0df555" id="r_ab9680888ef1890f81ef62ea64a0df555"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ab9680888ef1890f81ef62ea64a0df555">_cumcount_array</a> (self, bool ascending=True)</td></tr>
<tr class="separator:ab9680888ef1890f81ef62ea64a0df555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb43e78db5c44635a0e3143192e6833" id="r_a3cb43e78db5c44635a0e3143192e6833"><td class="memItemLeft" align="right" valign="top">Callable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a3cb43e78db5c44635a0e3143192e6833">_obj_1d_constructor</a> (self)</td></tr>
<tr class="separator:a3cb43e78db5c44635a0e3143192e6833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593fa8abde201f7b1425797105f1fe7b" id="r_a593fa8abde201f7b1425797105f1fe7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a593fa8abde201f7b1425797105f1fe7b">_bool_agg</a> (self, Literal[&quot;any&quot;, &quot;all&quot;] val_test, bool skipna)</td></tr>
<tr class="separator:a593fa8abde201f7b1425797105f1fe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c7f23ca259094f9058ba1d6bbcfb53" id="r_ad9c7f23ca259094f9058ba1d6bbcfb53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ad9c7f23ca259094f9058ba1d6bbcfb53">_fill</a> (self, Literal[&quot;ffill&quot;, &quot;bfill&quot;] direction, limit=None)</td></tr>
<tr class="separator:ad9c7f23ca259094f9058ba1d6bbcfb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d39b4286e3f16112113159820c2d471" id="r_a8d39b4286e3f16112113159820c2d471"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a8d39b4286e3f16112113159820c2d471">_nth</a> (self, PositionalIndexer|tuple <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, Literal[&quot;any&quot;, &quot;all&quot;, None] <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a27e6d7322e8c242ea87594807d342c6b">dropna</a>=None)</td></tr>
<tr class="separator:a8d39b4286e3f16112113159820c2d471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d2fc9b02784da8356e687d0ba74815" id="r_a72d2fc9b02784da8356e687d0ba74815"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a72d2fc9b02784da8356e687d0ba74815">_get_cythonized_result</a> (self, Callable base_func, np.dtype cython_dtype, bool|lib.NoDefault numeric_only=lib.no_default, bool needs_counts=False, bool needs_nullable=False, bool needs_mask=False, pre_processing=None, post_processing=None, **kwargs)</td></tr>
<tr class="separator:a72d2fc9b02784da8356e687d0ba74815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae444b9f5016c2439cf1662f905d66d64" id="r_ae444b9f5016c2439cf1662f905d66d64"><td class="memItemLeft" align="right" valign="top">NDFrameT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#ae444b9f5016c2439cf1662f905d66d64">_mask_selected_obj</a> (self, npt.NDArray[np.bool_] mask)</td></tr>
<tr class="separator:ae444b9f5016c2439cf1662f905d66d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24281d563b467e8f513648bd5af299f" id="r_aa24281d563b467e8f513648bd5af299f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aa24281d563b467e8f513648bd5af299f">_reindex_output</a> (self, <a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a> output, Scalar fill_value=np.NaN, npt.NDArray[np.float64]|None qs=None)</td></tr>
<tr class="separator:aa24281d563b467e8f513648bd5af299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html">pandas.core.groupby.groupby.BaseGroupBy</a></td></tr>
<tr class="memitem:accd950a40bfd15bc8696bf3a9ca76f38 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_accd950a40bfd15bc8696bf3a9ca76f38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#accd950a40bfd15bc8696bf3a9ca76f38">_get_indices</a> (self, names)</td></tr>
<tr class="separator:accd950a40bfd15bc8696bf3a9ca76f38 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3542def8e404156a3457e499c8583842 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a3542def8e404156a3457e499c8583842"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a3542def8e404156a3457e499c8583842">_get_index</a> (self, name)</td></tr>
<tr class="separator:a3542def8e404156a3457e499c8583842 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7f37c3e7e01e9a624bfcdb9ca795f inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_aa8d7f37c3e7e01e9a624bfcdb9ca795f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#aa8d7f37c3e7e01e9a624bfcdb9ca795f">_selected_obj</a> (self)</td></tr>
<tr class="separator:aa8d7f37c3e7e01e9a624bfcdb9ca795f inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cad65657392c7742cfa69fdb2fadbb inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_ad7cad65657392c7742cfa69fdb2fadbb"><td class="memItemLeft" align="right" valign="top">set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#ad7cad65657392c7742cfa69fdb2fadbb">_dir_additions</a> (self)</td></tr>
<tr class="separator:ad7cad65657392c7742cfa69fdb2fadbb inherit pro_methods_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html">pandas.core.base.PandasObject</a></td></tr>
<tr class="memitem:a7b5112b72a8bafe13b1fa732bf1ea30d inherit pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object" id="r_a7b5112b72a8bafe13b1fa732bf1ea30d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#a7b5112b72a8bafe13b1fa732bf1ea30d">_constructor</a> (self)</td></tr>
<tr class="separator:a7b5112b72a8bafe13b1fa732bf1ea30d inherit pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2b95a9e1e4befc5ad3cba09c3f3e68 inherit pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object" id="r_a8a2b95a9e1e4befc5ad3cba09c3f3e68"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#a8a2b95a9e1e4befc5ad3cba09c3f3e68">_reset_cache</a> (self, str|None key=None)</td></tr>
<tr class="separator:a8a2b95a9e1e4befc5ad3cba09c3f3e68 inherit pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html">pandas.core.accessor.DirNamesMixin</a></td></tr>
<tr class="memitem:a3151f76f1b53042e9d13da3d3ef3cb92 inherit pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_a3151f76f1b53042e9d13da3d3ef3cb92"><td class="memItemLeft" align="right" valign="top">set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#a3151f76f1b53042e9d13da3d3ef3cb92">_dir_deletions</a> (self)</td></tr>
<tr class="separator:a3151f76f1b53042e9d13da3d3ef3cb92 inherit pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html">pandas.core.base.SelectionMixin</a></td></tr>
<tr class="memitem:a84ab5b21406fb07629293d56ffc9f98a inherit pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a84ab5b21406fb07629293d56ffc9f98a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a84ab5b21406fb07629293d56ffc9f98a">_selection_list</a> (self)</td></tr>
<tr class="separator:a84ab5b21406fb07629293d56ffc9f98a inherit pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6785b162f9f2a0f0a8a279201346db inherit pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_acd6785b162f9f2a0f0a8a279201346db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#acd6785b162f9f2a0f0a8a279201346db">_obj_with_exclusions</a> (self)</td></tr>
<tr class="separator:acd6785b162f9f2a0f0a8a279201346db inherit pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3d118b3cd8f40293932a1487962d18 inherit pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a9f3d118b3cd8f40293932a1487962d18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a9f3d118b3cd8f40293932a1487962d18">_gotitem</a> (self, key, int <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#ae71168779b11e49ff704d8e1252625ba">ndim</a>, subset=None)</td></tr>
<tr class="separator:a9f3d118b3cd8f40293932a1487962d18 inherit pro_methods_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html">pandas.core.groupby.indexing.GroupByIndexingMixin</a></td></tr>
<tr class="memitem:a8058dd6f140a9da6b0f02e823cce9159 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a8058dd6f140a9da6b0f02e823cce9159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_positional_selector.html">GroupByPositionalSelector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a8058dd6f140a9da6b0f02e823cce9159">_positional_selector</a> (self)</td></tr>
<tr class="separator:a8058dd6f140a9da6b0f02e823cce9159 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1544259469e017dd36d79d395ed5f15e inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a1544259469e017dd36d79d395ed5f15e"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a1544259469e017dd36d79d395ed5f15e">_make_mask_from_positional_indexer</a> (self, PositionalIndexer|tuple arg)</td></tr>
<tr class="separator:a1544259469e017dd36d79d395ed5f15e inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919beb972b6e2651679c1ab45f0d0f63 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a919beb972b6e2651679c1ab45f0d0f63"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a919beb972b6e2651679c1ab45f0d0f63">_make_mask_from_int</a> (self, int arg)</td></tr>
<tr class="separator:a919beb972b6e2651679c1ab45f0d0f63 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0259da6f314c77dd123353e9812c97 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a1d0259da6f314c77dd123353e9812c97"><td class="memItemLeft" align="right" valign="top">bool|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a1d0259da6f314c77dd123353e9812c97">_make_mask_from_list</a> (self, Iterable[int] args)</td></tr>
<tr class="separator:a1d0259da6f314c77dd123353e9812c97 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd469858a37bce644e9d3beafbe7ff1 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a6fd469858a37bce644e9d3beafbe7ff1"><td class="memItemLeft" align="right" valign="top">bool|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a6fd469858a37bce644e9d3beafbe7ff1">_make_mask_from_tuple</a> (self, tuple args)</td></tr>
<tr class="separator:a6fd469858a37bce644e9d3beafbe7ff1 inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3816900101ed8903025bb3c5e4e29f1a inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a3816900101ed8903025bb3c5e4e29f1a"><td class="memItemLeft" align="right" valign="top">bool|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a3816900101ed8903025bb3c5e4e29f1a">_make_mask_from_slice</a> (self, slice arg)</td></tr>
<tr class="separator:a3816900101ed8903025bb3c5e4e29f1a inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8a626dbf481c3b532e4479cb8b040c inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_aea8a626dbf481c3b532e4479cb8b040c"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#aea8a626dbf481c3b532e4479cb8b040c">_ascending_count</a> (self)</td></tr>
<tr class="separator:aea8a626dbf481c3b532e4479cb8b040c inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad474a847bbcdd0cadf7ca3edce7bcbb inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_aad474a847bbcdd0cadf7ca3edce7bcbb"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#aad474a847bbcdd0cadf7ca3edce7bcbb">_descending_count</a> (self)</td></tr>
<tr class="separator:aad474a847bbcdd0cadf7ca3edce7bcbb inherit pro_methods_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a91472f24fd5afcc07a81edd04b4a5328" id="r_a91472f24fd5afcc07a81edd04b4a5328"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a91472f24fd5afcc07a81edd04b4a5328">_selection</a></td></tr>
<tr class="separator:a91472f24fd5afcc07a81edd04b4a5328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ece12e82ff5f534105bb530a9ab8d7b" id="r_a8ece12e82ff5f534105bb530a9ab8d7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a8ece12e82ff5f534105bb530a9ab8d7b">_obj_with_exclusions</a></td></tr>
<tr class="separator:a8ece12e82ff5f534105bb530a9ab8d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff99672d810c7fc573dfda274d594902" id="r_aff99672d810c7fc573dfda274d594902"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#aff99672d810c7fc573dfda274d594902">_group_selection</a></td></tr>
<tr class="separator:aff99672d810c7fc573dfda274d594902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9c3764acd40f62b4463bf8aa235190" id="r_a6e9c3764acd40f62b4463bf8aa235190"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html#a6e9c3764acd40f62b4463bf8aa235190">_selected_obj</a></td></tr>
<tr class="separator:a6e9c3764acd40f62b4463bf8aa235190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html">pandas.core.groupby.groupby.BaseGroupBy</a></td></tr>
<tr class="memitem:a9a9f7af2038792b5d11979856e4e20dc inherit pro_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a9a9f7af2038792b5d11979856e4e20dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a9a9f7af2038792b5d11979856e4e20dc">_selected_obj</a></td></tr>
<tr class="separator:a9a9f7af2038792b5d11979856e4e20dc inherit pro_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html">pandas.core.base.SelectionMixin</a></td></tr>
<tr class="memitem:a4b377ecea0956413cc4e45a77d887ac5 inherit pro_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a4b377ecea0956413cc4e45a77d887ac5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a4b377ecea0956413cc4e45a77d887ac5">_selection</a></td></tr>
<tr class="separator:a4b377ecea0956413cc4e45a77d887ac5 inherit pro_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html">pandas.core.groupby.indexing.GroupByIndexingMixin</a></td></tr>
<tr class="memitem:a783cac517cedcd04929c9306b10f99f7 inherit pro_attribs_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a783cac517cedcd04929c9306b10f99f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a783cac517cedcd04929c9306b10f99f7">_ascending_count</a></td></tr>
<tr class="separator:a783cac517cedcd04929c9306b10f99f7 inherit pro_attribs_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9035f1c6ded6d3a8a4be99f8bcdc819e inherit pro_attribs_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin" id="r_a9035f1c6ded6d3a8a4be99f8bcdc819e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin.html#a9035f1c6ded6d3a8a4be99f8bcdc819e">_descending_count</a></td></tr>
<tr class="separator:a9035f1c6ded6d3a8a4be99f8bcdc819e inherit pro_attribs_classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_indexing_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html">pandas.core.groupby.groupby.BaseGroupBy</a></td></tr>
<tr class="memitem:ab1eb9ea25d40e44224ef45786e96593b inherit pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_ab1eb9ea25d40e44224ef45786e96593b"><td class="memItemLeft" align="right" valign="top">IndexLabel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#ab1eb9ea25d40e44224ef45786e96593b">_group_selection</a> = None</td></tr>
<tr class="separator:ab1eb9ea25d40e44224ef45786e96593b inherit pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56913505db7674b523b10e2801ff808b inherit pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a56913505db7674b523b10e2801ff808b"><td class="memItemLeft" align="right" valign="top">frozenset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a56913505db7674b523b10e2801ff808b">_apply_allowlist</a> = frozenset()</td></tr>
<tr class="separator:a56913505db7674b523b10e2801ff808b inherit pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792c142e01aa4fc5640ed6e0211d3c5f inherit pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a792c142e01aa4fc5640ed6e0211d3c5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a792c142e01aa4fc5640ed6e0211d3c5f">_hidden_attrs</a></td></tr>
<tr class="separator:a792c142e01aa4fc5640ed6e0211d3c5f inherit pro_static_attribs_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html">pandas.core.base.PandasObject</a></td></tr>
<tr class="memitem:a3972565a4ab5ff072118eda20364cd2c inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object" id="r_a3972565a4ab5ff072118eda20364cd2c"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#a3972565a4ab5ff072118eda20364cd2c">_cache</a> [str, Any]</td></tr>
<tr class="separator:a3972565a4ab5ff072118eda20364cd2c inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html">pandas.core.accessor.DirNamesMixin</a></td></tr>
<tr class="memitem:a1e3f9f50e3532c77c3610c4b8fe27e6f inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_a1e3f9f50e3532c77c3610c4b8fe27e6f"><td class="memItemLeft" align="right" valign="top">set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#a1e3f9f50e3532c77c3610c4b8fe27e6f">_accessors</a> = set()</td></tr>
<tr class="separator:a1e3f9f50e3532c77c3610c4b8fe27e6f inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c1894b79d330020bdc71ddc7126f0 inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_a7b9c1894b79d330020bdc71ddc7126f0"><td class="memItemLeft" align="right" valign="top">frozenset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#a7b9c1894b79d330020bdc71ddc7126f0">_hidden_attrs</a> = frozenset()</td></tr>
<tr class="separator:a7b9c1894b79d330020bdc71ddc7126f0 inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html">pandas.core.base.SelectionMixin</a></td></tr>
<tr class="memitem:aa329bea9aae5a514a109fd19b39e4d51 inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_aa329bea9aae5a514a109fd19b39e4d51"><td class="memItemLeft" align="right" valign="top">IndexLabel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#aa329bea9aae5a514a109fd19b39e4d51">_selection</a> = None</td></tr>
<tr class="separator:aa329bea9aae5a514a109fd19b39e4d51 inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fff6c63df1250ed6784ad633fe03f4 inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_ae5fff6c63df1250ed6784ad633fe03f4"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#ae5fff6c63df1250ed6784ad633fe03f4">_internal_names</a> = [&quot;_cache&quot;, &quot;__setstate__&quot;]</td></tr>
<tr class="separator:ae5fff6c63df1250ed6784ad633fe03f4 inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df1b01fd09955430d448bf0a173a2f5 inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin" id="r_a4df1b01fd09955430d448bf0a173a2f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#a4df1b01fd09955430d448bf0a173a2f5">_internal_names_set</a> = set(<a class="el" href="classpandas_1_1core_1_1base_1_1_selection_mixin.html#ae5fff6c63df1250ed6784ad633fe03f4">_internal_names</a>)</td></tr>
<tr class="separator:a4df1b01fd09955430d448bf0a173a2f5 inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_selection_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td colspan="2" onclick="javascript:toggleInherit('properties_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html">pandas.core.groupby.groupby.BaseGroupBy</a></td></tr>
<tr class="memitem:a6c077356eed76c9ccef179f410fdb3c6 inherit properties_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by" id="r_a6c077356eed76c9ccef179f410fdb3c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by.html#a6c077356eed76c9ccef179f410fdb3c6">plot</a> = property(<a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by_plot.html">GroupByPlot</a>)</td></tr>
<tr class="separator:a6c077356eed76c9ccef179f410fdb3c6 inherit properties_classpandas_1_1core_1_1groupby_1_1groupby_1_1_base_group_by"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Class for grouping and aggregating relational data.

See aggregate, transform, and apply functions on this object.

It's easiest to use obj.groupby(...) to use GroupBy, but you can also do:

::

    grouped = groupby(obj, ...)

Parameters
----------
obj : pandas object
axis : int, default 0
level : int, default None
    Level of MultiIndex
groupings : list of Grouping objects
    Most users should ignore this
exclusions : array-like, optional
    List of columns to exclude
name : str
    Most users should ignore this

Returns
-------
**Attributes**
groups : dict
    {group name -&gt; group labels}
len(grouped) : int
    Number of groups

Notes
-----
After grouping, see aggregate, apply, and transform functions. Here are
some other brief notes about usage. When grouping by multiple groups, the
result index will be a MultiIndex (hierarchical) by default.

Iteration produces (key, group) tuples, i.e. chunking the data by group. So
you can write code like:

::

    grouped = obj.groupby(keys, axis=axis)
    for key, group in grouped:
        # do something with the data

Function calls on GroupBy, if not specially implemented, "dispatch" to the
grouped data. So if you group a DataFrame and wish to invoke the std()
method on each group, you can simply do:

::

    df.groupby(mapper).std()

rather than

::

    df.groupby(mapper).aggregate(np.std)

You can pass arguments to these "wrapped" functions, too.

See the online documentation for full exposition on these topics and much
more
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a428c03b38a8e631b520eb73065457ddf" name="a428c03b38a8e631b520eb73065457ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c03b38a8e631b520eb73065457ddf">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.groupby.groupby.GroupBy.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NDFrameT&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a34ab6708bf412008a6c49f719c219280">_KeysArgType</a> | None &#160;</td>
          <td class="paramname"><em>keys</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1groupby_1_1ops_1_1_base_grouper.html">ops.BaseGrouper</a> | None &#160;</td>
          <td class="paramname"><em>grouper</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">frozenset[Hashable] | None &#160;</td>
          <td class="paramname"><em>exclusions</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>selection</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>as_index</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>group_keys</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>squeeze</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>observed</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>mutated</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dropna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  933</span>    ) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  934</span> </div>
<div class="line"><span class="lineno">  935</span>        self._selection = selection</div>
<div class="line"><span class="lineno">  936</span> </div>
<div class="line"><span class="lineno">  937</span>        <span class="keyword">assert</span> isinstance(obj, NDFrame), type(obj)</div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span>        self.level = level</div>
<div class="line"><span class="lineno">  940</span> </div>
<div class="line"><span class="lineno">  941</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> as_index:</div>
<div class="line"><span class="lineno">  942</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(obj, DataFrame):</div>
<div class="line"><span class="lineno">  943</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;as_index=False only valid with DataFrame&quot;</span>)</div>
<div class="line"><span class="lineno">  944</span>            <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno">  945</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;as_index=False only valid for axis=0&quot;</span>)</div>
<div class="line"><span class="lineno">  946</span> </div>
<div class="line"><span class="lineno">  947</span>        self.as_index = as_index</div>
<div class="line"><span class="lineno">  948</span>        self.keys = keys</div>
<div class="line"><span class="lineno">  949</span>        self.sort = sort</div>
<div class="line"><span class="lineno">  950</span>        self.group_keys = group_keys</div>
<div class="line"><span class="lineno">  951</span>        self.squeeze = squeeze</div>
<div class="line"><span class="lineno">  952</span>        self.observed = observed</div>
<div class="line"><span class="lineno">  953</span>        self.mutated = mutated</div>
<div class="line"><span class="lineno">  954</span>        self.dropna = dropna</div>
<div class="line"><span class="lineno">  955</span> </div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordflow">if</span> grouper <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  957</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1groupby_1_1grouper.html">pandas.core.groupby.grouper</a> <span class="keyword">import</span> get_grouper</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span>            grouper, exclusions, obj = get_grouper(</div>
<div class="line"><span class="lineno">  960</span>                obj,</div>
<div class="line"><span class="lineno">  961</span>                keys,</div>
<div class="line"><span class="lineno">  962</span>                axis=axis,</div>
<div class="line"><span class="lineno">  963</span>                level=level,</div>
<div class="line"><span class="lineno">  964</span>                sort=sort,</div>
<div class="line"><span class="lineno">  965</span>                observed=observed,</div>
<div class="line"><span class="lineno">  966</span>                mutated=self.mutated,</div>
<div class="line"><span class="lineno">  967</span>                dropna=self.dropna,</div>
<div class="line"><span class="lineno">  968</span>            )</div>
<div class="line"><span class="lineno">  969</span> </div>
<div class="line"><span class="lineno">  970</span>        self.obj = obj</div>
<div class="line"><span class="lineno">  971</span>        self.axis = obj._get_axis_number(axis)</div>
<div class="line"><span class="lineno">  972</span>        self.grouper = grouper</div>
<div class="line"><span class="lineno">  973</span>        self.exclusions = frozenset(exclusions) <span class="keywordflow">if</span> exclusions <span class="keywordflow">else</span> frozenset()</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1groupby_1_1grouper_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1groupby_1_1grouper.html">pandas.core.groupby.grouper</a></div><div class="ttdef"><b>Definition</b> grouper.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a75caced3d083bf6a25e21388c79b8d76" name="a75caced3d083bf6a25e21388c79b8d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75caced3d083bf6a25e21388c79b8d76">&#9670;&#160;</a></span>__getattr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.__getattr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  975</span>    <span class="keyword">def </span>__getattr__(self, attr: str):</div>
<div class="line"><span class="lineno">  976</span>        <span class="keywordflow">if</span> attr <span class="keywordflow">in</span> self._internal_names_set:</div>
<div class="line"><span class="lineno">  977</span>            <span class="keywordflow">return</span> object.__getattribute__(self, attr)</div>
<div class="line"><span class="lineno">  978</span>        <span class="keywordflow">if</span> attr <span class="keywordflow">in</span> self.obj:</div>
<div class="line"><span class="lineno">  979</span>            <span class="keywordflow">return</span> self[attr]</div>
<div class="line"><span class="lineno">  980</span> </div>
<div class="line"><span class="lineno">  981</span>        <span class="keywordflow">raise</span> AttributeError(</div>
<div class="line"><span class="lineno">  982</span>            f<span class="stringliteral">&quot;&#39;{type(self).__name__}&#39; object has no attribute &#39;{attr}&#39;&quot;</span></div>
<div class="line"><span class="lineno">  983</span>        )</div>
<div class="line"><span class="lineno">  984</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c1ef78759435da21e572e4c267260ea" name="a7c1ef78759435da21e572e4c267260ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1ef78759435da21e572e4c267260ea">&#9670;&#160;</a></span>_agg_general()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._agg_general </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>npfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1679</span>    ):</div>
<div class="line"><span class="lineno"> 1680</span> </div>
<div class="line"><span class="lineno"> 1681</span>        <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 1682</span>            <span class="comment"># try a cython aggregation if we can</span></div>
<div class="line"><span class="lineno"> 1683</span>            result = self._cython_agg_general(</div>
<div class="line"><span class="lineno"> 1684</span>                how=alias,</div>
<div class="line"><span class="lineno"> 1685</span>                alt=npfunc,</div>
<div class="line"><span class="lineno"> 1686</span>                numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 1687</span>                min_count=min_count,</div>
<div class="line"><span class="lineno"> 1688</span>            )</div>
<div class="line"><span class="lineno"> 1689</span>            <span class="keywordflow">return</span> result.__finalize__(self.obj, method=<span class="stringliteral">&quot;groupby&quot;</span>)</div>
<div class="line"><span class="lineno"> 1690</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a674c277dc7d1d668684f3cfc5b4abe65" name="a674c277dc7d1d668684f3cfc5b4abe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674c277dc7d1d668684f3cfc5b4abe65">&#9670;&#160;</a></span>_agg_py_fallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.groupby.groupby.GroupBy._agg_py_fallback </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable
    &#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Fallback to pure-python aggregation if _cython_operation raises
NotImplementedError.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1693</span>    ) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1694</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">        Fallback to pure-python aggregation if _cython_operation raises</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">        NotImplementedError.</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1698</span>        <span class="comment"># We get here with a) EADtypes and b) object dtype</span></div>
<div class="line"><span class="lineno"> 1699</span> </div>
<div class="line"><span class="lineno"> 1700</span>        <span class="keywordflow">if</span> values.ndim == 1:</div>
<div class="line"><span class="lineno"> 1701</span>            <span class="comment"># For DataFrameGroupBy we only get here with ExtensionArray</span></div>
<div class="line"><span class="lineno"> 1702</span>            ser = Series(values)</div>
<div class="line"><span class="lineno"> 1703</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1704</span>            <span class="comment"># We only get here with values.dtype == object</span></div>
<div class="line"><span class="lineno"> 1705</span>            <span class="comment"># TODO: special case not needed with ArrayManager</span></div>
<div class="line"><span class="lineno"> 1706</span>            df = DataFrame(values.T)</div>
<div class="line"><span class="lineno"> 1707</span>            <span class="comment"># bc we split object blocks in grouped_reduce, we have only 1 col</span></div>
<div class="line"><span class="lineno"> 1708</span>            <span class="comment"># otherwise we&#39;d have to worry about block-splitting GH#39329</span></div>
<div class="line"><span class="lineno"> 1709</span>            <span class="keyword">assert</span> df.shape[1] == 1</div>
<div class="line"><span class="lineno"> 1710</span>            <span class="comment"># Avoid call to self.values that can occur in DataFrame</span></div>
<div class="line"><span class="lineno"> 1711</span>            <span class="comment">#  reductions; see GH#28949</span></div>
<div class="line"><span class="lineno"> 1712</span>            ser = df.iloc[:, 0]</div>
<div class="line"><span class="lineno"> 1713</span> </div>
<div class="line"><span class="lineno"> 1714</span>        <span class="comment"># We do not get here with UDFs, so we know that our dtype</span></div>
<div class="line"><span class="lineno"> 1715</span>        <span class="comment">#  should always be preserved by the implemented aggregations</span></div>
<div class="line"><span class="lineno"> 1716</span>        <span class="comment"># TODO: Is this exactly right; see WrappedCythonOp get_result_dtype?</span></div>
<div class="line"><span class="lineno"> 1717</span>        res_values = self.grouper.agg_series(ser, alt, preserve_dtype=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1718</span> </div>
<div class="line"><span class="lineno"> 1719</span>        <span class="keywordflow">if</span> isinstance(values, Categorical):</div>
<div class="line"><span class="lineno"> 1720</span>            <span class="comment"># Because we only get here with known dtype-preserving</span></div>
<div class="line"><span class="lineno"> 1721</span>            <span class="comment">#  reductions, we cast back to Categorical.</span></div>
<div class="line"><span class="lineno"> 1722</span>            <span class="comment"># TODO: if we ever get &quot;rank&quot; working, exclude it here.</span></div>
<div class="line"><span class="lineno"> 1723</span>            res_values = type(values)._from_sequence(res_values, dtype=values.dtype)</div>
<div class="line"><span class="lineno"> 1724</span> </div>
<div class="line"><span class="lineno"> 1725</span>        <span class="comment"># If we are DataFrameGroupBy and went through a SeriesGroupByPath</span></div>
<div class="line"><span class="lineno"> 1726</span>        <span class="comment"># then we need to reshape</span></div>
<div class="line"><span class="lineno"> 1727</span>        <span class="comment"># GH#32223 includes case with IntegerArray values, ndarray res_values</span></div>
<div class="line"><span class="lineno"> 1728</span>        <span class="comment"># test_groupby_duplicate_columns with object dtype values</span></div>
<div class="line"><span class="lineno"> 1729</span>        <span class="keywordflow">return</span> ensure_block_shape(res_values, ndim=ndim)</div>
<div class="line"><span class="lineno"> 1730</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a56d512d66c9b4cd678481b0333940b7f" name="a56d512d66c9b4cd678481b0333940b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d512d66c9b4cd678481b0333940b7f">&#9670;&#160;</a></span>_aggregate_with_numba()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._aggregate_with_numba </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Perform groupby aggregation routine with the numba engine.

This routine mimics the data splitting routine of the DataSplitter class
to generate the indices of each group in the sorted data and then passes the
data and indices into a Numba jitted function.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1479</span>    <span class="keyword">def </span>_aggregate_with_numba(self, data, func, *args, engine_kwargs=None, **kwargs):</div>
<div class="line"><span class="lineno"> 1480</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">        Perform groupby aggregation routine with the numba engine.</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral">        This routine mimics the data splitting routine of the DataSplitter class</span></div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">        to generate the indices of each group in the sorted data and then passes the</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">        data and indices into a Numba jitted function.</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1487</span>        starts, ends, sorted_index, sorted_data = self._numba_prep(data)</div>
<div class="line"><span class="lineno"> 1488</span>        numba_.validate_udf(func)</div>
<div class="line"><span class="lineno"> 1489</span>        numba_agg_func = numba_.generate_numba_agg_func(</div>
<div class="line"><span class="lineno"> 1490</span>            func, **get_jit_arguments(engine_kwargs, kwargs)</div>
<div class="line"><span class="lineno"> 1491</span>        )</div>
<div class="line"><span class="lineno"> 1492</span>        result = numba_agg_func(</div>
<div class="line"><span class="lineno"> 1493</span>            sorted_data,</div>
<div class="line"><span class="lineno"> 1494</span>            sorted_index,</div>
<div class="line"><span class="lineno"> 1495</span>            starts,</div>
<div class="line"><span class="lineno"> 1496</span>            ends,</div>
<div class="line"><span class="lineno"> 1497</span>            len(data.columns),</div>
<div class="line"><span class="lineno"> 1498</span>            *args,</div>
<div class="line"><span class="lineno"> 1499</span>        )</div>
<div class="line"><span class="lineno"> 1500</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1501</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9dcc837b955e5cc03775a395cdcff47a" name="a9dcc837b955e5cc03775a395cdcff47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcc837b955e5cc03775a395cdcff47a">&#9670;&#160;</a></span>_apply_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._apply_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dropna</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1874</span>    <span class="keyword">def </span>_apply_filter(self, indices, dropna):</div>
<div class="line"><span class="lineno"> 1875</span>        <span class="keywordflow">if</span> len(indices) == 0:</div>
<div class="line"><span class="lineno"> 1876</span>            indices = np.array([], dtype=<span class="stringliteral">&quot;int64&quot;</span>)</div>
<div class="line"><span class="lineno"> 1877</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1878</span>            indices = np.sort(np.concatenate(indices))</div>
<div class="line"><span class="lineno"> 1879</span>        <span class="keywordflow">if</span> dropna:</div>
<div class="line"><span class="lineno"> 1880</span>            filtered = self._selected_obj.take(indices, axis=self.axis)</div>
<div class="line"><span class="lineno"> 1881</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1882</span>            mask = np.empty(len(self._selected_obj.index), dtype=bool)</div>
<div class="line"><span class="lineno"> 1883</span>            mask.fill(<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1884</span>            mask[indices.astype(int)] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1885</span>            <span class="comment"># mask fails to broadcast when passed to where; broadcast manually.</span></div>
<div class="line"><span class="lineno"> 1886</span>            mask = np.tile(mask, list(self._selected_obj.shape[1:]) + [1]).T</div>
<div class="line"><span class="lineno"> 1887</span>            filtered = self._selected_obj.where(mask)  <span class="comment"># Fill with NaNs.</span></div>
<div class="line"><span class="lineno"> 1888</span>        <span class="keywordflow">return</span> filtered</div>
<div class="line"><span class="lineno"> 1889</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a593fa8abde201f7b1425797105f1fe7b" name="a593fa8abde201f7b1425797105f1fe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593fa8abde201f7b1425797105f1fe7b">&#9670;&#160;</a></span>_bool_agg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._bool_agg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;any&quot;, &quot;all&quot;]&#160;</td>
          <td class="paramname"><em>val_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipna</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Shared func to call any / all Cython GroupBy implementations.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1940</span>    <span class="keyword">def </span>_bool_agg(self, val_test: Literal[<span class="stringliteral">&quot;any&quot;</span>, <span class="stringliteral">&quot;all&quot;</span>], skipna: bool):</div>
<div class="line"><span class="lineno"> 1941</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">        Shared func to call any / all Cython GroupBy implementations.</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1944</span> </div>
<div class="line"><span class="lineno"> 1945</span>        <span class="keyword">def </span>objs_to_bool(vals: ArrayLike) -&gt; tuple[np.ndarray, type]:</div>
<div class="line"><span class="lineno"> 1946</span>            <span class="keywordflow">if</span> is_object_dtype(vals.dtype):</div>
<div class="line"><span class="lineno"> 1947</span>                <span class="comment"># GH#37501: don&#39;t raise on pd.NA when skipna=True</span></div>
<div class="line"><span class="lineno"> 1948</span>                <span class="keywordflow">if</span> skipna:</div>
<div class="line"><span class="lineno"> 1949</span>                    func = np.vectorize(</div>
<div class="line"><span class="lineno"> 1950</span>                        <span class="keyword">lambda</span> x: bool(x) <span class="keywordflow">if</span> <span class="keywordflow">not</span> isna(x) <span class="keywordflow">else</span> <span class="keyword">True</span>, otypes=[bool]</div>
<div class="line"><span class="lineno"> 1951</span>                    )</div>
<div class="line"><span class="lineno"> 1952</span>                    vals = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(vals)</div>
<div class="line"><span class="lineno"> 1953</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1954</span>                    vals = vals.astype(bool, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1955</span> </div>
<div class="line"><span class="lineno"> 1956</span>                vals = cast(np.ndarray, vals)</div>
<div class="line"><span class="lineno"> 1957</span>            <span class="keywordflow">elif</span> isinstance(vals, BaseMaskedArray):</div>
<div class="line"><span class="lineno"> 1958</span>                vals = vals._data.astype(bool, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1959</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1960</span>                vals = vals.astype(bool, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1961</span> </div>
<div class="line"><span class="lineno"> 1962</span>            <span class="keywordflow">return</span> vals.view(np.int8), bool</div>
<div class="line"><span class="lineno"> 1963</span> </div>
<div class="line"><span class="lineno"> 1964</span>        <span class="keyword">def </span>result_to_bool(</div>
<div class="line"><span class="lineno"> 1965</span>            result: np.ndarray,</div>
<div class="line"><span class="lineno"> 1966</span>            inference: type,</div>
<div class="line"><span class="lineno"> 1967</span>            nullable: bool = <span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1968</span>        ) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1969</span>            <span class="keywordflow">if</span> nullable:</div>
<div class="line"><span class="lineno"> 1970</span>                <span class="keywordflow">return</span> BooleanArray(result.astype(bool, copy=<span class="keyword">False</span>), result == -1)</div>
<div class="line"><span class="lineno"> 1971</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1972</span>                <span class="keywordflow">return</span> result.astype(inference, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1973</span> </div>
<div class="line"><span class="lineno"> 1974</span>        <span class="keywordflow">return</span> self._get_cythonized_result(</div>
<div class="line"><span class="lineno"> 1975</span>            libgroupby.group_any_all,</div>
<div class="line"><span class="lineno"> 1976</span>            numeric_only=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1977</span>            cython_dtype=np.dtype(np.int8),</div>
<div class="line"><span class="lineno"> 1978</span>            needs_mask=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 1979</span>            needs_nullable=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 1980</span>            pre_processing=objs_to_bool,</div>
<div class="line"><span class="lineno"> 1981</span>            post_processing=result_to_bool,</div>
<div class="line"><span class="lineno"> 1982</span>            val_test=val_test,</div>
<div class="line"><span class="lineno"> 1983</span>            skipna=skipna,</div>
<div class="line"><span class="lineno"> 1984</span>        )</div>
<div class="line"><span class="lineno"> 1985</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b52b4a05f444874a884d158d3da8f93" name="a0b52b4a05f444874a884d158d3da8f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b52b4a05f444874a884d158d3da8f93">&#9670;&#160;</a></span>_concat_objects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._concat_objects </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>not_indexed_same</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>override_group_keys</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1122</span>    ):</div>
<div class="line"><span class="lineno"> 1123</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1reshape_1_1concat.html">pandas.core.reshape.concat</a> <span class="keyword">import</span> concat</div>
<div class="line"><span class="lineno"> 1124</span> </div>
<div class="line"><span class="lineno"> 1125</span>        <span class="keyword">def </span>reset_identity(values):</div>
<div class="line"><span class="lineno"> 1126</span>            <span class="comment"># reset the identities of the components</span></div>
<div class="line"><span class="lineno"> 1127</span>            <span class="comment"># of the values to prevent aliasing</span></div>
<div class="line"><span class="lineno"> 1128</span>            <span class="keywordflow">for</span> v <span class="keywordflow">in</span> com.not_none(*values):</div>
<div class="line"><span class="lineno"> 1129</span>                ax = v._get_axis(self.axis)</div>
<div class="line"><span class="lineno"> 1130</span>                ax._reset_identity()</div>
<div class="line"><span class="lineno"> 1131</span>            <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1132</span> </div>
<div class="line"><span class="lineno"> 1133</span>        <span class="keywordflow">if</span> self.group_keys <span class="keywordflow">and</span> <span class="keywordflow">not</span> override_group_keys:</div>
<div class="line"><span class="lineno"> 1134</span> </div>
<div class="line"><span class="lineno"> 1135</span>            values = reset_identity(values)</div>
<div class="line"><span class="lineno"> 1136</span>            <span class="keywordflow">if</span> self.as_index:</div>
<div class="line"><span class="lineno"> 1137</span> </div>
<div class="line"><span class="lineno"> 1138</span>                <span class="comment"># possible MI return case</span></div>
<div class="line"><span class="lineno"> 1139</span>                group_keys = self.grouper.result_index</div>
<div class="line"><span class="lineno"> 1140</span>                group_levels = self.grouper.levels</div>
<div class="line"><span class="lineno"> 1141</span>                group_names = self.grouper.names</div>
<div class="line"><span class="lineno"> 1142</span> </div>
<div class="line"><span class="lineno"> 1143</span>                result = concat(</div>
<div class="line"><span class="lineno"> 1144</span>                    values,</div>
<div class="line"><span class="lineno"> 1145</span>                    axis=self.axis,</div>
<div class="line"><span class="lineno"> 1146</span>                    keys=group_keys,</div>
<div class="line"><span class="lineno"> 1147</span>                    levels=group_levels,</div>
<div class="line"><span class="lineno"> 1148</span>                    names=group_names,</div>
<div class="line"><span class="lineno"> 1149</span>                    sort=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 1150</span>                )</div>
<div class="line"><span class="lineno"> 1151</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1152</span> </div>
<div class="line"><span class="lineno"> 1153</span>                <span class="comment"># GH5610, returns a MI, with the first level being a</span></div>
<div class="line"><span class="lineno"> 1154</span>                <span class="comment"># range index</span></div>
<div class="line"><span class="lineno"> 1155</span>                keys = list(range(len(values)))</div>
<div class="line"><span class="lineno"> 1156</span>                result = concat(values, axis=self.axis, keys=keys)</div>
<div class="line"><span class="lineno"> 1157</span> </div>
<div class="line"><span class="lineno"> 1158</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> not_indexed_same:</div>
<div class="line"><span class="lineno"> 1159</span>            result = concat(values, axis=self.axis)</div>
<div class="line"><span class="lineno"> 1160</span> </div>
<div class="line"><span class="lineno"> 1161</span>            ax = self._selected_obj._get_axis(self.axis)</div>
<div class="line"><span class="lineno"> 1162</span>            <span class="keywordflow">if</span> self.dropna:</div>
<div class="line"><span class="lineno"> 1163</span>                labels = self.grouper.group_info[0]</div>
<div class="line"><span class="lineno"> 1164</span>                mask = labels != -1</div>
<div class="line"><span class="lineno"> 1165</span>                ax = ax[mask]</div>
<div class="line"><span class="lineno"> 1166</span> </div>
<div class="line"><span class="lineno"> 1167</span>            <span class="comment"># this is a very unfortunate situation</span></div>
<div class="line"><span class="lineno"> 1168</span>            <span class="comment"># we can&#39;t use reindex to restore the original order</span></div>
<div class="line"><span class="lineno"> 1169</span>            <span class="comment"># when the ax has duplicates</span></div>
<div class="line"><span class="lineno"> 1170</span>            <span class="comment"># so we resort to this</span></div>
<div class="line"><span class="lineno"> 1171</span>            <span class="comment"># GH 14776, 30667</span></div>
<div class="line"><span class="lineno"> 1172</span>            <span class="keywordflow">if</span> ax.has_duplicates <span class="keywordflow">and</span> <span class="keywordflow">not</span> result.axes[self.axis].equals(ax):</div>
<div class="line"><span class="lineno"> 1173</span>                target = algorithms.unique1d(ax._values)</div>
<div class="line"><span class="lineno"> 1174</span>                indexer, _ = result.index.get_indexer_non_unique(target)</div>
<div class="line"><span class="lineno"> 1175</span>                result = result.take(indexer, axis=self.axis)</div>
<div class="line"><span class="lineno"> 1176</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1177</span>                result = result.reindex(ax, axis=self.axis, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1178</span> </div>
<div class="line"><span class="lineno"> 1179</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1180</span>            values = reset_identity(values)</div>
<div class="line"><span class="lineno"> 1181</span>            result = concat(values, axis=self.axis)</div>
<div class="line"><span class="lineno"> 1182</span> </div>
<div class="line"><span class="lineno"> 1183</span>        name = self.obj.name <span class="keywordflow">if</span> self.obj.ndim == 1 <span class="keywordflow">else</span> self._selection</div>
<div class="line"><span class="lineno"> 1184</span>        <span class="keywordflow">if</span> isinstance(result, Series) <span class="keywordflow">and</span> name <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1185</span> </div>
<div class="line"><span class="lineno"> 1186</span>            result.name = name</div>
<div class="line"><span class="lineno"> 1187</span> </div>
<div class="line"><span class="lineno"> 1188</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1189</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1reshape_1_1concat_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1reshape_1_1concat.html">pandas.core.reshape.concat</a></div><div class="ttdef"><b>Definition</b> concat.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9680888ef1890f81ef62ea64a0df555" name="ab9680888ef1890f81ef62ea64a0df555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9680888ef1890f81ef62ea64a0df555">&#9670;&#160;</a></span>_cumcount_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.groupby.groupby.GroupBy._cumcount_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
ascending : bool, default True
    If False, number in reverse, from length of group - 1 to 0.

Notes
-----
this is currently implementing sort=False
(though the default is sort=True) for groupby in general
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1891</span>    <span class="keyword">def </span>_cumcount_array(self, ascending: bool = <span class="keyword">True</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1892</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">        ascending : bool, default True</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">            If False, number in reverse, from length of group - 1 to 0.</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">        this is currently implementing sort=False</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">        (though the default is sort=True) for groupby in general</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1903</span>        ids, _, ngroups = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 1904</span>        sorter = get_group_index_sorter(ids, ngroups)</div>
<div class="line"><span class="lineno"> 1905</span>        ids, count = ids[sorter], len(ids)</div>
<div class="line"><span class="lineno"> 1906</span> </div>
<div class="line"><span class="lineno"> 1907</span>        <span class="keywordflow">if</span> count == 0:</div>
<div class="line"><span class="lineno"> 1908</span>            <span class="keywordflow">return</span> np.empty(0, dtype=np.int64)</div>
<div class="line"><span class="lineno"> 1909</span> </div>
<div class="line"><span class="lineno"> 1910</span>        run = np.r_[<span class="keyword">True</span>, ids[:-1] != ids[1:]]</div>
<div class="line"><span class="lineno"> 1911</span>        rep = np.diff(np.r_[np.nonzero(run)[0], count])</div>
<div class="line"><span class="lineno"> 1912</span>        out = (~run).cumsum()</div>
<div class="line"><span class="lineno"> 1913</span> </div>
<div class="line"><span class="lineno"> 1914</span>        <span class="keywordflow">if</span> ascending:</div>
<div class="line"><span class="lineno"> 1915</span>            out -= np.repeat(out[run], rep)</div>
<div class="line"><span class="lineno"> 1916</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1917</span>            out = np.repeat(out[np.r_[run[1:], <span class="keyword">True</span>]], rep) - out</div>
<div class="line"><span class="lineno"> 1918</span> </div>
<div class="line"><span class="lineno"> 1919</span>        <span class="keywordflow">if</span> self.grouper.has_dropped_na:</div>
<div class="line"><span class="lineno"> 1920</span>            out = np.where(ids == -1, np.nan, out.astype(np.float64, copy=<span class="keyword">False</span>))</div>
<div class="line"><span class="lineno"> 1921</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1922</span>            out = out.astype(np.int64, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1923</span> </div>
<div class="line"><span class="lineno"> 1924</span>        rev = np.empty(count, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 1925</span>        rev[sorter] = np.arange(count, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 1926</span>        <span class="keywordflow">return</span> out[rev]</div>
<div class="line"><span class="lineno"> 1927</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a64c8a3809df7bb3ba545722053ab4a8b" name="a64c8a3809df7bb3ba545722053ab4a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c8a3809df7bb3ba545722053ab4a8b">&#9670;&#160;</a></span>_cython_agg_general()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._cython_agg_general </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>how</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>alt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault&#160;</td>
          <td class="paramname"><em>numeric_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ignore_failures</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1740</span>    ):</div>
<div class="line"><span class="lineno"> 1741</span>        <span class="comment"># Note: we never get here with how=&quot;ohlc&quot; for DataFrameGroupBy;</span></div>
<div class="line"><span class="lineno"> 1742</span>        <span class="comment">#  that goes through SeriesGroupBy</span></div>
<div class="line"><span class="lineno"> 1743</span>        numeric_only_bool = self._resolve_numeric_only(how, numeric_only, axis=0)</div>
<div class="line"><span class="lineno"> 1744</span> </div>
<div class="line"><span class="lineno"> 1745</span>        data = self._get_data_to_aggregate()</div>
<div class="line"><span class="lineno"> 1746</span>        is_ser = data.ndim == 1</div>
<div class="line"><span class="lineno"> 1747</span> </div>
<div class="line"><span class="lineno"> 1748</span>        orig_len = len(data)</div>
<div class="line"><span class="lineno"> 1749</span>        <span class="keywordflow">if</span> numeric_only_bool:</div>
<div class="line"><span class="lineno"> 1750</span>            <span class="keywordflow">if</span> is_ser <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_numeric_dtype(self._selected_obj.dtype):</div>
<div class="line"><span class="lineno"> 1751</span>                <span class="comment"># GH#41291 match Series behavior</span></div>
<div class="line"><span class="lineno"> 1752</span>                kwd_name = <span class="stringliteral">&quot;numeric_only&quot;</span></div>
<div class="line"><span class="lineno"> 1753</span>                <span class="keywordflow">if</span> how <span class="keywordflow">in</span> [<span class="stringliteral">&quot;any&quot;</span>, <span class="stringliteral">&quot;all&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1754</span>                    kwd_name = <span class="stringliteral">&quot;bool_only&quot;</span></div>
<div class="line"><span class="lineno"> 1755</span>                <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 1756</span>                    f<span class="stringliteral">&quot;{type(self).__name__}.{how} does not implement {kwd_name}.&quot;</span></div>
<div class="line"><span class="lineno"> 1757</span>                )</div>
<div class="line"><span class="lineno"> 1758</span>            <span class="keywordflow">elif</span> <span class="keywordflow">not</span> is_ser:</div>
<div class="line"><span class="lineno"> 1759</span>                data = data.get_numeric_data(copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1760</span> </div>
<div class="line"><span class="lineno"> 1761</span>        <span class="keyword">def </span>array_func(values: ArrayLike) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 1762</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1763</span>                result = self.grouper._cython_operation(</div>
<div class="line"><span class="lineno"> 1764</span>                    <span class="stringliteral">&quot;aggregate&quot;</span>,</div>
<div class="line"><span class="lineno"> 1765</span>                    values,</div>
<div class="line"><span class="lineno"> 1766</span>                    how,</div>
<div class="line"><span class="lineno"> 1767</span>                    axis=data.ndim - 1,</div>
<div class="line"><span class="lineno"> 1768</span>                    min_count=min_count,</div>
<div class="line"><span class="lineno"> 1769</span>                    **kwargs,</div>
<div class="line"><span class="lineno"> 1770</span>                )</div>
<div class="line"><span class="lineno"> 1771</span>            <span class="keywordflow">except</span> NotImplementedError:</div>
<div class="line"><span class="lineno"> 1772</span>                <span class="comment"># generally if we have numeric_only=False</span></div>
<div class="line"><span class="lineno"> 1773</span>                <span class="comment"># and non-applicable functions</span></div>
<div class="line"><span class="lineno"> 1774</span>                <span class="comment"># try to python agg</span></div>
<div class="line"><span class="lineno"> 1775</span>                <span class="comment"># TODO: shouldn&#39;t min_count matter?</span></div>
<div class="line"><span class="lineno"> 1776</span>                result = self._agg_py_fallback(values, ndim=data.ndim, alt=alt)</div>
<div class="line"><span class="lineno"> 1777</span> </div>
<div class="line"><span class="lineno"> 1778</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1779</span> </div>
<div class="line"><span class="lineno"> 1780</span>        <span class="comment"># TypeError -&gt; we may have an exception in trying to aggregate</span></div>
<div class="line"><span class="lineno"> 1781</span>        <span class="comment">#  continue and exclude the block</span></div>
<div class="line"><span class="lineno"> 1782</span>        new_mgr = data.grouped_reduce(array_func, ignore_failures=ignore_failures)</div>
<div class="line"><span class="lineno"> 1783</span> </div>
<div class="line"><span class="lineno"> 1784</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_ser <span class="keywordflow">and</span> len(new_mgr) &lt; orig_len:</div>
<div class="line"><span class="lineno"> 1785</span>            warn_dropping_nuisance_columns_deprecated(type(self), how, numeric_only)</div>
<div class="line"><span class="lineno"> 1786</span> </div>
<div class="line"><span class="lineno"> 1787</span>        res = self._wrap_agged_manager(new_mgr)</div>
<div class="line"><span class="lineno"> 1788</span>        <span class="keywordflow">if</span> is_ser:</div>
<div class="line"><span class="lineno"> 1789</span>            res.index = self.grouper.result_index</div>
<div class="line"><span class="lineno"> 1790</span>            <span class="keywordflow">return</span> self._reindex_output(res)</div>
<div class="line"><span class="lineno"> 1791</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1792</span>            <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 1793</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac52338f17622f5eb324ce8a654d41901" name="ac52338f17622f5eb324ce8a654d41901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52338f17622f5eb324ce8a654d41901">&#9670;&#160;</a></span>_cython_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._cython_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>how</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_series_group_by.html#ab14620883fafdf312e99f07d1a418bf5">pandas.core.groupby.generic.SeriesGroupBy</a>, and <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_data_frame_group_by.html#adfa82b9f4da62c17acf15a1b45ad606b">pandas.core.groupby.generic.DataFrameGroupBy</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1796</span>    ):</div>
<div class="line"><span class="lineno"> 1797</span>        <span class="keywordflow">raise</span> AbstractMethodError(self)</div>
<div class="line"><span class="lineno"> 1798</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9c7f23ca259094f9058ba1d6bbcfb53" name="ad9c7f23ca259094f9058ba1d6bbcfb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c7f23ca259094f9058ba1d6bbcfb53">&#9670;&#160;</a></span>_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;ffill&quot;, &quot;bfill&quot;]&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Shared function for `pad` and `backfill` to call Cython method.

Parameters
----------
direction : {'ffill', 'bfill'}
    Direction passed to underlying Cython function. `bfill` will cause
    values to be filled backwards. `ffill` and any other values will
    default to a forward fill
limit : int, default None
    Maximum number of consecutive values to fill. If `None`, this
    method will convert to -1 prior to passing to Cython

Returns
-------
`Series` or `DataFrame` with filled values

See Also
--------
pad : Returns Series with minimum number of char in object.
backfill : Backward fill the missing values in the dataset.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2825</span>    <span class="keyword">def </span>_fill(self, direction: Literal[<span class="stringliteral">&quot;ffill&quot;</span>, <span class="stringliteral">&quot;bfill&quot;</span>], limit=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2826</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2827</span><span class="stringliteral">        Shared function for `pad` and `backfill` to call Cython method.</span></div>
<div class="line"><span class="lineno"> 2828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2829</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2830</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2831</span><span class="stringliteral">        direction : {&#39;ffill&#39;, &#39;bfill&#39;}</span></div>
<div class="line"><span class="lineno"> 2832</span><span class="stringliteral">            Direction passed to underlying Cython function. `bfill` will cause</span></div>
<div class="line"><span class="lineno"> 2833</span><span class="stringliteral">            values to be filled backwards. `ffill` and any other values will</span></div>
<div class="line"><span class="lineno"> 2834</span><span class="stringliteral">            default to a forward fill</span></div>
<div class="line"><span class="lineno"> 2835</span><span class="stringliteral">        limit : int, default None</span></div>
<div class="line"><span class="lineno"> 2836</span><span class="stringliteral">            Maximum number of consecutive values to fill. If `None`, this</span></div>
<div class="line"><span class="lineno"> 2837</span><span class="stringliteral">            method will convert to -1 prior to passing to Cython</span></div>
<div class="line"><span class="lineno"> 2838</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2839</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2840</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2841</span><span class="stringliteral">        `Series` or `DataFrame` with filled values</span></div>
<div class="line"><span class="lineno"> 2842</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2843</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2844</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2845</span><span class="stringliteral">        pad : Returns Series with minimum number of char in object.</span></div>
<div class="line"><span class="lineno"> 2846</span><span class="stringliteral">        backfill : Backward fill the missing values in the dataset.</span></div>
<div class="line"><span class="lineno"> 2847</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2848</span>        <span class="comment"># Need int value for Cython</span></div>
<div class="line"><span class="lineno"> 2849</span>        <span class="keywordflow">if</span> limit <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2850</span>            limit = -1</div>
<div class="line"><span class="lineno"> 2851</span> </div>
<div class="line"><span class="lineno"> 2852</span>        ids, _, _ = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 2853</span>        sorted_labels = np.argsort(ids, kind=<span class="stringliteral">&quot;mergesort&quot;</span>).astype(np.intp, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2854</span>        <span class="keywordflow">if</span> direction == <span class="stringliteral">&quot;bfill&quot;</span>:</div>
<div class="line"><span class="lineno"> 2855</span>            sorted_labels = sorted_labels[::-1]</div>
<div class="line"><span class="lineno"> 2856</span> </div>
<div class="line"><span class="lineno"> 2857</span>        col_func = partial(</div>
<div class="line"><span class="lineno"> 2858</span>            libgroupby.group_fillna_indexer,</div>
<div class="line"><span class="lineno"> 2859</span>            labels=ids,</div>
<div class="line"><span class="lineno"> 2860</span>            sorted_labels=sorted_labels,</div>
<div class="line"><span class="lineno"> 2861</span>            direction=direction,</div>
<div class="line"><span class="lineno"> 2862</span>            limit=limit,</div>
<div class="line"><span class="lineno"> 2863</span>            dropna=self.dropna,</div>
<div class="line"><span class="lineno"> 2864</span>        )</div>
<div class="line"><span class="lineno"> 2865</span> </div>
<div class="line"><span class="lineno"> 2866</span>        <span class="keyword">def </span>blk_func(values: ArrayLike) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 2867</span>            mask = isna(values)</div>
<div class="line"><span class="lineno"> 2868</span>            <span class="keywordflow">if</span> values.ndim == 1:</div>
<div class="line"><span class="lineno"> 2869</span>                indexer = np.empty(values.shape, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 2870</span>                col_func(out=indexer, mask=mask)</div>
<div class="line"><span class="lineno"> 2871</span>                <span class="keywordflow">return</span> algorithms.take_nd(values, indexer)</div>
<div class="line"><span class="lineno"> 2872</span> </div>
<div class="line"><span class="lineno"> 2873</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2874</span>                <span class="comment"># We broadcast algorithms.take_nd analogous to</span></div>
<div class="line"><span class="lineno"> 2875</span>                <span class="comment">#  np.take_along_axis</span></div>
<div class="line"><span class="lineno"> 2876</span> </div>
<div class="line"><span class="lineno"> 2877</span>                <span class="comment"># Note: we only get here with backfill/pad,</span></div>
<div class="line"><span class="lineno"> 2878</span>                <span class="comment">#  so if we have a dtype that cannot hold NAs,</span></div>
<div class="line"><span class="lineno"> 2879</span>                <span class="comment">#  then there will be no -1s in indexer, so we can use</span></div>
<div class="line"><span class="lineno"> 2880</span>                <span class="comment">#  the original dtype (no need to ensure_dtype_can_hold_na)</span></div>
<div class="line"><span class="lineno"> 2881</span>                <span class="keywordflow">if</span> isinstance(values, np.ndarray):</div>
<div class="line"><span class="lineno"> 2882</span>                    dtype = values.dtype</div>
<div class="line"><span class="lineno"> 2883</span>                    <span class="keywordflow">if</span> self.grouper.has_dropped_na:</div>
<div class="line"><span class="lineno"> 2884</span>                        <span class="comment"># dropped null groups give rise to nan in the result</span></div>
<div class="line"><span class="lineno"> 2885</span>                        dtype = ensure_dtype_can_hold_na(values.dtype)</div>
<div class="line"><span class="lineno"> 2886</span>                    out = np.empty(values.shape, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2887</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2888</span>                    out = type(values)._empty(values.shape, dtype=values.dtype)</div>
<div class="line"><span class="lineno"> 2889</span> </div>
<div class="line"><span class="lineno"> 2890</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(values)):</div>
<div class="line"><span class="lineno"> 2891</span>                    <span class="comment"># call group_fillna_indexer column-wise</span></div>
<div class="line"><span class="lineno"> 2892</span>                    indexer = np.empty(values.shape[1], dtype=np.intp)</div>
<div class="line"><span class="lineno"> 2893</span>                    col_func(out=indexer, mask=mask[i])</div>
<div class="line"><span class="lineno"> 2894</span>                    out[i, :] = algorithms.take_nd(values[i], indexer)</div>
<div class="line"><span class="lineno"> 2895</span>                <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 2896</span> </div>
<div class="line"><span class="lineno"> 2897</span>        obj = self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 2898</span>        <span class="keywordflow">if</span> self.axis == 1:</div>
<div class="line"><span class="lineno"> 2899</span>            obj = obj.T</div>
<div class="line"><span class="lineno"> 2900</span>        mgr = obj._mgr</div>
<div class="line"><span class="lineno"> 2901</span>        res_mgr = mgr.apply(blk_func)</div>
<div class="line"><span class="lineno"> 2902</span> </div>
<div class="line"><span class="lineno"> 2903</span>        new_obj = obj._constructor(res_mgr)</div>
<div class="line"><span class="lineno"> 2904</span>        <span class="keywordflow">if</span> isinstance(new_obj, Series):</div>
<div class="line"><span class="lineno"> 2905</span>            new_obj.name = obj.name</div>
<div class="line"><span class="lineno"> 2906</span> </div>
<div class="line"><span class="lineno"> 2907</span>        <span class="keywordflow">return</span> self._wrap_transformed_output(new_obj)</div>
<div class="line"><span class="lineno"> 2908</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a72d2fc9b02784da8356e687d0ba74815" name="a72d2fc9b02784da8356e687d0ba74815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d2fc9b02784da8356e687d0ba74815">&#9670;&#160;</a></span>_get_cythonized_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._get_cythonized_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>base_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>cython_dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>needs_counts</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>needs_nullable</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>needs_mask</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pre_processing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>post_processing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get result for Cythonized functions.

Parameters
----------
base_func : callable, Cythonized function to be called
cython_dtype : np.dtype
    Type of the array that will be modified by the Cython call.
numeric_only : bool, default True
    Whether only numeric datatypes should be computed
needs_counts : bool, default False
    Whether the counts should be a part of the Cython call
needs_mask : bool, default False
    Whether boolean mask needs to be part of the Cython call
    signature
needs_nullable : bool, default False
    Whether a bool specifying if the input is nullable is part
    of the Cython call signature
pre_processing : function, default None
    Function to be applied to `values` prior to passing to Cython.
    Function should return a tuple where the first element is the
    values to be passed to Cython and the second element is an optional
    type which the values should be converted to after being returned
    by the Cython operation. This function is also responsible for
    raising a TypeError if the values have an invalid type. Raises
    if `needs_values` is False.
post_processing : function, default None
    Function to be applied to result of Cython function. Should accept
    an array of values as the first argument and type inferences as its
    second argument, i.e. the signature should be
    (ndarray, Type). If `needs_nullable=True`, a third argument should be
    `nullable`, to allow for processing specific to nullable values.
**kwargs : dict
    Extra arguments to be passed back to Cython funcs

Returns
-------
`Series` or `DataFrame`  with filled values
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3721</span>    ):</div>
<div class="line"><span class="lineno"> 3722</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3723</span><span class="stringliteral">        Get result for Cythonized functions.</span></div>
<div class="line"><span class="lineno"> 3724</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3725</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3726</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3727</span><span class="stringliteral">        base_func : callable, Cythonized function to be called</span></div>
<div class="line"><span class="lineno"> 3728</span><span class="stringliteral">        cython_dtype : np.dtype</span></div>
<div class="line"><span class="lineno"> 3729</span><span class="stringliteral">            Type of the array that will be modified by the Cython call.</span></div>
<div class="line"><span class="lineno"> 3730</span><span class="stringliteral">        numeric_only : bool, default True</span></div>
<div class="line"><span class="lineno"> 3731</span><span class="stringliteral">            Whether only numeric datatypes should be computed</span></div>
<div class="line"><span class="lineno"> 3732</span><span class="stringliteral">        needs_counts : bool, default False</span></div>
<div class="line"><span class="lineno"> 3733</span><span class="stringliteral">            Whether the counts should be a part of the Cython call</span></div>
<div class="line"><span class="lineno"> 3734</span><span class="stringliteral">        needs_mask : bool, default False</span></div>
<div class="line"><span class="lineno"> 3735</span><span class="stringliteral">            Whether boolean mask needs to be part of the Cython call</span></div>
<div class="line"><span class="lineno"> 3736</span><span class="stringliteral">            signature</span></div>
<div class="line"><span class="lineno"> 3737</span><span class="stringliteral">        needs_nullable : bool, default False</span></div>
<div class="line"><span class="lineno"> 3738</span><span class="stringliteral">            Whether a bool specifying if the input is nullable is part</span></div>
<div class="line"><span class="lineno"> 3739</span><span class="stringliteral">            of the Cython call signature</span></div>
<div class="line"><span class="lineno"> 3740</span><span class="stringliteral">        pre_processing : function, default None</span></div>
<div class="line"><span class="lineno"> 3741</span><span class="stringliteral">            Function to be applied to `values` prior to passing to Cython.</span></div>
<div class="line"><span class="lineno"> 3742</span><span class="stringliteral">            Function should return a tuple where the first element is the</span></div>
<div class="line"><span class="lineno"> 3743</span><span class="stringliteral">            values to be passed to Cython and the second element is an optional</span></div>
<div class="line"><span class="lineno"> 3744</span><span class="stringliteral">            type which the values should be converted to after being returned</span></div>
<div class="line"><span class="lineno"> 3745</span><span class="stringliteral">            by the Cython operation. This function is also responsible for</span></div>
<div class="line"><span class="lineno"> 3746</span><span class="stringliteral">            raising a TypeError if the values have an invalid type. Raises</span></div>
<div class="line"><span class="lineno"> 3747</span><span class="stringliteral">            if `needs_values` is False.</span></div>
<div class="line"><span class="lineno"> 3748</span><span class="stringliteral">        post_processing : function, default None</span></div>
<div class="line"><span class="lineno"> 3749</span><span class="stringliteral">            Function to be applied to result of Cython function. Should accept</span></div>
<div class="line"><span class="lineno"> 3750</span><span class="stringliteral">            an array of values as the first argument and type inferences as its</span></div>
<div class="line"><span class="lineno"> 3751</span><span class="stringliteral">            second argument, i.e. the signature should be</span></div>
<div class="line"><span class="lineno"> 3752</span><span class="stringliteral">            (ndarray, Type). If `needs_nullable=True`, a third argument should be</span></div>
<div class="line"><span class="lineno"> 3753</span><span class="stringliteral">            `nullable`, to allow for processing specific to nullable values.</span></div>
<div class="line"><span class="lineno"> 3754</span><span class="stringliteral">        **kwargs : dict</span></div>
<div class="line"><span class="lineno"> 3755</span><span class="stringliteral">            Extra arguments to be passed back to Cython funcs</span></div>
<div class="line"><span class="lineno"> 3756</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3757</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3758</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3759</span><span class="stringliteral">        `Series` or `DataFrame`  with filled values</span></div>
<div class="line"><span class="lineno"> 3760</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3761</span>        how = base_func.__name__</div>
<div class="line"><span class="lineno"> 3762</span>        numeric_only_bool = self._resolve_numeric_only(how, numeric_only, axis=0)</div>
<div class="line"><span class="lineno"> 3763</span> </div>
<div class="line"><span class="lineno"> 3764</span>        <span class="keywordflow">if</span> post_processing <span class="keywordflow">and</span> <span class="keywordflow">not</span> callable(post_processing):</div>
<div class="line"><span class="lineno"> 3765</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;post_processing&#39; must be a callable!&quot;</span>)</div>
<div class="line"><span class="lineno"> 3766</span>        <span class="keywordflow">if</span> pre_processing <span class="keywordflow">and</span> <span class="keywordflow">not</span> callable(pre_processing):</div>
<div class="line"><span class="lineno"> 3767</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;pre_processing&#39; must be a callable!&quot;</span>)</div>
<div class="line"><span class="lineno"> 3768</span> </div>
<div class="line"><span class="lineno"> 3769</span>        grouper = self.grouper</div>
<div class="line"><span class="lineno"> 3770</span> </div>
<div class="line"><span class="lineno"> 3771</span>        ids, _, ngroups = grouper.group_info</div>
<div class="line"><span class="lineno"> 3772</span> </div>
<div class="line"><span class="lineno"> 3773</span>        base_func = partial(base_func, labels=ids)</div>
<div class="line"><span class="lineno"> 3774</span> </div>
<div class="line"><span class="lineno"> 3775</span>        <span class="keyword">def </span>blk_func(values: ArrayLike) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 3776</span>            values = values.T</div>
<div class="line"><span class="lineno"> 3777</span>            ncols = 1 <span class="keywordflow">if</span> values.ndim == 1 <span class="keywordflow">else</span> values.shape[1]</div>
<div class="line"><span class="lineno"> 3778</span> </div>
<div class="line"><span class="lineno"> 3779</span>            result: ArrayLike</div>
<div class="line"><span class="lineno"> 3780</span>            result = np.zeros(ngroups * ncols, dtype=cython_dtype)</div>
<div class="line"><span class="lineno"> 3781</span>            result = result.reshape((ngroups, ncols))</div>
<div class="line"><span class="lineno"> 3782</span> </div>
<div class="line"><span class="lineno"> 3783</span>            func = partial(base_func, out=result)</div>
<div class="line"><span class="lineno"> 3784</span> </div>
<div class="line"><span class="lineno"> 3785</span>            inferences = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3786</span> </div>
<div class="line"><span class="lineno"> 3787</span>            <span class="keywordflow">if</span> needs_counts:</div>
<div class="line"><span class="lineno"> 3788</span>                counts = np.zeros(self.ngroups, dtype=np.int64)</div>
<div class="line"><span class="lineno"> 3789</span>                func = partial(func, counts=counts)</div>
<div class="line"><span class="lineno"> 3790</span> </div>
<div class="line"><span class="lineno"> 3791</span>            vals = values</div>
<div class="line"><span class="lineno"> 3792</span>            <span class="keywordflow">if</span> pre_processing:</div>
<div class="line"><span class="lineno"> 3793</span>                vals, inferences = pre_processing(vals)</div>
<div class="line"><span class="lineno"> 3794</span> </div>
<div class="line"><span class="lineno"> 3795</span>            vals = vals.astype(cython_dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3796</span>            <span class="keywordflow">if</span> vals.ndim == 1:</div>
<div class="line"><span class="lineno"> 3797</span>                vals = vals.reshape((-1, 1))</div>
<div class="line"><span class="lineno"> 3798</span>            func = partial(func, values=vals)</div>
<div class="line"><span class="lineno"> 3799</span> </div>
<div class="line"><span class="lineno"> 3800</span>            <span class="keywordflow">if</span> needs_mask:</div>
<div class="line"><span class="lineno"> 3801</span>                mask = isna(values).view(np.uint8)</div>
<div class="line"><span class="lineno"> 3802</span>                <span class="keywordflow">if</span> mask.ndim == 1:</div>
<div class="line"><span class="lineno"> 3803</span>                    mask = mask.reshape(-1, 1)</div>
<div class="line"><span class="lineno"> 3804</span>                func = partial(func, mask=mask)</div>
<div class="line"><span class="lineno"> 3805</span> </div>
<div class="line"><span class="lineno"> 3806</span>            <span class="keywordflow">if</span> needs_nullable:</div>
<div class="line"><span class="lineno"> 3807</span>                is_nullable = isinstance(values, BaseMaskedArray)</div>
<div class="line"><span class="lineno"> 3808</span>                func = partial(func, nullable=is_nullable)</div>
<div class="line"><span class="lineno"> 3809</span> </div>
<div class="line"><span class="lineno"> 3810</span>            <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(**kwargs)  <span class="comment"># Call func to modify indexer values in place</span></div>
<div class="line"><span class="lineno"> 3811</span> </div>
<div class="line"><span class="lineno"> 3812</span>            <span class="keywordflow">if</span> values.ndim == 1:</div>
<div class="line"><span class="lineno"> 3813</span>                <span class="keyword">assert</span> result.shape[1] == 1, result.shape</div>
<div class="line"><span class="lineno"> 3814</span>                result = result[:, 0]</div>
<div class="line"><span class="lineno"> 3815</span> </div>
<div class="line"><span class="lineno"> 3816</span>            <span class="keywordflow">if</span> post_processing:</div>
<div class="line"><span class="lineno"> 3817</span>                pp_kwargs = {}</div>
<div class="line"><span class="lineno"> 3818</span>                <span class="keywordflow">if</span> needs_nullable:</div>
<div class="line"><span class="lineno"> 3819</span>                    pp_kwargs[<span class="stringliteral">&quot;nullable&quot;</span>] = isinstance(values, BaseMaskedArray)</div>
<div class="line"><span class="lineno"> 3820</span> </div>
<div class="line"><span class="lineno"> 3821</span>                result = post_processing(result, inferences, **pp_kwargs)</div>
<div class="line"><span class="lineno"> 3822</span> </div>
<div class="line"><span class="lineno"> 3823</span>            <span class="keywordflow">return</span> result.T</div>
<div class="line"><span class="lineno"> 3824</span> </div>
<div class="line"><span class="lineno"> 3825</span>        obj = self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 3826</span> </div>
<div class="line"><span class="lineno"> 3827</span>        <span class="comment"># Operate block-wise instead of column-by-column</span></div>
<div class="line"><span class="lineno"> 3828</span>        is_ser = obj.ndim == 1</div>
<div class="line"><span class="lineno"> 3829</span>        mgr = self._get_data_to_aggregate()</div>
<div class="line"><span class="lineno"> 3830</span>        orig_mgr_len = len(mgr)</div>
<div class="line"><span class="lineno"> 3831</span> </div>
<div class="line"><span class="lineno"> 3832</span>        <span class="keywordflow">if</span> numeric_only_bool:</div>
<div class="line"><span class="lineno"> 3833</span>            mgr = mgr.get_numeric_data()</div>
<div class="line"><span class="lineno"> 3834</span> </div>
<div class="line"><span class="lineno"> 3835</span>        res_mgr = mgr.grouped_reduce(blk_func, ignore_failures=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3836</span> </div>
<div class="line"><span class="lineno"> 3837</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_ser <span class="keywordflow">and</span> len(res_mgr.items) != orig_mgr_len:</div>
<div class="line"><span class="lineno"> 3838</span>            howstr = how.replace(<span class="stringliteral">&quot;group_&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno"> 3839</span>            warn_dropping_nuisance_columns_deprecated(type(self), howstr, numeric_only)</div>
<div class="line"><span class="lineno"> 3840</span> </div>
<div class="line"><span class="lineno"> 3841</span>            <span class="keywordflow">if</span> len(res_mgr.items) == 0:</div>
<div class="line"><span class="lineno"> 3842</span>                <span class="comment"># We re-call grouped_reduce to get the right exception message</span></div>
<div class="line"><span class="lineno"> 3843</span>                mgr.grouped_reduce(blk_func, ignore_failures=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3844</span>                <span class="comment"># grouped_reduce _should_ raise, so this should not be reached</span></div>
<div class="line"><span class="lineno"> 3845</span>                <span class="keywordflow">raise</span> TypeError(  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno"> 3846</span>                    <span class="stringliteral">&quot;All columns were dropped in grouped_reduce&quot;</span></div>
<div class="line"><span class="lineno"> 3847</span>                )</div>
<div class="line"><span class="lineno"> 3848</span> </div>
<div class="line"><span class="lineno"> 3849</span>        <span class="keywordflow">if</span> is_ser:</div>
<div class="line"><span class="lineno"> 3850</span>            out = self._wrap_agged_manager(res_mgr)</div>
<div class="line"><span class="lineno"> 3851</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3852</span>            out = obj._constructor(res_mgr)</div>
<div class="line"><span class="lineno"> 3853</span> </div>
<div class="line"><span class="lineno"> 3854</span>        <span class="keywordflow">return</span> self._wrap_aggregated_output(out)</div>
<div class="line"><span class="lineno"> 3855</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a61f8512420b9ff6a6542e8486ffa34fb" name="a61f8512420b9ff6a6542e8486ffa34fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f8512420b9ff6a6542e8486ffa34fb">&#9670;&#160;</a></span>_group_selection_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[<a class="el" href="classpandas_1_1core_1_1groupby_1_1groupby_1_1_group_by.html">GroupBy</a>] pandas.core.groupby.groupby.GroupBy._group_selection_context </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Set / reset the _group_selection_context.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1100</span>    <span class="keyword">def </span>_group_selection_context(self) -&gt; Iterator[GroupBy]:</div>
<div class="line"><span class="lineno"> 1101</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">        Set / reset the _group_selection_context.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1104</span>        self._set_group_selection()</div>
<div class="line"><span class="lineno"> 1105</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1106</span>            <span class="keywordflow">yield</span> self</div>
<div class="line"><span class="lineno"> 1107</span>        <span class="keywordflow">finally</span>:</div>
<div class="line"><span class="lineno"> 1108</span>            self._reset_group_selection()</div>
<div class="line"><span class="lineno"> 1109</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a30d6aef348ced9cc5cab50928b4315f7" name="a30d6aef348ced9cc5cab50928b4315f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d6aef348ced9cc5cab50928b4315f7">&#9670;&#160;</a></span>_indexed_output_to_ndframe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> | <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.core.groupby.groupby.GroupBy._indexed_output_to_ndframe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[<a class="el" href="classpandas_1_1core_1_1groupby_1_1base_1_1_output_key.html">base.OutputKey</a>, ArrayLike]
    &#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_series_group_by.html#afd43600eee6245b277fe00737017b00d">pandas.core.groupby.generic.SeriesGroupBy</a>, and <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_data_frame_group_by.html#ab7fc73de6ae861946e81ca561ac0b754">pandas.core.groupby.generic.DataFrameGroupBy</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1218</span>    ) -&gt; Series | DataFrame:</div>
<div class="line"><span class="lineno"> 1219</span>        <span class="keywordflow">raise</span> AbstractMethodError(self)</div>
<div class="line"><span class="lineno"> 1220</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a831f287a1285ba7913d7586ba7688aba" name="a831f287a1285ba7913d7586ba7688aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831f287a1285ba7913d7586ba7688aba">&#9670;&#160;</a></span>_iterate_slices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Iterable[<a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>] pandas.core.groupby.groupby.GroupBy._iterate_slices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_series_group_by.html#a6f2cdbb589a34660331c452a54325363">pandas.core.groupby.generic.SeriesGroupBy</a>, and <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_data_frame_group_by.html#a61d4695654415335ab0a1e389e7e2947">pandas.core.groupby.generic.DataFrameGroupBy</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1110</span>    <span class="keyword">def </span>_iterate_slices(self) -&gt; Iterable[Series]:</div>
<div class="line"><span class="lineno"> 1111</span>        <span class="keywordflow">raise</span> AbstractMethodError(self)</div>
<div class="line"><span class="lineno"> 1112</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b9f732b71012fa0bb8536d92a4a9a58" name="a8b9f732b71012fa0bb8536d92a4a9a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9f732b71012fa0bb8536d92a4a9a58">&#9670;&#160;</a></span>_make_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Callable pandas.core.groupby.groupby.GroupBy._make_wrapper </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  986</span>    <span class="keyword">def </span>_make_wrapper(self, name: str) -&gt; Callable:</div>
<div class="line"><span class="lineno">  987</span>        <span class="keyword">assert</span> name <span class="keywordflow">in</span> self._apply_allowlist</div>
<div class="line"><span class="lineno">  988</span> </div>
<div class="line"><span class="lineno">  989</span>        <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno">  990</span>            <span class="comment"># need to setup the selection</span></div>
<div class="line"><span class="lineno">  991</span>            <span class="comment"># as are not passed directly but in the grouper</span></div>
<div class="line"><span class="lineno">  992</span>            f = getattr(self._obj_with_exclusions, name)</div>
<div class="line"><span class="lineno">  993</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(f, types.MethodType):</div>
<div class="line"><span class="lineno">  994</span>                <span class="comment">#  error: Incompatible return value type</span></div>
<div class="line"><span class="lineno">  995</span>                <span class="comment"># (got &quot;NDFrameT&quot;, expected &quot;Callable[..., Any]&quot;)  [return-value]</span></div>
<div class="line"><span class="lineno">  996</span>                <span class="keywordflow">return</span> cast(Callable, self.apply(<span class="keyword">lambda</span> self: getattr(self, name)))</div>
<div class="line"><span class="lineno">  997</span> </div>
<div class="line"><span class="lineno">  998</span>        f = getattr(type(self._obj_with_exclusions), name)</div>
<div class="line"><span class="lineno">  999</span>        sig = inspect.signature(f)</div>
<div class="line"><span class="lineno"> 1000</span> </div>
<div class="line"><span class="lineno"> 1001</span>        <span class="keyword">def </span>wrapper(*args, **kwargs):</div>
<div class="line"><span class="lineno"> 1002</span>            <span class="comment"># a little trickery for aggregation functions that need an axis</span></div>
<div class="line"><span class="lineno"> 1003</span>            <span class="comment"># argument</span></div>
<div class="line"><span class="lineno"> 1004</span>            <span class="keywordflow">if</span> <span class="stringliteral">&quot;axis&quot;</span> <span class="keywordflow">in</span> sig.parameters:</div>
<div class="line"><span class="lineno"> 1005</span>                <span class="keywordflow">if</span> kwargs.get(<span class="stringliteral">&quot;axis&quot;</span>, <span class="keywordtype">None</span>) <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1006</span>                    kwargs[<span class="stringliteral">&quot;axis&quot;</span>] = self.axis</div>
<div class="line"><span class="lineno"> 1007</span> </div>
<div class="line"><span class="lineno"> 1008</span>            numeric_only = kwargs.get(<span class="stringliteral">&quot;numeric_only&quot;</span>, lib.no_default)</div>
<div class="line"><span class="lineno"> 1009</span> </div>
<div class="line"><span class="lineno"> 1010</span>            <span class="keyword">def </span>curried(x):</div>
<div class="line"><span class="lineno"> 1011</span>                <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno"> 1012</span>                    <span class="comment"># Catch any warnings from dispatch to DataFrame; we&#39;ll emit</span></div>
<div class="line"><span class="lineno"> 1013</span>                    <span class="comment"># a warning for groupby below</span></div>
<div class="line"><span class="lineno"> 1014</span>                    match = <span class="stringliteral">&quot;The default value of numeric_only &quot;</span></div>
<div class="line"><span class="lineno"> 1015</span>                    warnings.filterwarnings(<span class="stringliteral">&quot;ignore&quot;</span>, match, FutureWarning)</div>
<div class="line"><span class="lineno"> 1016</span>                    <span class="keywordflow">return</span> <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(x, *args, **kwargs)</div>
<div class="line"><span class="lineno"> 1017</span> </div>
<div class="line"><span class="lineno"> 1018</span>            <span class="comment"># preserve the name so we can detect it when calling plot methods,</span></div>
<div class="line"><span class="lineno"> 1019</span>            <span class="comment"># to avoid duplicates</span></div>
<div class="line"><span class="lineno"> 1020</span>            curried.__name__ = name</div>
<div class="line"><span class="lineno"> 1021</span> </div>
<div class="line"><span class="lineno"> 1022</span>            <span class="comment"># special case otherwise extra plots are created when catching the</span></div>
<div class="line"><span class="lineno"> 1023</span>            <span class="comment"># exception below</span></div>
<div class="line"><span class="lineno"> 1024</span>            <span class="keywordflow">if</span> name <span class="keywordflow">in</span> base.plotting_methods:</div>
<div class="line"><span class="lineno"> 1025</span>                <span class="keywordflow">return</span> self.apply(curried)</div>
<div class="line"><span class="lineno"> 1026</span> </div>
<div class="line"><span class="lineno"> 1027</span>            is_transform = name <span class="keywordflow">in</span> base.transformation_kernels</div>
<div class="line"><span class="lineno"> 1028</span> </div>
<div class="line"><span class="lineno"> 1029</span>            <span class="comment"># Transform needs to keep the same schema, including when empty</span></div>
<div class="line"><span class="lineno"> 1030</span>            <span class="keywordflow">if</span> is_transform <span class="keywordflow">and</span> self._obj_with_exclusions.empty:</div>
<div class="line"><span class="lineno"> 1031</span>                <span class="keywordflow">return</span> self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 1032</span> </div>
<div class="line"><span class="lineno"> 1033</span>            result = self._python_apply_general(</div>
<div class="line"><span class="lineno"> 1034</span>                curried,</div>
<div class="line"><span class="lineno"> 1035</span>                self._obj_with_exclusions,</div>
<div class="line"><span class="lineno"> 1036</span>                is_transform=is_transform,</div>
<div class="line"><span class="lineno"> 1037</span>                not_indexed_same=<span class="keywordflow">not</span> is_transform,</div>
<div class="line"><span class="lineno"> 1038</span>            )</div>
<div class="line"><span class="lineno"> 1039</span> </div>
<div class="line"><span class="lineno"> 1040</span>            <span class="keywordflow">if</span> self._selected_obj.ndim != 1 <span class="keywordflow">and</span> self.axis != 1 <span class="keywordflow">and</span> result.ndim != 1:</div>
<div class="line"><span class="lineno"> 1041</span>                missing = self._obj_with_exclusions.columns.difference(result.columns)</div>
<div class="line"><span class="lineno"> 1042</span>                <span class="keywordflow">if</span> len(missing) &gt; 0:</div>
<div class="line"><span class="lineno"> 1043</span>                    warn_dropping_nuisance_columns_deprecated(</div>
<div class="line"><span class="lineno"> 1044</span>                        type(self), name, numeric_only</div>
<div class="line"><span class="lineno"> 1045</span>                    )</div>
<div class="line"><span class="lineno"> 1046</span> </div>
<div class="line"><span class="lineno"> 1047</span>            <span class="keywordflow">if</span> self.grouper.has_dropped_na <span class="keywordflow">and</span> is_transform:</div>
<div class="line"><span class="lineno"> 1048</span>                <span class="comment"># result will have dropped rows due to nans, fill with null</span></div>
<div class="line"><span class="lineno"> 1049</span>                <span class="comment"># and ensure index is ordered same as the input</span></div>
<div class="line"><span class="lineno"> 1050</span>                result = self._set_result_index_ordered(result)</div>
<div class="line"><span class="lineno"> 1051</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1052</span> </div>
<div class="line"><span class="lineno"> 1053</span>        wrapper.__name__ = name</div>
<div class="line"><span class="lineno"> 1054</span>        <span class="keywordflow">return</span> wrapper</div>
<div class="line"><span class="lineno"> 1055</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_af01a903df7bdb7a494f5827e45bf3a2a"><div class="ttname"><a href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a></div><div class="ttdeci">void int int int int npy_complex64 int int npy_complex64 float float npy_complex64 npy_complex64 * f</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:262</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae444b9f5016c2439cf1662f905d66d64" name="ae444b9f5016c2439cf1662f905d66d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae444b9f5016c2439cf1662f905d66d64">&#9670;&#160;</a></span>_mask_selected_obj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy._mask_selected_obj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_]&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return _selected_obj with mask applied to the correct axis.

Parameters
----------
mask : np.ndarray[bool]
    Boolean mask to apply.

Returns
-------
Series or DataFrame
    Filtered _selected_obj.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4063</span>    <span class="keyword">def </span>_mask_selected_obj(self, mask: npt.NDArray[np.bool_]) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 4064</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4065</span><span class="stringliteral">        Return _selected_obj with mask applied to the correct axis.</span></div>
<div class="line"><span class="lineno"> 4066</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4067</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4068</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4069</span><span class="stringliteral">        mask : np.ndarray[bool]</span></div>
<div class="line"><span class="lineno"> 4070</span><span class="stringliteral">            Boolean mask to apply.</span></div>
<div class="line"><span class="lineno"> 4071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4072</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 4073</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 4074</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 4075</span><span class="stringliteral">            Filtered _selected_obj.</span></div>
<div class="line"><span class="lineno"> 4076</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4077</span>        ids = self.grouper.group_info[0]</div>
<div class="line"><span class="lineno"> 4078</span>        mask = mask &amp; (ids != -1)</div>
<div class="line"><span class="lineno"> 4079</span> </div>
<div class="line"><span class="lineno"> 4080</span>        <span class="keywordflow">if</span> self.axis == 0:</div>
<div class="line"><span class="lineno"> 4081</span>            <span class="keywordflow">return</span> self._selected_obj[mask]</div>
<div class="line"><span class="lineno"> 4082</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4083</span>            <span class="keywordflow">return</span> self._selected_obj.iloc[:, mask]</div>
<div class="line"><span class="lineno"> 4084</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acdb36b34707fadb002e190330665c619" name="acdb36b34707fadb002e190330665c619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb36b34707fadb002e190330665c619">&#9670;&#160;</a></span>_maybe_warn_numeric_only_depr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.groupby.groupby.GroupBy._maybe_warn_numeric_only_depr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>how</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> | <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault
    &#160;</td>
          <td class="paramname"><em>numeric_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Emit warning on numeric_only behavior deprecation when appropriate.

Parameters
----------
how : str
    Groupby kernel name.
result :
    Result of the groupby operation.
numeric_only : bool or lib.no_default
    Argument as passed by user.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1370</span>    ) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1371</span>        <span class="stringliteral">&quot;&quot;&quot;Emit warning on numeric_only behavior deprecation when appropriate.</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">        how : str</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">            Groupby kernel name.</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">        result :</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">            Result of the groupby operation.</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">        numeric_only : bool or lib.no_default</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">            Argument as passed by user.</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1382</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 1383</span>            self._obj_with_exclusions.ndim != 1</div>
<div class="line"><span class="lineno"> 1384</span>            <span class="keywordflow">and</span> result.ndim &gt; 1</div>
<div class="line"><span class="lineno"> 1385</span>            <span class="keywordflow">and</span> len(result.columns) &lt; len(self._obj_with_exclusions.columns)</div>
<div class="line"><span class="lineno"> 1386</span>        ):</div>
<div class="line"><span class="lineno"> 1387</span>            warn_dropping_nuisance_columns_deprecated(type(self), how, numeric_only)</div>
<div class="line"><span class="lineno"> 1388</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d39b4286e3f16112113159820c2d471" name="a8d39b4286e3f16112113159820c2d471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d39b4286e3f16112113159820c2d471">&#9670;&#160;</a></span>_nth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy._nth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PositionalIndexer | tuple&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;any&quot;, &quot;all&quot;, None] &#160;</td>
          <td class="paramname"><em>dropna</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3124</span>    ) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3125</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> dropna:</div>
<div class="line"><span class="lineno"> 3126</span>            <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 3127</span>                mask = self._make_mask_from_positional_indexer(n)</div>
<div class="line"><span class="lineno"> 3128</span> </div>
<div class="line"><span class="lineno"> 3129</span>                ids, _, _ = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 3130</span> </div>
<div class="line"><span class="lineno"> 3131</span>                <span class="comment"># Drop NA values in grouping</span></div>
<div class="line"><span class="lineno"> 3132</span>                mask = mask &amp; (ids != -1)</div>
<div class="line"><span class="lineno"> 3133</span> </div>
<div class="line"><span class="lineno"> 3134</span>                out = self._mask_selected_obj(mask)</div>
<div class="line"><span class="lineno"> 3135</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.as_index:</div>
<div class="line"><span class="lineno"> 3136</span>                    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 3137</span> </div>
<div class="line"><span class="lineno"> 3138</span>                result_index = self.grouper.result_index</div>
<div class="line"><span class="lineno"> 3139</span>                <span class="keywordflow">if</span> self.axis == 0:</div>
<div class="line"><span class="lineno"> 3140</span>                    out.index = result_index[ids[mask]]</div>
<div class="line"><span class="lineno"> 3141</span>                    <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.observed <span class="keywordflow">and</span> isinstance(result_index, CategoricalIndex):</div>
<div class="line"><span class="lineno"> 3142</span>                        out = out.reindex(result_index)</div>
<div class="line"><span class="lineno"> 3143</span> </div>
<div class="line"><span class="lineno"> 3144</span>                    out = self._reindex_output(out)</div>
<div class="line"><span class="lineno"> 3145</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3146</span>                    out.columns = result_index[ids[mask]]</div>
<div class="line"><span class="lineno"> 3147</span> </div>
<div class="line"><span class="lineno"> 3148</span>                <span class="keywordflow">return</span> out.sort_index(axis=self.axis) <span class="keywordflow">if</span> self.sort <span class="keywordflow">else</span> out</div>
<div class="line"><span class="lineno"> 3149</span> </div>
<div class="line"><span class="lineno"> 3150</span>        <span class="comment"># dropna is truthy</span></div>
<div class="line"><span class="lineno"> 3151</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_integer(n):</div>
<div class="line"><span class="lineno"> 3152</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;dropna option only supported for an integer argument&quot;</span>)</div>
<div class="line"><span class="lineno"> 3153</span> </div>
<div class="line"><span class="lineno"> 3154</span>        <span class="keywordflow">if</span> dropna <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;any&quot;</span>, <span class="stringliteral">&quot;all&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3155</span>            <span class="comment"># Note: when agg-ing picker doesn&#39;t raise this, just returns NaN</span></div>
<div class="line"><span class="lineno"> 3156</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3157</span>                <span class="stringliteral">&quot;For a DataFrame or Series groupby.nth, dropna must be &quot;</span></div>
<div class="line"><span class="lineno"> 3158</span>                <span class="stringliteral">&quot;either None, &#39;any&#39; or &#39;all&#39;, &quot;</span></div>
<div class="line"><span class="lineno"> 3159</span>                f<span class="stringliteral">&quot;(was passed {dropna}).&quot;</span></div>
<div class="line"><span class="lineno"> 3160</span>            )</div>
<div class="line"><span class="lineno"> 3161</span> </div>
<div class="line"><span class="lineno"> 3162</span>        <span class="comment"># old behaviour, but with all and any support for DataFrames.</span></div>
<div class="line"><span class="lineno"> 3163</span>        <span class="comment"># modified in GH 7559 to have better perf</span></div>
<div class="line"><span class="lineno"> 3164</span>        n = cast(int, n)</div>
<div class="line"><span class="lineno"> 3165</span>        max_len = n <span class="keywordflow">if</span> n &gt;= 0 <span class="keywordflow">else</span> -1 - n</div>
<div class="line"><span class="lineno"> 3166</span>        dropped = self.obj.dropna(how=dropna, axis=self.axis)</div>
<div class="line"><span class="lineno"> 3167</span> </div>
<div class="line"><span class="lineno"> 3168</span>        <span class="comment"># get a new grouper for our dropped obj</span></div>
<div class="line"><span class="lineno"> 3169</span>        <span class="keywordflow">if</span> self.keys <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> self.level <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3170</span> </div>
<div class="line"><span class="lineno"> 3171</span>            <span class="comment"># we don&#39;t have the grouper info available</span></div>
<div class="line"><span class="lineno"> 3172</span>            <span class="comment"># (e.g. we have selected out</span></div>
<div class="line"><span class="lineno"> 3173</span>            <span class="comment"># a column that is not in the current object)</span></div>
<div class="line"><span class="lineno"> 3174</span>            axis = self.grouper.axis</div>
<div class="line"><span class="lineno"> 3175</span>            grouper = axis[axis.isin(dropped.index)]</div>
<div class="line"><span class="lineno"> 3176</span> </div>
<div class="line"><span class="lineno"> 3177</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3178</span> </div>
<div class="line"><span class="lineno"> 3179</span>            <span class="comment"># create a grouper with the original parameters, but on dropped</span></div>
<div class="line"><span class="lineno"> 3180</span>            <span class="comment"># object</span></div>
<div class="line"><span class="lineno"> 3181</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1groupby_1_1grouper.html">pandas.core.groupby.grouper</a> <span class="keyword">import</span> get_grouper</div>
<div class="line"><span class="lineno"> 3182</span> </div>
<div class="line"><span class="lineno"> 3183</span>            grouper, _, _ = get_grouper(</div>
<div class="line"><span class="lineno"> 3184</span>                dropped,</div>
<div class="line"><span class="lineno"> 3185</span>                key=self.keys,</div>
<div class="line"><span class="lineno"> 3186</span>                axis=self.axis,</div>
<div class="line"><span class="lineno"> 3187</span>                level=self.level,</div>
<div class="line"><span class="lineno"> 3188</span>                sort=self.sort,</div>
<div class="line"><span class="lineno"> 3189</span>                mutated=self.mutated,</div>
<div class="line"><span class="lineno"> 3190</span>            )</div>
<div class="line"><span class="lineno"> 3191</span> </div>
<div class="line"><span class="lineno"> 3192</span>        grb = dropped.groupby(</div>
<div class="line"><span class="lineno"> 3193</span>            grouper, as_index=self.as_index, sort=self.sort, axis=self.axis</div>
<div class="line"><span class="lineno"> 3194</span>        )</div>
<div class="line"><span class="lineno"> 3195</span>        sizes, result = grb.size(), grb.nth(n)</div>
<div class="line"><span class="lineno"> 3196</span>        mask = (sizes &lt; max_len)._values</div>
<div class="line"><span class="lineno"> 3197</span> </div>
<div class="line"><span class="lineno"> 3198</span>        <span class="comment"># set the results which don&#39;t meet the criteria</span></div>
<div class="line"><span class="lineno"> 3199</span>        <span class="keywordflow">if</span> len(result) <span class="keywordflow">and</span> mask.any():</div>
<div class="line"><span class="lineno"> 3200</span>            result.loc[mask] = np.nan</div>
<div class="line"><span class="lineno"> 3201</span> </div>
<div class="line"><span class="lineno"> 3202</span>        <span class="comment"># reset/reindex to the original groups</span></div>
<div class="line"><span class="lineno"> 3203</span>        <span class="keywordflow">if</span> len(self.obj) == len(dropped) <span class="keywordflow">or</span> len(result) == len(</div>
<div class="line"><span class="lineno"> 3204</span>            self.grouper.result_index</div>
<div class="line"><span class="lineno"> 3205</span>        ):</div>
<div class="line"><span class="lineno"> 3206</span>            result.index = self.grouper.result_index</div>
<div class="line"><span class="lineno"> 3207</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3208</span>            result = result.reindex(self.grouper.result_index)</div>
<div class="line"><span class="lineno"> 3209</span> </div>
<div class="line"><span class="lineno"> 3210</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3211</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ec4b2be84825263fb17a1ca2ac56baa" name="a4ec4b2be84825263fb17a1ca2ac56baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec4b2be84825263fb17a1ca2ac56baa">&#9670;&#160;</a></span>_numba_agg_general()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._numba_agg_general </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, bool] | None&#160;</td>
          <td class="paramname"><em>engine_kwargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>aggregator_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Perform groupby with a standard numerical aggregation function (e.g. mean)
with Numba.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1423</span>    ):</div>
<div class="line"><span class="lineno"> 1424</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral">        Perform groupby with a standard numerical aggregation function (e.g. mean)</span></div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">        with Numba.</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1428</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.as_index:</div>
<div class="line"><span class="lineno"> 1429</span>            <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 1430</span>                <span class="stringliteral">&quot;as_index=False is not supported. Use .reset_index() instead.&quot;</span></div>
<div class="line"><span class="lineno"> 1431</span>            )</div>
<div class="line"><span class="lineno"> 1432</span>        <span class="keywordflow">if</span> self.axis == 1:</div>
<div class="line"><span class="lineno"> 1433</span>            <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;axis=1 is not supported.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1434</span> </div>
<div class="line"><span class="lineno"> 1435</span>        <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 1436</span>            data = self._selected_obj</div>
<div class="line"><span class="lineno"> 1437</span>        df = data <span class="keywordflow">if</span> data.ndim == 2 <span class="keywordflow">else</span> data.to_frame()</div>
<div class="line"><span class="lineno"> 1438</span>        starts, ends, sorted_index, sorted_data = self._numba_prep(df)</div>
<div class="line"><span class="lineno"> 1439</span>        aggregator = executor.generate_shared_aggregator(</div>
<div class="line"><span class="lineno"> 1440</span>            func, **get_jit_arguments(engine_kwargs)</div>
<div class="line"><span class="lineno"> 1441</span>        )</div>
<div class="line"><span class="lineno"> 1442</span>        result = aggregator(sorted_data, starts, ends, 0, *aggregator_args)</div>
<div class="line"><span class="lineno"> 1443</span> </div>
<div class="line"><span class="lineno"> 1444</span>        index = self.grouper.result_index</div>
<div class="line"><span class="lineno"> 1445</span>        <span class="keywordflow">if</span> data.ndim == 1:</div>
<div class="line"><span class="lineno"> 1446</span>            result_kwargs = {<span class="stringliteral">&quot;name&quot;</span>: data.name}</div>
<div class="line"><span class="lineno"> 1447</span>            result = result.ravel()</div>
<div class="line"><span class="lineno"> 1448</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1449</span>            result_kwargs = {<span class="stringliteral">&quot;columns&quot;</span>: data.columns}</div>
<div class="line"><span class="lineno"> 1450</span>        <span class="keywordflow">return</span> data._constructor(result, index=index, **result_kwargs)</div>
<div class="line"><span class="lineno"> 1451</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4addbd51bc8d613fae2841d94c27d295" name="a4addbd51bc8d613fae2841d94c27d295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4addbd51bc8d613fae2841d94c27d295">&#9670;&#160;</a></span>_numba_prep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._numba_prep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1393</span>    <span class="keyword">def </span>_numba_prep(self, data):</div>
<div class="line"><span class="lineno"> 1394</span>        ids, _, ngroups = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 1395</span>        sorted_index = get_group_index_sorter(ids, ngroups)</div>
<div class="line"><span class="lineno"> 1396</span>        sorted_ids = algorithms.take_nd(ids, sorted_index, allow_fill=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1397</span> </div>
<div class="line"><span class="lineno"> 1398</span>        sorted_data = data.take(sorted_index, axis=self.axis).to_numpy()</div>
<div class="line"><span class="lineno"> 1399</span>        <span class="keywordflow">if</span> len(self.grouper.groupings) &gt; 1:</div>
<div class="line"><span class="lineno"> 1400</span>            <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 1401</span>                <span class="stringliteral">&quot;More than 1 grouping labels are not supported with engine=&#39;numba&#39;&quot;</span></div>
<div class="line"><span class="lineno"> 1402</span>            )</div>
<div class="line"><span class="lineno"> 1403</span>        <span class="comment"># GH 46867</span></div>
<div class="line"><span class="lineno"> 1404</span>        index_data = data.index</div>
<div class="line"><span class="lineno"> 1405</span>        <span class="keywordflow">if</span> isinstance(index_data, MultiIndex):</div>
<div class="line"><span class="lineno"> 1406</span>            group_key = self.grouper.groupings[0].name</div>
<div class="line"><span class="lineno"> 1407</span>            index_data = index_data.get_level_values(group_key)</div>
<div class="line"><span class="lineno"> 1408</span>        sorted_index_data = index_data.take(sorted_index).to_numpy()</div>
<div class="line"><span class="lineno"> 1409</span> </div>
<div class="line"><span class="lineno"> 1410</span>        starts, ends = lib.generate_slices(sorted_ids, ngroups)</div>
<div class="line"><span class="lineno"> 1411</span>        <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno"> 1412</span>            starts,</div>
<div class="line"><span class="lineno"> 1413</span>            ends,</div>
<div class="line"><span class="lineno"> 1414</span>            sorted_index_data,</div>
<div class="line"><span class="lineno"> 1415</span>            sorted_data,</div>
<div class="line"><span class="lineno"> 1416</span>        )</div>
<div class="line"><span class="lineno"> 1417</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3cb43e78db5c44635a0e3143192e6833" name="a3cb43e78db5c44635a0e3143192e6833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb43e78db5c44635a0e3143192e6833">&#9670;&#160;</a></span>_obj_1d_constructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Callable pandas.core.groupby.groupby.GroupBy._obj_1d_constructor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1932</span>    <span class="keyword">def </span>_obj_1d_constructor(self) -&gt; Callable:</div>
<div class="line"><span class="lineno"> 1933</span>        <span class="comment"># GH28330 preserve subclassed Series/DataFrames</span></div>
<div class="line"><span class="lineno"> 1934</span>        <span class="keywordflow">if</span> isinstance(self.obj, DataFrame):</div>
<div class="line"><span class="lineno"> 1935</span>            <span class="keywordflow">return</span> self.obj._constructor_sliced</div>
<div class="line"><span class="lineno"> 1936</span>        <span class="keyword">assert</span> isinstance(self.obj, Series)</div>
<div class="line"><span class="lineno"> 1937</span>        <span class="keywordflow">return</span> self.obj._constructor</div>
<div class="line"><span class="lineno"> 1938</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac40939c6ff6ab88ee3a42b3c60b84263" name="ac40939c6ff6ab88ee3a42b3c60b84263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40939c6ff6ab88ee3a42b3c60b84263">&#9670;&#160;</a></span>_python_agg_general()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._python_agg_general </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>raise_on_typeerror</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1638</span>    <span class="keyword">def </span>_python_agg_general(self, func, *args, raise_on_typeerror=False, **kwargs):</div>
<div class="line"><span class="lineno"> 1639</span>        func = com.is_builtin_func(func)</div>
<div class="line"><span class="lineno"> 1640</span>        f = <span class="keyword">lambda</span> x: <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(x, *args, **kwargs)</div>
<div class="line"><span class="lineno"> 1641</span> </div>
<div class="line"><span class="lineno"> 1642</span>        <span class="comment"># iterate through &quot;columns&quot; ex exclusions to populate output dict</span></div>
<div class="line"><span class="lineno"> 1643</span>        output: dict[base.OutputKey, ArrayLike] = {}</div>
<div class="line"><span class="lineno"> 1644</span> </div>
<div class="line"><span class="lineno"> 1645</span>        <span class="keywordflow">if</span> self.ngroups == 0:</div>
<div class="line"><span class="lineno"> 1646</span>            <span class="comment"># agg_series below assumes ngroups &gt; 0</span></div>
<div class="line"><span class="lineno"> 1647</span>            <span class="keywordflow">return</span> self._python_apply_general(f, self._selected_obj, is_agg=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1648</span> </div>
<div class="line"><span class="lineno"> 1649</span>        <span class="keywordflow">for</span> idx, obj <span class="keywordflow">in</span> enumerate(self._iterate_slices()):</div>
<div class="line"><span class="lineno"> 1650</span>            name = obj.name</div>
<div class="line"><span class="lineno"> 1651</span> </div>
<div class="line"><span class="lineno"> 1652</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1653</span>                <span class="comment"># if this function is invalid for this dtype, we will ignore it.</span></div>
<div class="line"><span class="lineno"> 1654</span>                result = self.grouper.agg_series(obj, f)</div>
<div class="line"><span class="lineno"> 1655</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1656</span>                <span class="keywordflow">if</span> raise_on_typeerror:</div>
<div class="line"><span class="lineno"> 1657</span>                    <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 1658</span>                warn_dropping_nuisance_columns_deprecated(</div>
<div class="line"><span class="lineno"> 1659</span>                    type(self), <span class="stringliteral">&quot;agg&quot;</span>, numeric_only=<span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1660</span>                )</div>
<div class="line"><span class="lineno"> 1661</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1662</span> </div>
<div class="line"><span class="lineno"> 1663</span>            key = base.OutputKey(label=name, position=idx)</div>
<div class="line"><span class="lineno"> 1664</span>            output[key] = result</div>
<div class="line"><span class="lineno"> 1665</span> </div>
<div class="line"><span class="lineno"> 1666</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> output:</div>
<div class="line"><span class="lineno"> 1667</span>            <span class="keywordflow">return</span> self._python_apply_general(f, self._selected_obj)</div>
<div class="line"><span class="lineno"> 1668</span> </div>
<div class="line"><span class="lineno"> 1669</span>        <span class="keywordflow">return</span> self._wrap_aggregated_output(output)</div>
<div class="line"><span class="lineno"> 1670</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a70b26dccbffe8fc844cec39230938a94" name="a70b26dccbffe8fc844cec39230938a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b26dccbffe8fc844cec39230938a94">&#9670;&#160;</a></span>_python_apply_general()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy._python_apply_general </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> | <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>not_indexed_same</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>is_transform</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>is_agg</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Apply function f in python space

Parameters
----------
f : callable
    Function to apply
data : Series or DataFrame
    Data to apply f to
not_indexed_same: bool, optional
    When specified, overrides the value of not_indexed_same. Apply behaves
    differently when the result index is equal to the input index, but
    this can be coincidental leading to value-dependent behavior.
is_transform : bool, default False
    Indicator for whether the function is actually a transform
    and should not have group keys prepended. This is used
    in _make_wrapper which generates both transforms (e.g. diff)
    and non-transforms (e.g. corr)
is_agg : bool, default False
    Indicator for whether the function is an aggregation. When the
    result is empty, we don't want to warn for this case.
    See _GroupBy._python_agg_general.

Returns
-------
Series or DataFrame
    data after applying f
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1572</span>    ) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 1573</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1574</span><span class="stringliteral">        Apply function f in python space</span></div>
<div class="line"><span class="lineno"> 1575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1576</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1577</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1578</span><span class="stringliteral">        f : callable</span></div>
<div class="line"><span class="lineno"> 1579</span><span class="stringliteral">            Function to apply</span></div>
<div class="line"><span class="lineno"> 1580</span><span class="stringliteral">        data : Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">            Data to apply f to</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral">        not_indexed_same: bool, optional</span></div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">            When specified, overrides the value of not_indexed_same. Apply behaves</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">            differently when the result index is equal to the input index, but</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral">            this can be coincidental leading to value-dependent behavior.</span></div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">        is_transform : bool, default False</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">            Indicator for whether the function is actually a transform</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">            and should not have group keys prepended. This is used</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">            in _make_wrapper which generates both transforms (e.g. diff)</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral">            and non-transforms (e.g. corr)</span></div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">        is_agg : bool, default False</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">            Indicator for whether the function is an aggregation. When the</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">            result is empty, we don&#39;t want to warn for this case.</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">            See _GroupBy._python_agg_general.</span></div>
<div class="line"><span class="lineno"> 1595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1596</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1597</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1598</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">            data after applying f</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1601</span>        values, mutated = self.grouper.apply(f, data, self.axis)</div>
<div class="line"><span class="lineno"> 1602</span>        <span class="keywordflow">if</span> not_indexed_same <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1603</span>            not_indexed_same = mutated <span class="keywordflow">or</span> self.mutated</div>
<div class="line"><span class="lineno"> 1604</span>        override_group_keys = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1605</span> </div>
<div class="line"><span class="lineno"> 1606</span>        is_empty_agg = is_agg <span class="keywordflow">and</span> len(values) == 0</div>
<div class="line"><span class="lineno"> 1607</span>        <span class="keywordflow">if</span> (<span class="keywordflow">not</span> not_indexed_same <span class="keywordflow">and</span> self.group_keys <span class="keywordflow">is</span> lib.no_default) <span class="keywordflow">and</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno"> 1608</span>            is_transform <span class="keywordflow">or</span> is_empty_agg</div>
<div class="line"><span class="lineno"> 1609</span>        ):</div>
<div class="line"><span class="lineno"> 1610</span>            <span class="comment"># We&#39;ve detected value-dependent behavior: the result&#39;s index depends on</span></div>
<div class="line"><span class="lineno"> 1611</span>            <span class="comment"># whether the user&#39;s function `f` returned the same index or not.</span></div>
<div class="line"><span class="lineno"> 1612</span>            msg = (</div>
<div class="line"><span class="lineno"> 1613</span>                <span class="stringliteral">&quot;Not prepending group keys to the result index of &quot;</span></div>
<div class="line"><span class="lineno"> 1614</span>                <span class="stringliteral">&quot;transform-like apply. In the future, the group keys &quot;</span></div>
<div class="line"><span class="lineno"> 1615</span>                <span class="stringliteral">&quot;will be included in the index, regardless of whether &quot;</span></div>
<div class="line"><span class="lineno"> 1616</span>                <span class="stringliteral">&quot;the applied function returns a like-indexed object.\n&quot;</span></div>
<div class="line"><span class="lineno"> 1617</span>                <span class="stringliteral">&quot;To preserve the previous behavior, use\n\n\t&quot;</span></div>
<div class="line"><span class="lineno"> 1618</span>                <span class="stringliteral">&quot;&gt;&gt;&gt; .groupby(..., group_keys=False)\n\n&quot;</span></div>
<div class="line"><span class="lineno"> 1619</span>                <span class="stringliteral">&quot;To adopt the future behavior and silence this warning, use &quot;</span></div>
<div class="line"><span class="lineno"> 1620</span>                <span class="stringliteral">&quot;\n\n\t&gt;&gt;&gt; .groupby(..., group_keys=True)&quot;</span></div>
<div class="line"><span class="lineno"> 1621</span>            )</div>
<div class="line"><span class="lineno"> 1622</span>            warnings.warn(msg, FutureWarning, stacklevel=find_stack_level())</div>
<div class="line"><span class="lineno"> 1623</span>            <span class="comment"># We want to behave as if `self.group_keys=False` when reconstructing</span></div>
<div class="line"><span class="lineno"> 1624</span>            <span class="comment"># the object. However, we don&#39;t want to mutate the stateful GroupBy</span></div>
<div class="line"><span class="lineno"> 1625</span>            <span class="comment"># object, so we just override it.</span></div>
<div class="line"><span class="lineno"> 1626</span>            <span class="comment"># When this deprecation is enforced then override_group_keys</span></div>
<div class="line"><span class="lineno"> 1627</span>            <span class="comment"># may be removed.</span></div>
<div class="line"><span class="lineno"> 1628</span>            override_group_keys = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1629</span> </div>
<div class="line"><span class="lineno"> 1630</span>        <span class="keywordflow">return</span> self._wrap_applied_output(</div>
<div class="line"><span class="lineno"> 1631</span>            data,</div>
<div class="line"><span class="lineno"> 1632</span>            values,</div>
<div class="line"><span class="lineno"> 1633</span>            not_indexed_same,</div>
<div class="line"><span class="lineno"> 1634</span>            override_group_keys=is_transform <span class="keywordflow">or</span> override_group_keys,</div>
<div class="line"><span class="lineno"> 1635</span>        )</div>
<div class="line"><span class="lineno"> 1636</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa24281d563b467e8f513648bd5af299f" name="aa24281d563b467e8f513648bd5af299f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24281d563b467e8f513648bd5af299f">&#9670;&#160;</a></span>_reindex_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a> pandas.core.groupby.groupby.GroupBy._reindex_output </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a>&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>np.NaN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.float64] | None &#160;</td>
          <td class="paramname"><em>qs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">If we have categorical groupers, then we might want to make sure that
we have a fully re-indexed output to the levels. This means expanding
the output space to accommodate all values in the cartesian product of
our groups, regardless of whether they were observed in the data or
not. This will expand the output space if there are missing groups.

The method returns early without modifying the input if the number of
groupings is less than 2, self.observed == True or none of the groupers
are categorical.

Parameters
----------
output : Series or DataFrame
    Object resulting from grouping and applying an operation.
fill_value : scalar, default np.NaN
    Value to use for unobserved categories if self.observed is False.
qs : np.ndarray[float64] or None, default None
    quantile values, only relevant for quantile.

Returns
-------
Series or DataFrame
    Object (potentially) re-indexed to include all possible groups.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4091</span>    ) -&gt; OutputFrameOrSeries:</div>
<div class="line"><span class="lineno"> 4092</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4093</span><span class="stringliteral">        If we have categorical groupers, then we might want to make sure that</span></div>
<div class="line"><span class="lineno"> 4094</span><span class="stringliteral">        we have a fully re-indexed output to the levels. This means expanding</span></div>
<div class="line"><span class="lineno"> 4095</span><span class="stringliteral">        the output space to accommodate all values in the cartesian product of</span></div>
<div class="line"><span class="lineno"> 4096</span><span class="stringliteral">        our groups, regardless of whether they were observed in the data or</span></div>
<div class="line"><span class="lineno"> 4097</span><span class="stringliteral">        not. This will expand the output space if there are missing groups.</span></div>
<div class="line"><span class="lineno"> 4098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4099</span><span class="stringliteral">        The method returns early without modifying the input if the number of</span></div>
<div class="line"><span class="lineno"> 4100</span><span class="stringliteral">        groupings is less than 2, self.observed == True or none of the groupers</span></div>
<div class="line"><span class="lineno"> 4101</span><span class="stringliteral">        are categorical.</span></div>
<div class="line"><span class="lineno"> 4102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4103</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4104</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4105</span><span class="stringliteral">        output : Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 4106</span><span class="stringliteral">            Object resulting from grouping and applying an operation.</span></div>
<div class="line"><span class="lineno"> 4107</span><span class="stringliteral">        fill_value : scalar, default np.NaN</span></div>
<div class="line"><span class="lineno"> 4108</span><span class="stringliteral">            Value to use for unobserved categories if self.observed is False.</span></div>
<div class="line"><span class="lineno"> 4109</span><span class="stringliteral">        qs : np.ndarray[float64] or None, default None</span></div>
<div class="line"><span class="lineno"> 4110</span><span class="stringliteral">            quantile values, only relevant for quantile.</span></div>
<div class="line"><span class="lineno"> 4111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4112</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 4113</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 4114</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 4115</span><span class="stringliteral">            Object (potentially) re-indexed to include all possible groups.</span></div>
<div class="line"><span class="lineno"> 4116</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4117</span>        groupings = self.grouper.groupings</div>
<div class="line"><span class="lineno"> 4118</span>        <span class="keywordflow">if</span> len(groupings) == 1:</div>
<div class="line"><span class="lineno"> 4119</span>            <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 4120</span> </div>
<div class="line"><span class="lineno"> 4121</span>        <span class="comment"># if we only care about the observed values</span></div>
<div class="line"><span class="lineno"> 4122</span>        <span class="comment"># we are done</span></div>
<div class="line"><span class="lineno"> 4123</span>        <span class="keywordflow">elif</span> self.observed:</div>
<div class="line"><span class="lineno"> 4124</span>            <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 4125</span> </div>
<div class="line"><span class="lineno"> 4126</span>        <span class="comment"># reindexing only applies to a Categorical grouper</span></div>
<div class="line"><span class="lineno"> 4127</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> any(</div>
<div class="line"><span class="lineno"> 4128</span>            isinstance(ping.grouping_vector, (Categorical, CategoricalIndex))</div>
<div class="line"><span class="lineno"> 4129</span>            <span class="keywordflow">for</span> ping <span class="keywordflow">in</span> groupings</div>
<div class="line"><span class="lineno"> 4130</span>        ):</div>
<div class="line"><span class="lineno"> 4131</span>            <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 4132</span> </div>
<div class="line"><span class="lineno"> 4133</span>        levels_list = [ping.group_index <span class="keywordflow">for</span> ping <span class="keywordflow">in</span> groupings]</div>
<div class="line"><span class="lineno"> 4134</span>        names = self.grouper.names</div>
<div class="line"><span class="lineno"> 4135</span>        <span class="keywordflow">if</span> qs <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4136</span>            <span class="comment"># error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 4137</span>            <span class="comment"># &quot;ndarray[Any, dtype[floating[_64Bit]]]&quot;; expected &quot;Index&quot;</span></div>
<div class="line"><span class="lineno"> 4138</span>            levels_list.append(qs)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 4139</span>            names = names + [<span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno"> 4140</span>        index, _ = MultiIndex.from_product(levels_list, names=names).sortlevel()</div>
<div class="line"><span class="lineno"> 4141</span> </div>
<div class="line"><span class="lineno"> 4142</span>        <span class="keywordflow">if</span> self.as_index:</div>
<div class="line"><span class="lineno"> 4143</span>            <span class="comment"># Always holds for SeriesGroupBy unless GH#36507 is implemented</span></div>
<div class="line"><span class="lineno"> 4144</span>            d = {</div>
<div class="line"><span class="lineno"> 4145</span>                self.obj._get_axis_name(self.axis): index,</div>
<div class="line"><span class="lineno"> 4146</span>                <span class="stringliteral">&quot;copy&quot;</span>: <span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 4147</span>                <span class="stringliteral">&quot;fill_value&quot;</span>: fill_value,</div>
<div class="line"><span class="lineno"> 4148</span>            }</div>
<div class="line"><span class="lineno"> 4149</span>            <span class="keywordflow">return</span> output.reindex(**d)</div>
<div class="line"><span class="lineno"> 4150</span> </div>
<div class="line"><span class="lineno"> 4151</span>        <span class="comment"># GH 13204</span></div>
<div class="line"><span class="lineno"> 4152</span>        <span class="comment"># Here, the categorical in-axis groupers, which need to be fully</span></div>
<div class="line"><span class="lineno"> 4153</span>        <span class="comment"># expanded, are columns in `output`. An idea is to do:</span></div>
<div class="line"><span class="lineno"> 4154</span>        <span class="comment"># output = output.set_index(self.grouper.names)</span></div>
<div class="line"><span class="lineno"> 4155</span>        <span class="comment">#                .reindex(index).reset_index()</span></div>
<div class="line"><span class="lineno"> 4156</span>        <span class="comment"># but special care has to be taken because of possible not-in-axis</span></div>
<div class="line"><span class="lineno"> 4157</span>        <span class="comment"># groupers.</span></div>
<div class="line"><span class="lineno"> 4158</span>        <span class="comment"># So, we manually select and drop the in-axis grouper columns,</span></div>
<div class="line"><span class="lineno"> 4159</span>        <span class="comment"># reindex `output`, and then reset the in-axis grouper columns.</span></div>
<div class="line"><span class="lineno"> 4160</span> </div>
<div class="line"><span class="lineno"> 4161</span>        <span class="comment"># Select in-axis groupers</span></div>
<div class="line"><span class="lineno"> 4162</span>        in_axis_grps = (</div>
<div class="line"><span class="lineno"> 4163</span>            (i, ping.name) <span class="keywordflow">for</span> (i, ping) <span class="keywordflow">in</span> enumerate(groupings) <span class="keywordflow">if</span> ping.in_axis</div>
<div class="line"><span class="lineno"> 4164</span>        )</div>
<div class="line"><span class="lineno"> 4165</span>        g_nums, g_names = zip(*in_axis_grps)</div>
<div class="line"><span class="lineno"> 4166</span> </div>
<div class="line"><span class="lineno"> 4167</span>        output = output.drop(labels=list(g_names), axis=1)</div>
<div class="line"><span class="lineno"> 4168</span> </div>
<div class="line"><span class="lineno"> 4169</span>        <span class="comment"># Set a temp index and reindex (possibly expanding)</span></div>
<div class="line"><span class="lineno"> 4170</span>        output = output.set_index(self.grouper.result_index).reindex(</div>
<div class="line"><span class="lineno"> 4171</span>            index, copy=<span class="keyword">False</span>, fill_value=fill_value</div>
<div class="line"><span class="lineno"> 4172</span>        )</div>
<div class="line"><span class="lineno"> 4173</span> </div>
<div class="line"><span class="lineno"> 4174</span>        <span class="comment"># Reset in-axis grouper columns</span></div>
<div class="line"><span class="lineno"> 4175</span>        <span class="comment"># (using level numbers `g_nums` because level names may not be unique)</span></div>
<div class="line"><span class="lineno"> 4176</span>        output = output.reset_index(level=g_nums)</div>
<div class="line"><span class="lineno"> 4177</span> </div>
<div class="line"><span class="lineno"> 4178</span>        <span class="keywordflow">return</span> output.reset_index(drop=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 4179</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b3412e1599dfe3fd3b2a7d11e898235" name="a8b3412e1599dfe3fd3b2a7d11e898235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3412e1599dfe3fd3b2a7d11e898235">&#9670;&#160;</a></span>_reset_group_selection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.groupby.groupby.GroupBy._reset_group_selection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Clear group based selection.

Used for methods needing to return info on each group regardless of
whether a group selection was previously set.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1087</span>    <span class="keyword">def </span>_reset_group_selection(self) -&gt; None:</div>
<div class="line"><span class="lineno"> 1088</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">        Clear group based selection.</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">        Used for methods needing to return info on each group regardless of</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">        whether a group selection was previously set.</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1094</span>        <span class="keywordflow">if</span> self._group_selection <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1095</span>            <span class="comment"># GH12839 clear cached selection too when changing group selection</span></div>
<div class="line"><span class="lineno"> 1096</span>            self._group_selection = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1097</span>            self._reset_cache(<span class="stringliteral">&quot;_selected_obj&quot;</span>)</div>
<div class="line"><span class="lineno"> 1098</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1d4f7353558af547198e4b1a1241987" name="ab1d4f7353558af547198e4b1a1241987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d4f7353558af547198e4b1a1241987">&#9670;&#160;</a></span>_resolve_numeric_only()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.groupby.groupby.GroupBy._resolve_numeric_only </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>how</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault&#160;</td>
          <td class="paramname"><em>numeric_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
    &#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Determine subclass-specific default value for 'numeric_only'.

For SeriesGroupBy we want the default to be False (to match Series behavior).
For DataFrameGroupBy we want it to be True (for backwards-compat).

Parameters
----------
numeric_only : bool or lib.no_default
axis : int
    Axis passed to the groupby op (not self.axis).

Returns
-------
bool
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1317</span>    ) -&gt; bool:</div>
<div class="line"><span class="lineno"> 1318</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">        Determine subclass-specific default value for &#39;numeric_only&#39;.</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">        For SeriesGroupBy we want the default to be False (to match Series behavior).</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">        For DataFrameGroupBy we want it to be True (for backwards-compat).</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">        numeric_only : bool or lib.no_default</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">        axis : int</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">            Axis passed to the groupby op (not self.axis).</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1334</span>        <span class="comment"># GH#41291</span></div>
<div class="line"><span class="lineno"> 1335</span>        <span class="keywordflow">if</span> numeric_only <span class="keywordflow">is</span> lib.no_default:</div>
<div class="line"><span class="lineno"> 1336</span>            <span class="comment"># i.e. not explicitly passed by user</span></div>
<div class="line"><span class="lineno"> 1337</span>            <span class="keywordflow">if</span> self.obj.ndim == 2:</div>
<div class="line"><span class="lineno"> 1338</span>                <span class="comment"># i.e. DataFrameGroupBy</span></div>
<div class="line"><span class="lineno"> 1339</span>                numeric_only = axis != 1</div>
<div class="line"><span class="lineno"> 1340</span>                <span class="comment"># GH#42395 GH#43108 GH#43154</span></div>
<div class="line"><span class="lineno"> 1341</span>                <span class="comment"># Regression from 1.2.5 to 1.3 caused object columns to be dropped</span></div>
<div class="line"><span class="lineno"> 1342</span>                <span class="keywordflow">if</span> self.axis:</div>
<div class="line"><span class="lineno"> 1343</span>                    obj = self._obj_with_exclusions.T</div>
<div class="line"><span class="lineno"> 1344</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1345</span>                    obj = self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 1346</span>                check = obj._get_numeric_data()</div>
<div class="line"><span class="lineno"> 1347</span>                <span class="keywordflow">if</span> len(obj.columns) <span class="keywordflow">and</span> <span class="keywordflow">not</span> len(check.columns) <span class="keywordflow">and</span> <span class="keywordflow">not</span> obj.empty:</div>
<div class="line"><span class="lineno"> 1348</span>                    numeric_only = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1349</span> </div>
<div class="line"><span class="lineno"> 1350</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1351</span>                numeric_only = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1352</span> </div>
<div class="line"><span class="lineno"> 1353</span>        <span class="keywordflow">if</span> numeric_only <span class="keywordflow">and</span> self.obj.ndim == 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_numeric_dtype(self.obj.dtype):</div>
<div class="line"><span class="lineno"> 1354</span>            <span class="comment"># GH#47500</span></div>
<div class="line"><span class="lineno"> 1355</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1356</span>                f<span class="stringliteral">&quot;{type(self).__name__}.{how} called with &quot;</span></div>
<div class="line"><span class="lineno"> 1357</span>                f<span class="stringliteral">&quot;numeric_only={numeric_only} and dtype {self.obj.dtype}. This will &quot;</span></div>
<div class="line"><span class="lineno"> 1358</span>                <span class="stringliteral">&quot;raise a TypeError in a future version of pandas&quot;</span>,</div>
<div class="line"><span class="lineno"> 1359</span>                category=FutureWarning,</div>
<div class="line"><span class="lineno"> 1360</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1361</span>            )</div>
<div class="line"><span class="lineno"> 1362</span>            <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 1363</span>                f<span class="stringliteral">&quot;{type(self).__name__}.{how} does not implement numeric_only&quot;</span></div>
<div class="line"><span class="lineno"> 1364</span>            )</div>
<div class="line"><span class="lineno"> 1365</span> </div>
<div class="line"><span class="lineno"> 1366</span>        <span class="keywordflow">return</span> numeric_only</div>
<div class="line"><span class="lineno"> 1367</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e0d7bbfff21a8fd204ef792ebcde526" name="a0e0d7bbfff21a8fd204ef792ebcde526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0d7bbfff21a8fd204ef792ebcde526">&#9670;&#160;</a></span>_set_group_selection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.groupby.groupby.GroupBy._set_group_selection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create group based selection.

Used when selection is not passed directly but instead via a grouper.

NOTE: this should be paired with a call to _reset_group_selection
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1060</span>    <span class="keyword">def </span>_set_group_selection(self) -&gt; None:</div>
<div class="line"><span class="lineno"> 1061</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">        Create group based selection.</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        Used when selection is not passed directly but instead via a grouper.</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">        NOTE: this should be paired with a call to _reset_group_selection</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1068</span>        <span class="comment"># This is a no-op for SeriesGroupBy</span></div>
<div class="line"><span class="lineno"> 1069</span>        grp = self.grouper</div>
<div class="line"><span class="lineno"> 1070</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno"> 1071</span>            self.as_index</div>
<div class="line"><span class="lineno"> 1072</span>            <span class="keywordflow">and</span> grp.groupings <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1073</span>            <span class="keywordflow">and</span> self.obj.ndim &gt; 1</div>
<div class="line"><span class="lineno"> 1074</span>            <span class="keywordflow">and</span> self._group_selection <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1075</span>        ):</div>
<div class="line"><span class="lineno"> 1076</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1077</span> </div>
<div class="line"><span class="lineno"> 1078</span>        groupers = [g.name <span class="keywordflow">for</span> g <span class="keywordflow">in</span> grp.groupings <span class="keywordflow">if</span> g.level <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> g.in_axis]</div>
<div class="line"><span class="lineno"> 1079</span> </div>
<div class="line"><span class="lineno"> 1080</span>        <span class="keywordflow">if</span> len(groupers):</div>
<div class="line"><span class="lineno"> 1081</span>            <span class="comment"># GH12839 clear selected obj cache when group selection changes</span></div>
<div class="line"><span class="lineno"> 1082</span>            ax = self.obj._info_axis</div>
<div class="line"><span class="lineno"> 1083</span>            self._group_selection = ax.difference(Index(groupers), sort=<span class="keyword">False</span>).tolist()</div>
<div class="line"><span class="lineno"> 1084</span>            self._reset_cache(<span class="stringliteral">&quot;_selected_obj&quot;</span>)</div>
<div class="line"><span class="lineno"> 1085</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3d6b6af581a5671c827e89968aa0538" name="ad3d6b6af581a5671c827e89968aa0538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d6b6af581a5671c827e89968aa0538">&#9670;&#160;</a></span>_set_result_index_ordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a> pandas.core.groupby.groupby.GroupBy._set_result_index_ordered </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1groupby_1_1groupby.html#a4b829fd0e051c1b8ae0ce117a4cb40ec">OutputFrameOrSeries</a>
    &#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1193</span>    ) -&gt; OutputFrameOrSeries:</div>
<div class="line"><span class="lineno"> 1194</span>        <span class="comment"># set the result index on the passed values object and</span></div>
<div class="line"><span class="lineno"> 1195</span>        <span class="comment"># return the new object, xref 8046</span></div>
<div class="line"><span class="lineno"> 1196</span> </div>
<div class="line"><span class="lineno"> 1197</span>        obj_axis = self.obj._get_axis(self.axis)</div>
<div class="line"><span class="lineno"> 1198</span> </div>
<div class="line"><span class="lineno"> 1199</span>        <span class="keywordflow">if</span> self.grouper.is_monotonic <span class="keywordflow">and</span> <span class="keywordflow">not</span> self.grouper.has_dropped_na:</div>
<div class="line"><span class="lineno"> 1200</span>            <span class="comment"># shortcut if we have an already ordered grouper</span></div>
<div class="line"><span class="lineno"> 1201</span>            result = result.set_axis(obj_axis, axis=self.axis, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1202</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1203</span> </div>
<div class="line"><span class="lineno"> 1204</span>        <span class="comment"># row order is scrambled =&gt; sort the rows by position in original index</span></div>
<div class="line"><span class="lineno"> 1205</span>        original_positions = Index(self.grouper.result_ilocs())</div>
<div class="line"><span class="lineno"> 1206</span>        result = result.set_axis(original_positions, axis=self.axis, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1207</span>        result = result.sort_index(axis=self.axis)</div>
<div class="line"><span class="lineno"> 1208</span>        <span class="keywordflow">if</span> self.grouper.has_dropped_na:</div>
<div class="line"><span class="lineno"> 1209</span>            <span class="comment"># Add back in any missing rows due to dropna - index here is integral</span></div>
<div class="line"><span class="lineno"> 1210</span>            <span class="comment"># with values referring to the row of the input so can use RangeIndex</span></div>
<div class="line"><span class="lineno"> 1211</span>            result = result.reindex(RangeIndex(len(obj_axis)), axis=self.axis)</div>
<div class="line"><span class="lineno"> 1212</span>        result = result.set_axis(obj_axis, axis=self.axis, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1213</span> </div>
<div class="line"><span class="lineno"> 1214</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1215</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6091d4c7f024ed33ef4d07b06cead74a" name="a6091d4c7f024ed33ef4d07b06cead74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6091d4c7f024ed33ef4d07b06cead74a">&#9670;&#160;</a></span>_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1800</span>    <span class="keyword">def </span>_transform(self, func, *args, engine=None, engine_kwargs=None, **kwargs):</div>
<div class="line"><span class="lineno"> 1801</span> </div>
<div class="line"><span class="lineno"> 1802</span>        <span class="keywordflow">if</span> maybe_use_numba(engine):</div>
<div class="line"><span class="lineno"> 1803</span>            <span class="comment"># TODO: tests with self._selected_obj.ndim == 1 on DataFrameGroupBy</span></div>
<div class="line"><span class="lineno"> 1804</span>            <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 1805</span>                data = self._selected_obj</div>
<div class="line"><span class="lineno"> 1806</span>            df = data <span class="keywordflow">if</span> data.ndim == 2 <span class="keywordflow">else</span> data.to_frame()</div>
<div class="line"><span class="lineno"> 1807</span>            result = self._transform_with_numba(</div>
<div class="line"><span class="lineno"> 1808</span>                df, func, *args, engine_kwargs=engine_kwargs, **kwargs</div>
<div class="line"><span class="lineno"> 1809</span>            )</div>
<div class="line"><span class="lineno"> 1810</span>            <span class="keywordflow">if</span> self.obj.ndim == 2:</div>
<div class="line"><span class="lineno"> 1811</span>                <span class="keywordflow">return</span> cast(DataFrame, self.obj)._constructor(</div>
<div class="line"><span class="lineno"> 1812</span>                    result, index=data.index, columns=data.columns</div>
<div class="line"><span class="lineno"> 1813</span>                )</div>
<div class="line"><span class="lineno"> 1814</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1815</span>                <span class="keywordflow">return</span> cast(Series, self.obj)._constructor(</div>
<div class="line"><span class="lineno"> 1816</span>                    result.ravel(), index=data.index, name=data.name</div>
<div class="line"><span class="lineno"> 1817</span>                )</div>
<div class="line"><span class="lineno"> 1818</span> </div>
<div class="line"><span class="lineno"> 1819</span>        <span class="comment"># optimized transforms</span></div>
<div class="line"><span class="lineno"> 1820</span>        func = com.get_cython_func(func) <span class="keywordflow">or</span> func</div>
<div class="line"><span class="lineno"> 1821</span> </div>
<div class="line"><span class="lineno"> 1822</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(func, str):</div>
<div class="line"><span class="lineno"> 1823</span>            <span class="keywordflow">return</span> self._transform_general(func, *args, **kwargs)</div>
<div class="line"><span class="lineno"> 1824</span> </div>
<div class="line"><span class="lineno"> 1825</span>        <span class="keywordflow">elif</span> func <span class="keywordflow">not</span> <span class="keywordflow">in</span> base.transform_kernel_allowlist:</div>
<div class="line"><span class="lineno"> 1826</span>            msg = f<span class="stringliteral">&quot;&#39;{func}&#39; is not a valid function name for transform(name)&quot;</span></div>
<div class="line"><span class="lineno"> 1827</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 1828</span>        <span class="keywordflow">elif</span> func <span class="keywordflow">in</span> base.cythonized_kernels <span class="keywordflow">or</span> func <span class="keywordflow">in</span> base.transformation_kernels:</div>
<div class="line"><span class="lineno"> 1829</span>            <span class="comment"># cythonized transform or canned &quot;agg+broadcast&quot;</span></div>
<div class="line"><span class="lineno"> 1830</span>            <span class="keywordflow">return</span> getattr(self, func)(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 1831</span> </div>
<div class="line"><span class="lineno"> 1832</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1833</span>            <span class="comment"># i.e. func in base.reduction_kernels</span></div>
<div class="line"><span class="lineno"> 1834</span> </div>
<div class="line"><span class="lineno"> 1835</span>            <span class="comment"># GH#30918 Use _transform_fast only when we know func is an aggregation</span></div>
<div class="line"><span class="lineno"> 1836</span>            <span class="comment"># If func is a reduction, we need to broadcast the</span></div>
<div class="line"><span class="lineno"> 1837</span>            <span class="comment"># result to the whole group. Compute func result</span></div>
<div class="line"><span class="lineno"> 1838</span>            <span class="comment"># and deal with possible broadcasting below.</span></div>
<div class="line"><span class="lineno"> 1839</span>            <span class="comment"># Temporarily set observed for dealing with categoricals.</span></div>
<div class="line"><span class="lineno"> 1840</span>            <span class="keyword">with</span> com.temp_setattr(self, <span class="stringliteral">&quot;observed&quot;</span>, <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 1841</span>                result = getattr(self, func)(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 1842</span> </div>
<div class="line"><span class="lineno"> 1843</span>            <span class="keywordflow">return</span> self._wrap_transform_fast_result(result)</div>
<div class="line"><span class="lineno"> 1844</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a70ec1d562112a04515b8d40120c26df4" name="a70ec1d562112a04515b8d40120c26df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ec1d562112a04515b8d40120c26df4">&#9670;&#160;</a></span>_transform_with_numba()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._transform_with_numba </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Perform groupby transform routine with the numba engine.

This routine mimics the data splitting routine of the DataSplitter class
to generate the indices of each group in the sorted data and then passes the
data and indices into a Numba jitted function.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1453</span>    <span class="keyword">def </span>_transform_with_numba(self, data, func, *args, engine_kwargs=None, **kwargs):</div>
<div class="line"><span class="lineno"> 1454</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">        Perform groupby transform routine with the numba engine.</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">        This routine mimics the data splitting routine of the DataSplitter class</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral">        to generate the indices of each group in the sorted data and then passes the</span></div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">        data and indices into a Numba jitted function.</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1461</span>        starts, ends, sorted_index, sorted_data = self._numba_prep(data)</div>
<div class="line"><span class="lineno"> 1462</span>        numba_.validate_udf(func)</div>
<div class="line"><span class="lineno"> 1463</span>        numba_transform_func = numba_.generate_numba_transform_func(</div>
<div class="line"><span class="lineno"> 1464</span>            func, **get_jit_arguments(engine_kwargs, kwargs)</div>
<div class="line"><span class="lineno"> 1465</span>        )</div>
<div class="line"><span class="lineno"> 1466</span>        result = numba_transform_func(</div>
<div class="line"><span class="lineno"> 1467</span>            sorted_data,</div>
<div class="line"><span class="lineno"> 1468</span>            sorted_index,</div>
<div class="line"><span class="lineno"> 1469</span>            starts,</div>
<div class="line"><span class="lineno"> 1470</span>            ends,</div>
<div class="line"><span class="lineno"> 1471</span>            len(data.columns),</div>
<div class="line"><span class="lineno"> 1472</span>            *args,</div>
<div class="line"><span class="lineno"> 1473</span>        )</div>
<div class="line"><span class="lineno"> 1474</span>        <span class="comment"># result values needs to be resorted to their original positions since we</span></div>
<div class="line"><span class="lineno"> 1475</span>        <span class="comment"># evaluated the data sorted by group</span></div>
<div class="line"><span class="lineno"> 1476</span>        <span class="keywordflow">return</span> result.take(np.argsort(sorted_index), axis=0)</div>
<div class="line"><span class="lineno"> 1477</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abccf9ccdf5c08799c946111ed987f8f5" name="abccf9ccdf5c08799c946111ed987f8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccf9ccdf5c08799c946111ed987f8f5">&#9670;&#160;</a></span>_wrap_aggregated_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._wrap_aggregated_output </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> | <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> | Mapping[<a class="el" href="classpandas_1_1core_1_1groupby_1_1base_1_1_output_key.html">base.OutputKey</a>, ArrayLike]&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.float64] | None &#160;</td>
          <td class="paramname"><em>qs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wraps the output of GroupBy aggregations into the expected result.

Parameters
----------
output : Series, DataFrame, or Mapping[base.OutputKey, ArrayLike]
   Data to wrap.

Returns
-------
Series or DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1226</span>    ):</div>
<div class="line"><span class="lineno"> 1227</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">        Wraps the output of GroupBy aggregations into the expected result.</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">        output : Series, DataFrame, or Mapping[base.OutputKey, ArrayLike]</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">           Data to wrap.</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1239</span> </div>
<div class="line"><span class="lineno"> 1240</span>        <span class="keywordflow">if</span> isinstance(output, (Series, DataFrame)):</div>
<div class="line"><span class="lineno"> 1241</span>            <span class="comment"># We get here (for DataFrameGroupBy) if we used Manager.grouped_reduce,</span></div>
<div class="line"><span class="lineno"> 1242</span>            <span class="comment">#  in which case our columns are already set correctly.</span></div>
<div class="line"><span class="lineno"> 1243</span>            <span class="comment"># ATM we do not get here for SeriesGroupBy; when we do, we will</span></div>
<div class="line"><span class="lineno"> 1244</span>            <span class="comment">#  need to require that result.name already match self.obj.name</span></div>
<div class="line"><span class="lineno"> 1245</span>            result = output</div>
<div class="line"><span class="lineno"> 1246</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1247</span>            result = self._indexed_output_to_ndframe(output)</div>
<div class="line"><span class="lineno"> 1248</span> </div>
<div class="line"><span class="lineno"> 1249</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.as_index:</div>
<div class="line"><span class="lineno"> 1250</span>            <span class="comment"># `not self.as_index` is only relevant for DataFrameGroupBy,</span></div>
<div class="line"><span class="lineno"> 1251</span>            <span class="comment">#   enforced in __init__</span></div>
<div class="line"><span class="lineno"> 1252</span>            self._insert_inaxis_grouper_inplace(result)</div>
<div class="line"><span class="lineno"> 1253</span>            result = result._consolidate()</div>
<div class="line"><span class="lineno"> 1254</span>            index = Index(range(self.grouper.ngroups))</div>
<div class="line"><span class="lineno"> 1255</span> </div>
<div class="line"><span class="lineno"> 1256</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1257</span>            index = self.grouper.result_index</div>
<div class="line"><span class="lineno"> 1258</span> </div>
<div class="line"><span class="lineno"> 1259</span>        <span class="keywordflow">if</span> qs <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1260</span>            <span class="comment"># We get here with len(qs) != 1 and not self.as_index</span></div>
<div class="line"><span class="lineno"> 1261</span>            <span class="comment">#  in test_pass_args_kwargs</span></div>
<div class="line"><span class="lineno"> 1262</span>            index = _insert_quantile_level(index, qs)</div>
<div class="line"><span class="lineno"> 1263</span> </div>
<div class="line"><span class="lineno"> 1264</span>        result.index = index</div>
<div class="line"><span class="lineno"> 1265</span> </div>
<div class="line"><span class="lineno"> 1266</span>        <span class="keywordflow">if</span> self.axis == 1:</div>
<div class="line"><span class="lineno"> 1267</span>            <span class="comment"># Only relevant for DataFrameGroupBy, no-op for SeriesGroupBy</span></div>
<div class="line"><span class="lineno"> 1268</span>            result = result.T</div>
<div class="line"><span class="lineno"> 1269</span>            <span class="keywordflow">if</span> result.index.equals(self.obj.index):</div>
<div class="line"><span class="lineno"> 1270</span>                <span class="comment"># Retain e.g. DatetimeIndex/TimedeltaIndex freq</span></div>
<div class="line"><span class="lineno"> 1271</span>                result.index = self.obj.index.copy()</div>
<div class="line"><span class="lineno"> 1272</span>                <span class="comment"># TODO: Do this more systematically</span></div>
<div class="line"><span class="lineno"> 1273</span> </div>
<div class="line"><span class="lineno"> 1274</span>        <span class="keywordflow">return</span> self._reindex_output(result, qs=qs)</div>
<div class="line"><span class="lineno"> 1275</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aee76f55dbe28d70c0200aa1e1445240f" name="aee76f55dbe28d70c0200aa1e1445240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee76f55dbe28d70c0200aa1e1445240f">&#9670;&#160;</a></span>_wrap_applied_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._wrap_applied_output </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>not_indexed_same</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>override_group_keys</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_data_frame_group_by.html#aee7d07db6e8bd7b14ff5cbc1d792915c">pandas.core.groupby.generic.DataFrameGroupBy</a>, and <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_series_group_by.html#af22a846d6d87c3ab82854b872399facd">pandas.core.groupby.generic.SeriesGroupBy</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1312</span>    ):</div>
<div class="line"><span class="lineno"> 1313</span>        <span class="keywordflow">raise</span> AbstractMethodError(self)</div>
<div class="line"><span class="lineno"> 1314</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a81fd76cecac1af72652720dd31b8f64c" name="a81fd76cecac1af72652720dd31b8f64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fd76cecac1af72652720dd31b8f64c">&#9670;&#160;</a></span>_wrap_transform_fast_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy._wrap_transform_fast_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NDFrameT&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Fast transform path for aggregations.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1846</span>    <span class="keyword">def </span>_wrap_transform_fast_result(self, result: NDFrameT) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 1847</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1848</span><span class="stringliteral">        Fast transform path for aggregations.</span></div>
<div class="line"><span class="lineno"> 1849</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1850</span>        obj = self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 1851</span> </div>
<div class="line"><span class="lineno"> 1852</span>        <span class="comment"># for each col, reshape to size of original frame by take operation</span></div>
<div class="line"><span class="lineno"> 1853</span>        ids, _, _ = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 1854</span>        result = result.reindex(self.grouper.result_index, axis=self.axis, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1855</span> </div>
<div class="line"><span class="lineno"> 1856</span>        <span class="keywordflow">if</span> self.obj.ndim == 1:</div>
<div class="line"><span class="lineno"> 1857</span>            <span class="comment"># i.e. SeriesGroupBy</span></div>
<div class="line"><span class="lineno"> 1858</span>            out = algorithms.take_nd(result._values, ids)</div>
<div class="line"><span class="lineno"> 1859</span>            output = obj._constructor(out, index=obj.index, name=obj.name)</div>
<div class="line"><span class="lineno"> 1860</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1861</span>            <span class="comment"># `.size()` gives Series output on DataFrame input, need axis 0</span></div>
<div class="line"><span class="lineno"> 1862</span>            axis = 0 <span class="keywordflow">if</span> result.ndim == 1 <span class="keywordflow">else</span> self.axis</div>
<div class="line"><span class="lineno"> 1863</span>            <span class="comment"># GH#46209</span></div>
<div class="line"><span class="lineno"> 1864</span>            <span class="comment"># Don&#39;t convert indices: negative indices need to give rise</span></div>
<div class="line"><span class="lineno"> 1865</span>            <span class="comment"># to null values in the result</span></div>
<div class="line"><span class="lineno"> 1866</span>            output = result._take(ids, axis=axis, convert_indices=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1867</span>            output = output.set_axis(obj._get_axis(self.axis), axis=axis)</div>
<div class="line"><span class="lineno"> 1868</span>        <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 1869</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aabcb1df4792ba902486d6f381b8a86e5" name="aabcb1df4792ba902486d6f381b8a86e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcb1df4792ba902486d6f381b8a86e5">&#9670;&#160;</a></span>_wrap_transformed_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> | <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.core.groupby.groupby.GroupBy._wrap_transformed_output </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping[<a class="el" href="classpandas_1_1core_1_1groupby_1_1base_1_1_output_key.html">base.OutputKey</a>, ArrayLike]
    &#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wraps the output of GroupBy transformations into the expected result.

Parameters
----------
output : Mapping[base.OutputKey, ArrayLike]
    Data to wrap.

Returns
-------
Series or DataFrame
    Series for SeriesGroupBy, DataFrame for DataFrameGroupBy
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1279</span>    ) -&gt; Series | DataFrame:</div>
<div class="line"><span class="lineno"> 1280</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">        Wraps the output of GroupBy transformations into the expected result.</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        output : Mapping[base.OutputKey, ArrayLike]</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">            Data to wrap.</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">            Series for SeriesGroupBy, DataFrame for DataFrameGroupBy</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1293</span>        <span class="keywordflow">if</span> isinstance(output, (Series, DataFrame)):</div>
<div class="line"><span class="lineno"> 1294</span>            result = output</div>
<div class="line"><span class="lineno"> 1295</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1296</span>            result = self._indexed_output_to_ndframe(output)</div>
<div class="line"><span class="lineno"> 1297</span> </div>
<div class="line"><span class="lineno"> 1298</span>        <span class="keywordflow">if</span> self.axis == 1:</div>
<div class="line"><span class="lineno"> 1299</span>            <span class="comment"># Only relevant for DataFrameGroupBy</span></div>
<div class="line"><span class="lineno"> 1300</span>            result = result.T</div>
<div class="line"><span class="lineno"> 1301</span>            result.columns = self.obj.columns</div>
<div class="line"><span class="lineno"> 1302</span> </div>
<div class="line"><span class="lineno"> 1303</span>        result.index = self.obj.index</div>
<div class="line"><span class="lineno"> 1304</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1305</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2ec2cda59b14da99f075a6e0890765e" name="ad2ec2cda59b14da99f075a6e0890765e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ec2cda59b14da99f075a6e0890765e">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if all values in the group are truthful, else False.

Parameters
----------
skipna : bool, default True
    Flag to ignore nan values during truth testing.

Returns
-------
Series or DataFrame
    DataFrame or Series of boolean values, where a value is True if all elements
    are True within its respective group, False otherwise.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2009</span>    <span class="keyword">def </span>all(self, skipna: bool = <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 2010</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral">        Return True if all values in the group are truthful, else False.</span></div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">        skipna : bool, default True</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral">            Flag to ignore nan values during truth testing.</span></div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2018</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2019</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2020</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral">            DataFrame or Series of boolean values, where a value is True if all elements</span></div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">            are True within its respective group, False otherwise.</span></div>
<div class="line"><span class="lineno"> 2023</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2024</span>        <span class="keywordflow">return</span> self._bool_agg(<span class="stringliteral">&quot;all&quot;</span>, skipna)</div>
<div class="line"><span class="lineno"> 2025</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adb225d01333635a4d2a7c89098a8a665" name="adb225d01333635a4d2a7c89098a8a665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb225d01333635a4d2a7c89098a8a665">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.any </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if any value in the group is truthful, else False.

Parameters
----------
skipna : bool, default True
    Flag to ignore nan values during truth testing.

Returns
-------
Series or DataFrame
    DataFrame or Series of boolean values, where a value is True if any element
    is True within its respective group, False otherwise.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1989</span>    <span class="keyword">def </span>any(self, skipna: bool = <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 1990</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral">        Return True if any value in the group is truthful, else False.</span></div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1993</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral">        skipna : bool, default True</span></div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">            Flag to ignore nan values during truth testing.</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">            DataFrame or Series of boolean values, where a value is True if any element</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral">            is True within its respective group, False otherwise.</span></div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2004</span>        <span class="keywordflow">return</span> self._bool_agg(<span class="stringliteral">&quot;any&quot;</span>, skipna)</div>
<div class="line"><span class="lineno"> 2005</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0dc3e65e8535fa5140908580c8ce555" name="ad0dc3e65e8535fa5140908580c8ce555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dc3e65e8535fa5140908580c8ce555">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.apply </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_series_group_by.html#a4bb7c63c45f8d99015a8bdbaeabc66c8">pandas.core.groupby.generic.SeriesGroupBy</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1510</span>    <span class="keyword">def </span>apply(self, func, *args, **kwargs) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 1511</span> </div>
<div class="line"><span class="lineno"> 1512</span>        func = com.is_builtin_func(func)</div>
<div class="line"><span class="lineno"> 1513</span> </div>
<div class="line"><span class="lineno"> 1514</span>        <span class="keywordflow">if</span> isinstance(func, str):</div>
<div class="line"><span class="lineno"> 1515</span>            <span class="keywordflow">if</span> hasattr(self, func):</div>
<div class="line"><span class="lineno"> 1516</span>                res = getattr(self, func)</div>
<div class="line"><span class="lineno"> 1517</span>                <span class="keywordflow">if</span> callable(res):</div>
<div class="line"><span class="lineno"> 1518</span>                    <span class="keywordflow">return</span> res(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 1519</span>                <span class="keywordflow">elif</span> args <span class="keywordflow">or</span> kwargs:</div>
<div class="line"><span class="lineno"> 1520</span>                    <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Cannot pass arguments to property {func}&quot;</span>)</div>
<div class="line"><span class="lineno"> 1521</span>                <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 1522</span> </div>
<div class="line"><span class="lineno"> 1523</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1524</span>                <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;apply func should be callable, not &#39;{func}&#39;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1525</span> </div>
<div class="line"><span class="lineno"> 1526</span>        <span class="keywordflow">elif</span> args <span class="keywordflow">or</span> kwargs:</div>
<div class="line"><span class="lineno"> 1527</span>            <span class="keywordflow">if</span> callable(func):</div>
<div class="line"><span class="lineno"> 1528</span> </div>
<div class="line"><span class="lineno"> 1529</span>                <span class="preprocessor">@wraps(func)</span></div>
<div class="line"><span class="lineno"> 1530</span>                <span class="keyword">def </span><a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(g):</div>
<div class="line"><span class="lineno"> 1531</span>                    <span class="keyword">with</span> np.errstate(all=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno"> 1532</span>                        <span class="keywordflow">return</span> <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(g, *args, **kwargs)</div>
<div class="line"><span class="lineno"> 1533</span> </div>
<div class="line"><span class="lineno"> 1534</span>            <span class="keywordflow">elif</span> hasattr(nanops, <span class="stringliteral">&quot;nan&quot;</span> + func):</div>
<div class="line"><span class="lineno"> 1535</span>                <span class="comment"># TODO: should we wrap this in to e.g. _is_builtin_func?</span></div>
<div class="line"><span class="lineno"> 1536</span>                f = getattr(nanops, <span class="stringliteral">&quot;nan&quot;</span> + func)</div>
<div class="line"><span class="lineno"> 1537</span> </div>
<div class="line"><span class="lineno"> 1538</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1539</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1540</span>                    <span class="stringliteral">&quot;func must be a callable if args or kwargs are supplied&quot;</span></div>
<div class="line"><span class="lineno"> 1541</span>                )</div>
<div class="line"><span class="lineno"> 1542</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1543</span> </div>
<div class="line"><span class="lineno"> 1544</span>            f = func</div>
<div class="line"><span class="lineno"> 1545</span> </div>
<div class="line"><span class="lineno"> 1546</span>        <span class="comment"># ignore SettingWithCopy here in case the user mutates</span></div>
<div class="line"><span class="lineno"> 1547</span>        <span class="keyword">with</span> option_context(<span class="stringliteral">&quot;mode.chained_assignment&quot;</span>, <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1548</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1549</span>                result = self._python_apply_general(f, self._selected_obj)</div>
<div class="line"><span class="lineno"> 1550</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 1551</span>                <span class="comment"># gh-20949</span></div>
<div class="line"><span class="lineno"> 1552</span>                <span class="comment"># try again, with .apply acting as a filtering</span></div>
<div class="line"><span class="lineno"> 1553</span>                <span class="comment"># operation, by excluding the grouping column</span></div>
<div class="line"><span class="lineno"> 1554</span>                <span class="comment"># This would normally not be triggered</span></div>
<div class="line"><span class="lineno"> 1555</span>                <span class="comment"># except if the udf is trying an operation that</span></div>
<div class="line"><span class="lineno"> 1556</span>                <span class="comment"># fails on *some* columns, e.g. a numeric operation</span></div>
<div class="line"><span class="lineno"> 1557</span>                <span class="comment"># on a string grouper column</span></div>
<div class="line"><span class="lineno"> 1558</span> </div>
<div class="line"><span class="lineno"> 1559</span>                <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 1560</span>                    <span class="keywordflow">return</span> self._python_apply_general(f, self._selected_obj)</div>
<div class="line"><span class="lineno"> 1561</span> </div>
<div class="line"><span class="lineno"> 1562</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1563</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2daa2f507b10a89023a89f5be2140c82" name="a2daa2f507b10a89023a89f5be2140c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2daa2f507b10a89023a89f5be2140c82">&#9670;&#160;</a></span>backfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.backfill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Backward fill the values.

.. deprecated:: 1.4
    Use bfill instead.

Parameters
----------
limit : int, optional
    Limit of how many values to fill.

Returns
-------
Series or DataFrame
    Object with missing values filled.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2984</span>    <span class="keyword">def </span>backfill(self, limit=None):</div>
<div class="line"><span class="lineno"> 2985</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">        Backward fill the values.</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral">        .. deprecated:: 1.4</span></div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral">            Use bfill instead.</span></div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2993</span><span class="stringliteral">        limit : int, optional</span></div>
<div class="line"><span class="lineno"> 2994</span><span class="stringliteral">            Limit of how many values to fill.</span></div>
<div class="line"><span class="lineno"> 2995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2996</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2997</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral">            Object with missing values filled.</span></div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3001</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 3002</span>            <span class="stringliteral">&quot;backfill is deprecated and will be removed in a future version. &quot;</span></div>
<div class="line"><span class="lineno"> 3003</span>            <span class="stringliteral">&quot;Use bfill instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 3004</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 3005</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 3006</span>        )</div>
<div class="line"><span class="lineno"> 3007</span>        <span class="keywordflow">return</span> self.bfill(limit=limit)</div>
<div class="line"><span class="lineno"> 3008</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab522014f60e0dda6683098724cd2cf72" name="ab522014f60e0dda6683098724cd2cf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab522014f60e0dda6683098724cd2cf72">&#9670;&#160;</a></span>bfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.bfill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Backward fill the values.

Parameters
----------
limit : int, optional
    Limit of how many values to fill.

Returns
-------
Series or DataFrame
    Object with missing values filled.

See Also
--------
Series.bfill :  Backward fill the missing values in the dataset.
DataFrame.bfill:  Backward fill the missing values in the dataset.
Series.fillna: Fill NaN values of a Series.
DataFrame.fillna: Fill NaN values of a DataFrame.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2961</span>    <span class="keyword">def </span>bfill(self, limit=None):</div>
<div class="line"><span class="lineno"> 2962</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2963</span><span class="stringliteral">        Backward fill the values.</span></div>
<div class="line"><span class="lineno"> 2964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2965</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2966</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2967</span><span class="stringliteral">        limit : int, optional</span></div>
<div class="line"><span class="lineno"> 2968</span><span class="stringliteral">            Limit of how many values to fill.</span></div>
<div class="line"><span class="lineno"> 2969</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2970</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2971</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2972</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2973</span><span class="stringliteral">            Object with missing values filled.</span></div>
<div class="line"><span class="lineno"> 2974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2975</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2976</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2977</span><span class="stringliteral">        Series.bfill :  Backward fill the missing values in the dataset.</span></div>
<div class="line"><span class="lineno"> 2978</span><span class="stringliteral">        DataFrame.bfill:  Backward fill the missing values in the dataset.</span></div>
<div class="line"><span class="lineno"> 2979</span><span class="stringliteral">        Series.fillna: Fill NaN values of a Series.</span></div>
<div class="line"><span class="lineno"> 2980</span><span class="stringliteral">        DataFrame.fillna: Fill NaN values of a DataFrame.</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2982</span>        <span class="keywordflow">return</span> self._fill(<span class="stringliteral">&quot;bfill&quot;</span>, limit=limit)</div>
<div class="line"><span class="lineno"> 2983</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f0e94b2416991aed9f5aef0be1ea312" name="a7f0e94b2416991aed9f5aef0be1ea312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0e94b2416991aed9f5aef0be1ea312">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute count of group, excluding missing values.

Returns
-------
Series or DataFrame
    Count of values within each group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2029</span>    <span class="keyword">def </span>count(self) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 2030</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2031</span><span class="stringliteral">        Compute count of group, excluding missing values.</span></div>
<div class="line"><span class="lineno"> 2032</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2033</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2034</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2035</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2036</span><span class="stringliteral">            Count of values within each group.</span></div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2038</span>        data = self._get_data_to_aggregate()</div>
<div class="line"><span class="lineno"> 2039</span>        ids, _, ngroups = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 2040</span>        mask = ids != -1</div>
<div class="line"><span class="lineno"> 2041</span> </div>
<div class="line"><span class="lineno"> 2042</span>        is_series = data.ndim == 1</div>
<div class="line"><span class="lineno"> 2043</span> </div>
<div class="line"><span class="lineno"> 2044</span>        <span class="keyword">def </span>hfunc(bvalues: ArrayLike) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 2045</span>            <span class="comment"># TODO(EA2D): reshape would not be necessary with 2D EAs</span></div>
<div class="line"><span class="lineno"> 2046</span>            <span class="keywordflow">if</span> bvalues.ndim == 1:</div>
<div class="line"><span class="lineno"> 2047</span>                <span class="comment"># EA</span></div>
<div class="line"><span class="lineno"> 2048</span>                masked = mask &amp; ~isna(bvalues).reshape(1, -1)</div>
<div class="line"><span class="lineno"> 2049</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2050</span>                masked = mask &amp; ~isna(bvalues)</div>
<div class="line"><span class="lineno"> 2051</span> </div>
<div class="line"><span class="lineno"> 2052</span>            counted = lib.count_level_2d(masked, labels=ids, max_bin=ngroups, axis=1)</div>
<div class="line"><span class="lineno"> 2053</span>            <span class="keywordflow">if</span> is_series:</div>
<div class="line"><span class="lineno"> 2054</span>                <span class="keyword">assert</span> counted.ndim == 2</div>
<div class="line"><span class="lineno"> 2055</span>                <span class="keyword">assert</span> counted.shape[0] == 1</div>
<div class="line"><span class="lineno"> 2056</span>                <span class="keywordflow">return</span> counted[0]</div>
<div class="line"><span class="lineno"> 2057</span>            <span class="keywordflow">return</span> counted</div>
<div class="line"><span class="lineno"> 2058</span> </div>
<div class="line"><span class="lineno"> 2059</span>        new_mgr = data.grouped_reduce(hfunc)</div>
<div class="line"><span class="lineno"> 2060</span> </div>
<div class="line"><span class="lineno"> 2061</span>        <span class="comment"># If we are grouping on categoricals we want unobserved categories to</span></div>
<div class="line"><span class="lineno"> 2062</span>        <span class="comment"># return zero, rather than the default of NaN which the reindexing in</span></div>
<div class="line"><span class="lineno"> 2063</span>        <span class="comment"># _wrap_agged_manager() returns. GH 35028</span></div>
<div class="line"><span class="lineno"> 2064</span>        <span class="keyword">with</span> com.temp_setattr(self, <span class="stringliteral">&quot;observed&quot;</span>, <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 2065</span>            result = self._wrap_agged_manager(new_mgr)</div>
<div class="line"><span class="lineno"> 2066</span> </div>
<div class="line"><span class="lineno"> 2067</span>        <span class="keywordflow">if</span> result.ndim == 1:</div>
<div class="line"><span class="lineno"> 2068</span>            result.index = self.grouper.result_index</div>
<div class="line"><span class="lineno"> 2069</span> </div>
<div class="line"><span class="lineno"> 2070</span>        <span class="keywordflow">return</span> self._reindex_output(result, fill_value=0)</div>
<div class="line"><span class="lineno"> 2071</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab69f343f46d328e9ff7f92c48167bd9d" name="ab69f343f46d328e9ff7f92c48167bd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69f343f46d328e9ff7f92c48167bd9d">&#9670;&#160;</a></span>cumcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.cumcount </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Number each item in each group from 0 to the length of that group - 1.

Essentially this is equivalent to

.. code-block:: python

    self.apply(lambda x: pd.Series(np.arange(len(x)), x.index))

Parameters
----------
ascending : bool, default True
    If False, number in reverse, from length of group - 1 to 0.

Returns
-------
Series
    Sequence number of each element within each group.

See Also
--------
.ngroup : Number the groups themselves.

Examples
--------
&gt;&gt;&gt; df = pd.DataFrame([['a'], ['a'], ['a'], ['b'], ['b'], ['a']],
...                   columns=['A'])
&gt;&gt;&gt; df
   A
0  a
1  a
2  a
3  b
4  b
5  a
&gt;&gt;&gt; df.groupby('A').cumcount()
0    0
1    1
2    2
3    0
4    1
5    3
dtype: int64
&gt;&gt;&gt; df.groupby('A').cumcount(ascending=False)
0    3
1    2
2    1
3    1
4    0
5    0
dtype: int64
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3469</span>    <span class="keyword">def </span>cumcount(self, ascending: bool = <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 3470</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3471</span><span class="stringliteral">        Number each item in each group from 0 to the length of that group - 1.</span></div>
<div class="line"><span class="lineno"> 3472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3473</span><span class="stringliteral">        Essentially this is equivalent to</span></div>
<div class="line"><span class="lineno"> 3474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3475</span><span class="stringliteral">        .. code-block:: python</span></div>
<div class="line"><span class="lineno"> 3476</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3477</span><span class="stringliteral">            self.apply(lambda x: pd.Series(np.arange(len(x)), x.index))</span></div>
<div class="line"><span class="lineno"> 3478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3479</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3480</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3481</span><span class="stringliteral">        ascending : bool, default True</span></div>
<div class="line"><span class="lineno"> 3482</span><span class="stringliteral">            If False, number in reverse, from length of group - 1 to 0.</span></div>
<div class="line"><span class="lineno"> 3483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3484</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3485</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3486</span><span class="stringliteral">        Series</span></div>
<div class="line"><span class="lineno"> 3487</span><span class="stringliteral">            Sequence number of each element within each group.</span></div>
<div class="line"><span class="lineno"> 3488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3489</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 3490</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3491</span><span class="stringliteral">        .ngroup : Number the groups themselves.</span></div>
<div class="line"><span class="lineno"> 3492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3493</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3494</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3495</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame([[&#39;a&#39;], [&#39;a&#39;], [&#39;a&#39;], [&#39;b&#39;], [&#39;b&#39;], [&#39;a&#39;]],</span></div>
<div class="line"><span class="lineno"> 3496</span><span class="stringliteral">        ...                   columns=[&#39;A&#39;])</span></div>
<div class="line"><span class="lineno"> 3497</span><span class="stringliteral">        &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 3498</span><span class="stringliteral">           A</span></div>
<div class="line"><span class="lineno"> 3499</span><span class="stringliteral">        0  a</span></div>
<div class="line"><span class="lineno"> 3500</span><span class="stringliteral">        1  a</span></div>
<div class="line"><span class="lineno"> 3501</span><span class="stringliteral">        2  a</span></div>
<div class="line"><span class="lineno"> 3502</span><span class="stringliteral">        3  b</span></div>
<div class="line"><span class="lineno"> 3503</span><span class="stringliteral">        4  b</span></div>
<div class="line"><span class="lineno"> 3504</span><span class="stringliteral">        5  a</span></div>
<div class="line"><span class="lineno"> 3505</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).cumcount()</span></div>
<div class="line"><span class="lineno"> 3506</span><span class="stringliteral">        0    0</span></div>
<div class="line"><span class="lineno"> 3507</span><span class="stringliteral">        1    1</span></div>
<div class="line"><span class="lineno"> 3508</span><span class="stringliteral">        2    2</span></div>
<div class="line"><span class="lineno"> 3509</span><span class="stringliteral">        3    0</span></div>
<div class="line"><span class="lineno"> 3510</span><span class="stringliteral">        4    1</span></div>
<div class="line"><span class="lineno"> 3511</span><span class="stringliteral">        5    3</span></div>
<div class="line"><span class="lineno"> 3512</span><span class="stringliteral">        dtype: int64</span></div>
<div class="line"><span class="lineno"> 3513</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).cumcount(ascending=False)</span></div>
<div class="line"><span class="lineno"> 3514</span><span class="stringliteral">        0    3</span></div>
<div class="line"><span class="lineno"> 3515</span><span class="stringliteral">        1    2</span></div>
<div class="line"><span class="lineno"> 3516</span><span class="stringliteral">        2    1</span></div>
<div class="line"><span class="lineno"> 3517</span><span class="stringliteral">        3    1</span></div>
<div class="line"><span class="lineno"> 3518</span><span class="stringliteral">        4    0</span></div>
<div class="line"><span class="lineno"> 3519</span><span class="stringliteral">        5    0</span></div>
<div class="line"><span class="lineno"> 3520</span><span class="stringliteral">        dtype: int64</span></div>
<div class="line"><span class="lineno"> 3521</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3522</span>        <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 3523</span>            index = self._selected_obj._get_axis(self.axis)</div>
<div class="line"><span class="lineno"> 3524</span>            cumcounts = self._cumcount_array(ascending=ascending)</div>
<div class="line"><span class="lineno"> 3525</span>            <span class="keywordflow">return</span> self._obj_1d_constructor(cumcounts, index)</div>
<div class="line"><span class="lineno"> 3526</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a865f9d3df6838dce31c947e4a6a4b481" name="a865f9d3df6838dce31c947e4a6a4b481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865f9d3df6838dce31c947e4a6a4b481">&#9670;&#160;</a></span>cummax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.cummax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cumulative max for each group.

Returns
-------
Series or DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3688</span>    <span class="keyword">def </span>cummax(self, axis=0, numeric_only=False, **kwargs) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3689</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3690</span><span class="stringliteral">        Cumulative max for each group.</span></div>
<div class="line"><span class="lineno"> 3691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3692</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3693</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3694</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3695</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3696</span>        skipna = kwargs.get(<span class="stringliteral">&quot;skipna&quot;</span>, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3697</span>        <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3698</span>            f = <span class="keyword">lambda</span> x: np.maximum.accumulate(x, axis)</div>
<div class="line"><span class="lineno"> 3699</span>            numeric_only_bool = self._resolve_numeric_only(<span class="stringliteral">&quot;cummax&quot;</span>, numeric_only, axis)</div>
<div class="line"><span class="lineno"> 3700</span>            obj = self._selected_obj</div>
<div class="line"><span class="lineno"> 3701</span>            <span class="keywordflow">if</span> numeric_only_bool:</div>
<div class="line"><span class="lineno"> 3702</span>                obj = obj._get_numeric_data()</div>
<div class="line"><span class="lineno"> 3703</span>            <span class="keywordflow">return</span> self._python_apply_general(f, obj, is_transform=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3704</span> </div>
<div class="line"><span class="lineno"> 3705</span>        <span class="keywordflow">return</span> self._cython_transform(</div>
<div class="line"><span class="lineno"> 3706</span>            <span class="stringliteral">&quot;cummax&quot;</span>, numeric_only=numeric_only, skipna=skipna</div>
<div class="line"><span class="lineno"> 3707</span>        )</div>
<div class="line"><span class="lineno"> 3708</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8038f2e1440fa9fa797cfc881cbf31ae" name="a8038f2e1440fa9fa797cfc881cbf31ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8038f2e1440fa9fa797cfc881cbf31ae">&#9670;&#160;</a></span>cummin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.cummin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cumulative min for each group.

Returns
-------
Series or DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3664</span>    <span class="keyword">def </span>cummin(self, axis=0, numeric_only=False, **kwargs) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3665</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3666</span><span class="stringliteral">        Cumulative min for each group.</span></div>
<div class="line"><span class="lineno"> 3667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3668</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3669</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3670</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3671</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3672</span>        skipna = kwargs.get(<span class="stringliteral">&quot;skipna&quot;</span>, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3673</span>        <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3674</span>            f = <span class="keyword">lambda</span> x: np.minimum.accumulate(x, axis)</div>
<div class="line"><span class="lineno"> 3675</span>            numeric_only_bool = self._resolve_numeric_only(<span class="stringliteral">&quot;cummax&quot;</span>, numeric_only, axis)</div>
<div class="line"><span class="lineno"> 3676</span>            obj = self._selected_obj</div>
<div class="line"><span class="lineno"> 3677</span>            <span class="keywordflow">if</span> numeric_only_bool:</div>
<div class="line"><span class="lineno"> 3678</span>                obj = obj._get_numeric_data()</div>
<div class="line"><span class="lineno"> 3679</span>            <span class="keywordflow">return</span> self._python_apply_general(f, obj, is_transform=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3680</span> </div>
<div class="line"><span class="lineno"> 3681</span>        <span class="keywordflow">return</span> self._cython_transform(</div>
<div class="line"><span class="lineno"> 3682</span>            <span class="stringliteral">&quot;cummin&quot;</span>, numeric_only=numeric_only, skipna=skipna</div>
<div class="line"><span class="lineno"> 3683</span>        )</div>
<div class="line"><span class="lineno"> 3684</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3293c5ecf5d70d63b09bde1ce92f0bd6" name="a3293c5ecf5d70d63b09bde1ce92f0bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3293c5ecf5d70d63b09bde1ce92f0bd6">&#9670;&#160;</a></span>cumprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.cumprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cumulative product for each group.

Returns
-------
Series or DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3628</span>    <span class="keyword">def </span>cumprod(self, axis=0, *args, **kwargs) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3629</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3630</span><span class="stringliteral">        Cumulative product for each group.</span></div>
<div class="line"><span class="lineno"> 3631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3632</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3633</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3634</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3635</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3636</span>        nv.validate_groupby_func(<span class="stringliteral">&quot;cumprod&quot;</span>, args, kwargs, [<span class="stringliteral">&quot;numeric_only&quot;</span>, <span class="stringliteral">&quot;skipna&quot;</span>])</div>
<div class="line"><span class="lineno"> 3637</span>        <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3638</span>            f = <span class="keyword">lambda</span> x: x.cumprod(axis=axis, **kwargs)</div>
<div class="line"><span class="lineno"> 3639</span>            <span class="keywordflow">return</span> self._python_apply_general(f, self._selected_obj, is_transform=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3640</span> </div>
<div class="line"><span class="lineno"> 3641</span>        <span class="keywordflow">return</span> self._cython_transform(<span class="stringliteral">&quot;cumprod&quot;</span>, **kwargs)</div>
<div class="line"><span class="lineno"> 3642</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae982f07ae1d9a9cad06f3c171388c19c" name="ae982f07ae1d9a9cad06f3c171388c19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae982f07ae1d9a9cad06f3c171388c19c">&#9670;&#160;</a></span>cumsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.cumsum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cumulative sum for each group.

Returns
-------
Series or DataFrame
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3646</span>    <span class="keyword">def </span>cumsum(self, axis=0, *args, **kwargs) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3647</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3648</span><span class="stringliteral">        Cumulative sum for each group.</span></div>
<div class="line"><span class="lineno"> 3649</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3650</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3651</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3652</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3653</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3654</span>        nv.validate_groupby_func(<span class="stringliteral">&quot;cumsum&quot;</span>, args, kwargs, [<span class="stringliteral">&quot;numeric_only&quot;</span>, <span class="stringliteral">&quot;skipna&quot;</span>])</div>
<div class="line"><span class="lineno"> 3655</span>        <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3656</span>            f = <span class="keyword">lambda</span> x: x.cumsum(axis=axis, **kwargs)</div>
<div class="line"><span class="lineno"> 3657</span>            <span class="keywordflow">return</span> self._python_apply_general(f, self._selected_obj, is_transform=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3658</span> </div>
<div class="line"><span class="lineno"> 3659</span>        <span class="keywordflow">return</span> self._cython_transform(<span class="stringliteral">&quot;cumsum&quot;</span>, **kwargs)</div>
<div class="line"><span class="lineno"> 3660</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d35b107f398970a5b1a98f684f525de" name="a7d35b107f398970a5b1a98f684f525de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d35b107f398970a5b1a98f684f525de">&#9670;&#160;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.describe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1groupby_1_1generic_1_1_series_group_by.html#a5c8216f14882f96d846092f4508948d9">pandas.core.groupby.generic.SeriesGroupBy</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2653</span>    <span class="keyword">def </span>describe(self, **kwargs):</div>
<div class="line"><span class="lineno"> 2654</span>        <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 2655</span>            <span class="keywordflow">if</span> len(self._selected_obj) == 0:</div>
<div class="line"><span class="lineno"> 2656</span>                described = self._selected_obj.describe(**kwargs)</div>
<div class="line"><span class="lineno"> 2657</span>                <span class="keywordflow">if</span> self._selected_obj.ndim == 1:</div>
<div class="line"><span class="lineno"> 2658</span>                    result = described</div>
<div class="line"><span class="lineno"> 2659</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2660</span>                    result = described.unstack()</div>
<div class="line"><span class="lineno"> 2661</span>                <span class="keywordflow">return</span> result.to_frame().T.iloc[:0]</div>
<div class="line"><span class="lineno"> 2662</span> </div>
<div class="line"><span class="lineno"> 2663</span>            result = self._python_apply_general(</div>
<div class="line"><span class="lineno"> 2664</span>                <span class="keyword">lambda</span> x: x.describe(**kwargs),</div>
<div class="line"><span class="lineno"> 2665</span>                self._selected_obj,</div>
<div class="line"><span class="lineno"> 2666</span>                not_indexed_same=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 2667</span>            )</div>
<div class="line"><span class="lineno"> 2668</span>            <span class="keywordflow">if</span> self.axis == 1:</div>
<div class="line"><span class="lineno"> 2669</span>                <span class="keywordflow">return</span> result.T</div>
<div class="line"><span class="lineno"> 2670</span>            <span class="keywordflow">return</span> result.unstack()</div>
<div class="line"><span class="lineno"> 2671</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="add436d2f4a8444bcfe3dbfc49ed29fe0" name="add436d2f4a8444bcfe3dbfc49ed29fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add436d2f4a8444bcfe3dbfc49ed29fe0">&#9670;&#160;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>periods</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">First discrete difference of element.

Calculates the difference of each element compared with another
element in the group (default is element in previous row).

Parameters
----------
periods : int, default 1
    Periods to shift for calculating difference, accepts negative values.
axis : axis to shift, default 0
    Take difference over rows (0) or columns (1).

Returns
-------
Series or DataFrame
    First differences.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3907</span>    <span class="keyword">def </span>diff(self, periods: int = 1, axis: int = 0) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3908</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3909</span><span class="stringliteral">        First discrete difference of element.</span></div>
<div class="line"><span class="lineno"> 3910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3911</span><span class="stringliteral">        Calculates the difference of each element compared with another</span></div>
<div class="line"><span class="lineno"> 3912</span><span class="stringliteral">        element in the group (default is element in previous row).</span></div>
<div class="line"><span class="lineno"> 3913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3914</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3915</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3916</span><span class="stringliteral">        periods : int, default 1</span></div>
<div class="line"><span class="lineno"> 3917</span><span class="stringliteral">            Periods to shift for calculating difference, accepts negative values.</span></div>
<div class="line"><span class="lineno"> 3918</span><span class="stringliteral">        axis : axis to shift, default 0</span></div>
<div class="line"><span class="lineno"> 3919</span><span class="stringliteral">            Take difference over rows (0) or columns (1).</span></div>
<div class="line"><span class="lineno"> 3920</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3921</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3922</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3923</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3924</span><span class="stringliteral">            First differences.</span></div>
<div class="line"><span class="lineno"> 3925</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3926</span>        <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3927</span>            <span class="keywordflow">return</span> self.apply(<span class="keyword">lambda</span> x: x.diff(periods=periods, axis=axis))</div>
<div class="line"><span class="lineno"> 3928</span> </div>
<div class="line"><span class="lineno"> 3929</span>        obj = self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 3930</span>        shifted = self.shift(periods=periods, axis=axis)</div>
<div class="line"><span class="lineno"> 3931</span> </div>
<div class="line"><span class="lineno"> 3932</span>        <span class="comment"># GH45562 - to retain existing behavior and match behavior of Series.diff(),</span></div>
<div class="line"><span class="lineno"> 3933</span>        <span class="comment"># int8 and int16 are coerced to float32 rather than float64.</span></div>
<div class="line"><span class="lineno"> 3934</span>        dtypes_to_f32 = [<span class="stringliteral">&quot;int8&quot;</span>, <span class="stringliteral">&quot;int16&quot;</span>]</div>
<div class="line"><span class="lineno"> 3935</span>        <span class="keywordflow">if</span> obj.ndim == 1:</div>
<div class="line"><span class="lineno"> 3936</span>            <span class="keywordflow">if</span> obj.dtype <span class="keywordflow">in</span> dtypes_to_f32:</div>
<div class="line"><span class="lineno"> 3937</span>                shifted = shifted.astype(<span class="stringliteral">&quot;float32&quot;</span>)</div>
<div class="line"><span class="lineno"> 3938</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3939</span>            to_coerce = [c <span class="keywordflow">for</span> c, dtype <span class="keywordflow">in</span> obj.dtypes.items() <span class="keywordflow">if</span> dtype <span class="keywordflow">in</span> dtypes_to_f32]</div>
<div class="line"><span class="lineno"> 3940</span>            <span class="keywordflow">if</span> len(to_coerce):</div>
<div class="line"><span class="lineno"> 3941</span>                shifted = shifted.astype({c: <span class="stringliteral">&quot;float32&quot;</span> <span class="keywordflow">for</span> c <span class="keywordflow">in</span> to_coerce})</div>
<div class="line"><span class="lineno"> 3942</span> </div>
<div class="line"><span class="lineno"> 3943</span>        <span class="keywordflow">return</span> obj - shifted</div>
<div class="line"><span class="lineno"> 3944</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa2aca5c66474b38ec1460b90c787568" name="aaa2aca5c66474b38ec1460b90c787568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2aca5c66474b38ec1460b90c787568">&#9670;&#160;</a></span>ewm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1window_1_1ewm_1_1_exponential_moving_window_groupby.html">ExponentialMovingWindowGroupby</a> pandas.core.groupby.groupby.GroupBy.ewm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an ewm grouper, providing ewm functionality per group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2811</span>    <span class="keyword">def </span>ewm(self, *args, **kwargs) -&gt; ExponentialMovingWindowGroupby:</div>
<div class="line"><span class="lineno"> 2812</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2813</span><span class="stringliteral">        Return an ewm grouper, providing ewm functionality per group.</span></div>
<div class="line"><span class="lineno"> 2814</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2815</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1window.html">pandas.core.window</a> <span class="keyword">import</span> ExponentialMovingWindowGroupby</div>
<div class="line"><span class="lineno"> 2816</span> </div>
<div class="line"><span class="lineno"> 2817</span>        <span class="keywordflow">return</span> ExponentialMovingWindowGroupby(</div>
<div class="line"><span class="lineno"> 2818</span>            self._selected_obj,</div>
<div class="line"><span class="lineno"> 2819</span>            *args,</div>
<div class="line"><span class="lineno"> 2820</span>            _grouper=self.grouper,</div>
<div class="line"><span class="lineno"> 2821</span>            **kwargs,</div>
<div class="line"><span class="lineno"> 2822</span>        )</div>
<div class="line"><span class="lineno"> 2823</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1window_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1window.html">pandas.core.window</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a310c9e138f254a8dc75b9b00fac63e" name="a5a310c9e138f254a8dc75b9b00fac63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a310c9e138f254a8dc75b9b00fac63e">&#9670;&#160;</a></span>expanding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1window_1_1expanding_1_1_expanding_groupby.html">ExpandingGroupby</a> pandas.core.groupby.groupby.GroupBy.expanding </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an expanding grouper, providing expanding
functionality per group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2794</span>    <span class="keyword">def </span>expanding(self, *args, **kwargs) -&gt; ExpandingGroupby:</div>
<div class="line"><span class="lineno"> 2795</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral">        Return an expanding grouper, providing expanding</span></div>
<div class="line"><span class="lineno"> 2797</span><span class="stringliteral">        functionality per group.</span></div>
<div class="line"><span class="lineno"> 2798</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2799</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1window.html">pandas.core.window</a> <span class="keyword">import</span> ExpandingGroupby</div>
<div class="line"><span class="lineno"> 2800</span> </div>
<div class="line"><span class="lineno"> 2801</span>        <span class="keywordflow">return</span> ExpandingGroupby(</div>
<div class="line"><span class="lineno"> 2802</span>            self._selected_obj,</div>
<div class="line"><span class="lineno"> 2803</span>            *args,</div>
<div class="line"><span class="lineno"> 2804</span>            _grouper=self.grouper,</div>
<div class="line"><span class="lineno"> 2805</span>            **kwargs,</div>
<div class="line"><span class="lineno"> 2806</span>        )</div>
<div class="line"><span class="lineno"> 2807</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a009da5b1693c64f17dccd6916c534e75" name="a009da5b1693c64f17dccd6916c534e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009da5b1693c64f17dccd6916c534e75">&#9670;&#160;</a></span>ffill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.ffill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Forward fill the values.

Parameters
----------
limit : int, optional
    Limit of how many values to fill.

Returns
-------
Series or DataFrame
    Object with missing values filled.

See Also
--------
Series.ffill: Returns Series with minimum number of char in object.
DataFrame.ffill: Object with missing values filled or None if inplace=True.
Series.fillna: Fill NaN values of a Series.
DataFrame.fillna: Fill NaN values of a DataFrame.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2911</span>    <span class="keyword">def </span>ffill(self, limit=None):</div>
<div class="line"><span class="lineno"> 2912</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral">        Forward fill the values.</span></div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2916</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2917</span><span class="stringliteral">        limit : int, optional</span></div>
<div class="line"><span class="lineno"> 2918</span><span class="stringliteral">            Limit of how many values to fill.</span></div>
<div class="line"><span class="lineno"> 2919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2920</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2921</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2922</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2923</span><span class="stringliteral">            Object with missing values filled.</span></div>
<div class="line"><span class="lineno"> 2924</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2925</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2926</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2927</span><span class="stringliteral">        Series.ffill: Returns Series with minimum number of char in object.</span></div>
<div class="line"><span class="lineno"> 2928</span><span class="stringliteral">        DataFrame.ffill: Object with missing values filled or None if inplace=True.</span></div>
<div class="line"><span class="lineno"> 2929</span><span class="stringliteral">        Series.fillna: Fill NaN values of a Series.</span></div>
<div class="line"><span class="lineno"> 2930</span><span class="stringliteral">        DataFrame.fillna: Fill NaN values of a DataFrame.</span></div>
<div class="line"><span class="lineno"> 2931</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2932</span>        <span class="keywordflow">return</span> self._fill(<span class="stringliteral">&quot;ffill&quot;</span>, limit=limit)</div>
<div class="line"><span class="lineno"> 2933</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b9ffe53710ea4a6d45c95679279c68f" name="a3b9ffe53710ea4a6d45c95679279c68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9ffe53710ea4a6d45c95679279c68f">&#9670;&#160;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.first </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the first non-null entry of each column.

Parameters
----------
numeric_only : bool, default False
    Include only float, int, boolean columns.
min_count : int, default -1
    The required number of valid values to perform the operation. If fewer
    than ``min_count`` non-NA values are present the result will be NA.

Returns
-------
Series or DataFrame
    First non-null of values within each group.

See Also
--------
DataFrame.groupby : Apply a function groupby to each row or column of a
    DataFrame.
DataFrame.core.groupby.GroupBy.last : Compute the last non-null entry of each
    column.
DataFrame.core.groupby.GroupBy.nth : Take the nth row from each group.

Examples
--------
&gt;&gt;&gt; df = pd.DataFrame(dict(A=[1, 1, 3], B=[None, 5, 6], C=[1, 2, 3],
...                        D=['3/11/2000', '3/12/2000', '3/13/2000']))
&gt;&gt;&gt; df['D'] = pd.to_datetime(df['D'])
&gt;&gt;&gt; df.groupby("A").first()
     B  C          D
A
1  5.0  1 2000-03-11
3  6.0  3 2000-03-13
&gt;&gt;&gt; df.groupby("A").first(min_count=2)
    B    C          D
A
1 NaN  1.0 2000-03-11
3 NaN  NaN        NaT
&gt;&gt;&gt; df.groupby("A").first(numeric_only=True)
     B  C
A
1  5.0  1
3  6.0  3
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2487</span>    <span class="keyword">def </span>first(self, numeric_only: bool = <span class="keyword">False</span>, min_count: int = -1):</div>
<div class="line"><span class="lineno"> 2488</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">        Compute the first non-null entry of each column.</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">        numeric_only : bool, default False</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral">            Include only float, int, boolean columns.</span></div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral">        min_count : int, default -1</span></div>
<div class="line"><span class="lineno"> 2496</span><span class="stringliteral">            The required number of valid values to perform the operation. If fewer</span></div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral">            than ``min_count`` non-NA values are present the result will be NA.</span></div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">            First non-null of values within each group.</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">        DataFrame.groupby : Apply a function groupby to each row or column of a</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral">            DataFrame.</span></div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral">        DataFrame.core.groupby.GroupBy.last : Compute the last non-null entry of each</span></div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral">            column.</span></div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral">        DataFrame.core.groupby.GroupBy.nth : Take the nth row from each group.</span></div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame(dict(A=[1, 1, 3], B=[None, 5, 6], C=[1, 2, 3],</span></div>
<div class="line"><span class="lineno"> 2515</span><span class="stringliteral">        ...                        D=[&#39;3/11/2000&#39;, &#39;3/12/2000&#39;, &#39;3/13/2000&#39;]))</span></div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">        &gt;&gt;&gt; df[&#39;D&#39;] = pd.to_datetime(df[&#39;D&#39;])</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&quot;A&quot;).first()</span></div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral">             B  C          D</span></div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral">        1  5.0  1 2000-03-11</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral">        3  6.0  3 2000-03-13</span></div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&quot;A&quot;).first(min_count=2)</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral">            B    C          D</span></div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral">        1 NaN  1.0 2000-03-11</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral">        3 NaN  NaN        NaT</span></div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&quot;A&quot;).first(numeric_only=True)</span></div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">             B  C</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">        1  5.0  1</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral">        3  6.0  3</span></div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2533</span> </div>
<div class="line"><span class="lineno"> 2534</span>        <span class="keyword">def </span>first_compat(obj: NDFrameT, axis: int = 0):</div>
<div class="line"><span class="lineno"> 2535</span>            <span class="keyword">def </span>first(x: Series):</div>
<div class="line"><span class="lineno"> 2536</span>                <span class="stringliteral">&quot;&quot;&quot;Helper function for first item that isn&#39;t NA.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2537</span>                arr = x.array[notna(x.array)]</div>
<div class="line"><span class="lineno"> 2538</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(arr):</div>
<div class="line"><span class="lineno"> 2539</span>                    <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 2540</span>                <span class="keywordflow">return</span> arr[0]</div>
<div class="line"><span class="lineno"> 2541</span> </div>
<div class="line"><span class="lineno"> 2542</span>            <span class="keywordflow">if</span> isinstance(obj, DataFrame):</div>
<div class="line"><span class="lineno"> 2543</span>                <span class="keywordflow">return</span> obj.apply(first, axis=axis)</div>
<div class="line"><span class="lineno"> 2544</span>            <span class="keywordflow">elif</span> isinstance(obj, Series):</div>
<div class="line"><span class="lineno"> 2545</span>                <span class="keywordflow">return</span> first(obj)</div>
<div class="line"><span class="lineno"> 2546</span>            <span class="keywordflow">else</span>:  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno"> 2547</span>                <span class="keywordflow">raise</span> TypeError(type(obj))</div>
<div class="line"><span class="lineno"> 2548</span> </div>
<div class="line"><span class="lineno"> 2549</span>        <span class="keywordflow">return</span> self._agg_general(</div>
<div class="line"><span class="lineno"> 2550</span>            numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2551</span>            min_count=min_count,</div>
<div class="line"><span class="lineno"> 2552</span>            alias=<span class="stringliteral">&quot;first&quot;</span>,</div>
<div class="line"><span class="lineno"> 2553</span>            npfunc=first_compat,</div>
<div class="line"><span class="lineno"> 2554</span>        )</div>
<div class="line"><span class="lineno"> 2555</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a78f1160675cd14ffa2152d7892ed0408" name="a78f1160675cd14ffa2152d7892ed0408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f1160675cd14ffa2152d7892ed0408">&#9670;&#160;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.head </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>n</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return first n rows of each group.

Similar to ``.apply(lambda x: x.head(n))``, but it returns a subset of rows
from the original DataFrame with original index and order preserved
(``as_index`` flag is ignored).

Parameters
----------
n : int
    If positive: number of entries to include from start of each group.
    If negative: number of entries to exclude from end of each group.

Returns
-------
Series or DataFrame
    Subset of original Series or DataFrame as determined by n.
%(see_also)s
Examples
--------

&gt;&gt;&gt; df = pd.DataFrame([[1, 2], [1, 4], [5, 6]],
...                   columns=['A', 'B'])
&gt;&gt;&gt; df.groupby('A').head(1)
   A  B
0  1  2
2  5  6
&gt;&gt;&gt; df.groupby('A').head(-1)
   A  B
0  1  2
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3982</span>    <span class="keyword">def </span>head(self, n: int = 5) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3983</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3984</span><span class="stringliteral">        Return first n rows of each group.</span></div>
<div class="line"><span class="lineno"> 3985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3986</span><span class="stringliteral">        Similar to ``.apply(lambda x: x.head(n))``, but it returns a subset of rows</span></div>
<div class="line"><span class="lineno"> 3987</span><span class="stringliteral">        from the original DataFrame with original index and order preserved</span></div>
<div class="line"><span class="lineno"> 3988</span><span class="stringliteral">        (``as_index`` flag is ignored).</span></div>
<div class="line"><span class="lineno"> 3989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3990</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3991</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3992</span><span class="stringliteral">        n : int</span></div>
<div class="line"><span class="lineno"> 3993</span><span class="stringliteral">            If positive: number of entries to include from start of each group.</span></div>
<div class="line"><span class="lineno"> 3994</span><span class="stringliteral">            If negative: number of entries to exclude from end of each group.</span></div>
<div class="line"><span class="lineno"> 3995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3996</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3997</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3998</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3999</span><span class="stringliteral">            Subset of original Series or DataFrame as determined by n.</span></div>
<div class="line"><span class="lineno"> 4000</span><span class="stringliteral">        %(see_also)s</span></div>
<div class="line"><span class="lineno"> 4001</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 4002</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 4003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4004</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [1, 4], [5, 6]],</span></div>
<div class="line"><span class="lineno"> 4005</span><span class="stringliteral">        ...                   columns=[&#39;A&#39;, &#39;B&#39;])</span></div>
<div class="line"><span class="lineno"> 4006</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).head(1)</span></div>
<div class="line"><span class="lineno"> 4007</span><span class="stringliteral">           A  B</span></div>
<div class="line"><span class="lineno"> 4008</span><span class="stringliteral">        0  1  2</span></div>
<div class="line"><span class="lineno"> 4009</span><span class="stringliteral">        2  5  6</span></div>
<div class="line"><span class="lineno"> 4010</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).head(-1)</span></div>
<div class="line"><span class="lineno"> 4011</span><span class="stringliteral">           A  B</span></div>
<div class="line"><span class="lineno"> 4012</span><span class="stringliteral">        0  1  2</span></div>
<div class="line"><span class="lineno"> 4013</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4014</span>        self._reset_group_selection()</div>
<div class="line"><span class="lineno"> 4015</span>        mask = self._make_mask_from_positional_indexer(slice(<span class="keywordtype">None</span>, n))</div>
<div class="line"><span class="lineno"> 4016</span>        <span class="keywordflow">return</span> self._mask_selected_obj(mask)</div>
<div class="line"><span class="lineno"> 4017</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abde1107f7b563ee416464242ffd06918" name="abde1107f7b563ee416464242ffd06918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde1107f7b563ee416464242ffd06918">&#9670;&#160;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the last non-null entry of each column.

Parameters
----------
numeric_only : bool, default False
    Include only float, int, boolean columns. If None, will attempt to use
    everything, then use only numeric data.
min_count : int, default -1
    The required number of valid values to perform the operation. If fewer
    than ``min_count`` non-NA values are present the result will be NA.

Returns
-------
Series or DataFrame
    Last non-null of values within each group.

See Also
--------
DataFrame.groupby : Apply a function groupby to each row or column of a
    DataFrame.
DataFrame.core.groupby.GroupBy.first : Compute the first non-null entry of each
    column.
DataFrame.core.groupby.GroupBy.nth : Take the nth row from each group.

Examples
--------
&gt;&gt;&gt; df = pd.DataFrame(dict(A=[1, 1, 3], B=[5, None, 6], C=[1, 2, 3]))
&gt;&gt;&gt; df.groupby("A").last()
     B  C
A
1  5.0  2
3  6.0  3
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2558</span>    <span class="keyword">def </span>last(self, numeric_only: bool = <span class="keyword">False</span>, min_count: int = -1):</div>
<div class="line"><span class="lineno"> 2559</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral">        Compute the last non-null entry of each column.</span></div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">        numeric_only : bool, default False</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral">            Include only float, int, boolean columns. If None, will attempt to use</span></div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">            everything, then use only numeric data.</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">        min_count : int, default -1</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral">            The required number of valid values to perform the operation. If fewer</span></div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral">            than ``min_count`` non-NA values are present the result will be NA.</span></div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral">            Last non-null of values within each group.</span></div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2577</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2578</span><span class="stringliteral">        DataFrame.groupby : Apply a function groupby to each row or column of a</span></div>
<div class="line"><span class="lineno"> 2579</span><span class="stringliteral">            DataFrame.</span></div>
<div class="line"><span class="lineno"> 2580</span><span class="stringliteral">        DataFrame.core.groupby.GroupBy.first : Compute the first non-null entry of each</span></div>
<div class="line"><span class="lineno"> 2581</span><span class="stringliteral">            column.</span></div>
<div class="line"><span class="lineno"> 2582</span><span class="stringliteral">        DataFrame.core.groupby.GroupBy.nth : Take the nth row from each group.</span></div>
<div class="line"><span class="lineno"> 2583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2584</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame(dict(A=[1, 1, 3], B=[5, None, 6], C=[1, 2, 3]))</span></div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&quot;A&quot;).last()</span></div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral">             B  C</span></div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">        1  5.0  2</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral">        3  6.0  3</span></div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2593</span> </div>
<div class="line"><span class="lineno"> 2594</span>        <span class="keyword">def </span>last_compat(obj: NDFrameT, axis: int = 0):</div>
<div class="line"><span class="lineno"> 2595</span>            <span class="keyword">def </span>last(x: Series):</div>
<div class="line"><span class="lineno"> 2596</span>                <span class="stringliteral">&quot;&quot;&quot;Helper function for last item that isn&#39;t NA.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2597</span>                arr = x.array[notna(x.array)]</div>
<div class="line"><span class="lineno"> 2598</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(arr):</div>
<div class="line"><span class="lineno"> 2599</span>                    <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 2600</span>                <span class="keywordflow">return</span> arr[-1]</div>
<div class="line"><span class="lineno"> 2601</span> </div>
<div class="line"><span class="lineno"> 2602</span>            <span class="keywordflow">if</span> isinstance(obj, DataFrame):</div>
<div class="line"><span class="lineno"> 2603</span>                <span class="keywordflow">return</span> obj.apply(last, axis=axis)</div>
<div class="line"><span class="lineno"> 2604</span>            <span class="keywordflow">elif</span> isinstance(obj, Series):</div>
<div class="line"><span class="lineno"> 2605</span>                <span class="keywordflow">return</span> last(obj)</div>
<div class="line"><span class="lineno"> 2606</span>            <span class="keywordflow">else</span>:  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno"> 2607</span>                <span class="keywordflow">raise</span> TypeError(type(obj))</div>
<div class="line"><span class="lineno"> 2608</span> </div>
<div class="line"><span class="lineno"> 2609</span>        <span class="keywordflow">return</span> self._agg_general(</div>
<div class="line"><span class="lineno"> 2610</span>            numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2611</span>            min_count=min_count,</div>
<div class="line"><span class="lineno"> 2612</span>            alias=<span class="stringliteral">&quot;last&quot;</span>,</div>
<div class="line"><span class="lineno"> 2613</span>            npfunc=last_compat,</div>
<div class="line"><span class="lineno"> 2614</span>        )</div>
<div class="line"><span class="lineno"> 2615</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a995fffc13f0e2705bfe369942592c8c2" name="a995fffc13f0e2705bfe369942592c8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995fffc13f0e2705bfe369942592c8c2">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.max </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, bool] | None &#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2472</span>    ):</div>
<div class="line"><span class="lineno"> 2473</span>        <span class="keywordflow">if</span> maybe_use_numba(engine):</div>
<div class="line"><span class="lineno"> 2474</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1__numba_1_1kernels.html">pandas.core._numba.kernels</a> <span class="keyword">import</span> sliding_min_max</div>
<div class="line"><span class="lineno"> 2475</span> </div>
<div class="line"><span class="lineno"> 2476</span>            <span class="keywordflow">return</span> self._numba_agg_general(sliding_min_max, engine_kwargs, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2477</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2478</span>            <span class="keywordflow">return</span> self._agg_general(</div>
<div class="line"><span class="lineno"> 2479</span>                numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2480</span>                min_count=min_count,</div>
<div class="line"><span class="lineno"> 2481</span>                alias=<span class="stringliteral">&quot;max&quot;</span>,</div>
<div class="line"><span class="lineno"> 2482</span>                npfunc=np.max,</div>
<div class="line"><span class="lineno"> 2483</span>            )</div>
<div class="line"><span class="lineno"> 2484</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1__numba_1_1kernels_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1__numba_1_1kernels.html">pandas.core._numba.kernels</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afc1d83f9ba2d0d7187c2cc270476bd7f" name="afc1d83f9ba2d0d7187c2cc270476bd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1d83f9ba2d0d7187c2cc270476bd7f">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>engine</em> = <code>&quot;cython&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, bool] | None &#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute mean of groups, excluding missing values.

Parameters
----------
numeric_only : bool, default True
    Include only float, int, boolean columns. If None, will attempt to use
    everything, then use only numeric data.

engine : str, default None
    * ``'cython'`` : Runs the operation through C-extensions from cython.
    * ``'numba'`` : Runs the operation through JIT compiled code from numba.
    * ``None`` : Defaults to ``'cython'`` or globally setting
      ``compute.use_numba``

    .. versionadded:: 1.4.0

engine_kwargs : dict, default None
    * For ``'cython'`` engine, there are no accepted ``engine_kwargs``
    * For ``'numba'`` engine, the engine can accept ``nopython``, ``nogil``
      and ``parallel`` dictionary keys. The values must either be ``True`` or
      ``False``. The default ``engine_kwargs`` for the ``'numba'`` engine is
      ``{{'nopython': True, 'nogil': False, 'parallel': False}}``

    .. versionadded:: 1.4.0

Returns
-------
pandas.Series or pandas.DataFrame
%(see_also)s
Examples
--------
&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 1, 2, 1, 2],
...                    'B': [np.nan, 2, 3, 4, 5],
...                    'C': [1, 2, 1, 1, 2]}, columns=['A', 'B', 'C'])

Groupby one column and return the mean of the remaining columns in
each group.

&gt;&gt;&gt; df.groupby('A').mean()
     B         C
A
1  3.0  1.333333
2  4.0  1.500000

Groupby two columns and return the mean of the remaining column.

&gt;&gt;&gt; df.groupby(['A', 'B']).mean()
         C
A B
1 2.0  2.0
  4.0  1.0
2 3.0  1.0
  5.0  2.0

Groupby one column and return the mean of only particular column in
the group.

&gt;&gt;&gt; df.groupby('A')['B'].mean()
A
1    3.0
2    4.0
Name: B, dtype: float64
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2080</span>    ):</div>
<div class="line"><span class="lineno"> 2081</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">        Compute mean of groups, excluding missing values.</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2084</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2085</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2086</span><span class="stringliteral">        numeric_only : bool, default True</span></div>
<div class="line"><span class="lineno"> 2087</span><span class="stringliteral">            Include only float, int, boolean columns. If None, will attempt to use</span></div>
<div class="line"><span class="lineno"> 2088</span><span class="stringliteral">            everything, then use only numeric data.</span></div>
<div class="line"><span class="lineno"> 2089</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2090</span><span class="stringliteral">        engine : str, default None</span></div>
<div class="line"><span class="lineno"> 2091</span><span class="stringliteral">            * ``&#39;cython&#39;`` : Runs the operation through C-extensions from cython.</span></div>
<div class="line"><span class="lineno"> 2092</span><span class="stringliteral">            * ``&#39;numba&#39;`` : Runs the operation through JIT compiled code from numba.</span></div>
<div class="line"><span class="lineno"> 2093</span><span class="stringliteral">            * ``None`` : Defaults to ``&#39;cython&#39;`` or globally setting</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">              ``compute.use_numba``</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral">            .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral">        engine_kwargs : dict, default None</span></div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">            * For ``&#39;cython&#39;`` engine, there are no accepted ``engine_kwargs``</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">            * For ``&#39;numba&#39;`` engine, the engine can accept ``nopython``, ``nogil``</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">              and ``parallel`` dictionary keys. The values must either be ``True`` or</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral">              ``False``. The default ``engine_kwargs`` for the ``&#39;numba&#39;`` engine is</span></div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral">              ``{{&#39;nopython&#39;: True, &#39;nogil&#39;: False, &#39;parallel&#39;: False}}``</span></div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">            .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">        pandas.Series or pandas.DataFrame</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral">        %(see_also)s</span></div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 1, 2, 1, 2],</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">        ...                    &#39;B&#39;: [np.nan, 2, 3, 4, 5],</span></div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">        ...                    &#39;C&#39;: [1, 2, 1, 1, 2]}, columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">        Groupby one column and return the mean of the remaining columns in</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">        each group.</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).mean()</span></div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">             B         C</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">        1  3.0  1.333333</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral">        2  4.0  1.500000</span></div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">        Groupby two columns and return the mean of the remaining column.</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2128</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby([&#39;A&#39;, &#39;B&#39;]).mean()</span></div>
<div class="line"><span class="lineno"> 2129</span><span class="stringliteral">                 C</span></div>
<div class="line"><span class="lineno"> 2130</span><span class="stringliteral">        A B</span></div>
<div class="line"><span class="lineno"> 2131</span><span class="stringliteral">        1 2.0  2.0</span></div>
<div class="line"><span class="lineno"> 2132</span><span class="stringliteral">          4.0  1.0</span></div>
<div class="line"><span class="lineno"> 2133</span><span class="stringliteral">        2 3.0  1.0</span></div>
<div class="line"><span class="lineno"> 2134</span><span class="stringliteral">          5.0  2.0</span></div>
<div class="line"><span class="lineno"> 2135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral">        Groupby one column and return the mean of only particular column in</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral">        the group.</span></div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;)[&#39;B&#39;].mean()</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">        1    3.0</span></div>
<div class="line"><span class="lineno"> 2142</span><span class="stringliteral">        2    4.0</span></div>
<div class="line"><span class="lineno"> 2143</span><span class="stringliteral">        Name: B, dtype: float64</span></div>
<div class="line"><span class="lineno"> 2144</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2145</span>        numeric_only_bool = self._resolve_numeric_only(<span class="stringliteral">&quot;mean&quot;</span>, numeric_only, axis=0)</div>
<div class="line"><span class="lineno"> 2146</span> </div>
<div class="line"><span class="lineno"> 2147</span>        <span class="keywordflow">if</span> maybe_use_numba(engine):</div>
<div class="line"><span class="lineno"> 2148</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1__numba_1_1kernels.html">pandas.core._numba.kernels</a> <span class="keyword">import</span> sliding_mean</div>
<div class="line"><span class="lineno"> 2149</span> </div>
<div class="line"><span class="lineno"> 2150</span>            <span class="keywordflow">return</span> self._numba_agg_general(sliding_mean, engine_kwargs)</div>
<div class="line"><span class="lineno"> 2151</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2152</span>            result = self._cython_agg_general(</div>
<div class="line"><span class="lineno"> 2153</span>                <span class="stringliteral">&quot;mean&quot;</span>,</div>
<div class="line"><span class="lineno"> 2154</span>                alt=<span class="keyword">lambda</span> x: Series(x).mean(numeric_only=numeric_only_bool),</div>
<div class="line"><span class="lineno"> 2155</span>                numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2156</span>            )</div>
<div class="line"><span class="lineno"> 2157</span>            <span class="keywordflow">return</span> result.__finalize__(self.obj, method=<span class="stringliteral">&quot;groupby&quot;</span>)</div>
<div class="line"><span class="lineno"> 2158</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ebfc333d04f0a16c69ed336cc95338a" name="a8ebfc333d04f0a16c69ed336cc95338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebfc333d04f0a16c69ed336cc95338a">&#9670;&#160;</a></span>median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.median </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute median of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex

Parameters
----------
numeric_only : bool, default True
    Include only float, int, boolean columns. If None, will attempt to use
    everything, then use only numeric data.

Returns
-------
Series or DataFrame
    Median of values within each group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2162</span>    <span class="keyword">def </span>median(self, numeric_only: bool | lib.NoDefault = lib.no_default):</div>
<div class="line"><span class="lineno"> 2163</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">        Compute median of groups, excluding missing values.</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">        For multiple groupings, the result index will be a MultiIndex</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral">        numeric_only : bool, default True</span></div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">            Include only float, int, boolean columns. If None, will attempt to use</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral">            everything, then use only numeric data.</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">            Median of values within each group.</span></div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2179</span>        numeric_only_bool = self._resolve_numeric_only(<span class="stringliteral">&quot;median&quot;</span>, numeric_only, axis=0)</div>
<div class="line"><span class="lineno"> 2180</span> </div>
<div class="line"><span class="lineno"> 2181</span>        result = self._cython_agg_general(</div>
<div class="line"><span class="lineno"> 2182</span>            <span class="stringliteral">&quot;median&quot;</span>,</div>
<div class="line"><span class="lineno"> 2183</span>            alt=<span class="keyword">lambda</span> x: Series(x).median(numeric_only=numeric_only_bool),</div>
<div class="line"><span class="lineno"> 2184</span>            numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2185</span>        )</div>
<div class="line"><span class="lineno"> 2186</span>        <span class="keywordflow">return</span> result.__finalize__(self.obj, method=<span class="stringliteral">&quot;groupby&quot;</span>)</div>
<div class="line"><span class="lineno"> 2187</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c716cac1d88960ad119d16601c5ab55" name="a7c716cac1d88960ad119d16601c5ab55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c716cac1d88960ad119d16601c5ab55">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.min </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, bool] | None &#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2451</span>    ):</div>
<div class="line"><span class="lineno"> 2452</span>        <span class="keywordflow">if</span> maybe_use_numba(engine):</div>
<div class="line"><span class="lineno"> 2453</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1__numba_1_1kernels.html">pandas.core._numba.kernels</a> <span class="keyword">import</span> sliding_min_max</div>
<div class="line"><span class="lineno"> 2454</span> </div>
<div class="line"><span class="lineno"> 2455</span>            <span class="keywordflow">return</span> self._numba_agg_general(sliding_min_max, engine_kwargs, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2456</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2457</span>            <span class="keywordflow">return</span> self._agg_general(</div>
<div class="line"><span class="lineno"> 2458</span>                numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2459</span>                min_count=min_count,</div>
<div class="line"><span class="lineno"> 2460</span>                alias=<span class="stringliteral">&quot;min&quot;</span>,</div>
<div class="line"><span class="lineno"> 2461</span>                npfunc=np.min,</div>
<div class="line"><span class="lineno"> 2462</span>            )</div>
<div class="line"><span class="lineno"> 2463</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e0ab5f350005e94a5ff7a77874a9bde" name="a4e0ab5f350005e94a5ff7a77874a9bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0ab5f350005e94a5ff7a77874a9bde">&#9670;&#160;</a></span>ngroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.ngroup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Number each group from 0 to the number of groups - 1.

This is the enumerative complement of cumcount.  Note that the
numbers given to the groups match the order in which the groups
would be seen when iterating over the groupby object, not the
order they are first observed.

Parameters
----------
ascending : bool, default True
    If False, number in reverse, from number of group - 1 to 0.

Returns
-------
Series
    Unique numbers for each group.

See Also
--------
.cumcount : Number the rows in each group.

Examples
--------
&gt;&gt;&gt; df = pd.DataFrame({"A": list("aaabba")})
&gt;&gt;&gt; df
   A
0  a
1  a
2  a
3  b
4  b
5  a
&gt;&gt;&gt; df.groupby('A').ngroup()
0    0
1    0
2    0
3    1
4    1
5    0
dtype: int64
&gt;&gt;&gt; df.groupby('A').ngroup(ascending=False)
0    1
1    1
2    1
3    0
4    0
5    1
dtype: int64
&gt;&gt;&gt; df.groupby(["A", [1,1,2,3,2,1]]).ngroup()
0    0
1    0
2    1
3    3
4    2
5    0
dtype: int64
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3392</span>    <span class="keyword">def </span>ngroup(self, ascending: bool = <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 3393</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3394</span><span class="stringliteral">        Number each group from 0 to the number of groups - 1.</span></div>
<div class="line"><span class="lineno"> 3395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3396</span><span class="stringliteral">        This is the enumerative complement of cumcount.  Note that the</span></div>
<div class="line"><span class="lineno"> 3397</span><span class="stringliteral">        numbers given to the groups match the order in which the groups</span></div>
<div class="line"><span class="lineno"> 3398</span><span class="stringliteral">        would be seen when iterating over the groupby object, not the</span></div>
<div class="line"><span class="lineno"> 3399</span><span class="stringliteral">        order they are first observed.</span></div>
<div class="line"><span class="lineno"> 3400</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3401</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3402</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3403</span><span class="stringliteral">        ascending : bool, default True</span></div>
<div class="line"><span class="lineno"> 3404</span><span class="stringliteral">            If False, number in reverse, from number of group - 1 to 0.</span></div>
<div class="line"><span class="lineno"> 3405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3406</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3407</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3408</span><span class="stringliteral">        Series</span></div>
<div class="line"><span class="lineno"> 3409</span><span class="stringliteral">            Unique numbers for each group.</span></div>
<div class="line"><span class="lineno"> 3410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3411</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 3412</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3413</span><span class="stringliteral">        .cumcount : Number the rows in each group.</span></div>
<div class="line"><span class="lineno"> 3414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3415</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3416</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3417</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: list(&quot;aaabba&quot;)})</span></div>
<div class="line"><span class="lineno"> 3418</span><span class="stringliteral">        &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 3419</span><span class="stringliteral">           A</span></div>
<div class="line"><span class="lineno"> 3420</span><span class="stringliteral">        0  a</span></div>
<div class="line"><span class="lineno"> 3421</span><span class="stringliteral">        1  a</span></div>
<div class="line"><span class="lineno"> 3422</span><span class="stringliteral">        2  a</span></div>
<div class="line"><span class="lineno"> 3423</span><span class="stringliteral">        3  b</span></div>
<div class="line"><span class="lineno"> 3424</span><span class="stringliteral">        4  b</span></div>
<div class="line"><span class="lineno"> 3425</span><span class="stringliteral">        5  a</span></div>
<div class="line"><span class="lineno"> 3426</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).ngroup()</span></div>
<div class="line"><span class="lineno"> 3427</span><span class="stringliteral">        0    0</span></div>
<div class="line"><span class="lineno"> 3428</span><span class="stringliteral">        1    0</span></div>
<div class="line"><span class="lineno"> 3429</span><span class="stringliteral">        2    0</span></div>
<div class="line"><span class="lineno"> 3430</span><span class="stringliteral">        3    1</span></div>
<div class="line"><span class="lineno"> 3431</span><span class="stringliteral">        4    1</span></div>
<div class="line"><span class="lineno"> 3432</span><span class="stringliteral">        5    0</span></div>
<div class="line"><span class="lineno"> 3433</span><span class="stringliteral">        dtype: int64</span></div>
<div class="line"><span class="lineno"> 3434</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).ngroup(ascending=False)</span></div>
<div class="line"><span class="lineno"> 3435</span><span class="stringliteral">        0    1</span></div>
<div class="line"><span class="lineno"> 3436</span><span class="stringliteral">        1    1</span></div>
<div class="line"><span class="lineno"> 3437</span><span class="stringliteral">        2    1</span></div>
<div class="line"><span class="lineno"> 3438</span><span class="stringliteral">        3    0</span></div>
<div class="line"><span class="lineno"> 3439</span><span class="stringliteral">        4    0</span></div>
<div class="line"><span class="lineno"> 3440</span><span class="stringliteral">        5    1</span></div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral">        dtype: int64</span></div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby([&quot;A&quot;, [1,1,2,3,2,1]]).ngroup()</span></div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral">        0    0</span></div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral">        1    0</span></div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">        2    1</span></div>
<div class="line"><span class="lineno"> 3446</span><span class="stringliteral">        3    3</span></div>
<div class="line"><span class="lineno"> 3447</span><span class="stringliteral">        4    2</span></div>
<div class="line"><span class="lineno"> 3448</span><span class="stringliteral">        5    0</span></div>
<div class="line"><span class="lineno"> 3449</span><span class="stringliteral">        dtype: int64</span></div>
<div class="line"><span class="lineno"> 3450</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3451</span>        <span class="keyword">with</span> self._group_selection_context():</div>
<div class="line"><span class="lineno"> 3452</span>            index = self._selected_obj.index</div>
<div class="line"><span class="lineno"> 3453</span>            comp_ids = self.grouper.group_info[0]</div>
<div class="line"><span class="lineno"> 3454</span> </div>
<div class="line"><span class="lineno"> 3455</span>            dtype: type</div>
<div class="line"><span class="lineno"> 3456</span>            <span class="keywordflow">if</span> self.grouper.has_dropped_na:</div>
<div class="line"><span class="lineno"> 3457</span>                comp_ids = np.where(comp_ids == -1, np.nan, comp_ids)</div>
<div class="line"><span class="lineno"> 3458</span>                dtype = np.float64</div>
<div class="line"><span class="lineno"> 3459</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3460</span>                dtype = np.int64</div>
<div class="line"><span class="lineno"> 3461</span> </div>
<div class="line"><span class="lineno"> 3462</span>            result = self._obj_1d_constructor(comp_ids, index, dtype=dtype)</div>
<div class="line"><span class="lineno"> 3463</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> ascending:</div>
<div class="line"><span class="lineno"> 3464</span>                result = self.ngroups - 1 - result</div>
<div class="line"><span class="lineno"> 3465</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3466</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a99dc3aa9708151309c8e76d075ae458a" name="a99dc3aa9708151309c8e76d075ae458a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dc3aa9708151309c8e76d075ae458a">&#9670;&#160;</a></span>nth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1groupby_1_1indexing_1_1_group_by_nth_selector.html">GroupByNthSelector</a> pandas.core.groupby.groupby.GroupBy.nth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take the nth row from each group if n is an int, otherwise a subset of rows.

Can be either a call or an index. dropna is not available with index notation.
Index notation accepts a comma separated list of integers and slices.

If dropna, will take the nth non-null row, dropna is either
'all' or 'any'; this is equivalent to calling dropna(how=dropna)
before the groupby.

Parameters
----------
n : int, slice or list of ints and slices
    A single nth value for the row or a list of nth values or slices.

    .. versionchanged:: 1.4.0
        Added slice and lists containing slices.
        Added index notation.

dropna : {'any', 'all', None}, default None
    Apply the specified dropna operation before counting which row is
    the nth row. Only supported if n is an int.

Returns
-------
Series or DataFrame
    N-th value within each group.
%(see_also)s
Examples
--------

&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 1, 2, 1, 2],
...                    'B': [np.nan, 2, 3, 4, 5]}, columns=['A', 'B'])
&gt;&gt;&gt; g = df.groupby('A')
&gt;&gt;&gt; g.nth(0)
     B
A
1  NaN
2  3.0
&gt;&gt;&gt; g.nth(1)
     B
A
1  2.0
2  5.0
&gt;&gt;&gt; g.nth(-1)
     B
A
1  4.0
2  5.0
&gt;&gt;&gt; g.nth([0, 1])
     B
A
1  NaN
1  2.0
2  3.0
2  5.0
&gt;&gt;&gt; g.nth(slice(None, -1))
     B
A
1  NaN
1  2.0
2  3.0

Index notation may also be used

&gt;&gt;&gt; g.nth[0, 1]
     B
A
1  NaN
1  2.0
2  3.0
2  5.0
&gt;&gt;&gt; g.nth[:-1]
     B
A
1  NaN
1  2.0
2  3.0

Specifying `dropna` allows count ignoring ``NaN``

&gt;&gt;&gt; g.nth(0, dropna='any')
     B
A
1  2.0
2  3.0

NaNs denote group exhausted when using dropna

&gt;&gt;&gt; g.nth(3, dropna='any')
    B
A
1 NaN
2 NaN

Specifying `as_index=False` in `groupby` keeps the original index.

&gt;&gt;&gt; df.groupby('A', as_index=False).nth(1)
   A    B
1  1  2.0
4  2  5.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3015</span>    <span class="keyword">def </span>nth(self) -&gt; GroupByNthSelector:</div>
<div class="line"><span class="lineno"> 3016</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3017</span><span class="stringliteral">        Take the nth row from each group if n is an int, otherwise a subset of rows.</span></div>
<div class="line"><span class="lineno"> 3018</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3019</span><span class="stringliteral">        Can be either a call or an index. dropna is not available with index notation.</span></div>
<div class="line"><span class="lineno"> 3020</span><span class="stringliteral">        Index notation accepts a comma separated list of integers and slices.</span></div>
<div class="line"><span class="lineno"> 3021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3022</span><span class="stringliteral">        If dropna, will take the nth non-null row, dropna is either</span></div>
<div class="line"><span class="lineno"> 3023</span><span class="stringliteral">        &#39;all&#39; or &#39;any&#39;; this is equivalent to calling dropna(how=dropna)</span></div>
<div class="line"><span class="lineno"> 3024</span><span class="stringliteral">        before the groupby.</span></div>
<div class="line"><span class="lineno"> 3025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3026</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3027</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3028</span><span class="stringliteral">        n : int, slice or list of ints and slices</span></div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral">            A single nth value for the row or a list of nth values or slices.</span></div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3031</span><span class="stringliteral">            .. versionchanged:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 3032</span><span class="stringliteral">                Added slice and lists containing slices.</span></div>
<div class="line"><span class="lineno"> 3033</span><span class="stringliteral">                Added index notation.</span></div>
<div class="line"><span class="lineno"> 3034</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3035</span><span class="stringliteral">        dropna : {&#39;any&#39;, &#39;all&#39;, None}, default None</span></div>
<div class="line"><span class="lineno"> 3036</span><span class="stringliteral">            Apply the specified dropna operation before counting which row is</span></div>
<div class="line"><span class="lineno"> 3037</span><span class="stringliteral">            the nth row. Only supported if n is an int.</span></div>
<div class="line"><span class="lineno"> 3038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3039</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3040</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3041</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3042</span><span class="stringliteral">            N-th value within each group.</span></div>
<div class="line"><span class="lineno"> 3043</span><span class="stringliteral">        %(see_also)s</span></div>
<div class="line"><span class="lineno"> 3044</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3045</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3046</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3047</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 1, 2, 1, 2],</span></div>
<div class="line"><span class="lineno"> 3048</span><span class="stringliteral">        ...                    &#39;B&#39;: [np.nan, 2, 3, 4, 5]}, columns=[&#39;A&#39;, &#39;B&#39;])</span></div>
<div class="line"><span class="lineno"> 3049</span><span class="stringliteral">        &gt;&gt;&gt; g = df.groupby(&#39;A&#39;)</span></div>
<div class="line"><span class="lineno"> 3050</span><span class="stringliteral">        &gt;&gt;&gt; g.nth(0)</span></div>
<div class="line"><span class="lineno"> 3051</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3052</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3053</span><span class="stringliteral">        1  NaN</span></div>
<div class="line"><span class="lineno"> 3054</span><span class="stringliteral">        2  3.0</span></div>
<div class="line"><span class="lineno"> 3055</span><span class="stringliteral">        &gt;&gt;&gt; g.nth(1)</span></div>
<div class="line"><span class="lineno"> 3056</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3057</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3058</span><span class="stringliteral">        1  2.0</span></div>
<div class="line"><span class="lineno"> 3059</span><span class="stringliteral">        2  5.0</span></div>
<div class="line"><span class="lineno"> 3060</span><span class="stringliteral">        &gt;&gt;&gt; g.nth(-1)</span></div>
<div class="line"><span class="lineno"> 3061</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3062</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3063</span><span class="stringliteral">        1  4.0</span></div>
<div class="line"><span class="lineno"> 3064</span><span class="stringliteral">        2  5.0</span></div>
<div class="line"><span class="lineno"> 3065</span><span class="stringliteral">        &gt;&gt;&gt; g.nth([0, 1])</span></div>
<div class="line"><span class="lineno"> 3066</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3067</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3068</span><span class="stringliteral">        1  NaN</span></div>
<div class="line"><span class="lineno"> 3069</span><span class="stringliteral">        1  2.0</span></div>
<div class="line"><span class="lineno"> 3070</span><span class="stringliteral">        2  3.0</span></div>
<div class="line"><span class="lineno"> 3071</span><span class="stringliteral">        2  5.0</span></div>
<div class="line"><span class="lineno"> 3072</span><span class="stringliteral">        &gt;&gt;&gt; g.nth(slice(None, -1))</span></div>
<div class="line"><span class="lineno"> 3073</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3074</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3075</span><span class="stringliteral">        1  NaN</span></div>
<div class="line"><span class="lineno"> 3076</span><span class="stringliteral">        1  2.0</span></div>
<div class="line"><span class="lineno"> 3077</span><span class="stringliteral">        2  3.0</span></div>
<div class="line"><span class="lineno"> 3078</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3079</span><span class="stringliteral">        Index notation may also be used</span></div>
<div class="line"><span class="lineno"> 3080</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3081</span><span class="stringliteral">        &gt;&gt;&gt; g.nth[0, 1]</span></div>
<div class="line"><span class="lineno"> 3082</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3083</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3084</span><span class="stringliteral">        1  NaN</span></div>
<div class="line"><span class="lineno"> 3085</span><span class="stringliteral">        1  2.0</span></div>
<div class="line"><span class="lineno"> 3086</span><span class="stringliteral">        2  3.0</span></div>
<div class="line"><span class="lineno"> 3087</span><span class="stringliteral">        2  5.0</span></div>
<div class="line"><span class="lineno"> 3088</span><span class="stringliteral">        &gt;&gt;&gt; g.nth[:-1]</span></div>
<div class="line"><span class="lineno"> 3089</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3090</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3091</span><span class="stringliteral">        1  NaN</span></div>
<div class="line"><span class="lineno"> 3092</span><span class="stringliteral">        1  2.0</span></div>
<div class="line"><span class="lineno"> 3093</span><span class="stringliteral">        2  3.0</span></div>
<div class="line"><span class="lineno"> 3094</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3095</span><span class="stringliteral">        Specifying `dropna` allows count ignoring ``NaN``</span></div>
<div class="line"><span class="lineno"> 3096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3097</span><span class="stringliteral">        &gt;&gt;&gt; g.nth(0, dropna=&#39;any&#39;)</span></div>
<div class="line"><span class="lineno"> 3098</span><span class="stringliteral">             B</span></div>
<div class="line"><span class="lineno"> 3099</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3100</span><span class="stringliteral">        1  2.0</span></div>
<div class="line"><span class="lineno"> 3101</span><span class="stringliteral">        2  3.0</span></div>
<div class="line"><span class="lineno"> 3102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3103</span><span class="stringliteral">        NaNs denote group exhausted when using dropna</span></div>
<div class="line"><span class="lineno"> 3104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3105</span><span class="stringliteral">        &gt;&gt;&gt; g.nth(3, dropna=&#39;any&#39;)</span></div>
<div class="line"><span class="lineno"> 3106</span><span class="stringliteral">            B</span></div>
<div class="line"><span class="lineno"> 3107</span><span class="stringliteral">        A</span></div>
<div class="line"><span class="lineno"> 3108</span><span class="stringliteral">        1 NaN</span></div>
<div class="line"><span class="lineno"> 3109</span><span class="stringliteral">        2 NaN</span></div>
<div class="line"><span class="lineno"> 3110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3111</span><span class="stringliteral">        Specifying `as_index=False` in `groupby` keeps the original index.</span></div>
<div class="line"><span class="lineno"> 3112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3113</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;, as_index=False).nth(1)</span></div>
<div class="line"><span class="lineno"> 3114</span><span class="stringliteral">           A    B</span></div>
<div class="line"><span class="lineno"> 3115</span><span class="stringliteral">        1  1  2.0</span></div>
<div class="line"><span class="lineno"> 3116</span><span class="stringliteral">        4  2  5.0</span></div>
<div class="line"><span class="lineno"> 3117</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3118</span>        <span class="keywordflow">return</span> GroupByNthSelector(self)</div>
<div class="line"><span class="lineno"> 3119</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a94e9ea883682f3e31624abd0170195a3" name="a94e9ea883682f3e31624abd0170195a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9ea883682f3e31624abd0170195a3">&#9670;&#160;</a></span>ohlc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> pandas.core.groupby.groupby.GroupBy.ohlc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute open, high, low and close values of a group, excluding missing values.

For multiple groupings, the result index will be a MultiIndex

Returns
-------
DataFrame
    Open, high, low and close values within each group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2619</span>    <span class="keyword">def </span>ohlc(self) -&gt; DataFrame:</div>
<div class="line"><span class="lineno"> 2620</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2621</span><span class="stringliteral">        Compute open, high, low and close values of a group, excluding missing values.</span></div>
<div class="line"><span class="lineno"> 2622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2623</span><span class="stringliteral">        For multiple groupings, the result index will be a MultiIndex</span></div>
<div class="line"><span class="lineno"> 2624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2625</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral">        DataFrame</span></div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral">            Open, high, low and close values within each group.</span></div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2630</span>        <span class="keywordflow">if</span> self.obj.ndim == 1:</div>
<div class="line"><span class="lineno"> 2631</span>            <span class="comment"># self._iterate_slices() yields only self._selected_obj</span></div>
<div class="line"><span class="lineno"> 2632</span>            obj = self._selected_obj</div>
<div class="line"><span class="lineno"> 2633</span> </div>
<div class="line"><span class="lineno"> 2634</span>            is_numeric = is_numeric_dtype(obj.dtype)</div>
<div class="line"><span class="lineno"> 2635</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_numeric:</div>
<div class="line"><span class="lineno"> 2636</span>                <span class="keywordflow">raise</span> DataError(<span class="stringliteral">&quot;No numeric types to aggregate&quot;</span>)</div>
<div class="line"><span class="lineno"> 2637</span> </div>
<div class="line"><span class="lineno"> 2638</span>            res_values = self.grouper._cython_operation(</div>
<div class="line"><span class="lineno"> 2639</span>                <span class="stringliteral">&quot;aggregate&quot;</span>, obj._values, <span class="stringliteral">&quot;ohlc&quot;</span>, axis=0, min_count=-1</div>
<div class="line"><span class="lineno"> 2640</span>            )</div>
<div class="line"><span class="lineno"> 2641</span> </div>
<div class="line"><span class="lineno"> 2642</span>            agg_names = [<span class="stringliteral">&quot;open&quot;</span>, <span class="stringliteral">&quot;high&quot;</span>, <span class="stringliteral">&quot;low&quot;</span>, <span class="stringliteral">&quot;close&quot;</span>]</div>
<div class="line"><span class="lineno"> 2643</span>            result = self.obj._constructor_expanddim(</div>
<div class="line"><span class="lineno"> 2644</span>                res_values, index=self.grouper.result_index, columns=agg_names</div>
<div class="line"><span class="lineno"> 2645</span>            )</div>
<div class="line"><span class="lineno"> 2646</span>            <span class="keywordflow">return</span> self._reindex_output(result)</div>
<div class="line"><span class="lineno"> 2647</span> </div>
<div class="line"><span class="lineno"> 2648</span>        <span class="keywordflow">return</span> self._apply_to_column_groupbys(</div>
<div class="line"><span class="lineno"> 2649</span>            <span class="keyword">lambda</span> x: x.ohlc(), self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 2650</span>        )</div>
<div class="line"><span class="lineno"> 2651</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a06b63a7756867fcf6d9923b31c177158" name="a06b63a7756867fcf6d9923b31c177158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b63a7756867fcf6d9923b31c177158">&#9670;&#160;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.pad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Forward fill the values.

.. deprecated:: 1.4
    Use ffill instead.

Parameters
----------
limit : int, optional
    Limit of how many values to fill.

Returns
-------
Series or DataFrame
    Object with missing values filled.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2934</span>    <span class="keyword">def </span>pad(self, limit=None):</div>
<div class="line"><span class="lineno"> 2935</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2936</span><span class="stringliteral">        Forward fill the values.</span></div>
<div class="line"><span class="lineno"> 2937</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2938</span><span class="stringliteral">        .. deprecated:: 1.4</span></div>
<div class="line"><span class="lineno"> 2939</span><span class="stringliteral">            Use ffill instead.</span></div>
<div class="line"><span class="lineno"> 2940</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2941</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2942</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2943</span><span class="stringliteral">        limit : int, optional</span></div>
<div class="line"><span class="lineno"> 2944</span><span class="stringliteral">            Limit of how many values to fill.</span></div>
<div class="line"><span class="lineno"> 2945</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2946</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2947</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2948</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2949</span><span class="stringliteral">            Object with missing values filled.</span></div>
<div class="line"><span class="lineno"> 2950</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2951</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 2952</span>            <span class="stringliteral">&quot;pad is deprecated and will be removed in a future version. &quot;</span></div>
<div class="line"><span class="lineno"> 2953</span>            <span class="stringliteral">&quot;Use ffill instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2954</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 2955</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 2956</span>        )</div>
<div class="line"><span class="lineno"> 2957</span>        <span class="keywordflow">return</span> self.ffill(limit=limit)</div>
<div class="line"><span class="lineno"> 2958</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a025ca8bbcf1e6600ae14b1aa34dea5cd" name="a025ca8bbcf1e6600ae14b1aa34dea5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025ca8bbcf1e6600ae14b1aa34dea5cd">&#9670;&#160;</a></span>pct_change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.pct_change </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>periods</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_method</em> = <code>&quot;ffill&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>freq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate pct_change of each value to previous entry in group.

Returns
-------
Series or DataFrame
    Percentage changes within each group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3948</span>    <span class="keyword">def </span>pct_change(self, periods=1, fill_method=&quot;ffill&quot;, limit=None, freq=None, axis=0):</div>
<div class="line"><span class="lineno"> 3949</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3950</span><span class="stringliteral">        Calculate pct_change of each value to previous entry in group.</span></div>
<div class="line"><span class="lineno"> 3951</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3952</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3953</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3954</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3955</span><span class="stringliteral">            Percentage changes within each group.</span></div>
<div class="line"><span class="lineno"> 3956</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3957</span>        <span class="comment"># TODO(GH#23918): Remove this conditional for SeriesGroupBy when</span></div>
<div class="line"><span class="lineno"> 3958</span>        <span class="comment">#  GH#23918 is fixed</span></div>
<div class="line"><span class="lineno"> 3959</span>        <span class="keywordflow">if</span> freq <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3960</span>            f = <span class="keyword">lambda</span> x: x.pct_change(</div>
<div class="line"><span class="lineno"> 3961</span>                periods=periods,</div>
<div class="line"><span class="lineno"> 3962</span>                fill_method=fill_method,</div>
<div class="line"><span class="lineno"> 3963</span>                limit=limit,</div>
<div class="line"><span class="lineno"> 3964</span>                freq=freq,</div>
<div class="line"><span class="lineno"> 3965</span>                axis=axis,</div>
<div class="line"><span class="lineno"> 3966</span>            )</div>
<div class="line"><span class="lineno"> 3967</span>            <span class="keywordflow">return</span> self._python_apply_general(f, self._selected_obj, is_transform=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3968</span> </div>
<div class="line"><span class="lineno"> 3969</span>        <span class="keywordflow">if</span> fill_method <span class="keywordflow">is</span> <span class="keywordtype">None</span>:  <span class="comment"># GH30463</span></div>
<div class="line"><span class="lineno"> 3970</span>            fill_method = <span class="stringliteral">&quot;ffill&quot;</span></div>
<div class="line"><span class="lineno"> 3971</span>            limit = 0</div>
<div class="line"><span class="lineno"> 3972</span>        filled = getattr(self, fill_method)(limit=limit)</div>
<div class="line"><span class="lineno"> 3973</span>        fill_grp = filled.groupby(</div>
<div class="line"><span class="lineno"> 3974</span>            self.grouper.codes, axis=self.axis, group_keys=self.group_keys</div>
<div class="line"><span class="lineno"> 3975</span>        )</div>
<div class="line"><span class="lineno"> 3976</span>        shifted = fill_grp.shift(periods=periods, freq=freq, axis=self.axis)</div>
<div class="line"><span class="lineno"> 3977</span>        <span class="keywordflow">return</span> (filled / shifted) - 1</div>
<div class="line"><span class="lineno"> 3978</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa63487cbbe0689953baab3bcef598288" name="aa63487cbbe0689953baab3bcef598288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63487cbbe0689953baab3bcef598288">&#9670;&#160;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.prod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2438</span>    ):</div>
<div class="line"><span class="lineno"> 2439</span>        <span class="keywordflow">return</span> self._agg_general(</div>
<div class="line"><span class="lineno"> 2440</span>            numeric_only=numeric_only, min_count=min_count, alias=<span class="stringliteral">&quot;prod&quot;</span>, npfunc=np.prod</div>
<div class="line"><span class="lineno"> 2441</span>        )</div>
<div class="line"><span class="lineno"> 2442</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af18e71ddc461771884209ddf5e199369" name="af18e71ddc461771884209ddf5e199369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18e71ddc461771884209ddf5e199369">&#9670;&#160;</a></span>quantile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.quantile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return group values at the given quantile, a la numpy.percentile.

Parameters
----------
q : float or array-like, default 0.5 (50% quantile)
    Value(s) between 0 and 1 providing the quantile(s) to compute.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    Method to use when the desired quantile falls between two points.
numeric_only : bool, default True
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

Returns
-------
Series or DataFrame
    Return type determined by caller of GroupBy object.

See Also
--------
Series.quantile : Similar method for Series.
DataFrame.quantile : Similar method for DataFrame.
numpy.percentile : NumPy method to compute qth percentile.

Examples
--------
&gt;&gt;&gt; df = pd.DataFrame([
...     ['a', 1], ['a', 2], ['a', 3],
...     ['b', 1], ['b', 3], ['b', 5]
... ], columns=['key', 'val'])
&gt;&gt;&gt; df.groupby('key').quantile()
    val
key
a    2.0
b    3.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3218</span>    ):</div>
<div class="line"><span class="lineno"> 3219</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3220</span><span class="stringliteral">        Return group values at the given quantile, a la numpy.percentile.</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3224</span><span class="stringliteral">        q : float or array-like, default 0.5 (50% quantile)</span></div>
<div class="line"><span class="lineno"> 3225</span><span class="stringliteral">            Value(s) between 0 and 1 providing the quantile(s) to compute.</span></div>
<div class="line"><span class="lineno"> 3226</span><span class="stringliteral">        interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span></div>
<div class="line"><span class="lineno"> 3227</span><span class="stringliteral">            Method to use when the desired quantile falls between two points.</span></div>
<div class="line"><span class="lineno"> 3228</span><span class="stringliteral">        numeric_only : bool, default True</span></div>
<div class="line"><span class="lineno"> 3229</span><span class="stringliteral">            Include only `float`, `int` or `boolean` data.</span></div>
<div class="line"><span class="lineno"> 3230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3231</span><span class="stringliteral">            .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 3232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3233</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3234</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3235</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3236</span><span class="stringliteral">            Return type determined by caller of GroupBy object.</span></div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">        Series.quantile : Similar method for Series.</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral">        DataFrame.quantile : Similar method for DataFrame.</span></div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral">        numpy.percentile : NumPy method to compute qth percentile.</span></div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame([</span></div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">        ...     [&#39;a&#39;, 1], [&#39;a&#39;, 2], [&#39;a&#39;, 3],</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">        ...     [&#39;b&#39;, 1], [&#39;b&#39;, 3], [&#39;b&#39;, 5]</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral">        ... ], columns=[&#39;key&#39;, &#39;val&#39;])</span></div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;key&#39;).quantile()</span></div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral">            val</span></div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral">        key</span></div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral">        a    2.0</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">        b    3.0</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3256</span>        numeric_only_bool = self._resolve_numeric_only(<span class="stringliteral">&quot;quantile&quot;</span>, numeric_only, axis=0)</div>
<div class="line"><span class="lineno"> 3257</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3258</span>            numeric_only_bool</div>
<div class="line"><span class="lineno"> 3259</span>            <span class="keywordflow">and</span> self.obj.ndim == 1</div>
<div class="line"><span class="lineno"> 3260</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_numeric_dtype(self.obj.dtype)</div>
<div class="line"><span class="lineno"> 3261</span>        ):</div>
<div class="line"><span class="lineno"> 3262</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 3263</span>                f<span class="stringliteral">&quot;{type(self).__name__}.quantile called with &quot;</span></div>
<div class="line"><span class="lineno"> 3264</span>                f<span class="stringliteral">&quot;numeric_only={numeric_only} and dtype {self.obj.dtype}&quot;</span></div>
<div class="line"><span class="lineno"> 3265</span>            )</div>
<div class="line"><span class="lineno"> 3266</span> </div>
<div class="line"><span class="lineno"> 3267</span>        <span class="keyword">def </span>pre_processor(vals: ArrayLike) -&gt; tuple[np.ndarray, np.dtype | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 3268</span>            <span class="keywordflow">if</span> is_object_dtype(vals):</div>
<div class="line"><span class="lineno"> 3269</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 3270</span>                    <span class="stringliteral">&quot;&#39;quantile&#39; cannot be performed against &#39;object&#39; dtypes!&quot;</span></div>
<div class="line"><span class="lineno"> 3271</span>                )</div>
<div class="line"><span class="lineno"> 3272</span> </div>
<div class="line"><span class="lineno"> 3273</span>            inference: np.dtype | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3274</span>            <span class="keywordflow">if</span> is_integer_dtype(vals.dtype):</div>
<div class="line"><span class="lineno"> 3275</span>                <span class="keywordflow">if</span> isinstance(vals, ExtensionArray):</div>
<div class="line"><span class="lineno"> 3276</span>                    out = vals.to_numpy(dtype=float, na_value=np.nan)</div>
<div class="line"><span class="lineno"> 3277</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3278</span>                    out = vals</div>
<div class="line"><span class="lineno"> 3279</span>                inference = np.dtype(np.int64)</div>
<div class="line"><span class="lineno"> 3280</span>            <span class="keywordflow">elif</span> is_bool_dtype(vals.dtype) <span class="keywordflow">and</span> isinstance(vals, ExtensionArray):</div>
<div class="line"><span class="lineno"> 3281</span>                out = vals.to_numpy(dtype=float, na_value=np.nan)</div>
<div class="line"><span class="lineno"> 3282</span>            <span class="keywordflow">elif</span> is_datetime64_dtype(vals.dtype):</div>
<div class="line"><span class="lineno"> 3283</span>                inference = np.dtype(<span class="stringliteral">&quot;datetime64[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 3284</span>                out = np.asarray(vals).astype(float)</div>
<div class="line"><span class="lineno"> 3285</span>            <span class="keywordflow">elif</span> is_timedelta64_dtype(vals.dtype):</div>
<div class="line"><span class="lineno"> 3286</span>                inference = np.dtype(<span class="stringliteral">&quot;timedelta64[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 3287</span>                out = np.asarray(vals).astype(float)</div>
<div class="line"><span class="lineno"> 3288</span>            <span class="keywordflow">elif</span> isinstance(vals, ExtensionArray) <span class="keywordflow">and</span> is_float_dtype(vals):</div>
<div class="line"><span class="lineno"> 3289</span>                inference = np.dtype(np.float64)</div>
<div class="line"><span class="lineno"> 3290</span>                out = vals.to_numpy(dtype=float, na_value=np.nan)</div>
<div class="line"><span class="lineno"> 3291</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3292</span>                out = np.asarray(vals)</div>
<div class="line"><span class="lineno"> 3293</span> </div>
<div class="line"><span class="lineno"> 3294</span>            <span class="keywordflow">return</span> out, inference</div>
<div class="line"><span class="lineno"> 3295</span> </div>
<div class="line"><span class="lineno"> 3296</span>        <span class="keyword">def </span>post_processor(vals: np.ndarray, inference: np.dtype | <span class="keywordtype">None</span>) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 3297</span>            <span class="keywordflow">if</span> inference:</div>
<div class="line"><span class="lineno"> 3298</span>                <span class="comment"># Check for edge case</span></div>
<div class="line"><span class="lineno"> 3299</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno"> 3300</span>                    is_integer_dtype(inference)</div>
<div class="line"><span class="lineno"> 3301</span>                    <span class="keywordflow">and</span> interpolation <span class="keywordflow">in</span> {<span class="stringliteral">&quot;linear&quot;</span>, <span class="stringliteral">&quot;midpoint&quot;</span>}</div>
<div class="line"><span class="lineno"> 3302</span>                ):</div>
<div class="line"><span class="lineno"> 3303</span>                    vals = vals.astype(inference)</div>
<div class="line"><span class="lineno"> 3304</span> </div>
<div class="line"><span class="lineno"> 3305</span>            <span class="keywordflow">return</span> vals</div>
<div class="line"><span class="lineno"> 3306</span> </div>
<div class="line"><span class="lineno"> 3307</span>        orig_scalar = is_scalar(q)</div>
<div class="line"><span class="lineno"> 3308</span>        <span class="keywordflow">if</span> orig_scalar:</div>
<div class="line"><span class="lineno"> 3309</span>            q = [q]</div>
<div class="line"><span class="lineno"> 3310</span> </div>
<div class="line"><span class="lineno"> 3311</span>        qs = np.array(q, dtype=np.float64)</div>
<div class="line"><span class="lineno"> 3312</span>        ids, _, ngroups = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 3313</span>        nqs = len(qs)</div>
<div class="line"><span class="lineno"> 3314</span> </div>
<div class="line"><span class="lineno"> 3315</span>        func = partial(</div>
<div class="line"><span class="lineno"> 3316</span>            libgroupby.group_quantile, labels=ids, qs=qs, interpolation=interpolation</div>
<div class="line"><span class="lineno"> 3317</span>        )</div>
<div class="line"><span class="lineno"> 3318</span> </div>
<div class="line"><span class="lineno"> 3319</span>        <span class="comment"># Put &#39;-1&#39; (NaN) labels as the last group so it does not interfere</span></div>
<div class="line"><span class="lineno"> 3320</span>        <span class="comment"># with the calculations. Note: length check avoids failure on empty</span></div>
<div class="line"><span class="lineno"> 3321</span>        <span class="comment"># labels. In that case, the value doesn&#39;t matter</span></div>
<div class="line"><span class="lineno"> 3322</span>        na_label_for_sorting = ids.max() + 1 <span class="keywordflow">if</span> len(ids) &gt; 0 <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno"> 3323</span>        labels_for_lexsort = np.where(ids == -1, na_label_for_sorting, ids)</div>
<div class="line"><span class="lineno"> 3324</span> </div>
<div class="line"><span class="lineno"> 3325</span>        <span class="keyword">def </span>blk_func(values: ArrayLike) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 3326</span>            mask = isna(values)</div>
<div class="line"><span class="lineno"> 3327</span>            vals, inference = pre_processor(values)</div>
<div class="line"><span class="lineno"> 3328</span> </div>
<div class="line"><span class="lineno"> 3329</span>            ncols = 1</div>
<div class="line"><span class="lineno"> 3330</span>            <span class="keywordflow">if</span> vals.ndim == 2:</div>
<div class="line"><span class="lineno"> 3331</span>                ncols = vals.shape[0]</div>
<div class="line"><span class="lineno"> 3332</span>                shaped_labels = np.broadcast_to(</div>
<div class="line"><span class="lineno"> 3333</span>                    labels_for_lexsort, (ncols, len(labels_for_lexsort))</div>
<div class="line"><span class="lineno"> 3334</span>                )</div>
<div class="line"><span class="lineno"> 3335</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3336</span>                shaped_labels = labels_for_lexsort</div>
<div class="line"><span class="lineno"> 3337</span> </div>
<div class="line"><span class="lineno"> 3338</span>            out = np.empty((ncols, ngroups, nqs), dtype=np.float64)</div>
<div class="line"><span class="lineno"> 3339</span> </div>
<div class="line"><span class="lineno"> 3340</span>            <span class="comment"># Get an index of values sorted by values and then labels</span></div>
<div class="line"><span class="lineno"> 3341</span>            order = (vals, shaped_labels)</div>
<div class="line"><span class="lineno"> 3342</span>            sort_arr = np.lexsort(order).astype(np.intp, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3343</span> </div>
<div class="line"><span class="lineno"> 3344</span>            <span class="keywordflow">if</span> vals.ndim == 1:</div>
<div class="line"><span class="lineno"> 3345</span>                <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(out[0], values=vals, mask=mask, sort_indexer=sort_arr)</div>
<div class="line"><span class="lineno"> 3346</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3347</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(ncols):</div>
<div class="line"><span class="lineno"> 3348</span>                    <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(out[i], values=vals[i], mask=mask[i], sort_indexer=sort_arr[i])</div>
<div class="line"><span class="lineno"> 3349</span> </div>
<div class="line"><span class="lineno"> 3350</span>            <span class="keywordflow">if</span> vals.ndim == 1:</div>
<div class="line"><span class="lineno"> 3351</span>                out = out.ravel(<span class="stringliteral">&quot;K&quot;</span>)</div>
<div class="line"><span class="lineno"> 3352</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3353</span>                out = out.reshape(ncols, ngroups * nqs)</div>
<div class="line"><span class="lineno"> 3354</span>            <span class="keywordflow">return</span> post_processor(out, inference)</div>
<div class="line"><span class="lineno"> 3355</span> </div>
<div class="line"><span class="lineno"> 3356</span>        obj = self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 3357</span>        is_ser = obj.ndim == 1</div>
<div class="line"><span class="lineno"> 3358</span>        mgr = self._get_data_to_aggregate()</div>
<div class="line"><span class="lineno"> 3359</span>        data = mgr.get_numeric_data() <span class="keywordflow">if</span> numeric_only_bool <span class="keywordflow">else</span> mgr</div>
<div class="line"><span class="lineno"> 3360</span>        ignore_failures = numeric_only_bool</div>
<div class="line"><span class="lineno"> 3361</span>        res_mgr = data.grouped_reduce(blk_func, ignore_failures=ignore_failures)</div>
<div class="line"><span class="lineno"> 3362</span> </div>
<div class="line"><span class="lineno"> 3363</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3364</span>            numeric_only <span class="keywordflow">is</span> lib.no_default</div>
<div class="line"><span class="lineno"> 3365</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_ser</div>
<div class="line"><span class="lineno"> 3366</span>            <span class="keywordflow">and</span> len(res_mgr.items) != len(mgr.items)</div>
<div class="line"><span class="lineno"> 3367</span>        ):</div>
<div class="line"><span class="lineno"> 3368</span>            warn_dropping_nuisance_columns_deprecated(</div>
<div class="line"><span class="lineno"> 3369</span>                type(self), <span class="stringliteral">&quot;quantile&quot;</span>, numeric_only</div>
<div class="line"><span class="lineno"> 3370</span>            )</div>
<div class="line"><span class="lineno"> 3371</span> </div>
<div class="line"><span class="lineno"> 3372</span>            <span class="keywordflow">if</span> len(res_mgr.items) == 0:</div>
<div class="line"><span class="lineno"> 3373</span>                <span class="comment"># re-call grouped_reduce to get the desired exception message</span></div>
<div class="line"><span class="lineno"> 3374</span>                mgr.grouped_reduce(blk_func, ignore_failures=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3375</span>                <span class="comment"># grouped_reduce _should_ raise, so this should not be reached</span></div>
<div class="line"><span class="lineno"> 3376</span>                <span class="keywordflow">raise</span> TypeError(  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno"> 3377</span>                    <span class="stringliteral">&quot;All columns were dropped in grouped_reduce&quot;</span></div>
<div class="line"><span class="lineno"> 3378</span>                )</div>
<div class="line"><span class="lineno"> 3379</span> </div>
<div class="line"><span class="lineno"> 3380</span>        <span class="keywordflow">if</span> is_ser:</div>
<div class="line"><span class="lineno"> 3381</span>            res = self._wrap_agged_manager(res_mgr)</div>
<div class="line"><span class="lineno"> 3382</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3383</span>            res = obj._constructor(res_mgr)</div>
<div class="line"><span class="lineno"> 3384</span> </div>
<div class="line"><span class="lineno"> 3385</span>        <span class="keywordflow">if</span> orig_scalar:</div>
<div class="line"><span class="lineno"> 3386</span>            <span class="comment"># Avoid expensive MultiIndex construction</span></div>
<div class="line"><span class="lineno"> 3387</span>            <span class="keywordflow">return</span> self._wrap_aggregated_output(res)</div>
<div class="line"><span class="lineno"> 3388</span>        <span class="keywordflow">return</span> self._wrap_aggregated_output(res, qs=qs)</div>
<div class="line"><span class="lineno"> 3389</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9af26294b299effab221f75776492586" name="a9af26294b299effab221f75776492586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af26294b299effab221f75776492586">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;average&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>na_option</em> = <code>&quot;keep&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>pct</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide the rank of values within each group.

Parameters
----------
method : {'average', 'min', 'max', 'first', 'dense'}, default 'average'
    * average: average rank of group.
    * min: lowest rank in group.
    * max: highest rank in group.
    * first: ranks assigned in order they appear in the array.
    * dense: like 'min', but rank always increases by 1 between groups.
ascending : bool, default True
    False for ranks by high (1) to low (N).
na_option : {'keep', 'top', 'bottom'}, default 'keep'
    * keep: leave NA values where they are.
    * top: smallest rank if ascending.
    * bottom: smallest rank if descending.
pct : bool, default False
    Compute percentage rank of data within each group.
axis : int, default 0
    The axis of the object over which to compute the rank.

Returns
-------
DataFrame with ranking of values within each group
%(see_also)s
Examples
--------
&gt;&gt;&gt; df = pd.DataFrame(
...     {
...         "group": ["a", "a", "a", "a", "a", "b", "b", "b", "b", "b"],
...         "value": [2, 4, 2, 3, 5, 1, 2, 4, 1, 5],
...     }
... )
&gt;&gt;&gt; df
  group  value
0     a      2
1     a      4
2     a      2
3     a      3
4     a      5
5     b      1
6     b      2
7     b      4
8     b      1
9     b      5
&gt;&gt;&gt; for method in ['average', 'min', 'max', 'dense', 'first']:
...     df[f'{method}_rank'] = df.groupby('group')['value'].rank(method)
&gt;&gt;&gt; df
  group  value  average_rank  min_rank  max_rank  dense_rank  first_rank
0     a      2           1.5       1.0       2.0         1.0         1.0
1     a      4           4.0       4.0       4.0         3.0         4.0
2     a      2           1.5       1.0       2.0         1.0         2.0
3     a      3           3.0       3.0       3.0         2.0         3.0
4     a      5           5.0       5.0       5.0         4.0         5.0
5     b      1           1.5       1.0       2.0         1.0         1.0
6     b      2           3.0       3.0       3.0         2.0         3.0
7     b      4           4.0       4.0       4.0         3.0         4.0
8     b      1           1.5       1.0       2.0         1.0         2.0
9     b      5           5.0       5.0       5.0         4.0         5.0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3537</span>    ) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 3538</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3539</span><span class="stringliteral">        Provide the rank of values within each group.</span></div>
<div class="line"><span class="lineno"> 3540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3541</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3542</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3543</span><span class="stringliteral">        method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}, default &#39;average&#39;</span></div>
<div class="line"><span class="lineno"> 3544</span><span class="stringliteral">            * average: average rank of group.</span></div>
<div class="line"><span class="lineno"> 3545</span><span class="stringliteral">            * min: lowest rank in group.</span></div>
<div class="line"><span class="lineno"> 3546</span><span class="stringliteral">            * max: highest rank in group.</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral">            * first: ranks assigned in order they appear in the array.</span></div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral">            * dense: like &#39;min&#39;, but rank always increases by 1 between groups.</span></div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">        ascending : bool, default True</span></div>
<div class="line"><span class="lineno"> 3550</span><span class="stringliteral">            False for ranks by high (1) to low (N).</span></div>
<div class="line"><span class="lineno"> 3551</span><span class="stringliteral">        na_option : {&#39;keep&#39;, &#39;top&#39;, &#39;bottom&#39;}, default &#39;keep&#39;</span></div>
<div class="line"><span class="lineno"> 3552</span><span class="stringliteral">            * keep: leave NA values where they are.</span></div>
<div class="line"><span class="lineno"> 3553</span><span class="stringliteral">            * top: smallest rank if ascending.</span></div>
<div class="line"><span class="lineno"> 3554</span><span class="stringliteral">            * bottom: smallest rank if descending.</span></div>
<div class="line"><span class="lineno"> 3555</span><span class="stringliteral">        pct : bool, default False</span></div>
<div class="line"><span class="lineno"> 3556</span><span class="stringliteral">            Compute percentage rank of data within each group.</span></div>
<div class="line"><span class="lineno"> 3557</span><span class="stringliteral">        axis : int, default 0</span></div>
<div class="line"><span class="lineno"> 3558</span><span class="stringliteral">            The axis of the object over which to compute the rank.</span></div>
<div class="line"><span class="lineno"> 3559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3560</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3561</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3562</span><span class="stringliteral">        DataFrame with ranking of values within each group</span></div>
<div class="line"><span class="lineno"> 3563</span><span class="stringliteral">        %(see_also)s</span></div>
<div class="line"><span class="lineno"> 3564</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3565</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame(</span></div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">        ...     {</span></div>
<div class="line"><span class="lineno"> 3568</span><span class="stringliteral">        ...         &quot;group&quot;: [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;],</span></div>
<div class="line"><span class="lineno"> 3569</span><span class="stringliteral">        ...         &quot;value&quot;: [2, 4, 2, 3, 5, 1, 2, 4, 1, 5],</span></div>
<div class="line"><span class="lineno"> 3570</span><span class="stringliteral">        ...     }</span></div>
<div class="line"><span class="lineno"> 3571</span><span class="stringliteral">        ... )</span></div>
<div class="line"><span class="lineno"> 3572</span><span class="stringliteral">        &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 3573</span><span class="stringliteral">          group  value</span></div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral">        0     a      2</span></div>
<div class="line"><span class="lineno"> 3575</span><span class="stringliteral">        1     a      4</span></div>
<div class="line"><span class="lineno"> 3576</span><span class="stringliteral">        2     a      2</span></div>
<div class="line"><span class="lineno"> 3577</span><span class="stringliteral">        3     a      3</span></div>
<div class="line"><span class="lineno"> 3578</span><span class="stringliteral">        4     a      5</span></div>
<div class="line"><span class="lineno"> 3579</span><span class="stringliteral">        5     b      1</span></div>
<div class="line"><span class="lineno"> 3580</span><span class="stringliteral">        6     b      2</span></div>
<div class="line"><span class="lineno"> 3581</span><span class="stringliteral">        7     b      4</span></div>
<div class="line"><span class="lineno"> 3582</span><span class="stringliteral">        8     b      1</span></div>
<div class="line"><span class="lineno"> 3583</span><span class="stringliteral">        9     b      5</span></div>
<div class="line"><span class="lineno"> 3584</span><span class="stringliteral">        &gt;&gt;&gt; for method in [&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;dense&#39;, &#39;first&#39;]:</span></div>
<div class="line"><span class="lineno"> 3585</span><span class="stringliteral">        ...     df[f&#39;{method}_rank&#39;] = df.groupby(&#39;group&#39;)[&#39;value&#39;].rank(method)</span></div>
<div class="line"><span class="lineno"> 3586</span><span class="stringliteral">        &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 3587</span><span class="stringliteral">          group  value  average_rank  min_rank  max_rank  dense_rank  first_rank</span></div>
<div class="line"><span class="lineno"> 3588</span><span class="stringliteral">        0     a      2           1.5       1.0       2.0         1.0         1.0</span></div>
<div class="line"><span class="lineno"> 3589</span><span class="stringliteral">        1     a      4           4.0       4.0       4.0         3.0         4.0</span></div>
<div class="line"><span class="lineno"> 3590</span><span class="stringliteral">        2     a      2           1.5       1.0       2.0         1.0         2.0</span></div>
<div class="line"><span class="lineno"> 3591</span><span class="stringliteral">        3     a      3           3.0       3.0       3.0         2.0         3.0</span></div>
<div class="line"><span class="lineno"> 3592</span><span class="stringliteral">        4     a      5           5.0       5.0       5.0         4.0         5.0</span></div>
<div class="line"><span class="lineno"> 3593</span><span class="stringliteral">        5     b      1           1.5       1.0       2.0         1.0         1.0</span></div>
<div class="line"><span class="lineno"> 3594</span><span class="stringliteral">        6     b      2           3.0       3.0       3.0         2.0         3.0</span></div>
<div class="line"><span class="lineno"> 3595</span><span class="stringliteral">        7     b      4           4.0       4.0       4.0         3.0         4.0</span></div>
<div class="line"><span class="lineno"> 3596</span><span class="stringliteral">        8     b      1           1.5       1.0       2.0         1.0         2.0</span></div>
<div class="line"><span class="lineno"> 3597</span><span class="stringliteral">        9     b      5           5.0       5.0       5.0         4.0         5.0</span></div>
<div class="line"><span class="lineno"> 3598</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3599</span>        <span class="keywordflow">if</span> na_option <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="stringliteral">&quot;keep&quot;</span>, <span class="stringliteral">&quot;top&quot;</span>, <span class="stringliteral">&quot;bottom&quot;</span>}:</div>
<div class="line"><span class="lineno"> 3600</span>            msg = <span class="stringliteral">&quot;na_option must be one of &#39;keep&#39;, &#39;top&#39;, or &#39;bottom&#39;&quot;</span></div>
<div class="line"><span class="lineno"> 3601</span>            <span class="keywordflow">raise</span> ValueError(msg)</div>
<div class="line"><span class="lineno"> 3602</span> </div>
<div class="line"><span class="lineno"> 3603</span>        kwargs = {</div>
<div class="line"><span class="lineno"> 3604</span>            <span class="stringliteral">&quot;ties_method&quot;</span>: method,</div>
<div class="line"><span class="lineno"> 3605</span>            <span class="stringliteral">&quot;ascending&quot;</span>: ascending,</div>
<div class="line"><span class="lineno"> 3606</span>            <span class="stringliteral">&quot;na_option&quot;</span>: na_option,</div>
<div class="line"><span class="lineno"> 3607</span>            <span class="stringliteral">&quot;pct&quot;</span>: pct,</div>
<div class="line"><span class="lineno"> 3608</span>        }</div>
<div class="line"><span class="lineno"> 3609</span>        <span class="keywordflow">if</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3610</span>            <span class="comment"># DataFrame uses different keyword name</span></div>
<div class="line"><span class="lineno"> 3611</span>            kwargs[<span class="stringliteral">&quot;method&quot;</span>] = kwargs.pop(<span class="stringliteral">&quot;ties_method&quot;</span>)</div>
<div class="line"><span class="lineno"> 3612</span>            f = <span class="keyword">lambda</span> x: x.rank(axis=axis, numeric_only=<span class="keyword">False</span>, **kwargs)</div>
<div class="line"><span class="lineno"> 3613</span>            result = self._python_apply_general(</div>
<div class="line"><span class="lineno"> 3614</span>                f, self._selected_obj, is_transform=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3615</span>            )</div>
<div class="line"><span class="lineno"> 3616</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3617</span> </div>
<div class="line"><span class="lineno"> 3618</span>        <span class="keywordflow">return</span> self._cython_transform(</div>
<div class="line"><span class="lineno"> 3619</span>            <span class="stringliteral">&quot;rank&quot;</span>,</div>
<div class="line"><span class="lineno"> 3620</span>            numeric_only=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 3621</span>            axis=axis,</div>
<div class="line"><span class="lineno"> 3622</span>            **kwargs,</div>
<div class="line"><span class="lineno"> 3623</span>        )</div>
<div class="line"><span class="lineno"> 3624</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aff8c61e42721b5c838b9fd3439599ac0" name="aff8c61e42721b5c838b9fd3439599ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8c61e42721b5c838b9fd3439599ac0">&#9670;&#160;</a></span>resample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Provide resampling when using a TimeGrouper.

Given a grouper, the function resamples it according to a string
"string" -&gt; "frequency".

See the :ref:`frequency aliases &lt;timeseries.offset_aliases&gt;`
documentation for more details.

Parameters
----------
rule : str or DateOffset
    The offset string or object representing target grouper conversion.
*args, **kwargs
    Possible arguments are `how`, `fill_method`, `limit`, `kind` and
    `on`, and other arguments of `TimeGrouper`.

Returns
-------
Grouper
    Return a new grouper with our resampler appended.

See Also
--------
Grouper : Specify a frequency to resample with when
    grouping by a key.
DatetimeIndex.resample : Frequency conversion and resampling of
    time series.

Examples
--------
&gt;&gt;&gt; idx = pd.date_range('1/1/2000', periods=4, freq='T')
&gt;&gt;&gt; df = pd.DataFrame(data=4 * [range(2)],
...                   index=idx,
...                   columns=['a', 'b'])
&gt;&gt;&gt; df.iloc[2, 0] = 5
&gt;&gt;&gt; df
                    a  b
2000-01-01 00:00:00  0  1
2000-01-01 00:01:00  0  1
2000-01-01 00:02:00  5  1
2000-01-01 00:03:00  0  1

Downsample the DataFrame into 3 minute bins and sum the values of
the timestamps falling into a bin.

&gt;&gt;&gt; df.groupby('a').resample('3T').sum()
                         a  b
a
0   2000-01-01 00:00:00  0  2
    2000-01-01 00:03:00  0  1
5   2000-01-01 00:00:00  5  1

Upsample the series into 30 second bins.

&gt;&gt;&gt; df.groupby('a').resample('30S').sum()
                    a  b
a
0   2000-01-01 00:00:00  0  1
    2000-01-01 00:00:30  0  0
    2000-01-01 00:01:00  0  1
    2000-01-01 00:01:30  0  0
    2000-01-01 00:02:00  0  0
    2000-01-01 00:02:30  0  0
    2000-01-01 00:03:00  0  1
5   2000-01-01 00:02:00  5  1

Resample by month. Values are assigned to the month of the period.

&gt;&gt;&gt; df.groupby('a').resample('M').sum()
            a  b
a
0   2000-01-31  0  3
5   2000-01-31  5  1

Downsample the series into 3 minute bins as above, but close the right
side of the bin interval.

&gt;&gt;&gt; df.groupby('a').resample('3T', closed='right').sum()
                         a  b
a
0   1999-12-31 23:57:00  0  1
    2000-01-01 00:00:00  0  2
5   2000-01-01 00:00:00  5  1

Downsample the series into 3 minute bins and close the right side of
the bin interval, but label each bin using the right edge instead of
the left.

&gt;&gt;&gt; df.groupby('a').resample('3T', closed='right', label='right').sum()
                         a  b
a
0   2000-01-01 00:00:00  0  1
    2000-01-01 00:03:00  0  2
5   2000-01-01 00:03:00  5  1
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2673</span>    <span class="keyword">def </span>resample(self, rule, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 2674</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">        Provide resampling when using a TimeGrouper.</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral">        Given a grouper, the function resamples it according to a string</span></div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral">        &quot;string&quot; -&gt; &quot;frequency&quot;.</span></div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">        See the :ref:`frequency aliases &lt;timeseries.offset_aliases&gt;`</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral">        documentation for more details.</span></div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral">        rule : str or DateOffset</span></div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral">            The offset string or object representing target grouper conversion.</span></div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral">        *args, **kwargs</span></div>
<div class="line"><span class="lineno"> 2688</span><span class="stringliteral">            Possible arguments are `how`, `fill_method`, `limit`, `kind` and</span></div>
<div class="line"><span class="lineno"> 2689</span><span class="stringliteral">            `on`, and other arguments of `TimeGrouper`.</span></div>
<div class="line"><span class="lineno"> 2690</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2691</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2692</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2693</span><span class="stringliteral">        Grouper</span></div>
<div class="line"><span class="lineno"> 2694</span><span class="stringliteral">            Return a new grouper with our resampler appended.</span></div>
<div class="line"><span class="lineno"> 2695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2696</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2697</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2698</span><span class="stringliteral">        Grouper : Specify a frequency to resample with when</span></div>
<div class="line"><span class="lineno"> 2699</span><span class="stringliteral">            grouping by a key.</span></div>
<div class="line"><span class="lineno"> 2700</span><span class="stringliteral">        DatetimeIndex.resample : Frequency conversion and resampling of</span></div>
<div class="line"><span class="lineno"> 2701</span><span class="stringliteral">            time series.</span></div>
<div class="line"><span class="lineno"> 2702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2703</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2704</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2705</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;T&#39;)</span></div>
<div class="line"><span class="lineno"> 2706</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame(data=4 * [range(2)],</span></div>
<div class="line"><span class="lineno"> 2707</span><span class="stringliteral">        ...                   index=idx,</span></div>
<div class="line"><span class="lineno"> 2708</span><span class="stringliteral">        ...                   columns=[&#39;a&#39;, &#39;b&#39;])</span></div>
<div class="line"><span class="lineno"> 2709</span><span class="stringliteral">        &gt;&gt;&gt; df.iloc[2, 0] = 5</span></div>
<div class="line"><span class="lineno"> 2710</span><span class="stringliteral">        &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 2711</span><span class="stringliteral">                            a  b</span></div>
<div class="line"><span class="lineno"> 2712</span><span class="stringliteral">        2000-01-01 00:00:00  0  1</span></div>
<div class="line"><span class="lineno"> 2713</span><span class="stringliteral">        2000-01-01 00:01:00  0  1</span></div>
<div class="line"><span class="lineno"> 2714</span><span class="stringliteral">        2000-01-01 00:02:00  5  1</span></div>
<div class="line"><span class="lineno"> 2715</span><span class="stringliteral">        2000-01-01 00:03:00  0  1</span></div>
<div class="line"><span class="lineno"> 2716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2717</span><span class="stringliteral">        Downsample the DataFrame into 3 minute bins and sum the values of</span></div>
<div class="line"><span class="lineno"> 2718</span><span class="stringliteral">        the timestamps falling into a bin.</span></div>
<div class="line"><span class="lineno"> 2719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2720</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;a&#39;).resample(&#39;3T&#39;).sum()</span></div>
<div class="line"><span class="lineno"> 2721</span><span class="stringliteral">                                 a  b</span></div>
<div class="line"><span class="lineno"> 2722</span><span class="stringliteral">        a</span></div>
<div class="line"><span class="lineno"> 2723</span><span class="stringliteral">        0   2000-01-01 00:00:00  0  2</span></div>
<div class="line"><span class="lineno"> 2724</span><span class="stringliteral">            2000-01-01 00:03:00  0  1</span></div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral">        5   2000-01-01 00:00:00  5  1</span></div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral">        Upsample the series into 30 second bins.</span></div>
<div class="line"><span class="lineno"> 2728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2729</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;a&#39;).resample(&#39;30S&#39;).sum()</span></div>
<div class="line"><span class="lineno"> 2730</span><span class="stringliteral">                            a  b</span></div>
<div class="line"><span class="lineno"> 2731</span><span class="stringliteral">        a</span></div>
<div class="line"><span class="lineno"> 2732</span><span class="stringliteral">        0   2000-01-01 00:00:00  0  1</span></div>
<div class="line"><span class="lineno"> 2733</span><span class="stringliteral">            2000-01-01 00:00:30  0  0</span></div>
<div class="line"><span class="lineno"> 2734</span><span class="stringliteral">            2000-01-01 00:01:00  0  1</span></div>
<div class="line"><span class="lineno"> 2735</span><span class="stringliteral">            2000-01-01 00:01:30  0  0</span></div>
<div class="line"><span class="lineno"> 2736</span><span class="stringliteral">            2000-01-01 00:02:00  0  0</span></div>
<div class="line"><span class="lineno"> 2737</span><span class="stringliteral">            2000-01-01 00:02:30  0  0</span></div>
<div class="line"><span class="lineno"> 2738</span><span class="stringliteral">            2000-01-01 00:03:00  0  1</span></div>
<div class="line"><span class="lineno"> 2739</span><span class="stringliteral">        5   2000-01-01 00:02:00  5  1</span></div>
<div class="line"><span class="lineno"> 2740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2741</span><span class="stringliteral">        Resample by month. Values are assigned to the month of the period.</span></div>
<div class="line"><span class="lineno"> 2742</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;a&#39;).resample(&#39;M&#39;).sum()</span></div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral">                    a  b</span></div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral">        a</span></div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral">        0   2000-01-31  0  3</span></div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral">        5   2000-01-31  5  1</span></div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">        Downsample the series into 3 minute bins as above, but close the right</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral">        side of the bin interval.</span></div>
<div class="line"><span class="lineno"> 2751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;a&#39;).resample(&#39;3T&#39;, closed=&#39;right&#39;).sum()</span></div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral">                                 a  b</span></div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral">        a</span></div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral">        0   1999-12-31 23:57:00  0  1</span></div>
<div class="line"><span class="lineno"> 2756</span><span class="stringliteral">            2000-01-01 00:00:00  0  2</span></div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">        5   2000-01-01 00:00:00  5  1</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral">        Downsample the series into 3 minute bins and close the right side of</span></div>
<div class="line"><span class="lineno"> 2760</span><span class="stringliteral">        the bin interval, but label each bin using the right edge instead of</span></div>
<div class="line"><span class="lineno"> 2761</span><span class="stringliteral">        the left.</span></div>
<div class="line"><span class="lineno"> 2762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2763</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;a&#39;).resample(&#39;3T&#39;, closed=&#39;right&#39;, label=&#39;right&#39;).sum()</span></div>
<div class="line"><span class="lineno"> 2764</span><span class="stringliteral">                                 a  b</span></div>
<div class="line"><span class="lineno"> 2765</span><span class="stringliteral">        a</span></div>
<div class="line"><span class="lineno"> 2766</span><span class="stringliteral">        0   2000-01-01 00:00:00  0  1</span></div>
<div class="line"><span class="lineno"> 2767</span><span class="stringliteral">            2000-01-01 00:03:00  0  2</span></div>
<div class="line"><span class="lineno"> 2768</span><span class="stringliteral">        5   2000-01-01 00:03:00  5  1</span></div>
<div class="line"><span class="lineno"> 2769</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2770</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1resample.html">pandas.core.resample</a> <span class="keyword">import</span> get_resampler_for_grouping</div>
<div class="line"><span class="lineno"> 2771</span> </div>
<div class="line"><span class="lineno"> 2772</span>        <span class="keywordflow">return</span> get_resampler_for_grouping(self, rule, *args, **kwargs)</div>
<div class="line"><span class="lineno"> 2773</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1resample_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1resample.html">pandas.core.resample</a></div><div class="ttdef"><b>Definition</b> resample.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad123d631afc14e83b31e7384cbd4a158" name="ad123d631afc14e83b31e7384cbd4a158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad123d631afc14e83b31e7384cbd4a158">&#9670;&#160;</a></span>rolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1window_1_1rolling_1_1_rolling_groupby.html">RollingGroupby</a> pandas.core.groupby.groupby.GroupBy.rolling </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a rolling grouper, providing rolling functionality per group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2777</span>    <span class="keyword">def </span>rolling(self, *args, **kwargs) -&gt; RollingGroupby:</div>
<div class="line"><span class="lineno"> 2778</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2779</span><span class="stringliteral">        Return a rolling grouper, providing rolling functionality per group.</span></div>
<div class="line"><span class="lineno"> 2780</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2781</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1window.html">pandas.core.window</a> <span class="keyword">import</span> RollingGroupby</div>
<div class="line"><span class="lineno"> 2782</span> </div>
<div class="line"><span class="lineno"> 2783</span>        <span class="keywordflow">return</span> RollingGroupby(</div>
<div class="line"><span class="lineno"> 2784</span>            self._selected_obj,</div>
<div class="line"><span class="lineno"> 2785</span>            *args,</div>
<div class="line"><span class="lineno"> 2786</span>            _grouper=self.grouper,</div>
<div class="line"><span class="lineno"> 2787</span>            _as_index=self.as_index,</div>
<div class="line"><span class="lineno"> 2788</span>            **kwargs,</div>
<div class="line"><span class="lineno"> 2789</span>        )</div>
<div class="line"><span class="lineno"> 2790</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a36848017b67bb140e005f24888fb9fc1" name="a36848017b67bb140e005f24888fb9fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36848017b67bb140e005f24888fb9fc1">&#9670;&#160;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.sample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float | None &#160;</td>
          <td class="paramname"><em>frac</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>replace</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence | <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> | None &#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomState | None &#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a random sample of items from each group.

You can use `random_state` for reproducibility.

.. versionadded:: 1.1.0

Parameters
----------
n : int, optional
    Number of items to return for each group. Cannot be used with
    `frac` and must be no larger than the smallest group unless
    `replace` is True. Default is one if `frac` is None.
frac : float, optional
    Fraction of items to return. Cannot be used with `n`.
replace : bool, default False
    Allow or disallow sampling of the same row more than once.
weights : list-like, optional
    Default None results in equal probability weighting.
    If passed a list-like then values must have the same length as
    the underlying DataFrame or Series object and will be used as
    sampling probabilities after normalization within each group.
    Values must be non-negative with at least one positive element
    within each group.
random_state : int, array-like, BitGenerator, np.random.RandomState, np.random.Generator, optional
    If int, array-like, or BitGenerator, seed for random number generator.
    If np.random.RandomState or np.random.Generator, use as given.

    .. versionchanged:: 1.4.0

        np.random.Generator objects now accepted

Returns
-------
Series or DataFrame
    A new object of same type as caller containing items randomly
    sampled within each group from the caller object.

See Also
--------
DataFrame.sample: Generate random samples from a DataFrame object.
numpy.random.choice: Generate a random sample from a given 1-D numpy
    array.

Examples
--------
&gt;&gt;&gt; df = pd.DataFrame(
...     {"a": ["red"] * 2 + ["blue"] * 2 + ["black"] * 2, "b": range(6)}
... )
&gt;&gt;&gt; df
       a  b
0    red  0
1    red  1
2   blue  2
3   blue  3
4  black  4
5  black  5

Select one row at random for each distinct value in column a. The
`random_state` argument can be used to guarantee reproducibility:

&gt;&gt;&gt; df.groupby("a").sample(n=1, random_state=1)
       a  b
4  black  4
2   blue  2
1    red  1

Set `frac` to sample fixed proportions rather than counts:

&gt;&gt;&gt; df.groupby("a")["b"].sample(frac=0.5, random_state=2)
5    5
2    2
0    0
Name: b, dtype: int64

Control sample probabilities within groups by setting weights:

&gt;&gt;&gt; df.groupby("a").sample(
...     n=1,
...     weights=[1, 1, 1, 0, 0, 1],
...     random_state=1,
... )
       a  b
5  black  5
2   blue  2
0    red  0
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4188</span>    ):</div>
<div class="line"><span class="lineno"> 4189</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4190</span><span class="stringliteral">        Return a random sample of items from each group.</span></div>
<div class="line"><span class="lineno"> 4191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4192</span><span class="stringliteral">        You can use `random_state` for reproducibility.</span></div>
<div class="line"><span class="lineno"> 4193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4194</span><span class="stringliteral">        .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno"> 4195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4196</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4197</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4198</span><span class="stringliteral">        n : int, optional</span></div>
<div class="line"><span class="lineno"> 4199</span><span class="stringliteral">            Number of items to return for each group. Cannot be used with</span></div>
<div class="line"><span class="lineno"> 4200</span><span class="stringliteral">            `frac` and must be no larger than the smallest group unless</span></div>
<div class="line"><span class="lineno"> 4201</span><span class="stringliteral">            `replace` is True. Default is one if `frac` is None.</span></div>
<div class="line"><span class="lineno"> 4202</span><span class="stringliteral">        frac : float, optional</span></div>
<div class="line"><span class="lineno"> 4203</span><span class="stringliteral">            Fraction of items to return. Cannot be used with `n`.</span></div>
<div class="line"><span class="lineno"> 4204</span><span class="stringliteral">        replace : bool, default False</span></div>
<div class="line"><span class="lineno"> 4205</span><span class="stringliteral">            Allow or disallow sampling of the same row more than once.</span></div>
<div class="line"><span class="lineno"> 4206</span><span class="stringliteral">        weights : list-like, optional</span></div>
<div class="line"><span class="lineno"> 4207</span><span class="stringliteral">            Default None results in equal probability weighting.</span></div>
<div class="line"><span class="lineno"> 4208</span><span class="stringliteral">            If passed a list-like then values must have the same length as</span></div>
<div class="line"><span class="lineno"> 4209</span><span class="stringliteral">            the underlying DataFrame or Series object and will be used as</span></div>
<div class="line"><span class="lineno"> 4210</span><span class="stringliteral">            sampling probabilities after normalization within each group.</span></div>
<div class="line"><span class="lineno"> 4211</span><span class="stringliteral">            Values must be non-negative with at least one positive element</span></div>
<div class="line"><span class="lineno"> 4212</span><span class="stringliteral">            within each group.</span></div>
<div class="line"><span class="lineno"> 4213</span><span class="stringliteral">        random_state : int, array-like, BitGenerator, np.random.RandomState, np.random.Generator, optional</span></div>
<div class="line"><span class="lineno"> 4214</span><span class="stringliteral">            If int, array-like, or BitGenerator, seed for random number generator.</span></div>
<div class="line"><span class="lineno"> 4215</span><span class="stringliteral">            If np.random.RandomState or np.random.Generator, use as given.</span></div>
<div class="line"><span class="lineno"> 4216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4217</span><span class="stringliteral">            .. versionchanged:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 4218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4219</span><span class="stringliteral">                np.random.Generator objects now accepted</span></div>
<div class="line"><span class="lineno"> 4220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4221</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 4222</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 4223</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 4224</span><span class="stringliteral">            A new object of same type as caller containing items randomly</span></div>
<div class="line"><span class="lineno"> 4225</span><span class="stringliteral">            sampled within each group from the caller object.</span></div>
<div class="line"><span class="lineno"> 4226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4227</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 4228</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 4229</span><span class="stringliteral">        DataFrame.sample: Generate random samples from a DataFrame object.</span></div>
<div class="line"><span class="lineno"> 4230</span><span class="stringliteral">        numpy.random.choice: Generate a random sample from a given 1-D numpy</span></div>
<div class="line"><span class="lineno"> 4231</span><span class="stringliteral">            array.</span></div>
<div class="line"><span class="lineno"> 4232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4233</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 4234</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 4235</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame(</span></div>
<div class="line"><span class="lineno"> 4236</span><span class="stringliteral">        ...     {&quot;a&quot;: [&quot;red&quot;] * 2 + [&quot;blue&quot;] * 2 + [&quot;black&quot;] * 2, &quot;b&quot;: range(6)}</span></div>
<div class="line"><span class="lineno"> 4237</span><span class="stringliteral">        ... )</span></div>
<div class="line"><span class="lineno"> 4238</span><span class="stringliteral">        &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 4239</span><span class="stringliteral">               a  b</span></div>
<div class="line"><span class="lineno"> 4240</span><span class="stringliteral">        0    red  0</span></div>
<div class="line"><span class="lineno"> 4241</span><span class="stringliteral">        1    red  1</span></div>
<div class="line"><span class="lineno"> 4242</span><span class="stringliteral">        2   blue  2</span></div>
<div class="line"><span class="lineno"> 4243</span><span class="stringliteral">        3   blue  3</span></div>
<div class="line"><span class="lineno"> 4244</span><span class="stringliteral">        4  black  4</span></div>
<div class="line"><span class="lineno"> 4245</span><span class="stringliteral">        5  black  5</span></div>
<div class="line"><span class="lineno"> 4246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4247</span><span class="stringliteral">        Select one row at random for each distinct value in column a. The</span></div>
<div class="line"><span class="lineno"> 4248</span><span class="stringliteral">        `random_state` argument can be used to guarantee reproducibility:</span></div>
<div class="line"><span class="lineno"> 4249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4250</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&quot;a&quot;).sample(n=1, random_state=1)</span></div>
<div class="line"><span class="lineno"> 4251</span><span class="stringliteral">               a  b</span></div>
<div class="line"><span class="lineno"> 4252</span><span class="stringliteral">        4  black  4</span></div>
<div class="line"><span class="lineno"> 4253</span><span class="stringliteral">        2   blue  2</span></div>
<div class="line"><span class="lineno"> 4254</span><span class="stringliteral">        1    red  1</span></div>
<div class="line"><span class="lineno"> 4255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4256</span><span class="stringliteral">        Set `frac` to sample fixed proportions rather than counts:</span></div>
<div class="line"><span class="lineno"> 4257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4258</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&quot;a&quot;)[&quot;b&quot;].sample(frac=0.5, random_state=2)</span></div>
<div class="line"><span class="lineno"> 4259</span><span class="stringliteral">        5    5</span></div>
<div class="line"><span class="lineno"> 4260</span><span class="stringliteral">        2    2</span></div>
<div class="line"><span class="lineno"> 4261</span><span class="stringliteral">        0    0</span></div>
<div class="line"><span class="lineno"> 4262</span><span class="stringliteral">        Name: b, dtype: int64</span></div>
<div class="line"><span class="lineno"> 4263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4264</span><span class="stringliteral">        Control sample probabilities within groups by setting weights:</span></div>
<div class="line"><span class="lineno"> 4265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4266</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&quot;a&quot;).sample(</span></div>
<div class="line"><span class="lineno"> 4267</span><span class="stringliteral">        ...     n=1,</span></div>
<div class="line"><span class="lineno"> 4268</span><span class="stringliteral">        ...     weights=[1, 1, 1, 0, 0, 1],</span></div>
<div class="line"><span class="lineno"> 4269</span><span class="stringliteral">        ...     random_state=1,</span></div>
<div class="line"><span class="lineno"> 4270</span><span class="stringliteral">        ... )</span></div>
<div class="line"><span class="lineno"> 4271</span><span class="stringliteral">               a  b</span></div>
<div class="line"><span class="lineno"> 4272</span><span class="stringliteral">        5  black  5</span></div>
<div class="line"><span class="lineno"> 4273</span><span class="stringliteral">        2   blue  2</span></div>
<div class="line"><span class="lineno"> 4274</span><span class="stringliteral">        0    red  0</span></div>
<div class="line"><span class="lineno"> 4275</span><span class="stringliteral">        &quot;&quot;&quot;</span>  <span class="comment"># noqa:E501</span></div>
<div class="line"><span class="lineno"> 4276</span>        size = sample.process_sampling_size(n, frac, replace)</div>
<div class="line"><span class="lineno"> 4277</span>        <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4278</span>            weights_arr = sample.preprocess_weights(</div>
<div class="line"><span class="lineno"> 4279</span>                self._selected_obj, weights, axis=self.axis</div>
<div class="line"><span class="lineno"> 4280</span>            )</div>
<div class="line"><span class="lineno"> 4281</span> </div>
<div class="line"><span class="lineno"> 4282</span>        random_state = com.random_state(random_state)</div>
<div class="line"><span class="lineno"> 4283</span> </div>
<div class="line"><span class="lineno"> 4284</span>        group_iterator = self.grouper.get_iterator(self._selected_obj, self.axis)</div>
<div class="line"><span class="lineno"> 4285</span> </div>
<div class="line"><span class="lineno"> 4286</span>        sampled_indices = []</div>
<div class="line"><span class="lineno"> 4287</span>        <span class="keywordflow">for</span> labels, obj <span class="keywordflow">in</span> group_iterator:</div>
<div class="line"><span class="lineno"> 4288</span>            grp_indices = self.indices[labels]</div>
<div class="line"><span class="lineno"> 4289</span>            group_size = len(grp_indices)</div>
<div class="line"><span class="lineno"> 4290</span>            <span class="keywordflow">if</span> size <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4291</span>                sample_size = size</div>
<div class="line"><span class="lineno"> 4292</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4293</span>                <span class="keyword">assert</span> frac <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4294</span>                sample_size = round(frac * group_size)</div>
<div class="line"><span class="lineno"> 4295</span> </div>
<div class="line"><span class="lineno"> 4296</span>            grp_sample = sample.sample(</div>
<div class="line"><span class="lineno"> 4297</span>                group_size,</div>
<div class="line"><span class="lineno"> 4298</span>                size=sample_size,</div>
<div class="line"><span class="lineno"> 4299</span>                replace=replace,</div>
<div class="line"><span class="lineno"> 4300</span>                weights=<span class="keywordtype">None</span> <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> weights_arr[grp_indices],</div>
<div class="line"><span class="lineno"> 4301</span>                random_state=random_state,</div>
<div class="line"><span class="lineno"> 4302</span>            )</div>
<div class="line"><span class="lineno"> 4303</span>            sampled_indices.append(grp_indices[grp_sample])</div>
<div class="line"><span class="lineno"> 4304</span> </div>
<div class="line"><span class="lineno"> 4305</span>        sampled_indices = np.concatenate(sampled_indices)</div>
<div class="line"><span class="lineno"> 4306</span>        <span class="keywordflow">return</span> self._selected_obj.take(sampled_indices, axis=self.axis)</div>
<div class="line"><span class="lineno"> 4307</span> </div>
<div class="line"><span class="lineno"> 4308</span> </div>
<div class="line"><span class="lineno"> 4309</span><span class="preprocessor">@doc(GroupBy)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abf988d343f659a546a1d9ad6621245fd" name="abf988d343f659a546a1d9ad6621245fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf988d343f659a546a1d9ad6621245fd">&#9670;&#160;</a></span>sem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.sem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute standard error of the mean of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex.

Parameters
----------
ddof : int, default 1
    Degrees of freedom.

numeric_only : bool, default True
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

Returns
-------
Series or DataFrame
    Standard error of the mean of values within each group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2325</span>    <span class="keyword">def </span>sem(self, ddof: int = 1, numeric_only: bool | lib.NoDefault = lib.no_default):</div>
<div class="line"><span class="lineno"> 2326</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral">        Compute standard error of the mean of groups, excluding missing values.</span></div>
<div class="line"><span class="lineno"> 2328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2329</span><span class="stringliteral">        For multiple groupings, the result index will be a MultiIndex.</span></div>
<div class="line"><span class="lineno"> 2330</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2331</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2332</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2333</span><span class="stringliteral">        ddof : int, default 1</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral">            Degrees of freedom.</span></div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">        numeric_only : bool, default True</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral">            Include only `float`, `int` or `boolean` data.</span></div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral">            .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2344</span><span class="stringliteral">            Standard error of the mean of values within each group.</span></div>
<div class="line"><span class="lineno"> 2345</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2346</span>        <span class="comment"># Reolve numeric_only so that std doesn&#39;t warn</span></div>
<div class="line"><span class="lineno"> 2347</span>        numeric_only_bool = self._resolve_numeric_only(<span class="stringliteral">&quot;sem&quot;</span>, numeric_only, axis=0)</div>
<div class="line"><span class="lineno"> 2348</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 2349</span>            numeric_only_bool</div>
<div class="line"><span class="lineno"> 2350</span>            <span class="keywordflow">and</span> self.obj.ndim == 1</div>
<div class="line"><span class="lineno"> 2351</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_numeric_dtype(self.obj.dtype)</div>
<div class="line"><span class="lineno"> 2352</span>        ):</div>
<div class="line"><span class="lineno"> 2353</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 2354</span>                f<span class="stringliteral">&quot;{type(self).__name__}.sem called with &quot;</span></div>
<div class="line"><span class="lineno"> 2355</span>                f<span class="stringliteral">&quot;numeric_only={numeric_only} and dtype {self.obj.dtype}&quot;</span></div>
<div class="line"><span class="lineno"> 2356</span>            )</div>
<div class="line"><span class="lineno"> 2357</span>        result = self.std(ddof=ddof, numeric_only=numeric_only_bool)</div>
<div class="line"><span class="lineno"> 2358</span>        self._maybe_warn_numeric_only_depr(<span class="stringliteral">&quot;sem&quot;</span>, result, numeric_only)</div>
<div class="line"><span class="lineno"> 2359</span> </div>
<div class="line"><span class="lineno"> 2360</span>        <span class="keywordflow">if</span> result.ndim == 1:</div>
<div class="line"><span class="lineno"> 2361</span>            result /= np.sqrt(self.count())</div>
<div class="line"><span class="lineno"> 2362</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2363</span>            cols = result.columns.difference(self.exclusions).unique()</div>
<div class="line"><span class="lineno"> 2364</span>            counts = self.count()</div>
<div class="line"><span class="lineno"> 2365</span>            result_ilocs = result.columns.get_indexer_for(cols)</div>
<div class="line"><span class="lineno"> 2366</span>            count_ilocs = counts.columns.get_indexer_for(cols)</div>
<div class="line"><span class="lineno"> 2367</span>            <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno"> 2368</span>                <span class="comment"># TODO(2.0): once iloc[:, foo] = bar depecation is enforced,</span></div>
<div class="line"><span class="lineno"> 2369</span>                <span class="comment">#  this catching will be unnecessary</span></div>
<div class="line"><span class="lineno"> 2370</span>                warnings.filterwarnings(</div>
<div class="line"><span class="lineno"> 2371</span>                    <span class="stringliteral">&quot;ignore&quot;</span>, <span class="stringliteral">&quot;.*will attempt to set the values inplace.*&quot;</span></div>
<div class="line"><span class="lineno"> 2372</span>                )</div>
<div class="line"><span class="lineno"> 2373</span>                result.iloc[:, result_ilocs] /= np.sqrt(counts.iloc[:, count_ilocs])</div>
<div class="line"><span class="lineno"> 2374</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 2375</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a659eefaf1a7c641536630b970d9b2d74" name="a659eefaf1a7c641536630b970d9b2d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659eefaf1a7c641536630b970d9b2d74">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>periods</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>freq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Shift each group by periods observations.

If freq is passed, the index will be increased using the periods and the freq.

Parameters
----------
periods : int, default 1
    Number of periods to shift.
freq : str, optional
    Frequency string.
axis : axis to shift, default 0
    Shift direction.
fill_value : optional
    The scalar value to use for newly introduced missing values.

Returns
-------
Series or DataFrame
    Object shifted within each group.

See Also
--------
Index.shift : Shift values of Index.
tshift : Shift the time index, using the indexs frequency
    if available.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3858</span>    <span class="keyword">def </span>shift(self, periods=1, freq=None, axis=0, fill_value=None):</div>
<div class="line"><span class="lineno"> 3859</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3860</span><span class="stringliteral">        Shift each group by periods observations.</span></div>
<div class="line"><span class="lineno"> 3861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3862</span><span class="stringliteral">        If freq is passed, the index will be increased using the periods and the freq.</span></div>
<div class="line"><span class="lineno"> 3863</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3864</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3865</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3866</span><span class="stringliteral">        periods : int, default 1</span></div>
<div class="line"><span class="lineno"> 3867</span><span class="stringliteral">            Number of periods to shift.</span></div>
<div class="line"><span class="lineno"> 3868</span><span class="stringliteral">        freq : str, optional</span></div>
<div class="line"><span class="lineno"> 3869</span><span class="stringliteral">            Frequency string.</span></div>
<div class="line"><span class="lineno"> 3870</span><span class="stringliteral">        axis : axis to shift, default 0</span></div>
<div class="line"><span class="lineno"> 3871</span><span class="stringliteral">            Shift direction.</span></div>
<div class="line"><span class="lineno"> 3872</span><span class="stringliteral">        fill_value : optional</span></div>
<div class="line"><span class="lineno"> 3873</span><span class="stringliteral">            The scalar value to use for newly introduced missing values.</span></div>
<div class="line"><span class="lineno"> 3874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3875</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3876</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3877</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 3878</span><span class="stringliteral">            Object shifted within each group.</span></div>
<div class="line"><span class="lineno"> 3879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3880</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 3881</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3882</span><span class="stringliteral">        Index.shift : Shift values of Index.</span></div>
<div class="line"><span class="lineno"> 3883</span><span class="stringliteral">        tshift : Shift the time index, using the indexs frequency</span></div>
<div class="line"><span class="lineno"> 3884</span><span class="stringliteral">            if available.</span></div>
<div class="line"><span class="lineno"> 3885</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3886</span>        <span class="keywordflow">if</span> freq <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> axis != 0:</div>
<div class="line"><span class="lineno"> 3887</span>            f = <span class="keyword">lambda</span> x: x.shift(periods, freq, axis, fill_value)</div>
<div class="line"><span class="lineno"> 3888</span>            <span class="keywordflow">return</span> self._python_apply_general(f, self._selected_obj, is_transform=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3889</span> </div>
<div class="line"><span class="lineno"> 3890</span>        ids, _, ngroups = self.grouper.group_info</div>
<div class="line"><span class="lineno"> 3891</span>        res_indexer = np.zeros(len(ids), dtype=np.int64)</div>
<div class="line"><span class="lineno"> 3892</span> </div>
<div class="line"><span class="lineno"> 3893</span>        libgroupby.group_shift_indexer(res_indexer, ids, ngroups, periods)</div>
<div class="line"><span class="lineno"> 3894</span> </div>
<div class="line"><span class="lineno"> 3895</span>        obj = self._obj_with_exclusions</div>
<div class="line"><span class="lineno"> 3896</span> </div>
<div class="line"><span class="lineno"> 3897</span>        res = obj._reindex_with_indexers(</div>
<div class="line"><span class="lineno"> 3898</span>            {self.axis: (obj.axes[self.axis], res_indexer)},</div>
<div class="line"><span class="lineno"> 3899</span>            fill_value=fill_value,</div>
<div class="line"><span class="lineno"> 3900</span>            allow_dups=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 3901</span>        )</div>
<div class="line"><span class="lineno"> 3902</span>        <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 3903</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abf144a9cf62fed56f15f1cfb77c0a263" name="abf144a9cf62fed56f15f1cfb77c0a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf144a9cf62fed56f15f1cfb77c0a263">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1frame_1_1_data_frame.html">DataFrame</a> | <a class="el" href="classpandas_1_1core_1_1series_1_1_series.html">Series</a> pandas.core.groupby.groupby.GroupBy.size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute group sizes.

Returns
-------
DataFrame or Series
    Number of rows in each group as a Series if as_index is True
    or a DataFrame if as_index is False.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2379</span>    <span class="keyword">def </span>size(self) -&gt; DataFrame | Series:</div>
<div class="line"><span class="lineno"> 2380</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2381</span><span class="stringliteral">        Compute group sizes.</span></div>
<div class="line"><span class="lineno"> 2382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2383</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2384</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral">        DataFrame or Series</span></div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">            Number of rows in each group as a Series if as_index is True</span></div>
<div class="line"><span class="lineno"> 2387</span><span class="stringliteral">            or a DataFrame if as_index is False.</span></div>
<div class="line"><span class="lineno"> 2388</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2389</span>        result = self.grouper.size()</div>
<div class="line"><span class="lineno"> 2390</span> </div>
<div class="line"><span class="lineno"> 2391</span>        <span class="comment"># GH28330 preserve subclassed Series/DataFrames through calls</span></div>
<div class="line"><span class="lineno"> 2392</span>        <span class="keywordflow">if</span> isinstance(self.obj, Series):</div>
<div class="line"><span class="lineno"> 2393</span>            result = self._obj_1d_constructor(result, name=self.obj.name)</div>
<div class="line"><span class="lineno"> 2394</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2395</span>            result = self._obj_1d_constructor(result)</div>
<div class="line"><span class="lineno"> 2396</span> </div>
<div class="line"><span class="lineno"> 2397</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.as_index:</div>
<div class="line"><span class="lineno"> 2398</span>            <span class="comment"># error: Incompatible types in assignment (expression has</span></div>
<div class="line"><span class="lineno"> 2399</span>            <span class="comment"># type &quot;DataFrame&quot;, variable has type &quot;Series&quot;)</span></div>
<div class="line"><span class="lineno"> 2400</span>            result = result.rename(<span class="stringliteral">&quot;size&quot;</span>).reset_index()  <span class="comment"># type: ignore[assignment]</span></div>
<div class="line"><span class="lineno"> 2401</span> </div>
<div class="line"><span class="lineno"> 2402</span>        <span class="keywordflow">return</span> self._reindex_output(result, fill_value=0)</div>
<div class="line"><span class="lineno"> 2403</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a902038000da231faea3dbb14016e287e" name="a902038000da231faea3dbb14016e287e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902038000da231faea3dbb14016e287e">&#9670;&#160;</a></span>std()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.std </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, bool] | None &#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute standard deviation of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex.

Parameters
----------
ddof : int, default 1
    Degrees of freedom.

engine : str, default None
    * ``'cython'`` : Runs the operation through C-extensions from cython.
    * ``'numba'`` : Runs the operation through JIT compiled code from numba.
    * ``None`` : Defaults to ``'cython'`` or globally setting
      ``compute.use_numba``

    .. versionadded:: 1.4.0

engine_kwargs : dict, default None
    * For ``'cython'`` engine, there are no accepted ``engine_kwargs``
    * For ``'numba'`` engine, the engine can accept ``nopython``, ``nogil``
      and ``parallel`` dictionary keys. The values must either be ``True`` or
      ``False``. The default ``engine_kwargs`` for the ``'numba'`` engine is
      ``{{'nopython': True, 'nogil': False, 'parallel': False}}``

    .. versionadded:: 1.4.0

numeric_only : bool, default True
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

Returns
-------
Series or DataFrame
    Standard deviation of values within each group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2197</span>    ):</div>
<div class="line"><span class="lineno"> 2198</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2199</span><span class="stringliteral">        Compute standard deviation of groups, excluding missing values.</span></div>
<div class="line"><span class="lineno"> 2200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2201</span><span class="stringliteral">        For multiple groupings, the result index will be a MultiIndex.</span></div>
<div class="line"><span class="lineno"> 2202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2203</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2204</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2205</span><span class="stringliteral">        ddof : int, default 1</span></div>
<div class="line"><span class="lineno"> 2206</span><span class="stringliteral">            Degrees of freedom.</span></div>
<div class="line"><span class="lineno"> 2207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2208</span><span class="stringliteral">        engine : str, default None</span></div>
<div class="line"><span class="lineno"> 2209</span><span class="stringliteral">            * ``&#39;cython&#39;`` : Runs the operation through C-extensions from cython.</span></div>
<div class="line"><span class="lineno"> 2210</span><span class="stringliteral">            * ``&#39;numba&#39;`` : Runs the operation through JIT compiled code from numba.</span></div>
<div class="line"><span class="lineno"> 2211</span><span class="stringliteral">            * ``None`` : Defaults to ``&#39;cython&#39;`` or globally setting</span></div>
<div class="line"><span class="lineno"> 2212</span><span class="stringliteral">              ``compute.use_numba``</span></div>
<div class="line"><span class="lineno"> 2213</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2214</span><span class="stringliteral">            .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 2215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2216</span><span class="stringliteral">        engine_kwargs : dict, default None</span></div>
<div class="line"><span class="lineno"> 2217</span><span class="stringliteral">            * For ``&#39;cython&#39;`` engine, there are no accepted ``engine_kwargs``</span></div>
<div class="line"><span class="lineno"> 2218</span><span class="stringliteral">            * For ``&#39;numba&#39;`` engine, the engine can accept ``nopython``, ``nogil``</span></div>
<div class="line"><span class="lineno"> 2219</span><span class="stringliteral">              and ``parallel`` dictionary keys. The values must either be ``True`` or</span></div>
<div class="line"><span class="lineno"> 2220</span><span class="stringliteral">              ``False``. The default ``engine_kwargs`` for the ``&#39;numba&#39;`` engine is</span></div>
<div class="line"><span class="lineno"> 2221</span><span class="stringliteral">              ``{{&#39;nopython&#39;: True, &#39;nogil&#39;: False, &#39;parallel&#39;: False}}``</span></div>
<div class="line"><span class="lineno"> 2222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral">            .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral">        numeric_only : bool, default True</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral">            Include only `float`, `int` or `boolean` data.</span></div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">            .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">            Standard deviation of values within each group.</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2235</span>        <span class="keywordflow">if</span> maybe_use_numba(engine):</div>
<div class="line"><span class="lineno"> 2236</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1__numba_1_1kernels.html">pandas.core._numba.kernels</a> <span class="keyword">import</span> sliding_var</div>
<div class="line"><span class="lineno"> 2237</span> </div>
<div class="line"><span class="lineno"> 2238</span>            <span class="keywordflow">return</span> np.sqrt(self._numba_agg_general(sliding_var, engine_kwargs, ddof))</div>
<div class="line"><span class="lineno"> 2239</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2240</span>            <span class="comment"># Resolve numeric_only so that var doesn&#39;t warn</span></div>
<div class="line"><span class="lineno"> 2241</span>            numeric_only_bool = self._resolve_numeric_only(<span class="stringliteral">&quot;std&quot;</span>, numeric_only, axis=0)</div>
<div class="line"><span class="lineno"> 2242</span>            <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 2243</span>                numeric_only_bool</div>
<div class="line"><span class="lineno"> 2244</span>                <span class="keywordflow">and</span> self.obj.ndim == 1</div>
<div class="line"><span class="lineno"> 2245</span>                <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_numeric_dtype(self.obj.dtype)</div>
<div class="line"><span class="lineno"> 2246</span>            ):</div>
<div class="line"><span class="lineno"> 2247</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 2248</span>                    f<span class="stringliteral">&quot;{type(self).__name__}.std called with &quot;</span></div>
<div class="line"><span class="lineno"> 2249</span>                    f<span class="stringliteral">&quot;numeric_only={numeric_only} and dtype {self.obj.dtype}&quot;</span></div>
<div class="line"><span class="lineno"> 2250</span>                )</div>
<div class="line"><span class="lineno"> 2251</span>            result = self._get_cythonized_result(</div>
<div class="line"><span class="lineno"> 2252</span>                libgroupby.group_var,</div>
<div class="line"><span class="lineno"> 2253</span>                cython_dtype=np.dtype(np.float64),</div>
<div class="line"><span class="lineno"> 2254</span>                numeric_only=numeric_only_bool,</div>
<div class="line"><span class="lineno"> 2255</span>                needs_counts=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 2256</span>                post_processing=<span class="keyword">lambda</span> vals, inference: np.sqrt(vals),</div>
<div class="line"><span class="lineno"> 2257</span>                ddof=ddof,</div>
<div class="line"><span class="lineno"> 2258</span>            )</div>
<div class="line"><span class="lineno"> 2259</span>            self._maybe_warn_numeric_only_depr(<span class="stringliteral">&quot;std&quot;</span>, result, numeric_only)</div>
<div class="line"><span class="lineno"> 2260</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 2261</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a29ce0f2f8317be6a231bc624cf865a6b" name="a29ce0f2f8317be6a231bc624cf865a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ce0f2f8317be6a231bc624cf865a6b">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.sum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, bool] | None &#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2412</span>    ):</div>
<div class="line"><span class="lineno"> 2413</span>        <span class="keywordflow">if</span> maybe_use_numba(engine):</div>
<div class="line"><span class="lineno"> 2414</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1__numba_1_1kernels.html">pandas.core._numba.kernels</a> <span class="keyword">import</span> sliding_sum</div>
<div class="line"><span class="lineno"> 2415</span> </div>
<div class="line"><span class="lineno"> 2416</span>            <span class="keywordflow">return</span> self._numba_agg_general(</div>
<div class="line"><span class="lineno"> 2417</span>                sliding_sum,</div>
<div class="line"><span class="lineno"> 2418</span>                engine_kwargs,</div>
<div class="line"><span class="lineno"> 2419</span>            )</div>
<div class="line"><span class="lineno"> 2420</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2421</span>            <span class="comment"># If we are grouping on categoricals we want unobserved categories to</span></div>
<div class="line"><span class="lineno"> 2422</span>            <span class="comment"># return zero, rather than the default of NaN which the reindexing in</span></div>
<div class="line"><span class="lineno"> 2423</span>            <span class="comment"># _agg_general() returns. GH #31422</span></div>
<div class="line"><span class="lineno"> 2424</span>            <span class="keyword">with</span> com.temp_setattr(self, <span class="stringliteral">&quot;observed&quot;</span>, <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 2425</span>                result = self._agg_general(</div>
<div class="line"><span class="lineno"> 2426</span>                    numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2427</span>                    min_count=min_count,</div>
<div class="line"><span class="lineno"> 2428</span>                    alias=<span class="stringliteral">&quot;sum&quot;</span>,</div>
<div class="line"><span class="lineno"> 2429</span>                    npfunc=np.sum,</div>
<div class="line"><span class="lineno"> 2430</span>                )</div>
<div class="line"><span class="lineno"> 2431</span> </div>
<div class="line"><span class="lineno"> 2432</span>            <span class="keywordflow">return</span> self._reindex_output(result, fill_value=0)</div>
<div class="line"><span class="lineno"> 2433</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a763a9595f945252ec15615cf0165dc26" name="a763a9595f945252ec15615cf0165dc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763a9595f945252ec15615cf0165dc26">&#9670;&#160;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NDFrameT pandas.core.groupby.groupby.GroupBy.tail </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>n</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return last n rows of each group.

Similar to ``.apply(lambda x: x.tail(n))``, but it returns a subset of rows
from the original DataFrame with original index and order preserved
(``as_index`` flag is ignored).

Parameters
----------
n : int
    If positive: number of entries to include from end of each group.
    If negative: number of entries to exclude from start of each group.

Returns
-------
Series or DataFrame
    Subset of original Series or DataFrame as determined by n.
%(see_also)s
Examples
--------

&gt;&gt;&gt; df = pd.DataFrame([['a', 1], ['a', 2], ['b', 1], ['b', 2]],
...                   columns=['A', 'B'])
&gt;&gt;&gt; df.groupby('A').tail(1)
   A  B
1  a  2
3  b  2
&gt;&gt;&gt; df.groupby('A').tail(-1)
   A  B
1  a  2
3  b  2
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4021</span>    <span class="keyword">def </span>tail(self, n: int = 5) -&gt; NDFrameT:</div>
<div class="line"><span class="lineno"> 4022</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4023</span><span class="stringliteral">        Return last n rows of each group.</span></div>
<div class="line"><span class="lineno"> 4024</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4025</span><span class="stringliteral">        Similar to ``.apply(lambda x: x.tail(n))``, but it returns a subset of rows</span></div>
<div class="line"><span class="lineno"> 4026</span><span class="stringliteral">        from the original DataFrame with original index and order preserved</span></div>
<div class="line"><span class="lineno"> 4027</span><span class="stringliteral">        (``as_index`` flag is ignored).</span></div>
<div class="line"><span class="lineno"> 4028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4029</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4030</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4031</span><span class="stringliteral">        n : int</span></div>
<div class="line"><span class="lineno"> 4032</span><span class="stringliteral">            If positive: number of entries to include from end of each group.</span></div>
<div class="line"><span class="lineno"> 4033</span><span class="stringliteral">            If negative: number of entries to exclude from start of each group.</span></div>
<div class="line"><span class="lineno"> 4034</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4035</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 4036</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 4037</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 4038</span><span class="stringliteral">            Subset of original Series or DataFrame as determined by n.</span></div>
<div class="line"><span class="lineno"> 4039</span><span class="stringliteral">        %(see_also)s</span></div>
<div class="line"><span class="lineno"> 4040</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 4041</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 4042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4043</span><span class="stringliteral">        &gt;&gt;&gt; df = pd.DataFrame([[&#39;a&#39;, 1], [&#39;a&#39;, 2], [&#39;b&#39;, 1], [&#39;b&#39;, 2]],</span></div>
<div class="line"><span class="lineno"> 4044</span><span class="stringliteral">        ...                   columns=[&#39;A&#39;, &#39;B&#39;])</span></div>
<div class="line"><span class="lineno"> 4045</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).tail(1)</span></div>
<div class="line"><span class="lineno"> 4046</span><span class="stringliteral">           A  B</span></div>
<div class="line"><span class="lineno"> 4047</span><span class="stringliteral">        1  a  2</span></div>
<div class="line"><span class="lineno"> 4048</span><span class="stringliteral">        3  b  2</span></div>
<div class="line"><span class="lineno"> 4049</span><span class="stringliteral">        &gt;&gt;&gt; df.groupby(&#39;A&#39;).tail(-1)</span></div>
<div class="line"><span class="lineno"> 4050</span><span class="stringliteral">           A  B</span></div>
<div class="line"><span class="lineno"> 4051</span><span class="stringliteral">        1  a  2</span></div>
<div class="line"><span class="lineno"> 4052</span><span class="stringliteral">        3  b  2</span></div>
<div class="line"><span class="lineno"> 4053</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4054</span>        self._reset_group_selection()</div>
<div class="line"><span class="lineno"> 4055</span>        <span class="keywordflow">if</span> n:</div>
<div class="line"><span class="lineno"> 4056</span>            mask = self._make_mask_from_positional_indexer(slice(-n, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno"> 4057</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4058</span>            mask = self._make_mask_from_positional_indexer([])</div>
<div class="line"><span class="lineno"> 4059</span> </div>
<div class="line"><span class="lineno"> 4060</span>        <span class="keywordflow">return</span> self._mask_selected_obj(mask)</div>
<div class="line"><span class="lineno"> 4061</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a280b92347376a05d27cf8e614410bee1" name="a280b92347376a05d27cf8e614410bee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280b92347376a05d27cf8e614410bee1">&#9670;&#160;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.var </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>engine</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, bool] | None &#160;</td>
          <td class="paramname"><em>engine_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | lib.NoDefault &#160;</td>
          <td class="paramname"><em>numeric_only</em> = <code>lib.no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute variance of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex.

Parameters
----------
ddof : int, default 1
    Degrees of freedom.

engine : str, default None
    * ``'cython'`` : Runs the operation through C-extensions from cython.
    * ``'numba'`` : Runs the operation through JIT compiled code from numba.
    * ``None`` : Defaults to ``'cython'`` or globally setting
      ``compute.use_numba``

    .. versionadded:: 1.4.0

engine_kwargs : dict, default None
    * For ``'cython'`` engine, there are no accepted ``engine_kwargs``
    * For ``'numba'`` engine, the engine can accept ``nopython``, ``nogil``
      and ``parallel`` dictionary keys. The values must either be ``True`` or
      ``False``. The default ``engine_kwargs`` for the ``'numba'`` engine is
      ``{{'nopython': True, 'nogil': False, 'parallel': False}}``

    .. versionadded:: 1.4.0

numeric_only : bool, default True
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

Returns
-------
Series or DataFrame
    Variance of values within each group.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2271</span>    ):</div>
<div class="line"><span class="lineno"> 2272</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2273</span><span class="stringliteral">        Compute variance of groups, excluding missing values.</span></div>
<div class="line"><span class="lineno"> 2274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2275</span><span class="stringliteral">        For multiple groupings, the result index will be a MultiIndex.</span></div>
<div class="line"><span class="lineno"> 2276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2277</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2278</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2279</span><span class="stringliteral">        ddof : int, default 1</span></div>
<div class="line"><span class="lineno"> 2280</span><span class="stringliteral">            Degrees of freedom.</span></div>
<div class="line"><span class="lineno"> 2281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2282</span><span class="stringliteral">        engine : str, default None</span></div>
<div class="line"><span class="lineno"> 2283</span><span class="stringliteral">            * ``&#39;cython&#39;`` : Runs the operation through C-extensions from cython.</span></div>
<div class="line"><span class="lineno"> 2284</span><span class="stringliteral">            * ``&#39;numba&#39;`` : Runs the operation through JIT compiled code from numba.</span></div>
<div class="line"><span class="lineno"> 2285</span><span class="stringliteral">            * ``None`` : Defaults to ``&#39;cython&#39;`` or globally setting</span></div>
<div class="line"><span class="lineno"> 2286</span><span class="stringliteral">              ``compute.use_numba``</span></div>
<div class="line"><span class="lineno"> 2287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2288</span><span class="stringliteral">            .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 2289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2290</span><span class="stringliteral">        engine_kwargs : dict, default None</span></div>
<div class="line"><span class="lineno"> 2291</span><span class="stringliteral">            * For ``&#39;cython&#39;`` engine, there are no accepted ``engine_kwargs``</span></div>
<div class="line"><span class="lineno"> 2292</span><span class="stringliteral">            * For ``&#39;numba&#39;`` engine, the engine can accept ``nopython``, ``nogil``</span></div>
<div class="line"><span class="lineno"> 2293</span><span class="stringliteral">              and ``parallel`` dictionary keys. The values must either be ``True`` or</span></div>
<div class="line"><span class="lineno"> 2294</span><span class="stringliteral">              ``False``. The default ``engine_kwargs`` for the ``&#39;numba&#39;`` engine is</span></div>
<div class="line"><span class="lineno"> 2295</span><span class="stringliteral">              ``{{&#39;nopython&#39;: True, &#39;nogil&#39;: False, &#39;parallel&#39;: False}}``</span></div>
<div class="line"><span class="lineno"> 2296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2297</span><span class="stringliteral">            .. versionadded:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 2298</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2299</span><span class="stringliteral">        numeric_only : bool, default True</span></div>
<div class="line"><span class="lineno"> 2300</span><span class="stringliteral">            Include only `float`, `int` or `boolean` data.</span></div>
<div class="line"><span class="lineno"> 2301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2302</span><span class="stringliteral">            .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 2303</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2304</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2305</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2306</span><span class="stringliteral">        Series or DataFrame</span></div>
<div class="line"><span class="lineno"> 2307</span><span class="stringliteral">            Variance of values within each group.</span></div>
<div class="line"><span class="lineno"> 2308</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2309</span>        <span class="keywordflow">if</span> maybe_use_numba(engine):</div>
<div class="line"><span class="lineno"> 2310</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1__numba_1_1kernels.html">pandas.core._numba.kernels</a> <span class="keyword">import</span> sliding_var</div>
<div class="line"><span class="lineno"> 2311</span> </div>
<div class="line"><span class="lineno"> 2312</span>            <span class="keywordflow">return</span> self._numba_agg_general(sliding_var, engine_kwargs, ddof)</div>
<div class="line"><span class="lineno"> 2313</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2314</span>            <span class="keywordflow">return</span> self._cython_agg_general(</div>
<div class="line"><span class="lineno"> 2315</span>                <span class="stringliteral">&quot;var&quot;</span>,</div>
<div class="line"><span class="lineno"> 2316</span>                alt=<span class="keyword">lambda</span> x: Series(x).var(ddof=ddof),</div>
<div class="line"><span class="lineno"> 2317</span>                numeric_only=numeric_only,</div>
<div class="line"><span class="lineno"> 2318</span>                ignore_failures=numeric_only <span class="keywordflow">is</span> lib.no_default,</div>
<div class="line"><span class="lineno"> 2319</span>                ddof=ddof,</div>
<div class="line"><span class="lineno"> 2320</span>            )</div>
<div class="line"><span class="lineno"> 2321</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aff99672d810c7fc573dfda274d594902" name="aff99672d810c7fc573dfda274d594902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff99672d810c7fc573dfda274d594902">&#9670;&#160;</a></span>_group_selection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._group_selection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ece12e82ff5f534105bb530a9ab8d7b" name="a8ece12e82ff5f534105bb530a9ab8d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ece12e82ff5f534105bb530a9ab8d7b">&#9670;&#160;</a></span>_obj_with_exclusions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._obj_with_exclusions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e9c3764acd40f62b4463bf8aa235190" name="a6e9c3764acd40f62b4463bf8aa235190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9c3764acd40f62b4463bf8aa235190">&#9670;&#160;</a></span>_selected_obj</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._selected_obj</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91472f24fd5afcc07a81edd04b4a5328" name="a91472f24fd5afcc07a81edd04b4a5328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91472f24fd5afcc07a81edd04b4a5328">&#9670;&#160;</a></span>_selection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy._selection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95f69def69abf91e4ed27e2f215b6645" name="a95f69def69abf91e4ed27e2f215b6645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f69def69abf91e4ed27e2f215b6645">&#9670;&#160;</a></span>as_index <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.groupby.groupby.GroupBy.as_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92fb589411ebb1a7c1a8babfe74987d1" name="a92fb589411ebb1a7c1a8babfe74987d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fb589411ebb1a7c1a8babfe74987d1">&#9670;&#160;</a></span>as_index <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.as_index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9cb972cc96e0e06c7d409ebed5dcf88" name="ae9cb972cc96e0e06c7d409ebed5dcf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cb972cc96e0e06c7d409ebed5dcf88">&#9670;&#160;</a></span>axis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.axis</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27e6d7322e8c242ea87594807d342c6b" name="a27e6d7322e8c242ea87594807d342c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e6d7322e8c242ea87594807d342c6b">&#9670;&#160;</a></span>dropna</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.dropna</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba8874c98a4d0fc618ae3ab735d83798" name="aba8874c98a4d0fc618ae3ab735d83798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8874c98a4d0fc618ae3ab735d83798">&#9670;&#160;</a></span>exclusions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.exclusions</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae43cf53a5fc86038b9ae1fcb50353232" name="ae43cf53a5fc86038b9ae1fcb50353232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43cf53a5fc86038b9ae1fcb50353232">&#9670;&#160;</a></span>group_keys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.group_keys</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d2ac167a7fdcb6e19af4f6f27a12389" name="a0d2ac167a7fdcb6e19af4f6f27a12389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2ac167a7fdcb6e19af4f6f27a12389">&#9670;&#160;</a></span>grouper <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ops pandas.core.groupby.groupby.GroupBy.grouper .BaseGrouper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a566c441bac194b364f4fd6f9a8dd54ac" name="a566c441bac194b364f4fd6f9a8dd54ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566c441bac194b364f4fd6f9a8dd54ac">&#9670;&#160;</a></span>grouper <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.grouper</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab885b4c07c7081d8f3bd8bfd51d9cad5" name="ab885b4c07c7081d8f3bd8bfd51d9cad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab885b4c07c7081d8f3bd8bfd51d9cad5">&#9670;&#160;</a></span>keys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.keys</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a5c3daddc0cd71d53ae1703376ba230" name="a2a5c3daddc0cd71d53ae1703376ba230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5c3daddc0cd71d53ae1703376ba230">&#9670;&#160;</a></span>level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.level</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9db815a5bbf93811613940f59ba04c92" name="a9db815a5bbf93811613940f59ba04c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db815a5bbf93811613940f59ba04c92">&#9670;&#160;</a></span>mutated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.mutated</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91097da9d4d374715a4d041be326bae0" name="a91097da9d4d374715a4d041be326bae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91097da9d4d374715a4d041be326bae0">&#9670;&#160;</a></span>ngroups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.ngroups</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e8befeb0c9e7da25600d0119af3f726" name="a1e8befeb0c9e7da25600d0119af3f726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8befeb0c9e7da25600d0119af3f726">&#9670;&#160;</a></span>obj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.obj</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad235e29e75ce0c2ea71fc58f3833d4a" name="aad235e29e75ce0c2ea71fc58f3833d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad235e29e75ce0c2ea71fc58f3833d4a">&#9670;&#160;</a></span>observed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.observed</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa716330d6113b7f0d85e594d84f7c83a" name="aa716330d6113b7f0d85e594d84f7c83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa716330d6113b7f0d85e594d84f7c83a">&#9670;&#160;</a></span>sort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.sort</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa824c16a2c4172ecca99029f7947fb95" name="aa824c16a2c4172ecca99029f7947fb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa824c16a2c4172ecca99029f7947fb95">&#9670;&#160;</a></span>squeeze</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.groupby.groupby.GroupBy.squeeze</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/pandas/core/groupby/<a class="el" href="core_2groupby_2groupby_8py.html">groupby.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
