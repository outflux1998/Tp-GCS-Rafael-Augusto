<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.tools.datetimes Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1tools.html">tools</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html">datetimes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.tools.datetimes Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1tools_1_1datetimes_1_1_fulldatetime_dict.html">FulldatetimeDict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1tools_1_1datetimes_1_1_year_month_day_dict.html">YearMonthDayDict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8f703db251011d5a8487060ee3084c4a" id="r_a8f703db251011d5a8487060ee3084c4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8f703db251011d5a8487060ee3084c4a">_guess_datetime_format_for_array</a> (arr, bool|None dayfirst=False)</td></tr>
<tr class="separator:a8f703db251011d5a8487060ee3084c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482e72c6249c75d23ffb683148a41d26" id="r_a482e72c6249c75d23ffb683148a41d26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a482e72c6249c75d23ffb683148a41d26">should_cache</a> (<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a84b1dd1a397c88da61c405304f0cb259">ArrayConvertible</a> arg, float unique_share=0.7, int|None check_count=None)</td></tr>
<tr class="separator:a482e72c6249c75d23ffb683148a41d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7a3d21d66bb29c37b57464b7c67699" id="r_add7a3d21d66bb29c37b57464b7c67699"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#add7a3d21d66bb29c37b57464b7c67699">_maybe_cache</a> (<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a84b1dd1a397c88da61c405304f0cb259">ArrayConvertible</a> arg, str|None format, bool cache, Callable convert_listlike)</td></tr>
<tr class="separator:add7a3d21d66bb29c37b57464b7c67699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c4e7673fa31721b5aa0fa9b12570ad" id="r_a17c4e7673fa31721b5aa0fa9b12570ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a17c4e7673fa31721b5aa0fa9b12570ad">_box_as_indexlike</a> (ArrayLike dt_array, bool|None utc=None, Hashable name=None)</td></tr>
<tr class="separator:a17c4e7673fa31721b5aa0fa9b12570ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a01f6153e301c2ec92e5c9cd82aa730" id="r_a1a01f6153e301c2ec92e5c9cd82aa730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a1a01f6153e301c2ec92e5c9cd82aa730">_convert_and_box_cache</a> (<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8217e588e94ff87dbb2f21b512aea797">DatetimeScalarOrArrayConvertible</a> arg, Series cache_array, Hashable|None name=None)</td></tr>
<tr class="separator:a1a01f6153e301c2ec92e5c9cd82aa730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4eb2797838120e451bcf076fb1ed4c0" id="r_af4eb2797838120e451bcf076fb1ed4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#af4eb2797838120e451bcf076fb1ed4c0">_return_parsed_timezone_results</a> (np.ndarray result, timezones, tz, name)</td></tr>
<tr class="separator:af4eb2797838120e451bcf076fb1ed4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e87e929133681214cfe6ba2a4544e2" id="r_ab0e87e929133681214cfe6ba2a4544e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#ab0e87e929133681214cfe6ba2a4544e2">_convert_listlike_datetimes</a> (arg, str|None format, Hashable name=None, Timezone|None tz=None, str|None unit=None, str errors=&quot;raise&quot;, bool infer_datetime_format=False, bool|None dayfirst=None, bool|None yearfirst=None, bool exact=True)</td></tr>
<tr class="separator:ab0e87e929133681214cfe6ba2a4544e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c453de1a09849efa3427d19bd140297" id="r_a9c453de1a09849efa3427d19bd140297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a9c453de1a09849efa3427d19bd140297">_array_strptime_with_fallback</a> (arg, name, tz, str fmt, bool exact, str errors, bool infer_datetime_format)</td></tr>
<tr class="separator:a9c453de1a09849efa3427d19bd140297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba34683c771e42a8f588e2c029564830" id="r_aba34683c771e42a8f588e2c029564830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aba34683c771e42a8f588e2c029564830">_to_datetime_with_format</a> (arg, orig_arg, name, tz, str fmt, bool exact, str errors, bool infer_datetime_format)</td></tr>
<tr class="separator:aba34683c771e42a8f588e2c029564830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4576d06377494c86492939edf3558a83" id="r_a4576d06377494c86492939edf3558a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a4576d06377494c86492939edf3558a83">_to_datetime_with_unit</a> (arg, unit, name, tz, str errors)</td></tr>
<tr class="separator:a4576d06377494c86492939edf3558a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530f0807dc86525f0380d84096272d5e" id="r_a530f0807dc86525f0380d84096272d5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a530f0807dc86525f0380d84096272d5e">_adjust_to_origin</a> (arg, origin, unit)</td></tr>
<tr class="separator:a530f0807dc86525f0380d84096272d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2568fe23b8737e519bdb6930b268304" id="r_ac2568fe23b8737e519bdb6930b268304"><td class="memItemLeft" align="right" valign="top">Timestamp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#ac2568fe23b8737e519bdb6930b268304">to_datetime</a> (<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aad678b01744f19f8a5268bfd6fa56592">DatetimeScalar</a> arg, DateTimeErrorChoices errors=..., bool dayfirst=..., bool yearfirst=..., bool|None utc=..., str|None format=..., bool exact=..., str|None unit=..., bool infer_datetime_format=..., origin=..., bool cache=...)</td></tr>
<tr class="separator:ac2568fe23b8737e519bdb6930b268304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26c55dc254a7ad369082749ad007a97" id="r_aa26c55dc254a7ad369082749ad007a97"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aa26c55dc254a7ad369082749ad007a97">to_datetime</a> (Series|<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8abf3f5e6ff0903da2999f6315ee14c6">DictConvertible</a> arg, DateTimeErrorChoices errors=..., bool dayfirst=..., bool yearfirst=..., bool|None utc=..., str|None format=..., bool exact=..., str|None unit=..., bool infer_datetime_format=..., origin=..., bool cache=...)</td></tr>
<tr class="separator:aa26c55dc254a7ad369082749ad007a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951afd0cfb09c39049ac620d40e32cf" id="r_a1951afd0cfb09c39049ac620d40e32cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html">DatetimeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a1951afd0cfb09c39049ac620d40e32cf">to_datetime</a> (list|tuple|<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|ArrayLike arg, DateTimeErrorChoices errors=..., bool dayfirst=..., bool yearfirst=..., bool|None utc=..., str|None format=..., bool exact=..., str|None unit=..., bool infer_datetime_format=..., origin=..., bool cache=...)</td></tr>
<tr class="separator:a1951afd0cfb09c39049ac620d40e32cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7d2650ec8a36239f9180a1cf34052a" id="r_a4e7d2650ec8a36239f9180a1cf34052a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html">DatetimeIndex</a>|Series|<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aad678b01744f19f8a5268bfd6fa56592">DatetimeScalar</a>|NaTType|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a4e7d2650ec8a36239f9180a1cf34052a">to_datetime</a> (<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8217e588e94ff87dbb2f21b512aea797">DatetimeScalarOrArrayConvertible</a>|<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8abf3f5e6ff0903da2999f6315ee14c6">DictConvertible</a> arg, DateTimeErrorChoices errors=&quot;raise&quot;, bool dayfirst=False, bool yearfirst=False, bool|None utc=None, str|None format=None, bool exact=True, str|None unit=None, bool infer_datetime_format=False, origin=&quot;unix&quot;, bool cache=True)</td></tr>
<tr class="separator:a4e7d2650ec8a36239f9180a1cf34052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c7dd19dbf31f48b0f4b5f2444d62c9" id="r_a60c7dd19dbf31f48b0f4b5f2444d62c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a60c7dd19dbf31f48b0f4b5f2444d62c9">_assemble_from_unit_mappings</a> (arg, DateTimeErrorChoices errors, tz)</td></tr>
<tr class="separator:a60c7dd19dbf31f48b0f4b5f2444d62c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e1a0270af241c01177b6582ea16760" id="r_a99e1a0270af241c01177b6582ea16760"><td class="memItemLeft" align="right" valign="top">np.ndarray|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a99e1a0270af241c01177b6582ea16760">_attempt_YYYYMMDD</a> (npt.NDArray[np.object_] arg, str errors)</td></tr>
<tr class="separator:a99e1a0270af241c01177b6582ea16760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa29bb4b7aa364ef830fc7012d7a0561" id="r_afa29bb4b7aa364ef830fc7012d7a0561"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#afa29bb4b7aa364ef830fc7012d7a0561">to_time</a> (arg, format=None, infer_time_format=False, errors=&quot;raise&quot;)</td></tr>
<tr class="separator:afa29bb4b7aa364ef830fc7012d7a0561"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a84b1dd1a397c88da61c405304f0cb259" id="r_a84b1dd1a397c88da61c405304f0cb259"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a84b1dd1a397c88da61c405304f0cb259">ArrayConvertible</a> = Union[List, Tuple, AnyArrayLike]</td></tr>
<tr class="separator:a84b1dd1a397c88da61c405304f0cb259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fa70511896af507a8512507be5aa99" id="r_a02fa70511896af507a8512507be5aa99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a02fa70511896af507a8512507be5aa99">Scalar</a> = Union[float, str]</td></tr>
<tr class="separator:a02fa70511896af507a8512507be5aa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad678b01744f19f8a5268bfd6fa56592" id="r_aad678b01744f19f8a5268bfd6fa56592"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aad678b01744f19f8a5268bfd6fa56592">DatetimeScalar</a> = Union[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a02fa70511896af507a8512507be5aa99">Scalar</a>, datetime]</td></tr>
<tr class="separator:aad678b01744f19f8a5268bfd6fa56592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8217e588e94ff87dbb2f21b512aea797" id="r_a8217e588e94ff87dbb2f21b512aea797"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8217e588e94ff87dbb2f21b512aea797">DatetimeScalarOrArrayConvertible</a> = Union[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aad678b01744f19f8a5268bfd6fa56592">DatetimeScalar</a>, <a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a84b1dd1a397c88da61c405304f0cb259">ArrayConvertible</a>]</td></tr>
<tr class="separator:a8217e588e94ff87dbb2f21b512aea797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce79427c6728ded3dbf7779ec6b371d" id="r_a3ce79427c6728ded3dbf7779ec6b371d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a3ce79427c6728ded3dbf7779ec6b371d">DatetimeDictArg</a> = Union[List[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a02fa70511896af507a8512507be5aa99">Scalar</a>], Tuple[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a02fa70511896af507a8512507be5aa99">Scalar</a>, ...], AnyArrayLike]</td></tr>
<tr class="separator:a3ce79427c6728ded3dbf7779ec6b371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf3f5e6ff0903da2999f6315ee14c6" id="r_a8abf3f5e6ff0903da2999f6315ee14c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8abf3f5e6ff0903da2999f6315ee14c6">DictConvertible</a> = Union[<a class="el" href="classpandas_1_1core_1_1tools_1_1datetimes_1_1_fulldatetime_dict.html">FulldatetimeDict</a>, &quot;DataFrame&quot;]</td></tr>
<tr class="separator:a8abf3f5e6ff0903da2999f6315ee14c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699494cc01fb31a3e719d6492100c326" id="r_a699494cc01fb31a3e719d6492100c326"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a699494cc01fb31a3e719d6492100c326">start_caching_at</a> = 50</td></tr>
<tr class="separator:a699494cc01fb31a3e719d6492100c326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b3451c8df8c5976cb278f8da0aca86" id="r_a79b3451c8df8c5976cb278f8da0aca86"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a79b3451c8df8c5976cb278f8da0aca86">_unit_map</a></td></tr>
<tr class="separator:a79b3451c8df8c5976cb278f8da0aca86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a530f0807dc86525f0380d84096272d5e" name="a530f0807dc86525f0380d84096272d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530f0807dc86525f0380d84096272d5e">&#9670;&#160;</a></span>_adjust_to_origin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes._adjust_to_origin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function for to_datetime.
Adjust input argument to the specified origin

Parameters
----------
arg : list, tuple, ndarray, Series, Index
    date to be adjusted
origin : 'julian' or Timestamp
    origin offset for the arg
unit : str
    passed unit from to_datetime, must be 'D'

Returns
-------
ndarray or scalar of adjusted date(s)
</pre> <div class="fragment"><div class="line"><span class="lineno">  581</span><span class="keyword">def </span>_adjust_to_origin(arg, origin, unit):</div>
<div class="line"><span class="lineno">  582</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    Helper function for to_datetime.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    Adjust input argument to the specified origin</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    arg : list, tuple, ndarray, Series, Index</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        date to be adjusted</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    origin : &#39;julian&#39; or Timestamp</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        origin offset for the arg</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    unit : str</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        passed unit from to_datetime, must be &#39;D&#39;</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    ndarray or scalar of adjusted date(s)</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  599</span>    <span class="keywordflow">if</span> origin == <span class="stringliteral">&quot;julian&quot;</span>:</div>
<div class="line"><span class="lineno">  600</span>        original = arg</div>
<div class="line"><span class="lineno">  601</span>        j0 = Timestamp(0).to_julian_date()</div>
<div class="line"><span class="lineno">  602</span>        <span class="keywordflow">if</span> unit != <span class="stringliteral">&quot;D&quot;</span>:</div>
<div class="line"><span class="lineno">  603</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;unit must be &#39;D&#39; for origin=&#39;julian&#39;&quot;</span>)</div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  605</span>            arg = arg - j0</div>
<div class="line"><span class="lineno">  606</span>        <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  607</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  608</span>                <span class="stringliteral">&quot;incompatible &#39;arg&#39; type for given &#39;origin&#39;=&#39;julian&#39;&quot;</span></div>
<div class="line"><span class="lineno">  609</span>            ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  610</span> </div>
<div class="line"><span class="lineno">  611</span>        <span class="comment"># preemptively check this for a nice range</span></div>
<div class="line"><span class="lineno">  612</span>        j_max = Timestamp.max.to_julian_date() - j0</div>
<div class="line"><span class="lineno">  613</span>        j_min = Timestamp.min.to_julian_date() - j0</div>
<div class="line"><span class="lineno">  614</span>        <span class="keywordflow">if</span> np.any(arg &gt; j_max) <span class="keywordflow">or</span> np.any(arg &lt; j_min):</div>
<div class="line"><span class="lineno">  615</span>            <span class="keywordflow">raise</span> OutOfBoundsDatetime(</div>
<div class="line"><span class="lineno">  616</span>                f<span class="stringliteral">&quot;{original} is Out of Bounds for origin=&#39;julian&#39;&quot;</span></div>
<div class="line"><span class="lineno">  617</span>            )</div>
<div class="line"><span class="lineno">  618</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  619</span>        <span class="comment"># arg must be numeric</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno">  621</span>            (is_scalar(arg) <span class="keywordflow">and</span> (is_integer(arg) <span class="keywordflow">or</span> is_float(arg)))</div>
<div class="line"><span class="lineno">  622</span>            <span class="keywordflow">or</span> is_numeric_dtype(np.asarray(arg))</div>
<div class="line"><span class="lineno">  623</span>        ):</div>
<div class="line"><span class="lineno">  624</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  625</span>                f<span class="stringliteral">&quot;&#39;{arg}&#39; is not compatible with origin=&#39;{origin}&#39;; &quot;</span></div>
<div class="line"><span class="lineno">  626</span>                <span class="stringliteral">&quot;it must be numeric with a unit specified&quot;</span></div>
<div class="line"><span class="lineno">  627</span>            )</div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="line"><span class="lineno">  629</span>        <span class="comment"># we are going to offset back to unix / epoch time</span></div>
<div class="line"><span class="lineno">  630</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  631</span>            offset = Timestamp(origin)</div>
<div class="line"><span class="lineno">  632</span>        <span class="keywordflow">except</span> OutOfBoundsDatetime <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  633</span>            <span class="keywordflow">raise</span> OutOfBoundsDatetime(f<span class="stringliteral">&quot;origin {origin} is Out of Bounds&quot;</span>) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  634</span>        <span class="keywordflow">except</span> ValueError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  635</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  636</span>                f<span class="stringliteral">&quot;origin {origin} cannot be converted to a Timestamp&quot;</span></div>
<div class="line"><span class="lineno">  637</span>            ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span>        <span class="keywordflow">if</span> offset.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  640</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;origin offset {offset} must be tz-naive&quot;</span>)</div>
<div class="line"><span class="lineno">  641</span>        td_offset = offset - Timestamp(0)</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>        <span class="comment"># convert the offset to the unit of the arg</span></div>
<div class="line"><span class="lineno">  644</span>        <span class="comment"># this should be lossless in terms of precision</span></div>
<div class="line"><span class="lineno">  645</span>        ioffset = td_offset // Timedelta(1, unit=unit)</div>
<div class="line"><span class="lineno">  646</span> </div>
<div class="line"><span class="lineno">  647</span>        <span class="comment"># scalars &amp; ndarray-like can handle the addition</span></div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">if</span> is_list_like(arg) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(arg, (ABCSeries, Index, np.ndarray)):</div>
<div class="line"><span class="lineno">  649</span>            arg = np.asarray(arg)</div>
<div class="line"><span class="lineno">  650</span>        arg = arg + ioffset</div>
<div class="line"><span class="lineno">  651</span>    <span class="keywordflow">return</span> arg</div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span> </div>
<div class="line"><span class="lineno">  654</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c453de1a09849efa3427d19bd140297" name="a9c453de1a09849efa3427d19bd140297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c453de1a09849efa3427d19bd140297">&#9670;&#160;</a></span>_array_strptime_with_fallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | None pandas.core.tools.datetimes._array_strptime_with_fallback </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>infer_datetime_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Call array_strptime, with fallback behavior depending on 'errors'.
</pre> <div class="fragment"><div class="line"><span class="lineno">  466</span>) -&gt; Index | <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  467</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">    Call array_strptime, with fallback behavior depending on &#39;errors&#39;.</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  470</span>    utc = tz == <span class="stringliteral">&quot;utc&quot;</span></div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  473</span>        result, timezones = array_strptime(arg, fmt, exact=exact, errors=errors)</div>
<div class="line"><span class="lineno">  474</span>    <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno">  475</span>        <span class="keywordflow">if</span> errors == <span class="stringliteral">&quot;raise&quot;</span>:</div>
<div class="line"><span class="lineno">  476</span>            <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  477</span>        <span class="keywordflow">elif</span> errors == <span class="stringliteral">&quot;coerce&quot;</span>:</div>
<div class="line"><span class="lineno">  478</span>            result = np.empty(arg.shape, dtype=<span class="stringliteral">&quot;M8[ns]&quot;</span>)</div>
<div class="line"><span class="lineno">  479</span>            iresult = result.view(<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno">  480</span>            iresult.fill(iNaT)</div>
<div class="line"><span class="lineno">  481</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  482</span>            result = arg</div>
<div class="line"><span class="lineno">  483</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  484</span>        <span class="comment"># if fmt was inferred, try falling back</span></div>
<div class="line"><span class="lineno">  485</span>        <span class="comment"># to array_to_datetime - terminate here</span></div>
<div class="line"><span class="lineno">  486</span>        <span class="comment"># for specified formats</span></div>
<div class="line"><span class="lineno">  487</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> infer_datetime_format:</div>
<div class="line"><span class="lineno">  488</span>            <span class="keywordflow">if</span> errors == <span class="stringliteral">&quot;raise&quot;</span>:</div>
<div class="line"><span class="lineno">  489</span>                <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  490</span>            <span class="keywordflow">elif</span> errors == <span class="stringliteral">&quot;coerce&quot;</span>:</div>
<div class="line"><span class="lineno">  491</span>                result = np.empty(arg.shape, dtype=<span class="stringliteral">&quot;M8[ns]&quot;</span>)</div>
<div class="line"><span class="lineno">  492</span>                iresult = result.view(<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno">  493</span>                iresult.fill(iNaT)</div>
<div class="line"><span class="lineno">  494</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  495</span>                result = arg</div>
<div class="line"><span class="lineno">  496</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  497</span>            <span class="comment"># Indicates to the caller to fallback to objects_to_datetime64ns</span></div>
<div class="line"><span class="lineno">  498</span>            <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  499</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  500</span>        <span class="keywordflow">if</span> <span class="stringliteral">&quot;%Z&quot;</span> <span class="keywordflow">in</span> fmt <span class="keywordflow">or</span> <span class="stringliteral">&quot;%z&quot;</span> <span class="keywordflow">in</span> fmt:</div>
<div class="line"><span class="lineno">  501</span>            <span class="keywordflow">return</span> _return_parsed_timezone_results(result, timezones, tz, name)</div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span>    <span class="keywordflow">return</span> _box_as_indexlike(result, utc=utc, name=name)</div>
<div class="line"><span class="lineno">  504</span> </div>
<div class="line"><span class="lineno">  505</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a60c7dd19dbf31f48b0f4b5f2444d62c9" name="a60c7dd19dbf31f48b0f4b5f2444d62c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c7dd19dbf31f48b0f4b5f2444d62c9">&#9670;&#160;</a></span>_assemble_from_unit_mappings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes._assemble_from_unit_mappings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTimeErrorChoices&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">assemble the unit specified fields from the arg (DataFrame)
Return a Series for actual parsing

Parameters
----------
arg : DataFrame
errors : {'ignore', 'raise', 'coerce'}, default 'raise'

    - If :const:`'raise'`, then invalid parsing will raise an exception
    - If :const:`'coerce'`, then invalid parsing will be set as :const:`NaT`
    - If :const:`'ignore'`, then invalid parsing will return the input
tz : None or 'utc'

Returns
-------
Series
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1138</span><span class="keyword">def </span>_assemble_from_unit_mappings(arg, errors: DateTimeErrorChoices, tz):</div>
<div class="line"><span class="lineno"> 1139</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    assemble the unit specified fields from the arg (DataFrame)</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">    Return a Series for actual parsing</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">    arg : DataFrame</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    errors : {&#39;ignore&#39;, &#39;raise&#39;, &#39;coerce&#39;}, default &#39;raise&#39;</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">        - If :const:`&#39;raise&#39;`, then invalid parsing will raise an exception</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">        - If :const:`&#39;coerce&#39;`, then invalid parsing will be set as :const:`NaT`</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">        - If :const:`&#39;ignore&#39;`, then invalid parsing will return the input</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    tz : None or &#39;utc&#39;</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    Series</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1157</span>    <span class="keyword">from</span> pandas <span class="keyword">import</span> (</div>
<div class="line"><span class="lineno"> 1158</span>        DataFrame,</div>
<div class="line"><span class="lineno"> 1159</span>        to_numeric,</div>
<div class="line"><span class="lineno"> 1160</span>        to_timedelta,</div>
<div class="line"><span class="lineno"> 1161</span>    )</div>
<div class="line"><span class="lineno"> 1162</span> </div>
<div class="line"><span class="lineno"> 1163</span>    arg = DataFrame(arg)</div>
<div class="line"><span class="lineno"> 1164</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> arg.columns.is_unique:</div>
<div class="line"><span class="lineno"> 1165</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot assemble with duplicate keys&quot;</span>)</div>
<div class="line"><span class="lineno"> 1166</span> </div>
<div class="line"><span class="lineno"> 1167</span>    <span class="comment"># replace passed unit with _unit_map</span></div>
<div class="line"><span class="lineno"> 1168</span>    <span class="keyword">def </span><a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(value):</div>
<div class="line"><span class="lineno"> 1169</span>        <span class="keywordflow">if</span> value <span class="keywordflow">in</span> _unit_map:</div>
<div class="line"><span class="lineno"> 1170</span>            <span class="keywordflow">return</span> _unit_map[value]</div>
<div class="line"><span class="lineno"> 1171</span> </div>
<div class="line"><span class="lineno"> 1172</span>        <span class="comment"># m is case significant</span></div>
<div class="line"><span class="lineno"> 1173</span>        <span class="keywordflow">if</span> value.lower() <span class="keywordflow">in</span> _unit_map:</div>
<div class="line"><span class="lineno"> 1174</span>            <span class="keywordflow">return</span> _unit_map[value.lower()]</div>
<div class="line"><span class="lineno"> 1175</span> </div>
<div class="line"><span class="lineno"> 1176</span>        <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno"> 1177</span> </div>
<div class="line"><span class="lineno"> 1178</span>    unit = {k: <a class="code hl_variable" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>(k) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> arg.keys()}</div>
<div class="line"><span class="lineno"> 1179</span>    unit_rev = {v: k <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> unit.items()}</div>
<div class="line"><span class="lineno"> 1180</span> </div>
<div class="line"><span class="lineno"> 1181</span>    <span class="comment"># we require at least Ymd</span></div>
<div class="line"><span class="lineno"> 1182</span>    required = [<span class="stringliteral">&quot;year&quot;</span>, <span class="stringliteral">&quot;month&quot;</span>, <span class="stringliteral">&quot;day&quot;</span>]</div>
<div class="line"><span class="lineno"> 1183</span>    req = sorted(set(required) - set(unit_rev.keys()))</div>
<div class="line"><span class="lineno"> 1184</span>    <span class="keywordflow">if</span> len(req):</div>
<div class="line"><span class="lineno"> 1185</span>        _required = <span class="stringliteral">&quot;,&quot;</span>.join(req)</div>
<div class="line"><span class="lineno"> 1186</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1187</span>            <span class="stringliteral">&quot;to assemble mappings requires at least that &quot;</span></div>
<div class="line"><span class="lineno"> 1188</span>            f<span class="stringliteral">&quot;[year, month, day] be specified: [{_required}] is missing&quot;</span></div>
<div class="line"><span class="lineno"> 1189</span>        )</div>
<div class="line"><span class="lineno"> 1190</span> </div>
<div class="line"><span class="lineno"> 1191</span>    <span class="comment"># keys we don&#39;t recognize</span></div>
<div class="line"><span class="lineno"> 1192</span>    excess = sorted(set(unit_rev.keys()) - set(_unit_map.values()))</div>
<div class="line"><span class="lineno"> 1193</span>    <span class="keywordflow">if</span> len(excess):</div>
<div class="line"><span class="lineno"> 1194</span>        _excess = <span class="stringliteral">&quot;,&quot;</span>.join(excess)</div>
<div class="line"><span class="lineno"> 1195</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1196</span>            f<span class="stringliteral">&quot;extra keys have been passed to the datetime assemblage: [{_excess}]&quot;</span></div>
<div class="line"><span class="lineno"> 1197</span>        )</div>
<div class="line"><span class="lineno"> 1198</span> </div>
<div class="line"><span class="lineno"> 1199</span>    <span class="keyword">def </span>coerce(values):</div>
<div class="line"><span class="lineno"> 1200</span>        <span class="comment"># we allow coercion to if errors allows</span></div>
<div class="line"><span class="lineno"> 1201</span>        values = to_numeric(values, errors=errors)</div>
<div class="line"><span class="lineno"> 1202</span> </div>
<div class="line"><span class="lineno"> 1203</span>        <span class="comment"># prevent overflow in case of int8 or int16</span></div>
<div class="line"><span class="lineno"> 1204</span>        <span class="keywordflow">if</span> is_integer_dtype(values):</div>
<div class="line"><span class="lineno"> 1205</span>            values = values.astype(<span class="stringliteral">&quot;int64&quot;</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1206</span>        <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1207</span> </div>
<div class="line"><span class="lineno"> 1208</span>    values = (</div>
<div class="line"><span class="lineno"> 1209</span>        coerce(arg[unit_rev[<span class="stringliteral">&quot;year&quot;</span>]]) * 10000</div>
<div class="line"><span class="lineno"> 1210</span>        + coerce(arg[unit_rev[<span class="stringliteral">&quot;month&quot;</span>]]) * 100</div>
<div class="line"><span class="lineno"> 1211</span>        + coerce(arg[unit_rev[<span class="stringliteral">&quot;day&quot;</span>]])</div>
<div class="line"><span class="lineno"> 1212</span>    )</div>
<div class="line"><span class="lineno"> 1213</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1214</span>        values = to_datetime(values, format=<span class="stringliteral">&quot;%Y%m%d&quot;</span>, errors=errors, utc=tz)</div>
<div class="line"><span class="lineno"> 1215</span>    <span class="keywordflow">except</span> (TypeError, ValueError) <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1216</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;cannot assemble the datetimes: {err}&quot;</span>) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 1217</span> </div>
<div class="line"><span class="lineno"> 1218</span>    units: list[UnitChoices] = [<span class="stringliteral">&quot;h&quot;</span>, <span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;s&quot;</span>, <span class="stringliteral">&quot;ms&quot;</span>, <span class="stringliteral">&quot;us&quot;</span>, <span class="stringliteral">&quot;ns&quot;</span>]</div>
<div class="line"><span class="lineno"> 1219</span>    <span class="keywordflow">for</span> u <span class="keywordflow">in</span> units:</div>
<div class="line"><span class="lineno"> 1220</span>        value = unit_rev.get(u)</div>
<div class="line"><span class="lineno"> 1221</span>        <span class="keywordflow">if</span> value <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> value <span class="keywordflow">in</span> arg:</div>
<div class="line"><span class="lineno"> 1222</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1223</span>                values += to_timedelta(coerce(arg[value]), unit=u, errors=errors)</div>
<div class="line"><span class="lineno"> 1224</span>            <span class="keywordflow">except</span> (TypeError, ValueError) <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1225</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1226</span>                    f<span class="stringliteral">&quot;cannot assemble the datetimes [{value}]: {err}&quot;</span></div>
<div class="line"><span class="lineno"> 1227</span>                ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 1228</span>    <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1229</span> </div>
<div class="line"><span class="lineno"> 1230</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_af01a903df7bdb7a494f5827e45bf3a2a"><div class="ttname"><a href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a></div><div class="ttdeci">void int int int int npy_complex64 int int npy_complex64 float float npy_complex64 npy_complex64 * f</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:262</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a99e1a0270af241c01177b6582ea16760" name="a99e1a0270af241c01177b6582ea16760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e1a0270af241c01177b6582ea16760">&#9670;&#160;</a></span>_attempt_YYYYMMDD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray | None pandas.core.tools.datetimes._attempt_YYYYMMDD </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.object_]&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">try to parse the YYYYMMDD/%Y%m%d format, try to deal with NaT-like,
arg is a passed in as an object dtype, but could really be ints/strings
with nan-like/or floats (e.g. with nan)

Parameters
----------
arg : np.ndarray[object]
errors : {'raise','ignore','coerce'}
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1231</span><span class="keyword">def </span>_attempt_YYYYMMDD(arg: npt.NDArray[np.object_], errors: str) -&gt; np.ndarray | <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1232</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">    try to parse the YYYYMMDD/%Y%m%d format, try to deal with NaT-like,</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">    arg is a passed in as an object dtype, but could really be ints/strings</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    with nan-like/or floats (e.g. with nan)</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">    arg : np.ndarray[object]</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    errors : {&#39;raise&#39;,&#39;ignore&#39;,&#39;coerce&#39;}</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1242</span> </div>
<div class="line"><span class="lineno"> 1243</span>    <span class="keyword">def </span>calc(carg):</div>
<div class="line"><span class="lineno"> 1244</span>        <span class="comment"># calculate the actual result</span></div>
<div class="line"><span class="lineno"> 1245</span>        carg = carg.astype(object, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1246</span>        parsed = parsing.try_parse_year_month_day(</div>
<div class="line"><span class="lineno"> 1247</span>            carg / 10000, carg / 100 % 100, carg % 100</div>
<div class="line"><span class="lineno"> 1248</span>        )</div>
<div class="line"><span class="lineno"> 1249</span>        <span class="keywordflow">return</span> tslib.array_to_datetime(parsed, errors=errors)[0]</div>
<div class="line"><span class="lineno"> 1250</span> </div>
<div class="line"><span class="lineno"> 1251</span>    <span class="keyword">def </span>calc_with_mask(carg, mask):</div>
<div class="line"><span class="lineno"> 1252</span>        result = np.empty(carg.shape, dtype=<span class="stringliteral">&quot;M8[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1253</span>        iresult = result.view(<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno"> 1254</span>        iresult[~mask] = iNaT</div>
<div class="line"><span class="lineno"> 1255</span> </div>
<div class="line"><span class="lineno"> 1256</span>        masked_result = calc(carg[mask].astype(np.float64).astype(np.int64))</div>
<div class="line"><span class="lineno"> 1257</span>        result[mask] = masked_result.astype(<span class="stringliteral">&quot;M8[ns]&quot;</span>)</div>
<div class="line"><span class="lineno"> 1258</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1259</span> </div>
<div class="line"><span class="lineno"> 1260</span>    <span class="comment"># try intlike / strings that are ints</span></div>
<div class="line"><span class="lineno"> 1261</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1262</span>        <span class="keywordflow">return</span> calc(arg.astype(np.int64))</div>
<div class="line"><span class="lineno"> 1263</span>    <span class="keywordflow">except</span> (ValueError, OverflowError, TypeError):</div>
<div class="line"><span class="lineno"> 1264</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1265</span> </div>
<div class="line"><span class="lineno"> 1266</span>    <span class="comment"># a float with actual np.nan</span></div>
<div class="line"><span class="lineno"> 1267</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1268</span>        carg = arg.astype(np.float64)</div>
<div class="line"><span class="lineno"> 1269</span>        <span class="keywordflow">return</span> calc_with_mask(carg, notna(carg))</div>
<div class="line"><span class="lineno"> 1270</span>    <span class="keywordflow">except</span> (ValueError, OverflowError, TypeError):</div>
<div class="line"><span class="lineno"> 1271</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1272</span> </div>
<div class="line"><span class="lineno"> 1273</span>    <span class="comment"># string with NaN-like</span></div>
<div class="line"><span class="lineno"> 1274</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1275</span>        <span class="comment"># error: Argument 2 to &quot;isin&quot; has incompatible type &quot;List[Any]&quot;; expected</span></div>
<div class="line"><span class="lineno"> 1276</span>        <span class="comment"># &quot;Union[Union[ExtensionArray, ndarray], Index, Series]&quot;</span></div>
<div class="line"><span class="lineno"> 1277</span>        mask = ~algorithms.isin(arg, list(nat_strings))  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 1278</span>        <span class="keywordflow">return</span> calc_with_mask(arg, mask)</div>
<div class="line"><span class="lineno"> 1279</span>    <span class="keywordflow">except</span> (ValueError, OverflowError, TypeError):</div>
<div class="line"><span class="lineno"> 1280</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1281</span> </div>
<div class="line"><span class="lineno"> 1282</span>    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1283</span> </div>
<div class="line"><span class="lineno"> 1284</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a17c4e7673fa31721b5aa0fa9b12570ad" name="a17c4e7673fa31721b5aa0fa9b12570ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c4e7673fa31721b5aa0fa9b12570ad">&#9670;&#160;</a></span>_box_as_indexlike()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.tools.datetimes._box_as_indexlike </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>dt_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>utc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Properly boxes the ndarray of datetimes to DatetimeIndex
if it is possible or to generic Index instead

Parameters
----------
dt_array: 1-d array
    Array of datetimes to be wrapped in an Index.
tz : object
    None or 'utc'
name : string, default None
    Name for a resulting index

Returns
-------
result : datetime of converted dates
    - DatetimeIndex if convertible to sole datetime64 type
    - general Index otherwise
</pre> <div class="fragment"><div class="line"><span class="lineno">  243</span>) -&gt; Index:</div>
<div class="line"><span class="lineno">  244</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    Properly boxes the ndarray of datetimes to DatetimeIndex</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    if it is possible or to generic Index instead</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    dt_array: 1-d array</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        Array of datetimes to be wrapped in an Index.</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    tz : object</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        None or &#39;utc&#39;</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    name : string, default None</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">        Name for a resulting index</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    result : datetime of converted dates</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">        - DatetimeIndex if convertible to sole datetime64 type</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        - general Index otherwise</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span>    <span class="keywordflow">if</span> is_datetime64_dtype(dt_array):</div>
<div class="line"><span class="lineno">  265</span>        tz = <span class="stringliteral">&quot;utc&quot;</span> <span class="keywordflow">if</span> utc <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  266</span>        <span class="keywordflow">return</span> DatetimeIndex(dt_array, tz=tz, name=name)</div>
<div class="line"><span class="lineno">  267</span>    <span class="keywordflow">return</span> Index(dt_array, name=name, dtype=dt_array.dtype)</div>
<div class="line"><span class="lineno">  268</span> </div>
<div class="line"><span class="lineno">  269</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a01f6153e301c2ec92e5c9cd82aa730" name="a1a01f6153e301c2ec92e5c9cd82aa730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a01f6153e301c2ec92e5c9cd82aa730">&#9670;&#160;</a></span>_convert_and_box_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.tools.datetimes._convert_and_box_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8217e588e94ff87dbb2f21b512aea797">DatetimeScalarOrArrayConvertible</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Series&#160;</td>
          <td class="paramname"><em>cache_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable | None &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert array of dates with a cache and wrap the result in an Index.

Parameters
----------
arg : integer, float, string, datetime, list, tuple, 1-d array, Series
cache_array : Series
    Cache of converted, unique dates
name : string, default None
    Name for a DatetimeIndex

Returns
-------
result : Index-like of converted dates
</pre> <div class="fragment"><div class="line"><span class="lineno">  274</span>) -&gt; Index:</div>
<div class="line"><span class="lineno">  275</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    Convert array of dates with a cache and wrap the result in an Index.</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    arg : integer, float, string, datetime, list, tuple, 1-d array, Series</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    cache_array : Series</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        Cache of converted, unique dates</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    name : string, default None</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        Name for a DatetimeIndex</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    result : Index-like of converted dates</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  290</span>    <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span>    result = Series(arg).map(cache_array)</div>
<div class="line"><span class="lineno">  293</span>    <span class="keywordflow">return</span> _box_as_indexlike(result._values, utc=<span class="keywordtype">None</span>, name=name)</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0e87e929133681214cfe6ba2a4544e2" name="ab0e87e929133681214cfe6ba2a4544e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e87e929133681214cfe6ba2a4544e2">&#9670;&#160;</a></span>_convert_listlike_datetimes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes._convert_listlike_datetimes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Timezone | None &#160;</td>
          <td class="paramname"><em>tz</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>unit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;raise&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>infer_datetime_format</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>dayfirst</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>yearfirst</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exact</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function for to_datetime. Performs the conversions of 1D listlike
of dates

Parameters
----------
arg : list, tuple, ndarray, Series, Index
    date to be parsed
name : object
    None or string for the Index name
tz : object
    None or 'utc'
unit : str
    None or string of the frequency of the passed data
errors : str
    error handing behaviors from to_datetime, 'raise', 'coerce', 'ignore'
infer_datetime_format : bool, default False
    inferring format behavior from to_datetime
dayfirst : bool
    dayfirst parsing behavior from to_datetime
yearfirst : bool
    yearfirst parsing behavior from to_datetime
exact : bool, default True
    exact format matching behavior from to_datetime

Returns
-------
Index-like of parsed dates
</pre> <div class="fragment"><div class="line"><span class="lineno">  336</span>):</div>
<div class="line"><span class="lineno">  337</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    Helper function for to_datetime. Performs the conversions of 1D listlike</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    of dates</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    arg : list, tuple, ndarray, Series, Index</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">        date to be parsed</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    name : object</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">        None or string for the Index name</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    tz : object</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">        None or &#39;utc&#39;</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    unit : str</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        None or string of the frequency of the passed data</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    errors : str</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">        error handing behaviors from to_datetime, &#39;raise&#39;, &#39;coerce&#39;, &#39;ignore&#39;</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    infer_datetime_format : bool, default False</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">        inferring format behavior from to_datetime</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    dayfirst : bool</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        dayfirst parsing behavior from to_datetime</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    yearfirst : bool</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">        yearfirst parsing behavior from to_datetime</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    exact : bool, default True</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        exact format matching behavior from to_datetime</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    Index-like of parsed dates</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  366</span>    <span class="keywordflow">if</span> isinstance(arg, (list, tuple)):</div>
<div class="line"><span class="lineno">  367</span>        arg = np.array(arg, dtype=<span class="stringliteral">&quot;O&quot;</span>)</div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span>    arg_dtype = getattr(arg, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  370</span>    <span class="comment"># these are shortcutable</span></div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordflow">if</span> is_datetime64tz_dtype(arg_dtype):</div>
<div class="line"><span class="lineno">  372</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(arg, (DatetimeArray, DatetimeIndex)):</div>
<div class="line"><span class="lineno">  373</span>            <span class="keywordflow">return</span> DatetimeIndex(arg, tz=tz, name=name)</div>
<div class="line"><span class="lineno">  374</span>        <span class="keywordflow">if</span> tz == <span class="stringliteral">&quot;utc&quot;</span>:</div>
<div class="line"><span class="lineno">  375</span>            arg = arg.tz_convert(<span class="keywordtype">None</span>).tz_localize(tz)</div>
<div class="line"><span class="lineno">  376</span>        <span class="keywordflow">return</span> arg</div>
<div class="line"><span class="lineno">  377</span> </div>
<div class="line"><span class="lineno">  378</span>    <span class="keywordflow">elif</span> is_datetime64_ns_dtype(arg_dtype):</div>
<div class="line"><span class="lineno">  379</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(arg, (DatetimeArray, DatetimeIndex)):</div>
<div class="line"><span class="lineno">  380</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  381</span>                <span class="keywordflow">return</span> DatetimeIndex(arg, tz=tz, name=name)</div>
<div class="line"><span class="lineno">  382</span>            <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  383</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  384</span>        <span class="keywordflow">elif</span> tz:</div>
<div class="line"><span class="lineno">  385</span>            <span class="comment"># DatetimeArray, DatetimeIndex</span></div>
<div class="line"><span class="lineno">  386</span>            <span class="keywordflow">return</span> arg.tz_localize(tz)</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span>        <span class="keywordflow">return</span> arg</div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span>    <span class="keywordflow">elif</span> unit <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  391</span>        <span class="keywordflow">if</span> format <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  392</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot specify both format and unit&quot;</span>)</div>
<div class="line"><span class="lineno">  393</span>        <span class="keywordflow">return</span> _to_datetime_with_unit(arg, unit, name, tz, errors)</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">elif</span> getattr(arg, <span class="stringliteral">&quot;ndim&quot;</span>, 1) &gt; 1:</div>
<div class="line"><span class="lineno">  395</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  396</span>            <span class="stringliteral">&quot;arg must be a string, datetime, list, tuple, 1-d array, or Series&quot;</span></div>
<div class="line"><span class="lineno">  397</span>        )</div>
<div class="line"><span class="lineno">  398</span> </div>
<div class="line"><span class="lineno">  399</span>    <span class="comment"># warn if passing timedelta64, raise for PeriodDtype</span></div>
<div class="line"><span class="lineno">  400</span>    <span class="comment"># NB: this must come after unit transformation</span></div>
<div class="line"><span class="lineno">  401</span>    orig_arg = arg</div>
<div class="line"><span class="lineno">  402</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  403</span>        arg, _ = maybe_convert_dtype(arg, copy=<span class="keyword">False</span>, tz=timezones.maybe_get_tz(tz))</div>
<div class="line"><span class="lineno">  404</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  405</span>        <span class="keywordflow">if</span> errors == <span class="stringliteral">&quot;coerce&quot;</span>:</div>
<div class="line"><span class="lineno">  406</span>            npvalues = np.array([<span class="stringliteral">&quot;NaT&quot;</span>], dtype=<span class="stringliteral">&quot;datetime64[ns]&quot;</span>).repeat(len(arg))</div>
<div class="line"><span class="lineno">  407</span>            <span class="keywordflow">return</span> DatetimeIndex(npvalues, name=name)</div>
<div class="line"><span class="lineno">  408</span>        <span class="keywordflow">elif</span> errors == <span class="stringliteral">&quot;ignore&quot;</span>:</div>
<div class="line"><span class="lineno">  409</span>            idx = Index(arg, name=name)</div>
<div class="line"><span class="lineno">  410</span>            <span class="keywordflow">return</span> idx</div>
<div class="line"><span class="lineno">  411</span>        <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span>    arg = ensure_object(arg)</div>
<div class="line"><span class="lineno">  414</span>    require_iso8601 = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  415</span> </div>
<div class="line"><span class="lineno">  416</span>    <span class="keywordflow">if</span> infer_datetime_format <span class="keywordflow">and</span> format <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  417</span>        format = _guess_datetime_format_for_array(arg, dayfirst=dayfirst)</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span>    <span class="keywordflow">if</span> format <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  420</span>        <span class="comment"># There is a special fast-path for iso8601 formatted</span></div>
<div class="line"><span class="lineno">  421</span>        <span class="comment"># datetime strings, so in those cases don&#39;t use the inferred</span></div>
<div class="line"><span class="lineno">  422</span>        <span class="comment"># format because this path makes process slower in this</span></div>
<div class="line"><span class="lineno">  423</span>        <span class="comment"># special case</span></div>
<div class="line"><span class="lineno">  424</span>        format_is_iso8601 = format_is_iso(format)</div>
<div class="line"><span class="lineno">  425</span>        <span class="keywordflow">if</span> format_is_iso8601:</div>
<div class="line"><span class="lineno">  426</span>            require_iso8601 = <span class="keywordflow">not</span> infer_datetime_format</div>
<div class="line"><span class="lineno">  427</span>            format = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  428</span> </div>
<div class="line"><span class="lineno">  429</span>    <span class="keywordflow">if</span> format <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  430</span>        res = _to_datetime_with_format(</div>
<div class="line"><span class="lineno">  431</span>            arg, orig_arg, name, tz, format, exact, errors, infer_datetime_format</div>
<div class="line"><span class="lineno">  432</span>        )</div>
<div class="line"><span class="lineno">  433</span>        <span class="keywordflow">if</span> res <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  434</span>            <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  435</span> </div>
<div class="line"><span class="lineno">  436</span>    <span class="keyword">assert</span> format <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> infer_datetime_format</div>
<div class="line"><span class="lineno">  437</span>    utc = tz == <span class="stringliteral">&quot;utc&quot;</span></div>
<div class="line"><span class="lineno">  438</span>    result, tz_parsed = objects_to_datetime64ns(</div>
<div class="line"><span class="lineno">  439</span>        arg,</div>
<div class="line"><span class="lineno">  440</span>        dayfirst=dayfirst,</div>
<div class="line"><span class="lineno">  441</span>        yearfirst=yearfirst,</div>
<div class="line"><span class="lineno">  442</span>        utc=utc,</div>
<div class="line"><span class="lineno">  443</span>        errors=errors,</div>
<div class="line"><span class="lineno">  444</span>        require_iso8601=require_iso8601,</div>
<div class="line"><span class="lineno">  445</span>        allow_object=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  446</span>    )</div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">if</span> tz_parsed <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  449</span>        <span class="comment"># We can take a shortcut since the datetime64 numpy array</span></div>
<div class="line"><span class="lineno">  450</span>        <span class="comment"># is in UTC</span></div>
<div class="line"><span class="lineno">  451</span>        dta = DatetimeArray(result, dtype=tz_to_dtype(tz_parsed))</div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordflow">return</span> DatetimeIndex._simple_new(dta, name=name)</div>
<div class="line"><span class="lineno">  453</span> </div>
<div class="line"><span class="lineno">  454</span>    utc = tz == <span class="stringliteral">&quot;utc&quot;</span></div>
<div class="line"><span class="lineno">  455</span>    <span class="keywordflow">return</span> _box_as_indexlike(result, utc=utc, name=name)</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f703db251011d5a8487060ee3084c4a" name="a8f703db251011d5a8487060ee3084c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f703db251011d5a8487060ee3084c4a">&#9670;&#160;</a></span>_guess_datetime_format_for_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes._guess_datetime_format_for_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>dayfirst</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  127</span><span class="keyword">def </span>_guess_datetime_format_for_array(arr, dayfirst: bool | <span class="keywordtype">None</span> = <span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  128</span>    <span class="comment"># Try to guess the format based on the first non-NaN element</span></div>
<div class="line"><span class="lineno">  129</span>    non_nan_elements = notna(arr).nonzero()[0]</div>
<div class="line"><span class="lineno">  130</span>    <span class="keywordflow">if</span> len(non_nan_elements):</div>
<div class="line"><span class="lineno">  131</span>        <span class="keywordflow">return</span> guess_datetime_format(arr[non_nan_elements[0]], dayfirst=dayfirst)</div>
<div class="line"><span class="lineno">  132</span> </div>
<div class="line"><span class="lineno">  133</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="add7a3d21d66bb29c37b57464b7c67699" name="add7a3d21d66bb29c37b57464b7c67699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7a3d21d66bb29c37b57464b7c67699">&#9670;&#160;</a></span>_maybe_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Series pandas.core.tools.datetimes._maybe_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a84b1dd1a397c88da61c405304f0cb259">ArrayConvertible</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>convert_listlike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create a cache of unique dates from an array of dates

Parameters
----------
arg : listlike, tuple, 1-d array, Series
format : string
    Strftime format to parse time
cache : bool
    True attempts to create a cache of converted values
convert_listlike : function
    Conversion function to apply on dates

Returns
-------
cache_array : Series
    Cache of converted, unique dates. Can be empty
</pre> <div class="fragment"><div class="line"><span class="lineno">  199</span>) -&gt; Series:</div>
<div class="line"><span class="lineno">  200</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    Create a cache of unique dates from an array of dates</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    arg : listlike, tuple, 1-d array, Series</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    format : string</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        Strftime format to parse time</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    cache : bool</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        True attempts to create a cache of converted values</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    convert_listlike : function</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        Conversion function to apply on dates</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    cache_array : Series</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        Cache of converted, unique dates. Can be empty</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  218</span>    <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>    cache_array = Series(dtype=object)</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">if</span> cache:</div>
<div class="line"><span class="lineno">  223</span>        <span class="comment"># Perform a quicker unique check</span></div>
<div class="line"><span class="lineno">  224</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> should_cache(arg):</div>
<div class="line"><span class="lineno">  225</span>            <span class="keywordflow">return</span> cache_array</div>
<div class="line"><span class="lineno">  226</span> </div>
<div class="line"><span class="lineno">  227</span>        unique_dates = unique(arg)</div>
<div class="line"><span class="lineno">  228</span>        <span class="keywordflow">if</span> len(unique_dates) &lt; len(arg):</div>
<div class="line"><span class="lineno">  229</span>            cache_dates = convert_listlike(unique_dates, format)</div>
<div class="line"><span class="lineno">  230</span>            <span class="comment"># GH#45319</span></div>
<div class="line"><span class="lineno">  231</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  232</span>                cache_array = Series(cache_dates, index=unique_dates)</div>
<div class="line"><span class="lineno">  233</span>            <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno">  234</span>                <span class="keywordflow">return</span> cache_array</div>
<div class="line"><span class="lineno">  235</span>            <span class="comment"># GH#39882 and GH#35888 in case of None and NaT we get duplicates</span></div>
<div class="line"><span class="lineno">  236</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> cache_array.index.is_unique:</div>
<div class="line"><span class="lineno">  237</span>                cache_array = cache_array[~cache_array.index.duplicated()]</div>
<div class="line"><span class="lineno">  238</span>    <span class="keywordflow">return</span> cache_array</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af4eb2797838120e451bcf076fb1ed4c0" name="af4eb2797838120e451bcf076fb1ed4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4eb2797838120e451bcf076fb1ed4c0">&#9670;&#160;</a></span>_return_parsed_timezone_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.tools.datetimes._return_parsed_timezone_results </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timezones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return results from array_strptime if a %z or %Z directive was passed.

Parameters
----------
result : ndarray[int64]
    int64 date representations of the dates
timezones : ndarray
    pytz timezone objects
tz : object
    None or pytz timezone object
name : string, default None
    Name for a DatetimeIndex

Returns
-------
tz_result : Index-like of parsed dates with timezone
</pre> <div class="fragment"><div class="line"><span class="lineno">  296</span><span class="keyword">def </span>_return_parsed_timezone_results(result: np.ndarray, timezones, tz, name) -&gt; Index:</div>
<div class="line"><span class="lineno">  297</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    Return results from array_strptime if a %z or %Z directive was passed.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    result : ndarray[int64]</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        int64 date representations of the dates</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    timezones : ndarray</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        pytz timezone objects</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    tz : object</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        None or pytz timezone object</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    name : string, default None</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">        Name for a DatetimeIndex</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    tz_result : Index-like of parsed dates with timezone</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  315</span>    tz_results = np.array(</div>
<div class="line"><span class="lineno">  316</span>        [Timestamp(res).tz_localize(zone) <span class="keywordflow">for</span> res, zone <span class="keywordflow">in</span> zip(result, timezones)]</div>
<div class="line"><span class="lineno">  317</span>    )</div>
<div class="line"><span class="lineno">  318</span>    <span class="keywordflow">if</span> tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  319</span>        <span class="comment"># Convert to the same tz</span></div>
<div class="line"><span class="lineno">  320</span>        tz_results = np.array([tz_result.tz_convert(tz) <span class="keywordflow">for</span> tz_result <span class="keywordflow">in</span> tz_results])</div>
<div class="line"><span class="lineno">  321</span> </div>
<div class="line"><span class="lineno">  322</span>    <span class="keywordflow">return</span> Index(tz_results, name=name)</div>
<div class="line"><span class="lineno">  323</span> </div>
<div class="line"><span class="lineno">  324</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aba34683c771e42a8f588e2c029564830" name="aba34683c771e42a8f588e2c029564830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba34683c771e42a8f588e2c029564830">&#9670;&#160;</a></span>_to_datetime_with_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | None pandas.core.tools.datetimes._to_datetime_with_format </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orig_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>infer_datetime_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Try parsing with the given format, returning None on failure.
</pre> <div class="fragment"><div class="line"><span class="lineno">  515</span>) -&gt; Index | <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  516</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    Try parsing with the given format, returning None on failure.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  519</span>    result = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  520</span> </div>
<div class="line"><span class="lineno">  521</span>    <span class="comment"># shortcut formatting here</span></div>
<div class="line"><span class="lineno">  522</span>    <span class="keywordflow">if</span> fmt == <span class="stringliteral">&quot;%Y%m%d&quot;</span>:</div>
<div class="line"><span class="lineno">  523</span>        <span class="comment"># pass orig_arg as float-dtype may have been converted to</span></div>
<div class="line"><span class="lineno">  524</span>        <span class="comment"># datetime64[ns]</span></div>
<div class="line"><span class="lineno">  525</span>        orig_arg = ensure_object(orig_arg)</div>
<div class="line"><span class="lineno">  526</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  527</span>            <span class="comment"># may return None without raising</span></div>
<div class="line"><span class="lineno">  528</span>            result = _attempt_YYYYMMDD(orig_arg, errors=errors)</div>
<div class="line"><span class="lineno">  529</span>        <span class="keywordflow">except</span> (ValueError, TypeError, OutOfBoundsDatetime) <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno">  530</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  531</span>                <span class="stringliteral">&quot;cannot convert the input to &#39;%Y%m%d&#39; date format&quot;</span></div>
<div class="line"><span class="lineno">  532</span>            ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno">  533</span>        <span class="keywordflow">if</span> result <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  534</span>            utc = tz == <span class="stringliteral">&quot;utc&quot;</span></div>
<div class="line"><span class="lineno">  535</span>            <span class="keywordflow">return</span> _box_as_indexlike(result, utc=utc, name=name)</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>    <span class="comment"># fallback</span></div>
<div class="line"><span class="lineno">  538</span>    res = _array_strptime_with_fallback(</div>
<div class="line"><span class="lineno">  539</span>        arg, name, tz, fmt, exact, errors, infer_datetime_format</div>
<div class="line"><span class="lineno">  540</span>    )</div>
<div class="line"><span class="lineno">  541</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">  542</span> </div>
<div class="line"><span class="lineno">  543</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4576d06377494c86492939edf3558a83" name="a4576d06377494c86492939edf3558a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4576d06377494c86492939edf3558a83">&#9670;&#160;</a></span>_to_datetime_with_unit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.tools.datetimes._to_datetime_with_unit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">to_datetime specalized to the case where a 'unit' is passed.
</pre> <div class="fragment"><div class="line"><span class="lineno">  544</span><span class="keyword">def </span>_to_datetime_with_unit(arg, unit, name, tz, errors: str) -&gt; Index:</div>
<div class="line"><span class="lineno">  545</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    to_datetime specalized to the case where a &#39;unit&#39; is passed.</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  548</span>    arg = extract_array(arg, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  549</span> </div>
<div class="line"><span class="lineno">  550</span>    <span class="comment"># GH#30050 pass an ndarray to tslib.array_with_unit_to_datetime</span></div>
<div class="line"><span class="lineno">  551</span>    <span class="comment"># because it expects an ndarray argument</span></div>
<div class="line"><span class="lineno">  552</span>    <span class="keywordflow">if</span> isinstance(arg, IntegerArray):</div>
<div class="line"><span class="lineno">  553</span>        arr = arg.astype(f<span class="stringliteral">&quot;datetime64[{unit}]&quot;</span>)</div>
<div class="line"><span class="lineno">  554</span>        tz_parsed = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  555</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  556</span>        arg = np.asarray(arg)</div>
<div class="line"><span class="lineno">  557</span>        arr, tz_parsed = tslib.array_with_unit_to_datetime(arg, unit, errors=errors)</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>    <span class="keywordflow">if</span> errors == <span class="stringliteral">&quot;ignore&quot;</span>:</div>
<div class="line"><span class="lineno">  560</span>        <span class="comment"># Index constructor _may_ infer to DatetimeIndex</span></div>
<div class="line"><span class="lineno">  561</span>        result = Index._with_infer(arr, name=name)</div>
<div class="line"><span class="lineno">  562</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  563</span>        result = DatetimeIndex(arr, name=name)</div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(result, DatetimeIndex):</div>
<div class="line"><span class="lineno">  566</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>    <span class="comment"># GH#23758: We may still need to localize the result with tz</span></div>
<div class="line"><span class="lineno">  569</span>    <span class="comment"># GH#25546: Apply tz_parsed first (from arg), then tz (from caller)</span></div>
<div class="line"><span class="lineno">  570</span>    <span class="comment"># result will be naive but in UTC</span></div>
<div class="line"><span class="lineno">  571</span>    result = result.tz_localize(<span class="stringliteral">&quot;UTC&quot;</span>).tz_convert(tz_parsed)</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span>    <span class="keywordflow">if</span> tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  574</span>        <span class="keywordflow">if</span> result.tz <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  575</span>            result = result.tz_localize(tz)</div>
<div class="line"><span class="lineno">  576</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  577</span>            result = result.tz_convert(tz)</div>
<div class="line"><span class="lineno">  578</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  579</span> </div>
<div class="line"><span class="lineno">  580</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a482e72c6249c75d23ffb683148a41d26" name="a482e72c6249c75d23ffb683148a41d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482e72c6249c75d23ffb683148a41d26">&#9670;&#160;</a></span>should_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.tools.datetimes.should_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a84b1dd1a397c88da61c405304f0cb259">ArrayConvertible</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>unique_share</em> = <code>0.7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>check_count</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decides whether to do caching.

If the percent of unique elements among `check_count` elements less
than `unique_share * 100` then we can do caching.

Parameters
----------
arg: listlike, tuple, 1-d array, Series
unique_share: float, default=0.7, optional
    0 &lt; unique_share &lt; 1
check_count: int, optional
    0 &lt;= check_count &lt;= len(arg)

Returns
-------
do_caching: bool

Notes
-----
By default for a sequence of less than 50 items in size, we don't do
caching; for the number of elements less than 5000, we take ten percent of
all elements to check for a uniqueness share; if the sequence size is more
than 5000, then we check only the first 500 elements.
All constants were chosen empirically by.
</pre> <div class="fragment"><div class="line"><span class="lineno">  136</span>) -&gt; bool:</div>
<div class="line"><span class="lineno">  137</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    Decides whether to do caching.</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    If the percent of unique elements among `check_count` elements less</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    than `unique_share * 100` then we can do caching.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    arg: listlike, tuple, 1-d array, Series</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    unique_share: float, default=0.7, optional</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">        0 &lt; unique_share &lt; 1</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    check_count: int, optional</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        0 &lt;= check_count &lt;= len(arg)</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    do_caching: bool</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    By default for a sequence of less than 50 items in size, we don&#39;t do</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    caching; for the number of elements less than 5000, we take ten percent of</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    all elements to check for a uniqueness share; if the sequence size is more</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    than 5000, then we check only the first 500 elements.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    All constants were chosen empirically by.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  163</span>    do_caching = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    <span class="comment"># default realization</span></div>
<div class="line"><span class="lineno">  166</span>    <span class="keywordflow">if</span> check_count <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  167</span>        <span class="comment"># in this case, the gain from caching is negligible</span></div>
<div class="line"><span class="lineno">  168</span>        <span class="keywordflow">if</span> len(arg) &lt;= start_caching_at:</div>
<div class="line"><span class="lineno">  169</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  170</span> </div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordflow">if</span> len(arg) &lt;= 5000:</div>
<div class="line"><span class="lineno">  172</span>            check_count = len(arg) // 10</div>
<div class="line"><span class="lineno">  173</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  174</span>            check_count = 500</div>
<div class="line"><span class="lineno">  175</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  176</span>        <span class="keyword">assert</span> (</div>
<div class="line"><span class="lineno">  177</span>            0 &lt;= check_count &lt;= len(arg)</div>
<div class="line"><span class="lineno">  178</span>        ), <span class="stringliteral">&quot;check_count must be in next bounds: [0; len(arg)]&quot;</span></div>
<div class="line"><span class="lineno">  179</span>        <span class="keywordflow">if</span> check_count == 0:</div>
<div class="line"><span class="lineno">  180</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>    <span class="keyword">assert</span> 0 &lt; unique_share &lt; 1, <span class="stringliteral">&quot;unique_share must be in next bounds: (0; 1)&quot;</span></div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  185</span>        <span class="comment"># We can&#39;t cache if the items are not hashable.</span></div>
<div class="line"><span class="lineno">  186</span>        unique_elements = set(islice(arg, check_count))</div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  188</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  189</span>    <span class="keywordflow">if</span> len(unique_elements) &gt; check_count * unique_share:</div>
<div class="line"><span class="lineno">  190</span>        do_caching = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  191</span>    <span class="keywordflow">return</span> do_caching</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2568fe23b8737e519bdb6930b268304" name="ac2568fe23b8737e519bdb6930b268304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2568fe23b8737e519bdb6930b268304">&#9670;&#160;</a></span>to_datetime() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Timestamp pandas.core.tools.datetimes.to_datetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aad678b01744f19f8a5268bfd6fa56592">DatetimeScalar</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTimeErrorChoices &#160;</td>
          <td class="paramname"><em>errors</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dayfirst</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>yearfirst</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>utc</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>format</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exact</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>unit</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>infer_datetime_format</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>cache</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  667</span>) -&gt; Timestamp:</div>
<div class="line"><span class="lineno">  668</span>    ...</div>
<div class="line"><span class="lineno">  669</span> </div>
<div class="line"><span class="lineno">  670</span> </div>
<div class="line"><span class="lineno">  671</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e7d2650ec8a36239f9180a1cf34052a" name="a4e7d2650ec8a36239f9180a1cf34052a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7d2650ec8a36239f9180a1cf34052a">&#9670;&#160;</a></span>to_datetime() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html">DatetimeIndex</a> | Series | <a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aad678b01744f19f8a5268bfd6fa56592">DatetimeScalar</a> | NaTType | None pandas.core.tools.datetimes.to_datetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8217e588e94ff87dbb2f21b512aea797">DatetimeScalarOrArrayConvertible</a> | <a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8abf3f5e6ff0903da2999f6315ee14c6">DictConvertible</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTimeErrorChoices &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;raise&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dayfirst</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>yearfirst</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>utc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exact</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>unit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>infer_datetime_format</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>&quot;unix&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>cache</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert argument to datetime.

This function converts a scalar, array-like, :class:`Series` or
:class:`DataFrame`/dict-like to a pandas datetime object.

Parameters
----------
arg : int, float, str, datetime, list, tuple, 1-d array, Series, DataFrame/dict-like
    The object to convert to a datetime. If a :class:`DataFrame` is provided, the
    method expects minimally the following columns: :const:`"year"`,
    :const:`"month"`, :const:`"day"`.
errors : {'ignore', 'raise', 'coerce'}, default 'raise'
    - If :const:`'raise'`, then invalid parsing will raise an exception.
    - If :const:`'coerce'`, then invalid parsing will be set as :const:`NaT`.
    - If :const:`'ignore'`, then invalid parsing will return the input.
dayfirst : bool, default False
    Specify a date parse order if `arg` is str or is list-like.
    If :const:`True`, parses dates with the day first, e.g. :const:`"10/11/12"`
    is parsed as :const:`2012-11-10`.

    .. warning::

        ``dayfirst=True`` is not strict, but will prefer to parse
        with day first. If a delimited date string cannot be parsed in
        accordance with the given `dayfirst` option, e.g.
        ``to_datetime(['31-12-2021'])``, then a warning will be shown.

yearfirst : bool, default False
    Specify a date parse order if `arg` is str or is list-like.

    - If :const:`True` parses dates with the year first, e.g.
      :const:`"10/11/12"` is parsed as :const:`2010-11-12`.
    - If both `dayfirst` and `yearfirst` are :const:`True`, `yearfirst` is
      preceded (same as :mod:`dateutil`).

    .. warning::

        ``yearfirst=True`` is not strict, but will prefer to parse
        with year first.

utc : bool, default None
    Control timezone-related parsing, localization and conversion.

    - If :const:`True`, the function *always* returns a timezone-aware
      UTC-localized :class:`Timestamp`, :class:`Series` or
      :class:`DatetimeIndex`. To do this, timezone-naive inputs are
      *localized* as UTC, while timezone-aware inputs are *converted* to UTC.

    - If :const:`False` (default), inputs will not be coerced to UTC.
      Timezone-naive inputs will remain naive, while timezone-aware ones
      will keep their time offsets. Limitations exist for mixed
      offsets (typically, daylight savings), see :ref:`Examples
      &lt;to_datetime_tz_examples&gt;` section for details.

    See also: pandas general documentation about `timezone conversion and
    localization
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html
    #time-zone-handling&gt;`_.

format : str, default None
    The strftime to parse time, e.g. :const:`"%d/%m/%Y"`. Note that
    :const:`"%f"` will parse all the way up to nanoseconds. See
    `strftime documentation
    &lt;https://docs.python.org/3/library/datetime.html
    #strftime-and-strptime-behavior&gt;`_ for more information on choices.
exact : bool, default True
    Control how `format` is used:

    - If :const:`True`, require an exact `format` match.
    - If :const:`False`, allow the `format` to match anywhere in the target
      string.

unit : str, default 'ns'
    The unit of the arg (D,s,ms,us,ns) denote the unit, which is an
    integer or float number. This will be based off the origin.
    Example, with ``unit='ms'`` and ``origin='unix'``, this would calculate
    the number of milliseconds to the unix epoch start.
infer_datetime_format : bool, default False
    If :const:`True` and no `format` is given, attempt to infer the format
    of the datetime strings based on the first non-NaN element,
    and if it can be inferred, switch to a faster method of parsing them.
    In some cases this can increase the parsing speed by ~5-10x.
origin : scalar, default 'unix'
    Define the reference date. The numeric values would be parsed as number
    of units (defined by `unit`) since this reference date.

    - If :const:`'unix'` (or POSIX) time; origin is set to 1970-01-01.
    - If :const:`'julian'`, unit must be :const:`'D'`, and origin is set to
      beginning of Julian Calendar. Julian day number :const:`0` is assigned
      to the day starting at noon on January 1, 4713 BC.
    - If Timestamp convertible, origin is set to Timestamp identified by
      origin.
cache : bool, default True
    If :const:`True`, use a cache of unique, converted dates to apply the
    datetime conversion. May produce significant speed-up when parsing
    duplicate date strings, especially ones with timezone offsets. The cache
    is only used when there are at least 50 values. The presence of
    out-of-bounds values will render the cache unusable and may slow down
    parsing.

    .. versionchanged:: 0.25.0
        changed default value from :const:`False` to :const:`True`.

Returns
-------
datetime
    If parsing succeeded.
    Return type depends on input (types in parenthesis correspond to
    fallback in case of unsuccessful timezone or out-of-range timestamp
    parsing):

    - scalar: :class:`Timestamp` (or :class:`datetime.datetime`)
    - array-like: :class:`DatetimeIndex` (or :class:`Series` with
      :class:`object` dtype containing :class:`datetime.datetime`)
    - Series: :class:`Series` of :class:`datetime64` dtype (or
      :class:`Series` of :class:`object` dtype containing
      :class:`datetime.datetime`)
    - DataFrame: :class:`Series` of :class:`datetime64` dtype (or
      :class:`Series` of :class:`object` dtype containing
      :class:`datetime.datetime`)

Raises
------
ParserError
    When parsing a date from string fails.
ValueError
    When another datetime conversion error happens. For example when one
    of 'year', 'month', day' columns is missing in a :class:`DataFrame`, or
    when a Timezone-aware :class:`datetime.datetime` is found in an array-like
    of mixed time offsets, and ``utc=False``.

See Also
--------
DataFrame.astype : Cast argument to a specified dtype.
to_timedelta : Convert argument to timedelta.
convert_dtypes : Convert dtypes.

Notes
-----

Many input types are supported, and lead to different output types:

- **scalars** can be int, float, str, datetime object (from stdlib :mod:`datetime`
  module or :mod:`numpy`). They are converted to :class:`Timestamp` when
  possible, otherwise they are converted to :class:`datetime.datetime`.
  None/NaN/null scalars are converted to :const:`NaT`.

- **array-like** can contain int, float, str, datetime objects. They are
  converted to :class:`DatetimeIndex` when possible, otherwise they are
  converted to :class:`Index` with :class:`object` dtype, containing
  :class:`datetime.datetime`. None/NaN/null entries are converted to
  :const:`NaT` in both cases.

- **Series** are converted to :class:`Series` with :class:`datetime64`
  dtype when possible, otherwise they are converted to :class:`Series` with
  :class:`object` dtype, containing :class:`datetime.datetime`. None/NaN/null
  entries are converted to :const:`NaT` in both cases.

- **DataFrame/dict-like** are converted to :class:`Series` with
  :class:`datetime64` dtype. For each row a datetime is created from assembling
  the various dataframe columns. Column keys can be common abbreviations
  like [year, month, day, minute, second, ms, us, ns]) or
  plurals of the same.

The following causes are responsible for :class:`datetime.datetime` objects
being returned (possibly inside an :class:`Index` or a :class:`Series` with
:class:`object` dtype) instead of a proper pandas designated type
(:class:`Timestamp`, :class:`DatetimeIndex` or :class:`Series`
with :class:`datetime64` dtype):

- when any input element is before :const:`Timestamp.min` or after
  :const:`Timestamp.max`, see `timestamp limitations
  &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html
  #timeseries-timestamp-limits&gt;`_.

- when ``utc=False`` (default) and the input is an array-like or
  :class:`Series` containing mixed naive/aware datetime, or aware with mixed
  time offsets. Note that this happens in the (quite frequent) situation when
  the timezone has a daylight savings policy. In that case you may wish to
  use ``utc=True``.

Examples
--------

**Handling various input formats**

Assembling a datetime from multiple columns of a :class:`DataFrame`. The keys
can be common abbreviations like ['year', 'month', 'day', 'minute', 'second',
'ms', 'us', 'ns']) or plurals of the same

&gt;&gt;&gt; df = pd.DataFrame({'year': [2015, 2016],
...                    'month': [2, 3],
...                    'day': [4, 5]})
&gt;&gt;&gt; pd.to_datetime(df)
0   2015-02-04
1   2016-03-05
dtype: datetime64[ns]

Passing ``infer_datetime_format=True`` can often-times speedup a parsing
if its not an ISO8601 format exactly, but in a regular format.

&gt;&gt;&gt; s = pd.Series(['3/11/2000', '3/12/2000', '3/13/2000'] * 1000)
&gt;&gt;&gt; s.head()
0    3/11/2000
1    3/12/2000
2    3/13/2000
3    3/11/2000
4    3/12/2000
dtype: object

&gt;&gt;&gt; %timeit pd.to_datetime(s, infer_datetime_format=True)  # doctest: +SKIP
100 loops, best of 3: 10.4 ms per loop

&gt;&gt;&gt; %timeit pd.to_datetime(s, infer_datetime_format=False)  # doctest: +SKIP
1 loop, best of 3: 471 ms per loop

Using a unix epoch time

&gt;&gt;&gt; pd.to_datetime(1490195805, unit='s')
Timestamp('2017-03-22 15:16:45')
&gt;&gt;&gt; pd.to_datetime(1490195805433502912, unit='ns')
Timestamp('2017-03-22 15:16:45.433502912')

.. warning:: For float arg, precision rounding might happen. To prevent
    unexpected behavior use a fixed-width exact type.

Using a non-unix epoch origin

&gt;&gt;&gt; pd.to_datetime([1, 2, 3], unit='D',
...                origin=pd.Timestamp('1960-01-01'))
DatetimeIndex(['1960-01-02', '1960-01-03', '1960-01-04'],
              dtype='datetime64[ns]', freq=None)

**Non-convertible date/times**

If a date does not meet the `timestamp limitations
&lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html
#timeseries-timestamp-limits&gt;`_, passing ``errors='ignore'``
will return the original input instead of raising any exception.

Passing ``errors='coerce'`` will force an out-of-bounds date to :const:`NaT`,
in addition to forcing non-dates (or non-parseable dates) to :const:`NaT`.

&gt;&gt;&gt; pd.to_datetime('13000101', format='%Y%m%d', errors='ignore')
datetime.datetime(1300, 1, 1, 0, 0)
&gt;&gt;&gt; pd.to_datetime('13000101', format='%Y%m%d', errors='coerce')
NaT

.. _to_datetime_tz_examples:

**Timezones and time offsets**

The default behaviour (``utc=False``) is as follows:

- Timezone-naive inputs are converted to timezone-naive :class:`DatetimeIndex`:

&gt;&gt;&gt; pd.to_datetime(['2018-10-26 12:00', '2018-10-26 13:00:15'])
DatetimeIndex(['2018-10-26 12:00:00', '2018-10-26 13:00:15'],
              dtype='datetime64[ns]', freq=None)

- Timezone-aware inputs *with constant time offset* are converted to
  timezone-aware :class:`DatetimeIndex`:

&gt;&gt;&gt; pd.to_datetime(['2018-10-26 12:00 -0500', '2018-10-26 13:00 -0500'])
DatetimeIndex(['2018-10-26 12:00:00-05:00', '2018-10-26 13:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)

- However, timezone-aware inputs *with mixed time offsets* (for example
  issued from a timezone with daylight savings, such as Europe/Paris)
  are **not successfully converted** to a :class:`DatetimeIndex`. Instead a
  simple :class:`Index` containing :class:`datetime.datetime` objects is
  returned:

&gt;&gt;&gt; pd.to_datetime(['2020-10-25 02:00 +0200', '2020-10-25 04:00 +0100'])
Index([2020-10-25 02:00:00+02:00, 2020-10-25 04:00:00+01:00],
      dtype='object')

- A mix of timezone-aware and timezone-naive inputs is converted to
  a timezone-aware :class:`DatetimeIndex` if the offsets of the timezone-aware
  are constant:

&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; pd.to_datetime(["2020-01-01 01:00 -01:00", datetime(2020, 1, 1, 3, 0)])
DatetimeIndex(['2020-01-01 01:00:00-01:00', '2020-01-01 02:00:00-01:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-60)]', freq=None)

|

Setting ``utc=True`` solves most of the above issues:

- Timezone-naive inputs are *localized* as UTC

&gt;&gt;&gt; pd.to_datetime(['2018-10-26 12:00', '2018-10-26 13:00'], utc=True)
DatetimeIndex(['2018-10-26 12:00:00+00:00', '2018-10-26 13:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq=None)

- Timezone-aware inputs are *converted* to UTC (the output represents the
  exact same datetime, but viewed from the UTC time offset `+00:00`).

&gt;&gt;&gt; pd.to_datetime(['2018-10-26 12:00 -0530', '2018-10-26 12:00 -0500'],
...                utc=True)
DatetimeIndex(['2018-10-26 17:30:00+00:00', '2018-10-26 17:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq=None)

- Inputs can contain both naive and aware, string or datetime, the above
  rules still apply

&gt;&gt;&gt; from datetime import timezone, timedelta
&gt;&gt;&gt; pd.to_datetime(['2018-10-26 12:00', '2018-10-26 12:00 -0530',
...                datetime(2020, 1, 1, 18),
...                datetime(2020, 1, 1, 18,
...                tzinfo=timezone(-timedelta(hours=1)))],
...                utc=True)
DatetimeIndex(['2018-10-26 12:00:00+00:00', '2018-10-26 17:30:00+00:00',
               '2020-01-01 18:00:00+00:00', '2020-01-01 19:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq=None)
</pre> <div class="fragment"><div class="line"><span class="lineno">  717</span>) -&gt; DatetimeIndex | Series | DatetimeScalar | NaTType | <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  718</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    Convert argument to datetime.</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    This function converts a scalar, array-like, :class:`Series` or</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    :class:`DataFrame`/dict-like to a pandas datetime object.</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    arg : int, float, str, datetime, list, tuple, 1-d array, Series, DataFrame/dict-like</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">        The object to convert to a datetime. If a :class:`DataFrame` is provided, the</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        method expects minimally the following columns: :const:`&quot;year&quot;`,</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">        :const:`&quot;month&quot;`, :const:`&quot;day&quot;`.</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    errors : {&#39;ignore&#39;, &#39;raise&#39;, &#39;coerce&#39;}, default &#39;raise&#39;</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">        - If :const:`&#39;raise&#39;`, then invalid parsing will raise an exception.</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">        - If :const:`&#39;coerce&#39;`, then invalid parsing will be set as :const:`NaT`.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">        - If :const:`&#39;ignore&#39;`, then invalid parsing will return the input.</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    dayfirst : bool, default False</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        Specify a date parse order if `arg` is str or is list-like.</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        If :const:`True`, parses dates with the day first, e.g. :const:`&quot;10/11/12&quot;`</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">        is parsed as :const:`2012-11-10`.</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        .. warning::</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">            ``dayfirst=True`` is not strict, but will prefer to parse</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">            with day first. If a delimited date string cannot be parsed in</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">            accordance with the given `dayfirst` option, e.g.</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">            ``to_datetime([&#39;31-12-2021&#39;])``, then a warning will be shown.</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    yearfirst : bool, default False</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        Specify a date parse order if `arg` is str or is list-like.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        - If :const:`True` parses dates with the year first, e.g.</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">          :const:`&quot;10/11/12&quot;` is parsed as :const:`2010-11-12`.</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        - If both `dayfirst` and `yearfirst` are :const:`True`, `yearfirst` is</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">          preceded (same as :mod:`dateutil`).</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        .. warning::</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">            ``yearfirst=True`` is not strict, but will prefer to parse</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">            with year first.</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    utc : bool, default None</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        Control timezone-related parsing, localization and conversion.</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        - If :const:`True`, the function *always* returns a timezone-aware</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">          UTC-localized :class:`Timestamp`, :class:`Series` or</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">          :class:`DatetimeIndex`. To do this, timezone-naive inputs are</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">          *localized* as UTC, while timezone-aware inputs are *converted* to UTC.</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        - If :const:`False` (default), inputs will not be coerced to UTC.</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">          Timezone-naive inputs will remain naive, while timezone-aware ones</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">          will keep their time offsets. Limitations exist for mixed</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">          offsets (typically, daylight savings), see :ref:`Examples</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">          &lt;to_datetime_tz_examples&gt;` section for details.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">        See also: pandas general documentation about `timezone conversion and</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">        localization</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        #time-zone-handling&gt;`_.</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    format : str, default None</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        The strftime to parse time, e.g. :const:`&quot;%d/%m/%Y&quot;`. Note that</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">        :const:`&quot;%f&quot;` will parse all the way up to nanoseconds. See</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">        `strftime documentation</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">        &lt;https://docs.python.org/3/library/datetime.html</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        #strftime-and-strptime-behavior&gt;`_ for more information on choices.</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    exact : bool, default True</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        Control how `format` is used:</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        - If :const:`True`, require an exact `format` match.</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        - If :const:`False`, allow the `format` to match anywhere in the target</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">          string.</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    unit : str, default &#39;ns&#39;</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        The unit of the arg (D,s,ms,us,ns) denote the unit, which is an</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">        integer or float number. This will be based off the origin.</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        Example, with ``unit=&#39;ms&#39;`` and ``origin=&#39;unix&#39;``, this would calculate</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        the number of milliseconds to the unix epoch start.</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    infer_datetime_format : bool, default False</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">        If :const:`True` and no `format` is given, attempt to infer the format</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        of the datetime strings based on the first non-NaN element,</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">        and if it can be inferred, switch to a faster method of parsing them.</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">        In some cases this can increase the parsing speed by ~5-10x.</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    origin : scalar, default &#39;unix&#39;</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">        Define the reference date. The numeric values would be parsed as number</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">        of units (defined by `unit`) since this reference date.</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        - If :const:`&#39;unix&#39;` (or POSIX) time; origin is set to 1970-01-01.</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        - If :const:`&#39;julian&#39;`, unit must be :const:`&#39;D&#39;`, and origin is set to</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">          beginning of Julian Calendar. Julian day number :const:`0` is assigned</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">          to the day starting at noon on January 1, 4713 BC.</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        - If Timestamp convertible, origin is set to Timestamp identified by</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">          origin.</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    cache : bool, default True</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">        If :const:`True`, use a cache of unique, converted dates to apply the</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">        datetime conversion. May produce significant speed-up when parsing</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">        duplicate date strings, especially ones with timezone offsets. The cache</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">        is only used when there are at least 50 values. The presence of</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">        out-of-bounds values will render the cache unusable and may slow down</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        parsing.</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">        .. versionchanged:: 0.25.0</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">            changed default value from :const:`False` to :const:`True`.</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    datetime</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">        If parsing succeeded.</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">        Return type depends on input (types in parenthesis correspond to</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">        fallback in case of unsuccessful timezone or out-of-range timestamp</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">        parsing):</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">        - scalar: :class:`Timestamp` (or :class:`datetime.datetime`)</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">        - array-like: :class:`DatetimeIndex` (or :class:`Series` with</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">          :class:`object` dtype containing :class:`datetime.datetime`)</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">        - Series: :class:`Series` of :class:`datetime64` dtype (or</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">          :class:`Series` of :class:`object` dtype containing</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">          :class:`datetime.datetime`)</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">        - DataFrame: :class:`Series` of :class:`datetime64` dtype (or</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">          :class:`Series` of :class:`object` dtype containing</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">          :class:`datetime.datetime`)</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    ParserError</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        When parsing a date from string fails.</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        When another datetime conversion error happens. For example when one</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">        of &#39;year&#39;, &#39;month&#39;, day&#39; columns is missing in a :class:`DataFrame`, or</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        when a Timezone-aware :class:`datetime.datetime` is found in an array-like</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">        of mixed time offsets, and ``utc=False``.</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">    DataFrame.astype : Cast argument to a specified dtype.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    to_timedelta : Convert argument to timedelta.</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">    convert_dtypes : Convert dtypes.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    Many input types are supported, and lead to different output types:</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    - **scalars** can be int, float, str, datetime object (from stdlib :mod:`datetime`</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">      module or :mod:`numpy`). They are converted to :class:`Timestamp` when</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">      possible, otherwise they are converted to :class:`datetime.datetime`.</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">      None/NaN/null scalars are converted to :const:`NaT`.</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    - **array-like** can contain int, float, str, datetime objects. They are</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">      converted to :class:`DatetimeIndex` when possible, otherwise they are</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">      converted to :class:`Index` with :class:`object` dtype, containing</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">      :class:`datetime.datetime`. None/NaN/null entries are converted to</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">      :const:`NaT` in both cases.</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    - **Series** are converted to :class:`Series` with :class:`datetime64`</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">      dtype when possible, otherwise they are converted to :class:`Series` with</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">      :class:`object` dtype, containing :class:`datetime.datetime`. None/NaN/null</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">      entries are converted to :const:`NaT` in both cases.</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    - **DataFrame/dict-like** are converted to :class:`Series` with</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">      :class:`datetime64` dtype. For each row a datetime is created from assembling</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">      the various dataframe columns. Column keys can be common abbreviations</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">      like [year, month, day, minute, second, ms, us, ns]) or</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">      plurals of the same.</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    The following causes are responsible for :class:`datetime.datetime` objects</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    being returned (possibly inside an :class:`Index` or a :class:`Series` with</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    :class:`object` dtype) instead of a proper pandas designated type</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    (:class:`Timestamp`, :class:`DatetimeIndex` or :class:`Series`</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    with :class:`datetime64` dtype):</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    - when any input element is before :const:`Timestamp.min` or after</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">      :const:`Timestamp.max`, see `timestamp limitations</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">      &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">      #timeseries-timestamp-limits&gt;`_.</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    - when ``utc=False`` (default) and the input is an array-like or</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">      :class:`Series` containing mixed naive/aware datetime, or aware with mixed</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">      time offsets. Note that this happens in the (quite frequent) situation when</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">      the timezone has a daylight savings policy. In that case you may wish to</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">      use ``utc=True``.</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    **Handling various input formats**</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    Assembling a datetime from multiple columns of a :class:`DataFrame`. The keys</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    can be common abbreviations like [&#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;minute&#39;, &#39;second&#39;,</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39;]) or plurals of the same</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    &gt;&gt;&gt; df = pd.DataFrame({&#39;year&#39;: [2015, 2016],</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    ...                    &#39;month&#39;: [2, 3],</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    ...                    &#39;day&#39;: [4, 5]})</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime(df)</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    0   2015-02-04</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    1   2016-03-05</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    dtype: datetime64[ns]</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    Passing ``infer_datetime_format=True`` can often-times speedup a parsing</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    if its not an ISO8601 format exactly, but in a regular format.</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    &gt;&gt;&gt; s = pd.Series([&#39;3/11/2000&#39;, &#39;3/12/2000&#39;, &#39;3/13/2000&#39;] * 1000)</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    &gt;&gt;&gt; s.head()</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    0    3/11/2000</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    1    3/12/2000</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    2    3/13/2000</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    3    3/11/2000</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    4    3/12/2000</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    dtype: object</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    &gt;&gt;&gt; %timeit pd.to_datetime(s, infer_datetime_format=True)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    100 loops, best of 3: 10.4 ms per loop</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    &gt;&gt;&gt; %timeit pd.to_datetime(s, infer_datetime_format=False)  # doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    1 loop, best of 3: 471 ms per loop</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    Using a unix epoch time</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime(1490195805, unit=&#39;s&#39;)</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    Timestamp(&#39;2017-03-22 15:16:45&#39;)</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime(1490195805433502912, unit=&#39;ns&#39;)</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    Timestamp(&#39;2017-03-22 15:16:45.433502912&#39;)</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    .. warning:: For float arg, precision rounding might happen. To prevent</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">        unexpected behavior use a fixed-width exact type.</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    Using a non-unix epoch origin</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([1, 2, 3], unit=&#39;D&#39;,</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    ...                origin=pd.Timestamp(&#39;1960-01-01&#39;))</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">    DatetimeIndex([&#39;1960-01-02&#39;, &#39;1960-01-03&#39;, &#39;1960-01-04&#39;],</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">                  dtype=&#39;datetime64[ns]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    **Non-convertible date/times**</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">    If a date does not meet the `timestamp limitations</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    #timeseries-timestamp-limits&gt;`_, passing ``errors=&#39;ignore&#39;``</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    will return the original input instead of raising any exception.</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    Passing ``errors=&#39;coerce&#39;`` will force an out-of-bounds date to :const:`NaT`,</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    in addition to forcing non-dates (or non-parseable dates) to :const:`NaT`.</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;ignore&#39;)</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    datetime.datetime(1300, 1, 1, 0, 0)</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime(&#39;13000101&#39;, format=&#39;%Y%m%d&#39;, errors=&#39;coerce&#39;)</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    NaT</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    .. _to_datetime_tz_examples:</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    **Timezones and time offsets**</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    The default behaviour (``utc=False``) is as follows:</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    - Timezone-naive inputs are converted to timezone-naive :class:`DatetimeIndex`:</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00&#39;, &#39;2018-10-26 13:00:15&#39;])</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    DatetimeIndex([&#39;2018-10-26 12:00:00&#39;, &#39;2018-10-26 13:00:15&#39;],</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">                  dtype=&#39;datetime64[ns]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    - Timezone-aware inputs *with constant time offset* are converted to</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">      timezone-aware :class:`DatetimeIndex`:</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00 -0500&#39;, &#39;2018-10-26 13:00 -0500&#39;])</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    DatetimeIndex([&#39;2018-10-26 12:00:00-05:00&#39;, &#39;2018-10-26 13:00:00-05:00&#39;],</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">                  dtype=&#39;datetime64[ns, pytz.FixedOffset(-300)]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    - However, timezone-aware inputs *with mixed time offsets* (for example</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">      issued from a timezone with daylight savings, such as Europe/Paris)</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">      are **not successfully converted** to a :class:`DatetimeIndex`. Instead a</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">      simple :class:`Index` containing :class:`datetime.datetime` objects is</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">      returned:</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([&#39;2020-10-25 02:00 +0200&#39;, &#39;2020-10-25 04:00 +0100&#39;])</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">    Index([2020-10-25 02:00:00+02:00, 2020-10-25 04:00:00+01:00],</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">          dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">    - A mix of timezone-aware and timezone-naive inputs is converted to</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">      a timezone-aware :class:`DatetimeIndex` if the offsets of the timezone-aware</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">      are constant:</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    &gt;&gt;&gt; from datetime import datetime</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([&quot;2020-01-01 01:00 -01:00&quot;, datetime(2020, 1, 1, 3, 0)])</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    DatetimeIndex([&#39;2020-01-01 01:00:00-01:00&#39;, &#39;2020-01-01 02:00:00-01:00&#39;],</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">                  dtype=&#39;datetime64[ns, pytz.FixedOffset(-60)]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    |</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    Setting ``utc=True`` solves most of the above issues:</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    - Timezone-naive inputs are *localized* as UTC</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00&#39;, &#39;2018-10-26 13:00&#39;], utc=True)</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    DatetimeIndex([&#39;2018-10-26 12:00:00+00:00&#39;, &#39;2018-10-26 13:00:00+00:00&#39;],</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">                  dtype=&#39;datetime64[ns, UTC]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    - Timezone-aware inputs are *converted* to UTC (the output represents the</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">      exact same datetime, but viewed from the UTC time offset `+00:00`).</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00 -0530&#39;, &#39;2018-10-26 12:00 -0500&#39;],</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    ...                utc=True)</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    DatetimeIndex([&#39;2018-10-26 17:30:00+00:00&#39;, &#39;2018-10-26 17:00:00+00:00&#39;],</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">                  dtype=&#39;datetime64[ns, UTC]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    - Inputs can contain both naive and aware, string or datetime, the above</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">      rules still apply</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    &gt;&gt;&gt; from datetime import timezone, timedelta</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    &gt;&gt;&gt; pd.to_datetime([&#39;2018-10-26 12:00&#39;, &#39;2018-10-26 12:00 -0530&#39;,</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    ...                datetime(2020, 1, 1, 18),</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    ...                datetime(2020, 1, 1, 18,</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    ...                tzinfo=timezone(-timedelta(hours=1)))],</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    ...                utc=True)</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    DatetimeIndex([&#39;2018-10-26 12:00:00+00:00&#39;, &#39;2018-10-26 17:30:00+00:00&#39;,</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">                   &#39;2020-01-01 18:00:00+00:00&#39;, &#39;2020-01-01 19:00:00+00:00&#39;],</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">                  dtype=&#39;datetime64[ns, UTC]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1036</span>    <span class="keywordflow">if</span> arg <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1037</span>        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1038</span> </div>
<div class="line"><span class="lineno"> 1039</span>    <span class="keywordflow">if</span> origin != <span class="stringliteral">&quot;unix&quot;</span>:</div>
<div class="line"><span class="lineno"> 1040</span>        arg = _adjust_to_origin(arg, origin, unit)</div>
<div class="line"><span class="lineno"> 1041</span> </div>
<div class="line"><span class="lineno"> 1042</span>    tz = <span class="stringliteral">&quot;utc&quot;</span> <span class="keywordflow">if</span> utc <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1043</span>    convert_listlike = partial(</div>
<div class="line"><span class="lineno"> 1044</span>        _convert_listlike_datetimes,</div>
<div class="line"><span class="lineno"> 1045</span>        tz=tz,</div>
<div class="line"><span class="lineno"> 1046</span>        unit=unit,</div>
<div class="line"><span class="lineno"> 1047</span>        dayfirst=dayfirst,</div>
<div class="line"><span class="lineno"> 1048</span>        yearfirst=yearfirst,</div>
<div class="line"><span class="lineno"> 1049</span>        errors=errors,</div>
<div class="line"><span class="lineno"> 1050</span>        exact=exact,</div>
<div class="line"><span class="lineno"> 1051</span>        infer_datetime_format=infer_datetime_format,</div>
<div class="line"><span class="lineno"> 1052</span>    )</div>
<div class="line"><span class="lineno"> 1053</span> </div>
<div class="line"><span class="lineno"> 1054</span>    result: Timestamp | NaTType | Series | Index</div>
<div class="line"><span class="lineno"> 1055</span> </div>
<div class="line"><span class="lineno"> 1056</span>    <span class="keywordflow">if</span> isinstance(arg, Timestamp):</div>
<div class="line"><span class="lineno"> 1057</span>        result = arg</div>
<div class="line"><span class="lineno"> 1058</span>        <span class="keywordflow">if</span> tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1059</span>            <span class="keywordflow">if</span> arg.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1060</span>                result = arg.tz_convert(tz)</div>
<div class="line"><span class="lineno"> 1061</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1062</span>                result = arg.tz_localize(tz)</div>
<div class="line"><span class="lineno"> 1063</span>    <span class="keywordflow">elif</span> isinstance(arg, ABCSeries):</div>
<div class="line"><span class="lineno"> 1064</span>        cache_array = _maybe_cache(arg, format, cache, convert_listlike)</div>
<div class="line"><span class="lineno"> 1065</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> cache_array.empty:</div>
<div class="line"><span class="lineno"> 1066</span>            result = arg.map(cache_array)</div>
<div class="line"><span class="lineno"> 1067</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1068</span>            values = convert_listlike(arg._values, format)</div>
<div class="line"><span class="lineno"> 1069</span>            result = arg._constructor(values, index=arg.index, name=arg.name)</div>
<div class="line"><span class="lineno"> 1070</span>    <span class="keywordflow">elif</span> isinstance(arg, (ABCDataFrame, abc.MutableMapping)):</div>
<div class="line"><span class="lineno"> 1071</span>        result = _assemble_from_unit_mappings(arg, errors, tz)</div>
<div class="line"><span class="lineno"> 1072</span>    <span class="keywordflow">elif</span> isinstance(arg, Index):</div>
<div class="line"><span class="lineno"> 1073</span>        cache_array = _maybe_cache(arg, format, cache, convert_listlike)</div>
<div class="line"><span class="lineno"> 1074</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> cache_array.empty:</div>
<div class="line"><span class="lineno"> 1075</span>            result = _convert_and_box_cache(arg, cache_array, name=arg.name)</div>
<div class="line"><span class="lineno"> 1076</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1077</span>            result = convert_listlike(arg, format, name=arg.name)</div>
<div class="line"><span class="lineno"> 1078</span>    <span class="keywordflow">elif</span> is_list_like(arg):</div>
<div class="line"><span class="lineno"> 1079</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1080</span>            <span class="comment"># error: Argument 1 to &quot;_maybe_cache&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 1081</span>            <span class="comment"># &quot;Union[float, str, datetime, List[Any], Tuple[Any, ...], ExtensionArray,</span></div>
<div class="line"><span class="lineno"> 1082</span>            <span class="comment"># ndarray[Any, Any], Series]&quot;; expected &quot;Union[List[Any], Tuple[Any, ...],</span></div>
<div class="line"><span class="lineno"> 1083</span>            <span class="comment"># Union[Union[ExtensionArray, ndarray[Any, Any]], Index, Series], Series]&quot;</span></div>
<div class="line"><span class="lineno"> 1084</span>            argc = cast(</div>
<div class="line"><span class="lineno"> 1085</span>                Union[list, tuple, ExtensionArray, np.ndarray, <span class="stringliteral">&quot;Series&quot;</span>, Index], arg</div>
<div class="line"><span class="lineno"> 1086</span>            )</div>
<div class="line"><span class="lineno"> 1087</span>            cache_array = _maybe_cache(argc, format, cache, convert_listlike)</div>
<div class="line"><span class="lineno"> 1088</span>        <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno"> 1089</span>            <span class="comment"># caching attempts to create a DatetimeIndex, which may raise</span></div>
<div class="line"><span class="lineno"> 1090</span>            <span class="comment"># an OOB. If that&#39;s the desired behavior, then just reraise...</span></div>
<div class="line"><span class="lineno"> 1091</span>            <span class="keywordflow">if</span> errors == <span class="stringliteral">&quot;raise&quot;</span>:</div>
<div class="line"><span class="lineno"> 1092</span>                <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 1093</span>            <span class="comment"># ... otherwise, continue without the cache.</span></div>
<div class="line"><span class="lineno"> 1094</span>            <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno"> 1095</span> </div>
<div class="line"><span class="lineno"> 1096</span>            cache_array = Series([], dtype=object)  <span class="comment"># just an empty array</span></div>
<div class="line"><span class="lineno"> 1097</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> cache_array.empty:</div>
<div class="line"><span class="lineno"> 1098</span>            result = _convert_and_box_cache(argc, cache_array)</div>
<div class="line"><span class="lineno"> 1099</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1100</span>            result = convert_listlike(argc, format)</div>
<div class="line"><span class="lineno"> 1101</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1102</span>        result = convert_listlike(np.array([arg]), format)[0]</div>
<div class="line"><span class="lineno"> 1103</span>        <span class="keywordflow">if</span> isinstance(arg, bool) <span class="keywordflow">and</span> isinstance(result, np.bool_):</div>
<div class="line"><span class="lineno"> 1104</span>            result = bool(result)  <span class="comment"># TODO: avoid this kludge.</span></div>
<div class="line"><span class="lineno"> 1105</span> </div>
<div class="line"><span class="lineno"> 1106</span>    <span class="comment">#  error: Incompatible return value type (got &quot;Union[Timestamp, NaTType,</span></div>
<div class="line"><span class="lineno"> 1107</span>    <span class="comment"># Series, Index]&quot;, expected &quot;Union[DatetimeIndex, Series, float, str,</span></div>
<div class="line"><span class="lineno"> 1108</span>    <span class="comment"># NaTType, None]&quot;)</span></div>
<div class="line"><span class="lineno"> 1109</span>    <span class="keywordflow">return</span> result  <span class="comment"># type: ignore[return-value]</span></div>
<div class="line"><span class="lineno"> 1110</span> </div>
<div class="line"><span class="lineno"> 1111</span> </div>
<div class="line"><span class="lineno"> 1112</span><span class="comment"># mappings for assembling units</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1951afd0cfb09c39049ac620d40e32cf" name="a1951afd0cfb09c39049ac620d40e32cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951afd0cfb09c39049ac620d40e32cf">&#9670;&#160;</a></span>to_datetime() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html">DatetimeIndex</a> pandas.core.tools.datetimes.to_datetime </td>
          <td>(</td>
          <td class="paramtype">list | tuple | <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | ArrayLike&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTimeErrorChoices &#160;</td>
          <td class="paramname"><em>errors</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dayfirst</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>yearfirst</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>utc</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>format</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exact</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>unit</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>infer_datetime_format</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>cache</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  701</span>) -&gt; DatetimeIndex:</div>
<div class="line"><span class="lineno">  702</span>    ...</div>
<div class="line"><span class="lineno">  703</span> </div>
<div class="line"><span class="lineno">  704</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa26c55dc254a7ad369082749ad007a97" name="aa26c55dc254a7ad369082749ad007a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26c55dc254a7ad369082749ad007a97">&#9670;&#160;</a></span>to_datetime() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Series pandas.core.tools.datetimes.to_datetime </td>
          <td>(</td>
          <td class="paramtype">Series | <a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a8abf3f5e6ff0903da2999f6315ee14c6">DictConvertible</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTimeErrorChoices &#160;</td>
          <td class="paramname"><em>errors</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dayfirst</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>yearfirst</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool | None &#160;</td>
          <td class="paramname"><em>utc</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>format</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>exact</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>unit</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>infer_datetime_format</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>cache</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  684</span>) -&gt; Series:</div>
<div class="line"><span class="lineno">  685</span>    ...</div>
<div class="line"><span class="lineno">  686</span> </div>
<div class="line"><span class="lineno">  687</span> </div>
<div class="line"><span class="lineno">  688</span><span class="preprocessor">@overload</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afa29bb4b7aa364ef830fc7012d7a0561" name="afa29bb4b7aa364ef830fc7012d7a0561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa29bb4b7aa364ef830fc7012d7a0561">&#9670;&#160;</a></span>to_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes.to_time </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>infer_time_format</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;raise&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1285</span><span class="keyword">def </span>to_time(arg, format=None, infer_time_format=False, errors=&quot;raise&quot;):</div>
<div class="line"><span class="lineno"> 1286</span>    <span class="comment"># GH#34145</span></div>
<div class="line"><span class="lineno"> 1287</span>    warnings.warn(</div>
<div class="line"><span class="lineno"> 1288</span>        <span class="stringliteral">&quot;`to_time` has been moved, should be imported from pandas.core.tools.times. &quot;</span></div>
<div class="line"><span class="lineno"> 1289</span>        <span class="stringliteral">&quot;This alias will be removed in a future version.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1290</span>        FutureWarning,</div>
<div class="line"><span class="lineno"> 1291</span>        stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1292</span>    )</div>
<div class="line"><span class="lineno"> 1293</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1tools_1_1times.html">pandas.core.tools.times</a> <span class="keyword">import</span> to_time</div>
<div class="line"><span class="lineno"> 1294</span> </div>
<div class="line"><span class="lineno"> 1295</span>    <span class="keywordflow">return</span> to_time(arg, format, infer_time_format, errors)</div>
<div class="line"><span class="lineno"> 1296</span> </div>
<div class="line"><span class="lineno"> 1297</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1tools_1_1times_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1tools_1_1times.html">pandas.core.tools.times</a></div><div class="ttdef"><b>Definition</b> times.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a79b3451c8df8c5976cb278f8da0aca86" name="a79b3451c8df8c5976cb278f8da0aca86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b3451c8df8c5976cb278f8da0aca86">&#9670;&#160;</a></span>_unit_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.tools.datetimes._unit_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;year&quot;</span>: <span class="stringliteral">&quot;year&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;years&quot;</span>: <span class="stringliteral">&quot;year&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;month&quot;</span>: <span class="stringliteral">&quot;month&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;months&quot;</span>: <span class="stringliteral">&quot;month&quot;</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;day&quot;</span>: <span class="stringliteral">&quot;day&quot;</span>,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;days&quot;</span>: <span class="stringliteral">&quot;day&quot;</span>,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;hour&quot;</span>: <span class="stringliteral">&quot;h&quot;</span>,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;hours&quot;</span>: <span class="stringliteral">&quot;h&quot;</span>,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;minute&quot;</span>: <span class="stringliteral">&quot;m&quot;</span>,</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&quot;minutes&quot;</span>: <span class="stringliteral">&quot;m&quot;</span>,</div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">&quot;second&quot;</span>: <span class="stringliteral">&quot;s&quot;</span>,</div>
<div class="line"><span class="lineno">   13</span>    <span class="stringliteral">&quot;seconds&quot;</span>: <span class="stringliteral">&quot;s&quot;</span>,</div>
<div class="line"><span class="lineno">   14</span>    <span class="stringliteral">&quot;ms&quot;</span>: <span class="stringliteral">&quot;ms&quot;</span>,</div>
<div class="line"><span class="lineno">   15</span>    <span class="stringliteral">&quot;millisecond&quot;</span>: <span class="stringliteral">&quot;ms&quot;</span>,</div>
<div class="line"><span class="lineno">   16</span>    <span class="stringliteral">&quot;milliseconds&quot;</span>: <span class="stringliteral">&quot;ms&quot;</span>,</div>
<div class="line"><span class="lineno">   17</span>    <span class="stringliteral">&quot;us&quot;</span>: <span class="stringliteral">&quot;us&quot;</span>,</div>
<div class="line"><span class="lineno">   18</span>    <span class="stringliteral">&quot;microsecond&quot;</span>: <span class="stringliteral">&quot;us&quot;</span>,</div>
<div class="line"><span class="lineno">   19</span>    <span class="stringliteral">&quot;microseconds&quot;</span>: <span class="stringliteral">&quot;us&quot;</span>,</div>
<div class="line"><span class="lineno">   20</span>    <span class="stringliteral">&quot;ns&quot;</span>: <span class="stringliteral">&quot;ns&quot;</span>,</div>
<div class="line"><span class="lineno">   21</span>    <span class="stringliteral">&quot;nanosecond&quot;</span>: <span class="stringliteral">&quot;ns&quot;</span>,</div>
<div class="line"><span class="lineno">   22</span>    <span class="stringliteral">&quot;nanoseconds&quot;</span>: <span class="stringliteral">&quot;ns&quot;</span>,</div>
<div class="line"><span class="lineno">   23</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a84b1dd1a397c88da61c405304f0cb259" name="a84b1dd1a397c88da61c405304f0cb259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b1dd1a397c88da61c405304f0cb259">&#9670;&#160;</a></span>ArrayConvertible</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes.ArrayConvertible = Union[List, Tuple, AnyArrayLike]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ce79427c6728ded3dbf7779ec6b371d" name="a3ce79427c6728ded3dbf7779ec6b371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce79427c6728ded3dbf7779ec6b371d">&#9670;&#160;</a></span>DatetimeDictArg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes.DatetimeDictArg = Union[List[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a02fa70511896af507a8512507be5aa99">Scalar</a>], Tuple[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a02fa70511896af507a8512507be5aa99">Scalar</a>, ...], AnyArrayLike]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad678b01744f19f8a5268bfd6fa56592" name="aad678b01744f19f8a5268bfd6fa56592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad678b01744f19f8a5268bfd6fa56592">&#9670;&#160;</a></span>DatetimeScalar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes.DatetimeScalar = Union[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a02fa70511896af507a8512507be5aa99">Scalar</a>, datetime]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8217e588e94ff87dbb2f21b512aea797" name="a8217e588e94ff87dbb2f21b512aea797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8217e588e94ff87dbb2f21b512aea797">&#9670;&#160;</a></span>DatetimeScalarOrArrayConvertible</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes.DatetimeScalarOrArrayConvertible = Union[<a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#aad678b01744f19f8a5268bfd6fa56592">DatetimeScalar</a>, <a class="el" href="namespacepandas_1_1core_1_1tools_1_1datetimes.html#a84b1dd1a397c88da61c405304f0cb259">ArrayConvertible</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8abf3f5e6ff0903da2999f6315ee14c6" name="a8abf3f5e6ff0903da2999f6315ee14c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abf3f5e6ff0903da2999f6315ee14c6">&#9670;&#160;</a></span>DictConvertible</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes.DictConvertible = Union[<a class="el" href="classpandas_1_1core_1_1tools_1_1datetimes_1_1_fulldatetime_dict.html">FulldatetimeDict</a>, &quot;DataFrame&quot;]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02fa70511896af507a8512507be5aa99" name="a02fa70511896af507a8512507be5aa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fa70511896af507a8512507be5aa99">&#9670;&#160;</a></span>Scalar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.tools.datetimes.Scalar = Union[float, str]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a699494cc01fb31a3e719d6492100c326" name="a699494cc01fb31a3e719d6492100c326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699494cc01fb31a3e719d6492100c326">&#9670;&#160;</a></span>start_caching_at</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pandas.core.tools.datetimes.start_caching_at = 50</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
