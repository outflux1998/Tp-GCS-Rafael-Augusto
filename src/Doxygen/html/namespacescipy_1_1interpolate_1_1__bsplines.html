<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.interpolate._bsplines Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1interpolate.html">interpolate</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html">_bsplines</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.interpolate._bsplines Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1interpolate_1_1__bsplines_1_1_b_spline.html">BSpline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a12eff94cc3957733a4b568f78ce9944c" id="r_a12eff94cc3957733a4b568f78ce9944c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a12eff94cc3957733a4b568f78ce9944c">_get_dtype</a> (dtype)</td></tr>
<tr class="separator:a12eff94cc3957733a4b568f78ce9944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c22a61aaf927f68ee7310b03fa254d5" id="r_a1c22a61aaf927f68ee7310b03fa254d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a1c22a61aaf927f68ee7310b03fa254d5">_as_float_array</a> (x, check_finite=False)</td></tr>
<tr class="separator:a1c22a61aaf927f68ee7310b03fa254d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a41bd7ade0ce03532cab4aa64b1f44" id="r_a82a41bd7ade0ce03532cab4aa64b1f44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a82a41bd7ade0ce03532cab4aa64b1f44">_dual_poly</a> (<a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, t, y)</td></tr>
<tr class="separator:a82a41bd7ade0ce03532cab4aa64b1f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d533ffccb59f0e2f79d612cca9d87eb" id="r_a3d533ffccb59f0e2f79d612cca9d87eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a3d533ffccb59f0e2f79d612cca9d87eb">_diff_dual_poly</a> (<a class="el" href="__lapack__subroutines_8h.html#a7a2934b0e050f997202d3f47a979d888">j</a>, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, y, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>, t)</td></tr>
<tr class="separator:a3d533ffccb59f0e2f79d612cca9d87eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2cef211b422bf7cb0a21b9b6bfa0ad" id="r_a3b2cef211b422bf7cb0a21b9b6bfa0ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a3b2cef211b422bf7cb0a21b9b6bfa0ad">_not_a_knot</a> (x, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:a3b2cef211b422bf7cb0a21b9b6bfa0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22ff51a45adb9b9fde8780085c3b444" id="r_ab22ff51a45adb9b9fde8780085c3b444"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#ab22ff51a45adb9b9fde8780085c3b444">_augknt</a> (x, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:ab22ff51a45adb9b9fde8780085c3b444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7ff6b252a21c5e1d7eba6a1d7e2530" id="r_a6a7ff6b252a21c5e1d7eba6a1d7e2530"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a6a7ff6b252a21c5e1d7eba6a1d7e2530">_convert_string_aliases</a> (deriv, target_shape)</td></tr>
<tr class="separator:a6a7ff6b252a21c5e1d7eba6a1d7e2530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b1dd8dd949ff5e64b32bdac71a07d8" id="r_aa1b1dd8dd949ff5e64b32bdac71a07d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#aa1b1dd8dd949ff5e64b32bdac71a07d8">_process_deriv_spec</a> (deriv)</td></tr>
<tr class="separator:aa1b1dd8dd949ff5e64b32bdac71a07d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f44f2b8ccda26c4ae46a52495cd49b9" id="r_a4f44f2b8ccda26c4ae46a52495cd49b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a4f44f2b8ccda26c4ae46a52495cd49b9">_woodbury_algorithm</a> (A, ur, ll, b, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:a4f44f2b8ccda26c4ae46a52495cd49b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec44936026d4ec7a34f6d40246e0b3" id="r_ac4ec44936026d4ec7a34f6d40246e0b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#ac4ec44936026d4ec7a34f6d40246e0b3">_periodic_knots</a> (x, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:ac4ec44936026d4ec7a34f6d40246e0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d039e8899fe9c0fa0afeec009c017e" id="r_aa9d039e8899fe9c0fa0afeec009c017e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#aa9d039e8899fe9c0fa0afeec009c017e">_make_interp_per_full_matr</a> (x, y, t, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>)</td></tr>
<tr class="separator:aa9d039e8899fe9c0fa0afeec009c017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc19be1f6d49573ea1cc8d02a770a7" id="r_acefc19be1f6d49573ea1cc8d02a770a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#acefc19be1f6d49573ea1cc8d02a770a7">_make_periodic_spline</a> (x, y, t, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>, axis)</td></tr>
<tr class="separator:acefc19be1f6d49573ea1cc8d02a770a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301d5b15ab29ed96dd4caed6f3f83be6" id="r_a301d5b15ab29ed96dd4caed6f3f83be6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#a301d5b15ab29ed96dd4caed6f3f83be6">make_interp_spline</a> (x, y, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>=3, t=None, bc_type=None, axis=0, check_finite=True)</td></tr>
<tr class="separator:a301d5b15ab29ed96dd4caed6f3f83be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa247d650f5cb3bd24ecd13a9d349cebe" id="r_aa247d650f5cb3bd24ecd13a9d349cebe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1interpolate_1_1__bsplines.html#aa247d650f5cb3bd24ecd13a9d349cebe">make_lsq_spline</a> (x, y, t, <a class="el" href="__blas__subroutines_8h.html#afa8f30d4cfebc7d1efb06e7d245eff5a">k</a>=3, <a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>=None, axis=0, check_finite=True)</td></tr>
<tr class="separator:aa247d650f5cb3bd24ecd13a9d349cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1c22a61aaf927f68ee7310b03fa254d5" name="a1c22a61aaf927f68ee7310b03fa254d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c22a61aaf927f68ee7310b03fa254d5">&#9670;&#160;</a></span>_as_float_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._as_float_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert the input into a C contiguous float array.

NB: Upcasts half- and single-precision floats to double precision.
</pre> <div class="fragment"><div class="line"><span class="lineno">   27</span><span class="keyword">def </span>_as_float_array(x, check_finite=False):</div>
<div class="line"><span class="lineno">   28</span>    <span class="stringliteral">&quot;&quot;&quot;Convert the input into a C contiguous float array.</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    NB: Upcasts half- and single-precision floats to double precision.</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   32</span>    x = np.ascontiguousarray(x)</div>
<div class="line"><span class="lineno">   33</span>    dtyp = _get_dtype(x.dtype)</div>
<div class="line"><span class="lineno">   34</span>    x = x.astype(dtyp, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">   35</span>    <span class="keywordflow">if</span> check_finite <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.isfinite(x).all():</div>
<div class="line"><span class="lineno">   36</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Array must not contain infs or nans.&quot;</span>)</div>
<div class="line"><span class="lineno">   37</span>    <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno">   38</span> </div>
<div class="line"><span class="lineno">   39</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab22ff51a45adb9b9fde8780085c3b444" name="ab22ff51a45adb9b9fde8780085c3b444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22ff51a45adb9b9fde8780085c3b444">&#9670;&#160;</a></span>_augknt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._augknt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Construct a knot vector appropriate for the order-k interpolation.</pre> <div class="fragment"><div class="line"><span class="lineno">  810</span><span class="keyword">def </span>_augknt(x, k):</div>
<div class="line"><span class="lineno">  811</span>    <span class="stringliteral">&quot;&quot;&quot;Construct a knot vector appropriate for the order-k interpolation.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  812</span>    <span class="keywordflow">return</span> np.r_[(x[0],)*k, x, (x[-1],)*k]</div>
<div class="line"><span class="lineno">  813</span> </div>
<div class="line"><span class="lineno">  814</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a7ff6b252a21c5e1d7eba6a1d7e2530" name="a6a7ff6b252a21c5e1d7eba6a1d7e2530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7ff6b252a21c5e1d7eba6a1d7e2530">&#9670;&#160;</a></span>_convert_string_aliases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._convert_string_aliases </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  815</span><span class="keyword">def </span>_convert_string_aliases(deriv, target_shape):</div>
<div class="line"><span class="lineno">  816</span>    <span class="keywordflow">if</span> isinstance(deriv, str):</div>
<div class="line"><span class="lineno">  817</span>        <span class="keywordflow">if</span> deriv == <span class="stringliteral">&quot;clamped&quot;</span>:</div>
<div class="line"><span class="lineno">  818</span>            deriv = [(1, np.zeros(target_shape))]</div>
<div class="line"><span class="lineno">  819</span>        <span class="keywordflow">elif</span> deriv == <span class="stringliteral">&quot;natural&quot;</span>:</div>
<div class="line"><span class="lineno">  820</span>            deriv = [(2, np.zeros(target_shape))]</div>
<div class="line"><span class="lineno">  821</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  822</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unknown boundary condition : %s&quot;</span> % deriv)</div>
<div class="line"><span class="lineno">  823</span>    <span class="keywordflow">return</span> deriv</div>
<div class="line"><span class="lineno">  824</span> </div>
<div class="line"><span class="lineno">  825</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d533ffccb59f0e2f79d612cca9d87eb" name="a3d533ffccb59f0e2f79d612cca9d87eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d533ffccb59f0e2f79d612cca9d87eb">&#9670;&#160;</a></span>_diff_dual_poly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._diff_dual_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">d-th derivative of the dual polynomial $p_{j,k}(y)$
</pre> <div class="fragment"><div class="line"><span class="lineno">   51</span><span class="keyword">def </span>_diff_dual_poly(j, k, y, d, t):</div>
<div class="line"><span class="lineno">   52</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    d-th derivative of the dual polynomial $p_{j,k}(y)$</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">if</span> d == 0:</div>
<div class="line"><span class="lineno">   56</span>        <span class="keywordflow">return</span> _dual_poly(j, k, t, y)</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">if</span> d == k:</div>
<div class="line"><span class="lineno">   58</span>        <span class="keywordflow">return</span> poch(1, k)</div>
<div class="line"><span class="lineno">   59</span>    comb = list(combinations(range(j + 1, j + k + 1), d))</div>
<div class="line"><span class="lineno">   60</span>    res = 0</div>
<div class="line"><span class="lineno">   61</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(comb) * len(comb[0])):</div>
<div class="line"><span class="lineno">   62</span>        res += np.prod([(y - t[j + p]) <span class="keywordflow">for</span> p <span class="keywordflow">in</span> range(1, k + 1)</div>
<div class="line"><span class="lineno">   63</span>                        <span class="keywordflow">if</span> (j + p) <span class="keywordflow">not</span> <span class="keywordflow">in</span> comb[i//d]])</div>
<div class="line"><span class="lineno">   64</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno">   65</span> </div>
<div class="line"><span class="lineno">   66</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a82a41bd7ade0ce03532cab4aa64b1f44" name="a82a41bd7ade0ce03532cab4aa64b1f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a41bd7ade0ce03532cab4aa64b1f44">&#9670;&#160;</a></span>_dual_poly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._dual_poly </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Dual polynomial of the B-spline B_{j,k,t} -
polynomial which is associated with B_{j,k,t}:
$p_{j,k}(y) = (y - t_{j+1})(y - t_{j+2})...(y - t_{j+k})$
</pre> <div class="fragment"><div class="line"><span class="lineno">   40</span><span class="keyword">def </span>_dual_poly(j, k, t, y):</div>
<div class="line"><span class="lineno">   41</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    Dual polynomial of the B-spline B_{j,k,t} -</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">    polynomial which is associated with B_{j,k,t}:</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    $p_{j,k}(y) = (y - t_{j+1})(y - t_{j+2})...(y - t_{j+k})$</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   46</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno">   47</span>        <span class="keywordflow">return</span> 1</div>
<div class="line"><span class="lineno">   48</span>    <span class="keywordflow">return</span> np.prod([(y - t[j + i]) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, k + 1)])</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a12eff94cc3957733a4b568f78ce9944c" name="a12eff94cc3957733a4b568f78ce9944c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12eff94cc3957733a4b568f78ce9944c">&#9670;&#160;</a></span>_get_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._get_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return np.complex128 for complex dtypes, np.float64 otherwise.</pre> <div class="fragment"><div class="line"><span class="lineno">   19</span><span class="keyword">def </span>_get_dtype(dtype):</div>
<div class="line"><span class="lineno">   20</span>    <span class="stringliteral">&quot;&quot;&quot;Return np.complex128 for complex dtypes, np.float64 otherwise.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   21</span>    <span class="keywordflow">if</span> np.issubdtype(dtype, np.complexfloating):</div>
<div class="line"><span class="lineno">   22</span>        <span class="keywordflow">return</span> np.complex_</div>
<div class="line"><span class="lineno">   23</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   24</span>        <span class="keywordflow">return</span> np.float_</div>
<div class="line"><span class="lineno">   25</span> </div>
<div class="line"><span class="lineno">   26</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9d039e8899fe9c0fa0afeec009c017e" name="aa9d039e8899fe9c0fa0afeec009c017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d039e8899fe9c0fa0afeec009c017e">&#9670;&#160;</a></span>_make_interp_per_full_matr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._make_interp_per_full_matr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns a solution of a system for B-spline interpolation with periodic
boundary conditions. First ``k - 1`` rows of matrix are condtions of
periodicity (continuity of ``k - 1`` derivatives at the boundary points).
Last ``n`` rows are interpolation conditions.
RHS is ``k - 1`` zeros and ``n`` ordinates in this case.

Parameters
----------
x : 1-D array, shape (n,)
    Values of x - coordinate of a given set of points.
y : 1-D array, shape (n,)
    Values of y - coordinate of a given set of points.
t : 1-D array, shape(n+2*k,)
    Vector of knots.
k : int
    The maximum degree of spline

Returns
-------
c : 1-D array, shape (n+k-1,)
    B-spline coefficients

Notes
-----
``t`` is supposed to be taken on circle.</pre> <div class="fragment"><div class="line"><span class="lineno">  943</span><span class="keyword">def </span>_make_interp_per_full_matr(x, y, t, k):</div>
<div class="line"><span class="lineno">  944</span>    <span class="stringliteral">&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    Returns a solution of a system for B-spline interpolation with periodic</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">    boundary conditions. First ``k - 1`` rows of matrix are condtions of</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    periodicity (continuity of ``k - 1`` derivatives at the boundary points).</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    Last ``n`` rows are interpolation conditions.</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">    RHS is ``k - 1`` zeros and ``n`` ordinates in this case.</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    x : 1-D array, shape (n,)</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">        Values of x - coordinate of a given set of points.</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">    y : 1-D array, shape (n,)</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">        Values of y - coordinate of a given set of points.</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    t : 1-D array, shape(n+2*k,)</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">        Vector of knots.</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">        The maximum degree of spline</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral">    c : 1-D array, shape (n+k-1,)</span></div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">        B-spline coefficients</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    ``t`` is supposed to be taken on circle.</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>    x, y, t = map(np.asarray, (x, y, t))</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>    n = x.size</div>
<div class="line"><span class="lineno">  976</span>    <span class="comment"># LHS: the collocation matrix + derivatives at edges</span></div>
<div class="line"><span class="lineno">  977</span>    matr = np.zeros((n + k - 1, n + k - 1))</div>
<div class="line"><span class="lineno">  978</span> </div>
<div class="line"><span class="lineno">  979</span>    <span class="comment"># derivatives at x[0] and x[-1]:</span></div>
<div class="line"><span class="lineno">  980</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(k - 1):</div>
<div class="line"><span class="lineno">  981</span>        bb = _bspl.evaluate_all_bspl(t, k, x[0], k, nu=i + 1)</div>
<div class="line"><span class="lineno">  982</span>        matr[i, : k + 1] += bb</div>
<div class="line"><span class="lineno">  983</span>        bb = _bspl.evaluate_all_bspl(t, k, x[-1], n + k - 1, nu=i + 1)[:-1]</div>
<div class="line"><span class="lineno">  984</span>        matr[i, -k:] -= bb</div>
<div class="line"><span class="lineno">  985</span>    </div>
<div class="line"><span class="lineno">  986</span>    <span class="comment"># collocation matrix</span></div>
<div class="line"><span class="lineno">  987</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno">  988</span>        xval = x[i]</div>
<div class="line"><span class="lineno">  989</span>        <span class="comment"># find interval</span></div>
<div class="line"><span class="lineno">  990</span>        <span class="keywordflow">if</span> xval == t[k]:</div>
<div class="line"><span class="lineno">  991</span>            left = k</div>
<div class="line"><span class="lineno">  992</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  993</span>            left = np.searchsorted(t, xval) - 1</div>
<div class="line"><span class="lineno">  994</span> </div>
<div class="line"><span class="lineno">  995</span>        <span class="comment"># fill a row</span></div>
<div class="line"><span class="lineno">  996</span>        bb = _bspl.evaluate_all_bspl(t, k, xval, left)</div>
<div class="line"><span class="lineno">  997</span>        matr[i + k - 1, left-k:left+1] = bb</div>
<div class="line"><span class="lineno">  998</span>    </div>
<div class="line"><span class="lineno">  999</span>    <span class="comment"># RHS</span></div>
<div class="line"><span class="lineno"> 1000</span>    b = np.r_[[0] * (k - 1), y]</div>
<div class="line"><span class="lineno"> 1001</span> </div>
<div class="line"><span class="lineno"> 1002</span>    c = solve(matr, b)</div>
<div class="line"><span class="lineno"> 1003</span>    <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno"> 1004</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acefc19be1f6d49573ea1cc8d02a770a7" name="acefc19be1f6d49573ea1cc8d02a770a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefc19be1f6d49573ea1cc8d02a770a7">&#9670;&#160;</a></span>_make_periodic_spline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._make_periodic_spline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the (coefficients of) interpolating B-spline with periodic
boundary conditions.

Parameters
----------
x : array_like, shape (n,)
    Abscissas.
y : array_like, shape (n,)
    Ordinates.
k : int
    B-spline degree.
t : array_like, shape (n + 2 * k,).
    Knots taken on a circle, ``k`` on the left and ``k`` on the right
    of the vector ``x``.

Returns
-------
b : a BSpline object of the degree ``k`` and with knots ``t``.

Notes
-----
The original system is formed by ``n + k - 1`` equations where the first
``k - 1`` of them stand for the ``k - 1`` derivatives continuity on the
edges while the other equations correspond to an interpolating case
(matching all the input points). Due to a special form of knot vector, it
can be proved that in the original system the first and last ``k``
coefficients of a spline function are the same, respectively. It follows
from the fact that all ``k - 1`` derivatives are equal term by term at ends
and that the matrix of the original system of linear equations is
non-degenerate. So, we can reduce the number of equations to ``n - 1``
(first ``k - 1`` equations could be reduced). Another trick of this
implementation is cyclic shift of values of B-splines due to equality of
``k`` unknown coefficients. With this we can receive matrix of the system
with upper right and lower left blocks, and ``k`` diagonals.  It allows
to use Woodbury formula to optimize the computations.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1005</span><span class="keyword">def </span>_make_periodic_spline(x, y, t, k, axis):</div>
<div class="line"><span class="lineno"> 1006</span>    <span class="stringliteral">&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    Compute the (coefficients of) interpolating B-spline with periodic</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    boundary conditions.</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    x : array_like, shape (n,)</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">        Abscissas.</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    y : array_like, shape (n,)</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">        Ordinates.</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        B-spline degree.</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    t : array_like, shape (n + 2 * k,).</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">        Knots taken on a circle, ``k`` on the left and ``k`` on the right</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">        of the vector ``x``.</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    b : a BSpline object of the degree ``k`` and with knots ``t``.</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    The original system is formed by ``n + k - 1`` equations where the first</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    ``k - 1`` of them stand for the ``k - 1`` derivatives continuity on the</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    edges while the other equations correspond to an interpolating case</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    (matching all the input points). Due to a special form of knot vector, it</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    can be proved that in the original system the first and last ``k``</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    coefficients of a spline function are the same, respectively. It follows</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    from the fact that all ``k - 1`` derivatives are equal term by term at ends</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    and that the matrix of the original system of linear equations is</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    non-degenerate. So, we can reduce the number of equations to ``n - 1``</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    (first ``k - 1`` equations could be reduced). Another trick of this</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    implementation is cyclic shift of values of B-splines due to equality of</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    ``k`` unknown coefficients. With this we can receive matrix of the system</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    with upper right and lower left blocks, and ``k`` diagonals.  It allows</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    to use Woodbury formula to optimize the computations.</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 1044</span>    n = y.shape[0]</div>
<div class="line"><span class="lineno"> 1045</span> </div>
<div class="line"><span class="lineno"> 1046</span>    extradim = prod(y.shape[1:])</div>
<div class="line"><span class="lineno"> 1047</span>    y_new = y.reshape(n, extradim)</div>
<div class="line"><span class="lineno"> 1048</span>    c = np.zeros((n + k - 1, extradim))</div>
<div class="line"><span class="lineno"> 1049</span> </div>
<div class="line"><span class="lineno"> 1050</span>    <span class="comment"># n &lt;= k case is solved with full matrix</span></div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">if</span> n &lt;= k:</div>
<div class="line"><span class="lineno"> 1052</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(extradim):</div>
<div class="line"><span class="lineno"> 1053</span>            c[:, i] = _make_interp_per_full_matr(x, y_new[:, i], t, k)</div>
<div class="line"><span class="lineno"> 1054</span>        c = np.ascontiguousarray(c.reshape((n + k - 1,) + y.shape[1:]))</div>
<div class="line"><span class="lineno"> 1055</span>        <span class="keywordflow">return</span> BSpline.construct_fast(t, c, k, extrapolate=<span class="stringliteral">&#39;periodic&#39;</span>, axis=axis)</div>
<div class="line"><span class="lineno"> 1056</span> </div>
<div class="line"><span class="lineno"> 1057</span>    nt = len(t) - k - 1</div>
<div class="line"><span class="lineno"> 1058</span> </div>
<div class="line"><span class="lineno"> 1059</span>    <span class="comment"># size of block elements</span></div>
<div class="line"><span class="lineno"> 1060</span>    kul = int(k / 2)</div>
<div class="line"><span class="lineno"> 1061</span>    </div>
<div class="line"><span class="lineno"> 1062</span>    <span class="comment"># kl = ku = k</span></div>
<div class="line"><span class="lineno"> 1063</span>    ab = np.zeros((3 * k + 1, nt), dtype=np.float_, order=<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno"> 1064</span> </div>
<div class="line"><span class="lineno"> 1065</span>    <span class="comment"># upper right and lower left blocks</span></div>
<div class="line"><span class="lineno"> 1066</span>    ur = np.zeros((kul, kul))</div>
<div class="line"><span class="lineno"> 1067</span>    ll = np.zeros_like(ur)</div>
<div class="line"><span class="lineno"> 1068</span>    </div>
<div class="line"><span class="lineno"> 1069</span>    <span class="comment"># `offset` is made to shift all the non-zero elements to the end of the</span></div>
<div class="line"><span class="lineno"> 1070</span>    <span class="comment"># matrix</span></div>
<div class="line"><span class="lineno"> 1071</span>    _bspl._colloc(x, t, k, ab, offset=k)</div>
<div class="line"><span class="lineno"> 1072</span>    </div>
<div class="line"><span class="lineno"> 1073</span>    <span class="comment"># remove zeros before the matrix</span></div>
<div class="line"><span class="lineno"> 1074</span>    ab = ab[-k - (k + 1) % 2:, :]</div>
<div class="line"><span class="lineno"> 1075</span>    </div>
<div class="line"><span class="lineno"> 1076</span>    <span class="comment"># The least elements in rows (except repetitions) are diagonals</span></div>
<div class="line"><span class="lineno"> 1077</span>    <span class="comment"># of block matrices. Upper right matrix is an upper triangular</span></div>
<div class="line"><span class="lineno"> 1078</span>    <span class="comment"># matrix while lower left is a lower triangular one.</span></div>
<div class="line"><span class="lineno"> 1079</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(kul):</div>
<div class="line"><span class="lineno"> 1080</span>        ur += np.diag(ab[-i - 1, i: kul], k=i)</div>
<div class="line"><span class="lineno"> 1081</span>        ll += np.diag(ab[i, -kul - (k % 2): n - 1 + 2 * kul - i], k=-i)</div>
<div class="line"><span class="lineno"> 1082</span> </div>
<div class="line"><span class="lineno"> 1083</span>    <span class="comment"># remove elements that occur in the last point</span></div>
<div class="line"><span class="lineno"> 1084</span>    <span class="comment"># (first and last points are equivalent)</span></div>
<div class="line"><span class="lineno"> 1085</span>    A = ab[:, kul: -k + kul]</div>
<div class="line"><span class="lineno"> 1086</span> </div>
<div class="line"><span class="lineno"> 1087</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(extradim):</div>
<div class="line"><span class="lineno"> 1088</span>        cc = _woodbury_algorithm(A, ur, ll, y_new[:, i][:-1], k)</div>
<div class="line"><span class="lineno"> 1089</span>        c[:, i] = np.concatenate((cc[-kul:], cc, cc[:kul + k % 2]))</div>
<div class="line"><span class="lineno"> 1090</span>    c = np.ascontiguousarray(c.reshape((n + k - 1,) + y.shape[1:]))</div>
<div class="line"><span class="lineno"> 1091</span>    <span class="keywordflow">return</span> BSpline.construct_fast(t, c, k, extrapolate=<span class="stringliteral">&#39;periodic&#39;</span>, axis=axis)</div>
<div class="line"><span class="lineno"> 1092</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b2cef211b422bf7cb0a21b9b6bfa0ad" name="a3b2cef211b422bf7cb0a21b9b6bfa0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2cef211b422bf7cb0a21b9b6bfa0ad">&#9670;&#160;</a></span>_not_a_knot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._not_a_knot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Given data x, construct the knot vector w/ not-a-knot BC.
cf de Boor, XIII(12).</pre> <div class="fragment"><div class="line"><span class="lineno">  797</span><span class="keyword">def </span>_not_a_knot(x, k):</div>
<div class="line"><span class="lineno">  798</span>    <span class="stringliteral">&quot;&quot;&quot;Given data x, construct the knot vector w/ not-a-knot BC.</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    cf de Boor, XIII(12).&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  800</span>    x = np.asarray(x)</div>
<div class="line"><span class="lineno">  801</span>    <span class="keywordflow">if</span> k % 2 != 1:</div>
<div class="line"><span class="lineno">  802</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Odd degree for now only. Got %s.&quot;</span> % k)</div>
<div class="line"><span class="lineno">  803</span> </div>
<div class="line"><span class="lineno">  804</span>    m = (k - 1) // 2</div>
<div class="line"><span class="lineno">  805</span>    t = x[m+1:-m-1]</div>
<div class="line"><span class="lineno">  806</span>    t = np.r_[(x[0],)*(k+1), t, (x[-1],)*(k+1)]</div>
<div class="line"><span class="lineno">  807</span>    <span class="keywordflow">return</span> t</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4ec44936026d4ec7a34f6d40246e0b3" name="ac4ec44936026d4ec7a34f6d40246e0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ec44936026d4ec7a34f6d40246e0b3">&#9670;&#160;</a></span>_periodic_knots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._periodic_knots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">returns vector of nodes on circle
</pre> <div class="fragment"><div class="line"><span class="lineno">  923</span><span class="keyword">def </span>_periodic_knots(x, k):</div>
<div class="line"><span class="lineno">  924</span>    <span class="stringliteral">&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    returns vector of nodes on circle</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  927</span>    xc = np.copy(x)</div>
<div class="line"><span class="lineno">  928</span>    n = len(xc)</div>
<div class="line"><span class="lineno">  929</span>    <span class="keywordflow">if</span> k % 2 == 0:</div>
<div class="line"><span class="lineno">  930</span>        dx = np.diff(xc)</div>
<div class="line"><span class="lineno">  931</span>        xc[1: -1] -= dx[:-1] / 2 </div>
<div class="line"><span class="lineno">  932</span>    dx = np.diff(xc)</div>
<div class="line"><span class="lineno">  933</span>    t = np.zeros(n + 2 * k)</div>
<div class="line"><span class="lineno">  934</span>    t[k: -k] = xc</div>
<div class="line"><span class="lineno">  935</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, k):</div>
<div class="line"><span class="lineno">  936</span>        <span class="comment"># filling first `k` elements in descending order</span></div>
<div class="line"><span class="lineno">  937</span>        t[k - i - 1] = t[k - i] - dx[-(i % (n - 1)) - 1]</div>
<div class="line"><span class="lineno">  938</span>        <span class="comment"># filling last `k` elements in ascending order</span></div>
<div class="line"><span class="lineno">  939</span>        t[-k + i] = t[-k + i - 1] + dx[i % (n - 1)]</div>
<div class="line"><span class="lineno">  940</span>    <span class="keywordflow">return</span> t</div>
<div class="line"><span class="lineno">  941</span> </div>
<div class="line"><span class="lineno">  942</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1b1dd8dd949ff5e64b32bdac71a07d8" name="aa1b1dd8dd949ff5e64b32bdac71a07d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b1dd8dd949ff5e64b32bdac71a07d8">&#9670;&#160;</a></span>_process_deriv_spec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._process_deriv_spec </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deriv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  826</span><span class="keyword">def </span>_process_deriv_spec(deriv):</div>
<div class="line"><span class="lineno">  827</span>    <span class="keywordflow">if</span> deriv <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  828</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  829</span>            ords, vals = zip(*deriv)</div>
<div class="line"><span class="lineno">  830</span>        <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  831</span>            msg = (<span class="stringliteral">&quot;Derivatives, `bc_type`, should be specified as a pair of &quot;</span></div>
<div class="line"><span class="lineno">  832</span>                   <span class="stringliteral">&quot;iterables of pairs of (order, value).&quot;</span>)</div>
<div class="line"><span class="lineno">  833</span>            <span class="keywordflow">raise</span> ValueError(msg) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  834</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  835</span>        ords, vals = [], []</div>
<div class="line"><span class="lineno">  836</span>    <span class="keywordflow">return</span> np.atleast_1d(ords, vals)</div>
<div class="line"><span class="lineno">  837</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f44f2b8ccda26c4ae46a52495cd49b9" name="a4f44f2b8ccda26c4ae46a52495cd49b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f44f2b8ccda26c4ae46a52495cd49b9">&#9670;&#160;</a></span>_woodbury_algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines._woodbury_algorithm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Solve a cyclic banded linear system with upper right
and lower blocks of size ``(k-1) / 2`` using
the Woodbury formula

Parameters
----------
A : 2-D array, shape(k, n)
    Matrix of diagonals of original matrix(see 
    ``solve_banded`` documentation).
ur : 2-D array, shape(bs, bs)
    Upper right block matrix.
ll : 2-D array, shape(bs, bs)
    Lower left block matrix.
b : 1-D array, shape(n,)
    Vector of constant terms of the system of linear equations.
k : int
    B-spline degree.
    
Returns
-------
c : 1-D array, shape(n,)
    Solution of the original system of linear equations.
    
Notes
-----
This algorithm works only for systems with banded matrix A plus
a correction term U @ V.T, where the matrix U @ V.T gives upper right
and lower left block of A
The system is solved with the following steps:
    1.  New systems of linear equations are constructed:
        A @ z_i = u_i,
        u_i - columnn vector of U,
        i = 1, ..., k - 1
    2.  Matrix Z is formed from vectors z_i:
        Z = [ z_1 | z_2 | ... | z_{k - 1} ]
    3.  Matrix H = (1 + V.T @ Z)^{-1}
    4.  The system A' @ y = b is solved
    5.  x = y - Z @ (H @ V.T @ y)
Also, ``n`` should be greater than ``k``, otherwise corner block
elements will intersect with diagonals.

Examples
--------
Consider the case of n = 8, k = 5 (size of blocks - 2 x 2).
The matrix of a system:       U:          V:
  x  x  x  *  *  a  b         a b 0 0     0 0 1 0
  x  x  x  x  *  *  c         0 c 0 0     0 0 0 1
  x  x  x  x  x  *  *         0 0 0 0     0 0 0 0
  *  x  x  x  x  x  *         0 0 0 0     0 0 0 0
  *  *  x  x  x  x  x         0 0 0 0     0 0 0 0
  d  *  *  x  x  x  x         0 0 d 0     1 0 0 0
  e  f  *  *  x  x  x         0 0 e f     0 1 0 0

References
----------
.. [1] William H. Press, Saul A. Teukolsky, William T. Vetterling
       and Brian P. Flannery, Numerical Recipes, 2007, Section 2.7.3</pre> <div class="fragment"><div class="line"><span class="lineno">  838</span><span class="keyword">def </span>_woodbury_algorithm(A, ur, ll, b, k):</div>
<div class="line"><span class="lineno">  839</span>    <span class="stringliteral">&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    Solve a cyclic banded linear system with upper right</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral">    and lower blocks of size ``(k-1) / 2`` using</span></div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    the Woodbury formula</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">    </span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">    A : 2-D array, shape(k, n)</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">        Matrix of diagonals of original matrix(see </span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">        ``solve_banded`` documentation).</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">    ur : 2-D array, shape(bs, bs)</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">        Upper right block matrix.</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    ll : 2-D array, shape(bs, bs)</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">        Lower left block matrix.</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">    b : 1-D array, shape(n,)</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">        Vector of constant terms of the system of linear equations.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    k : int</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">        B-spline degree.</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">        </span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    c : 1-D array, shape(n,)</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">        Solution of the original system of linear equations.</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">        </span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    This algorithm works only for systems with banded matrix A plus</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    a correction term U @ V.T, where the matrix U @ V.T gives upper right</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    and lower left block of A</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    The system is solved with the following steps:</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">        1.  New systems of linear equations are constructed:</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">            A @ z_i = u_i,</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">            u_i - columnn vector of U,</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">            i = 1, ..., k - 1</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">        2.  Matrix Z is formed from vectors z_i:</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">            Z = [ z_1 | z_2 | ... | z_{k - 1} ]</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        3.  Matrix H = (1 + V.T @ Z)^{-1}</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">        4.  The system A&#39; @ y = b is solved</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">        5.  x = y - Z @ (H @ V.T @ y)</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    Also, ``n`` should be greater than ``k``, otherwise corner block</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    elements will intersect with diagonals.</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    Consider the case of n = 8, k = 5 (size of blocks - 2 x 2).</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    The matrix of a system:       U:          V:</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">      x  x  x  *  *  a  b         a b 0 0     0 0 1 0</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">      x  x  x  x  *  *  c         0 c 0 0     0 0 0 1</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">      x  x  x  x  x  *  *         0 0 0 0     0 0 0 0</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">      *  x  x  x  x  x  *         0 0 0 0     0 0 0 0</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">      *  *  x  x  x  x  x         0 0 0 0     0 0 0 0</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">      d  *  *  x  x  x  x         0 0 d 0     1 0 0 0</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">      e  f  *  *  x  x  x         0 0 e f     0 1 0 0</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    .. [1] William H. Press, Saul A. Teukolsky, William T. Vetterling</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">           and Brian P. Flannery, Numerical Recipes, 2007, Section 2.7.3</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  899</span>    k_mod = k - k % 2</div>
<div class="line"><span class="lineno">  900</span>    bs = int((k - 1) / 2) + (k + 1) % 2</div>
<div class="line"><span class="lineno">  901</span> </div>
<div class="line"><span class="lineno">  902</span>    n = A.shape[1] + 1</div>
<div class="line"><span class="lineno">  903</span>    U = np.zeros((n - 1, k_mod))</div>
<div class="line"><span class="lineno">  904</span>    VT = np.zeros((k_mod, n - 1))  <span class="comment"># V transpose</span></div>
<div class="line"><span class="lineno">  905</span> </div>
<div class="line"><span class="lineno">  906</span>    <span class="comment"># upper right block </span></div>
<div class="line"><span class="lineno">  907</span>    U[:bs, :bs] = ur</div>
<div class="line"><span class="lineno">  908</span>    VT[np.arange(bs), np.arange(bs) - bs] = 1</div>
<div class="line"><span class="lineno">  909</span> </div>
<div class="line"><span class="lineno">  910</span>    <span class="comment"># lower left block </span></div>
<div class="line"><span class="lineno">  911</span>    U[-bs:, -bs:] = ll</div>
<div class="line"><span class="lineno">  912</span>    VT[np.arange(bs) - bs, np.arange(bs)] = 1</div>
<div class="line"><span class="lineno">  913</span>    </div>
<div class="line"><span class="lineno">  914</span>    Z = solve_banded((bs, bs), A, U)</div>
<div class="line"><span class="lineno">  915</span> </div>
<div class="line"><span class="lineno">  916</span>    H = solve(np.identity(k_mod) + VT @ Z, np.identity(k_mod))</div>
<div class="line"><span class="lineno">  917</span> </div>
<div class="line"><span class="lineno">  918</span>    y = solve_banded((bs, bs), A, b)</div>
<div class="line"><span class="lineno">  919</span>    c = y - Z @ (H @ (VT @ y))</div>
<div class="line"><span class="lineno">  920</span> </div>
<div class="line"><span class="lineno">  921</span>    <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno">  922</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a301d5b15ab29ed96dd4caed6f3f83be6" name="a301d5b15ab29ed96dd4caed6f3f83be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301d5b15ab29ed96dd4caed6f3f83be6">&#9670;&#160;</a></span>make_interp_spline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines.make_interp_spline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bc_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (coefficients of) interpolating B-spline.

Parameters
----------
x : array_like, shape (n,)
    Abscissas.
y : array_like, shape (n, ...)
    Ordinates.
k : int, optional
    B-spline degree. Default is cubic, k=3.
t : array_like, shape (nt + k + 1,), optional.
    Knots.
    The number of knots needs to agree with the number of datapoints and
    the number of derivatives at the edges. Specifically, ``nt - n`` must
    equal ``len(deriv_l) + len(deriv_r)``.
bc_type : 2-tuple or None
    Boundary conditions.
    Default is None, which means choosing the boundary conditions
    automatically. Otherwise, it must be a length-two tuple where the first
    element sets the boundary conditions at ``x[0]`` and the second
    element sets the boundary conditions at ``x[-1]``. Each of these must
    be an iterable of pairs ``(order, value)`` which gives the values of
    derivatives of specified orders at the given edge of the interpolation
    interval.
    Alternatively, the following string aliases are recognized:

    * ``"clamped"``: The first derivatives at the ends are zero. This is
       equivalent to ``bc_type=([(1, 0.0)], [(1, 0.0)])``.
    * ``"natural"``: The second derivatives at ends are zero. This is
      equivalent to ``bc_type=([(2, 0.0)], [(2, 0.0)])``.
    * ``"not-a-knot"`` (default): The first and second segments are the
      same polynomial. This is equivalent to having ``bc_type=None``.
    * ``"periodic"``: The values and the first ``k-1`` derivatives at the
      ends are equivalent.

axis : int, optional
    Interpolation axis. Default is 0.
check_finite : bool, optional
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.

Returns
-------
b : a BSpline object of the degree ``k`` and with knots ``t``.

Examples
--------

Use cubic interpolation on Chebyshev nodes:

&gt;&gt;&gt; def cheb_nodes(N):
...     jj = 2.*np.arange(N) + 1
...     x = np.cos(np.pi * jj / 2 / N)[::-1]
...     return x

&gt;&gt;&gt; x = cheb_nodes(20)
&gt;&gt;&gt; y = np.sqrt(1 - x**2)

&gt;&gt;&gt; from scipy.interpolate import BSpline, make_interp_spline
&gt;&gt;&gt; b = make_interp_spline(x, y)
&gt;&gt;&gt; np.allclose(b(x), y)
True

Note that the default is a cubic spline with a not-a-knot boundary condition

&gt;&gt;&gt; b.k
3

Here we use a 'natural' spline, with zero 2nd derivatives at edges:

&gt;&gt;&gt; l, r = [(2, 0.0)], [(2, 0.0)]
&gt;&gt;&gt; b_n = make_interp_spline(x, y, bc_type=(l, r))  # or, bc_type="natural"
&gt;&gt;&gt; np.allclose(b_n(x), y)
True
&gt;&gt;&gt; x0, x1 = x[0], x[-1]
&gt;&gt;&gt; np.allclose([b_n(x0, 2), b_n(x1, 2)], [0, 0])
True

Interpolation of parametric curves is also supported. As an example, we
compute a discretization of a snail curve in polar coordinates

&gt;&gt;&gt; phi = np.linspace(0, 2.*np.pi, 40)
&gt;&gt;&gt; r = 0.3 + np.cos(phi)
&gt;&gt;&gt; x, y = r*np.cos(phi), r*np.sin(phi)  # convert to Cartesian coordinates

Build an interpolating curve, parameterizing it by the angle

&gt;&gt;&gt; from scipy.interpolate import make_interp_spline
&gt;&gt;&gt; spl = make_interp_spline(phi, np.c_[x, y])

Evaluate the interpolant on a finer grid (note that we transpose the result
to unpack it into a pair of x- and y-arrays)

&gt;&gt;&gt; phi_new = np.linspace(0, 2.*np.pi, 100)
&gt;&gt;&gt; x_new, y_new = spl(phi_new).T

Plot the result

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x, y, 'o')
&gt;&gt;&gt; plt.plot(x_new, y_new, '-')
&gt;&gt;&gt; plt.show()

Build a B-spline curve with 2 dimensional y

&gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)
&gt;&gt;&gt; y = np.array([np.sin(x), np.cos(x)])

Periodic condition is satisfied because y coordinates of points on the ends
are equivalent

&gt;&gt;&gt; ax = plt.axes(projection='3d')
&gt;&gt;&gt; xx = np.linspace(0, 2*np.pi, 100)
&gt;&gt;&gt; bspl = make_interp_spline(x, y, k=5, bc_type='periodic', axis=1)
&gt;&gt;&gt; ax.plot3D(xx, *bspl(xx))
&gt;&gt;&gt; ax.scatter3D(x, *y, color='red')
&gt;&gt;&gt; plt.show()

See Also
--------
BSpline : base class representing the B-spline objects
CubicSpline : a cubic spline in the polynomial basis
make_lsq_spline : a similar factory function for spline fitting
UnivariateSpline : a wrapper over FITPACK spline fitting routines
splrep : a wrapper over FITPACK spline fitting routines</pre> <div class="fragment"><div class="line"><span class="lineno"> 1094</span>                       check_finite=<span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 1095</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the (coefficients of) interpolating B-spline.</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    x : array_like, shape (n,)</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">        Abscissas.</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    y : array_like, shape (n, ...)</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">        Ordinates.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    k : int, optional</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">        B-spline degree. Default is cubic, k=3.</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">    t : array_like, shape (nt + k + 1,), optional.</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">        Knots.</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">        The number of knots needs to agree with the number of datapoints and</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">        the number of derivatives at the edges. Specifically, ``nt - n`` must</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">        equal ``len(deriv_l) + len(deriv_r)``.</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    bc_type : 2-tuple or None</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">        Boundary conditions.</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">        Default is None, which means choosing the boundary conditions</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">        automatically. Otherwise, it must be a length-two tuple where the first</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">        element sets the boundary conditions at ``x[0]`` and the second</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">        element sets the boundary conditions at ``x[-1]``. Each of these must</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">        be an iterable of pairs ``(order, value)`` which gives the values of</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">        derivatives of specified orders at the given edge of the interpolation</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">        interval.</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">        Alternatively, the following string aliases are recognized:</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">        * ``&quot;clamped&quot;``: The first derivatives at the ends are zero. This is</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">           equivalent to ``bc_type=([(1, 0.0)], [(1, 0.0)])``.</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">        * ``&quot;natural&quot;``: The second derivatives at ends are zero. This is</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">          equivalent to ``bc_type=([(2, 0.0)], [(2, 0.0)])``.</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">        * ``&quot;not-a-knot&quot;`` (default): The first and second segments are the</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">          same polynomial. This is equivalent to having ``bc_type=None``.</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">        * ``&quot;periodic&quot;``: The values and the first ``k-1`` derivatives at the</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">          ends are equivalent.</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">        Interpolation axis. Default is 0.</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">        Whether to check that the input arrays contain only finite numbers.</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">        Default is True.</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    b : a BSpline object of the degree ``k`` and with knots ``t``.</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">    Use cubic interpolation on Chebyshev nodes:</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">    &gt;&gt;&gt; def cheb_nodes(N):</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    ...     jj = 2.*np.arange(N) + 1</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    ...     x = np.cos(np.pi * jj / 2 / N)[::-1]</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    ...     return x</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    &gt;&gt;&gt; x = cheb_nodes(20)</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    &gt;&gt;&gt; y = np.sqrt(1 - x**2)</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.interpolate import BSpline, make_interp_spline</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    &gt;&gt;&gt; b = make_interp_spline(x, y)</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(b(x), y)</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    Note that the default is a cubic spline with a not-a-knot boundary condition</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    &gt;&gt;&gt; b.k</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    3</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    Here we use a &#39;natural&#39; spline, with zero 2nd derivatives at edges:</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    &gt;&gt;&gt; l, r = [(2, 0.0)], [(2, 0.0)]</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    &gt;&gt;&gt; b_n = make_interp_spline(x, y, bc_type=(l, r))  # or, bc_type=&quot;natural&quot;</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose(b_n(x), y)</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    &gt;&gt;&gt; x0, x1 = x[0], x[-1]</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    &gt;&gt;&gt; np.allclose([b_n(x0, 2), b_n(x1, 2)], [0, 0])</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    Interpolation of parametric curves is also supported. As an example, we</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    compute a discretization of a snail curve in polar coordinates</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">    &gt;&gt;&gt; phi = np.linspace(0, 2.*np.pi, 40)</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    &gt;&gt;&gt; r = 0.3 + np.cos(phi)</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    &gt;&gt;&gt; x, y = r*np.cos(phi), r*np.sin(phi)  # convert to Cartesian coordinates</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    Build an interpolating curve, parameterizing it by the angle</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.interpolate import make_interp_spline</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    &gt;&gt;&gt; spl = make_interp_spline(phi, np.c_[x, y])</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    Evaluate the interpolant on a finer grid (note that we transpose the result</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    to unpack it into a pair of x- and y-arrays)</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    &gt;&gt;&gt; phi_new = np.linspace(0, 2.*np.pi, 100)</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    &gt;&gt;&gt; x_new, y_new = spl(phi_new).T</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    Plot the result</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;)</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x_new, y_new, &#39;-&#39;)</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    Build a B-spline curve with 2 dimensional y</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    </span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([np.sin(x), np.cos(x)])</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    Periodic condition is satisfied because y coordinates of points on the ends</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    are equivalent</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    &gt;&gt;&gt; ax = plt.axes(projection=&#39;3d&#39;)</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    &gt;&gt;&gt; xx = np.linspace(0, 2*np.pi, 100)</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    &gt;&gt;&gt; bspl = make_interp_spline(x, y, k=5, bc_type=&#39;periodic&#39;, axis=1)</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    &gt;&gt;&gt; ax.plot3D(xx, *bspl(xx))</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    &gt;&gt;&gt; ax.scatter3D(x, *y, color=&#39;red&#39;)</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    BSpline : base class representing the B-spline objects</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    CubicSpline : a cubic spline in the polynomial basis</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    make_lsq_spline : a similar factory function for spline fitting</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    UnivariateSpline : a wrapper over FITPACK spline fitting routines</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">    splrep : a wrapper over FITPACK spline fitting routines</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1224</span>    <span class="comment"># convert string aliases for the boundary conditions</span></div>
<div class="line"><span class="lineno"> 1225</span>    <span class="keywordflow">if</span> bc_type <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> bc_type == <span class="stringliteral">&#39;not-a-knot&#39;</span> <span class="keywordflow">or</span> bc_type == <span class="stringliteral">&#39;periodic&#39;</span>:</div>
<div class="line"><span class="lineno"> 1226</span>        deriv_l, deriv_r = <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1227</span>    <span class="keywordflow">elif</span> isinstance(bc_type, str):</div>
<div class="line"><span class="lineno"> 1228</span>        deriv_l, deriv_r = bc_type, bc_type</div>
<div class="line"><span class="lineno"> 1229</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1230</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1231</span>            deriv_l, deriv_r = bc_type</div>
<div class="line"><span class="lineno"> 1232</span>        <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 1233</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Unknown boundary condition: %s&quot;</span> % bc_type) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno"> 1234</span> </div>
<div class="line"><span class="lineno"> 1235</span>    y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 1236</span> </div>
<div class="line"><span class="lineno"> 1237</span>    axis = normalize_axis_index(axis, y.ndim)</div>
<div class="line"><span class="lineno"> 1238</span> </div>
<div class="line"><span class="lineno"> 1239</span>    x = _as_float_array(x, check_finite)</div>
<div class="line"><span class="lineno"> 1240</span>    y = _as_float_array(y, check_finite)</div>
<div class="line"><span class="lineno"> 1241</span> </div>
<div class="line"><span class="lineno"> 1242</span>    y = np.moveaxis(y, axis, 0)    <span class="comment"># now internally interp axis is zero</span></div>
<div class="line"><span class="lineno"> 1243</span> </div>
<div class="line"><span class="lineno"> 1244</span>    <span class="comment"># sanity check the input</span></div>
<div class="line"><span class="lineno"> 1245</span>    <span class="keywordflow">if</span> bc_type == <span class="stringliteral">&#39;periodic&#39;</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.allclose(y[0], y[-1], atol=1e-15):</div>
<div class="line"><span class="lineno"> 1246</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;First and last points does not match while &quot;</span></div>
<div class="line"><span class="lineno"> 1247</span>                         <span class="stringliteral">&quot;periodic case expected&quot;</span>)</div>
<div class="line"><span class="lineno"> 1248</span>    <span class="keywordflow">if</span> x.size != y.shape[0]:</div>
<div class="line"><span class="lineno"> 1249</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Shapes of x {} and y {} are incompatible&#39;</span></div>
<div class="line"><span class="lineno"> 1250</span>                         .format(x.shape, y.shape))</div>
<div class="line"><span class="lineno"> 1251</span>    <span class="keywordflow">if</span> np.any(x[1:] == x[:-1]):</div>
<div class="line"><span class="lineno"> 1252</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expect x to not have duplicates&quot;</span>)</div>
<div class="line"><span class="lineno"> 1253</span>    <span class="keywordflow">if</span> x.ndim != 1 <span class="keywordflow">or</span> np.any(x[1:] &lt; x[:-1]):</div>
<div class="line"><span class="lineno"> 1254</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expect x to be a 1D strictly increasing sequence.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1255</span> </div>
<div class="line"><span class="lineno"> 1256</span>    <span class="comment"># special-case k=0 right away</span></div>
<div class="line"><span class="lineno"> 1257</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno"> 1258</span>        <span class="keywordflow">if</span> any(_ <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> (t, deriv_l, deriv_r)):</div>
<div class="line"><span class="lineno"> 1259</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Too much info for k=0: t and bc_type can only &quot;</span></div>
<div class="line"><span class="lineno"> 1260</span>                             <span class="stringliteral">&quot;be None.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1261</span>        t = np.r_[x, x[-1]]</div>
<div class="line"><span class="lineno"> 1262</span>        c = np.asarray(y)</div>
<div class="line"><span class="lineno"> 1263</span>        c = np.ascontiguousarray(c, dtype=_get_dtype(c.dtype))</div>
<div class="line"><span class="lineno"> 1264</span>        <span class="keywordflow">return</span> BSpline.construct_fast(t, c, k, axis=axis)</div>
<div class="line"><span class="lineno"> 1265</span> </div>
<div class="line"><span class="lineno"> 1266</span>    <span class="comment"># special-case k=1 (e.g., Lyche and Morken, Eq.(2.16))</span></div>
<div class="line"><span class="lineno"> 1267</span>    <span class="keywordflow">if</span> k == 1 <span class="keywordflow">and</span> t <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1268</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (deriv_l <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> deriv_r <span class="keywordflow">is</span> <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1269</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Too much info for k=1: bc_type can only be None.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1270</span>        t = np.r_[x[0], x, x[-1]]</div>
<div class="line"><span class="lineno"> 1271</span>        c = np.asarray(y)</div>
<div class="line"><span class="lineno"> 1272</span>        c = np.ascontiguousarray(c, dtype=_get_dtype(c.dtype))</div>
<div class="line"><span class="lineno"> 1273</span>        <span class="keywordflow">return</span> BSpline.construct_fast(t, c, k, axis=axis)</div>
<div class="line"><span class="lineno"> 1274</span> </div>
<div class="line"><span class="lineno"> 1275</span>    k = operator.index(k)</div>
<div class="line"><span class="lineno"> 1276</span> </div>
<div class="line"><span class="lineno"> 1277</span>    <span class="keywordflow">if</span> bc_type == <span class="stringliteral">&#39;periodic&#39;</span> <span class="keywordflow">and</span> t <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1278</span>        <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;For periodic case t is constructed &quot;</span></div>
<div class="line"><span class="lineno"> 1279</span>                         <span class="stringliteral">&quot;automatically and can not be passed manually&quot;</span>)</div>
<div class="line"><span class="lineno"> 1280</span> </div>
<div class="line"><span class="lineno"> 1281</span>    <span class="comment"># come up with a sensible knot vector, if needed</span></div>
<div class="line"><span class="lineno"> 1282</span>    <span class="keywordflow">if</span> t <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1283</span>        <span class="keywordflow">if</span> deriv_l <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> deriv_r <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1284</span>            <span class="keywordflow">if</span> bc_type == <span class="stringliteral">&#39;periodic&#39;</span>:</div>
<div class="line"><span class="lineno"> 1285</span>                t = _periodic_knots(x, k)</div>
<div class="line"><span class="lineno"> 1286</span>            <span class="keywordflow">elif</span> k == 2:</div>
<div class="line"><span class="lineno"> 1287</span>                <span class="comment"># OK, it&#39;s a bit ad hoc: Greville sites + omit</span></div>
<div class="line"><span class="lineno"> 1288</span>                <span class="comment"># 2nd and 2nd-to-last points, a la not-a-knot</span></div>
<div class="line"><span class="lineno"> 1289</span>                t = (x[1:] + x[:-1]) / 2.</div>
<div class="line"><span class="lineno"> 1290</span>                t = np.r_[(x[0],)*(k+1),</div>
<div class="line"><span class="lineno"> 1291</span>                           t[1:-1],</div>
<div class="line"><span class="lineno"> 1292</span>                           (x[-1],)*(k+1)]</div>
<div class="line"><span class="lineno"> 1293</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1294</span>                t = _not_a_knot(x, k)</div>
<div class="line"><span class="lineno"> 1295</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1296</span>            t = _augknt(x, k)</div>
<div class="line"><span class="lineno"> 1297</span> </div>
<div class="line"><span class="lineno"> 1298</span>    t = _as_float_array(t, check_finite)</div>
<div class="line"><span class="lineno"> 1299</span> </div>
<div class="line"><span class="lineno"> 1300</span>    <span class="keywordflow">if</span> k &lt; 0:</div>
<div class="line"><span class="lineno"> 1301</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expect non-negative k.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1302</span>    <span class="keywordflow">if</span> t.ndim != 1 <span class="keywordflow">or</span> np.any(t[1:] &lt; t[:-1]):</div>
<div class="line"><span class="lineno"> 1303</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expect t to be a 1-D sorted array_like.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1304</span>    <span class="keywordflow">if</span> t.size &lt; x.size + k + 1:</div>
<div class="line"><span class="lineno"> 1305</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Got %d knots, need at least %d.&#39;</span> %</div>
<div class="line"><span class="lineno"> 1306</span>                         (t.size, x.size + k + 1))</div>
<div class="line"><span class="lineno"> 1307</span>    <span class="keywordflow">if</span> (x[0] &lt; t[k]) <span class="keywordflow">or</span> (x[-1] &gt; t[-k]):</div>
<div class="line"><span class="lineno"> 1308</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Out of bounds w/ x = %s.&#39;</span> % x)</div>
<div class="line"><span class="lineno"> 1309</span> </div>
<div class="line"><span class="lineno"> 1310</span>    <span class="keywordflow">if</span> bc_type == <span class="stringliteral">&#39;periodic&#39;</span>:</div>
<div class="line"><span class="lineno"> 1311</span>        <span class="keywordflow">return</span> _make_periodic_spline(x, y, t, k, axis)</div>
<div class="line"><span class="lineno"> 1312</span> </div>
<div class="line"><span class="lineno"> 1313</span>    <span class="comment"># Here : deriv_l, r = [(nu, value), ...]</span></div>
<div class="line"><span class="lineno"> 1314</span>    deriv_l = _convert_string_aliases(deriv_l, y.shape[1:])</div>
<div class="line"><span class="lineno"> 1315</span>    deriv_l_ords, deriv_l_vals = _process_deriv_spec(deriv_l)</div>
<div class="line"><span class="lineno"> 1316</span>    nleft = deriv_l_ords.shape[0]</div>
<div class="line"><span class="lineno"> 1317</span> </div>
<div class="line"><span class="lineno"> 1318</span>    deriv_r = _convert_string_aliases(deriv_r, y.shape[1:])</div>
<div class="line"><span class="lineno"> 1319</span>    deriv_r_ords, deriv_r_vals = _process_deriv_spec(deriv_r)</div>
<div class="line"><span class="lineno"> 1320</span>    nright = deriv_r_ords.shape[0]</div>
<div class="line"><span class="lineno"> 1321</span> </div>
<div class="line"><span class="lineno"> 1322</span>    <span class="comment"># have `n` conditions for `nt` coefficients; need nt-n derivatives</span></div>
<div class="line"><span class="lineno"> 1323</span>    n = x.size</div>
<div class="line"><span class="lineno"> 1324</span>    nt = t.size - k - 1</div>
<div class="line"><span class="lineno"> 1325</span> </div>
<div class="line"><span class="lineno"> 1326</span>    <span class="keywordflow">if</span> nt - n != nleft + nright:</div>
<div class="line"><span class="lineno"> 1327</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The number of derivatives at boundaries does not &quot;</span></div>
<div class="line"><span class="lineno"> 1328</span>                         <span class="stringliteral">&quot;match: expected %s, got %s+%s&quot;</span> % (nt-n, nleft, nright))</div>
<div class="line"><span class="lineno"> 1329</span> </div>
<div class="line"><span class="lineno"> 1330</span>    <span class="comment"># set up the LHS: the collocation matrix + derivatives at boundaries</span></div>
<div class="line"><span class="lineno"> 1331</span>    kl = ku = k</div>
<div class="line"><span class="lineno"> 1332</span>    ab = np.zeros((2*kl + ku + 1, nt), dtype=np.float_, order=<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno"> 1333</span>    _bspl._colloc(x, t, k, ab, offset=nleft)</div>
<div class="line"><span class="lineno"> 1334</span>    <span class="keywordflow">if</span> nleft &gt; 0:</div>
<div class="line"><span class="lineno"> 1335</span>        _bspl._handle_lhs_derivatives(t, k, x[0], ab, kl, ku, deriv_l_ords)</div>
<div class="line"><span class="lineno"> 1336</span>    <span class="keywordflow">if</span> nright &gt; 0:</div>
<div class="line"><span class="lineno"> 1337</span>        _bspl._handle_lhs_derivatives(t, k, x[-1], ab, kl, ku, deriv_r_ords,</div>
<div class="line"><span class="lineno"> 1338</span>                                offset=nt-nright)</div>
<div class="line"><span class="lineno"> 1339</span> </div>
<div class="line"><span class="lineno"> 1340</span>    <span class="comment"># set up the RHS: values to interpolate (+ derivative values, if any)</span></div>
<div class="line"><span class="lineno"> 1341</span>    extradim = prod(y.shape[1:])</div>
<div class="line"><span class="lineno"> 1342</span>    rhs = np.empty((nt, extradim), dtype=y.dtype)</div>
<div class="line"><span class="lineno"> 1343</span>    <span class="keywordflow">if</span> nleft &gt; 0:</div>
<div class="line"><span class="lineno"> 1344</span>        rhs[:nleft] = deriv_l_vals.reshape(-1, extradim)</div>
<div class="line"><span class="lineno"> 1345</span>    rhs[nleft:nt - nright] = y.reshape(-1, extradim)</div>
<div class="line"><span class="lineno"> 1346</span>    <span class="keywordflow">if</span> nright &gt; 0:</div>
<div class="line"><span class="lineno"> 1347</span>        rhs[nt - nright:] = deriv_r_vals.reshape(-1, extradim)</div>
<div class="line"><span class="lineno"> 1348</span> </div>
<div class="line"><span class="lineno"> 1349</span>    <span class="comment"># solve Ab @ x = rhs; this is the relevant part of linalg.solve_banded</span></div>
<div class="line"><span class="lineno"> 1350</span>    <span class="keywordflow">if</span> check_finite:</div>
<div class="line"><span class="lineno"> 1351</span>        ab, rhs = map(np.asarray_chkfinite, (ab, rhs))</div>
<div class="line"><span class="lineno"> 1352</span>    gbsv, = get_lapack_funcs((<span class="stringliteral">&#39;gbsv&#39;</span>,), (ab, rhs))</div>
<div class="line"><span class="lineno"> 1353</span>    lu, piv, c, info = gbsv(kl, ku, ab, rhs,</div>
<div class="line"><span class="lineno"> 1354</span>            overwrite_ab=<span class="keyword">True</span>, overwrite_b=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1355</span> </div>
<div class="line"><span class="lineno"> 1356</span>    <span class="keywordflow">if</span> info &gt; 0:</div>
<div class="line"><span class="lineno"> 1357</span>        <span class="keywordflow">raise</span> LinAlgError(<span class="stringliteral">&quot;Collocation matix is singular.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1358</span>    <span class="keywordflow">elif</span> info &lt; 0:</div>
<div class="line"><span class="lineno"> 1359</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;illegal value in %d-th argument of internal gbsv&#39;</span> % -info)</div>
<div class="line"><span class="lineno"> 1360</span> </div>
<div class="line"><span class="lineno"> 1361</span>    c = np.ascontiguousarray(c.reshape((nt,) + y.shape[1:]))</div>
<div class="line"><span class="lineno"> 1362</span>    <span class="keywordflow">return</span> BSpline.construct_fast(t, c, k, axis=axis)</div>
<div class="line"><span class="lineno"> 1363</span> </div>
<div class="line"><span class="lineno"> 1364</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa247d650f5cb3bd24ecd13a9d349cebe" name="aa247d650f5cb3bd24ecd13a9d349cebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa247d650f5cb3bd24ecd13a9d349cebe">&#9670;&#160;</a></span>make_lsq_spline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.interpolate._bsplines.make_lsq_spline </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>check_finite</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (coefficients of) an LSQ B-spline.

The result is a linear combination

.. math::

        S(x) = \sum_j c_j B_j(x; t)

of the B-spline basis elements, :math:`B_j(x; t)`, which minimizes

.. math::

    \sum_{j} \left( w_j \times (S(x_j) - y_j) \right)^2

Parameters
----------
x : array_like, shape (m,)
    Abscissas.
y : array_like, shape (m, ...)
    Ordinates.
t : array_like, shape (n + k + 1,).
    Knots.
    Knots and data points must satisfy Schoenberg-Whitney conditions.
k : int, optional
    B-spline degree. Default is cubic, k=3.
w : array_like, shape (n,), optional
    Weights for spline fitting. Must be positive. If ``None``,
    then weights are all equal.
    Default is ``None``.
axis : int, optional
    Interpolation axis. Default is zero.
check_finite : bool, optional
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.

Returns
-------
b : a BSpline object of the degree `k` with knots `t`.

Notes
-----
The number of data points must be larger than the spline degree `k`.

Knots `t` must satisfy the Schoenberg-Whitney conditions,
i.e., there must be a subset of data points ``x[j]`` such that
``t[j] &lt; x[j] &lt; t[j+k+1]``, for ``j=0, 1,...,n-k-2``.

Examples
--------
Generate some noisy data:

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = np.linspace(-3, 3, 50)
&gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)

Now fit a smoothing cubic spline with a pre-defined internal knots.
Here we make the knot vector (k+1)-regular by adding boundary knots:

&gt;&gt;&gt; from scipy.interpolate import make_lsq_spline, BSpline
&gt;&gt;&gt; t = [-1, 0, 1]
&gt;&gt;&gt; k = 3
&gt;&gt;&gt; t = np.r_[(x[0],)*(k+1),
...           t,
...           (x[-1],)*(k+1)]
&gt;&gt;&gt; spl = make_lsq_spline(x, y, t, k)

For comparison, we also construct an interpolating spline for the same
set of data:

&gt;&gt;&gt; from scipy.interpolate import make_interp_spline
&gt;&gt;&gt; spl_i = make_interp_spline(x, y)

Plot both:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; xs = np.linspace(-3, 3, 100)
&gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5)
&gt;&gt;&gt; plt.plot(xs, spl(xs), 'g-', lw=3, label='LSQ spline')
&gt;&gt;&gt; plt.plot(xs, spl_i(xs), 'b-', lw=3, alpha=0.7, label='interp spline')
&gt;&gt;&gt; plt.legend(loc='best')
&gt;&gt;&gt; plt.show()

**NaN handling**: If the input arrays contain ``nan`` values, the result is
not useful since the underlying spline fitting routines cannot deal with
``nan``. A workaround is to use zero weights for not-a-number data points:

&gt;&gt;&gt; y[8] = np.nan
&gt;&gt;&gt; w = np.isnan(y)
&gt;&gt;&gt; y[w] = 0.
&gt;&gt;&gt; tck = make_lsq_spline(x, y, t, w=~w)

Notice the need to replace a ``nan`` by a numerical value (precise value
does not matter as long as the corresponding weight is zero.)

See Also
--------
BSpline : base class representing the B-spline objects
make_interp_spline : a similar factory function for interpolating splines
LSQUnivariateSpline : a FITPACK-based spline fitting routine
splrep : a FITPACK-based fitting routine</pre> <div class="fragment"><div class="line"><span class="lineno"> 1365</span><span class="keyword">def </span>make_lsq_spline(x, y, t, k=3, w=None, axis=0, check_finite=True):</div>
<div class="line"><span class="lineno"> 1366</span>    <span class="stringliteral">r&quot;&quot;&quot;Compute the (coefficients of) an LSQ B-spline.</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">    The result is a linear combination</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">            S(x) = \sum_j c_j B_j(x; t)</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    of the B-spline basis elements, :math:`B_j(x; t)`, which minimizes</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">        \sum_{j} \left( w_j \times (S(x_j) - y_j) \right)^2</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    x : array_like, shape (m,)</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">        Abscissas.</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">    y : array_like, shape (m, ...)</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">        Ordinates.</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    t : array_like, shape (n + k + 1,).</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">        Knots.</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">        Knots and data points must satisfy Schoenberg-Whitney conditions.</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    k : int, optional</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">        B-spline degree. Default is cubic, k=3.</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">    w : array_like, shape (n,), optional</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">        Weights for spline fitting. Must be positive. If ``None``,</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">        then weights are all equal.</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">        Default is ``None``.</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">        Interpolation axis. Default is zero.</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    check_finite : bool, optional</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">        Whether to check that the input arrays contain only finite numbers.</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral">        Disabling may give a performance gain, but may result in problems</span></div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">        Default is True.</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1405</span><span class="stringliteral">    b : a BSpline object of the degree `k` with knots `t`.</span></div>
<div class="line"><span class="lineno"> 1406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1407</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">    The number of data points must be larger than the spline degree `k`.</span></div>
<div class="line"><span class="lineno"> 1410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1411</span><span class="stringliteral">    Knots `t` must satisfy the Schoenberg-Whitney conditions,</span></div>
<div class="line"><span class="lineno"> 1412</span><span class="stringliteral">    i.e., there must be a subset of data points ``x[j]`` such that</span></div>
<div class="line"><span class="lineno"> 1413</span><span class="stringliteral">    ``t[j] &lt; x[j] &lt; t[j+k+1]``, for ``j=0, 1,...,n-k-2``.</span></div>
<div class="line"><span class="lineno"> 1414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1415</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1416</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1417</span><span class="stringliteral">    Generate some noisy data:</span></div>
<div class="line"><span class="lineno"> 1418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1419</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1420</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(-3, 3, 50)</span></div>
<div class="line"><span class="lineno"> 1421</span><span class="stringliteral">    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)</span></div>
<div class="line"><span class="lineno"> 1422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1423</span><span class="stringliteral">    Now fit a smoothing cubic spline with a pre-defined internal knots.</span></div>
<div class="line"><span class="lineno"> 1424</span><span class="stringliteral">    Here we make the knot vector (k+1)-regular by adding boundary knots:</span></div>
<div class="line"><span class="lineno"> 1425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1426</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.interpolate import make_lsq_spline, BSpline</span></div>
<div class="line"><span class="lineno"> 1427</span><span class="stringliteral">    &gt;&gt;&gt; t = [-1, 0, 1]</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">    &gt;&gt;&gt; k = 3</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">    &gt;&gt;&gt; t = np.r_[(x[0],)*(k+1),</span></div>
<div class="line"><span class="lineno"> 1430</span><span class="stringliteral">    ...           t,</span></div>
<div class="line"><span class="lineno"> 1431</span><span class="stringliteral">    ...           (x[-1],)*(k+1)]</span></div>
<div class="line"><span class="lineno"> 1432</span><span class="stringliteral">    &gt;&gt;&gt; spl = make_lsq_spline(x, y, t, k)</span></div>
<div class="line"><span class="lineno"> 1433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1434</span><span class="stringliteral">    For comparison, we also construct an interpolating spline for the same</span></div>
<div class="line"><span class="lineno"> 1435</span><span class="stringliteral">    set of data:</span></div>
<div class="line"><span class="lineno"> 1436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1437</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.interpolate import make_interp_spline</span></div>
<div class="line"><span class="lineno"> 1438</span><span class="stringliteral">    &gt;&gt;&gt; spl_i = make_interp_spline(x, y)</span></div>
<div class="line"><span class="lineno"> 1439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1440</span><span class="stringliteral">    Plot both:</span></div>
<div class="line"><span class="lineno"> 1441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1442</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1443</span><span class="stringliteral">    &gt;&gt;&gt; xs = np.linspace(-3, 3, 100)</span></div>
<div class="line"><span class="lineno"> 1444</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, y, &#39;ro&#39;, ms=5)</span></div>
<div class="line"><span class="lineno"> 1445</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(xs, spl(xs), &#39;g-&#39;, lw=3, label=&#39;LSQ spline&#39;)</span></div>
<div class="line"><span class="lineno"> 1446</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(xs, spl_i(xs), &#39;b-&#39;, lw=3, alpha=0.7, label=&#39;interp spline&#39;)</span></div>
<div class="line"><span class="lineno"> 1447</span><span class="stringliteral">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span></div>
<div class="line"><span class="lineno"> 1448</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1450</span><span class="stringliteral">    **NaN handling**: If the input arrays contain ``nan`` values, the result is</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">    not useful since the underlying spline fitting routines cannot deal with</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">    ``nan``. A workaround is to use zero weights for not-a-number data points:</span></div>
<div class="line"><span class="lineno"> 1453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1454</span><span class="stringliteral">    &gt;&gt;&gt; y[8] = np.nan</span></div>
<div class="line"><span class="lineno"> 1455</span><span class="stringliteral">    &gt;&gt;&gt; w = np.isnan(y)</span></div>
<div class="line"><span class="lineno"> 1456</span><span class="stringliteral">    &gt;&gt;&gt; y[w] = 0.</span></div>
<div class="line"><span class="lineno"> 1457</span><span class="stringliteral">    &gt;&gt;&gt; tck = make_lsq_spline(x, y, t, w=~w)</span></div>
<div class="line"><span class="lineno"> 1458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1459</span><span class="stringliteral">    Notice the need to replace a ``nan`` by a numerical value (precise value</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">    does not matter as long as the corresponding weight is zero.)</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral">    BSpline : base class representing the B-spline objects</span></div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">    make_interp_spline : a similar factory function for interpolating splines</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    LSQUnivariateSpline : a FITPACK-based spline fitting routine</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral">    splrep : a FITPACK-based fitting routine</span></div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1470</span>    x = _as_float_array(x, check_finite)</div>
<div class="line"><span class="lineno"> 1471</span>    y = _as_float_array(y, check_finite)</div>
<div class="line"><span class="lineno"> 1472</span>    t = _as_float_array(t, check_finite)</div>
<div class="line"><span class="lineno"> 1473</span>    <span class="keywordflow">if</span> w <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1474</span>        w = _as_float_array(w, check_finite)</div>
<div class="line"><span class="lineno"> 1475</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1476</span>        w = np.ones_like(x)</div>
<div class="line"><span class="lineno"> 1477</span>    k = operator.index(k)</div>
<div class="line"><span class="lineno"> 1478</span> </div>
<div class="line"><span class="lineno"> 1479</span>    axis = normalize_axis_index(axis, y.ndim)</div>
<div class="line"><span class="lineno"> 1480</span> </div>
<div class="line"><span class="lineno"> 1481</span>    y = np.moveaxis(y, axis, 0)    <span class="comment"># now internally interp axis is zero</span></div>
<div class="line"><span class="lineno"> 1482</span> </div>
<div class="line"><span class="lineno"> 1483</span>    <span class="keywordflow">if</span> x.ndim != 1 <span class="keywordflow">or</span> np.any(x[1:] - x[:-1] &lt;= 0):</div>
<div class="line"><span class="lineno"> 1484</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expect x to be a 1-D sorted array_like.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1485</span>    <span class="keywordflow">if</span> x.shape[0] &lt; k+1:</div>
<div class="line"><span class="lineno"> 1486</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Need more x points.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1487</span>    <span class="keywordflow">if</span> k &lt; 0:</div>
<div class="line"><span class="lineno"> 1488</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expect non-negative k.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1489</span>    <span class="keywordflow">if</span> t.ndim != 1 <span class="keywordflow">or</span> np.any(t[1:] - t[:-1] &lt; 0):</div>
<div class="line"><span class="lineno"> 1490</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Expect t to be a 1-D sorted array_like.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1491</span>    <span class="keywordflow">if</span> x.size != y.shape[0]:</div>
<div class="line"><span class="lineno"> 1492</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Shapes of x {} and y {} are incompatible&#39;</span></div>
<div class="line"><span class="lineno"> 1493</span>                         .format(x.shape, y.shape))</div>
<div class="line"><span class="lineno"> 1494</span>    <span class="keywordflow">if</span> k &gt; 0 <span class="keywordflow">and</span> np.any((x &lt; t[k]) | (x &gt; t[-k])):</div>
<div class="line"><span class="lineno"> 1495</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Out of bounds w/ x = %s.&#39;</span> % x)</div>
<div class="line"><span class="lineno"> 1496</span>    <span class="keywordflow">if</span> x.size != w.size:</div>
<div class="line"><span class="lineno"> 1497</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Shapes of x {} and w {} are incompatible&#39;</span></div>
<div class="line"><span class="lineno"> 1498</span>                         .format(x.shape, w.shape))</div>
<div class="line"><span class="lineno"> 1499</span> </div>
<div class="line"><span class="lineno"> 1500</span>    <span class="comment"># number of coefficients</span></div>
<div class="line"><span class="lineno"> 1501</span>    n = t.size - k - 1</div>
<div class="line"><span class="lineno"> 1502</span> </div>
<div class="line"><span class="lineno"> 1503</span>    <span class="comment"># construct A.T @ A and rhs with A the collocation matrix, and</span></div>
<div class="line"><span class="lineno"> 1504</span>    <span class="comment"># rhs = A.T @ y for solving the LSQ problem  ``A.T @ A @ c = A.T @ y``</span></div>
<div class="line"><span class="lineno"> 1505</span>    lower = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1506</span>    extradim = prod(y.shape[1:])</div>
<div class="line"><span class="lineno"> 1507</span>    ab = np.zeros((k+1, n), dtype=np.float_, order=<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno"> 1508</span>    rhs = np.zeros((n, extradim), dtype=y.dtype, order=<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno"> 1509</span>    _bspl._norm_eq_lsq(x, t, k,</div>
<div class="line"><span class="lineno"> 1510</span>                      y.reshape(-1, extradim),</div>
<div class="line"><span class="lineno"> 1511</span>                      w,</div>
<div class="line"><span class="lineno"> 1512</span>                      ab, rhs)</div>
<div class="line"><span class="lineno"> 1513</span>    rhs = rhs.reshape((n,) + y.shape[1:])</div>
<div class="line"><span class="lineno"> 1514</span> </div>
<div class="line"><span class="lineno"> 1515</span>    <span class="comment"># have observation matrix &amp; rhs, can solve the LSQ problem</span></div>
<div class="line"><span class="lineno"> 1516</span>    cho_decomp = cholesky_banded(ab, overwrite_ab=<span class="keyword">True</span>, lower=lower,</div>
<div class="line"><span class="lineno"> 1517</span>                                 check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1518</span>    c = cho_solve_banded((cho_decomp, lower), rhs, overwrite_b=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno"> 1519</span>                         check_finite=check_finite)</div>
<div class="line"><span class="lineno"> 1520</span> </div>
<div class="line"><span class="lineno"> 1521</span>    c = np.ascontiguousarray(c)</div>
<div class="line"><span class="lineno"> 1522</span>    <span class="keywordflow">return</span> BSpline.construct_fast(t, c, k, axis=axis)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
