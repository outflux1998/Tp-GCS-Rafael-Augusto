<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.sparse.csgraph._laplacian Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse.html">sparse</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph.html">csgraph</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html">_laplacian</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.sparse.csgraph._laplacian Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a52840ca2a30489c1dc8a6fc75f52e9e3" id="r_a52840ca2a30489c1dc8a6fc75f52e9e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a52840ca2a30489c1dc8a6fc75f52e9e3">laplacian</a> (csgraph, normed=False, return_diag=False, use_out_degree=False, *copy=True, form=&quot;array&quot;, dtype=None, symmetrized=False)</td></tr>
<tr class="memdesc:a52840ca2a30489c1dc8a6fc75f52e9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graph laplacian.  <br /></td></tr>
<tr class="separator:a52840ca2a30489c1dc8a6fc75f52e9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47da83edb46113b4587e900fc78afb64" id="r_a47da83edb46113b4587e900fc78afb64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a47da83edb46113b4587e900fc78afb64">_setdiag_dense</a> (m, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>)</td></tr>
<tr class="separator:a47da83edb46113b4587e900fc78afb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc0f7b7f9df656ae370559fa9e2580" id="r_a2fbc0f7b7f9df656ae370559fa9e2580"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a2fbc0f7b7f9df656ae370559fa9e2580">_laplace</a> (m, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>)</td></tr>
<tr class="separator:a2fbc0f7b7f9df656ae370559fa9e2580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f6aad490cc7d8282097391404aa99b" id="r_a52f6aad490cc7d8282097391404aa99b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a52f6aad490cc7d8282097391404aa99b">_laplace_normed</a> (m, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>, <a class="el" href="__lapack__subroutines_8h.html#aabc6a997249c3c182db789eebc033474">nd</a>)</td></tr>
<tr class="separator:a52f6aad490cc7d8282097391404aa99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2583053ae201ba6ea45c86d9a04df26" id="r_af2583053ae201ba6ea45c86d9a04df26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#af2583053ae201ba6ea45c86d9a04df26">_laplace_sym</a> (m, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>)</td></tr>
<tr class="separator:af2583053ae201ba6ea45c86d9a04df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c4f71c89060a1edaf1907dd3bbfd73" id="r_a64c4f71c89060a1edaf1907dd3bbfd73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a64c4f71c89060a1edaf1907dd3bbfd73">_laplace_normed_sym</a> (m, <a class="el" href="__lapack__subroutines_8h.html#a4c293bae27b15a76659be28378992185">d</a>, <a class="el" href="__lapack__subroutines_8h.html#aabc6a997249c3c182db789eebc033474">nd</a>)</td></tr>
<tr class="separator:a64c4f71c89060a1edaf1907dd3bbfd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556da2e839d200fb1b5d54a9950affce" id="r_a556da2e839d200fb1b5d54a9950affce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a556da2e839d200fb1b5d54a9950affce">_linearoperator</a> (<a class="el" href="__lapack__subroutines_8h.html#ade2fd42108182ce8cd67f7d8e80c6ec1">mv</a>, shape, dtype)</td></tr>
<tr class="separator:a556da2e839d200fb1b5d54a9950affce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c3aef24b16a5f4f68a2d12f0a0728f" id="r_a42c3aef24b16a5f4f68a2d12f0a0728f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a42c3aef24b16a5f4f68a2d12f0a0728f">_laplacian_sparse_flo</a> (graph, normed, axis, copy, form, dtype, symmetrized)</td></tr>
<tr class="separator:a42c3aef24b16a5f4f68a2d12f0a0728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e73fb17b99c229e95e5a47a168f5cc" id="r_ab8e73fb17b99c229e95e5a47a168f5cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#ab8e73fb17b99c229e95e5a47a168f5cc">_laplacian_sparse</a> (graph, normed, axis, copy, form, dtype, symmetrized)</td></tr>
<tr class="separator:ab8e73fb17b99c229e95e5a47a168f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340da4fcbda65a808a3e9b06d68dce0b" id="r_a340da4fcbda65a808a3e9b06d68dce0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#a340da4fcbda65a808a3e9b06d68dce0b">_laplacian_dense_flo</a> (graph, normed, axis, copy, form, dtype, symmetrized)</td></tr>
<tr class="separator:a340da4fcbda65a808a3e9b06d68dce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62fd415c6257e25e1b11d1a21076f97" id="r_af62fd415c6257e25e1b11d1a21076f97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1sparse_1_1csgraph_1_1__laplacian.html#af62fd415c6257e25e1b11d1a21076f97">_laplacian_dense</a> (graph, normed, axis, copy, form, dtype, symmetrized)</td></tr>
<tr class="separator:af62fd415c6257e25e1b11d1a21076f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Laplacian of a compressed-sparse graph
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a2fbc0f7b7f9df656ae370559fa9e2580" name="a2fbc0f7b7f9df656ae370559fa9e2580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc0f7b7f9df656ae370559fa9e2580">&#9670;&#160;</a></span>_laplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  372</span><span class="keyword">def </span>_laplace(m, d):</div>
<div class="line"><span class="lineno">  373</span>    <span class="keywordflow">return</span> <span class="keyword">lambda</span> v: v * d[:, np.newaxis] - m @ v</div>
<div class="line"><span class="lineno">  374</span> </div>
<div class="line"><span class="lineno">  375</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a52f6aad490cc7d8282097391404aa99b" name="a52f6aad490cc7d8282097391404aa99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f6aad490cc7d8282097391404aa99b">&#9670;&#160;</a></span>_laplace_normed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplace_normed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  376</span><span class="keyword">def </span>_laplace_normed(m, d, nd):</div>
<div class="line"><span class="lineno">  377</span>    laplace = _laplace(m, d)</div>
<div class="line"><span class="lineno">  378</span>    <span class="keywordflow">return</span> <span class="keyword">lambda</span> v: nd[:, np.newaxis] * laplace(v * nd[:, np.newaxis])</div>
<div class="line"><span class="lineno">  379</span> </div>
<div class="line"><span class="lineno">  380</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a64c4f71c89060a1edaf1907dd3bbfd73" name="a64c4f71c89060a1edaf1907dd3bbfd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c4f71c89060a1edaf1907dd3bbfd73">&#9670;&#160;</a></span>_laplace_normed_sym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplace_normed_sym </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  389</span><span class="keyword">def </span>_laplace_normed_sym(m, d, nd):</div>
<div class="line"><span class="lineno">  390</span>    laplace_sym = _laplace_sym(m, d)</div>
<div class="line"><span class="lineno">  391</span>    <span class="keywordflow">return</span> <span class="keyword">lambda</span> v: nd[:, np.newaxis] * laplace_sym(v * nd[:, np.newaxis])</div>
<div class="line"><span class="lineno">  392</span> </div>
<div class="line"><span class="lineno">  393</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af2583053ae201ba6ea45c86d9a04df26" name="af2583053ae201ba6ea45c86d9a04df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2583053ae201ba6ea45c86d9a04df26">&#9670;&#160;</a></span>_laplace_sym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplace_sym </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  381</span><span class="keyword">def </span>_laplace_sym(m, d):</div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">  383</span>        <span class="keyword">lambda</span> v: v * d[:, np.newaxis]</div>
<div class="line"><span class="lineno">  384</span>        - m @ v</div>
<div class="line"><span class="lineno">  385</span>        - np.transpose(np.conjugate(np.transpose(np.conjugate(v)) @ m))</div>
<div class="line"><span class="lineno">  386</span>    )</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af62fd415c6257e25e1b11d1a21076f97" name="af62fd415c6257e25e1b11d1a21076f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62fd415c6257e25e1b11d1a21076f97">&#9670;&#160;</a></span>_laplacian_dense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplacian_dense </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symmetrized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  523</span><span class="keyword">def </span>_laplacian_dense(graph, normed, axis, copy, form, dtype, symmetrized):</div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span>    <span class="keywordflow">if</span> form != <span class="stringliteral">&quot;array&quot;</span>:</div>
<div class="line"><span class="lineno">  526</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&#39;{form!r} must be &quot;array&quot;&#39;</span>)</div>
<div class="line"><span class="lineno">  527</span> </div>
<div class="line"><span class="lineno">  528</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  529</span>        dtype = graph.dtype</div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno">  532</span>        m = np.array(graph)</div>
<div class="line"><span class="lineno">  533</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  534</span>        m = np.asarray(graph)</div>
<div class="line"><span class="lineno">  535</span> </div>
<div class="line"><span class="lineno">  536</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  537</span>        dtype = m.dtype</div>
<div class="line"><span class="lineno">  538</span> </div>
<div class="line"><span class="lineno">  539</span>    <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  540</span>        m += m.T.conj()</div>
<div class="line"><span class="lineno">  541</span>    np.fill_diagonal(m, 0)</div>
<div class="line"><span class="lineno">  542</span>    w = m.sum(axis=axis)</div>
<div class="line"><span class="lineno">  543</span>    <span class="keywordflow">if</span> normed:</div>
<div class="line"><span class="lineno">  544</span>        isolated_node_mask = (w == 0)</div>
<div class="line"><span class="lineno">  545</span>        w = np.where(isolated_node_mask, 1, np.sqrt(w))</div>
<div class="line"><span class="lineno">  546</span>        m /= w</div>
<div class="line"><span class="lineno">  547</span>        m /= w[:, np.newaxis]</div>
<div class="line"><span class="lineno">  548</span>        m *= -1</div>
<div class="line"><span class="lineno">  549</span>        _setdiag_dense(m, 1 - isolated_node_mask)</div>
<div class="line"><span class="lineno">  550</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  551</span>        m *= -1</div>
<div class="line"><span class="lineno">  552</span>        _setdiag_dense(m, w)</div>
<div class="line"><span class="lineno">  553</span> </div>
<div class="line"><span class="lineno">  554</span>    <span class="keywordflow">return</span> m.astype(dtype, copy=<span class="keyword">False</span>), w.astype(dtype, copy=<span class="keyword">False</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a340da4fcbda65a808a3e9b06d68dce0b" name="a340da4fcbda65a808a3e9b06d68dce0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340da4fcbda65a808a3e9b06d68dce0b">&#9670;&#160;</a></span>_laplacian_dense_flo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplacian_dense_flo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symmetrized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  478</span><span class="keyword">def </span>_laplacian_dense_flo(graph, normed, axis, copy, form, dtype, symmetrized):</div>
<div class="line"><span class="lineno">  479</span> </div>
<div class="line"><span class="lineno">  480</span>    <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno">  481</span>        m = np.array(graph)</div>
<div class="line"><span class="lineno">  482</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  483</span>        m = np.asarray(graph)</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  486</span>        dtype = m.dtype</div>
<div class="line"><span class="lineno">  487</span> </div>
<div class="line"><span class="lineno">  488</span>    graph_sum = m.sum(axis=axis)</div>
<div class="line"><span class="lineno">  489</span>    graph_diagonal = m.diagonal()</div>
<div class="line"><span class="lineno">  490</span>    diag = graph_sum - graph_diagonal</div>
<div class="line"><span class="lineno">  491</span>    <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  492</span>        graph_sum += m.sum(axis=1 - axis)</div>
<div class="line"><span class="lineno">  493</span>        diag = graph_sum - graph_diagonal - graph_diagonal</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>    <span class="keywordflow">if</span> normed:</div>
<div class="line"><span class="lineno">  496</span>        isolated_node_mask = diag == 0</div>
<div class="line"><span class="lineno">  497</span>        w = np.where(isolated_node_mask, 1, np.sqrt(diag))</div>
<div class="line"><span class="lineno">  498</span>        <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  499</span>            md = _laplace_normed_sym(m, graph_sum, 1.0 / w)</div>
<div class="line"><span class="lineno">  500</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  501</span>            md = _laplace_normed(m, graph_sum, 1.0 / w)</div>
<div class="line"><span class="lineno">  502</span>        <span class="keywordflow">if</span> form == <span class="stringliteral">&quot;function&quot;</span>:</div>
<div class="line"><span class="lineno">  503</span>            <span class="keywordflow">return</span> md, w.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  504</span>        <span class="keywordflow">elif</span> form == <span class="stringliteral">&quot;lo&quot;</span>:</div>
<div class="line"><span class="lineno">  505</span>            m = _linearoperator(md, shape=graph.shape, dtype=dtype)</div>
<div class="line"><span class="lineno">  506</span>            <span class="keywordflow">return</span> m, w.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  507</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  508</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid form: {form!r}&quot;</span>)</div>
<div class="line"><span class="lineno">  509</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  510</span>        <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  511</span>            md = _laplace_sym(m, graph_sum)</div>
<div class="line"><span class="lineno">  512</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  513</span>            md = _laplace(m, graph_sum)</div>
<div class="line"><span class="lineno">  514</span>        <span class="keywordflow">if</span> form == <span class="stringliteral">&quot;function&quot;</span>:</div>
<div class="line"><span class="lineno">  515</span>            <span class="keywordflow">return</span> md, diag.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  516</span>        <span class="keywordflow">elif</span> form == <span class="stringliteral">&quot;lo&quot;</span>:</div>
<div class="line"><span class="lineno">  517</span>            m = _linearoperator(md, shape=graph.shape, dtype=dtype)</div>
<div class="line"><span class="lineno">  518</span>            <span class="keywordflow">return</span> m, diag.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  519</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  520</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid form: {form!r}&quot;</span>)</div>
<div class="line"><span class="lineno">  521</span> </div>
<div class="line"><span class="lineno">  522</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8e73fb17b99c229e95e5a47a168f5cc" name="ab8e73fb17b99c229e95e5a47a168f5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e73fb17b99c229e95e5a47a168f5cc">&#9670;&#160;</a></span>_laplacian_sparse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplacian_sparse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symmetrized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  440</span><span class="keyword">def </span>_laplacian_sparse(graph, normed, axis, copy, form, dtype, symmetrized):</div>
<div class="line"><span class="lineno">  441</span>    <span class="comment"># The keyword argument `form` is unused and has no effect here.</span></div>
<div class="line"><span class="lineno">  442</span>    del form</div>
<div class="line"><span class="lineno">  443</span> </div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  445</span>        dtype = graph.dtype</div>
<div class="line"><span class="lineno">  446</span> </div>
<div class="line"><span class="lineno">  447</span>    needs_copy = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  448</span>    <span class="keywordflow">if</span> graph.format <span class="keywordflow">in</span> (<span class="stringliteral">&#39;lil&#39;</span>, <span class="stringliteral">&#39;dok&#39;</span>):</div>
<div class="line"><span class="lineno">  449</span>        m = graph.tocoo()</div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  451</span>        m = graph</div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno">  453</span>            needs_copy = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  454</span> </div>
<div class="line"><span class="lineno">  455</span>    <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  456</span>        m += m.T.conj()</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>    w = m.sum(axis=axis).getA1() - m.diagonal()</div>
<div class="line"><span class="lineno">  459</span>    <span class="keywordflow">if</span> normed:</div>
<div class="line"><span class="lineno">  460</span>        m = m.tocoo(copy=needs_copy)</div>
<div class="line"><span class="lineno">  461</span>        isolated_node_mask = (w == 0)</div>
<div class="line"><span class="lineno">  462</span>        w = np.where(isolated_node_mask, 1, np.sqrt(w))</div>
<div class="line"><span class="lineno">  463</span>        m.data /= w[m.row]</div>
<div class="line"><span class="lineno">  464</span>        m.data /= w[m.col]</div>
<div class="line"><span class="lineno">  465</span>        m.data *= -1</div>
<div class="line"><span class="lineno">  466</span>        m.setdiag(1 - isolated_node_mask)</div>
<div class="line"><span class="lineno">  467</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  468</span>        <span class="keywordflow">if</span> m.format == <span class="stringliteral">&#39;dia&#39;</span>:</div>
<div class="line"><span class="lineno">  469</span>            m = m.copy()</div>
<div class="line"><span class="lineno">  470</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  471</span>            m = m.tocoo(copy=needs_copy)</div>
<div class="line"><span class="lineno">  472</span>        m.data *= -1</div>
<div class="line"><span class="lineno">  473</span>        m.setdiag(w)</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span>    <span class="keywordflow">return</span> m.astype(dtype, copy=<span class="keyword">False</span>), w.astype(dtype)</div>
<div class="line"><span class="lineno">  476</span> </div>
<div class="line"><span class="lineno">  477</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a42c3aef24b16a5f4f68a2d12f0a0728f" name="a42c3aef24b16a5f4f68a2d12f0a0728f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c3aef24b16a5f4f68a2d12f0a0728f">&#9670;&#160;</a></span>_laplacian_sparse_flo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._laplacian_sparse_flo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symmetrized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  398</span><span class="keyword">def </span>_laplacian_sparse_flo(graph, normed, axis, copy, form, dtype, symmetrized):</div>
<div class="line"><span class="lineno">  399</span>    <span class="comment"># The keyword argument `copy` is unused and has no effect here.</span></div>
<div class="line"><span class="lineno">  400</span>    del copy</div>
<div class="line"><span class="lineno">  401</span> </div>
<div class="line"><span class="lineno">  402</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  403</span>        dtype = graph.dtype</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>    graph_sum = graph.sum(axis=axis).getA1()</div>
<div class="line"><span class="lineno">  406</span>    graph_diagonal = graph.diagonal()</div>
<div class="line"><span class="lineno">  407</span>    diag = graph_sum - graph_diagonal</div>
<div class="line"><span class="lineno">  408</span>    <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  409</span>        graph_sum += graph.sum(axis=1 - axis).getA1()</div>
<div class="line"><span class="lineno">  410</span>        diag = graph_sum - graph_diagonal - graph_diagonal</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span>    <span class="keywordflow">if</span> normed:</div>
<div class="line"><span class="lineno">  413</span>        isolated_node_mask = diag == 0</div>
<div class="line"><span class="lineno">  414</span>        w = np.where(isolated_node_mask, 1, np.sqrt(diag))</div>
<div class="line"><span class="lineno">  415</span>        <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  416</span>            md = _laplace_normed_sym(graph, graph_sum, 1.0 / w)</div>
<div class="line"><span class="lineno">  417</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  418</span>            md = _laplace_normed(graph, graph_sum, 1.0 / w)</div>
<div class="line"><span class="lineno">  419</span>        <span class="keywordflow">if</span> form == <span class="stringliteral">&quot;function&quot;</span>:</div>
<div class="line"><span class="lineno">  420</span>            <span class="keywordflow">return</span> md, w.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  421</span>        <span class="keywordflow">elif</span> form == <span class="stringliteral">&quot;lo&quot;</span>:</div>
<div class="line"><span class="lineno">  422</span>            m = _linearoperator(md, shape=graph.shape, dtype=dtype)</div>
<div class="line"><span class="lineno">  423</span>            <span class="keywordflow">return</span> m, w.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  424</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  425</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid form: {form!r}&quot;</span>)</div>
<div class="line"><span class="lineno">  426</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  427</span>        <span class="keywordflow">if</span> symmetrized:</div>
<div class="line"><span class="lineno">  428</span>            md = _laplace_sym(graph, graph_sum)</div>
<div class="line"><span class="lineno">  429</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  430</span>            md = _laplace(graph, graph_sum)</div>
<div class="line"><span class="lineno">  431</span>        <span class="keywordflow">if</span> form == <span class="stringliteral">&quot;function&quot;</span>:</div>
<div class="line"><span class="lineno">  432</span>            <span class="keywordflow">return</span> md, diag.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  433</span>        <span class="keywordflow">elif</span> form == <span class="stringliteral">&quot;lo&quot;</span>:</div>
<div class="line"><span class="lineno">  434</span>            m = _linearoperator(md, shape=graph.shape, dtype=dtype)</div>
<div class="line"><span class="lineno">  435</span>            <span class="keywordflow">return</span> m, diag.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  436</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  437</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Invalid form: {form!r}&quot;</span>)</div>
<div class="line"><span class="lineno">  438</span> </div>
<div class="line"><span class="lineno">  439</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a556da2e839d200fb1b5d54a9950affce" name="a556da2e839d200fb1b5d54a9950affce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556da2e839d200fb1b5d54a9950affce">&#9670;&#160;</a></span>_linearoperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._linearoperator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  394</span><span class="keyword">def </span>_linearoperator(mv, shape, dtype):</div>
<div class="line"><span class="lineno">  395</span>    <span class="keywordflow">return</span> LinearOperator(matvec=mv, matmat=mv, shape=shape, dtype=dtype)</div>
<div class="line"><span class="lineno">  396</span> </div>
<div class="line"><span class="lineno">  397</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a47da83edb46113b4587e900fc78afb64" name="a47da83edb46113b4587e900fc78afb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47da83edb46113b4587e900fc78afb64">&#9670;&#160;</a></span>_setdiag_dense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian._setdiag_dense </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  367</span><span class="keyword">def </span>_setdiag_dense(m, d):</div>
<div class="line"><span class="lineno">  368</span>    step = len(d) + 1</div>
<div class="line"><span class="lineno">  369</span>    m.flat[::step] = d</div>
<div class="line"><span class="lineno">  370</span> </div>
<div class="line"><span class="lineno">  371</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a52840ca2a30489c1dc8a6fc75f52e9e3" name="a52840ca2a30489c1dc8a6fc75f52e9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52840ca2a30489c1dc8a6fc75f52e9e3">&#9670;&#160;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.csgraph._laplacian.laplacian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>csgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normed</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_diag</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_out_degree</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>form</em> = <code>&quot;array&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symmetrized</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Graph laplacian. </p>
<pre class="fragment">Return the Laplacian of a directed graph.

Parameters
----------
csgraph : array_like or sparse matrix, 2 dimensions
    compressed-sparse graph, with shape (N, N).
normed : bool, optional
    If True, then compute symmetrically normalized Laplacian.
    Default: False.
return_diag : bool, optional
    If True, then also return an array related to vertex degrees.
    Default: False.
use_out_degree : bool, optional
    If True, then use out-degree instead of in-degree.
    This distinction matters only if the graph is asymmetric.
    Default: False.
copy: bool, optional
    If False, then change `csgraph` in place if possible,
    avoiding doubling the memory use.
    Default: True, for backward compatibility.
form: 'array', or 'function', or 'lo'
    Determines the format of the output Laplacian:

    * 'array' is a numpy array;
    * 'function' is a pointer to evaluating the Laplacian-vector
      or Laplacian-matrix product;
    * 'lo' results in the format of the `LinearOperator`.

    Choosing 'function' or 'lo' always avoids doubling
    the memory use, ignoring `copy` value.
    Default: 'array', for backward compatibility.
dtype: None or one of numeric numpy dtypes, optional
    The dtype of the output. If ``dtype=None``, the dtype of the
    output matches the dtype of the input csgraph, except for
    the case ``normed=True`` and integer-like csgraph, where
    the output dtype is 'float' allowing accurate normalization,
    but dramatically increasing the memory use.
    Default: None, for backward compatibility.
symmetrized: bool, optional
    If True, then the output Laplacian is symmetric/Hermitian.
    The symmetrization is done by ``csgraph + csgraph.T.conj``
    without dividing by 2 to preserve integer dtypes if possible
    prior to the construction of the Laplacian.
    The symmetrization will increase the memory footprint of
    sparse matrices unless the sparsity pattern is symmetric or
    `form` is 'function' or 'lo'.
    Default: False, for backward compatibility.

Returns
-------
lap : ndarray, or sparse matrix, or `LinearOperator`
    The N x N Laplacian of csgraph. It will be a NumPy array (dense)
    if the input was dense, or a sparse matrix otherwise, or
    the format of a function or `LinearOperator` if
    `form` equals 'function' or 'lo', respectively.
diag : ndarray, optional
    The length-N main diagonal of the Laplacian matrix.
    For the normalized Laplacian, this is the array of square roots
    of vertex degrees or 1 if the degree is zero.

Notes
-----
The Laplacian matrix of a graph is sometimes referred to as the
"Kirchhoff matrix" or just the "Laplacian", and is useful in many
parts of spectral graph theory.
In particular, the eigen-decomposition of the Laplacian can give
insight into many properties of the graph, e.g.,
is commonly used for spectral data embedding and clustering.

The constructed Laplacian doubles the memory use if ``copy=True`` and
``form="array"`` which is the default.
Choosing ``copy=False`` has no effect unless ``form="array"``
or the matrix is sparse in the ``coo`` format, or dense array, except
for the integer input with ``normed=True`` that forces the float output.

Sparse input is reformatted into ``coo`` if ``form="array"``,
which is the default.

If the input adjacency matrix is not symmetic, the Laplacian is
also non-symmetric unless ``symmetrized=True`` is used.

Diagonal entries of the input adjacency matrix are ignored and
replaced with zeros for the purpose of normalization where ``normed=True``.
The normalization uses the inverse square roots of row-sums of the input
adjacency matrix, and thus may fail if the row-sums contain
negative or complex with a non-zero imaginary part values.

The normalization is symmetric, making the normalized Laplacian also
symmetric if the input csgraph was symmetric.

References
----------
.. [1] Laplacian matrix. https://en.wikipedia.org/wiki/Laplacian_matrix

Examples
--------
&gt;&gt;&gt; from scipy.sparse import csgraph

Our first illustration is the symmetric graph

&gt;&gt;&gt; G = np.arange(4) * np.arange(4)[:, np.newaxis]
&gt;&gt;&gt; G
array([[0, 0, 0, 0],
       [0, 1, 2, 3],
       [0, 2, 4, 6],
       [0, 3, 6, 9]])

and its symmetric Laplacian matrix

&gt;&gt;&gt; csgraph.laplacian(G)
array([[ 0,  0,  0,  0],
       [ 0,  5, -2, -3],
       [ 0, -2,  8, -6],
       [ 0, -3, -6,  9]])

The non-symmetric graph

&gt;&gt;&gt; G = np.arange(9).reshape(3, 3)
&gt;&gt;&gt; G
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

has different row- and column sums, resulting in two varieties
of the Laplacian matrix, using an in-degree, which is the default

&gt;&gt;&gt; L_in_degree = csgraph.laplacian(G)
&gt;&gt;&gt; L_in_degree
array([[ 9, -1, -2],
       [-3,  8, -5],
       [-6, -7,  7]])

or alternatively an out-degree

&gt;&gt;&gt; L_out_degree = csgraph.laplacian(G, use_out_degree=True)
&gt;&gt;&gt; L_out_degree
array([[ 3, -1, -2],
       [-3,  8, -5],
       [-6, -7, 13]])

Constructing a symmetric Laplacian matrix, one can add the two as

&gt;&gt;&gt; L_in_degree + L_out_degree.T
array([[ 12,  -4,  -8],
        [ -4,  16, -12],
        [ -8, -12,  20]])

or use the ``symmetrized=True`` option

&gt;&gt;&gt; csgraph.laplacian(G, symmetrized=True)
array([[ 12,  -4,  -8],
       [ -4,  16, -12],
       [ -8, -12,  20]])

that is equivalent to symmetrizing the original graph

&gt;&gt;&gt; csgraph.laplacian(G + G.T)
array([[ 12,  -4,  -8],
       [ -4,  16, -12],
       [ -8, -12,  20]])

The goal of normalization is to make the non-zero diagonal entries
of the Laplacian matrix to be all unit, also scaling off-diagonal
entries correspondingly. The normalization can be done manually, e.g.,

&gt;&gt;&gt; G = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])
&gt;&gt;&gt; L, d = csgraph.laplacian(G, return_diag=True)
&gt;&gt;&gt; L
array([[ 2, -1, -1],
       [-1,  2, -1],
       [-1, -1,  2]])
&gt;&gt;&gt; d
array([2, 2, 2])
&gt;&gt;&gt; scaling = np.sqrt(d)
&gt;&gt;&gt; scaling
array([1.41421356, 1.41421356, 1.41421356])
&gt;&gt;&gt; (1/scaling)*L*(1/scaling)
array([[ 1. , -0.5, -0.5],
       [-0.5,  1. , -0.5],
       [-0.5, -0.5,  1. ]])

Or using ``normed=True`` option

&gt;&gt;&gt; L, d = csgraph.laplacian(G, return_diag=True, normed=True)
&gt;&gt;&gt; L
array([[ 1. , -0.5, -0.5],
       [-0.5,  1. , -0.5],
       [-0.5, -0.5,  1. ]])

which now instead of the diagonal returns the scaling coefficients

&gt;&gt;&gt; d
array([1.41421356, 1.41421356, 1.41421356])

Zero scaling coefficients are substituted with 1s, where scaling
has thus no effect, e.g.,

&gt;&gt;&gt; G = np.array([[0, 0, 0], [0, 0, 1], [0, 1, 0]])
&gt;&gt;&gt; G
array([[0, 0, 0],
       [0, 0, 1],
       [0, 1, 0]])
&gt;&gt;&gt; L, d = csgraph.laplacian(G, return_diag=True, normed=True)
&gt;&gt;&gt; L
array([[ 0., -0., -0.],
       [-0.,  1., -1.],
       [-0., -1.,  1.]])
&gt;&gt;&gt; d
array([1., 1., 1.])

Only the symmetric normalization is implemented, resulting
in a symmetric Laplacian matrix if and only if its graph is symmetric
and has all non-negative degrees, like in the examples above.

The output Laplacian matrix is by default a dense array or a sparse matrix
inferring its shape, format, and dtype from the input graph matrix:

&gt;&gt;&gt; G = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]]).astype(np.float32)
&gt;&gt;&gt; G
array([[0., 1., 1.],
       [1., 0., 1.],
       [1., 1., 0.]], dtype=float32)
&gt;&gt;&gt; csgraph.laplacian(G)
array([[ 2., -1., -1.],
       [-1.,  2., -1.],
       [-1., -1.,  2.]], dtype=float32)

but can alternatively be generated matrix-free as a LinearOperator:

&gt;&gt;&gt; L = csgraph.laplacian(G, form="lo")
&gt;&gt;&gt; L
&lt;3x3 _CustomLinearOperator with dtype=float32&gt;
&gt;&gt;&gt; L(np.eye(3))
array([[ 2., -1., -1.],
       [-1.,  2., -1.],
       [-1., -1.,  2.]])

or as a lambda-function:

&gt;&gt;&gt; L = csgraph.laplacian(G, form="function")
&gt;&gt;&gt; L
&lt;function _laplace.&lt;locals&gt;.&lt;lambda&gt; at 0x0000012AE6F5A598&gt;
&gt;&gt;&gt; L(np.eye(3))
array([[ 2., -1., -1.],
       [-1.,  2., -1.],
       [-1., -1.,  2.]])

The Laplacian matrix is used for
spectral data clustering and embedding
as well as for spectral graph partitioning.
Our final example illustrates the latter
for a noisy directed linear graph.

&gt;&gt;&gt; from scipy.sparse import diags, random
&gt;&gt;&gt; from scipy.sparse.linalg import lobpcg

Create a directed linear graph with ``N=35`` vertices
using a sparse adjacency matrix ``G``:

&gt;&gt;&gt; N = 35
&gt;&gt;&gt; G = diags(np.ones(N-1), 1, format="csr")

Fix a random seed ``rng`` and add a random sparse noise to the graph ``G``:

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; G += 1e-2 * random(N, N, density=0.1, random_state=rng)

Set initial approximations for eigenvectors:

&gt;&gt;&gt; X = rng.random((N, 2))

The constant vector of ones is always a trivial eigenvector
of the non-normalized Laplacian to be filtered out:

&gt;&gt;&gt; Y = np.ones((N, 1))

Alternating (1) the sign of the graph weights allows determining
labels for spectral max- and min- cuts in a single loop.
Since the graph is undirected, the option ``symmetrized=True``
must be used in the construction of the Laplacian.
The option ``normed=True`` cannot be used in (2) for the negative weights
here as the symmetric normalization evaluates square roots.
The option ``form="lo"`` in (2) is matrix-free, i.e., guarantees
a fixed memory footprint and read-only access to the graph.
Calling the eigenvalue solver ``lobpcg`` (3) computes the Fiedler vector
that determines the labels as the signs of its components in (5).
Since the sign in an eigenvector is not deterministic and can flip,
we fix the sign of the first component to be always +1 in (4).

&gt;&gt;&gt; for cut in ["max", "min"]:
...     G = -G  # 1.
...     L = csgraph.laplacian(G, symmetrized=True, form="lo")  # 2.
...     _, eves = lobpcg(L, X, Y=Y, largest=False, tol=1e-3)  # 3.
...     eves *= np.sign(eves[0, 0])  # 4.
...     print(cut + "-cut labels:\\n", 1 * (eves[:, 0]&gt;0))  # 5.
max-cut labels:
[1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1]
min-cut labels:
[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]

As anticipated for a (slightly noisy) linear graph,
the max-cut strips all the edges of the graph coloring all
odd vertices into one color and all even vertices into another one,
while the balanced min-cut partitions the graph
in the middle by deleting a single edge.
Both determined partitions are optimal.
</pre> <div class="fragment"><div class="line"><span class="lineno">   22</span>):</div>
<div class="line"><span class="lineno">   23</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">    Return the Laplacian of a directed graph.</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    csgraph : array_like or sparse matrix, 2 dimensions</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">        compressed-sparse graph, with shape (N, N).</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    normed : bool, optional</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">        If True, then compute symmetrically normalized Laplacian.</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">        Default: False.</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    return_diag : bool, optional</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">        If True, then also return an array related to vertex degrees.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">        Default: False.</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    use_out_degree : bool, optional</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        If True, then use out-degree instead of in-degree.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">        This distinction matters only if the graph is asymmetric.</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        Default: False.</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">    copy: bool, optional</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">        If False, then change `csgraph` in place if possible,</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        avoiding doubling the memory use.</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        Default: True, for backward compatibility.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    form: &#39;array&#39;, or &#39;function&#39;, or &#39;lo&#39;</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        Determines the format of the output Laplacian:</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">        * &#39;array&#39; is a numpy array;</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">        * &#39;function&#39; is a pointer to evaluating the Laplacian-vector</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">          or Laplacian-matrix product;</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        * &#39;lo&#39; results in the format of the `LinearOperator`.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">        Choosing &#39;function&#39; or &#39;lo&#39; always avoids doubling</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        the memory use, ignoring `copy` value.</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        Default: &#39;array&#39;, for backward compatibility.</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">    dtype: None or one of numeric numpy dtypes, optional</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">        The dtype of the output. If ``dtype=None``, the dtype of the</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">        output matches the dtype of the input csgraph, except for</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        the case ``normed=True`` and integer-like csgraph, where</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        the output dtype is &#39;float&#39; allowing accurate normalization,</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        but dramatically increasing the memory use.</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">        Default: None, for backward compatibility.</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    symmetrized: bool, optional</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">        If True, then the output Laplacian is symmetric/Hermitian.</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">        The symmetrization is done by ``csgraph + csgraph.T.conj``</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">        without dividing by 2 to preserve integer dtypes if possible</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        prior to the construction of the Laplacian.</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">        The symmetrization will increase the memory footprint of</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">        sparse matrices unless the sparsity pattern is symmetric or</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">        `form` is &#39;function&#39; or &#39;lo&#39;.</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">        Default: False, for backward compatibility.</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    lap : ndarray, or sparse matrix, or `LinearOperator`</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">        The N x N Laplacian of csgraph. It will be a NumPy array (dense)</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">        if the input was dense, or a sparse matrix otherwise, or</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">        the format of a function or `LinearOperator` if</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">        `form` equals &#39;function&#39; or &#39;lo&#39;, respectively.</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    diag : ndarray, optional</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">        The length-N main diagonal of the Laplacian matrix.</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">        For the normalized Laplacian, this is the array of square roots</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        of vertex degrees or 1 if the degree is zero.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    The Laplacian matrix of a graph is sometimes referred to as the</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    &quot;Kirchhoff matrix&quot; or just the &quot;Laplacian&quot;, and is useful in many</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    parts of spectral graph theory.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    In particular, the eigen-decomposition of the Laplacian can give</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    insight into many properties of the graph, e.g.,</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    is commonly used for spectral data embedding and clustering.</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    The constructed Laplacian doubles the memory use if ``copy=True`` and</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    ``form=&quot;array&quot;`` which is the default.</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    Choosing ``copy=False`` has no effect unless ``form=&quot;array&quot;``</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    or the matrix is sparse in the ``coo`` format, or dense array, except</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">    for the integer input with ``normed=True`` that forces the float output.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    Sparse input is reformatted into ``coo`` if ``form=&quot;array&quot;``,</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    which is the default.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    If the input adjacency matrix is not symmetic, the Laplacian is</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    also non-symmetric unless ``symmetrized=True`` is used.</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    Diagonal entries of the input adjacency matrix are ignored and</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">    replaced with zeros for the purpose of normalization where ``normed=True``.</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    The normalization uses the inverse square roots of row-sums of the input</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    adjacency matrix, and thus may fail if the row-sums contain</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    negative or complex with a non-zero imaginary part values.</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    The normalization is symmetric, making the normalized Laplacian also</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    symmetric if the input csgraph was symmetric.</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    .. [1] Laplacian matrix. https://en.wikipedia.org/wiki/Laplacian_matrix</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import csgraph</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    Our first illustration is the symmetric graph</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &gt;&gt;&gt; G = np.arange(4) * np.arange(4)[:, np.newaxis]</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    &gt;&gt;&gt; G</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    array([[0, 0, 0, 0],</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">           [0, 1, 2, 3],</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">           [0, 2, 4, 6],</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">           [0, 3, 6, 9]])</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    and its symmetric Laplacian matrix</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    &gt;&gt;&gt; csgraph.laplacian(G)</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    array([[ 0,  0,  0,  0],</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">           [ 0,  5, -2, -3],</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">           [ 0, -2,  8, -6],</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">           [ 0, -3, -6,  9]])</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    The non-symmetric graph</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    &gt;&gt;&gt; G = np.arange(9).reshape(3, 3)</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    &gt;&gt;&gt; G</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">           [3, 4, 5],</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">           [6, 7, 8]])</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    has different row- and column sums, resulting in two varieties</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    of the Laplacian matrix, using an in-degree, which is the default</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    &gt;&gt;&gt; L_in_degree = csgraph.laplacian(G)</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    &gt;&gt;&gt; L_in_degree</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    array([[ 9, -1, -2],</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">           [-3,  8, -5],</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">           [-6, -7,  7]])</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    or alternatively an out-degree</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    &gt;&gt;&gt; L_out_degree = csgraph.laplacian(G, use_out_degree=True)</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    &gt;&gt;&gt; L_out_degree</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    array([[ 3, -1, -2],</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">           [-3,  8, -5],</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">           [-6, -7, 13]])</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    Constructing a symmetric Laplacian matrix, one can add the two as</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    &gt;&gt;&gt; L_in_degree + L_out_degree.T</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    array([[ 12,  -4,  -8],</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">            [ -4,  16, -12],</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">            [ -8, -12,  20]])</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    or use the ``symmetrized=True`` option</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    &gt;&gt;&gt; csgraph.laplacian(G, symmetrized=True)</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    array([[ 12,  -4,  -8],</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">           [ -4,  16, -12],</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">           [ -8, -12,  20]])</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    that is equivalent to symmetrizing the original graph</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    &gt;&gt;&gt; csgraph.laplacian(G + G.T)</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    array([[ 12,  -4,  -8],</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">           [ -4,  16, -12],</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">           [ -8, -12,  20]])</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    The goal of normalization is to make the non-zero diagonal entries</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    of the Laplacian matrix to be all unit, also scaling off-diagonal</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    entries correspondingly. The normalization can be done manually, e.g.,</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    &gt;&gt;&gt; G = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    &gt;&gt;&gt; L, d = csgraph.laplacian(G, return_diag=True)</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    &gt;&gt;&gt; L</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    array([[ 2, -1, -1],</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">           [-1,  2, -1],</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">           [-1, -1,  2]])</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    &gt;&gt;&gt; d</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    array([2, 2, 2])</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    &gt;&gt;&gt; scaling = np.sqrt(d)</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    &gt;&gt;&gt; scaling</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    array([1.41421356, 1.41421356, 1.41421356])</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    &gt;&gt;&gt; (1/scaling)*L*(1/scaling)</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    array([[ 1. , -0.5, -0.5],</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">           [-0.5,  1. , -0.5],</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">           [-0.5, -0.5,  1. ]])</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    Or using ``normed=True`` option</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    &gt;&gt;&gt; L, d = csgraph.laplacian(G, return_diag=True, normed=True)</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    &gt;&gt;&gt; L</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    array([[ 1. , -0.5, -0.5],</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">           [-0.5,  1. , -0.5],</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">           [-0.5, -0.5,  1. ]])</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    which now instead of the diagonal returns the scaling coefficients</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; d</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    array([1.41421356, 1.41421356, 1.41421356])</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    Zero scaling coefficients are substituted with 1s, where scaling</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    has thus no effect, e.g.,</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    &gt;&gt;&gt; G = np.array([[0, 0, 0], [0, 0, 1], [0, 1, 0]])</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &gt;&gt;&gt; G</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    array([[0, 0, 0],</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">           [0, 0, 1],</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">           [0, 1, 0]])</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    &gt;&gt;&gt; L, d = csgraph.laplacian(G, return_diag=True, normed=True)</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    &gt;&gt;&gt; L</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    array([[ 0., -0., -0.],</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">           [-0.,  1., -1.],</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">           [-0., -1.,  1.]])</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    &gt;&gt;&gt; d</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    array([1., 1., 1.])</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Only the symmetric normalization is implemented, resulting</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    in a symmetric Laplacian matrix if and only if its graph is symmetric</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    and has all non-negative degrees, like in the examples above.</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    The output Laplacian matrix is by default a dense array or a sparse matrix</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    inferring its shape, format, and dtype from the input graph matrix:</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    &gt;&gt;&gt; G = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]]).astype(np.float32)</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    &gt;&gt;&gt; G</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    array([[0., 1., 1.],</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">           [1., 0., 1.],</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">           [1., 1., 0.]], dtype=float32)</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    &gt;&gt;&gt; csgraph.laplacian(G)</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    array([[ 2., -1., -1.],</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">           [-1.,  2., -1.],</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">           [-1., -1.,  2.]], dtype=float32)</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    but can alternatively be generated matrix-free as a LinearOperator:</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    &gt;&gt;&gt; L = csgraph.laplacian(G, form=&quot;lo&quot;)</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    &gt;&gt;&gt; L</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    &lt;3x3 _CustomLinearOperator with dtype=float32&gt;</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    &gt;&gt;&gt; L(np.eye(3))</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    array([[ 2., -1., -1.],</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">           [-1.,  2., -1.],</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">           [-1., -1.,  2.]])</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    or as a lambda-function:</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    &gt;&gt;&gt; L = csgraph.laplacian(G, form=&quot;function&quot;)</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    &gt;&gt;&gt; L</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    &lt;function _laplace.&lt;locals&gt;.&lt;lambda&gt; at 0x0000012AE6F5A598&gt;</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    &gt;&gt;&gt; L(np.eye(3))</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    array([[ 2., -1., -1.],</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">           [-1.,  2., -1.],</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">           [-1., -1.,  2.]])</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    The Laplacian matrix is used for</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    spectral data clustering and embedding</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    as well as for spectral graph partitioning.</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    Our final example illustrates the latter</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    for a noisy directed linear graph.</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse import diags, random</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.sparse.linalg import lobpcg</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    Create a directed linear graph with ``N=35`` vertices</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    using a sparse adjacency matrix ``G``:</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    &gt;&gt;&gt; N = 35</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    &gt;&gt;&gt; G = diags(np.ones(N-1), 1, format=&quot;csr&quot;)</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    Fix a random seed ``rng`` and add a random sparse noise to the graph ``G``:</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &gt;&gt;&gt; G += 1e-2 * random(N, N, density=0.1, random_state=rng)</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    Set initial approximations for eigenvectors:</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    &gt;&gt;&gt; X = rng.random((N, 2))</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    The constant vector of ones is always a trivial eigenvector</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    of the non-normalized Laplacian to be filtered out:</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    &gt;&gt;&gt; Y = np.ones((N, 1))</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    Alternating (1) the sign of the graph weights allows determining</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    labels for spectral max- and min- cuts in a single loop.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    Since the graph is undirected, the option ``symmetrized=True``</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    must be used in the construction of the Laplacian.</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    The option ``normed=True`` cannot be used in (2) for the negative weights</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    here as the symmetric normalization evaluates square roots.</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    The option ``form=&quot;lo&quot;`` in (2) is matrix-free, i.e., guarantees</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    a fixed memory footprint and read-only access to the graph.</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    Calling the eigenvalue solver ``lobpcg`` (3) computes the Fiedler vector</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    that determines the labels as the signs of its components in (5).</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    Since the sign in an eigenvector is not deterministic and can flip,</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    we fix the sign of the first component to be always +1 in (4).</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    &gt;&gt;&gt; for cut in [&quot;max&quot;, &quot;min&quot;]:</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    ...     G = -G  # 1.</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    ...     L = csgraph.laplacian(G, symmetrized=True, form=&quot;lo&quot;)  # 2.</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    ...     _, eves = lobpcg(L, X, Y=Y, largest=False, tol=1e-3)  # 3.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    ...     eves *= np.sign(eves[0, 0])  # 4.</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    ...     print(cut + &quot;-cut labels:\\n&quot;, 1 * (eves[:, 0]&gt;0))  # 5.</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    max-cut labels:</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    [1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1]</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    min-cut labels:</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    As anticipated for a (slightly noisy) linear graph,</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    the max-cut strips all the edges of the graph coloring all</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    odd vertices into one color and all even vertices into another one,</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    while the balanced min-cut partitions the graph</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    in the middle by deleting a single edge.</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    Both determined partitions are optimal.</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  331</span>    <span class="keywordflow">if</span> csgraph.ndim != 2 <span class="keywordflow">or</span> csgraph.shape[0] != csgraph.shape[1]:</div>
<div class="line"><span class="lineno">  332</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;csgraph must be a square matrix or array&#39;</span>)</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>    <span class="keywordflow">if</span> normed <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno">  335</span>        np.issubdtype(csgraph.dtype, np.signedinteger)</div>
<div class="line"><span class="lineno">  336</span>        <span class="keywordflow">or</span> np.issubdtype(csgraph.dtype, np.uint)</div>
<div class="line"><span class="lineno">  337</span>    ):</div>
<div class="line"><span class="lineno">  338</span>        csgraph = csgraph.astype(np.float64)</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordflow">if</span> form == <span class="stringliteral">&quot;array&quot;</span>:</div>
<div class="line"><span class="lineno">  341</span>        create_lap = (</div>
<div class="line"><span class="lineno">  342</span>            _laplacian_sparse <span class="keywordflow">if</span> isspmatrix(csgraph) <span class="keywordflow">else</span> _laplacian_dense</div>
<div class="line"><span class="lineno">  343</span>        )</div>
<div class="line"><span class="lineno">  344</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  345</span>        create_lap = (</div>
<div class="line"><span class="lineno">  346</span>            _laplacian_sparse_flo</div>
<div class="line"><span class="lineno">  347</span>            <span class="keywordflow">if</span> isspmatrix(csgraph)</div>
<div class="line"><span class="lineno">  348</span>            <span class="keywordflow">else</span> _laplacian_dense_flo</div>
<div class="line"><span class="lineno">  349</span>        )</div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>    degree_axis = 1 <span class="keywordflow">if</span> use_out_degree <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno">  352</span> </div>
<div class="line"><span class="lineno">  353</span>    lap, d = create_lap(</div>
<div class="line"><span class="lineno">  354</span>        csgraph,</div>
<div class="line"><span class="lineno">  355</span>        normed=normed,</div>
<div class="line"><span class="lineno">  356</span>        axis=degree_axis,</div>
<div class="line"><span class="lineno">  357</span>        copy=copy,</div>
<div class="line"><span class="lineno">  358</span>        form=form,</div>
<div class="line"><span class="lineno">  359</span>        dtype=dtype,</div>
<div class="line"><span class="lineno">  360</span>        symmetrized=symmetrized,</div>
<div class="line"><span class="lineno">  361</span>    )</div>
<div class="line"><span class="lineno">  362</span>    <span class="keywordflow">if</span> return_diag:</div>
<div class="line"><span class="lineno">  363</span>        <span class="keywordflow">return</span> lap, d</div>
<div class="line"><span class="lineno">  364</span>    <span class="keywordflow">return</span> lap</div>
<div class="line"><span class="lineno">  365</span> </div>
<div class="line"><span class="lineno">  366</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
