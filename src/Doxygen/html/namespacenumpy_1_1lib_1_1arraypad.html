<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.arraypad Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html">arraypad</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.arraypad Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa7460d8995330adb81edac72607c5f79" id="r_aa7460d8995330adb81edac72607c5f79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#aa7460d8995330adb81edac72607c5f79">_round_if_needed</a> (arr, dtype)</td></tr>
<tr class="memdesc:aa7460d8995330adb81edac72607c5f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private utility functions.  <br /></td></tr>
<tr class="separator:aa7460d8995330adb81edac72607c5f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6a68eb64f5bb61960e803dd07c884" id="r_a02c6a68eb64f5bb61960e803dd07c884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a02c6a68eb64f5bb61960e803dd07c884">_slice_at_axis</a> (sl, axis)</td></tr>
<tr class="separator:a02c6a68eb64f5bb61960e803dd07c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ce2ba54b8417fc3a481a4c5ba69cd6" id="r_a14ce2ba54b8417fc3a481a4c5ba69cd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a14ce2ba54b8417fc3a481a4c5ba69cd6">_view_roi</a> (array, original_area_slice, axis)</td></tr>
<tr class="separator:a14ce2ba54b8417fc3a481a4c5ba69cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39919b9582e52a6ffafa42c81c1e1d60" id="r_a39919b9582e52a6ffafa42c81c1e1d60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a39919b9582e52a6ffafa42c81c1e1d60">_pad_simple</a> (array, pad_width, fill_value=None)</td></tr>
<tr class="separator:a39919b9582e52a6ffafa42c81c1e1d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1898525b60749417fc05922db9c872" id="r_a9b1898525b60749417fc05922db9c872"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a9b1898525b60749417fc05922db9c872">_set_pad_area</a> (padded, axis, width_pair, value_pair)</td></tr>
<tr class="separator:a9b1898525b60749417fc05922db9c872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841b9954aae119493d6e5e1536195778" id="r_a841b9954aae119493d6e5e1536195778"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a841b9954aae119493d6e5e1536195778">_get_edges</a> (padded, axis, width_pair)</td></tr>
<tr class="separator:a841b9954aae119493d6e5e1536195778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6398a036646fe6b7c4ab4e5ff6c1bd" id="r_a1b6398a036646fe6b7c4ab4e5ff6c1bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a1b6398a036646fe6b7c4ab4e5ff6c1bd">_get_linear_ramps</a> (padded, axis, width_pair, end_value_pair)</td></tr>
<tr class="separator:a1b6398a036646fe6b7c4ab4e5ff6c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddb7169260593afb561b47396788518" id="r_a3ddb7169260593afb561b47396788518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a3ddb7169260593afb561b47396788518">_get_stats</a> (padded, axis, width_pair, length_pair, stat_func)</td></tr>
<tr class="separator:a3ddb7169260593afb561b47396788518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199e591eaea076f82376e77b7908be7f" id="r_a199e591eaea076f82376e77b7908be7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a199e591eaea076f82376e77b7908be7f">_set_reflect_both</a> (padded, axis, width_pair, method, include_edge=False)</td></tr>
<tr class="separator:a199e591eaea076f82376e77b7908be7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f36bcd36dba7a7e94526686871fc14" id="r_a05f36bcd36dba7a7e94526686871fc14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a05f36bcd36dba7a7e94526686871fc14">_set_wrap_both</a> (padded, axis, width_pair)</td></tr>
<tr class="separator:a05f36bcd36dba7a7e94526686871fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b964186a3e797729b4c3c289e11a4a" id="r_ae6b964186a3e797729b4c3c289e11a4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#ae6b964186a3e797729b4c3c289e11a4a">_as_pairs</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, ndim, as_index=False)</td></tr>
<tr class="separator:ae6b964186a3e797729b4c3c289e11a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dad4ff5561deb84a6922067d71ce93" id="r_ac8dad4ff5561deb84a6922067d71ce93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#ac8dad4ff5561deb84a6922067d71ce93">_pad_dispatcher</a> (array, pad_width, mode=None, **kwargs)</td></tr>
<tr class="separator:ac8dad4ff5561deb84a6922067d71ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f6ba7ccefaab37a09357632bdcd7b7" id="r_a03f6ba7ccefaab37a09357632bdcd7b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a03f6ba7ccefaab37a09357632bdcd7b7">pad</a> (array, pad_width, mode='constant', **kwargs)</td></tr>
<tr class="memdesc:a03f6ba7ccefaab37a09357632bdcd7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public functions.  <br /></td></tr>
<tr class="separator:a03f6ba7ccefaab37a09357632bdcd7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The arraypad module contains a group of functions to pad values onto the edges
of an n-dimensional array.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae6b964186a3e797729b4c3c289e11a4a" name="ae6b964186a3e797729b4c3c289e11a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b964186a3e797729b4c3c289e11a4a">&#9670;&#160;</a></span>_as_pairs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._as_pairs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>as_index</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Broadcast `x` to an array with the shape (`ndim`, 2).

A helper function for `pad` that prepares and validates arguments like
`pad_width` for iteration in pairs.

Parameters
----------
x : {None, scalar, array-like}
    The object to broadcast to the shape (`ndim`, 2).
ndim : int
    Number of pairs the broadcasted `x` will have.
as_index : bool, optional
    If `x` is not None, try to round each element of `x` to an integer
    (dtype `np.intp`) and ensure every element is positive.

Returns
-------
pairs : nested iterables, shape (`ndim`, 2)
    The broadcasted version of `x`.

Raises
------
ValueError
    If `as_index` is True and `x` contains negative elements.
    Or if `x` is not broadcastable to the shape (`ndim`, 2).
</pre> <div class="fragment"><div class="line"><span class="lineno">  454</span><span class="keyword">def </span>_as_pairs(x, ndim, as_index=False):</div>
<div class="line"><span class="lineno">  455</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Broadcast `x` to an array with the shape (`ndim`, 2).</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    A helper function for `pad` that prepares and validates arguments like</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    `pad_width` for iteration in pairs.</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    x : {None, scalar, array-like}</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">        The object to broadcast to the shape (`ndim`, 2).</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    ndim : int</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">        Number of pairs the broadcasted `x` will have.</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    as_index : bool, optional</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">        If `x` is not None, try to round each element of `x` to an integer</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        (dtype `np.intp`) and ensure every element is positive.</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    pairs : nested iterables, shape (`ndim`, 2)</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        The broadcasted version of `x`.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        If `as_index` is True and `x` contains negative elements.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">        Or if `x` is not broadcastable to the shape (`ndim`, 2).</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  482</span>    <span class="keywordflow">if</span> x <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  483</span>        <span class="comment"># Pass through None as a special case, otherwise np.round(x) fails</span></div>
<div class="line"><span class="lineno">  484</span>        <span class="comment"># with an AttributeError</span></div>
<div class="line"><span class="lineno">  485</span>        <span class="keywordflow">return</span> ((<span class="keywordtype">None</span>, <span class="keywordtype">None</span>),) * ndim</div>
<div class="line"><span class="lineno">  486</span> </div>
<div class="line"><span class="lineno">  487</span>    x = np.array(x)</div>
<div class="line"><span class="lineno">  488</span>    <span class="keywordflow">if</span> as_index:</div>
<div class="line"><span class="lineno">  489</span>        x = np.round(x).astype(np.intp, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  490</span> </div>
<div class="line"><span class="lineno">  491</span>    <span class="keywordflow">if</span> x.ndim &lt; 3:</div>
<div class="line"><span class="lineno">  492</span>        <span class="comment"># Optimization: Possibly use faster paths for cases where `x` has</span></div>
<div class="line"><span class="lineno">  493</span>        <span class="comment"># only 1 or 2 elements. `np.broadcast_to` could handle these as well</span></div>
<div class="line"><span class="lineno">  494</span>        <span class="comment"># but is currently slower</span></div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span>        <span class="keywordflow">if</span> x.size == 1:</div>
<div class="line"><span class="lineno">  497</span>            <span class="comment"># x was supplied as a single value</span></div>
<div class="line"><span class="lineno">  498</span>            x = x.ravel()  <span class="comment"># Ensure x[0] works for x.ndim == 0, 1, 2</span></div>
<div class="line"><span class="lineno">  499</span>            <span class="keywordflow">if</span> as_index <span class="keywordflow">and</span> x &lt; 0:</div>
<div class="line"><span class="lineno">  500</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;index can&#39;t contain negative values&quot;</span>)</div>
<div class="line"><span class="lineno">  501</span>            <span class="keywordflow">return</span> ((x[0], x[0]),) * ndim</div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span>        <span class="keywordflow">if</span> x.size == 2 <span class="keywordflow">and</span> x.shape != (2, 1):</div>
<div class="line"><span class="lineno">  504</span>            <span class="comment"># x was supplied with a single value for each side</span></div>
<div class="line"><span class="lineno">  505</span>            <span class="comment"># but except case when each dimension has a single value</span></div>
<div class="line"><span class="lineno">  506</span>            <span class="comment"># which should be broadcasted to a pair,</span></div>
<div class="line"><span class="lineno">  507</span>            <span class="comment"># e.g. [[1], [2]] -&gt; [[1, 1], [2, 2]] not [[1, 2], [1, 2]]</span></div>
<div class="line"><span class="lineno">  508</span>            x = x.ravel()  <span class="comment"># Ensure x[0], x[1] works</span></div>
<div class="line"><span class="lineno">  509</span>            <span class="keywordflow">if</span> as_index <span class="keywordflow">and</span> (x[0] &lt; 0 <span class="keywordflow">or</span> x[1] &lt; 0):</div>
<div class="line"><span class="lineno">  510</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;index can&#39;t contain negative values&quot;</span>)</div>
<div class="line"><span class="lineno">  511</span>            <span class="keywordflow">return</span> ((x[0], x[1]),) * ndim</div>
<div class="line"><span class="lineno">  512</span> </div>
<div class="line"><span class="lineno">  513</span>    <span class="keywordflow">if</span> as_index <span class="keywordflow">and</span> x.min() &lt; 0:</div>
<div class="line"><span class="lineno">  514</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;index can&#39;t contain negative values&quot;</span>)</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span>    <span class="comment"># Converting the array with `tolist` seems to improve performance</span></div>
<div class="line"><span class="lineno">  517</span>    <span class="comment"># when iterating and indexing the result (see usage in `pad`)</span></div>
<div class="line"><span class="lineno">  518</span>    <span class="keywordflow">return</span> np.broadcast_to(x, (ndim, 2)).tolist()</div>
<div class="line"><span class="lineno">  519</span> </div>
<div class="line"><span class="lineno">  520</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a841b9954aae119493d6e5e1536195778" name="a841b9954aae119493d6e5e1536195778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841b9954aae119493d6e5e1536195778">&#9670;&#160;</a></span>_get_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._get_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Retrieve edge values from empty-padded array in given dimension.

Parameters
----------
padded : ndarray
    Empty-padded array.
axis : int
    Dimension in which the edges are considered.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.

Returns
-------
left_edge, right_edge : ndarray
    Edge values of the valid area in `padded` in the given dimension. Its
    shape will always match `padded` except for the dimension given by
    `axis` which will have a length of 1.
</pre> <div class="fragment"><div class="line"><span class="lineno">  154</span><span class="keyword">def </span>_get_edges(padded, axis, width_pair):</div>
<div class="line"><span class="lineno">  155</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    Retrieve edge values from empty-padded array in given dimension.</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    padded : ndarray</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        Empty-padded array.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">        Dimension in which the edges are considered.</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    width_pair : (int, int)</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        Pair of widths that mark the pad area on both sides in the given</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    left_edge, right_edge : ndarray</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">        Edge values of the valid area in `padded` in the given dimension. Its</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        shape will always match `padded` except for the dimension given by</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        `axis` which will have a length of 1.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  175</span>    left_index = width_pair[0]</div>
<div class="line"><span class="lineno">  176</span>    left_slice = _slice_at_axis(slice(left_index, left_index + 1), axis)</div>
<div class="line"><span class="lineno">  177</span>    left_edge = padded[left_slice]</div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>    right_index = padded.shape[axis] - width_pair[1]</div>
<div class="line"><span class="lineno">  180</span>    right_slice = _slice_at_axis(slice(right_index - 1, right_index), axis)</div>
<div class="line"><span class="lineno">  181</span>    right_edge = padded[right_slice]</div>
<div class="line"><span class="lineno">  182</span> </div>
<div class="line"><span class="lineno">  183</span>    <span class="keywordflow">return</span> left_edge, right_edge</div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b6398a036646fe6b7c4ab4e5ff6c1bd" name="a1b6398a036646fe6b7c4ab4e5ff6c1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6398a036646fe6b7c4ab4e5ff6c1bd">&#9670;&#160;</a></span>_get_linear_ramps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._get_linear_ramps </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end_value_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Construct linear ramps for empty-padded array in given dimension.

Parameters
----------
padded : ndarray
    Empty-padded array.
axis : int
    Dimension in which the ramps are constructed.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
end_value_pair : (scalar, scalar)
    End values for the linear ramps which form the edge of the fully padded
    array. These values are included in the linear ramps.

Returns
-------
left_ramp, right_ramp : ndarray
    Linear ramps to set on both sides of `padded`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  186</span><span class="keyword">def </span>_get_linear_ramps(padded, axis, width_pair, end_value_pair):</div>
<div class="line"><span class="lineno">  187</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    Construct linear ramps for empty-padded array in given dimension.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    padded : ndarray</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        Empty-padded array.</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        Dimension in which the ramps are constructed.</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    width_pair : (int, int)</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">        Pair of widths that mark the pad area on both sides in the given</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    end_value_pair : (scalar, scalar)</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        End values for the linear ramps which form the edge of the fully padded</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        array. These values are included in the linear ramps.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    left_ramp, right_ramp : ndarray</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        Linear ramps to set on both sides of `padded`.</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  208</span>    edge_pair = _get_edges(padded, axis, width_pair)</div>
<div class="line"><span class="lineno">  209</span> </div>
<div class="line"><span class="lineno">  210</span>    left_ramp, right_ramp = (</div>
<div class="line"><span class="lineno">  211</span>        np.linspace(</div>
<div class="line"><span class="lineno">  212</span>            start=end_value,</div>
<div class="line"><span class="lineno">  213</span>            stop=edge.squeeze(axis), <span class="comment"># Dimension is replaced by linspace</span></div>
<div class="line"><span class="lineno">  214</span>            num=width,</div>
<div class="line"><span class="lineno">  215</span>            endpoint=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  216</span>            dtype=padded.dtype,</div>
<div class="line"><span class="lineno">  217</span>            axis=axis</div>
<div class="line"><span class="lineno">  218</span>        )</div>
<div class="line"><span class="lineno">  219</span>        <span class="keywordflow">for</span> end_value, edge, width <span class="keywordflow">in</span> zip(</div>
<div class="line"><span class="lineno">  220</span>            end_value_pair, edge_pair, width_pair</div>
<div class="line"><span class="lineno">  221</span>        )</div>
<div class="line"><span class="lineno">  222</span>    )</div>
<div class="line"><span class="lineno">  223</span>        </div>
<div class="line"><span class="lineno">  224</span>    <span class="comment"># Reverse linear space in appropriate dimension</span></div>
<div class="line"><span class="lineno">  225</span>    right_ramp = right_ramp[_slice_at_axis(slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, -1), axis)]</div>
<div class="line"><span class="lineno">  226</span> </div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">return</span> left_ramp, right_ramp</div>
<div class="line"><span class="lineno">  228</span> </div>
<div class="line"><span class="lineno">  229</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ddb7169260593afb561b47396788518" name="a3ddb7169260593afb561b47396788518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddb7169260593afb561b47396788518">&#9670;&#160;</a></span>_get_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._get_stats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stat_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate statistic for the empty-padded array in given dimension.

Parameters
----------
padded : ndarray
    Empty-padded array.
axis : int
    Dimension in which the statistic is calculated.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
length_pair : 2-element sequence of None or int
    Gives the number of values in valid area from each side that is
    taken into account when calculating the statistic. If None the entire
    valid area in `padded` is considered.
stat_func : function
    Function to compute statistic. The expected signature is
    ``stat_func(x: ndarray, axis: int, keepdims: bool) -&gt; ndarray``.

Returns
-------
left_stat, right_stat : ndarray
    Calculated statistic for both sides of `padded`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  230</span><span class="keyword">def </span>_get_stats(padded, axis, width_pair, length_pair, stat_func):</div>
<div class="line"><span class="lineno">  231</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    Calculate statistic for the empty-padded array in given dimension.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    padded : ndarray</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        Empty-padded array.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        Dimension in which the statistic is calculated.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    width_pair : (int, int)</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">        Pair of widths that mark the pad area on both sides in the given</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    length_pair : 2-element sequence of None or int</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        Gives the number of values in valid area from each side that is</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        taken into account when calculating the statistic. If None the entire</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">        valid area in `padded` is considered.</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    stat_func : function</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        Function to compute statistic. The expected signature is</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        ``stat_func(x: ndarray, axis: int, keepdims: bool) -&gt; ndarray``.</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    left_stat, right_stat : ndarray</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">        Calculated statistic for both sides of `padded`.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  256</span>    <span class="comment"># Calculate indices of the edges of the area with original values</span></div>
<div class="line"><span class="lineno">  257</span>    left_index = width_pair[0]</div>
<div class="line"><span class="lineno">  258</span>    right_index = padded.shape[axis] - width_pair[1]</div>
<div class="line"><span class="lineno">  259</span>    <span class="comment"># as well as its length</span></div>
<div class="line"><span class="lineno">  260</span>    max_length = right_index - left_index</div>
<div class="line"><span class="lineno">  261</span> </div>
<div class="line"><span class="lineno">  262</span>    <span class="comment"># Limit stat_lengths to max_length</span></div>
<div class="line"><span class="lineno">  263</span>    left_length, right_length = length_pair</div>
<div class="line"><span class="lineno">  264</span>    <span class="keywordflow">if</span> left_length <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> max_length &lt; left_length:</div>
<div class="line"><span class="lineno">  265</span>        left_length = max_length</div>
<div class="line"><span class="lineno">  266</span>    <span class="keywordflow">if</span> right_length <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> max_length &lt; right_length:</div>
<div class="line"><span class="lineno">  267</span>        right_length = max_length</div>
<div class="line"><span class="lineno">  268</span> </div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordflow">if</span> (left_length == 0 <span class="keywordflow">or</span> right_length == 0) \</div>
<div class="line"><span class="lineno">  270</span>            <span class="keywordflow">and</span> stat_func <span class="keywordflow">in</span> {np.amax, np.amin}:</div>
<div class="line"><span class="lineno">  271</span>        <span class="comment"># amax and amin can&#39;t operate on an empty array,</span></div>
<div class="line"><span class="lineno">  272</span>        <span class="comment"># raise a more descriptive warning here instead of the default one</span></div>
<div class="line"><span class="lineno">  273</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;stat_length of 0 yields no value for padding&quot;</span>)</div>
<div class="line"><span class="lineno">  274</span> </div>
<div class="line"><span class="lineno">  275</span>    <span class="comment"># Calculate statistic for the left side</span></div>
<div class="line"><span class="lineno">  276</span>    left_slice = _slice_at_axis(</div>
<div class="line"><span class="lineno">  277</span>        slice(left_index, left_index + left_length), axis)</div>
<div class="line"><span class="lineno">  278</span>    left_chunk = padded[left_slice]</div>
<div class="line"><span class="lineno">  279</span>    left_stat = stat_func(left_chunk, axis=axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  280</span>    _round_if_needed(left_stat, padded.dtype)</div>
<div class="line"><span class="lineno">  281</span> </div>
<div class="line"><span class="lineno">  282</span>    <span class="keywordflow">if</span> left_length == right_length == max_length:</div>
<div class="line"><span class="lineno">  283</span>        <span class="comment"># return early as right_stat must be identical to left_stat</span></div>
<div class="line"><span class="lineno">  284</span>        <span class="keywordflow">return</span> left_stat, left_stat</div>
<div class="line"><span class="lineno">  285</span> </div>
<div class="line"><span class="lineno">  286</span>    <span class="comment"># Calculate statistic for the right side</span></div>
<div class="line"><span class="lineno">  287</span>    right_slice = _slice_at_axis(</div>
<div class="line"><span class="lineno">  288</span>        slice(right_index - right_length, right_index), axis)</div>
<div class="line"><span class="lineno">  289</span>    right_chunk = padded[right_slice]</div>
<div class="line"><span class="lineno">  290</span>    right_stat = stat_func(right_chunk, axis=axis, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  291</span>    _round_if_needed(right_stat, padded.dtype)</div>
<div class="line"><span class="lineno">  292</span> </div>
<div class="line"><span class="lineno">  293</span>    <span class="keywordflow">return</span> left_stat, right_stat</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8dad4ff5561deb84a6922067d71ce93" name="ac8dad4ff5561deb84a6922067d71ce93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dad4ff5561deb84a6922067d71ce93">&#9670;&#160;</a></span>_pad_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._pad_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  521</span><span class="keyword">def </span>_pad_dispatcher(array, pad_width, mode=None, **kwargs):</div>
<div class="line"><span class="lineno">  522</span>    <span class="keywordflow">return</span> (array,)</div>
<div class="line"><span class="lineno">  523</span> </div>
<div class="line"><span class="lineno">  524</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a39919b9582e52a6ffafa42c81c1e1d60" name="a39919b9582e52a6ffafa42c81c1e1d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39919b9582e52a6ffafa42c81c1e1d60">&#9670;&#160;</a></span>_pad_simple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._pad_simple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pad array on all sides with either a single value or undefined values.

Parameters
----------
array : ndarray
    Array to grow.
pad_width : sequence of tuple[int, int]
    Pad width on both sides for each dimension in `arr`.
fill_value : scalar, optional
    If provided the padded area is filled with this value, otherwise
    the pad area left undefined.

Returns
-------
padded : ndarray
    The padded array with the same dtype as`array`. Its order will default
    to C-style if `array` is not F-contiguous.
original_area_slice : tuple
    A tuple of slices pointing to the area of the original array.
</pre> <div class="fragment"><div class="line"><span class="lineno">   86</span><span class="keyword">def </span>_pad_simple(array, pad_width, fill_value=None):</div>
<div class="line"><span class="lineno">   87</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    Pad array on all sides with either a single value or undefined values.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    array : ndarray</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        Array to grow.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    pad_width : sequence of tuple[int, int]</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        Pad width on both sides for each dimension in `arr`.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    fill_value : scalar, optional</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        If provided the padded area is filled with this value, otherwise</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        the pad area left undefined.</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    padded : ndarray</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        The padded array with the same dtype as`array`. Its order will default</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        to C-style if `array` is not F-contiguous.</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    original_area_slice : tuple</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        A tuple of slices pointing to the area of the original array.</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  108</span>    <span class="comment"># Allocate grown array</span></div>
<div class="line"><span class="lineno">  109</span>    new_shape = tuple(</div>
<div class="line"><span class="lineno">  110</span>        left + size + right</div>
<div class="line"><span class="lineno">  111</span>        <span class="keywordflow">for</span> size, (left, right) <span class="keywordflow">in</span> zip(array.shape, pad_width)</div>
<div class="line"><span class="lineno">  112</span>    )</div>
<div class="line"><span class="lineno">  113</span>    order = <span class="stringliteral">&#39;F&#39;</span> <span class="keywordflow">if</span> array.flags.fnc <span class="keywordflow">else</span> <span class="stringliteral">&#39;C&#39;</span>  <span class="comment"># Fortran and not also C-order</span></div>
<div class="line"><span class="lineno">  114</span>    padded = np.empty(new_shape, dtype=array.dtype, order=order)</div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span>    <span class="keywordflow">if</span> fill_value <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  117</span>        padded.fill(fill_value)</div>
<div class="line"><span class="lineno">  118</span> </div>
<div class="line"><span class="lineno">  119</span>    <span class="comment"># Copy old array into correct space</span></div>
<div class="line"><span class="lineno">  120</span>    original_area_slice = tuple(</div>
<div class="line"><span class="lineno">  121</span>        slice(left, left + size)</div>
<div class="line"><span class="lineno">  122</span>        <span class="keywordflow">for</span> size, (left, right) <span class="keywordflow">in</span> zip(array.shape, pad_width)</div>
<div class="line"><span class="lineno">  123</span>    )</div>
<div class="line"><span class="lineno">  124</span>    padded[original_area_slice] = array</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">return</span> padded, original_area_slice</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7460d8995330adb81edac72607c5f79" name="aa7460d8995330adb81edac72607c5f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7460d8995330adb81edac72607c5f79">&#9670;&#160;</a></span>_round_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._round_if_needed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private utility functions. </p>
<pre class="fragment">Rounds arr inplace if destination dtype is integer.

Parameters
----------
arr : ndarray
    Input array.
dtype : dtype
    The dtype of the destination array.
</pre> <div class="fragment"><div class="line"><span class="lineno">   18</span><span class="keyword">def </span>_round_if_needed(arr, dtype):</div>
<div class="line"><span class="lineno">   19</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral">    Rounds arr inplace if destination dtype is integer.</span></div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">    arr : ndarray</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    dtype : dtype</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">        The dtype of the destination array.</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   29</span>    <span class="keywordflow">if</span> np.issubdtype(dtype, np.integer):</div>
<div class="line"><span class="lineno">   30</span>        arr.round(out=arr)</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b1898525b60749417fc05922db9c872" name="a9b1898525b60749417fc05922db9c872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1898525b60749417fc05922db9c872">&#9670;&#160;</a></span>_set_pad_area()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._set_pad_area </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Set empty-padded area in given dimension.

Parameters
----------
padded : ndarray
    Array with the pad area which is modified inplace.
axis : int
    Dimension with the pad area to set.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
value_pair : tuple of scalars or ndarrays
    Values inserted into the pad area on each side. It must match or be
    broadcastable to the shape of `arr`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  129</span><span class="keyword">def </span>_set_pad_area(padded, axis, width_pair, value_pair):</div>
<div class="line"><span class="lineno">  130</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    Set empty-padded area in given dimension.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    padded : ndarray</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">        Array with the pad area which is modified inplace.</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">        Dimension with the pad area to set.</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    width_pair : (int, int)</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        Pair of widths that mark the pad area on both sides in the given</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    value_pair : tuple of scalars or ndarrays</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        Values inserted into the pad area on each side. It must match or be</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        broadcastable to the shape of `arr`.</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  146</span>    left_slice = _slice_at_axis(slice(<span class="keywordtype">None</span>, width_pair[0]), axis)</div>
<div class="line"><span class="lineno">  147</span>    padded[left_slice] = value_pair[0]</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>    right_slice = _slice_at_axis(</div>
<div class="line"><span class="lineno">  150</span>        slice(padded.shape[axis] - width_pair[1], <span class="keywordtype">None</span>), axis)</div>
<div class="line"><span class="lineno">  151</span>    padded[right_slice] = value_pair[1]</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a199e591eaea076f82376e77b7908be7f" name="a199e591eaea076f82376e77b7908be7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e591eaea076f82376e77b7908be7f">&#9670;&#160;</a></span>_set_reflect_both()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._set_reflect_both </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>include_edge</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pad `axis` of `arr` with reflection.

Parameters
----------
padded : ndarray
    Input array of arbitrary shape.
axis : int
    Axis along which to pad `arr`.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
method : str
    Controls method of reflection; options are 'even' or 'odd'.
include_edge : bool
    If true, edge value is included in reflection, otherwise the edge
    value forms the symmetric axis to the reflection.

Returns
-------
pad_amt : tuple of ints, length 2
    New index positions of padding to do along the `axis`. If these are
    both 0, padding is done in this dimension.
</pre> <div class="fragment"><div class="line"><span class="lineno">  296</span><span class="keyword">def </span>_set_reflect_both(padded, axis, width_pair, method, include_edge=False):</div>
<div class="line"><span class="lineno">  297</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    Pad `axis` of `arr` with reflection.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    padded : ndarray</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        Input array of arbitrary shape.</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        Axis along which to pad `arr`.</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">    width_pair : (int, int)</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        Pair of widths that mark the pad area on both sides in the given</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    method : str</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        Controls method of reflection; options are &#39;even&#39; or &#39;odd&#39;.</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    include_edge : bool</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        If true, edge value is included in reflection, otherwise the edge</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        value forms the symmetric axis to the reflection.</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    pad_amt : tuple of ints, length 2</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        New index positions of padding to do along the `axis`. If these are</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        both 0, padding is done in this dimension.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  321</span>    left_pad, right_pad = width_pair</div>
<div class="line"><span class="lineno">  322</span>    old_length = padded.shape[axis] - right_pad - left_pad</div>
<div class="line"><span class="lineno">  323</span> </div>
<div class="line"><span class="lineno">  324</span>    <span class="keywordflow">if</span> include_edge:</div>
<div class="line"><span class="lineno">  325</span>        <span class="comment"># Edge is included, we need to offset the pad amount by 1</span></div>
<div class="line"><span class="lineno">  326</span>        edge_offset = 1</div>
<div class="line"><span class="lineno">  327</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  328</span>        edge_offset = 0  <span class="comment"># Edge is not included, no need to offset pad amount</span></div>
<div class="line"><span class="lineno">  329</span>        old_length -= 1  <span class="comment"># but must be omitted from the chunk</span></div>
<div class="line"><span class="lineno">  330</span> </div>
<div class="line"><span class="lineno">  331</span>    <span class="keywordflow">if</span> left_pad &gt; 0:</div>
<div class="line"><span class="lineno">  332</span>        <span class="comment"># Pad with reflected values on left side:</span></div>
<div class="line"><span class="lineno">  333</span>        <span class="comment"># First limit chunk size which can&#39;t be larger than pad area</span></div>
<div class="line"><span class="lineno">  334</span>        chunk_length = min(old_length, left_pad)</div>
<div class="line"><span class="lineno">  335</span>        <span class="comment"># Slice right to left, stop on or next to edge, start relative to stop</span></div>
<div class="line"><span class="lineno">  336</span>        stop = left_pad - edge_offset</div>
<div class="line"><span class="lineno">  337</span>        start = stop + chunk_length</div>
<div class="line"><span class="lineno">  338</span>        left_slice = _slice_at_axis(slice(start, stop, -1), axis)</div>
<div class="line"><span class="lineno">  339</span>        left_chunk = padded[left_slice]</div>
<div class="line"><span class="lineno">  340</span> </div>
<div class="line"><span class="lineno">  341</span>        <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;odd&quot;</span>:</div>
<div class="line"><span class="lineno">  342</span>            <span class="comment"># Negate chunk and align with edge</span></div>
<div class="line"><span class="lineno">  343</span>            edge_slice = _slice_at_axis(slice(left_pad, left_pad + 1), axis)</div>
<div class="line"><span class="lineno">  344</span>            left_chunk = 2 * padded[edge_slice] - left_chunk</div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>        <span class="comment"># Insert chunk into padded area</span></div>
<div class="line"><span class="lineno">  347</span>        start = left_pad - chunk_length</div>
<div class="line"><span class="lineno">  348</span>        stop = left_pad</div>
<div class="line"><span class="lineno">  349</span>        pad_area = _slice_at_axis(slice(start, stop), axis)</div>
<div class="line"><span class="lineno">  350</span>        padded[pad_area] = left_chunk</div>
<div class="line"><span class="lineno">  351</span>        <span class="comment"># Adjust pointer to left edge for next iteration</span></div>
<div class="line"><span class="lineno">  352</span>        left_pad -= chunk_length</div>
<div class="line"><span class="lineno">  353</span> </div>
<div class="line"><span class="lineno">  354</span>    <span class="keywordflow">if</span> right_pad &gt; 0:</div>
<div class="line"><span class="lineno">  355</span>        <span class="comment"># Pad with reflected values on right side:</span></div>
<div class="line"><span class="lineno">  356</span>        <span class="comment"># First limit chunk size which can&#39;t be larger than pad area</span></div>
<div class="line"><span class="lineno">  357</span>        chunk_length = min(old_length, right_pad)</div>
<div class="line"><span class="lineno">  358</span>        <span class="comment"># Slice right to left, start on or next to edge, stop relative to start</span></div>
<div class="line"><span class="lineno">  359</span>        start = -right_pad + edge_offset - 2</div>
<div class="line"><span class="lineno">  360</span>        stop = start - chunk_length</div>
<div class="line"><span class="lineno">  361</span>        right_slice = _slice_at_axis(slice(start, stop, -1), axis)</div>
<div class="line"><span class="lineno">  362</span>        right_chunk = padded[right_slice]</div>
<div class="line"><span class="lineno">  363</span> </div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;odd&quot;</span>:</div>
<div class="line"><span class="lineno">  365</span>            <span class="comment"># Negate chunk and align with edge</span></div>
<div class="line"><span class="lineno">  366</span>            edge_slice = _slice_at_axis(</div>
<div class="line"><span class="lineno">  367</span>                slice(-right_pad - 1, -right_pad), axis)</div>
<div class="line"><span class="lineno">  368</span>            right_chunk = 2 * padded[edge_slice] - right_chunk</div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>        <span class="comment"># Insert chunk into padded area</span></div>
<div class="line"><span class="lineno">  371</span>        start = padded.shape[axis] - right_pad</div>
<div class="line"><span class="lineno">  372</span>        stop = start + chunk_length</div>
<div class="line"><span class="lineno">  373</span>        pad_area = _slice_at_axis(slice(start, stop), axis)</div>
<div class="line"><span class="lineno">  374</span>        padded[pad_area] = right_chunk</div>
<div class="line"><span class="lineno">  375</span>        <span class="comment"># Adjust pointer to right edge for next iteration</span></div>
<div class="line"><span class="lineno">  376</span>        right_pad -= chunk_length</div>
<div class="line"><span class="lineno">  377</span> </div>
<div class="line"><span class="lineno">  378</span>    <span class="keywordflow">return</span> left_pad, right_pad</div>
<div class="line"><span class="lineno">  379</span> </div>
<div class="line"><span class="lineno">  380</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a05f36bcd36dba7a7e94526686871fc14" name="a05f36bcd36dba7a7e94526686871fc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f36bcd36dba7a7e94526686871fc14">&#9670;&#160;</a></span>_set_wrap_both()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._set_wrap_both </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pad `axis` of `arr` with wrapped values.

Parameters
----------
padded : ndarray
    Input array of arbitrary shape.
axis : int
    Axis along which to pad `arr`.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.

Returns
-------
pad_amt : tuple of ints, length 2
    New index positions of padding to do along the `axis`. If these are
    both 0, padding is done in this dimension.
</pre> <div class="fragment"><div class="line"><span class="lineno">  381</span><span class="keyword">def </span>_set_wrap_both(padded, axis, width_pair):</div>
<div class="line"><span class="lineno">  382</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    Pad `axis` of `arr` with wrapped values.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    padded : ndarray</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">        Input array of arbitrary shape.</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">        Axis along which to pad `arr`.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    width_pair : (int, int)</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">        Pair of widths that mark the pad area on both sides in the given</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">        dimension.</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    pad_amt : tuple of ints, length 2</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        New index positions of padding to do along the `axis`. If these are</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        both 0, padding is done in this dimension.</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  401</span>    left_pad, right_pad = width_pair</div>
<div class="line"><span class="lineno">  402</span>    period = padded.shape[axis] - right_pad - left_pad</div>
<div class="line"><span class="lineno">  403</span> </div>
<div class="line"><span class="lineno">  404</span>    <span class="comment"># If the current dimension of `arr` doesn&#39;t contain enough valid values</span></div>
<div class="line"><span class="lineno">  405</span>    <span class="comment"># (not part of the undefined pad area) we need to pad multiple times.</span></div>
<div class="line"><span class="lineno">  406</span>    <span class="comment"># Each time the pad area shrinks on both sides which is communicated with</span></div>
<div class="line"><span class="lineno">  407</span>    <span class="comment"># these variables.</span></div>
<div class="line"><span class="lineno">  408</span>    new_left_pad = 0</div>
<div class="line"><span class="lineno">  409</span>    new_right_pad = 0</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">if</span> left_pad &gt; 0:</div>
<div class="line"><span class="lineno">  412</span>        <span class="comment"># Pad with wrapped values on left side</span></div>
<div class="line"><span class="lineno">  413</span>        <span class="comment"># First slice chunk from right side of the non-pad area.</span></div>
<div class="line"><span class="lineno">  414</span>        <span class="comment"># Use min(period, left_pad) to ensure that chunk is not larger than</span></div>
<div class="line"><span class="lineno">  415</span>        <span class="comment"># pad area</span></div>
<div class="line"><span class="lineno">  416</span>        right_slice = _slice_at_axis(</div>
<div class="line"><span class="lineno">  417</span>            slice(-right_pad - min(period, left_pad),</div>
<div class="line"><span class="lineno">  418</span>                  -right_pad <span class="keywordflow">if</span> right_pad != 0 <span class="keywordflow">else</span> <span class="keywordtype">None</span>),</div>
<div class="line"><span class="lineno">  419</span>            axis</div>
<div class="line"><span class="lineno">  420</span>        )</div>
<div class="line"><span class="lineno">  421</span>        right_chunk = padded[right_slice]</div>
<div class="line"><span class="lineno">  422</span> </div>
<div class="line"><span class="lineno">  423</span>        <span class="keywordflow">if</span> left_pad &gt; period:</div>
<div class="line"><span class="lineno">  424</span>            <span class="comment"># Chunk is smaller than pad area</span></div>
<div class="line"><span class="lineno">  425</span>            pad_area = _slice_at_axis(slice(left_pad - period, left_pad), axis)</div>
<div class="line"><span class="lineno">  426</span>            new_left_pad = left_pad - period</div>
<div class="line"><span class="lineno">  427</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  428</span>            <span class="comment"># Chunk matches pad area</span></div>
<div class="line"><span class="lineno">  429</span>            pad_area = _slice_at_axis(slice(<span class="keywordtype">None</span>, left_pad), axis)</div>
<div class="line"><span class="lineno">  430</span>        padded[pad_area] = right_chunk</div>
<div class="line"><span class="lineno">  431</span> </div>
<div class="line"><span class="lineno">  432</span>    <span class="keywordflow">if</span> right_pad &gt; 0:</div>
<div class="line"><span class="lineno">  433</span>        <span class="comment"># Pad with wrapped values on right side</span></div>
<div class="line"><span class="lineno">  434</span>        <span class="comment"># First slice chunk from left side of the non-pad area.</span></div>
<div class="line"><span class="lineno">  435</span>        <span class="comment"># Use min(period, right_pad) to ensure that chunk is not larger than</span></div>
<div class="line"><span class="lineno">  436</span>        <span class="comment"># pad area</span></div>
<div class="line"><span class="lineno">  437</span>        left_slice = _slice_at_axis(</div>
<div class="line"><span class="lineno">  438</span>            slice(left_pad, left_pad + min(period, right_pad),), axis)</div>
<div class="line"><span class="lineno">  439</span>        left_chunk = padded[left_slice]</div>
<div class="line"><span class="lineno">  440</span> </div>
<div class="line"><span class="lineno">  441</span>        <span class="keywordflow">if</span> right_pad &gt; period:</div>
<div class="line"><span class="lineno">  442</span>            <span class="comment"># Chunk is smaller than pad area</span></div>
<div class="line"><span class="lineno">  443</span>            pad_area = _slice_at_axis(</div>
<div class="line"><span class="lineno">  444</span>                slice(-right_pad, -right_pad + period), axis)</div>
<div class="line"><span class="lineno">  445</span>            new_right_pad = right_pad - period</div>
<div class="line"><span class="lineno">  446</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  447</span>            <span class="comment"># Chunk matches pad area</span></div>
<div class="line"><span class="lineno">  448</span>            pad_area = _slice_at_axis(slice(-right_pad, <span class="keywordtype">None</span>), axis)</div>
<div class="line"><span class="lineno">  449</span>        padded[pad_area] = left_chunk</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">return</span> new_left_pad, new_right_pad</div>
<div class="line"><span class="lineno">  452</span> </div>
<div class="line"><span class="lineno">  453</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02c6a68eb64f5bb61960e803dd07c884" name="a02c6a68eb64f5bb61960e803dd07c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c6a68eb64f5bb61960e803dd07c884">&#9670;&#160;</a></span>_slice_at_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._slice_at_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Construct tuple of slices to slice an array in the given dimension.

Parameters
----------
sl : slice
    The slice for the given dimension.
axis : int
    The axis to which `sl` is applied. All other dimensions are left
    "unsliced".

Returns
-------
sl : tuple of slices
    A tuple with slices matching `shape` in length.

Examples
--------
&gt;&gt;&gt; _slice_at_axis(slice(None, 3, -1), 1)
(slice(None, None, None), slice(None, 3, -1), (...,))
</pre> <div class="fragment"><div class="line"><span class="lineno">   33</span><span class="keyword">def </span>_slice_at_axis(sl, axis):</div>
<div class="line"><span class="lineno">   34</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    Construct tuple of slices to slice an array in the given dimension.</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    sl : slice</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        The slice for the given dimension.</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        The axis to which `sl` is applied. All other dimensions are left</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        &quot;unsliced&quot;.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    sl : tuple of slices</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">        A tuple with slices matching `shape` in length.</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    &gt;&gt;&gt; _slice_at_axis(slice(None, 3, -1), 1)</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    (slice(None, None, None), slice(None, 3, -1), (...,))</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">return</span> (slice(<span class="keywordtype">None</span>),) * axis + (sl,) + (...,)</div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a14ce2ba54b8417fc3a481a4c5ba69cd6" name="a14ce2ba54b8417fc3a481a4c5ba69cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ce2ba54b8417fc3a481a4c5ba69cd6">&#9670;&#160;</a></span>_view_roi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad._view_roi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>original_area_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get a view of the current region of interest during iterative padding.

When padding multiple dimensions iteratively corner values are
unnecessarily overwritten multiple times. This function reduces the
working area for the first dimensions so that corners are excluded.

Parameters
----------
array : ndarray
    The array with the region of interest.
original_area_slice : tuple of slices
    Denotes the area with original values of the unpadded array.
axis : int
    The currently padded dimension assuming that `axis` is padded before
    `axis` + 1.

Returns
-------
roi : ndarray
    The region of interest of the original `array`.
</pre> <div class="fragment"><div class="line"><span class="lineno">   58</span><span class="keyword">def </span>_view_roi(array, original_area_slice, axis):</div>
<div class="line"><span class="lineno">   59</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    Get a view of the current region of interest during iterative padding.</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    When padding multiple dimensions iteratively corner values are</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    unnecessarily overwritten multiple times. This function reduces the</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    working area for the first dimensions so that corners are excluded.</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    array : ndarray</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">        The array with the region of interest.</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    original_area_slice : tuple of slices</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">        Denotes the area with original values of the unpadded array.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    axis : int</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">        The currently padded dimension assuming that `axis` is padded before</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">        `axis` + 1.</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    roi : ndarray</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">        The region of interest of the original `array`.</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   81</span>    axis += 1</div>
<div class="line"><span class="lineno">   82</span>    sl = (slice(<span class="keywordtype">None</span>),) * axis + original_area_slice[axis:]</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">return</span> array[sl]</div>
<div class="line"><span class="lineno">   84</span> </div>
<div class="line"><span class="lineno">   85</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a03f6ba7ccefaab37a09357632bdcd7b7" name="a03f6ba7ccefaab37a09357632bdcd7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f6ba7ccefaab37a09357632bdcd7b7">&#9670;&#160;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.arraypad.pad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'constant'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public functions. </p>
<pre class="fragment">Pad an array.

Parameters
----------
array : array_like of rank N
    The array to pad.
pad_width : {sequence, array_like, int}
    Number of values padded to the edges of each axis.
    ``((before_1, after_1), ... (before_N, after_N))`` unique pad widths
    for each axis.
    ``(before, after)`` or ``((before, after),)`` yields same before
    and after pad for each axis.
    ``(pad,)`` or ``int`` is a shortcut for before = after = pad width
    for all axes.
mode : str or function, optional
    One of the following string values or a user supplied function.

    'constant' (default)
        Pads with a constant value.
    'edge'
        Pads with the edge values of array.
    'linear_ramp'
        Pads with the linear ramp between end_value and the
        array edge value.
    'maximum'
        Pads with the maximum value of all or part of the
        vector along each axis.
    'mean'
        Pads with the mean value of all or part of the
        vector along each axis.
    'median'
        Pads with the median value of all or part of the
        vector along each axis.
    'minimum'
        Pads with the minimum value of all or part of the
        vector along each axis.
    'reflect'
        Pads with the reflection of the vector mirrored on
        the first and last values of the vector along each
        axis.
    'symmetric'
        Pads with the reflection of the vector mirrored
        along the edge of the array.
    'wrap'
        Pads with the wrap of the vector along the axis.
        The first values are used to pad the end and the
        end values are used to pad the beginning.
    'empty'
        Pads with undefined values.

        .. versionadded:: 1.17

    &lt;function&gt;
        Padding function, see Notes.
stat_length : sequence or int, optional
    Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of
    values at edge of each axis used to calculate the statistic value.

    ``((before_1, after_1), ... (before_N, after_N))`` unique statistic
    lengths for each axis.

    ``(before, after)`` or ``((before, after),)`` yields same before
    and after statistic lengths for each axis.

    ``(stat_length,)`` or ``int`` is a shortcut for
    ``before = after = statistic`` length for all axes.

    Default is ``None``, to use the entire axis.
constant_values : sequence or scalar, optional
    Used in 'constant'.  The values to set the padded values for each
    axis.

    ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants
    for each axis.

    ``(before, after)`` or ``((before, after),)`` yields same before
    and after constants for each axis.

    ``(constant,)`` or ``constant`` is a shortcut for
    ``before = after = constant`` for all axes.

    Default is 0.
end_values : sequence or scalar, optional
    Used in 'linear_ramp'.  The values used for the ending value of the
    linear_ramp and that will form the edge of the padded array.

    ``((before_1, after_1), ... (before_N, after_N))`` unique end values
    for each axis.

    ``(before, after)`` or ``((before, after),)`` yields same before
    and after end values for each axis.

    ``(constant,)`` or ``constant`` is a shortcut for
    ``before = after = constant`` for all axes.

    Default is 0.
reflect_type : {'even', 'odd'}, optional
    Used in 'reflect', and 'symmetric'.  The 'even' style is the
    default with an unaltered reflection around the edge value.  For
    the 'odd' style, the extended part of the array is created by
    subtracting the reflected values from two times the edge value.

Returns
-------
pad : ndarray
    Padded array of rank equal to `array` with shape increased
    according to `pad_width`.

Notes
-----
.. versionadded:: 1.7.0

For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.

The padding function, if used, should modify a rank 1 array in-place. It
has the following signature::

    padding_func(vector, iaxis_pad_width, iaxis, kwargs)

where

    vector : ndarray
        A rank 1 array already padded with zeros.  Padded values are
        vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].
    iaxis_pad_width : tuple
        A 2-tuple of ints, iaxis_pad_width[0] represents the number of
        values padded at the beginning of vector where
        iaxis_pad_width[1] represents the number of values padded at
        the end of vector.
    iaxis : int
        The axis currently being calculated.
    kwargs : dict
        Any keyword arguments the function requires.

Examples
--------
&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; np.pad(a, (2, 3), 'constant', constant_values=(4, 6))
array([4, 4, 1, ..., 6, 6, 6])

&gt;&gt;&gt; np.pad(a, (2, 3), 'edge')
array([1, 1, 1, ..., 5, 5, 5])

&gt;&gt;&gt; np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])

&gt;&gt;&gt; np.pad(a, (2,), 'maximum')
array([5, 5, 1, 2, 3, 4, 5, 5, 5])

&gt;&gt;&gt; np.pad(a, (2,), 'mean')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

&gt;&gt;&gt; np.pad(a, (2,), 'median')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

&gt;&gt;&gt; a = [[1, 2], [3, 4]]
&gt;&gt;&gt; np.pad(a, ((3, 2), (2, 3)), 'minimum')
array([[1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [3, 3, 3, 4, 3, 3, 3],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1]])

&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect')
array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])

&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect', reflect_type='odd')
array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])

&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric')
array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])

&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])

&gt;&gt;&gt; np.pad(a, (2, 3), 'wrap')
array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])

&gt;&gt;&gt; def pad_with(vector, pad_width, iaxis, kwargs):
...     pad_value = kwargs.get('padder', 10)
...     vector[:pad_width[0]] = pad_value
...     vector[-pad_width[1]:] = pad_value
&gt;&gt;&gt; a = np.arange(6)
&gt;&gt;&gt; a = a.reshape((2, 3))
&gt;&gt;&gt; np.pad(a, 2, pad_with)
array([[10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10,  0,  1,  2, 10, 10],
       [10, 10,  3,  4,  5, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10]])
&gt;&gt;&gt; np.pad(a, 2, pad_with, padder=100)
array([[100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100,   0,   1,   2, 100, 100],
       [100, 100,   3,   4,   5, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  530</span><span class="keyword">def </span>pad(array, pad_width, mode=&#39;constant&#39;, **kwargs):</div>
<div class="line"><span class="lineno">  531</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    Pad an array.</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    array : array_like of rank N</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">        The array to pad.</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    pad_width : {sequence, array_like, int}</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">        Number of values padded to the edges of each axis.</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">        ``((before_1, after_1), ... (before_N, after_N))`` unique pad widths</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        for each axis.</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        ``(before, after)`` or ``((before, after),)`` yields same before</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        and after pad for each axis.</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">        ``(pad,)`` or ``int`` is a shortcut for before = after = pad width</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">        for all axes.</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    mode : str or function, optional</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">        One of the following string values or a user supplied function.</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        &#39;constant&#39; (default)</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">            Pads with a constant value.</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        &#39;edge&#39;</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">            Pads with the edge values of array.</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        &#39;linear_ramp&#39;</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">            Pads with the linear ramp between end_value and the</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">            array edge value.</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">        &#39;maximum&#39;</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">            Pads with the maximum value of all or part of the</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">            vector along each axis.</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        &#39;mean&#39;</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">            Pads with the mean value of all or part of the</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">            vector along each axis.</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">        &#39;median&#39;</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">            Pads with the median value of all or part of the</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">            vector along each axis.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">        &#39;minimum&#39;</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">            Pads with the minimum value of all or part of the</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">            vector along each axis.</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">        &#39;reflect&#39;</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">            Pads with the reflection of the vector mirrored on</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">            the first and last values of the vector along each</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">            axis.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        &#39;symmetric&#39;</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">            Pads with the reflection of the vector mirrored</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">            along the edge of the array.</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">        &#39;wrap&#39;</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">            Pads with the wrap of the vector along the axis.</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">            The first values are used to pad the end and the</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">            end values are used to pad the beginning.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        &#39;empty&#39;</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">            Pads with undefined values.</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">            .. versionadded:: 1.17</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">        &lt;function&gt;</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">            Padding function, see Notes.</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    stat_length : sequence or int, optional</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        Used in &#39;maximum&#39;, &#39;mean&#39;, &#39;median&#39;, and &#39;minimum&#39;.  Number of</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">        values at edge of each axis used to calculate the statistic value.</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">        ``((before_1, after_1), ... (before_N, after_N))`` unique statistic</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        lengths for each axis.</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        ``(before, after)`` or ``((before, after),)`` yields same before</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        and after statistic lengths for each axis.</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        ``(stat_length,)`` or ``int`` is a shortcut for</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        ``before = after = statistic`` length for all axes.</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        Default is ``None``, to use the entire axis.</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    constant_values : sequence or scalar, optional</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        Used in &#39;constant&#39;.  The values to set the padded values for each</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">        axis.</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        for each axis.</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">        ``(before, after)`` or ``((before, after),)`` yields same before</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">        and after constants for each axis.</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">        ``(constant,)`` or ``constant`` is a shortcut for</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">        ``before = after = constant`` for all axes.</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">        Default is 0.</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    end_values : sequence or scalar, optional</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        Used in &#39;linear_ramp&#39;.  The values used for the ending value of the</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">        linear_ramp and that will form the edge of the padded array.</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">        ``((before_1, after_1), ... (before_N, after_N))`` unique end values</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">        for each axis.</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        ``(before, after)`` or ``((before, after),)`` yields same before</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">        and after end values for each axis.</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral">        ``(constant,)`` or ``constant`` is a shortcut for</span></div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">        ``before = after = constant`` for all axes.</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">        Default is 0.</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    reflect_type : {&#39;even&#39;, &#39;odd&#39;}, optional</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral">        Used in &#39;reflect&#39;, and &#39;symmetric&#39;.  The &#39;even&#39; style is the</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">        default with an unaltered reflection around the edge value.  For</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">        the &#39;odd&#39; style, the extended part of the array is created by</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">        subtracting the reflected values from two times the edge value.</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    pad : ndarray</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        Padded array of rank equal to `array` with shape increased</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">        according to `pad_width`.</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    For an array with rank greater than 1, some of the padding of later</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    axes is calculated from padding of previous axes.  This is easiest to</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    think about with a rank 2 array where the corners of the padded array</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    are calculated by using padded values from the first axis.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    The padding function, if used, should modify a rank 1 array in-place. It</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    has the following signature::</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        padding_func(vector, iaxis_pad_width, iaxis, kwargs)</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    where</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        vector : ndarray</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">            A rank 1 array already padded with zeros.  Padded values are</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">            vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        iaxis_pad_width : tuple</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">            A 2-tuple of ints, iaxis_pad_width[0] represents the number of</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">            values padded at the beginning of vector where</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">            iaxis_pad_width[1] represents the number of values padded at</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">            the end of vector.</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">        iaxis : int</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">            The axis currently being calculated.</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">        kwargs : dict</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">            Any keyword arguments the function requires.</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    &gt;&gt;&gt; a = [1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;constant&#39;, constant_values=(4, 6))</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    array([4, 4, 1, ..., 6, 6, 6])</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;edge&#39;)</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    array([1, 1, 1, ..., 5, 5, 5])</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;linear_ramp&#39;, end_values=(5, -4))</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2,), &#39;maximum&#39;)</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2,), &#39;mean&#39;)</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">    array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2,), &#39;median&#39;)</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    &gt;&gt;&gt; a = [[1, 2], [3, 4]]</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, ((3, 2), (2, 3)), &#39;minimum&#39;)</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    array([[1, 1, 1, 2, 1, 1, 1],</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">           [1, 1, 1, 2, 1, 1, 1],</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">           [1, 1, 1, 2, 1, 1, 1],</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">           [1, 1, 1, 2, 1, 1, 1],</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">           [3, 3, 3, 4, 3, 3, 3],</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">           [1, 1, 1, 2, 1, 1, 1],</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">           [1, 1, 1, 2, 1, 1, 1]])</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    &gt;&gt;&gt; a = [1, 2, 3, 4, 5]</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;reflect&#39;)</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;reflect&#39;, reflect_type=&#39;odd&#39;)</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;symmetric&#39;)</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;symmetric&#39;, reflect_type=&#39;odd&#39;)</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;wrap&#39;)</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    &gt;&gt;&gt; def pad_with(vector, pad_width, iaxis, kwargs):</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">    ...     pad_value = kwargs.get(&#39;padder&#39;, 10)</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    ...     vector[:pad_width[0]] = pad_value</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    ...     vector[-pad_width[1]:] = pad_value</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(6)</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    &gt;&gt;&gt; a = a.reshape((2, 3))</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, 2, pad_with)</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    array([[10, 10, 10, 10, 10, 10, 10],</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">           [10, 10, 10, 10, 10, 10, 10],</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">           [10, 10,  0,  1,  2, 10, 10],</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">           [10, 10,  3,  4,  5, 10, 10],</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">           [10, 10, 10, 10, 10, 10, 10],</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">           [10, 10, 10, 10, 10, 10, 10]])</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    &gt;&gt;&gt; np.pad(a, 2, pad_with, padder=100)</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    array([[100, 100, 100, 100, 100, 100, 100],</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">           [100, 100, 100, 100, 100, 100, 100],</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">           [100, 100,   0,   1,   2, 100, 100],</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">           [100, 100,   3,   4,   5, 100, 100],</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">           [100, 100, 100, 100, 100, 100, 100],</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">           [100, 100, 100, 100, 100, 100, 100]])</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  737</span>    array = np.asarray(array)</div>
<div class="line"><span class="lineno">  738</span>    pad_width = np.asarray(pad_width)</div>
<div class="line"><span class="lineno">  739</span> </div>
<div class="line"><span class="lineno">  740</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> pad_width.dtype.kind == <span class="stringliteral">&#39;i&#39;</span>:</div>
<div class="line"><span class="lineno">  741</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&#39;`pad_width` must be of integral type.&#39;</span>)</div>
<div class="line"><span class="lineno">  742</span> </div>
<div class="line"><span class="lineno">  743</span>    <span class="comment"># Broadcast to shape (array.ndim, 2)</span></div>
<div class="line"><span class="lineno">  744</span>    pad_width = _as_pairs(pad_width, array.ndim, as_index=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  745</span> </div>
<div class="line"><span class="lineno">  746</span>    <span class="keywordflow">if</span> callable(mode):</div>
<div class="line"><span class="lineno">  747</span>        <span class="comment"># Old behavior: Use user-supplied function with np.apply_along_axis</span></div>
<div class="line"><span class="lineno">  748</span>        function = mode</div>
<div class="line"><span class="lineno">  749</span>        <span class="comment"># Create a new zero padded array</span></div>
<div class="line"><span class="lineno">  750</span>        padded, _ = _pad_simple(array, pad_width, fill_value=0)</div>
<div class="line"><span class="lineno">  751</span>        <span class="comment"># And apply along each axis</span></div>
<div class="line"><span class="lineno">  752</span> </div>
<div class="line"><span class="lineno">  753</span>        <span class="keywordflow">for</span> axis <span class="keywordflow">in</span> range(padded.ndim):</div>
<div class="line"><span class="lineno">  754</span>            <span class="comment"># Iterate using ndindex as in apply_along_axis, but assuming that</span></div>
<div class="line"><span class="lineno">  755</span>            <span class="comment"># function operates inplace on the padded array.</span></div>
<div class="line"><span class="lineno">  756</span> </div>
<div class="line"><span class="lineno">  757</span>            <span class="comment"># view with the iteration axis at the end</span></div>
<div class="line"><span class="lineno">  758</span>            view = np.moveaxis(padded, axis, -1)</div>
<div class="line"><span class="lineno">  759</span> </div>
<div class="line"><span class="lineno">  760</span>            <span class="comment"># compute indices for the iteration axes, and append a trailing</span></div>
<div class="line"><span class="lineno">  761</span>            <span class="comment"># ellipsis to prevent 0d arrays decaying to scalars (gh-8642)</span></div>
<div class="line"><span class="lineno">  762</span>            inds = ndindex(view.shape[:-1])</div>
<div class="line"><span class="lineno">  763</span>            inds = (ind + (Ellipsis,) <span class="keywordflow">for</span> ind <span class="keywordflow">in</span> inds)</div>
<div class="line"><span class="lineno">  764</span>            <span class="keywordflow">for</span> ind <span class="keywordflow">in</span> inds:</div>
<div class="line"><span class="lineno">  765</span>                function(view[ind], pad_width[axis], axis, kwargs)</div>
<div class="line"><span class="lineno">  766</span> </div>
<div class="line"><span class="lineno">  767</span>        <span class="keywordflow">return</span> padded</div>
<div class="line"><span class="lineno">  768</span> </div>
<div class="line"><span class="lineno">  769</span>    <span class="comment"># Make sure that no unsupported keywords were passed for the current mode</span></div>
<div class="line"><span class="lineno">  770</span>    allowed_kwargs = {</div>
<div class="line"><span class="lineno">  771</span>        <span class="stringliteral">&#39;empty&#39;</span>: [], <span class="stringliteral">&#39;edge&#39;</span>: [], <span class="stringliteral">&#39;wrap&#39;</span>: [],</div>
<div class="line"><span class="lineno">  772</span>        <span class="stringliteral">&#39;constant&#39;</span>: [<span class="stringliteral">&#39;constant_values&#39;</span>],</div>
<div class="line"><span class="lineno">  773</span>        <span class="stringliteral">&#39;linear_ramp&#39;</span>: [<span class="stringliteral">&#39;end_values&#39;</span>],</div>
<div class="line"><span class="lineno">  774</span>        <span class="stringliteral">&#39;maximum&#39;</span>: [<span class="stringliteral">&#39;stat_length&#39;</span>],</div>
<div class="line"><span class="lineno">  775</span>        <span class="stringliteral">&#39;mean&#39;</span>: [<span class="stringliteral">&#39;stat_length&#39;</span>],</div>
<div class="line"><span class="lineno">  776</span>        <span class="stringliteral">&#39;median&#39;</span>: [<span class="stringliteral">&#39;stat_length&#39;</span>],</div>
<div class="line"><span class="lineno">  777</span>        <span class="stringliteral">&#39;minimum&#39;</span>: [<span class="stringliteral">&#39;stat_length&#39;</span>],</div>
<div class="line"><span class="lineno">  778</span>        <span class="stringliteral">&#39;reflect&#39;</span>: [<span class="stringliteral">&#39;reflect_type&#39;</span>],</div>
<div class="line"><span class="lineno">  779</span>        <span class="stringliteral">&#39;symmetric&#39;</span>: [<span class="stringliteral">&#39;reflect_type&#39;</span>],</div>
<div class="line"><span class="lineno">  780</span>    }</div>
<div class="line"><span class="lineno">  781</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  782</span>        unsupported_kwargs = set(kwargs) - set(allowed_kwargs[mode])</div>
<div class="line"><span class="lineno">  783</span>    <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno">  784</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;mode &#39;{}&#39; is not supported&quot;</span>.format(mode)) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  785</span>    <span class="keywordflow">if</span> unsupported_kwargs:</div>
<div class="line"><span class="lineno">  786</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;unsupported keyword arguments for mode &#39;{}&#39;: {}&quot;</span></div>
<div class="line"><span class="lineno">  787</span>                         .format(mode, unsupported_kwargs))</div>
<div class="line"><span class="lineno">  788</span> </div>
<div class="line"><span class="lineno">  789</span>    stat_functions = {<span class="stringliteral">&quot;maximum&quot;</span>: np.amax, <span class="stringliteral">&quot;minimum&quot;</span>: np.amin,</div>
<div class="line"><span class="lineno">  790</span>                      <span class="stringliteral">&quot;mean&quot;</span>: np.mean, <span class="stringliteral">&quot;median&quot;</span>: np.median}</div>
<div class="line"><span class="lineno">  791</span> </div>
<div class="line"><span class="lineno">  792</span>    <span class="comment"># Create array with final shape and original values</span></div>
<div class="line"><span class="lineno">  793</span>    <span class="comment"># (padded area is undefined)</span></div>
<div class="line"><span class="lineno">  794</span>    padded, original_area_slice = _pad_simple(array, pad_width)</div>
<div class="line"><span class="lineno">  795</span>    <span class="comment"># And prepare iteration over all dimensions</span></div>
<div class="line"><span class="lineno">  796</span>    <span class="comment"># (zipping may be more readable than using enumerate)</span></div>
<div class="line"><span class="lineno">  797</span>    axes = range(padded.ndim)</div>
<div class="line"><span class="lineno">  798</span> </div>
<div class="line"><span class="lineno">  799</span>    <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;constant&quot;</span>:</div>
<div class="line"><span class="lineno">  800</span>        values = kwargs.get(<span class="stringliteral">&quot;constant_values&quot;</span>, 0)</div>
<div class="line"><span class="lineno">  801</span>        values = _as_pairs(values, padded.ndim)</div>
<div class="line"><span class="lineno">  802</span>        <span class="keywordflow">for</span> axis, width_pair, value_pair <span class="keywordflow">in</span> zip(axes, pad_width, values):</div>
<div class="line"><span class="lineno">  803</span>            roi = _view_roi(padded, original_area_slice, axis)</div>
<div class="line"><span class="lineno">  804</span>            _set_pad_area(roi, axis, width_pair, value_pair)</div>
<div class="line"><span class="lineno">  805</span> </div>
<div class="line"><span class="lineno">  806</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;empty&quot;</span>:</div>
<div class="line"><span class="lineno">  807</span>        <span class="keywordflow">pass</span>  <span class="comment"># Do nothing as _pad_simple already returned the correct result</span></div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>    <span class="keywordflow">elif</span> array.size == 0:</div>
<div class="line"><span class="lineno">  810</span>        <span class="comment"># Only modes &quot;constant&quot; and &quot;empty&quot; can extend empty axes, all other</span></div>
<div class="line"><span class="lineno">  811</span>        <span class="comment"># modes depend on `array` not being empty</span></div>
<div class="line"><span class="lineno">  812</span>        <span class="comment"># -&gt; ensure every empty axis is only &quot;padded with 0&quot;</span></div>
<div class="line"><span class="lineno">  813</span>        <span class="keywordflow">for</span> axis, width_pair <span class="keywordflow">in</span> zip(axes, pad_width):</div>
<div class="line"><span class="lineno">  814</span>            <span class="keywordflow">if</span> array.shape[axis] == 0 <span class="keywordflow">and</span> any(width_pair):</div>
<div class="line"><span class="lineno">  815</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  816</span>                    <span class="stringliteral">&quot;can&#39;t extend empty axis {} using modes other than &quot;</span></div>
<div class="line"><span class="lineno">  817</span>                    <span class="stringliteral">&quot;&#39;constant&#39; or &#39;empty&#39;&quot;</span>.format(axis)</div>
<div class="line"><span class="lineno">  818</span>                )</div>
<div class="line"><span class="lineno">  819</span>        <span class="comment"># passed, don&#39;t need to do anything more as _pad_simple already</span></div>
<div class="line"><span class="lineno">  820</span>        <span class="comment"># returned the correct result</span></div>
<div class="line"><span class="lineno">  821</span> </div>
<div class="line"><span class="lineno">  822</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;edge&quot;</span>:</div>
<div class="line"><span class="lineno">  823</span>        <span class="keywordflow">for</span> axis, width_pair <span class="keywordflow">in</span> zip(axes, pad_width):</div>
<div class="line"><span class="lineno">  824</span>            roi = _view_roi(padded, original_area_slice, axis)</div>
<div class="line"><span class="lineno">  825</span>            edge_pair = _get_edges(roi, axis, width_pair)</div>
<div class="line"><span class="lineno">  826</span>            _set_pad_area(roi, axis, width_pair, edge_pair)</div>
<div class="line"><span class="lineno">  827</span> </div>
<div class="line"><span class="lineno">  828</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;linear_ramp&quot;</span>:</div>
<div class="line"><span class="lineno">  829</span>        end_values = kwargs.get(<span class="stringliteral">&quot;end_values&quot;</span>, 0)</div>
<div class="line"><span class="lineno">  830</span>        end_values = _as_pairs(end_values, padded.ndim)</div>
<div class="line"><span class="lineno">  831</span>        <span class="keywordflow">for</span> axis, width_pair, value_pair <span class="keywordflow">in</span> zip(axes, pad_width, end_values):</div>
<div class="line"><span class="lineno">  832</span>            roi = _view_roi(padded, original_area_slice, axis)</div>
<div class="line"><span class="lineno">  833</span>            ramp_pair = _get_linear_ramps(roi, axis, width_pair, value_pair)</div>
<div class="line"><span class="lineno">  834</span>            _set_pad_area(roi, axis, width_pair, ramp_pair)</div>
<div class="line"><span class="lineno">  835</span> </div>
<div class="line"><span class="lineno">  836</span>    <span class="keywordflow">elif</span> mode <span class="keywordflow">in</span> stat_functions:</div>
<div class="line"><span class="lineno">  837</span>        func = stat_functions[mode]</div>
<div class="line"><span class="lineno">  838</span>        length = kwargs.get(<span class="stringliteral">&quot;stat_length&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  839</span>        length = _as_pairs(length, padded.ndim, as_index=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  840</span>        <span class="keywordflow">for</span> axis, width_pair, length_pair <span class="keywordflow">in</span> zip(axes, pad_width, length):</div>
<div class="line"><span class="lineno">  841</span>            roi = _view_roi(padded, original_area_slice, axis)</div>
<div class="line"><span class="lineno">  842</span>            stat_pair = _get_stats(roi, axis, width_pair, length_pair, func)</div>
<div class="line"><span class="lineno">  843</span>            _set_pad_area(roi, axis, width_pair, stat_pair)</div>
<div class="line"><span class="lineno">  844</span> </div>
<div class="line"><span class="lineno">  845</span>    <span class="keywordflow">elif</span> mode <span class="keywordflow">in</span> {<span class="stringliteral">&quot;reflect&quot;</span>, <span class="stringliteral">&quot;symmetric&quot;</span>}:</div>
<div class="line"><span class="lineno">  846</span>        method = kwargs.get(<span class="stringliteral">&quot;reflect_type&quot;</span>, <span class="stringliteral">&quot;even&quot;</span>)</div>
<div class="line"><span class="lineno">  847</span>        include_edge = <span class="keyword">True</span> <span class="keywordflow">if</span> mode == <span class="stringliteral">&quot;symmetric&quot;</span> <span class="keywordflow">else</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  848</span>        <span class="keywordflow">for</span> axis, (left_index, right_index) <span class="keywordflow">in</span> zip(axes, pad_width):</div>
<div class="line"><span class="lineno">  849</span>            <span class="keywordflow">if</span> array.shape[axis] == 1 <span class="keywordflow">and</span> (left_index &gt; 0 <span class="keywordflow">or</span> right_index &gt; 0):</div>
<div class="line"><span class="lineno">  850</span>                <span class="comment"># Extending singleton dimension for &#39;reflect&#39; is legacy</span></div>
<div class="line"><span class="lineno">  851</span>                <span class="comment"># behavior; it really should raise an error.</span></div>
<div class="line"><span class="lineno">  852</span>                edge_pair = _get_edges(padded, axis, (left_index, right_index))</div>
<div class="line"><span class="lineno">  853</span>                _set_pad_area(</div>
<div class="line"><span class="lineno">  854</span>                    padded, axis, (left_index, right_index), edge_pair)</div>
<div class="line"><span class="lineno">  855</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  856</span> </div>
<div class="line"><span class="lineno">  857</span>            roi = _view_roi(padded, original_area_slice, axis)</div>
<div class="line"><span class="lineno">  858</span>            <span class="keywordflow">while</span> left_index &gt; 0 <span class="keywordflow">or</span> right_index &gt; 0:</div>
<div class="line"><span class="lineno">  859</span>                <span class="comment"># Iteratively pad until dimension is filled with reflected</span></div>
<div class="line"><span class="lineno">  860</span>                <span class="comment"># values. This is necessary if the pad area is larger than</span></div>
<div class="line"><span class="lineno">  861</span>                <span class="comment"># the length of the original values in the current dimension.</span></div>
<div class="line"><span class="lineno">  862</span>                left_index, right_index = _set_reflect_both(</div>
<div class="line"><span class="lineno">  863</span>                    roi, axis, (left_index, right_index),</div>
<div class="line"><span class="lineno">  864</span>                    method, include_edge</div>
<div class="line"><span class="lineno">  865</span>                )</div>
<div class="line"><span class="lineno">  866</span> </div>
<div class="line"><span class="lineno">  867</span>    <span class="keywordflow">elif</span> mode == <span class="stringliteral">&quot;wrap&quot;</span>:</div>
<div class="line"><span class="lineno">  868</span>        <span class="keywordflow">for</span> axis, (left_index, right_index) <span class="keywordflow">in</span> zip(axes, pad_width):</div>
<div class="line"><span class="lineno">  869</span>            roi = _view_roi(padded, original_area_slice, axis)</div>
<div class="line"><span class="lineno">  870</span>            <span class="keywordflow">while</span> left_index &gt; 0 <span class="keywordflow">or</span> right_index &gt; 0:</div>
<div class="line"><span class="lineno">  871</span>                <span class="comment"># Iteratively pad until dimension is filled with wrapped</span></div>
<div class="line"><span class="lineno">  872</span>                <span class="comment"># values. This is necessary if the pad area is larger than</span></div>
<div class="line"><span class="lineno">  873</span>                <span class="comment"># the length of the original values in the current dimension.</span></div>
<div class="line"><span class="lineno">  874</span>                left_index, right_index = _set_wrap_both(</div>
<div class="line"><span class="lineno">  875</span>                    roi, axis, (left_index, right_index))</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span>    <span class="keywordflow">return</span> padded</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
