<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.io.xml Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1io.html">io</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1io_1_1xml.html">xml</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.io.xml Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1xml_1_1___etree_frame_parser.html">_EtreeFrameParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1xml_1_1___lxml_frame_parser.html">_LxmlFrameParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1io_1_1xml_1_1___x_m_l_frame_parser.html">_XMLFrameParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a67c794bfdfaf92783b14e5c5ea33c321" id="r_a67c794bfdfaf92783b14e5c5ea33c321"><td class="memItemLeft" align="right" valign="top">str|bytes|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes]|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1xml.html#a67c794bfdfaf92783b14e5c5ea33c321">get_data_from_filepath</a> (FilePath|bytes|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes]|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str] filepath_or_buffer, str|None encoding, CompressionOptions compression, StorageOptions storage_options)</td></tr>
<tr class="separator:a67c794bfdfaf92783b14e5c5ea33c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e00c5ae2a77150415d7efd48b1d84c" id="r_af3e00c5ae2a77150415d7efd48b1d84c"><td class="memItemLeft" align="right" valign="top">io.StringIO|io.BytesIO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1xml.html#af3e00c5ae2a77150415d7efd48b1d84c">preprocess_data</a> (data)</td></tr>
<tr class="separator:af3e00c5ae2a77150415d7efd48b1d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb915a6b24afce31e3c0bcd7d1f698" id="r_acaeb915a6b24afce31e3c0bcd7d1f698"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1xml.html#acaeb915a6b24afce31e3c0bcd7d1f698">_data_to_frame</a> (data, **kwargs)</td></tr>
<tr class="separator:acaeb915a6b24afce31e3c0bcd7d1f698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0deb836067adc4adb8505a4bb1bb14" id="r_abb0deb836067adc4adb8505a4bb1bb14"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1xml.html#abb0deb836067adc4adb8505a4bb1bb14">_parse</a> (FilePath|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes]|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str] path_or_buffer, str xpath, dict[str, str]|None namespaces, bool elems_only, bool attrs_only, Sequence[str]|None names, DtypeArg|None dtype, ConvertersArg|None converters, ParseDatesArg|None parse_dates, str|None encoding, XMLParsers parser, FilePath|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes]|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str]|None stylesheet, dict[str, list[str]]|None iterparse, CompressionOptions compression, StorageOptions storage_options, **kwargs)</td></tr>
<tr class="separator:abb0deb836067adc4adb8505a4bb1bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fd42654d6d91a36c000b6b76c04051" id="r_a79fd42654d6d91a36c000b6b76c04051"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1io_1_1xml.html#a79fd42654d6d91a36c000b6b76c04051">read_xml</a> (FilePath|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes]|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str] path_or_buffer, str xpath=&quot;./*&quot;, dict[str, str]|None namespaces=None, bool elems_only=False, bool attrs_only=False, Sequence[str]|None names=None, DtypeArg|None dtype=None, ConvertersArg|None converters=None, ParseDatesArg|None parse_dates=None, str|None encoding=&quot;utf-8&quot;, XMLParsers parser=&quot;lxml&quot;, FilePath|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes]|<a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str]|None stylesheet=None, dict[str, list[str]]|None iterparse=None, CompressionOptions compression=&quot;infer&quot;, StorageOptions storage_options=None)</td></tr>
<tr class="separator:a79fd42654d6d91a36c000b6b76c04051"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">:mod:`pandas.io.xml` is a module for reading XML.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="acaeb915a6b24afce31e3c0bcd7d1f698" name="acaeb915a6b24afce31e3c0bcd7d1f698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb915a6b24afce31e3c0bcd7d1f698">&#9670;&#160;</a></span>_data_to_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.io.xml._data_to_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert parsed data to Data Frame.

This method will bind xml dictionary data of keys and values
into named columns of Data Frame using the built-in TextParser
class that build Data Frame and infers specific dtypes.
</pre> <div class="fragment"><div class="line"><span class="lineno">  726</span><span class="keyword">def </span>_data_to_frame(data, **kwargs) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  727</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">    Convert parsed data to Data Frame.</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    This method will bind xml dictionary data of keys and values</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    into named columns of Data Frame using the built-in TextParser</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    class that build Data Frame and infers specific dtypes.</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  734</span> </div>
<div class="line"><span class="lineno">  735</span>    tags = next(<a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(data))</div>
<div class="line"><span class="lineno">  736</span>    nodes = [list(d.values()) <span class="keywordflow">for</span> d <span class="keywordflow">in</span> data]</div>
<div class="line"><span class="lineno">  737</span> </div>
<div class="line"><span class="lineno">  738</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  739</span>        <span class="keyword">with</span> TextParser(nodes, names=tags, **kwargs) <span class="keyword">as</span> tp:</div>
<div class="line"><span class="lineno">  740</span>            <span class="keywordflow">return</span> tp.read()</div>
<div class="line"><span class="lineno">  741</span>    <span class="keywordflow">except</span> ParserError:</div>
<div class="line"><span class="lineno">  742</span>        <span class="keywordflow">raise</span> ParserError(</div>
<div class="line"><span class="lineno">  743</span>            <span class="stringliteral">&quot;XML document may be too complex for import. &quot;</span></div>
<div class="line"><span class="lineno">  744</span>            <span class="stringliteral">&quot;Try to flatten document and use distinct &quot;</span></div>
<div class="line"><span class="lineno">  745</span>            <span class="stringliteral">&quot;element and attribute names.&quot;</span></div>
<div class="line"><span class="lineno">  746</span>        )</div>
<div class="line"><span class="lineno">  747</span> </div>
<div class="line"><span class="lineno">  748</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb0deb836067adc4adb8505a4bb1bb14" name="abb0deb836067adc4adb8505a4bb1bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0deb836067adc4adb8505a4bb1bb14">&#9670;&#160;</a></span>_parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.io.xml._parse </td>
          <td>(</td>
          <td class="paramtype">FilePath | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes] | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str]&#160;</td>
          <td class="paramname"><em>path_or_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, str] | None&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>elems_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>attrs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[str] | None&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConvertersArg | None&#160;</td>
          <td class="paramname"><em>converters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParseDatesArg | None&#160;</td>
          <td class="paramname"><em>parse_dates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLParsers&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilePath | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes] | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str] | None&#160;</td>
          <td class="paramname"><em>stylesheet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, list[str]] | None&#160;</td>
          <td class="paramname"><em>iterparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompressionOptions&#160;</td>
          <td class="paramname"><em>compression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorageOptions&#160;</td>
          <td class="paramname"><em>storage_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Call internal parsers.

This method will conditionally call internal parsers:
LxmlFrameParser and/or EtreeParser.

Raises
------
ImportError
    * If lxml is not installed if selected as parser.

ValueError
    * If parser is not lxml or etree.
</pre> <div class="fragment"><div class="line"><span class="lineno">  766</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  767</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    Call internal parsers.</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    This method will conditionally call internal parsers:</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    LxmlFrameParser and/or EtreeParser.</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    ImportError</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        * If lxml is not installed if selected as parser.</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        * If parser is not lxml or etree.</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  781</span> </div>
<div class="line"><span class="lineno">  782</span>    p: _EtreeFrameParser | _LxmlFrameParser</div>
<div class="line"><span class="lineno">  783</span> </div>
<div class="line"><span class="lineno">  784</span>    <span class="keywordflow">if</span> parser == <span class="stringliteral">&quot;lxml&quot;</span>:</div>
<div class="line"><span class="lineno">  785</span>        lxml = import_optional_dependency(<span class="stringliteral">&quot;lxml.etree&quot;</span>, errors=<span class="stringliteral">&quot;ignore&quot;</span>)</div>
<div class="line"><span class="lineno">  786</span> </div>
<div class="line"><span class="lineno">  787</span>        <span class="keywordflow">if</span> lxml <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  788</span>            p = _LxmlFrameParser(</div>
<div class="line"><span class="lineno">  789</span>                path_or_buffer,</div>
<div class="line"><span class="lineno">  790</span>                xpath,</div>
<div class="line"><span class="lineno">  791</span>                namespaces,</div>
<div class="line"><span class="lineno">  792</span>                elems_only,</div>
<div class="line"><span class="lineno">  793</span>                attrs_only,</div>
<div class="line"><span class="lineno">  794</span>                names,</div>
<div class="line"><span class="lineno">  795</span>                dtype,</div>
<div class="line"><span class="lineno">  796</span>                converters,</div>
<div class="line"><span class="lineno">  797</span>                parse_dates,</div>
<div class="line"><span class="lineno">  798</span>                encoding,</div>
<div class="line"><span class="lineno">  799</span>                stylesheet,</div>
<div class="line"><span class="lineno">  800</span>                iterparse,</div>
<div class="line"><span class="lineno">  801</span>                compression,</div>
<div class="line"><span class="lineno">  802</span>                storage_options,</div>
<div class="line"><span class="lineno">  803</span>            )</div>
<div class="line"><span class="lineno">  804</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  805</span>            <span class="keywordflow">raise</span> ImportError(<span class="stringliteral">&quot;lxml not found, please install or use the etree parser.&quot;</span>)</div>
<div class="line"><span class="lineno">  806</span> </div>
<div class="line"><span class="lineno">  807</span>    <span class="keywordflow">elif</span> parser == <span class="stringliteral">&quot;etree&quot;</span>:</div>
<div class="line"><span class="lineno">  808</span>        p = _EtreeFrameParser(</div>
<div class="line"><span class="lineno">  809</span>            path_or_buffer,</div>
<div class="line"><span class="lineno">  810</span>            xpath,</div>
<div class="line"><span class="lineno">  811</span>            namespaces,</div>
<div class="line"><span class="lineno">  812</span>            elems_only,</div>
<div class="line"><span class="lineno">  813</span>            attrs_only,</div>
<div class="line"><span class="lineno">  814</span>            names,</div>
<div class="line"><span class="lineno">  815</span>            dtype,</div>
<div class="line"><span class="lineno">  816</span>            converters,</div>
<div class="line"><span class="lineno">  817</span>            parse_dates,</div>
<div class="line"><span class="lineno">  818</span>            encoding,</div>
<div class="line"><span class="lineno">  819</span>            stylesheet,</div>
<div class="line"><span class="lineno">  820</span>            iterparse,</div>
<div class="line"><span class="lineno">  821</span>            compression,</div>
<div class="line"><span class="lineno">  822</span>            storage_options,</div>
<div class="line"><span class="lineno">  823</span>        )</div>
<div class="line"><span class="lineno">  824</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  825</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Values for parser can only be lxml or etree.&quot;</span>)</div>
<div class="line"><span class="lineno">  826</span> </div>
<div class="line"><span class="lineno">  827</span>    data_dicts = p.parse_data()</div>
<div class="line"><span class="lineno">  828</span> </div>
<div class="line"><span class="lineno">  829</span>    <span class="keywordflow">return</span> _data_to_frame(</div>
<div class="line"><span class="lineno">  830</span>        data=data_dicts,</div>
<div class="line"><span class="lineno">  831</span>        dtype=dtype,</div>
<div class="line"><span class="lineno">  832</span>        converters=converters,</div>
<div class="line"><span class="lineno">  833</span>        parse_dates=parse_dates,</div>
<div class="line"><span class="lineno">  834</span>        **kwargs,</div>
<div class="line"><span class="lineno">  835</span>    )</div>
<div class="line"><span class="lineno">  836</span> </div>
<div class="line"><span class="lineno">  837</span> </div>
<div class="line"><span class="lineno">  838</span><span class="preprocessor">@deprecate_nonkeyword_arguments(version=None, allowed_args=[&quot;path_or_buffer&quot;])</span></div>
<div class="line"><span class="lineno">  839</span><span class="preprocessor">@doc</span>(</div>
<div class="line"><span class="lineno">  840</span>    storage_options=_shared_docs[<span class="stringliteral">&quot;storage_options&quot;</span>],</div>
<div class="line"><span class="lineno">  841</span>    decompression_options=_shared_docs[<span class="stringliteral">&quot;decompression_options&quot;</span>] % <span class="stringliteral">&quot;path_or_buffer&quot;</span>,</div>
<div class="line"><span class="lineno">  842</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a67c794bfdfaf92783b14e5c5ea33c321" name="a67c794bfdfaf92783b14e5c5ea33c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c794bfdfaf92783b14e5c5ea33c321">&#9670;&#160;</a></span>get_data_from_filepath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str | bytes | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes] | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str] pandas.io.xml.get_data_from_filepath </td>
          <td>(</td>
          <td class="paramtype">FilePath | bytes | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes] | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str]&#160;</td>
          <td class="paramname"><em>filepath_or_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompressionOptions&#160;</td>
          <td class="paramname"><em>compression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorageOptions&#160;</td>
          <td class="paramname"><em>storage_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract raw XML data.

The method accepts three input types:
    1. filepath (string-like)
    2. file-like object (e.g. open file object, StringIO)
    3. XML string or bytes

This method turns (1) into (2) to simplify the rest of the processing.
It returns input types (2) and (3) unchanged.
</pre> <div class="fragment"><div class="line"><span class="lineno">  665</span>) -&gt; str | bytes | ReadBuffer[bytes] | ReadBuffer[str]:</div>
<div class="line"><span class="lineno">  666</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    Extract raw XML data.</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    The method accepts three input types:</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        1. filepath (string-like)</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        2. file-like object (e.g. open file object, StringIO)</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        3. XML string or bytes</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    This method turns (1) into (2) to simplify the rest of the processing.</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">    It returns input types (2) and (3) unchanged.</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  677</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(filepath_or_buffer, bytes):</div>
<div class="line"><span class="lineno">  678</span>        filepath_or_buffer = stringify_path(filepath_or_buffer)</div>
<div class="line"><span class="lineno">  679</span> </div>
<div class="line"><span class="lineno">  680</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  681</span>        isinstance(filepath_or_buffer, str)</div>
<div class="line"><span class="lineno">  682</span>        <span class="keywordflow">and</span> <span class="keywordflow">not</span> filepath_or_buffer.startswith((<span class="stringliteral">&quot;&lt;?xml&quot;</span>, <span class="stringliteral">&quot;&lt;&quot;</span>))</div>
<div class="line"><span class="lineno">  683</span>    ) <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno">  684</span>        <span class="keywordflow">not</span> isinstance(filepath_or_buffer, str)</div>
<div class="line"><span class="lineno">  685</span>        <span class="keywordflow">or</span> is_url(filepath_or_buffer)</div>
<div class="line"><span class="lineno">  686</span>        <span class="keywordflow">or</span> is_fsspec_url(filepath_or_buffer)</div>
<div class="line"><span class="lineno">  687</span>        <span class="keywordflow">or</span> file_exists(filepath_or_buffer)</div>
<div class="line"><span class="lineno">  688</span>    ):</div>
<div class="line"><span class="lineno">  689</span>        <span class="keyword">with</span> get_handle(</div>
<div class="line"><span class="lineno">  690</span>            filepath_or_buffer,</div>
<div class="line"><span class="lineno">  691</span>            <span class="stringliteral">&quot;r&quot;</span>,</div>
<div class="line"><span class="lineno">  692</span>            encoding=encoding,</div>
<div class="line"><span class="lineno">  693</span>            compression=compression,</div>
<div class="line"><span class="lineno">  694</span>            storage_options=storage_options,</div>
<div class="line"><span class="lineno">  695</span>        ) <span class="keyword">as</span> handle_obj:</div>
<div class="line"><span class="lineno">  696</span>            filepath_or_buffer = (</div>
<div class="line"><span class="lineno">  697</span>                <span class="comment"># error: Incompatible types in assignment (expression has type</span></div>
<div class="line"><span class="lineno">  698</span>                <span class="comment"># &quot;Union[str, IO[str]]&quot;, variable has type &quot;Union[Union[str,</span></div>
<div class="line"><span class="lineno">  699</span>                <span class="comment"># PathLike[str]], bytes, ReadBuffer[bytes], ReadBuffer[str]]&quot;)</span></div>
<div class="line"><span class="lineno">  700</span>                handle_obj.handle.read()  <span class="comment"># type: ignore[assignment]</span></div>
<div class="line"><span class="lineno">  701</span>                <span class="keywordflow">if</span> hasattr(handle_obj.handle, <span class="stringliteral">&quot;read&quot;</span>)</div>
<div class="line"><span class="lineno">  702</span>                <span class="keywordflow">else</span> handle_obj.handle</div>
<div class="line"><span class="lineno">  703</span>            )</div>
<div class="line"><span class="lineno">  704</span> </div>
<div class="line"><span class="lineno">  705</span>    <span class="keywordflow">return</span> filepath_or_buffer</div>
<div class="line"><span class="lineno">  706</span> </div>
<div class="line"><span class="lineno">  707</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af3e00c5ae2a77150415d7efd48b1d84c" name="af3e00c5ae2a77150415d7efd48b1d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e00c5ae2a77150415d7efd48b1d84c">&#9670;&#160;</a></span>preprocess_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> io.StringIO | io.BytesIO pandas.io.xml.preprocess_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert extracted raw data.

This method will return underlying data of extracted XML content.
The data either has a `read` attribute (e.g. a file object or a
StringIO/BytesIO) or is a string or bytes that is an XML document.
</pre> <div class="fragment"><div class="line"><span class="lineno">  708</span><span class="keyword">def </span>preprocess_data(data) -&gt; io.StringIO | io.BytesIO:</div>
<div class="line"><span class="lineno">  709</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    Convert extracted raw data.</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    This method will return underlying data of extracted XML content.</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    The data either has a `read` attribute (e.g. a file object or a</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    StringIO/BytesIO) or is a string or bytes that is an XML document.</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  716</span> </div>
<div class="line"><span class="lineno">  717</span>    <span class="keywordflow">if</span> isinstance(data, str):</div>
<div class="line"><span class="lineno">  718</span>        data = io.StringIO(data)</div>
<div class="line"><span class="lineno">  719</span> </div>
<div class="line"><span class="lineno">  720</span>    <span class="keywordflow">elif</span> isinstance(data, bytes):</div>
<div class="line"><span class="lineno">  721</span>        data = io.BytesIO(data)</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span>    <span class="keywordflow">return</span> data</div>
<div class="line"><span class="lineno">  724</span> </div>
<div class="line"><span class="lineno">  725</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a79fd42654d6d91a36c000b6b76c04051" name="a79fd42654d6d91a36c000b6b76c04051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fd42654d6d91a36c000b6b76c04051">&#9670;&#160;</a></span>read_xml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.io.xml.read_xml </td>
          <td>(</td>
          <td class="paramtype">FilePath | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes] | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str]&#160;</td>
          <td class="paramname"><em>path_or_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>xpath</em> = <code>&quot;./*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, str] | None &#160;</td>
          <td class="paramname"><em>namespaces</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>elems_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>attrs_only</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[str] | None &#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConvertersArg | None &#160;</td>
          <td class="paramname"><em>converters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParseDatesArg | None &#160;</td>
          <td class="paramname"><em>parse_dates</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>encoding</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLParsers &#160;</td>
          <td class="paramname"><em>parser</em> = <code>&quot;lxml&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilePath | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[bytes] | <a class="el" href="classpandas_1_1__typing_1_1_read_buffer.html">ReadBuffer</a>[str] | None &#160;</td>
          <td class="paramname"><em>stylesheet</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, list[str]] | None &#160;</td>
          <td class="paramname"><em>iterparse</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompressionOptions &#160;</td>
          <td class="paramname"><em>compression</em> = <code>&quot;infer&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorageOptions &#160;</td>
          <td class="paramname"><em>storage_options</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read XML document into a ``DataFrame`` object.

.. versionadded:: 1.3.0

Parameters
----------
path_or_buffer : str, path object, or file-like object
    String, path object (implementing ``os.PathLike[str]``), or file-like
    object implementing a ``read()`` function. The string can be any valid XML
    string or a path. The string can further be a URL. Valid URL schemes
    include http, ftp, s3, and file.

xpath : str, optional, default './\*'
    The XPath to parse required set of nodes for migration to DataFrame.
    XPath should return a collection of elements and not a single
    element. Note: The ``etree`` parser supports limited XPath
    expressions. For more complex XPath, use ``lxml`` which requires
    installation.

namespaces : dict, optional
    The namespaces defined in XML document as dicts with key being
    namespace prefix and value the URI. There is no need to include all
    namespaces in XML, only the ones used in ``xpath`` expression.
    Note: if XML document uses default namespace denoted as
    `xmlns='&lt;URI&gt;'` without a prefix, you must assign any temporary
    namespace prefix such as 'doc' to the URI in order to parse
    underlying nodes and/or attributes. For example, ::

        namespaces = {{"doc": "https://example.com"}}

elems_only : bool, optional, default False
    Parse only the child elements at the specified ``xpath``. By default,
    all child elements and non-empty text nodes are returned.

attrs_only :  bool, optional, default False
    Parse only the attributes at the specified ``xpath``.
    By default, all attributes are returned.

names :  list-like, optional
    Column names for DataFrame of parsed XML data. Use this parameter to
    rename original element names and distinguish same named elements and
    attributes.

dtype : Type name or dict of column -&gt; type, optional
    Data type for data or columns. E.g. {{'a': np.float64, 'b': np.int32,
    'c': 'Int64'}}
    Use `str` or `object` together with suitable `na_values` settings
    to preserve and not interpret dtype.
    If converters are specified, they will be applied INSTEAD
    of dtype conversion.

    .. versionadded:: 1.5.0

converters : dict, optional
    Dict of functions for converting values in certain columns. Keys can either
    be integers or column labels.

    .. versionadded:: 1.5.0

parse_dates : bool or list of int or names or list of lists or dict, default False
    Identifiers to parse index or columns to datetime. The behavior is as follows:

    * boolean. If True -&gt; try parsing the index.
    * list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3
      each as a separate date column.
    * list of lists. e.g.  If [[1, 3]] -&gt; combine columns 1 and 3 and parse as
      a single date column.
    * dict, e.g. {{'foo' : [1, 3]}} -&gt; parse columns 1, 3 as date and call
      result 'foo'

    .. versionadded:: 1.5.0

encoding : str, optional, default 'utf-8'
    Encoding of XML document.

parser : {{'lxml','etree'}}, default 'lxml'
    Parser module to use for retrieval of data. Only 'lxml' and
    'etree' are supported. With 'lxml' more complex XPath searches
    and ability to use XSLT stylesheet are supported.

stylesheet : str, path object or file-like object
    A URL, file-like object, or a raw string containing an XSLT script.
    This stylesheet should flatten complex, deeply nested XML documents
    for easier parsing. To use this feature you must have ``lxml`` module
    installed and specify 'lxml' as ``parser``. The ``xpath`` must
    reference nodes of transformed XML document generated after XSLT
    transformation and not the original XML document. Only XSLT 1.0
    scripts and not later versions is currently supported.

iterparse : dict, optional
    The nodes or attributes to retrieve in iterparsing of XML document
    as a dict with key being the name of repeating element and value being
    list of elements or attribute names that are descendants of the repeated
    element. Note: If this option is used, it will replace ``xpath`` parsing
    and unlike xpath, descendants do not need to relate to each other but can
    exist any where in document under the repeating element. This memory-
    efficient method should be used for very large XML files (500MB, 1GB, or 5GB+).
    For example, ::

        iterparse = {{"row_element": ["child_elem", "attr", "grandchild_elem"]}}

    .. versionadded:: 1.5.0

{decompression_options}

    .. versionchanged:: 1.4.0 Zstandard support.

{storage_options}

Returns
-------
df
    A DataFrame.

See Also
--------
read_json : Convert a JSON string to pandas object.
read_html : Read HTML tables into a list of DataFrame objects.

Notes
-----
This method is best designed to import shallow XML documents in
following format which is the ideal fit for the two-dimensions of a
``DataFrame`` (row by column). ::

        &lt;root&gt;
            &lt;row&gt;
              &lt;column1&gt;data&lt;/column1&gt;
              &lt;column2&gt;data&lt;/column2&gt;
              &lt;column3&gt;data&lt;/column3&gt;
              ...
           &lt;/row&gt;
           &lt;row&gt;
              ...
           &lt;/row&gt;
           ...
        &lt;/root&gt;

As a file format, XML documents can be designed any way including
layout of elements and attributes as long as it conforms to W3C
specifications. Therefore, this method is a convenience handler for
a specific flatter design and not all possible XML structures.

However, for more complex XML documents, ``stylesheet`` allows you to
temporarily redesign original document with XSLT (a special purpose
language) for a flatter version for migration to a DataFrame.

This function will *always* return a single :class:`DataFrame` or raise
exceptions due to issues with XML document, ``xpath``, or other
parameters.

See the :ref:`read_xml documentation in the IO section of the docs
&lt;io.read_xml&gt;` for more information in using this method to parse XML
files to DataFrames.

Examples
--------
&gt;&gt;&gt; xml = '''&lt;?xml version='1.0' encoding='utf-8'?&gt;
... &lt;data xmlns="http://example.com"&gt;
...  &lt;row&gt;
...    &lt;shape&gt;square&lt;/shape&gt;
...    &lt;degrees&gt;360&lt;/degrees&gt;
...    &lt;sides&gt;4.0&lt;/sides&gt;
...  &lt;/row&gt;
...  &lt;row&gt;
...    &lt;shape&gt;circle&lt;/shape&gt;
...    &lt;degrees&gt;360&lt;/degrees&gt;
...    &lt;sides/&gt;
...  &lt;/row&gt;
...  &lt;row&gt;
...    &lt;shape&gt;triangle&lt;/shape&gt;
...    &lt;degrees&gt;180&lt;/degrees&gt;
...    &lt;sides&gt;3.0&lt;/sides&gt;
...  &lt;/row&gt;
... &lt;/data&gt;'''

&gt;&gt;&gt; df = pd.read_xml(xml)
&gt;&gt;&gt; df
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0

&gt;&gt;&gt; xml = '''&lt;?xml version='1.0' encoding='utf-8'?&gt;
... &lt;data&gt;
...   &lt;row shape="square" degrees="360" sides="4.0"/&gt;
...   &lt;row shape="circle" degrees="360"/&gt;
...   &lt;row shape="triangle" degrees="180" sides="3.0"/&gt;
... &lt;/data&gt;'''

&gt;&gt;&gt; df = pd.read_xml(xml, xpath=".//row")
&gt;&gt;&gt; df
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0

&gt;&gt;&gt; xml = '''&lt;?xml version='1.0' encoding='utf-8'?&gt;
... &lt;doc:data xmlns:doc="https://example.com"&gt;
...   &lt;doc:row&gt;
...     &lt;doc:shape&gt;square&lt;/doc:shape&gt;
...     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
...     &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;
...   &lt;/doc:row&gt;
...   &lt;doc:row&gt;
...     &lt;doc:shape&gt;circle&lt;/doc:shape&gt;
...     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
...     &lt;doc:sides/&gt;
...   &lt;/doc:row&gt;
...   &lt;doc:row&gt;
...     &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;
...     &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;
...     &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;
...   &lt;/doc:row&gt;
... &lt;/doc:data&gt;'''

&gt;&gt;&gt; df = pd.read_xml(xml,
...                  xpath="//doc:row",
...                  namespaces={{"doc": "https://example.com"}})
&gt;&gt;&gt; df
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  860</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  861</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    Read XML document into a ``DataFrame`` object.</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    .. versionadded:: 1.3.0</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    path_or_buffer : str, path object, or file-like object</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">        String, path object (implementing ``os.PathLike[str]``), or file-like</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">        object implementing a ``read()`` function. The string can be any valid XML</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">        string or a path. The string can further be a URL. Valid URL schemes</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">        include http, ftp, s3, and file.</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    xpath : str, optional, default &#39;./\*&#39;</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        The XPath to parse required set of nodes for migration to DataFrame.</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">        XPath should return a collection of elements and not a single</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">        element. Note: The ``etree`` parser supports limited XPath</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">        expressions. For more complex XPath, use ``lxml`` which requires</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">        installation.</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    namespaces : dict, optional</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        The namespaces defined in XML document as dicts with key being</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">        namespace prefix and value the URI. There is no need to include all</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">        namespaces in XML, only the ones used in ``xpath`` expression.</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">        Note: if XML document uses default namespace denoted as</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">        `xmlns=&#39;&lt;URI&gt;&#39;` without a prefix, you must assign any temporary</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">        namespace prefix such as &#39;doc&#39; to the URI in order to parse</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        underlying nodes and/or attributes. For example, ::</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">            namespaces = {{&quot;doc&quot;: &quot;https://example.com&quot;}}</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    elems_only : bool, optional, default False</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">        Parse only the child elements at the specified ``xpath``. By default,</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">        all child elements and non-empty text nodes are returned.</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    attrs_only :  bool, optional, default False</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">        Parse only the attributes at the specified ``xpath``.</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">        By default, all attributes are returned.</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    names :  list-like, optional</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">        Column names for DataFrame of parsed XML data. Use this parameter to</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">        rename original element names and distinguish same named elements and</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">        attributes.</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    dtype : Type name or dict of column -&gt; type, optional</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">        Data type for data or columns. E.g. {{&#39;a&#39;: np.float64, &#39;b&#39;: np.int32,</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        &#39;c&#39;: &#39;Int64&#39;}}</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">        Use `str` or `object` together with suitable `na_values` settings</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        to preserve and not interpret dtype.</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        If converters are specified, they will be applied INSTEAD</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        of dtype conversion.</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    converters : dict, optional</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">        Dict of functions for converting values in certain columns. Keys can either</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">        be integers or column labels.</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">        .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    parse_dates : bool or list of int or names or list of lists or dict, default False</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">        Identifiers to parse index or columns to datetime. The behavior is as follows:</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">        * boolean. If True -&gt; try parsing the index.</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">        * list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">          each as a separate date column.</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">        * list of lists. e.g.  If [[1, 3]] -&gt; combine columns 1 and 3 and parse as</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">          a single date column.</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">        * dict, e.g. {{&#39;foo&#39; : [1, 3]}} -&gt; parse columns 1, 3 as date and call</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">          result &#39;foo&#39;</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">        .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    encoding : str, optional, default &#39;utf-8&#39;</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">        Encoding of XML document.</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    parser : {{&#39;lxml&#39;,&#39;etree&#39;}}, default &#39;lxml&#39;</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">        Parser module to use for retrieval of data. Only &#39;lxml&#39; and</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">        &#39;etree&#39; are supported. With &#39;lxml&#39; more complex XPath searches</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">        and ability to use XSLT stylesheet are supported.</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    stylesheet : str, path object or file-like object</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">        A URL, file-like object, or a raw string containing an XSLT script.</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">        This stylesheet should flatten complex, deeply nested XML documents</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">        for easier parsing. To use this feature you must have ``lxml`` module</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">        installed and specify &#39;lxml&#39; as ``parser``. The ``xpath`` must</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">        reference nodes of transformed XML document generated after XSLT</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">        transformation and not the original XML document. Only XSLT 1.0</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">        scripts and not later versions is currently supported.</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    iterparse : dict, optional</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">        The nodes or attributes to retrieve in iterparsing of XML document</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">        as a dict with key being the name of repeating element and value being</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">        list of elements or attribute names that are descendants of the repeated</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">        element. Note: If this option is used, it will replace ``xpath`` parsing</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">        and unlike xpath, descendants do not need to relate to each other but can</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">        exist any where in document under the repeating element. This memory-</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">        efficient method should be used for very large XML files (500MB, 1GB, or 5GB+).</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">        For example, ::</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">            iterparse = {{&quot;row_element&quot;: [&quot;child_elem&quot;, &quot;attr&quot;, &quot;grandchild_elem&quot;]}}</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">        .. versionadded:: 1.5.0</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    {decompression_options}</span></div>
<div class="line"><span class="lineno">  966</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  967</span><span class="stringliteral">        .. versionchanged:: 1.4.0 Zstandard support.</span></div>
<div class="line"><span class="lineno">  968</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  969</span><span class="stringliteral">    {storage_options}</span></div>
<div class="line"><span class="lineno">  970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  971</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  972</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    df</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral">        A DataFrame.</span></div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    read_json : Convert a JSON string to pandas object.</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">    read_html : Read HTML tables into a list of DataFrame objects.</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    This method is best designed to import shallow XML documents in</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    following format which is the ideal fit for the two-dimensions of a</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    ``DataFrame`` (row by column). ::</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">            &lt;root&gt;</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">                &lt;row&gt;</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">                  &lt;column1&gt;data&lt;/column1&gt;</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">                  &lt;column2&gt;data&lt;/column2&gt;</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">                  &lt;column3&gt;data&lt;/column3&gt;</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">                  ...</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">               &lt;/row&gt;</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">               &lt;row&gt;</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">                  ...</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">               &lt;/row&gt;</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">               ...</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">            &lt;/root&gt;</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">    As a file format, XML documents can be designed any way including</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">    layout of elements and attributes as long as it conforms to W3C</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">    specifications. Therefore, this method is a convenience handler for</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    a specific flatter design and not all possible XML structures.</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    However, for more complex XML documents, ``stylesheet`` allows you to</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">    temporarily redesign original document with XSLT (a special purpose</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">    language) for a flatter version for migration to a DataFrame.</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">    This function will *always* return a single :class:`DataFrame` or raise</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    exceptions due to issues with XML document, ``xpath``, or other</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    parameters.</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    See the :ref:`read_xml documentation in the IO section of the docs</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    &lt;io.read_xml&gt;` for more information in using this method to parse XML</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    files to DataFrames.</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    &gt;&gt;&gt; xml = &#39;&#39;&#39;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    ... &lt;data xmlns=&quot;http://example.com&quot;&gt;</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    ...  &lt;row&gt;</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    ...    &lt;shape&gt;square&lt;/shape&gt;</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    ...    &lt;degrees&gt;360&lt;/degrees&gt;</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    ...    &lt;sides&gt;4.0&lt;/sides&gt;</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    ...  &lt;/row&gt;</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    ...  &lt;row&gt;</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    ...    &lt;shape&gt;circle&lt;/shape&gt;</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    ...    &lt;degrees&gt;360&lt;/degrees&gt;</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    ...    &lt;sides/&gt;</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    ...  &lt;/row&gt;</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">    ...  &lt;row&gt;</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    ...    &lt;shape&gt;triangle&lt;/shape&gt;</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    ...    &lt;degrees&gt;180&lt;/degrees&gt;</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    ...    &lt;sides&gt;3.0&lt;/sides&gt;</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    ...  &lt;/row&gt;</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    ... &lt;/data&gt;&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    &gt;&gt;&gt; df = pd.read_xml(xml)</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">          shape  degrees  sides</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    0    square      360    4.0</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">    1    circle      360    NaN</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    2  triangle      180    3.0</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">    &gt;&gt;&gt; xml = &#39;&#39;&#39;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">    ... &lt;data&gt;</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    ...   &lt;row shape=&quot;square&quot; degrees=&quot;360&quot; sides=&quot;4.0&quot;/&gt;</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">    ...   &lt;row shape=&quot;circle&quot; degrees=&quot;360&quot;/&gt;</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    ...   &lt;row shape=&quot;triangle&quot; degrees=&quot;180&quot; sides=&quot;3.0&quot;/&gt;</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">    ... &lt;/data&gt;&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">    &gt;&gt;&gt; df = pd.read_xml(xml, xpath=&quot;.//row&quot;)</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">    &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">          shape  degrees  sides</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">    0    square      360    4.0</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">    1    circle      360    NaN</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    2  triangle      180    3.0</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">    &gt;&gt;&gt; xml = &#39;&#39;&#39;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">    ... &lt;doc:data xmlns:doc=&quot;https://example.com&quot;&gt;</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    ...   &lt;doc:row&gt;</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    ...     &lt;doc:shape&gt;square&lt;/doc:shape&gt;</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">    ...     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">    ...     &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">    ...   &lt;/doc:row&gt;</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    ...   &lt;doc:row&gt;</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">    ...     &lt;doc:shape&gt;circle&lt;/doc:shape&gt;</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    ...     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    ...     &lt;doc:sides/&gt;</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    ...   &lt;/doc:row&gt;</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    ...   &lt;doc:row&gt;</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    ...     &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    ...     &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    ...     &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    ...   &lt;/doc:row&gt;</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">    ... &lt;/doc:data&gt;&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    &gt;&gt;&gt; df = pd.read_xml(xml,</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    ...                  xpath=&quot;//doc:row&quot;,</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">    ...                  namespaces={{&quot;doc&quot;: &quot;https://example.com&quot;}})</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    &gt;&gt;&gt; df</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">          shape  degrees  sides</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">    0    square      360    4.0</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    1    circle      360    NaN</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">    2  triangle      180    3.0</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1087</span> </div>
<div class="line"><span class="lineno"> 1088</span>    <span class="keywordflow">return</span> _parse(</div>
<div class="line"><span class="lineno"> 1089</span>        path_or_buffer=path_or_buffer,</div>
<div class="line"><span class="lineno"> 1090</span>        xpath=xpath,</div>
<div class="line"><span class="lineno"> 1091</span>        namespaces=namespaces,</div>
<div class="line"><span class="lineno"> 1092</span>        elems_only=elems_only,</div>
<div class="line"><span class="lineno"> 1093</span>        attrs_only=attrs_only,</div>
<div class="line"><span class="lineno"> 1094</span>        names=names,</div>
<div class="line"><span class="lineno"> 1095</span>        dtype=dtype,</div>
<div class="line"><span class="lineno"> 1096</span>        converters=converters,</div>
<div class="line"><span class="lineno"> 1097</span>        parse_dates=parse_dates,</div>
<div class="line"><span class="lineno"> 1098</span>        encoding=encoding,</div>
<div class="line"><span class="lineno"> 1099</span>        parser=parser,</div>
<div class="line"><span class="lineno"> 1100</span>        stylesheet=stylesheet,</div>
<div class="line"><span class="lineno"> 1101</span>        iterparse=iterparse,</div>
<div class="line"><span class="lineno"> 1102</span>        compression=compression,</div>
<div class="line"><span class="lineno"> 1103</span>        storage_options=storage_options,</div>
<div class="line"><span class="lineno"> 1104</span>    )</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
