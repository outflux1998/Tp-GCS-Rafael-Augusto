<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.stats._resampling Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats.html">stats</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html">_resampling</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.stats._resampling Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1cbf31c18034ecab33c5c808b268dd86" id="r_a1cbf31c18034ecab33c5c808b268dd86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a1cbf31c18034ecab33c5c808b268dd86">_vectorize_statistic</a> (statistic)</td></tr>
<tr class="separator:a1cbf31c18034ecab33c5c808b268dd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769ff272403e86cb56c70da1815f7578" id="r_a769ff272403e86cb56c70da1815f7578"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a769ff272403e86cb56c70da1815f7578">_jackknife_resample</a> (sample, batch=None)</td></tr>
<tr class="separator:a769ff272403e86cb56c70da1815f7578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d4dbf131de119c12f6c988ff2f220c" id="r_a92d4dbf131de119c12f6c988ff2f220c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a92d4dbf131de119c12f6c988ff2f220c">_bootstrap_resample</a> (sample, n_resamples=None, random_state=None)</td></tr>
<tr class="separator:a92d4dbf131de119c12f6c988ff2f220c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d690dafccfb69022dcf50b4c19becdd" id="r_a4d690dafccfb69022dcf50b4c19becdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a4d690dafccfb69022dcf50b4c19becdd">_percentile_of_score</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, score, axis)</td></tr>
<tr class="separator:a4d690dafccfb69022dcf50b4c19becdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe7a1919ac1faf534dd1e5e3f091543" id="r_acbe7a1919ac1faf534dd1e5e3f091543"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#acbe7a1919ac1faf534dd1e5e3f091543">_percentile_along_axis</a> (theta_hat_b, <a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#ace85b1427e9d22fa1c4faa15812b747d">alpha</a>)</td></tr>
<tr class="separator:acbe7a1919ac1faf534dd1e5e3f091543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f04e1d5f070ff31f1343441e0d49b13" id="r_a2f04e1d5f070ff31f1343441e0d49b13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a2f04e1d5f070ff31f1343441e0d49b13">_bca_interval</a> (data, statistic, axis, <a class="el" href="namespacescipy_1_1stats_1_1__continuous__distns.html#ace85b1427e9d22fa1c4faa15812b747d">alpha</a>, theta_hat_b, batch)</td></tr>
<tr class="separator:a2f04e1d5f070ff31f1343441e0d49b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5d6adcb1f2f5537240327cd4687a97" id="r_a4d5d6adcb1f2f5537240327cd4687a97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a4d5d6adcb1f2f5537240327cd4687a97">_bootstrap_iv</a> (data, statistic, vectorized, paired, axis, confidence_level, n_resamples, batch, <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>, random_state)</td></tr>
<tr class="separator:a4d5d6adcb1f2f5537240327cd4687a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f2089dc72d84cf7469193d59d6770" id="r_aec6f2089dc72d84cf7469193d59d6770"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#aec6f2089dc72d84cf7469193d59d6770">bootstrap</a> (data, statistic, *n_resamples=9999, batch=None, vectorized=True, paired=False, axis=0, confidence_level=0.95, <a class="el" href="namespacescipy_1_1stats_1_1__multivariate.html#ad5850caf3faceef835b3baacc93038ee">method</a>='BCa', random_state=None)</td></tr>
<tr class="separator:aec6f2089dc72d84cf7469193d59d6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746945289289f851a284d03ade01f838" id="r_a746945289289f851a284d03ade01f838"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a746945289289f851a284d03ade01f838">_monte_carlo_test_iv</a> (sample, rvs, statistic, vectorized, n_resamples, batch, alternative, axis)</td></tr>
<tr class="separator:a746945289289f851a284d03ade01f838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83269fcf47696542df1e5921be60b5ab" id="r_a83269fcf47696542df1e5921be60b5ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a83269fcf47696542df1e5921be60b5ab">monte_carlo_test</a> (sample, rvs, statistic, *vectorized=False, n_resamples=9999, batch=None, alternative=&quot;two-sided&quot;, axis=0)</td></tr>
<tr class="separator:a83269fcf47696542df1e5921be60b5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e31d9de95afc8cc40db53ed7f4cfddd" id="r_a0e31d9de95afc8cc40db53ed7f4cfddd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a0e31d9de95afc8cc40db53ed7f4cfddd">_all_partitions_concatenated</a> (<a class="el" href="__lapack__subroutines_8h.html#ace38bc4f3f3ba577fffa106105715135">ns</a>)</td></tr>
<tr class="separator:a0e31d9de95afc8cc40db53ed7f4cfddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c3fbfa8434bb273175aafd84fd9eb3" id="r_ab2c3fbfa8434bb273175aafd84fd9eb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#ab2c3fbfa8434bb273175aafd84fd9eb3">_batch_generator</a> (iterable, batch)</td></tr>
<tr class="separator:ab2c3fbfa8434bb273175aafd84fd9eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce466a2e498006d6c0c57bfde7b7ce7" id="r_abce466a2e498006d6c0c57bfde7b7ce7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#abce466a2e498006d6c0c57bfde7b7ce7">_calculate_null_both</a> (data, statistic, n_permutations, batch, random_state=None)</td></tr>
<tr class="separator:abce466a2e498006d6c0c57bfde7b7ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164b747bb35a0a8fc563729ec8e72e5d" id="r_a164b747bb35a0a8fc563729ec8e72e5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a164b747bb35a0a8fc563729ec8e72e5d">_calculate_null_pairings</a> (data, statistic, n_permutations, batch, random_state=None)</td></tr>
<tr class="separator:a164b747bb35a0a8fc563729ec8e72e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281bd931b030ac46a8df78e1ae2ce06c" id="r_a281bd931b030ac46a8df78e1ae2ce06c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a281bd931b030ac46a8df78e1ae2ce06c">_calculate_null_samples</a> (data, statistic, n_permutations, batch, random_state=None)</td></tr>
<tr class="separator:a281bd931b030ac46a8df78e1ae2ce06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7528e2c981d6bb79547bdb33da599a" id="r_aaa7528e2c981d6bb79547bdb33da599a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#aaa7528e2c981d6bb79547bdb33da599a">_permutation_test_iv</a> (data, statistic, permutation_type, vectorized, n_resamples, batch, alternative, axis, random_state)</td></tr>
<tr class="separator:aaa7528e2c981d6bb79547bdb33da599a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154544187d27a7967a0696aaa88abd76" id="r_a154544187d27a7967a0696aaa88abd76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a154544187d27a7967a0696aaa88abd76">permutation_test</a> (data, statistic, *permutation_type='independent', vectorized=False, n_resamples=9999, batch=None, alternative=&quot;two-sided&quot;, axis=0, random_state=None)</td></tr>
<tr class="separator:a154544187d27a7967a0696aaa88abd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4e22ee0892d74bab432bfd5333a81810" id="r_a4e22ee0892d74bab432bfd5333a81810"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a4e22ee0892d74bab432bfd5333a81810">fields</a> = ['confidence_interval', 'standard_error']</td></tr>
<tr class="separator:a4e22ee0892d74bab432bfd5333a81810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e55a2af5b196e3cabca2ec8dd5a5217" id="r_a0e55a2af5b196e3cabca2ec8dd5a5217"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a0e55a2af5b196e3cabca2ec8dd5a5217">BootstrapResult</a> = make_dataclass(&quot;BootstrapResult&quot;, <a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a4e22ee0892d74bab432bfd5333a81810">fields</a>)</td></tr>
<tr class="separator:a0e55a2af5b196e3cabca2ec8dd5a5217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245f06b9cc502d0f1983347197b50c55" id="r_a245f06b9cc502d0f1983347197b50c55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a245f06b9cc502d0f1983347197b50c55">MonteCarloTestResult</a> = make_dataclass(&quot;MonteCarloTestResult&quot;, <a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a4e22ee0892d74bab432bfd5333a81810">fields</a>)</td></tr>
<tr class="separator:a245f06b9cc502d0f1983347197b50c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2898f7d7422d9298058ae5aa30a2243c" id="r_a2898f7d7422d9298058ae5aa30a2243c"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a2898f7d7422d9298058ae5aa30a2243c">attributes</a> = ('statistic', 'pvalue', 'null_distribution')</td></tr>
<tr class="separator:a2898f7d7422d9298058ae5aa30a2243c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddb2359731d30b63aaecddcf839b4f6" id="r_acddb2359731d30b63aaecddcf839b4f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#acddb2359731d30b63aaecddcf839b4f6">PermutationTestResult</a> = make_dataclass('PermutationTestResult', <a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a2898f7d7422d9298058ae5aa30a2243c">attributes</a>)</td></tr>
<tr class="separator:acddb2359731d30b63aaecddcf839b4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0e31d9de95afc8cc40db53ed7f4cfddd" name="a0e31d9de95afc8cc40db53ed7f4cfddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e31d9de95afc8cc40db53ed7f4cfddd">&#9670;&#160;</a></span>_all_partitions_concatenated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._all_partitions_concatenated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generate all partitions of indices of groups of given sizes, concatenated

`ns` is an iterable of ints.
</pre> <div class="fragment"><div class="line"><span class="lineno">  733</span><span class="keyword">def </span>_all_partitions_concatenated(ns):</div>
<div class="line"><span class="lineno">  734</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    Generate all partitions of indices of groups of given sizes, concatenated</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    `ns` is an iterable of ints.</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  739</span>    <span class="keyword">def </span>all_partitions(z, n):</div>
<div class="line"><span class="lineno">  740</span>        <span class="keywordflow">for</span> c <span class="keywordflow">in</span> combinations(z, n):</div>
<div class="line"><span class="lineno">  741</span>            x0 = set(c)</div>
<div class="line"><span class="lineno">  742</span>            x1 = z - x0</div>
<div class="line"><span class="lineno">  743</span>            <span class="keywordflow">yield</span> [x0, x1]</div>
<div class="line"><span class="lineno">  744</span> </div>
<div class="line"><span class="lineno">  745</span>    <span class="keyword">def </span>all_partitions_n(z, ns):</div>
<div class="line"><span class="lineno">  746</span>        <span class="keywordflow">if</span> len(ns) == 0:</div>
<div class="line"><span class="lineno">  747</span>            <span class="keywordflow">yield</span> [z]</div>
<div class="line"><span class="lineno">  748</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  749</span>        <span class="keywordflow">for</span> c <span class="keywordflow">in</span> all_partitions(z, ns[0]):</div>
<div class="line"><span class="lineno">  750</span>            <span class="keywordflow">for</span> d <span class="keywordflow">in</span> all_partitions_n(c[1], ns[1:]):</div>
<div class="line"><span class="lineno">  751</span>                <span class="keywordflow">yield</span> c[0:1] + d</div>
<div class="line"><span class="lineno">  752</span> </div>
<div class="line"><span class="lineno">  753</span>    z = set(range(np.sum(ns)))</div>
<div class="line"><span class="lineno">  754</span>    <span class="keywordflow">for</span> partitioning <span class="keywordflow">in</span> all_partitions_n(z, ns[:]):</div>
<div class="line"><span class="lineno">  755</span>        x = np.concatenate([list(partition)</div>
<div class="line"><span class="lineno">  756</span>                            <span class="keywordflow">for</span> partition <span class="keywordflow">in</span> partitioning]).astype(int)</div>
<div class="line"><span class="lineno">  757</span>        <span class="keywordflow">yield</span> x</div>
<div class="line"><span class="lineno">  758</span> </div>
<div class="line"><span class="lineno">  759</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2c3fbfa8434bb273175aafd84fd9eb3" name="ab2c3fbfa8434bb273175aafd84fd9eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c3fbfa8434bb273175aafd84fd9eb3">&#9670;&#160;</a></span>_batch_generator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._batch_generator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A generator that yields batches of elements from an iterable</pre> <div class="fragment"><div class="line"><span class="lineno">  760</span><span class="keyword">def </span>_batch_generator(iterable, batch):</div>
<div class="line"><span class="lineno">  761</span>    <span class="stringliteral">&quot;&quot;&quot;A generator that yields batches of elements from an iterable&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  762</span>    iterator = <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(iterable)</div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">if</span> batch &lt;= 0:</div>
<div class="line"><span class="lineno">  764</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`batch` must be positive.&quot;</span>)</div>
<div class="line"><span class="lineno">  765</span>    z = [item <span class="keywordflow">for</span> i, item <span class="keywordflow">in</span> zip(range(batch), iterator)]</div>
<div class="line"><span class="lineno">  766</span>    <span class="keywordflow">while</span> z:  <span class="comment"># we don&#39;t want StopIteration without yielding an empty list</span></div>
<div class="line"><span class="lineno">  767</span>        <span class="keywordflow">yield</span> z</div>
<div class="line"><span class="lineno">  768</span>        z = [item <span class="keywordflow">for</span> i, item <span class="keywordflow">in</span> zip(range(batch), iterator)]</div>
<div class="line"><span class="lineno">  769</span> </div>
<div class="line"><span class="lineno">  770</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f04e1d5f070ff31f1343441e0d49b13" name="a2f04e1d5f070ff31f1343441e0d49b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f04e1d5f070ff31f1343441e0d49b13">&#9670;&#160;</a></span>_bca_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._bca_interval </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta_hat_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Bias-corrected and accelerated interval.</pre> <div class="fragment"><div class="line"><span class="lineno">  100</span><span class="keyword">def </span>_bca_interval(data, statistic, axis, alpha, theta_hat_b, batch):</div>
<div class="line"><span class="lineno">  101</span>    <span class="stringliteral">&quot;&quot;&quot;Bias-corrected and accelerated interval.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  102</span>    <span class="comment"># closely follows [2] &quot;BCa Bootstrap CIs&quot;</span></div>
<div class="line"><span class="lineno">  103</span>    sample = data[0]  <span class="comment"># only works with 1 sample statistics right now</span></div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span>    <span class="comment"># calculate z0_hat</span></div>
<div class="line"><span class="lineno">  106</span>    theta_hat = np.asarray(statistic(sample, axis=axis))[..., <span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno">  107</span>    percentile = _percentile_of_score(theta_hat_b, theta_hat, axis=-1)</div>
<div class="line"><span class="lineno">  108</span>    z0_hat = ndtri(percentile)</div>
<div class="line"><span class="lineno">  109</span> </div>
<div class="line"><span class="lineno">  110</span>    <span class="comment"># calculate a_hat</span></div>
<div class="line"><span class="lineno">  111</span>    theta_hat_i = []  <span class="comment"># would be better to fill pre-allocated array</span></div>
<div class="line"><span class="lineno">  112</span>    <span class="keywordflow">for</span> jackknife_sample <span class="keywordflow">in</span> _jackknife_resample(sample, batch):</div>
<div class="line"><span class="lineno">  113</span>        theta_hat_i.append(statistic(jackknife_sample, axis=-1))</div>
<div class="line"><span class="lineno">  114</span>    theta_hat_i = np.concatenate(theta_hat_i, axis=-1)</div>
<div class="line"><span class="lineno">  115</span>    theta_hat_dot = theta_hat_i.mean(axis=-1, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  116</span>    num = ((theta_hat_dot - theta_hat_i)**3).sum(axis=-1)</div>
<div class="line"><span class="lineno">  117</span>    den = 6*((theta_hat_dot - theta_hat_i)**2).sum(axis=-1)**(3/2)</div>
<div class="line"><span class="lineno">  118</span>    a_hat = num / den</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span>    <span class="comment"># calculate alpha_1, alpha_2</span></div>
<div class="line"><span class="lineno">  121</span>    z_alpha = ndtri(alpha)</div>
<div class="line"><span class="lineno">  122</span>    z_1alpha = -z_alpha</div>
<div class="line"><span class="lineno">  123</span>    num1 = z0_hat + z_alpha</div>
<div class="line"><span class="lineno">  124</span>    alpha_1 = ndtr(z0_hat + num1/(1 - a_hat*num1))</div>
<div class="line"><span class="lineno">  125</span>    num2 = z0_hat + z_1alpha</div>
<div class="line"><span class="lineno">  126</span>    alpha_2 = ndtr(z0_hat + num2/(1 - a_hat*num2))</div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">return</span> alpha_1, alpha_2</div>
<div class="line"><span class="lineno">  128</span> </div>
<div class="line"><span class="lineno">  129</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d5d6adcb1f2f5537240327cd4687a97" name="a4d5d6adcb1f2f5537240327cd4687a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5d6adcb1f2f5537240327cd4687a97">&#9670;&#160;</a></span>_bootstrap_iv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._bootstrap_iv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vectorized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>confidence_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_resamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Input validation and standardization for `bootstrap`.</pre> <div class="fragment"><div class="line"><span class="lineno">  131</span>                  n_resamples, batch, method, random_state):</div>
<div class="line"><span class="lineno">  132</span>    <span class="stringliteral">&quot;&quot;&quot;Input validation and standardization for `bootstrap`.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordflow">if</span> vectorized <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="keyword">True</span>, <span class="keyword">False</span>}:</div>
<div class="line"><span class="lineno">  135</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`vectorized` must be `True` or `False`.&quot;</span>)</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> vectorized:</div>
<div class="line"><span class="lineno">  138</span>        statistic = _vectorize_statistic(statistic)</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>    axis_int = int(axis)</div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">if</span> axis != axis_int:</div>
<div class="line"><span class="lineno">  142</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`axis` must be an integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>    n_samples = 0</div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  146</span>        n_samples = len(data)</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  148</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`data` must be a sequence of samples.&quot;</span>)</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span>    <span class="keywordflow">if</span> n_samples == 0:</div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`data` must contain at least one sample.&quot;</span>)</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    data_iv = []</div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> data:</div>
<div class="line"><span class="lineno">  155</span>        sample = np.atleast_1d(sample)</div>
<div class="line"><span class="lineno">  156</span>        <span class="keywordflow">if</span> sample.shape[axis_int] &lt;= 1:</div>
<div class="line"><span class="lineno">  157</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;each sample in `data` must contain two or more &quot;</span></div>
<div class="line"><span class="lineno">  158</span>                             <span class="stringliteral">&quot;observations along `axis`.&quot;</span>)</div>
<div class="line"><span class="lineno">  159</span>        sample = np.moveaxis(sample, axis_int, -1)</div>
<div class="line"><span class="lineno">  160</span>        data_iv.append(sample)</div>
<div class="line"><span class="lineno">  161</span> </div>
<div class="line"><span class="lineno">  162</span>    <span class="keywordflow">if</span> paired <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="keyword">True</span>, <span class="keyword">False</span>}:</div>
<div class="line"><span class="lineno">  163</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`paired` must be `True` or `False`.&quot;</span>)</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    <span class="keywordflow">if</span> paired:</div>
<div class="line"><span class="lineno">  166</span>        n = data_iv[0].shape[-1]</div>
<div class="line"><span class="lineno">  167</span>        <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> data_iv[1:]:</div>
<div class="line"><span class="lineno">  168</span>            <span class="keywordflow">if</span> sample.shape[-1] != n:</div>
<div class="line"><span class="lineno">  169</span>                message = (<span class="stringliteral">&quot;When `paired is True`, all samples must have the &quot;</span></div>
<div class="line"><span class="lineno">  170</span>                           <span class="stringliteral">&quot;same length along `axis`&quot;</span>)</div>
<div class="line"><span class="lineno">  171</span>                <span class="keywordflow">raise</span> ValueError(message)</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>        <span class="comment"># to generate the bootstrap distribution for paired-sample statistics,</span></div>
<div class="line"><span class="lineno">  174</span>        <span class="comment"># resample the indices of the observations</span></div>
<div class="line"><span class="lineno">  175</span>        <span class="keyword">def </span>statistic(i, axis=-1, data=data_iv, unpaired_statistic=statistic):</div>
<div class="line"><span class="lineno">  176</span>            data = [sample[..., i] <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> data]</div>
<div class="line"><span class="lineno">  177</span>            <span class="keywordflow">return</span> unpaired_statistic(*data, axis=axis)</div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>        data_iv = [np.arange(n)]</div>
<div class="line"><span class="lineno">  180</span> </div>
<div class="line"><span class="lineno">  181</span>    confidence_level_float = float(confidence_level)</div>
<div class="line"><span class="lineno">  182</span> </div>
<div class="line"><span class="lineno">  183</span>    n_resamples_int = int(n_resamples)</div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">if</span> n_resamples != n_resamples_int <span class="keywordflow">or</span> n_resamples_int &lt;= 0:</div>
<div class="line"><span class="lineno">  185</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`n_resamples` must be a positive integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">if</span> batch <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  188</span>        batch_iv = batch</div>
<div class="line"><span class="lineno">  189</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  190</span>        batch_iv = int(batch)</div>
<div class="line"><span class="lineno">  191</span>        <span class="keywordflow">if</span> batch != batch_iv <span class="keywordflow">or</span> batch_iv &lt;= 0:</div>
<div class="line"><span class="lineno">  192</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`batch` must be a positive integer or None.&quot;</span>)</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>    methods = {<span class="stringliteral">&#39;percentile&#39;</span>, <span class="stringliteral">&#39;basic&#39;</span>, <span class="stringliteral">&#39;bca&#39;</span>}</div>
<div class="line"><span class="lineno">  195</span>    method = method.lower()</div>
<div class="line"><span class="lineno">  196</span>    <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> methods:</div>
<div class="line"><span class="lineno">  197</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;`method` must be in {methods}&quot;</span>)</div>
<div class="line"><span class="lineno">  198</span> </div>
<div class="line"><span class="lineno">  199</span>    message = <span class="stringliteral">&quot;`method = &#39;BCa&#39; is only available for one-sample statistics&quot;</span></div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> paired <span class="keywordflow">and</span> n_samples &gt; 1 <span class="keywordflow">and</span> method == <span class="stringliteral">&#39;bca&#39;</span>:</div>
<div class="line"><span class="lineno">  201</span>        <span class="keywordflow">raise</span> ValueError(message)</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">return</span> (data_iv, statistic, vectorized, paired, axis_int,</div>
<div class="line"><span class="lineno">  206</span>            confidence_level_float, n_resamples_int, batch_iv,</div>
<div class="line"><span class="lineno">  207</span>            method, random_state)</div>
<div class="line"><span class="lineno">  208</span> </div>
<div class="line"><span class="lineno">  209</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a92d4dbf131de119c12f6c988ff2f220c" name="a92d4dbf131de119c12f6c988ff2f220c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d4dbf131de119c12f6c988ff2f220c">&#9670;&#160;</a></span>_bootstrap_resample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._bootstrap_resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_resamples</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Bootstrap resample the sample.</pre> <div class="fragment"><div class="line"><span class="lineno">   58</span><span class="keyword">def </span>_bootstrap_resample(sample, n_resamples=None, random_state=None):</div>
<div class="line"><span class="lineno">   59</span>    <span class="stringliteral">&quot;&quot;&quot;Bootstrap resample the sample.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   60</span>    n = sample.shape[-1]</div>
<div class="line"><span class="lineno">   61</span> </div>
<div class="line"><span class="lineno">   62</span>    <span class="comment"># bootstrap - each row is a random resample of original observations</span></div>
<div class="line"><span class="lineno">   63</span>    i = rng_integers(random_state, 0, n, (n_resamples, n))</div>
<div class="line"><span class="lineno">   64</span> </div>
<div class="line"><span class="lineno">   65</span>    resamples = sample[..., i]</div>
<div class="line"><span class="lineno">   66</span>    <span class="keywordflow">return</span> resamples</div>
<div class="line"><span class="lineno">   67</span> </div>
<div class="line"><span class="lineno">   68</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abce466a2e498006d6c0c57bfde7b7ce7" name="abce466a2e498006d6c0c57bfde7b7ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce466a2e498006d6c0c57bfde7b7ce7">&#9670;&#160;</a></span>_calculate_null_both()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._calculate_null_both </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_permutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate null distribution for independent sample tests.
</pre> <div class="fragment"><div class="line"><span class="lineno">  772</span>                         random_state=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  773</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    Calculate null distribution for independent sample tests.</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  776</span>    n_samples = len(data)</div>
<div class="line"><span class="lineno">  777</span> </div>
<div class="line"><span class="lineno">  778</span>    <span class="comment"># compute number of permutations</span></div>
<div class="line"><span class="lineno">  779</span>    <span class="comment"># (distinct partitions of data into samples of these sizes)</span></div>
<div class="line"><span class="lineno">  780</span>    n_obs_i = [sample.shape[-1] <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> data]  <span class="comment"># observations per sample</span></div>
<div class="line"><span class="lineno">  781</span>    n_obs_ic = np.cumsum(n_obs_i)</div>
<div class="line"><span class="lineno">  782</span>    n_obs = n_obs_ic[-1]  <span class="comment"># total number of observations</span></div>
<div class="line"><span class="lineno">  783</span>    n_max = np.prod([comb(n_obs_ic[i], n_obs_ic[i-1])</div>
<div class="line"><span class="lineno">  784</span>                     <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n_samples-1, 0, -1)])</div>
<div class="line"><span class="lineno">  785</span> </div>
<div class="line"><span class="lineno">  786</span>    <span class="comment"># perm_generator is an iterator that produces permutations of indices</span></div>
<div class="line"><span class="lineno">  787</span>    <span class="comment"># from 0 to n_obs. We&#39;ll concatenate the samples, use these indices to</span></div>
<div class="line"><span class="lineno">  788</span>    <span class="comment"># permute the data, then split the samples apart again.</span></div>
<div class="line"><span class="lineno">  789</span>    <span class="keywordflow">if</span> n_permutations &gt;= n_max:</div>
<div class="line"><span class="lineno">  790</span>        exact_test = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  791</span>        n_permutations = n_max</div>
<div class="line"><span class="lineno">  792</span>        perm_generator = _all_partitions_concatenated(n_obs_i)</div>
<div class="line"><span class="lineno">  793</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  794</span>        exact_test = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  795</span>        <span class="comment"># Neither RandomState.permutation nor Generator.permutation</span></div>
<div class="line"><span class="lineno">  796</span>        <span class="comment"># can permute axis-slices independently. If this feature is</span></div>
<div class="line"><span class="lineno">  797</span>        <span class="comment"># added in the future, batches of the desired size should be</span></div>
<div class="line"><span class="lineno">  798</span>        <span class="comment"># generated in a single call.</span></div>
<div class="line"><span class="lineno">  799</span>        perm_generator = (random_state.permutation(n_obs)</div>
<div class="line"><span class="lineno">  800</span>                          <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n_permutations))</div>
<div class="line"><span class="lineno">  801</span> </div>
<div class="line"><span class="lineno">  802</span>    batch = batch <span class="keywordflow">or</span> int(n_permutations)</div>
<div class="line"><span class="lineno">  803</span>    null_distribution = []</div>
<div class="line"><span class="lineno">  804</span> </div>
<div class="line"><span class="lineno">  805</span>    <span class="comment"># First, concatenate all the samples. In batches, permute samples with</span></div>
<div class="line"><span class="lineno">  806</span>    <span class="comment"># indices produced by the `perm_generator`, split them into new samples of</span></div>
<div class="line"><span class="lineno">  807</span>    <span class="comment"># the original sizes, compute the statistic for each batch, and add these</span></div>
<div class="line"><span class="lineno">  808</span>    <span class="comment"># statistic values to the null distribution.</span></div>
<div class="line"><span class="lineno">  809</span>    data = np.concatenate(data, axis=-1)</div>
<div class="line"><span class="lineno">  810</span>    <span class="keywordflow">for</span> indices <span class="keywordflow">in</span> _batch_generator(perm_generator, batch=batch):</div>
<div class="line"><span class="lineno">  811</span>        indices = np.array(indices)</div>
<div class="line"><span class="lineno">  812</span> </div>
<div class="line"><span class="lineno">  813</span>        <span class="comment"># `indices` is 2D: each row is a permutation of the indices.</span></div>
<div class="line"><span class="lineno">  814</span>        <span class="comment"># We use it to index `data` along its last axis, which corresponds</span></div>
<div class="line"><span class="lineno">  815</span>        <span class="comment"># with observations.</span></div>
<div class="line"><span class="lineno">  816</span>        <span class="comment"># After indexing, the second to last axis of `data_batch` corresponds</span></div>
<div class="line"><span class="lineno">  817</span>        <span class="comment"># with permutations, and the last axis corresponds with observations.</span></div>
<div class="line"><span class="lineno">  818</span>        data_batch = data[..., indices]</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>        <span class="comment"># Move the permutation axis to the front: we&#39;ll concatenate a list</span></div>
<div class="line"><span class="lineno">  821</span>        <span class="comment"># of batched statistic values along this zeroth axis to form the</span></div>
<div class="line"><span class="lineno">  822</span>        <span class="comment"># null distribution.</span></div>
<div class="line"><span class="lineno">  823</span>        data_batch = np.moveaxis(data_batch, -2, 0)</div>
<div class="line"><span class="lineno">  824</span>        data_batch = np.split(data_batch, n_obs_ic[:-1], axis=-1)</div>
<div class="line"><span class="lineno">  825</span>        null_distribution.append(statistic(*data_batch, axis=-1))</div>
<div class="line"><span class="lineno">  826</span>    null_distribution = np.concatenate(null_distribution, axis=0)</div>
<div class="line"><span class="lineno">  827</span> </div>
<div class="line"><span class="lineno">  828</span>    <span class="keywordflow">return</span> null_distribution, n_permutations, exact_test</div>
<div class="line"><span class="lineno">  829</span> </div>
<div class="line"><span class="lineno">  830</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a164b747bb35a0a8fc563729ec8e72e5d" name="a164b747bb35a0a8fc563729ec8e72e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164b747bb35a0a8fc563729ec8e72e5d">&#9670;&#160;</a></span>_calculate_null_pairings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._calculate_null_pairings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_permutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate null distribution for association tests.
</pre> <div class="fragment"><div class="line"><span class="lineno">  832</span>                             random_state=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  833</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    Calculate null distribution for association tests.</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  836</span>    n_samples = len(data)</div>
<div class="line"><span class="lineno">  837</span> </div>
<div class="line"><span class="lineno">  838</span>    <span class="comment"># compute number of permutations (factorial(n) permutations of each sample)</span></div>
<div class="line"><span class="lineno">  839</span>    n_obs_sample = data[0].shape[-1]  <span class="comment"># observations per sample; same for each</span></div>
<div class="line"><span class="lineno">  840</span>    n_max = factorial(n_obs_sample)**n_samples</div>
<div class="line"><span class="lineno">  841</span> </div>
<div class="line"><span class="lineno">  842</span>    <span class="comment"># `perm_generator` is an iterator that produces a list of permutations of</span></div>
<div class="line"><span class="lineno">  843</span>    <span class="comment"># indices from 0 to n_obs_sample, one for each sample.</span></div>
<div class="line"><span class="lineno">  844</span>    <span class="keywordflow">if</span> n_permutations &gt;= n_max:</div>
<div class="line"><span class="lineno">  845</span>        exact_test = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  846</span>        n_permutations = n_max</div>
<div class="line"><span class="lineno">  847</span>        <span class="comment"># cartesian product of the sets of all permutations of indices</span></div>
<div class="line"><span class="lineno">  848</span>        perm_generator = product(*(permutations(range(n_obs_sample))</div>
<div class="line"><span class="lineno">  849</span>                                   <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n_samples)))</div>
<div class="line"><span class="lineno">  850</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  851</span>        exact_test = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  852</span>        <span class="comment"># Separate random permutations of indices for each sample.</span></div>
<div class="line"><span class="lineno">  853</span>        <span class="comment"># Again, it would be nice if RandomState/Generator.permutation</span></div>
<div class="line"><span class="lineno">  854</span>        <span class="comment"># could permute each axis-slice separately.</span></div>
<div class="line"><span class="lineno">  855</span>        perm_generator = ([random_state.permutation(n_obs_sample)</div>
<div class="line"><span class="lineno">  856</span>                           <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n_samples)]</div>
<div class="line"><span class="lineno">  857</span>                          <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(n_permutations))</div>
<div class="line"><span class="lineno">  858</span> </div>
<div class="line"><span class="lineno">  859</span>    batch = batch <span class="keywordflow">or</span> int(n_permutations)</div>
<div class="line"><span class="lineno">  860</span>    null_distribution = []</div>
<div class="line"><span class="lineno">  861</span> </div>
<div class="line"><span class="lineno">  862</span>    <span class="keywordflow">for</span> indices <span class="keywordflow">in</span> _batch_generator(perm_generator, batch=batch):</div>
<div class="line"><span class="lineno">  863</span>        indices = np.array(indices)</div>
<div class="line"><span class="lineno">  864</span> </div>
<div class="line"><span class="lineno">  865</span>        <span class="comment"># `indices` is 3D: the zeroth axis is for permutations, the next is</span></div>
<div class="line"><span class="lineno">  866</span>        <span class="comment"># for samples, and the last is for observations. Swap the first two</span></div>
<div class="line"><span class="lineno">  867</span>        <span class="comment"># to make the zeroth axis correspond with samples, as it does for</span></div>
<div class="line"><span class="lineno">  868</span>        <span class="comment"># `data`.</span></div>
<div class="line"><span class="lineno">  869</span>        indices = np.swapaxes(indices, 0, 1)</div>
<div class="line"><span class="lineno">  870</span> </div>
<div class="line"><span class="lineno">  871</span>        <span class="comment"># When we&#39;re done, `data_batch` will be a list of length `n_samples`.</span></div>
<div class="line"><span class="lineno">  872</span>        <span class="comment"># Each element will be a batch of random permutations of one sample.</span></div>
<div class="line"><span class="lineno">  873</span>        <span class="comment"># The zeroth axis of each batch will correspond with permutations,</span></div>
<div class="line"><span class="lineno">  874</span>        <span class="comment"># and the last will correspond with observations. (This makes it</span></div>
<div class="line"><span class="lineno">  875</span>        <span class="comment"># easy to pass into `statistic`.)</span></div>
<div class="line"><span class="lineno">  876</span>        data_batch = [<span class="keywordtype">None</span>]*n_samples</div>
<div class="line"><span class="lineno">  877</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n_samples):</div>
<div class="line"><span class="lineno">  878</span>            data_batch[i] = data[i][..., indices[i]]</div>
<div class="line"><span class="lineno">  879</span>            data_batch[i] = np.moveaxis(data_batch[i], -2, 0)</div>
<div class="line"><span class="lineno">  880</span> </div>
<div class="line"><span class="lineno">  881</span>        null_distribution.append(statistic(*data_batch, axis=-1))</div>
<div class="line"><span class="lineno">  882</span>    null_distribution = np.concatenate(null_distribution, axis=0)</div>
<div class="line"><span class="lineno">  883</span> </div>
<div class="line"><span class="lineno">  884</span>    <span class="keywordflow">return</span> null_distribution, n_permutations, exact_test</div>
<div class="line"><span class="lineno">  885</span> </div>
<div class="line"><span class="lineno">  886</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a281bd931b030ac46a8df78e1ae2ce06c" name="a281bd931b030ac46a8df78e1ae2ce06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281bd931b030ac46a8df78e1ae2ce06c">&#9670;&#160;</a></span>_calculate_null_samples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._calculate_null_samples </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_permutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate null distribution for paired-sample tests.
</pre> <div class="fragment"><div class="line"><span class="lineno">  888</span>                            random_state=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  889</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">    Calculate null distribution for paired-sample tests.</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  892</span>    n_samples = len(data)</div>
<div class="line"><span class="lineno">  893</span> </div>
<div class="line"><span class="lineno">  894</span>    <span class="comment"># By convention, the meaning of the &quot;samples&quot; permutations type for</span></div>
<div class="line"><span class="lineno">  895</span>    <span class="comment"># data with only one sample is to flip the sign of the observations.</span></div>
<div class="line"><span class="lineno">  896</span>    <span class="comment"># Achieve this by adding a second sample - the negative of the original.</span></div>
<div class="line"><span class="lineno">  897</span>    <span class="keywordflow">if</span> n_samples == 1:</div>
<div class="line"><span class="lineno">  898</span>        data = [data[0], -data[0]]</div>
<div class="line"><span class="lineno">  899</span> </div>
<div class="line"><span class="lineno">  900</span>    <span class="comment"># The &quot;samples&quot; permutation strategy is the same as the &quot;pairings&quot;</span></div>
<div class="line"><span class="lineno">  901</span>    <span class="comment"># strategy except the roles of samples and observations are flipped.</span></div>
<div class="line"><span class="lineno">  902</span>    <span class="comment"># So swap these axes, then we&#39;ll use the function for the &quot;pairings&quot;</span></div>
<div class="line"><span class="lineno">  903</span>    <span class="comment"># strategy to do all the work!</span></div>
<div class="line"><span class="lineno">  904</span>    data = np.swapaxes(data, 0, -1)</div>
<div class="line"><span class="lineno">  905</span> </div>
<div class="line"><span class="lineno">  906</span>    <span class="comment"># (Of course, the user&#39;s statistic doesn&#39;t know what we&#39;ve done here,</span></div>
<div class="line"><span class="lineno">  907</span>    <span class="comment"># so we need to pass it what it&#39;s expecting.)</span></div>
<div class="line"><span class="lineno">  908</span>    <span class="keyword">def </span>statistic_wrapped(*data, axis):</div>
<div class="line"><span class="lineno">  909</span>        data = np.swapaxes(data, 0, -1)</div>
<div class="line"><span class="lineno">  910</span>        <span class="keywordflow">if</span> n_samples == 1:</div>
<div class="line"><span class="lineno">  911</span>            data = data[0:1]</div>
<div class="line"><span class="lineno">  912</span>        <span class="keywordflow">return</span> statistic(*data, axis=axis)</div>
<div class="line"><span class="lineno">  913</span> </div>
<div class="line"><span class="lineno">  914</span>    <span class="keywordflow">return</span> _calculate_null_pairings(data, statistic_wrapped, n_permutations,</div>
<div class="line"><span class="lineno">  915</span>                                    batch, random_state)</div>
<div class="line"><span class="lineno">  916</span> </div>
<div class="line"><span class="lineno">  917</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a769ff272403e86cb56c70da1815f7578" name="a769ff272403e86cb56c70da1815f7578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769ff272403e86cb56c70da1815f7578">&#9670;&#160;</a></span>_jackknife_resample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._jackknife_resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Jackknife resample the sample. Only one-sample stats for now.</pre> <div class="fragment"><div class="line"><span class="lineno">   38</span><span class="keyword">def </span>_jackknife_resample(sample, batch=None):</div>
<div class="line"><span class="lineno">   39</span>    <span class="stringliteral">&quot;&quot;&quot;Jackknife resample the sample. Only one-sample stats for now.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   40</span>    n = sample.shape[-1]</div>
<div class="line"><span class="lineno">   41</span>    batch_nominal = batch <span class="keywordflow">or</span> n</div>
<div class="line"><span class="lineno">   42</span> </div>
<div class="line"><span class="lineno">   43</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(0, n, batch_nominal):</div>
<div class="line"><span class="lineno">   44</span>        <span class="comment"># col_start:col_end are the observations to remove</span></div>
<div class="line"><span class="lineno">   45</span>        batch_actual = min(batch_nominal, n-k)</div>
<div class="line"><span class="lineno">   46</span> </div>
<div class="line"><span class="lineno">   47</span>        <span class="comment"># jackknife - each row leaves out one observation</span></div>
<div class="line"><span class="lineno">   48</span>        j = np.ones((batch_actual, n), dtype=bool)</div>
<div class="line"><span class="lineno">   49</span>        np.fill_diagonal(j[:, k:k+batch_actual], <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">   50</span>        i = np.arange(n)</div>
<div class="line"><span class="lineno">   51</span>        i = np.broadcast_to(i, (batch_actual, n))</div>
<div class="line"><span class="lineno">   52</span>        i = i[j].reshape((batch_actual, n-1))</div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span>        resamples = sample[..., i]</div>
<div class="line"><span class="lineno">   55</span>        <span class="keywordflow">yield</span> resamples</div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a746945289289f851a284d03ade01f838" name="a746945289289f851a284d03ade01f838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746945289289f851a284d03ade01f838">&#9670;&#160;</a></span>_monte_carlo_test_iv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._monte_carlo_test_iv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vectorized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_resamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Input validation for `monte_carlo_test`.</pre> <div class="fragment"><div class="line"><span class="lineno">  497</span>                         batch, alternative, axis):</div>
<div class="line"><span class="lineno">  498</span>    <span class="stringliteral">&quot;&quot;&quot;Input validation for `monte_carlo_test`.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  499</span> </div>
<div class="line"><span class="lineno">  500</span>    axis_int = int(axis)</div>
<div class="line"><span class="lineno">  501</span>    <span class="keywordflow">if</span> axis != axis_int:</div>
<div class="line"><span class="lineno">  502</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`axis` must be an integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  503</span> </div>
<div class="line"><span class="lineno">  504</span>    <span class="keywordflow">if</span> vectorized <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="keyword">True</span>, <span class="keyword">False</span>}:</div>
<div class="line"><span class="lineno">  505</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`vectorized` must be `True` or `False`.&quot;</span>)</div>
<div class="line"><span class="lineno">  506</span> </div>
<div class="line"><span class="lineno">  507</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(rvs):</div>
<div class="line"><span class="lineno">  508</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;`rvs` must be callable.&quot;</span>)</div>
<div class="line"><span class="lineno">  509</span> </div>
<div class="line"><span class="lineno">  510</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(statistic):</div>
<div class="line"><span class="lineno">  511</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;`statistic` must be callable.&quot;</span>)</div>
<div class="line"><span class="lineno">  512</span> </div>
<div class="line"><span class="lineno">  513</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> vectorized:</div>
<div class="line"><span class="lineno">  514</span>        statistic_vectorized = _vectorize_statistic(statistic)</div>
<div class="line"><span class="lineno">  515</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  516</span>        statistic_vectorized = statistic</div>
<div class="line"><span class="lineno">  517</span> </div>
<div class="line"><span class="lineno">  518</span>    sample = np.atleast_1d(sample)</div>
<div class="line"><span class="lineno">  519</span>    sample = np.moveaxis(sample, axis, -1)</div>
<div class="line"><span class="lineno">  520</span> </div>
<div class="line"><span class="lineno">  521</span>    n_resamples_int = int(n_resamples)</div>
<div class="line"><span class="lineno">  522</span>    <span class="keywordflow">if</span> n_resamples != n_resamples_int <span class="keywordflow">or</span> n_resamples_int &lt;= 0:</div>
<div class="line"><span class="lineno">  523</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`n_resamples` must be a positive integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  524</span> </div>
<div class="line"><span class="lineno">  525</span>    <span class="keywordflow">if</span> batch <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  526</span>        batch_iv = batch</div>
<div class="line"><span class="lineno">  527</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  528</span>        batch_iv = int(batch)</div>
<div class="line"><span class="lineno">  529</span>        <span class="keywordflow">if</span> batch != batch_iv <span class="keywordflow">or</span> batch_iv &lt;= 0:</div>
<div class="line"><span class="lineno">  530</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`batch` must be a positive integer or None.&quot;</span>)</div>
<div class="line"><span class="lineno">  531</span> </div>
<div class="line"><span class="lineno">  532</span>    alternatives = {<span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>}</div>
<div class="line"><span class="lineno">  533</span>    alternative = alternative.lower()</div>
<div class="line"><span class="lineno">  534</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> alternatives:</div>
<div class="line"><span class="lineno">  535</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;`alternative` must be in {alternatives}&quot;</span>)</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>    <span class="keywordflow">return</span> (sample, rvs, statistic_vectorized, vectorized, n_resamples_int,</div>
<div class="line"><span class="lineno">  538</span>            batch_iv, alternative, axis_int)</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acbe7a1919ac1faf534dd1e5e3f091543" name="acbe7a1919ac1faf534dd1e5e3f091543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe7a1919ac1faf534dd1e5e3f091543">&#9670;&#160;</a></span>_percentile_along_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._percentile_along_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta_hat_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">`np.percentile` with different percentile for each slice.</pre> <div class="fragment"><div class="line"><span class="lineno">   79</span><span class="keyword">def </span>_percentile_along_axis(theta_hat_b, alpha):</div>
<div class="line"><span class="lineno">   80</span>    <span class="stringliteral">&quot;&quot;&quot;`np.percentile` with different percentile for each slice.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   81</span>    <span class="comment"># the difference between _percentile_along_axis and np.percentile is that</span></div>
<div class="line"><span class="lineno">   82</span>    <span class="comment"># np.percentile gets _all_ the qs for each axis slice, whereas</span></div>
<div class="line"><span class="lineno">   83</span>    <span class="comment"># _percentile_along_axis gets the q corresponding with each axis slice</span></div>
<div class="line"><span class="lineno">   84</span>    shape = theta_hat_b.shape[:-1]</div>
<div class="line"><span class="lineno">   85</span>    alpha = np.broadcast_to(alpha, shape)</div>
<div class="line"><span class="lineno">   86</span>    percentiles = np.zeros_like(alpha, dtype=np.float64)</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">for</span> indices, alpha_i <span class="keywordflow">in</span> np.ndenumerate(alpha):</div>
<div class="line"><span class="lineno">   88</span>        <span class="keywordflow">if</span> np.isnan(alpha_i):</div>
<div class="line"><span class="lineno">   89</span>            <span class="comment"># e.g. when bootstrap distribution has only one unique element</span></div>
<div class="line"><span class="lineno">   90</span>            msg = (<span class="stringliteral">&quot;The bootstrap distribution is degenerate; the &quot;</span></div>
<div class="line"><span class="lineno">   91</span>                   <span class="stringliteral">&quot;confidence interval is not defined.&quot;</span>)</div>
<div class="line"><span class="lineno">   92</span>            warnings.warn(DegenerateDataWarning(msg))</div>
<div class="line"><span class="lineno">   93</span>            percentiles[indices] = np.nan</div>
<div class="line"><span class="lineno">   94</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   95</span>            theta_hat_b_i = theta_hat_b[indices]</div>
<div class="line"><span class="lineno">   96</span>            percentiles[indices] = np.percentile(theta_hat_b_i, alpha_i)</div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">return</span> percentiles[()]  <span class="comment"># return scalar instead of 0d array</span></div>
<div class="line"><span class="lineno">   98</span> </div>
<div class="line"><span class="lineno">   99</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d690dafccfb69022dcf50b4c19becdd" name="a4d690dafccfb69022dcf50b4c19becdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d690dafccfb69022dcf50b4c19becdd">&#9670;&#160;</a></span>_percentile_of_score()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._percentile_of_score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Vectorized, simplified `scipy.stats.percentileofscore`.

Unlike `stats.percentileofscore`, the percentile returned is a fraction
in [0, 1].
</pre> <div class="fragment"><div class="line"><span class="lineno">   69</span><span class="keyword">def </span>_percentile_of_score(a, score, axis):</div>
<div class="line"><span class="lineno">   70</span>    <span class="stringliteral">&quot;&quot;&quot;Vectorized, simplified `scipy.stats.percentileofscore`.</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    Unlike `stats.percentileofscore`, the percentile returned is a fraction</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    in [0, 1].</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   75</span>    B = a.shape[axis]</div>
<div class="line"><span class="lineno">   76</span>    <span class="keywordflow">return</span> (a &lt; score).sum(axis=axis) / B</div>
<div class="line"><span class="lineno">   77</span> </div>
<div class="line"><span class="lineno">   78</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa7528e2c981d6bb79547bdb33da599a" name="aaa7528e2c981d6bb79547bdb33da599a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7528e2c981d6bb79547bdb33da599a">&#9670;&#160;</a></span>_permutation_test_iv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._permutation_test_iv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permutation_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vectorized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_resamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Input validation for `permutation_test`.</pre> <div class="fragment"><div class="line"><span class="lineno">  919</span>                         n_resamples, batch, alternative, axis, random_state):</div>
<div class="line"><span class="lineno">  920</span>    <span class="stringliteral">&quot;&quot;&quot;Input validation for `permutation_test`.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  921</span> </div>
<div class="line"><span class="lineno">  922</span>    axis_int = int(axis)</div>
<div class="line"><span class="lineno">  923</span>    <span class="keywordflow">if</span> axis != axis_int:</div>
<div class="line"><span class="lineno">  924</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`axis` must be an integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span>    permutation_types = {<span class="stringliteral">&#39;samples&#39;</span>, <span class="stringliteral">&#39;pairings&#39;</span>, <span class="stringliteral">&#39;independent&#39;</span>}</div>
<div class="line"><span class="lineno">  927</span>    permutation_type = permutation_type.lower()</div>
<div class="line"><span class="lineno">  928</span>    <span class="keywordflow">if</span> permutation_type <span class="keywordflow">not</span> <span class="keywordflow">in</span> permutation_types:</div>
<div class="line"><span class="lineno">  929</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;`permutation_type` must be in {permutation_types}.&quot;</span>)</div>
<div class="line"><span class="lineno">  930</span> </div>
<div class="line"><span class="lineno">  931</span>    <span class="keywordflow">if</span> vectorized <span class="keywordflow">not</span> <span class="keywordflow">in</span> {<span class="keyword">True</span>, <span class="keyword">False</span>}:</div>
<div class="line"><span class="lineno">  932</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`vectorized` must be `True` or `False`.&quot;</span>)</div>
<div class="line"><span class="lineno">  933</span> </div>
<div class="line"><span class="lineno">  934</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> vectorized:</div>
<div class="line"><span class="lineno">  935</span>        statistic = _vectorize_statistic(statistic)</div>
<div class="line"><span class="lineno">  936</span> </div>
<div class="line"><span class="lineno">  937</span>    message = <span class="stringliteral">&quot;`data` must be a tuple containing at least two samples&quot;</span></div>
<div class="line"><span class="lineno">  938</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  939</span>        <span class="keywordflow">if</span> len(data) &lt; 2 <span class="keywordflow">and</span> permutation_type == <span class="stringliteral">&#39;independent&#39;</span>:</div>
<div class="line"><span class="lineno">  940</span>            <span class="keywordflow">raise</span> ValueError(message)</div>
<div class="line"><span class="lineno">  941</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  942</span>        <span class="keywordflow">raise</span> TypeError(message)</div>
<div class="line"><span class="lineno">  943</span> </div>
<div class="line"><span class="lineno">  944</span>    data = _broadcast_arrays(data, axis)</div>
<div class="line"><span class="lineno">  945</span>    data_iv = []</div>
<div class="line"><span class="lineno">  946</span>    <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> data:</div>
<div class="line"><span class="lineno">  947</span>        sample = np.atleast_1d(sample)</div>
<div class="line"><span class="lineno">  948</span>        <span class="keywordflow">if</span> sample.shape[axis] &lt;= 1:</div>
<div class="line"><span class="lineno">  949</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;each sample in `data` must contain two or more &quot;</span></div>
<div class="line"><span class="lineno">  950</span>                             <span class="stringliteral">&quot;observations along `axis`.&quot;</span>)</div>
<div class="line"><span class="lineno">  951</span>        sample = np.moveaxis(sample, axis_int, -1)</div>
<div class="line"><span class="lineno">  952</span>        data_iv.append(sample)</div>
<div class="line"><span class="lineno">  953</span> </div>
<div class="line"><span class="lineno">  954</span>    n_resamples_int = (int(n_resamples) <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.isinf(n_resamples)</div>
<div class="line"><span class="lineno">  955</span>                       <span class="keywordflow">else</span> np.inf)</div>
<div class="line"><span class="lineno">  956</span>    <span class="keywordflow">if</span> n_resamples != n_resamples_int <span class="keywordflow">or</span> n_resamples_int &lt;= 0:</div>
<div class="line"><span class="lineno">  957</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`n_resamples` must be a positive integer.&quot;</span>)</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span>    <span class="keywordflow">if</span> batch <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  960</span>        batch_iv = batch</div>
<div class="line"><span class="lineno">  961</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  962</span>        batch_iv = int(batch)</div>
<div class="line"><span class="lineno">  963</span>        <span class="keywordflow">if</span> batch != batch_iv <span class="keywordflow">or</span> batch_iv &lt;= 0:</div>
<div class="line"><span class="lineno">  964</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;`batch` must be a positive integer or None.&quot;</span>)</div>
<div class="line"><span class="lineno">  965</span> </div>
<div class="line"><span class="lineno">  966</span>    alternatives = {<span class="stringliteral">&#39;two-sided&#39;</span>, <span class="stringliteral">&#39;greater&#39;</span>, <span class="stringliteral">&#39;less&#39;</span>}</div>
<div class="line"><span class="lineno">  967</span>    alternative = alternative.lower()</div>
<div class="line"><span class="lineno">  968</span>    <span class="keywordflow">if</span> alternative <span class="keywordflow">not</span> <span class="keywordflow">in</span> alternatives:</div>
<div class="line"><span class="lineno">  969</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;`alternative` must be in {alternatives}&quot;</span>)</div>
<div class="line"><span class="lineno">  970</span> </div>
<div class="line"><span class="lineno">  971</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>    <span class="keywordflow">return</span> (data_iv, statistic, permutation_type, vectorized, n_resamples_int,</div>
<div class="line"><span class="lineno">  974</span>            batch_iv, alternative, axis_int, random_state)</div>
<div class="line"><span class="lineno">  975</span> </div>
<div class="line"><span class="lineno">  976</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1cbf31c18034ecab33c5c808b268dd86" name="a1cbf31c18034ecab33c5c808b268dd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbf31c18034ecab33c5c808b268dd86">&#9670;&#160;</a></span>_vectorize_statistic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling._vectorize_statistic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Vectorize an n-sample statistic</pre> <div class="fragment"><div class="line"><span class="lineno">   16</span><span class="keyword">def </span>_vectorize_statistic(statistic):</div>
<div class="line"><span class="lineno">   17</span>    <span class="stringliteral">&quot;&quot;&quot;Vectorize an n-sample statistic&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   18</span>    <span class="comment"># This is a little cleaner than np.nditer at the expense of some data</span></div>
<div class="line"><span class="lineno">   19</span>    <span class="comment"># copying: concatenate samples together, then use np.apply_along_axis</span></div>
<div class="line"><span class="lineno">   20</span>    <span class="keyword">def </span>stat_nd(*data, axis=0):</div>
<div class="line"><span class="lineno">   21</span>        lengths = [sample.shape[axis] <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> data]</div>
<div class="line"><span class="lineno">   22</span>        split_indices = np.cumsum(lengths)[:-1]</div>
<div class="line"><span class="lineno">   23</span>        z = _broadcast_concatenate(data, axis)</div>
<div class="line"><span class="lineno">   24</span> </div>
<div class="line"><span class="lineno">   25</span>        <span class="comment"># move working axis to position 0 so that new dimensions in the output</span></div>
<div class="line"><span class="lineno">   26</span>        <span class="comment"># of `statistic` are _prepended_. (&quot;This axis is removed, and replaced</span></div>
<div class="line"><span class="lineno">   27</span>        <span class="comment"># with new dimensions...&quot;)</span></div>
<div class="line"><span class="lineno">   28</span>        z = np.moveaxis(z, axis, 0)</div>
<div class="line"><span class="lineno">   29</span> </div>
<div class="line"><span class="lineno">   30</span>        <span class="keyword">def </span>stat_1d(z):</div>
<div class="line"><span class="lineno">   31</span>            data = np.split(z, split_indices)</div>
<div class="line"><span class="lineno">   32</span>            <span class="keywordflow">return</span> statistic(*data)</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span>        <span class="keywordflow">return</span> np.apply_along_axis(stat_1d, 0, z)[()]</div>
<div class="line"><span class="lineno">   35</span>    <span class="keywordflow">return</span> stat_nd</div>
<div class="line"><span class="lineno">   36</span> </div>
<div class="line"><span class="lineno">   37</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aec6f2089dc72d84cf7469193d59d6770" name="aec6f2089dc72d84cf7469193d59d6770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f2089dc72d84cf7469193d59d6770">&#9670;&#160;</a></span>bootstrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling.bootstrap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>n_resamples</em> = <code>9999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vectorized</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paired</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>confidence_level</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'BCa'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a two-sided bootstrap confidence interval of a statistic.

When `method` is ``'percentile'``, a bootstrap confidence interval is
computed according to the following procedure.

1. Resample the data: for each sample in `data` and for each of
`n_resamples`, take a random sample of the original sample
(with replacement) of the same size as the original sample.

2. Compute the bootstrap distribution of the statistic: for each set of
resamples, compute the test statistic.

3. Determine the confidence interval: find the interval of the bootstrap
distribution that is

- symmetric about the median and
- contains `confidence_level` of the resampled statistic values.

While the ``'percentile'`` method is the most intuitive, it is rarely
used in practice. Two more common methods are available, ``'basic'``
('reverse percentile') and ``'BCa'`` ('bias-corrected and accelerated');
they differ in how step 3 is performed.

If the samples in `data` are  taken at random from their respective
distributions :math:`n` times, the confidence interval returned by
`bootstrap` will contain the true value of the statistic for those
distributions approximately `confidence_level`:math:`\, \times \, n` times.

Parameters
----------
data : sequence of array-like
 Each element of data is a sample from an underlying distribution.
statistic : callable
Statistic for which the confidence interval is to be calculated.
`statistic` must be a callable that accepts ``len(data)`` samples
as separate arguments and returns the resulting statistic.
If `vectorized` is set ``True``,
`statistic` must also accept a keyword argument `axis` and be
vectorized to compute the statistic along the provided `axis`.
n_resamples : int, default: ``9999``
The number of resamples performed to form the bootstrap distribution
of the statistic.
batch : int, optional
The number of resamples to process in each vectorized call to
`statistic`. Memory usage is O(`batch`*``n``), where ``n`` is the
sample size. Default is ``None``, in which case ``batch = n_resamples``
(or ``batch = max(n_resamples, n)`` for ``method='BCa'``).
vectorized : bool, default: ``True``
If `vectorized` is set ``False``, `statistic` will not be passed
keyword argument `axis`, and is assumed to calculate the statistic
only for 1D samples.
paired : bool, default: ``False``
Whether the statistic treats corresponding elements of the samples
in `data` as paired.
axis : int, default: ``0``
The axis of the samples in `data` along which the `statistic` is
calculated.
confidence_level : float, default: ``0.95``
The confidence level of the confidence interval.
method : {'percentile', 'basic', 'bca'}, default: ``'BCa'``
Whether to return the 'percentile' bootstrap confidence interval
(``'percentile'``), the 'reverse' or the bias-corrected and accelerated
bootstrap confidence interval (``'BCa'``).
Note that only ``'percentile'`` and ``'basic'`` support multi-sample
statistics at this time.
random_state : {None, int, `numpy.random.Generator`,
            `numpy.random.RandomState`}, optional

Pseudorandom number generator state used to generate resamples.

If `random_state` is ``None`` (or `np.random`), the
`numpy.random.RandomState` singleton is used.
If `random_state` is an int, a new ``RandomState`` instance is used,
seeded with `random_state`.
If `random_state` is already a ``Generator`` or ``RandomState``
instance then that instance is used.

Returns
-------
res : BootstrapResult
An object with attributes:

confidence_interval : ConfidenceInterval
    The bootstrap confidence interval as an instance of
    `collections.namedtuple` with attributes `low` and `high`.
standard_error : float or ndarray
    The bootstrap standard error, that is, the sample standard
    deviation of the bootstrap distribution

Warns
-----
`~scipy.stats.DegenerateDataWarning`
Generated when ``method='BCa'`` and the bootstrap distribution is
degenerate (e.g. all elements are identical).

Notes
-----
Elements of the confidence interval may be NaN for ``method='BCa'`` if
the bootstrap distribution is degenerate (e.g. all elements are identical).
In this case, consider using another `method` or inspecting `data` for
indications that other analysis may be more appropriate (e.g. all
observations are identical).

References
----------
.. [1] B. Efron and R. J. Tibshirani, An Introduction to the Bootstrap,
Chapman &amp; Hall/CRC, Boca Raton, FL, USA (1993)
.. [2] Nathaniel E. Helwig, "Bootstrap Confidence Intervals",
http://users.stat.umn.edu/~helwig/notes/bootci-Notes.pdf
.. [3] Bootstrapping (statistics), Wikipedia,
https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29

Examples
--------
Suppose we have sampled data from an unknown distribution.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; from scipy.stats import norm
&gt;&gt;&gt; dist = norm(loc=2, scale=4)  # our "unknown" distribution
&gt;&gt;&gt; data = dist.rvs(size=100, random_state=rng)

We are interested int the standard deviation of the distribution.

&gt;&gt;&gt; std_true = dist.std()      # the true value of the statistic
&gt;&gt;&gt; print(std_true)
4.0
&gt;&gt;&gt; std_sample = np.std(data)  # the sample statistic
&gt;&gt;&gt; print(std_sample)
3.9460644295563863

We can calculate a 90% confidence interval of the statistic using
`bootstrap`.

&gt;&gt;&gt; from scipy.stats import bootstrap
&gt;&gt;&gt; data = (data,)  # samples must be in a sequence
&gt;&gt;&gt; res = bootstrap(data, np.std, confidence_level=0.9,
...                 random_state=rng)
&gt;&gt;&gt; print(res.confidence_interval)
ConfidenceInterval(low=3.57655333533867, high=4.382043696342881)

If we sample from the distribution 1000 times and form a bootstrap
confidence interval for each sample, the confidence interval
contains the true value of the statistic approximately 900 times.

&gt;&gt;&gt; n_trials = 1000
&gt;&gt;&gt; ci_contains_true_std = 0
&gt;&gt;&gt; for i in range(n_trials):
...    data = (dist.rvs(size=100, random_state=rng),)
...    ci = bootstrap(data, np.std, confidence_level=0.9, n_resamples=1000,
...                   random_state=rng).confidence_interval
...    if ci[0] &lt; std_true &lt; ci[1]:
...        ci_contains_true_std += 1
&gt;&gt;&gt; print(ci_contains_true_std)
875

Rather than writing a loop, we can also determine the confidence intervals
for all 1000 samples at once.

&gt;&gt;&gt; data = (dist.rvs(size=(n_trials, 100), random_state=rng),)
&gt;&gt;&gt; res = bootstrap(data, np.std, axis=-1, confidence_level=0.9,
...                 n_resamples=1000, random_state=rng)
&gt;&gt;&gt; ci_l, ci_u = res.confidence_interval

Here, `ci_l` and `ci_u` contain the confidence interval for each of the
``n_trials = 1000`` samples.

&gt;&gt;&gt; print(ci_l[995:])
[3.77729695 3.75090233 3.45829131 3.34078217 3.48072829]
&gt;&gt;&gt; print(ci_u[995:])
[4.88316666 4.86924034 4.32032996 4.2822427  4.59360598]

And again, approximately 90% contain the true value, ``std_true = 4``.

&gt;&gt;&gt; print(np.sum((ci_l &lt; std_true) &amp; (std_true &lt; ci_u)))
900

`bootstrap` can also be used to estimate confidence intervals of
multi-sample statistics, including those calculated by hypothesis
tests. `scipy.stats.mood` perform's Mood's test for equal scale parameters,
and it returns two outputs: a statistic, and a p-value. To get a
confidence interval for the test statistic, we first wrap
`scipy.stats.mood` in a function that accepts two sample arguments,
accepts an `axis` keyword argument, and returns only the statistic.

&gt;&gt;&gt; from scipy.stats import mood
&gt;&gt;&gt; def my_statistic(sample1, sample2, axis):
...     statistic, _ = mood(sample1, sample2, axis=-1)
...     return statistic

Here, we use the 'percentile' method with the default 95% confidence level.

&gt;&gt;&gt; sample1 = norm.rvs(scale=1, size=100, random_state=rng)
&gt;&gt;&gt; sample2 = norm.rvs(scale=2, size=100, random_state=rng)
&gt;&gt;&gt; data = (sample1, sample2)
&gt;&gt;&gt; res = bootstrap(data, my_statistic, method='basic', random_state=rng)
&gt;&gt;&gt; print(mood(sample1, sample2)[0])  # element 0 is the statistic
-5.521109549096542
&gt;&gt;&gt; print(res.confidence_interval)
ConfidenceInterval(low=-7.255994487314675, high=-4.016202624747605)

The bootstrap estimate of the standard error is also available.

&gt;&gt;&gt; print(res.standard_error)
0.8344963846318795

Paired-sample statistics work, too. For example, consider the Pearson
correlation coefficient.

&gt;&gt;&gt; from scipy.stats import pearsonr
&gt;&gt;&gt; n = 100
&gt;&gt;&gt; x = np.linspace(0, 10, n)
&gt;&gt;&gt; y = x + rng.uniform(size=n)
&gt;&gt;&gt; print(pearsonr(x, y)[0])  # element 0 is the statistic
0.9962357936065914

We wrap `pearsonr` so that it returns only the statistic.

&gt;&gt;&gt; def my_statistic(x, y):
...     return pearsonr(x, y)[0]

We call `bootstrap` using ``paired=True``.
Also, since ``my_statistic`` isn't vectorized to calculate the statistic
along a given axis, we pass in ``vectorized=False``.

&gt;&gt;&gt; res = bootstrap((x, y), my_statistic, vectorized=False, paired=True,
...                 random_state=rng)
&gt;&gt;&gt; print(res.confidence_interval)
ConfidenceInterval(low=0.9950085825848624, high=0.9971212407917498)</pre> <div class="fragment"><div class="line"><span class="lineno">  216</span>              method=<span class="stringliteral">&#39;BCa&#39;</span>, random_state=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  217</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    Compute a two-sided bootstrap confidence interval of a statistic.</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    When `method` is ``&#39;percentile&#39;``, a bootstrap confidence interval is</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    computed according to the following procedure.</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    1. Resample the data: for each sample in `data` and for each of</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">       `n_resamples`, take a random sample of the original sample</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">       (with replacement) of the same size as the original sample.</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    2. Compute the bootstrap distribution of the statistic: for each set of</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">       resamples, compute the test statistic.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    3. Determine the confidence interval: find the interval of the bootstrap</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">       distribution that is</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">       - symmetric about the median and</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">       - contains `confidence_level` of the resampled statistic values.</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    While the ``&#39;percentile&#39;`` method is the most intuitive, it is rarely</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    used in practice. Two more common methods are available, ``&#39;basic&#39;``</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    (&#39;reverse percentile&#39;) and ``&#39;BCa&#39;`` (&#39;bias-corrected and accelerated&#39;);</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    they differ in how step 3 is performed.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    If the samples in `data` are  taken at random from their respective</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    distributions :math:`n` times, the confidence interval returned by</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    `bootstrap` will contain the true value of the statistic for those</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    distributions approximately `confidence_level`:math:`\, \times \, n` times.</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    data : sequence of array-like</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">         Each element of data is a sample from an underlying distribution.</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    statistic : callable</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">        Statistic for which the confidence interval is to be calculated.</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">        `statistic` must be a callable that accepts ``len(data)`` samples</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">        as separate arguments and returns the resulting statistic.</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">        If `vectorized` is set ``True``,</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">        `statistic` must also accept a keyword argument `axis` and be</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">        vectorized to compute the statistic along the provided `axis`.</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    n_resamples : int, default: ``9999``</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">        The number of resamples performed to form the bootstrap distribution</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        of the statistic.</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    batch : int, optional</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">        The number of resamples to process in each vectorized call to</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">        `statistic`. Memory usage is O(`batch`*``n``), where ``n`` is the</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">        sample size. Default is ``None``, in which case ``batch = n_resamples``</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">        (or ``batch = max(n_resamples, n)`` for ``method=&#39;BCa&#39;``).</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    vectorized : bool, default: ``True``</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">        If `vectorized` is set ``False``, `statistic` will not be passed</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">        keyword argument `axis`, and is assumed to calculate the statistic</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">        only for 1D samples.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    paired : bool, default: ``False``</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">        Whether the statistic treats corresponding elements of the samples</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">        in `data` as paired.</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    axis : int, default: ``0``</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">        The axis of the samples in `data` along which the `statistic` is</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        calculated.</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    confidence_level : float, default: ``0.95``</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        The confidence level of the confidence interval.</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    method : {&#39;percentile&#39;, &#39;basic&#39;, &#39;bca&#39;}, default: ``&#39;BCa&#39;``</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        Whether to return the &#39;percentile&#39; bootstrap confidence interval</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        (``&#39;percentile&#39;``), the &#39;reverse&#39; or the bias-corrected and accelerated</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        bootstrap confidence interval (``&#39;BCa&#39;``).</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        Note that only ``&#39;percentile&#39;`` and ``&#39;basic&#39;`` support multi-sample</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        statistics at this time.</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">                    `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        Pseudorandom number generator state used to generate resamples.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        If `random_state` is ``None`` (or `np.random`), the</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">        `numpy.random.RandomState` singleton is used.</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">        If `random_state` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        seeded with `random_state`.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        If `random_state` is already a ``Generator`` or ``RandomState``</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        instance then that instance is used.</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">    res : BootstrapResult</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        An object with attributes:</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        confidence_interval : ConfidenceInterval</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">            The bootstrap confidence interval as an instance of</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">            `collections.namedtuple` with attributes `low` and `high`.</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        standard_error : float or ndarray</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">            The bootstrap standard error, that is, the sample standard</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">            deviation of the bootstrap distribution</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    `~scipy.stats.DegenerateDataWarning`</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        Generated when ``method=&#39;BCa&#39;`` and the bootstrap distribution is</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        degenerate (e.g. all elements are identical).</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    Elements of the confidence interval may be NaN for ``method=&#39;BCa&#39;`` if</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    the bootstrap distribution is degenerate (e.g. all elements are identical).</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    In this case, consider using another `method` or inspecting `data` for</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    indications that other analysis may be more appropriate (e.g. all</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    observations are identical).</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    .. [1] B. Efron and R. J. Tibshirani, An Introduction to the Bootstrap,</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">       Chapman &amp; Hall/CRC, Boca Raton, FL, USA (1993)</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    .. [2] Nathaniel E. Helwig, &quot;Bootstrap Confidence Intervals&quot;,</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">       http://users.stat.umn.edu/~helwig/notes/bootci-Notes.pdf</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    .. [3] Bootstrapping (statistics), Wikipedia,</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">       https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    Suppose we have sampled data from an unknown distribution.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import norm</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    &gt;&gt;&gt; dist = norm(loc=2, scale=4)  # our &quot;unknown&quot; distribution</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    &gt;&gt;&gt; data = dist.rvs(size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    We are interested int the standard deviation of the distribution.</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    &gt;&gt;&gt; std_true = dist.std()      # the true value of the statistic</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    &gt;&gt;&gt; print(std_true)</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    &gt;&gt;&gt; std_sample = np.std(data)  # the sample statistic</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    &gt;&gt;&gt; print(std_sample)</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    3.9460644295563863</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    We can calculate a 90% confidence interval of the statistic using</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    `bootstrap`.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import bootstrap</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    &gt;&gt;&gt; data = (data,)  # samples must be in a sequence</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    &gt;&gt;&gt; res = bootstrap(data, np.std, confidence_level=0.9,</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">    ...                 random_state=rng)</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    &gt;&gt;&gt; print(res.confidence_interval)</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    ConfidenceInterval(low=3.57655333533867, high=4.382043696342881)</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    If we sample from the distribution 1000 times and form a bootstrap</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    confidence interval for each sample, the confidence interval</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    contains the true value of the statistic approximately 900 times.</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    &gt;&gt;&gt; n_trials = 1000</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    &gt;&gt;&gt; ci_contains_true_std = 0</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    &gt;&gt;&gt; for i in range(n_trials):</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    ...    data = (dist.rvs(size=100, random_state=rng),)</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    ...    ci = bootstrap(data, np.std, confidence_level=0.9, n_resamples=1000,</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    ...                   random_state=rng).confidence_interval</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    ...    if ci[0] &lt; std_true &lt; ci[1]:</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    ...        ci_contains_true_std += 1</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    &gt;&gt;&gt; print(ci_contains_true_std)</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    875</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    Rather than writing a loop, we can also determine the confidence intervals</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    for all 1000 samples at once.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    &gt;&gt;&gt; data = (dist.rvs(size=(n_trials, 100), random_state=rng),)</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    &gt;&gt;&gt; res = bootstrap(data, np.std, axis=-1, confidence_level=0.9,</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    ...                 n_resamples=1000, random_state=rng)</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    &gt;&gt;&gt; ci_l, ci_u = res.confidence_interval</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    Here, `ci_l` and `ci_u` contain the confidence interval for each of the</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    ``n_trials = 1000`` samples.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    &gt;&gt;&gt; print(ci_l[995:])</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    [3.77729695 3.75090233 3.45829131 3.34078217 3.48072829]</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    &gt;&gt;&gt; print(ci_u[995:])</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    [4.88316666 4.86924034 4.32032996 4.2822427  4.59360598]</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    And again, approximately 90% contain the true value, ``std_true = 4``.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    &gt;&gt;&gt; print(np.sum((ci_l &lt; std_true) &amp; (std_true &lt; ci_u)))</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    900</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    `bootstrap` can also be used to estimate confidence intervals of</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    multi-sample statistics, including those calculated by hypothesis</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral">    tests. `scipy.stats.mood` perform&#39;s Mood&#39;s test for equal scale parameters,</span></div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    and it returns two outputs: a statistic, and a p-value. To get a</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">    confidence interval for the test statistic, we first wrap</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    `scipy.stats.mood` in a function that accepts two sample arguments,</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    accepts an `axis` keyword argument, and returns only the statistic.</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import mood</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    &gt;&gt;&gt; def my_statistic(sample1, sample2, axis):</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    ...     statistic, _ = mood(sample1, sample2, axis=-1)</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    ...     return statistic</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    Here, we use the &#39;percentile&#39; method with the default 95% confidence level.</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    &gt;&gt;&gt; sample1 = norm.rvs(scale=1, size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    &gt;&gt;&gt; sample2 = norm.rvs(scale=2, size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    &gt;&gt;&gt; data = (sample1, sample2)</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    &gt;&gt;&gt; res = bootstrap(data, my_statistic, method=&#39;basic&#39;, random_state=rng)</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">    &gt;&gt;&gt; print(mood(sample1, sample2)[0])  # element 0 is the statistic</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    -5.521109549096542</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    &gt;&gt;&gt; print(res.confidence_interval)</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    ConfidenceInterval(low=-7.255994487314675, high=-4.016202624747605)</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    The bootstrap estimate of the standard error is also available.</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    &gt;&gt;&gt; print(res.standard_error)</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    0.8344963846318795</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    Paired-sample statistics work, too. For example, consider the Pearson</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    correlation coefficient.</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import pearsonr</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    &gt;&gt;&gt; n = 100</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 10, n)</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    &gt;&gt;&gt; y = x + rng.uniform(size=n)</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    &gt;&gt;&gt; print(pearsonr(x, y)[0])  # element 0 is the statistic</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    0.9962357936065914</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    We wrap `pearsonr` so that it returns only the statistic.</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    &gt;&gt;&gt; def my_statistic(x, y):</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    ...     return pearsonr(x, y)[0]</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    We call `bootstrap` using ``paired=True``.</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    Also, since ``my_statistic`` isn&#39;t vectorized to calculate the statistic</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    along a given axis, we pass in ``vectorized=False``.</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    &gt;&gt;&gt; res = bootstrap((x, y), my_statistic, vectorized=False, paired=True,</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    ...                 random_state=rng)</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    &gt;&gt;&gt; print(res.confidence_interval)</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    ConfidenceInterval(low=0.9950085825848624, high=0.9971212407917498)</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  449</span>    <span class="comment"># Input validation</span></div>
<div class="line"><span class="lineno">  450</span>    args = _bootstrap_iv(data, statistic, vectorized, paired, axis,</div>
<div class="line"><span class="lineno">  451</span>                         confidence_level, n_resamples, batch, method,</div>
<div class="line"><span class="lineno">  452</span>                         random_state)</div>
<div class="line"><span class="lineno">  453</span>    data, statistic, vectorized, paired, axis = args[:5]</div>
<div class="line"><span class="lineno">  454</span>    confidence_level, n_resamples, batch, method, random_state = args[5:]</div>
<div class="line"><span class="lineno">  455</span> </div>
<div class="line"><span class="lineno">  456</span>    theta_hat_b = []</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>    batch_nominal = batch <span class="keywordflow">or</span> n_resamples</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(0, n_resamples, batch_nominal):</div>
<div class="line"><span class="lineno">  461</span>        batch_actual = min(batch_nominal, n_resamples-k)</div>
<div class="line"><span class="lineno">  462</span>        <span class="comment"># Generate resamples</span></div>
<div class="line"><span class="lineno">  463</span>        resampled_data = []</div>
<div class="line"><span class="lineno">  464</span>        <span class="keywordflow">for</span> sample <span class="keywordflow">in</span> data:</div>
<div class="line"><span class="lineno">  465</span>            resample = _bootstrap_resample(sample, n_resamples=batch_actual,</div>
<div class="line"><span class="lineno">  466</span>                                           random_state=random_state)</div>
<div class="line"><span class="lineno">  467</span>            resampled_data.append(resample)</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>        <span class="comment"># Compute bootstrap distribution of statistic</span></div>
<div class="line"><span class="lineno">  470</span>        theta_hat_b.append(statistic(*resampled_data, axis=-1))</div>
<div class="line"><span class="lineno">  471</span>    theta_hat_b = np.concatenate(theta_hat_b, axis=-1)</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>    <span class="comment"># Calculate percentile interval</span></div>
<div class="line"><span class="lineno">  474</span>    alpha = (1 - confidence_level)/2</div>
<div class="line"><span class="lineno">  475</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;bca&#39;</span>:</div>
<div class="line"><span class="lineno">  476</span>        interval = _bca_interval(data, statistic, axis=-1, alpha=alpha,</div>
<div class="line"><span class="lineno">  477</span>                                 theta_hat_b=theta_hat_b, batch=batch)</div>
<div class="line"><span class="lineno">  478</span>        percentile_fun = _percentile_along_axis</div>
<div class="line"><span class="lineno">  479</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  480</span>        interval = alpha, 1-alpha</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span>        <span class="keyword">def </span>percentile_fun(a, q):</div>
<div class="line"><span class="lineno">  483</span>            <span class="keywordflow">return</span> np.percentile(a=a, q=q, axis=-1)</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span>    <span class="comment"># Calculate confidence interval of statistic</span></div>
<div class="line"><span class="lineno">  486</span>    ci_l = percentile_fun(theta_hat_b, interval[0]*100)</div>
<div class="line"><span class="lineno">  487</span>    ci_u = percentile_fun(theta_hat_b, interval[1]*100)</div>
<div class="line"><span class="lineno">  488</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;basic&#39;</span>:  <span class="comment"># see [3]</span></div>
<div class="line"><span class="lineno">  489</span>        theta_hat = statistic(*data, axis=-1)</div>
<div class="line"><span class="lineno">  490</span>        ci_l, ci_u = 2*theta_hat - ci_u, 2*theta_hat - ci_l</div>
<div class="line"><span class="lineno">  491</span> </div>
<div class="line"><span class="lineno">  492</span>    <span class="keywordflow">return</span> BootstrapResult(confidence_interval=ConfidenceInterval(ci_l, ci_u),</div>
<div class="line"><span class="lineno">  493</span>                           standard_error=np.std(theta_hat_b, ddof=1, axis=-1))</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a83269fcf47696542df1e5921be60b5ab" name="a83269fcf47696542df1e5921be60b5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83269fcf47696542df1e5921be60b5ab">&#9670;&#160;</a></span>monte_carlo_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling.monte_carlo_test </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>vectorized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_resamples</em> = <code>9999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Monte Carlo test that a sample is drawn from a given distribution.

The null hypothesis is that the provided `sample` was drawn at random from
the distribution for which `rvs` generates random variates. The value of
the `statistic` for the given sample is compared against a Monte Carlo null
distribution: the value of the statistic for each of `n_resamples`
samples generated by `rvs`. This gives the p-value, the probability of
observing such an extreme value of the test statistic under the null
hypothesis.

Parameters
----------
sample : array-like
    An array of observations.
rvs : callable
    Generates random variates from the distribution against which `sample`
    will be tested. `rvs` must be a callable that accepts keyword argument
    ``size`` (e.g. ``rvs(size=(m, n))``) and returns an N-d array sample
    of that shape.
statistic : callable
    Statistic for which the p-value of the hypothesis test is to be
    calculated. `statistic` must be a callable that accepts a sample
    (e.g. ``statistic(sample)``) and returns the resulting statistic.
    If `vectorized` is set ``True``, `statistic` must also accept a keyword
    argument `axis` and be vectorized to compute the statistic along the
    provided `axis` of the sample array.
vectorized : bool, default: ``False``
    By default, `statistic` is assumed to calculate the statistic only for
    a 1D arrays `sample`. If `vectorized` is set ``True``, `statistic` must
    also accept a keyword argument `axis` and be vectorized to compute the
    statistic along the provided `axis` of an ND sample array. Use of a
    vectorized statistic can reduce computation time.
n_resamples : int, default: 9999
    Number of random permutations used to approximate the Monte Carlo null
    distribution.
batch : int, optional
    The number of permutations to process in each call to `statistic`.
    Memory usage is O(`batch`*``sample.size[axis]``). Default is
    ``None``, in which case `batch` equals `n_resamples`.
alternative : {'two-sided', 'less', 'greater'}
    The alternative hypothesis for which the p-value is calculated.
    For each alternative, the p-value is defined as follows.

    - ``'greater'`` : the percentage of the null distribution that is
      greater than or equal to the observed value of the test statistic.
    - ``'less'`` : the percentage of the null distribution that is
      less than or equal to the observed value of the test statistic.
    - ``'two-sided'`` : twice the smaller of the p-values above.

axis : int, default: 0
    The axis of `sample` over which to calculate the statistic.

Returns
-------
statistic : float or ndarray
    The observed test statistic of the sample.
pvalue : float or ndarray
    The p-value for the given alternative.
null_distribution : ndarray
    The values of the test statistic generated under the null hypothesis.

References
----------

.. [1] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
   Zero: Calculating Exact P-values When Permutations Are Randomly Drawn."
   Statistical Applications in Genetics and Molecular Biology 9.1 (2010).

Examples
--------

Suppose we wish to test whether a small sample has been drawn from a normal
distribution. We decide that we will use the skew of the sample as a
test statistic, and we will consider a p-value of 0.05 to be statistically
significant.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; def statistic(x, axis):
...     return stats.skew(x, axis)

After collecting our data, we calculate the observed value of the test
statistic.

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.skewnorm.rvs(a=1, size=50, random_state=rng)
&gt;&gt;&gt; statistic(x, axis=0)
0.12457412450240658

To determine the probability of observing such an extreme value of the
skewness by chance if the sample were drawn from the normal distribution,
we can perform a Monte Carlo hypothesis test. The test will draw many
samples at random from their normal distribution, calculate the skewness
of each sample, and compare our original skewness against this
distribution to determine an approximate p-value.

&gt;&gt;&gt; from scipy.stats import monte_carlo_test
&gt;&gt;&gt; # because our statistic is vectorized, we pass `vectorized=True`
&gt;&gt;&gt; rvs = lambda size: stats.norm.rvs(size=size, random_state=rng)
&gt;&gt;&gt; res = monte_carlo_test(x, rvs, statistic, vectorized=True)
&gt;&gt;&gt; print(res.statistic)
0.12457412450240658
&gt;&gt;&gt; print(res.pvalue)
0.7012

The probability of obtaining a test statistic less than or equal to the
observed value under the null hypothesis is ~70%. This is greater than
our chosen threshold of 5%, so we cannot consider this to to be significant
evidence against the null hypothesis.

Note that this p-value essentially matches that of
`scipy.stats.skewtest`, which relies on an asymptotic distribution of a
test statistic based on the sample skewness.

&gt;&gt;&gt; stats.skewtest(x).pvalue
0.6892046027110614

This asymptotic approximation is not valid for small sample sizes, but
`monte_carlo_test` can be used with samples of any size.

&gt;&gt;&gt; x = stats.skewnorm.rvs(a=1, size=7, random_state=rng)
&gt;&gt;&gt; # stats.skewtest(x) would produce an error due to small sample
&gt;&gt;&gt; res = monte_carlo_test(x, rvs, statistic, vectorized=True)

The Monte Carlo distribution of the test statistic is provided for
further investigation.

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; ax.hist(res.null_distribution, bins=50)
&gt;&gt;&gt; ax.set_title("Monte Carlo distribution of test statistic")
&gt;&gt;&gt; ax.set_xlabel("Value of Statistic")
&gt;&gt;&gt; ax.set_ylabel("Frequency")
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  547</span>                     axis=0):</div>
<div class="line"><span class="lineno">  548</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    Monte Carlo test that a sample is drawn from a given distribution.</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    The null hypothesis is that the provided `sample` was drawn at random from</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    the distribution for which `rvs` generates random variates. The value of</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    the `statistic` for the given sample is compared against a Monte Carlo null</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    distribution: the value of the statistic for each of `n_resamples`</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    samples generated by `rvs`. This gives the p-value, the probability of</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    observing such an extreme value of the test statistic under the null</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    hypothesis.</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    sample : array-like</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">        An array of observations.</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    rvs : callable</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">        Generates random variates from the distribution against which `sample`</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">        will be tested. `rvs` must be a callable that accepts keyword argument</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">        ``size`` (e.g. ``rvs(size=(m, n))``) and returns an N-d array sample</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">        of that shape.</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    statistic : callable</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        Statistic for which the p-value of the hypothesis test is to be</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        calculated. `statistic` must be a callable that accepts a sample</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        (e.g. ``statistic(sample)``) and returns the resulting statistic.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">        If `vectorized` is set ``True``, `statistic` must also accept a keyword</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        argument `axis` and be vectorized to compute the statistic along the</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">        provided `axis` of the sample array.</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    vectorized : bool, default: ``False``</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        By default, `statistic` is assumed to calculate the statistic only for</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        a 1D arrays `sample`. If `vectorized` is set ``True``, `statistic` must</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        also accept a keyword argument `axis` and be vectorized to compute the</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        statistic along the provided `axis` of an ND sample array. Use of a</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">        vectorized statistic can reduce computation time.</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    n_resamples : int, default: 9999</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">        Number of random permutations used to approximate the Monte Carlo null</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        distribution.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    batch : int, optional</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        The number of permutations to process in each call to `statistic`.</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        Memory usage is O(`batch`*``sample.size[axis]``). Default is</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        ``None``, in which case `batch` equals `n_resamples`.</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        The alternative hypothesis for which the p-value is calculated.</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">        For each alternative, the p-value is defined as follows.</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        - ``&#39;greater&#39;`` : the percentage of the null distribution that is</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">          greater than or equal to the observed value of the test statistic.</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">        - ``&#39;less&#39;`` : the percentage of the null distribution that is</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">          less than or equal to the observed value of the test statistic.</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">        - ``&#39;two-sided&#39;`` : twice the smaller of the p-values above.</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    axis : int, default: 0</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        The axis of `sample` over which to calculate the statistic.</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    statistic : float or ndarray</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        The observed test statistic of the sample.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">    pvalue : float or ndarray</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        The p-value for the given alternative.</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    null_distribution : ndarray</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">        The values of the test statistic generated under the null hypothesis.</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    .. [1] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">       Zero: Calculating Exact P-values When Permutations Are Randomly Drawn.&quot;</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">       Statistical Applications in Genetics and Molecular Biology 9.1 (2010).</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    Suppose we wish to test whether a small sample has been drawn from a normal</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    distribution. We decide that we will use the skew of the sample as a</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    test statistic, and we will consider a p-value of 0.05 to be statistically</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    significant.</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno">  626</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import stats</span></div>
<div class="line"><span class="lineno">  627</span><span class="stringliteral">    &gt;&gt;&gt; def statistic(x, axis):</span></div>
<div class="line"><span class="lineno">  628</span><span class="stringliteral">    ...     return stats.skew(x, axis)</span></div>
<div class="line"><span class="lineno">  629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    After collecting our data, we calculate the observed value of the test</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral">    statistic.</span></div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.skewnorm.rvs(a=1, size=50, random_state=rng)</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral">    &gt;&gt;&gt; statistic(x, axis=0)</span></div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">    0.12457412450240658</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    To determine the probability of observing such an extreme value of the</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    skewness by chance if the sample were drawn from the normal distribution,</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral">    we can perform a Monte Carlo hypothesis test. The test will draw many</span></div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    samples at random from their normal distribution, calculate the skewness</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    of each sample, and compare our original skewness against this</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    distribution to determine an approximate p-value.</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import monte_carlo_test</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    &gt;&gt;&gt; # because our statistic is vectorized, we pass `vectorized=True`</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">    &gt;&gt;&gt; rvs = lambda size: stats.norm.rvs(size=size, random_state=rng)</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    &gt;&gt;&gt; res = monte_carlo_test(x, rvs, statistic, vectorized=True)</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    &gt;&gt;&gt; print(res.statistic)</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    0.12457412450240658</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    &gt;&gt;&gt; print(res.pvalue)</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    0.7012</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">    The probability of obtaining a test statistic less than or equal to the</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    observed value under the null hypothesis is ~70%. This is greater than</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    our chosen threshold of 5%, so we cannot consider this to to be significant</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    evidence against the null hypothesis.</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">    Note that this p-value essentially matches that of</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">    `scipy.stats.skewtest`, which relies on an asymptotic distribution of a</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    test statistic based on the sample skewness.</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    &gt;&gt;&gt; stats.skewtest(x).pvalue</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">    0.6892046027110614</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    This asymptotic approximation is not valid for small sample sizes, but</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">    `monte_carlo_test` can be used with samples of any size.</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    &gt;&gt;&gt; x = stats.skewnorm.rvs(a=1, size=7, random_state=rng)</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">    &gt;&gt;&gt; # stats.skewtest(x) would produce an error due to small sample</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">    &gt;&gt;&gt; res = monte_carlo_test(x, rvs, statistic, vectorized=True)</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    The Monte Carlo distribution of the test statistic is provided for</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">    further investigation.</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">    &gt;&gt;&gt; fig, ax = plt.subplots()</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral">    &gt;&gt;&gt; ax.hist(res.null_distribution, bins=50)</span></div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_title(&quot;Monte Carlo distribution of test statistic&quot;)</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_xlabel(&quot;Value of Statistic&quot;)</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    &gt;&gt;&gt; ax.set_ylabel(&quot;Frequency&quot;)</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  685</span>    args = _monte_carlo_test_iv(sample, rvs, statistic, vectorized,</div>
<div class="line"><span class="lineno">  686</span>                                n_resamples, batch, alternative, axis)</div>
<div class="line"><span class="lineno">  687</span>    (sample, rvs, statistic, vectorized,</div>
<div class="line"><span class="lineno">  688</span>     n_resamples, batch, alternative, axis) = args</div>
<div class="line"><span class="lineno">  689</span> </div>
<div class="line"><span class="lineno">  690</span>    <span class="comment"># Some statistics return plain floats; ensure they&#39;re at least np.float64</span></div>
<div class="line"><span class="lineno">  691</span>    observed = np.asarray(statistic(sample, axis=-1))[()]</div>
<div class="line"><span class="lineno">  692</span> </div>
<div class="line"><span class="lineno">  693</span>    n_observations = sample.shape[-1]</div>
<div class="line"><span class="lineno">  694</span>    batch_nominal = batch <span class="keywordflow">or</span> n_resamples</div>
<div class="line"><span class="lineno">  695</span>    null_distribution = []</div>
<div class="line"><span class="lineno">  696</span>    <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(0, n_resamples, batch_nominal):</div>
<div class="line"><span class="lineno">  697</span>        batch_actual = min(batch_nominal, n_resamples-k)</div>
<div class="line"><span class="lineno">  698</span>        resamples = rvs(size=(batch_actual, n_observations))</div>
<div class="line"><span class="lineno">  699</span>        null_distribution.append(statistic(resamples, axis=-1))</div>
<div class="line"><span class="lineno">  700</span>    null_distribution = np.concatenate(null_distribution)</div>
<div class="line"><span class="lineno">  701</span>    null_distribution = null_distribution.reshape([-1] + [1]*observed.ndim)</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <span class="keyword">def </span>less(null_distribution, observed):</div>
<div class="line"><span class="lineno">  704</span>        cmps = null_distribution &lt;= observed</div>
<div class="line"><span class="lineno">  705</span>        pvalues = (cmps.sum(axis=0) + 1) / (n_resamples + 1)  <span class="comment"># see [1]</span></div>
<div class="line"><span class="lineno">  706</span>        <span class="keywordflow">return</span> pvalues</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span>    <span class="keyword">def </span>greater(null_distribution, observed):</div>
<div class="line"><span class="lineno">  709</span>        cmps = null_distribution &gt;= observed</div>
<div class="line"><span class="lineno">  710</span>        pvalues = (cmps.sum(axis=0) + 1) / (n_resamples + 1)  <span class="comment"># see [1]</span></div>
<div class="line"><span class="lineno">  711</span>        <span class="keywordflow">return</span> pvalues</div>
<div class="line"><span class="lineno">  712</span> </div>
<div class="line"><span class="lineno">  713</span>    <span class="keyword">def </span>two_sided(null_distribution, observed):</div>
<div class="line"><span class="lineno">  714</span>        pvalues_less = less(null_distribution, observed)</div>
<div class="line"><span class="lineno">  715</span>        pvalues_greater = greater(null_distribution, observed)</div>
<div class="line"><span class="lineno">  716</span>        pvalues = np.minimum(pvalues_less, pvalues_greater) * 2</div>
<div class="line"><span class="lineno">  717</span>        <span class="keywordflow">return</span> pvalues</div>
<div class="line"><span class="lineno">  718</span> </div>
<div class="line"><span class="lineno">  719</span>    compare = {<span class="stringliteral">&quot;less&quot;</span>: less,</div>
<div class="line"><span class="lineno">  720</span>               <span class="stringliteral">&quot;greater&quot;</span>: greater,</div>
<div class="line"><span class="lineno">  721</span>               <span class="stringliteral">&quot;two-sided&quot;</span>: two_sided}</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span>    pvalues = compare[alternative](null_distribution, observed)</div>
<div class="line"><span class="lineno">  724</span>    pvalues = np.clip(pvalues, 0, 1)</div>
<div class="line"><span class="lineno">  725</span> </div>
<div class="line"><span class="lineno">  726</span>    <span class="keywordflow">return</span> MonteCarloTestResult(observed, pvalues, null_distribution)</div>
<div class="line"><span class="lineno">  727</span> </div>
<div class="line"><span class="lineno">  728</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a154544187d27a7967a0696aaa88abd76" name="a154544187d27a7967a0696aaa88abd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154544187d27a7967a0696aaa88abd76">&#9670;&#160;</a></span>permutation_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling.permutation_test </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>permutation_type</em> = <code>'independent'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vectorized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_resamples</em> = <code>9999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>batch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alternative</em> = <code>&quot;two-sided&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs a permutation test of a given statistic on provided data.

For independent sample statistics, the null hypothesis is that the data are
randomly sampled from the same distribution.
For paired sample statistics, two null hypothesis can be tested:
that the data are paired at random or that the data are assigned to samples
at random.

Parameters
----------
data : iterable of array-like
Contains the samples, each of which is an array of observations.
Dimensions of sample arrays must be compatible for broadcasting except
along `axis`.
statistic : callable
Statistic for which the p-value of the hypothesis test is to be
calculated. `statistic` must be a callable that accepts samples
as separate arguments (e.g. ``statistic(*data)``) and returns the
resulting statistic.
If `vectorized` is set ``True``, `statistic` must also accept a keyword
argument `axis` and be vectorized to compute the statistic along the
provided `axis` of the sample arrays.
permutation_type : {'independent', 'samples', 'pairings'}, optional
The type of permutations to be performed, in accordance with the
null hypothesis. The first two permutation types are for paired sample
statistics, in which all samples contain the same number of
observations and observations with corresponding indices along `axis`
are considered to be paired; the third is for independent sample
statistics.

- ``'samples'`` : observations are assigned to different samples
but remain paired with the same observations from other samples.
This permutation type is appropriate for paired sample hypothesis
tests such as the Wilcoxon signed-rank test and the paired t-test.
- ``'pairings'`` : observations are paired with different observations,
but they remain within the same sample. This permutation type is
appropriate for association/correlation tests with statistics such
as Spearman's :math:`\rho`, Kendall's :math:`\tau`, and Pearson's
:math:`r`.
- ``'independent'`` (default) : observations are assigned to different
samples. Samples may contain different numbers of observations. This
permutation type is appropriate for independent sample hypothesis
tests such as the Mann-Whitney :math:`U` test and the independent
sample t-test.

Please see the Notes section below for more detailed descriptions
of the permutation types.

vectorized : bool, default: ``False``
By default, `statistic` is assumed to calculate the statistic only for
1D arrays contained in `data`. If `vectorized` is set ``True``,
`statistic` must also accept a keyword argument `axis` and be
vectorized to compute the statistic along the provided `axis` of the ND
arrays in `data`. Use of a vectorized statistic can reduce computation
time.
n_resamples : int or np.inf, default: 9999
Number of random permutations (resamples) used to approximate the null
distribution. If greater than or equal to the number of distinct
permutations, the exact null distribution will be computed.
Note that the number of distinct permutations grows very rapidly with
the sizes of samples, so exact tests are feasible only for very small
data sets.
batch : int, optional
The number of permutations to process in each call to `statistic`.
Memory usage is O(`batch`*``n``), where ``n`` is the total size
of all samples, regardless of the value of `vectorized`. Default is
``None``, in which case ``batch`` is the number of permutations.
alternative : {'two-sided', 'less', 'greater'}, optional
The alternative hypothesis for which the p-value is calculated.
For each alternative, the p-value is defined for exact tests as
follows.

- ``'greater'`` : the percentage of the null distribution that is
greater than or equal to the observed value of the test statistic.
- ``'less'`` : the percentage of the null distribution that is
less than or equal to the observed value of the test statistic.
- ``'two-sided'`` (default) : twice the smaller of the p-values above.

Note that p-values for randomized tests are calculated according to the
conservative (over-estimated) approximation suggested in [2]_ and [3]_
rather than the unbiased estimator suggested in [4]_. That is, when
calculating the proportion of the randomized null distribution that is
as extreme as the observed value of the test statistic, the values in
the numerator and denominator are both increased by one. An
interpretation of this adjustment is that the observed value of the
test statistic is always included as an element of the randomized
null distribution.
The convention used for two-sided p-values is not universal;
the observed test statistic and null distribution are returned in
case a different definition is preferred.

axis : int, default: 0
The axis of the (broadcasted) samples over which to calculate the
statistic. If samples have a different number of dimensions,
singleton dimensions are prepended to samples with fewer dimensions
before `axis` is considered.
random_state : {None, int, `numpy.random.Generator`,
`numpy.random.RandomState`}, optional

Pseudorandom number generator state used to generate permutations.

If `random_state` is ``None`` (default), the
`numpy.random.RandomState` singleton is used.
If `random_state` is an int, a new ``RandomState`` instance is used,
seeded with `random_state`.
If `random_state` is already a ``Generator`` or ``RandomState``
instance then that instance is used.

Returns
-------
statistic : float or ndarray
The observed test statistic of the data.
pvalue : float or ndarray
The p-value for the given alternative.
null_distribution : ndarray
The values of the test statistic generated under the null hypothesis.

Notes
-----

The three types of permutation tests supported by this function are
described below.

**Unpaired statistics** (``permutation_type='independent'``):

The null hypothesis associated with this permutation type is that all
observations are sampled from the same underlying distribution and that
they have been assigned to one of the samples at random.

Suppose ``data`` contains two samples; e.g. ``a, b = data``.
When ``1 &lt; n_resamples &lt; binom(n, k)``, where

* ``k`` is the number of observations in ``a``,
* ``n`` is the total number of observations in ``a`` and ``b``, and
* ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``),

the data are pooled (concatenated), randomly assigned to either the first
or second sample, and the statistic is calculated. This process is
performed repeatedly, `permutation` times, generating a distribution of the
statistic under the null hypothesis. The statistic of the original
data is compared to this distribution to determine the p-value.

When ``n_resamples &gt;= binom(n, k)``, an exact test is performed: the data
are *partitioned* between the samples in each distinct way exactly once,
and the exact null distribution is formed.
Note that for a given partitioning of the data between the samples,
only one ordering/permutation of the data *within* each sample is
considered. For statistics that do not depend on the order of the data
within samples, this dramatically reduces computational cost without
affecting the shape of the null distribution (because the frequency/count
of each value is affected by the same factor).

For ``a = [a1, a2, a3, a4]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``x = [b3, a1, a2, b2]`` and ``y = [a4, b1, a3]``.
Because only one ordering/permutation of the data *within* each sample
is considered in an exact test, a resampling like ``x = [b3, a1, b2, a2]``
and ``y = [a4, a3, b1]`` would *not* be considered distinct from the
example above.

``permutation_type='independent'`` does not support one-sample statistics,
but it can be applied to statistics with more than two samples. In this
case, if ``n`` is an array of the number of observations within each
sample, the number of distinct partitions is::

np.product([binom(sum(n[i:]), sum(n[i+1:])) for i in range(len(n)-1)])

**Paired statistics, permute pairings** (``permutation_type='pairings'``):

The null hypothesis associated with this permutation type is that
observations within each sample are drawn from the same underlying
distribution and that pairings with elements of other samples are
assigned at random.

Suppose ``data`` contains only one sample; e.g. ``a, = data``, and we
wish to consider all possible pairings of elements of ``a`` with elements
of a second sample, ``b``. Let ``n`` be the number of observations in
``a``, which must also equal the number of observations in ``b``.

When ``1 &lt; n_resamples &lt; factorial(n)``, the elements of ``a`` are
randomly permuted. The user-supplied statistic accepts one data argument,
say ``a_perm``, and calculates the statistic considering ``a_perm`` and
``b``. This process is performed repeatedly, `permutation` times,
generating a distribution of the statistic under the null hypothesis.
The statistic of the original data is compared to this distribution to
determine the p-value.

When ``n_resamples &gt;= factorial(n)``, an exact test is performed:
``a`` is permuted in each distinct way exactly once. Therefore, the
`statistic` is computed for each unique pairing of samples between ``a``
and ``b`` exactly once.

For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``a_perm = [a3, a1, a2]`` while ``b`` is left
in its original order.

``permutation_type='pairings'`` supports ``data`` containing any number
of samples, each of which must contain the same number of observations.
All samples provided in ``data`` are permuted *independently*. Therefore,
if ``m`` is the number of samples and ``n`` is the number of observations
within each sample, then the number of permutations in an exact test is::

factorial(n)**m

Note that if a two-sample statistic, for example, does not inherently
depend on the order in which observations are provided - only on the
*pairings* of observations - then only one of the two samples should be
provided in ``data``. This dramatically reduces computational cost without
affecting the shape of the null distribution (because the frequency/count
of each value is affected by the same factor).

**Paired statistics, permute samples** (``permutation_type='samples'``):

The null hypothesis associated with this permutation type is that
observations within each pair are drawn from the same underlying
distribution and that the sample to which they are assigned is random.

Suppose ``data`` contains two samples; e.g. ``a, b = data``.
Let ``n`` be the number of observations in ``a``, which must also equal
the number of observations in ``b``.

When ``1 &lt; n_resamples &lt; 2**n``, the elements of ``a`` are ``b`` are
randomly swapped between samples (maintaining their pairings) and the
statistic is calculated. This process is performed repeatedly,
`permutation` times,  generating a distribution of the statistic under the
null hypothesis. The statistic of the original data is compared to this
distribution to determine the p-value.

When ``n_resamples &gt;= 2**n``, an exact test is performed: the observations
are assigned to the two samples in each distinct way (while maintaining
pairings) exactly once.

For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``x = [b1, a2, b3]`` and ``y = [a1, b2, a3]``.

``permutation_type='samples'`` supports ``data`` containing any number
of samples, each of which must contain the same number of observations.
If ``data`` contains more than one sample, paired observations within
``data`` are exchanged between samples *independently*. Therefore, if ``m``
is the number of samples and ``n`` is the number of observations within
each sample, then the number of permutations in an exact test is::

factorial(m)**n

Several paired-sample statistical tests, such as the Wilcoxon signed rank
test and paired-sample t-test, can be performed considering only the
*difference* between two paired elements. Accordingly, if ``data`` contains
only one sample, then the null distribution is formed by independently
changing the *sign* of each observation.

.. warning::
The p-value is calculated by counting the elements of the null
distribution that are as extreme or more extreme than the observed
value of the statistic. Due to the use of finite precision arithmetic,
some statistic functions return numerically distinct values when the
theoretical values would be exactly equal. In some cases, this could
lead to a large error in the calculated p-value. `permutation_test`
guards against this by considering elements in the null distribution
that are "close" (within a factor of ``1+1e-14``) to the observed
value of the test statistic as equal to the observed value of the
test statistic. However, the user is advised to inspect the null
distribution to assess whether this method of comparison is
appropriate, and if not, calculate the p-value manually. See example
below.

References
----------

.. [1] R. A. Fisher. The Design of Experiments, 6th Ed (1951).
.. [2] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
Zero: Calculating Exact P-values When Permutations Are Randomly Drawn."
Statistical Applications in Genetics and Molecular Biology 9.1 (2010).
.. [3] M. D. Ernst. "Permutation Methods: A Basis for Exact Inference".
Statistical Science (2004).
.. [4] B. Efron and R. J. Tibshirani. An Introduction to the Bootstrap
(1993).

Examples
--------

Suppose we wish to test whether two samples are drawn from the same
distribution. Assume that the underlying distributions are unknown to us,
and that before observing the data, we hypothesized that the mean of the
first sample would be less than that of the second sample. We decide that
we will use the difference between the sample means as a test statistic,
and we will consider a p-value of 0.05 to be statistically significant.

For efficiency, we write the function defining the test statistic in a
vectorized fashion: the samples ``x`` and ``y`` can be ND arrays, and the
statistic will be calculated for each axis-slice along `axis`.

&gt;&gt;&gt; def statistic(x, y, axis):
...     return np.mean(x, axis=axis) - np.mean(y, axis=axis)

After collecting our data, we calculate the observed value of the test
statistic.

&gt;&gt;&gt; from scipy.stats import norm
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = norm.rvs(size=5, random_state=rng)
&gt;&gt;&gt; y = norm.rvs(size=6, loc = 3, random_state=rng)
&gt;&gt;&gt; statistic(x, y, 0)
-3.5411688580987266

Indeed, the test statistic is negative, suggesting that the true mean of
the distribution underlying ``x`` is less than that of the distribution
underlying ``y``. To determine the probability of this occuring by chance
if the two samples were drawn from the same distribution, we perform
a permutation test.

&gt;&gt;&gt; from scipy.stats import permutation_test
&gt;&gt;&gt; # because our statistic is vectorized, we pass `vectorized=True`
&gt;&gt;&gt; # `n_resamples=np.inf` indicates that an exact test is to be performed
&gt;&gt;&gt; res = permutation_test((x, y), statistic, vectorized=True,
...                        n_resamples=np.inf, alternative='less')
&gt;&gt;&gt; print(res.statistic)
-3.5411688580987266
&gt;&gt;&gt; print(res.pvalue)
0.004329004329004329

The probability of obtaining a test statistic less than or equal to the
observed value under the null hypothesis is 0.4329%. This is less than our
chosen threshold of 5%, so we consider this to to be significant evidence
against the null hypothesis in favor of the alternative.

Because the size of the samples above was small, `permutation_test` could
perform an exact test. For larger samples, we resort to a randomized
permutation test.

&gt;&gt;&gt; x = norm.rvs(size=100, random_state=rng)
&gt;&gt;&gt; y = norm.rvs(size=120, loc=0.3, random_state=rng)
&gt;&gt;&gt; res = permutation_test((x, y), statistic, n_resamples=100000,
...                        vectorized=True, alternative='less',
...                        random_state=rng)
&gt;&gt;&gt; print(res.statistic)
-0.5230459671240913
&gt;&gt;&gt; print(res.pvalue)
0.00016999830001699983

The approximate probability of obtaining a test statistic less than or
equal to the observed value under the null hypothesis is 0.0225%. This is
again less than our chosen threshold of 5%, so again we have significant
evidence to reject the null hypothesis in favor of the alternative.

For large samples and number of permutations, the result is comparable to
that of the corresponding asymptotic test, the independent sample t-test.

&gt;&gt;&gt; from scipy.stats import ttest_ind
&gt;&gt;&gt; res_asymptotic = ttest_ind(x, y, alternative='less')
&gt;&gt;&gt; print(res_asymptotic.pvalue)
0.00012688101537979522

The permutation distribution of the test statistic is provided for
further investigation.

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.hist(res.null_distribution, bins=50)
&gt;&gt;&gt; plt.title("Permutation distribution of test statistic")
&gt;&gt;&gt; plt.xlabel("Value of Statistic")
&gt;&gt;&gt; plt.ylabel("Frequency")
&gt;&gt;&gt; plt.show()

Inspection of the null distribution is essential if the statistic suffers
from inaccuracy due to limited machine precision. Consider the following
case:

&gt;&gt;&gt; from scipy.stats import pearsonr
&gt;&gt;&gt; x = [1, 2, 4, 3]
&gt;&gt;&gt; y = [2, 4, 6, 8]
&gt;&gt;&gt; def statistic(x, y):
...     return pearsonr(x, y).statistic
&gt;&gt;&gt; res = permutation_test((x, y), statistic, vectorized=False,
...                        permutation_type='pairings',
...                        alternative='greater')
&gt;&gt;&gt; r, pvalue, null = res.statistic, res.pvalue, res.null_distribution

In this case, some elements of the null distribution differ from the
observed value of the correlation coefficient ``r`` due to numerical noise.
We manually inspect the elements of the null distribution that are nearly
the same as the observed value of the test statistic.

&gt;&gt;&gt; r
0.8
&gt;&gt;&gt; unique = np.unique(null)
&gt;&gt;&gt; unique
array([-1. , -0.8, -0.8, -0.6, -0.4, -0.2, -0.2,  0. ,  0.2,  0.2,  0.4,
0.6,  0.8,  0.8,  1. ]) # may vary
&gt;&gt;&gt; unique[np.isclose(r, unique)].tolist()
[0.7999999999999999, 0.8]

If `permutation_test` were to perform the comparison naively, the
elements of the null distribution with value ``0.7999999999999999`` would
not be considered as extreme or more extreme as the observed value of the
statistic, so the calculated p-value would be too small.

&gt;&gt;&gt; incorrect_pvalue = np.count_nonzero(null &gt;= r) / len(null)
&gt;&gt;&gt; incorrect_pvalue
0.1111111111111111  # may vary

Instead, `permutation_test` treats elements of the null distribution that
are within ``max(1e-14, abs(r)*1e-14)`` of the observed value of the
statistic ``r`` to be equal to ``r``.

&gt;&gt;&gt; correct_pvalue = np.count_nonzero(null &gt;= r - 1e-14) / len(null)
&gt;&gt;&gt; correct_pvalue
0.16666666666666666
&gt;&gt;&gt; res.pvalue == correct_pvalue
True

This method of comparison is expected to be accurate in most practical
situations, but the user is advised to assess this by inspecting the
elements of the null distribution that are close to the observed value
of the statistic. Also, consider the use of statistics that can be
calculated using exact arithmetic (e.g. integer statistics).</pre> <div class="fragment"><div class="line"><span class="lineno">  979</span>                     alternative=<span class="stringliteral">&quot;two-sided&quot;</span>, axis=0, random_state=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  980</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    Performs a permutation test of a given statistic on provided data.</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">    For independent sample statistics, the null hypothesis is that the data are</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    randomly sampled from the same distribution.</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">    For paired sample statistics, two null hypothesis can be tested:</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">    that the data are paired at random or that the data are assigned to samples</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral">    at random.</span></div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">    data : iterable of array-like</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">        Contains the samples, each of which is an array of observations.</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">        Dimensions of sample arrays must be compatible for broadcasting except</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">        along `axis`.</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral">    statistic : callable</span></div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">        Statistic for which the p-value of the hypothesis test is to be</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">        calculated. `statistic` must be a callable that accepts samples</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral">        as separate arguments (e.g. ``statistic(*data)``) and returns the</span></div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">        resulting statistic.</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        If `vectorized` is set ``True``, `statistic` must also accept a keyword</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">        argument `axis` and be vectorized to compute the statistic along the</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">        provided `axis` of the sample arrays.</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">    permutation_type : {&#39;independent&#39;, &#39;samples&#39;, &#39;pairings&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">        The type of permutations to be performed, in accordance with the</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">        null hypothesis. The first two permutation types are for paired sample</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">        statistics, in which all samples contain the same number of</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">        observations and observations with corresponding indices along `axis`</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">        are considered to be paired; the third is for independent sample</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">        statistics.</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">        - ``&#39;samples&#39;`` : observations are assigned to different samples</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">          but remain paired with the same observations from other samples.</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">          This permutation type is appropriate for paired sample hypothesis</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">          tests such as the Wilcoxon signed-rank test and the paired t-test.</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">        - ``&#39;pairings&#39;`` : observations are paired with different observations,</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">          but they remain within the same sample. This permutation type is</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">          appropriate for association/correlation tests with statistics such</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">          as Spearman&#39;s :math:`\rho`, Kendall&#39;s :math:`\tau`, and Pearson&#39;s</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">          :math:`r`.</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">        - ``&#39;independent&#39;`` (default) : observations are assigned to different</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">          samples. Samples may contain different numbers of observations. This</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">          permutation type is appropriate for independent sample hypothesis</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">          tests such as the Mann-Whitney :math:`U` test and the independent</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">          sample t-test.</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">          Please see the Notes section below for more detailed descriptions</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">          of the permutation types.</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    vectorized : bool, default: ``False``</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">        By default, `statistic` is assumed to calculate the statistic only for</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">        1D arrays contained in `data`. If `vectorized` is set ``True``,</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">        `statistic` must also accept a keyword argument `axis` and be</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">        vectorized to compute the statistic along the provided `axis` of the ND</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">        arrays in `data`. Use of a vectorized statistic can reduce computation</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">        time.</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    n_resamples : int or np.inf, default: 9999</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">        Number of random permutations (resamples) used to approximate the null</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">        distribution. If greater than or equal to the number of distinct</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">        permutations, the exact null distribution will be computed.</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">        Note that the number of distinct permutations grows very rapidly with</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">        the sizes of samples, so exact tests are feasible only for very small</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        data sets.</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    batch : int, optional</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">        The number of permutations to process in each call to `statistic`.</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">        Memory usage is O(`batch`*``n``), where ``n`` is the total size</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        of all samples, regardless of the value of `vectorized`. Default is</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">        ``None``, in which case ``batch`` is the number of permutations.</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">    alternative : {&#39;two-sided&#39;, &#39;less&#39;, &#39;greater&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">        The alternative hypothesis for which the p-value is calculated.</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">        For each alternative, the p-value is defined for exact tests as</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">        follows.</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral">        - ``&#39;greater&#39;`` : the percentage of the null distribution that is</span></div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">          greater than or equal to the observed value of the test statistic.</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">        - ``&#39;less&#39;`` : the percentage of the null distribution that is</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">          less than or equal to the observed value of the test statistic.</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">        - ``&#39;two-sided&#39;`` (default) : twice the smaller of the p-values above.</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">        Note that p-values for randomized tests are calculated according to the</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">        conservative (over-estimated) approximation suggested in [2]_ and [3]_</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">        rather than the unbiased estimator suggested in [4]_. That is, when</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">        calculating the proportion of the randomized null distribution that is</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">        as extreme as the observed value of the test statistic, the values in</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        the numerator and denominator are both increased by one. An</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">        interpretation of this adjustment is that the observed value of the</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">        test statistic is always included as an element of the randomized</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">        null distribution.</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">        The convention used for two-sided p-values is not universal;</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">        the observed test statistic and null distribution are returned in</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">        case a different definition is preferred.</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    axis : int, default: 0</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">        The axis of the (broadcasted) samples over which to calculate the</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">        statistic. If samples have a different number of dimensions,</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        singleton dimensions are prepended to samples with fewer dimensions</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        before `axis` is considered.</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    random_state : {None, int, `numpy.random.Generator`,</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">                    `numpy.random.RandomState`}, optional</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">        Pseudorandom number generator state used to generate permutations.</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">        If `random_state` is ``None`` (default), the</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">        `numpy.random.RandomState` singleton is used.</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">        If `random_state` is an int, a new ``RandomState`` instance is used,</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral">        seeded with `random_state`.</span></div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">        If `random_state` is already a ``Generator`` or ``RandomState``</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">        instance then that instance is used.</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    statistic : float or ndarray</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">        The observed test statistic of the data.</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    pvalue : float or ndarray</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">        The p-value for the given alternative.</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">    null_distribution : ndarray</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">        The values of the test statistic generated under the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    The three types of permutation tests supported by this function are</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">    described below.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    **Unpaired statistics** (``permutation_type=&#39;independent&#39;``):</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    The null hypothesis associated with this permutation type is that all</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">    observations are sampled from the same underlying distribution and that</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    they have been assigned to one of the samples at random.</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    Suppose ``data`` contains two samples; e.g. ``a, b = data``.</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    When ``1 &lt; n_resamples &lt; binom(n, k)``, where</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">    * ``k`` is the number of observations in ``a``,</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    * ``n`` is the total number of observations in ``a`` and ``b``, and</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    * ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``),</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    the data are pooled (concatenated), randomly assigned to either the first</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    or second sample, and the statistic is calculated. This process is</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    performed repeatedly, `permutation` times, generating a distribution of the</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    statistic under the null hypothesis. The statistic of the original</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    data is compared to this distribution to determine the p-value.</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    When ``n_resamples &gt;= binom(n, k)``, an exact test is performed: the data</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    are *partitioned* between the samples in each distinct way exactly once,</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    and the exact null distribution is formed.</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    Note that for a given partitioning of the data between the samples,</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    only one ordering/permutation of the data *within* each sample is</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    considered. For statistics that do not depend on the order of the data</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    within samples, this dramatically reduces computational cost without</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    affecting the shape of the null distribution (because the frequency/count</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    of each value is affected by the same factor).</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    For ``a = [a1, a2, a3, a4]`` and ``b = [b1, b2, b3]``, an example of this</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    permutation type is ``x = [b3, a1, a2, b2]`` and ``y = [a4, b1, a3]``.</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    Because only one ordering/permutation of the data *within* each sample</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    is considered in an exact test, a resampling like ``x = [b3, a1, b2, a2]``</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">    and ``y = [a4, a3, b1]`` would *not* be considered distinct from the</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">    example above.</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    ``permutation_type=&#39;independent&#39;`` does not support one-sample statistics,</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">    but it can be applied to statistics with more than two samples. In this</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    case, if ``n`` is an array of the number of observations within each</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    sample, the number of distinct partitions is::</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">        np.product([binom(sum(n[i:]), sum(n[i+1:])) for i in range(len(n)-1)])</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">    **Paired statistics, permute pairings** (``permutation_type=&#39;pairings&#39;``):</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    The null hypothesis associated with this permutation type is that</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    observations within each sample are drawn from the same underlying</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    distribution and that pairings with elements of other samples are</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    assigned at random.</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    Suppose ``data`` contains only one sample; e.g. ``a, = data``, and we</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    wish to consider all possible pairings of elements of ``a`` with elements</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    of a second sample, ``b``. Let ``n`` be the number of observations in</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    ``a``, which must also equal the number of observations in ``b``.</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    When ``1 &lt; n_resamples &lt; factorial(n)``, the elements of ``a`` are</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    randomly permuted. The user-supplied statistic accepts one data argument,</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    say ``a_perm``, and calculates the statistic considering ``a_perm`` and</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    ``b``. This process is performed repeatedly, `permutation` times,</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    generating a distribution of the statistic under the null hypothesis.</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    The statistic of the original data is compared to this distribution to</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    determine the p-value.</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    When ``n_resamples &gt;= factorial(n)``, an exact test is performed:</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    ``a`` is permuted in each distinct way exactly once. Therefore, the</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    `statistic` is computed for each unique pairing of samples between ``a``</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">    and ``b`` exactly once.</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    permutation type is ``a_perm = [a3, a1, a2]`` while ``b`` is left</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    in its original order.</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    ``permutation_type=&#39;pairings&#39;`` supports ``data`` containing any number</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    of samples, each of which must contain the same number of observations.</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">    All samples provided in ``data`` are permuted *independently*. Therefore,</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    if ``m`` is the number of samples and ``n`` is the number of observations</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    within each sample, then the number of permutations in an exact test is::</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">        factorial(n)**m</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    Note that if a two-sample statistic, for example, does not inherently</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    depend on the order in which observations are provided - only on the</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    *pairings* of observations - then only one of the two samples should be</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    provided in ``data``. This dramatically reduces computational cost without</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    affecting the shape of the null distribution (because the frequency/count</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    of each value is affected by the same factor).</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    **Paired statistics, permute samples** (``permutation_type=&#39;samples&#39;``):</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    The null hypothesis associated with this permutation type is that</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    observations within each pair are drawn from the same underlying</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    distribution and that the sample to which they are assigned is random.</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    Suppose ``data`` contains two samples; e.g. ``a, b = data``.</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    Let ``n`` be the number of observations in ``a``, which must also equal</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    the number of observations in ``b``.</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    When ``1 &lt; n_resamples &lt; 2**n``, the elements of ``a`` are ``b`` are</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    randomly swapped between samples (maintaining their pairings) and the</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    statistic is calculated. This process is performed repeatedly,</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    `permutation` times,  generating a distribution of the statistic under the</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    null hypothesis. The statistic of the original data is compared to this</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    distribution to determine the p-value.</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    When ``n_resamples &gt;= 2**n``, an exact test is performed: the observations</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    are assigned to the two samples in each distinct way (while maintaining</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    pairings) exactly once.</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    permutation type is ``x = [b1, a2, b3]`` and ``y = [a1, b2, a3]``.</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    ``permutation_type=&#39;samples&#39;`` supports ``data`` containing any number</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">    of samples, each of which must contain the same number of observations.</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    If ``data`` contains more than one sample, paired observations within</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    ``data`` are exchanged between samples *independently*. Therefore, if ``m``</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    is the number of samples and ``n`` is the number of observations within</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    each sample, then the number of permutations in an exact test is::</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">        factorial(m)**n</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">    Several paired-sample statistical tests, such as the Wilcoxon signed rank</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">    test and paired-sample t-test, can be performed considering only the</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">    *difference* between two paired elements. Accordingly, if ``data`` contains</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    only one sample, then the null distribution is formed by independently</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">    changing the *sign* of each observation.</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">    .. warning::</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">        The p-value is calculated by counting the elements of the null</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">        distribution that are as extreme or more extreme than the observed</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">        value of the statistic. Due to the use of finite precision arithmetic,</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">        some statistic functions return numerically distinct values when the</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">        theoretical values would be exactly equal. In some cases, this could</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">        lead to a large error in the calculated p-value. `permutation_test`</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">        guards against this by considering elements in the null distribution</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">        that are &quot;close&quot; (within a factor of ``1+1e-14``) to the observed</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">        value of the test statistic as equal to the observed value of the</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">        test statistic. However, the user is advised to inspect the null</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">        distribution to assess whether this method of comparison is</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">        appropriate, and if not, calculate the p-value manually. See example</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">        below.</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">    .. [1] R. A. Fisher. The Design of Experiments, 6th Ed (1951).</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    .. [2] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">       Zero: Calculating Exact P-values When Permutations Are Randomly Drawn.&quot;</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral">       Statistical Applications in Genetics and Molecular Biology 9.1 (2010).</span></div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    .. [3] M. D. Ernst. &quot;Permutation Methods: A Basis for Exact Inference&quot;.</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">       Statistical Science (2004).</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    .. [4] B. Efron and R. J. Tibshirani. An Introduction to the Bootstrap</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">       (1993).</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">    Suppose we wish to test whether two samples are drawn from the same</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    distribution. Assume that the underlying distributions are unknown to us,</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">    and that before observing the data, we hypothesized that the mean of the</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    first sample would be less than that of the second sample. We decide that</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    we will use the difference between the sample means as a test statistic,</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">    and we will consider a p-value of 0.05 to be statistically significant.</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">    For efficiency, we write the function defining the test statistic in a</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">    vectorized fashion: the samples ``x`` and ``y`` can be ND arrays, and the</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    statistic will be calculated for each axis-slice along `axis`.</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">    &gt;&gt;&gt; def statistic(x, y, axis):</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">    ...     return np.mean(x, axis=axis) - np.mean(y, axis=axis)</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    After collecting our data, we calculate the observed value of the test</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">    statistic.</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import norm</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    &gt;&gt;&gt; x = norm.rvs(size=5, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    &gt;&gt;&gt; y = norm.rvs(size=6, loc = 3, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    &gt;&gt;&gt; statistic(x, y, 0)</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">    -3.5411688580987266</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    Indeed, the test statistic is negative, suggesting that the true mean of</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">    the distribution underlying ``x`` is less than that of the distribution</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">    underlying ``y``. To determine the probability of this occuring by chance</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">    if the two samples were drawn from the same distribution, we perform</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    a permutation test.</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import permutation_test</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    &gt;&gt;&gt; # because our statistic is vectorized, we pass `vectorized=True`</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    &gt;&gt;&gt; # `n_resamples=np.inf` indicates that an exact test is to be performed</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    &gt;&gt;&gt; res = permutation_test((x, y), statistic, vectorized=True,</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">    ...                        n_resamples=np.inf, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">    &gt;&gt;&gt; print(res.statistic)</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">    -3.5411688580987266</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">    &gt;&gt;&gt; print(res.pvalue)</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    0.004329004329004329</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">    The probability of obtaining a test statistic less than or equal to the</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">    observed value under the null hypothesis is 0.4329%. This is less than our</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">    chosen threshold of 5%, so we consider this to to be significant evidence</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">    against the null hypothesis in favor of the alternative.</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    Because the size of the samples above was small, `permutation_test` could</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">    perform an exact test. For larger samples, we resort to a randomized</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">    permutation test.</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">    &gt;&gt;&gt; x = norm.rvs(size=100, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral">    &gt;&gt;&gt; y = norm.rvs(size=120, loc=0.3, random_state=rng)</span></div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    &gt;&gt;&gt; res = permutation_test((x, y), statistic, n_resamples=100000,</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral">    ...                        vectorized=True, alternative=&#39;less&#39;,</span></div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    ...                        random_state=rng)</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">    &gt;&gt;&gt; print(res.statistic)</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    -0.5230459671240913</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    &gt;&gt;&gt; print(res.pvalue)</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">    0.00016999830001699983</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral">    The approximate probability of obtaining a test statistic less than or</span></div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    equal to the observed value under the null hypothesis is 0.0225%. This is</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral">    again less than our chosen threshold of 5%, so again we have significant</span></div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    evidence to reject the null hypothesis in favor of the alternative.</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    For large samples and number of permutations, the result is comparable to</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    that of the corresponding asymptotic test, the independent sample t-test.</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import ttest_ind</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    &gt;&gt;&gt; res_asymptotic = ttest_ind(x, y, alternative=&#39;less&#39;)</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">    &gt;&gt;&gt; print(res_asymptotic.pvalue)</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    0.00012688101537979522</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">    The permutation distribution of the test statistic is provided for</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    further investigation.</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    &gt;&gt;&gt; plt.hist(res.null_distribution, bins=50)</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Permutation distribution of test statistic&quot;)</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Value of Statistic&quot;)</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Frequency&quot;)</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    Inspection of the null distribution is essential if the statistic suffers</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">    from inaccuracy due to limited machine precision. Consider the following</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    case:</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.stats import pearsonr</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    &gt;&gt;&gt; x = [1, 2, 4, 3]</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    &gt;&gt;&gt; y = [2, 4, 6, 8]</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    &gt;&gt;&gt; def statistic(x, y):</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    ...     return pearsonr(x, y).statistic</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">    &gt;&gt;&gt; res = permutation_test((x, y), statistic, vectorized=False,</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    ...                        permutation_type=&#39;pairings&#39;,</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">    ...                        alternative=&#39;greater&#39;)</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    &gt;&gt;&gt; r, pvalue, null = res.statistic, res.pvalue, res.null_distribution</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">    In this case, some elements of the null distribution differ from the</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    observed value of the correlation coefficient ``r`` due to numerical noise.</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">    We manually inspect the elements of the null distribution that are nearly</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    the same as the observed value of the test statistic.</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    &gt;&gt;&gt; r</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    0.8</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    &gt;&gt;&gt; unique = np.unique(null)</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    &gt;&gt;&gt; unique</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    array([-1. , -0.8, -0.8, -0.6, -0.4, -0.2, -0.2,  0. ,  0.2,  0.2,  0.4,</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">            0.6,  0.8,  0.8,  1. ]) # may vary</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral">    &gt;&gt;&gt; unique[np.isclose(r, unique)].tolist()</span></div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">    [0.7999999999999999, 0.8]</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    If `permutation_test` were to perform the comparison naively, the</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral">    elements of the null distribution with value ``0.7999999999999999`` would</span></div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    not be considered as extreme or more extreme as the observed value of the</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    statistic, so the calculated p-value would be too small.</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    &gt;&gt;&gt; incorrect_pvalue = np.count_nonzero(null &gt;= r) / len(null)</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    &gt;&gt;&gt; incorrect_pvalue</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral">    0.1111111111111111  # may vary</span></div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    Instead, `permutation_test` treats elements of the null distribution that</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">    are within ``max(1e-14, abs(r)*1e-14)`` of the observed value of the</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    statistic ``r`` to be equal to ``r``.</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">    &gt;&gt;&gt; correct_pvalue = np.count_nonzero(null &gt;= r - 1e-14) / len(null)</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral">    &gt;&gt;&gt; correct_pvalue</span></div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    0.16666666666666666</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    &gt;&gt;&gt; res.pvalue == correct_pvalue</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    This method of comparison is expected to be accurate in most practical</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    situations, but the user is advised to assess this by inspecting the</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">    elements of the null distribution that are close to the observed value</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral">    of the statistic. Also, consider the use of statistics that can be</span></div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">    calculated using exact arithmetic (e.g. integer statistics).</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1396</span>    args = _permutation_test_iv(data, statistic, permutation_type, vectorized,</div>
<div class="line"><span class="lineno"> 1397</span>                                n_resamples, batch, alternative, axis,</div>
<div class="line"><span class="lineno"> 1398</span>                                random_state)</div>
<div class="line"><span class="lineno"> 1399</span>    (data, statistic, permutation_type, vectorized, n_resamples, batch,</div>
<div class="line"><span class="lineno"> 1400</span>     alternative, axis, random_state) = args</div>
<div class="line"><span class="lineno"> 1401</span> </div>
<div class="line"><span class="lineno"> 1402</span>    observed = statistic(*data, axis=-1)</div>
<div class="line"><span class="lineno"> 1403</span> </div>
<div class="line"><span class="lineno"> 1404</span>    null_calculators = {<span class="stringliteral">&quot;pairings&quot;</span>: _calculate_null_pairings,</div>
<div class="line"><span class="lineno"> 1405</span>                        <span class="stringliteral">&quot;samples&quot;</span>: _calculate_null_samples,</div>
<div class="line"><span class="lineno"> 1406</span>                        <span class="stringliteral">&quot;independent&quot;</span>: _calculate_null_both}</div>
<div class="line"><span class="lineno"> 1407</span>    null_calculator_args = (data, statistic, n_resamples,</div>
<div class="line"><span class="lineno"> 1408</span>                            batch, random_state)</div>
<div class="line"><span class="lineno"> 1409</span>    calculate_null = null_calculators[permutation_type]</div>
<div class="line"><span class="lineno"> 1410</span>    null_distribution, n_resamples, exact_test = (</div>
<div class="line"><span class="lineno"> 1411</span>        calculate_null(*null_calculator_args))</div>
<div class="line"><span class="lineno"> 1412</span> </div>
<div class="line"><span class="lineno"> 1413</span>    <span class="comment"># See References [2] and [3]</span></div>
<div class="line"><span class="lineno"> 1414</span>    adjustment = 0 <span class="keywordflow">if</span> exact_test <span class="keywordflow">else</span> 1</div>
<div class="line"><span class="lineno"> 1415</span> </div>
<div class="line"><span class="lineno"> 1416</span>    <span class="comment"># relative tolerance for detecting numerically distinct but</span></div>
<div class="line"><span class="lineno"> 1417</span>    <span class="comment"># theoretically equal values in the null distribution</span></div>
<div class="line"><span class="lineno"> 1418</span>    eps = 1e-14</div>
<div class="line"><span class="lineno"> 1419</span>    gamma = np.maximum(eps, np.abs(eps * observed))</div>
<div class="line"><span class="lineno"> 1420</span> </div>
<div class="line"><span class="lineno"> 1421</span>    <span class="keyword">def </span>less(null_distribution, observed):</div>
<div class="line"><span class="lineno"> 1422</span>        cmps = null_distribution &lt;= observed + gamma</div>
<div class="line"><span class="lineno"> 1423</span>        pvalues = (cmps.sum(axis=0) + adjustment) / (n_resamples + adjustment)</div>
<div class="line"><span class="lineno"> 1424</span>        <span class="keywordflow">return</span> pvalues</div>
<div class="line"><span class="lineno"> 1425</span> </div>
<div class="line"><span class="lineno"> 1426</span>    <span class="keyword">def </span>greater(null_distribution, observed):</div>
<div class="line"><span class="lineno"> 1427</span>        cmps = null_distribution &gt;= observed - gamma</div>
<div class="line"><span class="lineno"> 1428</span>        pvalues = (cmps.sum(axis=0) + adjustment) / (n_resamples + adjustment)</div>
<div class="line"><span class="lineno"> 1429</span>        <span class="keywordflow">return</span> pvalues</div>
<div class="line"><span class="lineno"> 1430</span> </div>
<div class="line"><span class="lineno"> 1431</span>    <span class="keyword">def </span>two_sided(null_distribution, observed):</div>
<div class="line"><span class="lineno"> 1432</span>        pvalues_less = less(null_distribution, observed)</div>
<div class="line"><span class="lineno"> 1433</span>        pvalues_greater = greater(null_distribution, observed)</div>
<div class="line"><span class="lineno"> 1434</span>        pvalues = np.minimum(pvalues_less, pvalues_greater) * 2</div>
<div class="line"><span class="lineno"> 1435</span>        <span class="keywordflow">return</span> pvalues</div>
<div class="line"><span class="lineno"> 1436</span> </div>
<div class="line"><span class="lineno"> 1437</span>    compare = {<span class="stringliteral">&quot;less&quot;</span>: less,</div>
<div class="line"><span class="lineno"> 1438</span>               <span class="stringliteral">&quot;greater&quot;</span>: greater,</div>
<div class="line"><span class="lineno"> 1439</span>               <span class="stringliteral">&quot;two-sided&quot;</span>: two_sided}</div>
<div class="line"><span class="lineno"> 1440</span> </div>
<div class="line"><span class="lineno"> 1441</span>    pvalues = compare[alternative](null_distribution, observed)</div>
<div class="line"><span class="lineno"> 1442</span>    pvalues = np.clip(pvalues, 0, 1)</div>
<div class="line"><span class="lineno"> 1443</span> </div>
<div class="line"><span class="lineno"> 1444</span>    <span class="keywordflow">return</span> PermutationTestResult(observed, pvalues, null_distribution)</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2898f7d7422d9298058ae5aa30a2243c" name="a2898f7d7422d9298058ae5aa30a2243c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2898f7d7422d9298058ae5aa30a2243c">&#9670;&#160;</a></span>attributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.stats._resampling.attributes = ('statistic', 'pvalue', 'null_distribution')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e55a2af5b196e3cabca2ec8dd5a5217" name="a0e55a2af5b196e3cabca2ec8dd5a5217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e55a2af5b196e3cabca2ec8dd5a5217">&#9670;&#160;</a></span>BootstrapResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling.BootstrapResult = make_dataclass(&quot;BootstrapResult&quot;, <a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a4e22ee0892d74bab432bfd5333a81810">fields</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e22ee0892d74bab432bfd5333a81810" name="a4e22ee0892d74bab432bfd5333a81810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e22ee0892d74bab432bfd5333a81810">&#9670;&#160;</a></span>fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.stats._resampling.fields = ['confidence_interval', 'standard_error']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a245f06b9cc502d0f1983347197b50c55" name="a245f06b9cc502d0f1983347197b50c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245f06b9cc502d0f1983347197b50c55">&#9670;&#160;</a></span>MonteCarloTestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling.MonteCarloTestResult = make_dataclass(&quot;MonteCarloTestResult&quot;, <a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a4e22ee0892d74bab432bfd5333a81810">fields</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acddb2359731d30b63aaecddcf839b4f6" name="acddb2359731d30b63aaecddcf839b4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acddb2359731d30b63aaecddcf839b4f6">&#9670;&#160;</a></span>PermutationTestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._resampling.PermutationTestResult = make_dataclass('PermutationTestResult', <a class="el" href="namespacescipy_1_1stats_1_1__resampling.html#a2898f7d7422d9298058ae5aa30a2243c">attributes</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
