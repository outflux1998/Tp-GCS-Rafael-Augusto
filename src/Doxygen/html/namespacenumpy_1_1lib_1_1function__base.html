<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.lib.function_base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html">function_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.function_base Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1lib_1_1function__base_1_1vectorize.html">vectorize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6663e9e17400c1da951e9bd9b33dc36b" id="r_a6663e9e17400c1da951e9bd9b33dc36b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a6663e9e17400c1da951e9bd9b33dc36b">_rot90_dispatcher</a> (m, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a487d35c8a6e2a81ebb15722142c54b9c">k</a>=None, axes=None)</td></tr>
<tr class="separator:a6663e9e17400c1da951e9bd9b33dc36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5374f6a2d928557250c44f626ee930ba" id="r_a5374f6a2d928557250c44f626ee930ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a5374f6a2d928557250c44f626ee930ba">rot90</a> (m, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a487d35c8a6e2a81ebb15722142c54b9c">k</a>=1, axes=(0, 1))</td></tr>
<tr class="separator:a5374f6a2d928557250c44f626ee930ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a4474ef9b3aed3b94c9991f0f55f7" id="r_ab07a4474ef9b3aed3b94c9991f0f55f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ab07a4474ef9b3aed3b94c9991f0f55f7">_flip_dispatcher</a> (m, axis=None)</td></tr>
<tr class="separator:ab07a4474ef9b3aed3b94c9991f0f55f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88c114152e04ed3734835f74c231a74" id="r_ad88c114152e04ed3734835f74c231a74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ad88c114152e04ed3734835f74c231a74">flip</a> (m, axis=None)</td></tr>
<tr class="separator:ad88c114152e04ed3734835f74c231a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531c572a52ebfaba6055e1d1b7c88ba2" id="r_a531c572a52ebfaba6055e1d1b7c88ba2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a531c572a52ebfaba6055e1d1b7c88ba2">iterable</a> (y)</td></tr>
<tr class="separator:a531c572a52ebfaba6055e1d1b7c88ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e6b286d5158dd2bba66e5af0519ff6" id="r_aa4e6b286d5158dd2bba66e5af0519ff6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#aa4e6b286d5158dd2bba66e5af0519ff6">_average_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, weights=None, returned=None, *keepdims=None)</td></tr>
<tr class="separator:aa4e6b286d5158dd2bba66e5af0519ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8798b608f6ee8d7a72139dfc4d0af52f" id="r_a8798b608f6ee8d7a72139dfc4d0af52f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a8798b608f6ee8d7a72139dfc4d0af52f">average</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, weights=None, returned=False, *keepdims=np._NoValue)</td></tr>
<tr class="separator:a8798b608f6ee8d7a72139dfc4d0af52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6385b3c574b743167157dae3e84545" id="r_abc6385b3c574b743167157dae3e84545"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#abc6385b3c574b743167157dae3e84545">asarray_chkfinite</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, dtype=None, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None)</td></tr>
<tr class="separator:abc6385b3c574b743167157dae3e84545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceacb7828da5503ff904677f933fbb6b" id="r_aceacb7828da5503ff904677f933fbb6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#aceacb7828da5503ff904677f933fbb6b">_piecewise_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, condlist, funclist, *args, **kw)</td></tr>
<tr class="separator:aceacb7828da5503ff904677f933fbb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd513d50354ad3bf31cdf9a39773dbf" id="r_a1cd513d50354ad3bf31cdf9a39773dbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a1cd513d50354ad3bf31cdf9a39773dbf">piecewise</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, condlist, funclist, *args, **kw)</td></tr>
<tr class="separator:a1cd513d50354ad3bf31cdf9a39773dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca57a36f8bb8337a548b07cdeb235ef" id="r_aaca57a36f8bb8337a548b07cdeb235ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#aaca57a36f8bb8337a548b07cdeb235ef">_select_dispatcher</a> (condlist, choicelist, default=None)</td></tr>
<tr class="separator:aaca57a36f8bb8337a548b07cdeb235ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5593cdafb52222befa97feaabb012c44" id="r_a5593cdafb52222befa97feaabb012c44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a5593cdafb52222befa97feaabb012c44">select</a> (condlist, choicelist, default=0)</td></tr>
<tr class="separator:a5593cdafb52222befa97feaabb012c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9ac66acdcd7af7d6526bc5e3def29e" id="r_a5e9ac66acdcd7af7d6526bc5e3def29e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a5e9ac66acdcd7af7d6526bc5e3def29e">_copy_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=None, subok=None)</td></tr>
<tr class="separator:a5e9ac66acdcd7af7d6526bc5e3def29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1a45e10c0c1606be5642979696590c" id="r_afb1a45e10c0c1606be5642979696590c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afb1a45e10c0c1606be5642979696590c">copy</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>='K', subok=False)</td></tr>
<tr class="separator:afb1a45e10c0c1606be5642979696590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14a18842fd055aa06165c99aeb4811c" id="r_af14a18842fd055aa06165c99aeb4811c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af14a18842fd055aa06165c99aeb4811c">_gradient_dispatcher</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, *varargs, axis=None, edge_order=None)</td></tr>
<tr class="separator:af14a18842fd055aa06165c99aeb4811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34816c3b1cf5a22aa4e2ec2d74013a7" id="r_ad34816c3b1cf5a22aa4e2ec2d74013a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ad34816c3b1cf5a22aa4e2ec2d74013a7">gradient</a> (<a class="el" href="__lapack__subroutines_8h.html#af01a903df7bdb7a494f5827e45bf3a2a">f</a>, *varargs, axis=None, edge_order=1)</td></tr>
<tr class="separator:ad34816c3b1cf5a22aa4e2ec2d74013a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd7ee8cd55e5286490297bd24a56e70" id="r_a7dd7ee8cd55e5286490297bd24a56e70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a7dd7ee8cd55e5286490297bd24a56e70">_diff_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=None, axis=None, prepend=None, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a13549a07e8b31d8a0658c402bd920251">append</a>=None)</td></tr>
<tr class="separator:a7dd7ee8cd55e5286490297bd24a56e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb0a6129e9afd0c17390fcf39834c97" id="r_a5eb0a6129e9afd0c17390fcf39834c97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a5eb0a6129e9afd0c17390fcf39834c97">diff</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>=1, axis=-1, prepend=np._NoValue, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a13549a07e8b31d8a0658c402bd920251">append</a>=np._NoValue)</td></tr>
<tr class="separator:a5eb0a6129e9afd0c17390fcf39834c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e4ecc4b33b992085fab6942d41d08f" id="r_af7e4ecc4b33b992085fab6942d41d08f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af7e4ecc4b33b992085fab6942d41d08f">_interp_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, xp, fp, left=None, right=None, period=None)</td></tr>
<tr class="separator:af7e4ecc4b33b992085fab6942d41d08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b0bfb8023fc47d9991cb3429af814f" id="r_ab5b0bfb8023fc47d9991cb3429af814f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ab5b0bfb8023fc47d9991cb3429af814f">interp</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, xp, fp, left=None, right=None, period=None)</td></tr>
<tr class="separator:ab5b0bfb8023fc47d9991cb3429af814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0165bfb4f4fcf0d1ad84866ab52eeb28" id="r_a0165bfb4f4fcf0d1ad84866ab52eeb28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a0165bfb4f4fcf0d1ad84866ab52eeb28">_angle_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>, deg=None)</td></tr>
<tr class="separator:a0165bfb4f4fcf0d1ad84866ab52eeb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf6fbcc0e56edf854c6c4cb60c10568" id="r_a0cf6fbcc0e56edf854c6c4cb60c10568"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a0cf6fbcc0e56edf854c6c4cb60c10568">angle</a> (<a class="el" href="__blas__subroutines_8h.html#a97fad269e85497afbd382321b3079d38">z</a>, deg=False)</td></tr>
<tr class="separator:a0cf6fbcc0e56edf854c6c4cb60c10568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc61f633b580e8b652be7769c69c866" id="r_a3fc61f633b580e8b652be7769c69c866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a3fc61f633b580e8b652be7769c69c866">_unwrap_dispatcher</a> (p, discont=None, axis=None, *period=None)</td></tr>
<tr class="separator:a3fc61f633b580e8b652be7769c69c866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac934e7fa932a746c0f58564f9d87ad26" id="r_ac934e7fa932a746c0f58564f9d87ad26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ac934e7fa932a746c0f58564f9d87ad26">unwrap</a> (p, discont=None, axis=-1, *period=2 *pi)</td></tr>
<tr class="separator:ac934e7fa932a746c0f58564f9d87ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ece2e212e3125f1026cf6c4d86e40b9" id="r_a4ece2e212e3125f1026cf6c4d86e40b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a4ece2e212e3125f1026cf6c4d86e40b9">_sort_complex</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a4ece2e212e3125f1026cf6c4d86e40b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12184eaf5717d61a52570d93c2dfc98f" id="r_a12184eaf5717d61a52570d93c2dfc98f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a12184eaf5717d61a52570d93c2dfc98f">sort_complex</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a12184eaf5717d61a52570d93c2dfc98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c81f1007b64a18be5fb25e2c1d0b2f" id="r_ae0c81f1007b64a18be5fb25e2c1d0b2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ae0c81f1007b64a18be5fb25e2c1d0b2f">_trim_zeros</a> (filt, trim=None)</td></tr>
<tr class="separator:ae0c81f1007b64a18be5fb25e2c1d0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdbca2c84c981abdf7f356dbf3c66bc" id="r_adcdbca2c84c981abdf7f356dbf3c66bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#adcdbca2c84c981abdf7f356dbf3c66bc">trim_zeros</a> (filt, trim='fb')</td></tr>
<tr class="separator:adcdbca2c84c981abdf7f356dbf3c66bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcce310d04442337ab72600d2376054" id="r_abfcce310d04442337ab72600d2376054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#abfcce310d04442337ab72600d2376054">_extract_dispatcher</a> (condition, arr)</td></tr>
<tr class="separator:abfcce310d04442337ab72600d2376054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b248407fcb2f95fee57aa96e087bb0" id="r_ae2b248407fcb2f95fee57aa96e087bb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ae2b248407fcb2f95fee57aa96e087bb0">extract</a> (condition, arr)</td></tr>
<tr class="separator:ae2b248407fcb2f95fee57aa96e087bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9453c54c6da5ab749ecfeda5aefdb" id="r_af7b9453c54c6da5ab749ecfeda5aefdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af7b9453c54c6da5ab749ecfeda5aefdb">_place_dispatcher</a> (arr, mask, vals)</td></tr>
<tr class="separator:af7b9453c54c6da5ab749ecfeda5aefdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e851f1e69da703565e781dc75ba601" id="r_ae4e851f1e69da703565e781dc75ba601"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ae4e851f1e69da703565e781dc75ba601">place</a> (arr, mask, vals)</td></tr>
<tr class="separator:ae4e851f1e69da703565e781dc75ba601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dbeec0a20ef95416268f8965120fba" id="r_a09dbeec0a20ef95416268f8965120fba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a09dbeec0a20ef95416268f8965120fba">disp</a> (mesg, device=None, linefeed=True)</td></tr>
<tr class="separator:a09dbeec0a20ef95416268f8965120fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd4d999d6b5a10b0393280c42c6af87" id="r_a8fd4d999d6b5a10b0393280c42c6af87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a8fd4d999d6b5a10b0393280c42c6af87">_parse_gufunc_signature</a> (signature)</td></tr>
<tr class="separator:a8fd4d999d6b5a10b0393280c42c6af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432b28466a45d69935947e5c43eac939" id="r_a432b28466a45d69935947e5c43eac939"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a432b28466a45d69935947e5c43eac939">_update_dim_sizes</a> (dim_sizes, arg, core_dims)</td></tr>
<tr class="separator:a432b28466a45d69935947e5c43eac939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcca8942511a26a4466c9792dac08e3" id="r_a2dcca8942511a26a4466c9792dac08e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a2dcca8942511a26a4466c9792dac08e3">_parse_input_dimensions</a> (args, input_core_dims)</td></tr>
<tr class="separator:a2dcca8942511a26a4466c9792dac08e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd84e4110f0ef89eace0688b4ec6d9e" id="r_accd84e4110f0ef89eace0688b4ec6d9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#accd84e4110f0ef89eace0688b4ec6d9e">_calculate_shapes</a> (broadcast_shape, dim_sizes, list_of_core_dims)</td></tr>
<tr class="separator:accd84e4110f0ef89eace0688b4ec6d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817fda32f3fd4bb659c8798d0b764339" id="r_a817fda32f3fd4bb659c8798d0b764339"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a817fda32f3fd4bb659c8798d0b764339">_create_arrays</a> (broadcast_shape, dim_sizes, list_of_core_dims, dtypes, results=None)</td></tr>
<tr class="separator:a817fda32f3fd4bb659c8798d0b764339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05da1ab168dad81bf5128b5e965973c" id="r_af05da1ab168dad81bf5128b5e965973c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af05da1ab168dad81bf5128b5e965973c">_cov_dispatcher</a> (m, y=None, rowvar=None, bias=None, ddof=None, fweights=None, aweights=None, *dtype=None)</td></tr>
<tr class="separator:af05da1ab168dad81bf5128b5e965973c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ff4e828f8cc2c7e326a1b09ffce808" id="r_ac6ff4e828f8cc2c7e326a1b09ffce808"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ac6ff4e828f8cc2c7e326a1b09ffce808">cov</a> (m, y=None, rowvar=True, bias=False, ddof=None, fweights=None, aweights=None, *dtype=None)</td></tr>
<tr class="separator:ac6ff4e828f8cc2c7e326a1b09ffce808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce71332a846dc341e3e16c575142e97" id="r_a3ce71332a846dc341e3e16c575142e97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a3ce71332a846dc341e3e16c575142e97">_corrcoef_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y=None, rowvar=None, bias=None, ddof=None, *dtype=None)</td></tr>
<tr class="separator:a3ce71332a846dc341e3e16c575142e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2472954dd7ece8908ce5d16934b838ab" id="r_a2472954dd7ece8908ce5d16934b838ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a2472954dd7ece8908ce5d16934b838ab">corrcoef</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, y=None, rowvar=True, bias=np._NoValue, ddof=np._NoValue, *dtype=None)</td></tr>
<tr class="separator:a2472954dd7ece8908ce5d16934b838ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25ec614bed6130cd2a0d4610369203f" id="r_af25ec614bed6130cd2a0d4610369203f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af25ec614bed6130cd2a0d4610369203f">blackman</a> (M)</td></tr>
<tr class="separator:af25ec614bed6130cd2a0d4610369203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f32cf5c260956aeada9d703c74620e" id="r_a04f32cf5c260956aeada9d703c74620e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a04f32cf5c260956aeada9d703c74620e">bartlett</a> (M)</td></tr>
<tr class="separator:a04f32cf5c260956aeada9d703c74620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485a32d8c4e900a028bf62da520be04" id="r_a5485a32d8c4e900a028bf62da520be04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a5485a32d8c4e900a028bf62da520be04">hanning</a> (M)</td></tr>
<tr class="separator:a5485a32d8c4e900a028bf62da520be04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6daf481775305b9274f38dbf7f28075" id="r_ad6daf481775305b9274f38dbf7f28075"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ad6daf481775305b9274f38dbf7f28075">hamming</a> (M)</td></tr>
<tr class="separator:ad6daf481775305b9274f38dbf7f28075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5223ef0995959b8e90373a8c0535b541" id="r_a5223ef0995959b8e90373a8c0535b541"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a5223ef0995959b8e90373a8c0535b541">_chbevl</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, vals)</td></tr>
<tr class="separator:a5223ef0995959b8e90373a8c0535b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415e4dc396dc474b62ec8f37a101ed98" id="r_a415e4dc396dc474b62ec8f37a101ed98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a415e4dc396dc474b62ec8f37a101ed98">_i0_1</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:a415e4dc396dc474b62ec8f37a101ed98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80035258d3cf2d7837975b6760b7caae" id="r_a80035258d3cf2d7837975b6760b7caae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a80035258d3cf2d7837975b6760b7caae">_i0_2</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:a80035258d3cf2d7837975b6760b7caae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680690bfaf9f6a7acc8ac34ca0d0dc5f" id="r_a680690bfaf9f6a7acc8ac34ca0d0dc5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a680690bfaf9f6a7acc8ac34ca0d0dc5f">_i0_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:a680690bfaf9f6a7acc8ac34ca0d0dc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c6f434b7fb3ba18363854522256b98" id="r_a56c6f434b7fb3ba18363854522256b98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a56c6f434b7fb3ba18363854522256b98">i0</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:a56c6f434b7fb3ba18363854522256b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c484a36cce93348651a5fe19e2ac5e8" id="r_a3c484a36cce93348651a5fe19e2ac5e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a3c484a36cce93348651a5fe19e2ac5e8">kaiser</a> (M, beta)</td></tr>
<tr class="memdesc:a3c484a36cce93348651a5fe19e2ac5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of cephes code for i0.  <br /></td></tr>
<tr class="separator:a3c484a36cce93348651a5fe19e2ac5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187839059f6c15a7083b0cfd2c8370b8" id="r_a187839059f6c15a7083b0cfd2c8370b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a187839059f6c15a7083b0cfd2c8370b8">_sinc_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:a187839059f6c15a7083b0cfd2c8370b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1037c45a8411f2e3cd9dcf9a9ed7c75c" id="r_a1037c45a8411f2e3cd9dcf9a9ed7c75c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a1037c45a8411f2e3cd9dcf9a9ed7c75c">sinc</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>)</td></tr>
<tr class="separator:a1037c45a8411f2e3cd9dcf9a9ed7c75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697831795d3e31b4fec41f491f42d566" id="r_a697831795d3e31b4fec41f491f42d566"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a697831795d3e31b4fec41f491f42d566">_msort_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a697831795d3e31b4fec41f491f42d566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c594f2c56716496924f9606f7751cd" id="r_a95c594f2c56716496924f9606f7751cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a95c594f2c56716496924f9606f7751cd">msort</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a95c594f2c56716496924f9606f7751cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9416be2583f39d18e7d839905d4da827" id="r_a9416be2583f39d18e7d839905d4da827"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a9416be2583f39d18e7d839905d4da827">_ureduce</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, keepdims=False, **kwargs)</td></tr>
<tr class="separator:a9416be2583f39d18e7d839905d4da827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35a05205b994efe996d7488299c6a71" id="r_ac35a05205b994efe996d7488299c6a71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ac35a05205b994efe996d7488299c6a71">_median_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, overwrite_input=None, keepdims=None)</td></tr>
<tr class="separator:ac35a05205b994efe996d7488299c6a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862b8d45a444babe7129725541b2e8bb" id="r_a862b8d45a444babe7129725541b2e8bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a862b8d45a444babe7129725541b2e8bb">median</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, overwrite_input=False, keepdims=False)</td></tr>
<tr class="separator:a862b8d45a444babe7129725541b2e8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13a3070ca6d89e5a7b77afbc6b93b5b" id="r_ac13a3070ca6d89e5a7b77afbc6b93b5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ac13a3070ca6d89e5a7b77afbc6b93b5b">_median</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, axis=None, out=None, overwrite_input=False)</td></tr>
<tr class="separator:ac13a3070ca6d89e5a7b77afbc6b93b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9f45ed23cdbeb84447214b29b4f200" id="r_ade9f45ed23cdbeb84447214b29b4f200"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ade9f45ed23cdbeb84447214b29b4f200">_percentile_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=None, method=None, keepdims=None, *interpolation=None)</td></tr>
<tr class="separator:ade9f45ed23cdbeb84447214b29b4f200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4e514e3ecff25254cc286445e42622" id="r_a7b4e514e3ecff25254cc286445e42622"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a7b4e514e3ecff25254cc286445e42622">percentile</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=False, method=&quot;linear&quot;, keepdims=False, *interpolation=None)</td></tr>
<tr class="separator:a7b4e514e3ecff25254cc286445e42622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736fb6304d6e0742af293b62420de80a" id="r_a736fb6304d6e0742af293b62420de80a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a736fb6304d6e0742af293b62420de80a">_quantile_dispatcher</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=None, method=None, keepdims=None, *interpolation=None)</td></tr>
<tr class="separator:a736fb6304d6e0742af293b62420de80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57179f55df5cbb088279582322eff2a0" id="r_a57179f55df5cbb088279582322eff2a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a57179f55df5cbb088279582322eff2a0">quantile</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=False, method=&quot;linear&quot;, keepdims=False, *interpolation=None)</td></tr>
<tr class="separator:a57179f55df5cbb088279582322eff2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ee7858a5049c52b0a7591c97e9d2a2" id="r_ac7ee7858a5049c52b0a7591c97e9d2a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ac7ee7858a5049c52b0a7591c97e9d2a2">_quantile_unchecked</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, axis=None, out=None, overwrite_input=False, method=&quot;linear&quot;, keepdims=False)</td></tr>
<tr class="separator:ac7ee7858a5049c52b0a7591c97e9d2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd779e8ab92d87504d8fa98658602b0" id="r_aafd779e8ab92d87504d8fa98658602b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#aafd779e8ab92d87504d8fa98658602b0">_quantile_is_valid</a> (<a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>)</td></tr>
<tr class="separator:aafd779e8ab92d87504d8fa98658602b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078381834838b66c27a96ec6d798cbaf" id="r_a078381834838b66c27a96ec6d798cbaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a078381834838b66c27a96ec6d798cbaf">_check_interpolation_as_method</a> (method, interpolation, fname)</td></tr>
<tr class="separator:a078381834838b66c27a96ec6d798cbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4872dd9e8f7cad54bca94832b667b68" id="r_ab4872dd9e8f7cad54bca94832b667b68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ab4872dd9e8f7cad54bca94832b667b68">_compute_virtual_index</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, quantiles, float <a class="el" href="__blas__subroutines_8h.html#a29dda7d0819a860e921db821deb590c9">alpha</a>, float beta)</td></tr>
<tr class="separator:ab4872dd9e8f7cad54bca94832b667b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38535df22bea17a5450c1cbe06705650" id="r_a38535df22bea17a5450c1cbe06705650"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a38535df22bea17a5450c1cbe06705650">_get_gamma</a> (virtual_indexes, previous_indexes, method)</td></tr>
<tr class="separator:a38535df22bea17a5450c1cbe06705650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f6bbc21ee745dd0bacb3c0d4cc8d99" id="r_a86f6bbc21ee745dd0bacb3c0d4cc8d99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a86f6bbc21ee745dd0bacb3c0d4cc8d99">_lerp</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, b, t, out=None)</td></tr>
<tr class="separator:a86f6bbc21ee745dd0bacb3c0d4cc8d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb5a05da78ca94a57a1c46c71b2893" id="r_acccb5a05da78ca94a57a1c46c71b2893"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#acccb5a05da78ca94a57a1c46c71b2893">_get_gamma_mask</a> (<a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>, default_value, conditioned_value, where)</td></tr>
<tr class="separator:acccb5a05da78ca94a57a1c46c71b2893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837273439cfedef9a15b4dd17c759dbd" id="r_a837273439cfedef9a15b4dd17c759dbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a837273439cfedef9a15b4dd17c759dbd">_discret_interpolation_to_boundaries</a> (index, gamma_condition_fun)</td></tr>
<tr class="separator:a837273439cfedef9a15b4dd17c759dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f111ae2e860dff2f018169b638fdd6" id="r_a30f111ae2e860dff2f018169b638fdd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a30f111ae2e860dff2f018169b638fdd6">_closest_observation</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, quantiles)</td></tr>
<tr class="separator:a30f111ae2e860dff2f018169b638fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af570374bc269eec1dec2cb524aaee2a0" id="r_af570374bc269eec1dec2cb524aaee2a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af570374bc269eec1dec2cb524aaee2a0">_inverted_cdf</a> (<a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, quantiles)</td></tr>
<tr class="separator:af570374bc269eec1dec2cb524aaee2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae9d682b7d8f24138adc42f0bb8a2dd" id="r_afae9d682b7d8f24138adc42f0bb8a2dd"><td class="memItemLeft" align="right" valign="top">np.array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afae9d682b7d8f24138adc42f0bb8a2dd">_quantile_ureduce_func</a> (np.array <a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>, np.array <a class="el" href="__lapack__subroutines_8h.html#a8061c32fe478d4807c95448a20a58ca8">q</a>, int axis=None, out=None, bool overwrite_input=False, method=&quot;linear&quot;)</td></tr>
<tr class="separator:afae9d682b7d8f24138adc42f0bb8a2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b582efb533df6bedb038ce54e55892" id="r_a73b582efb533df6bedb038ce54e55892"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a73b582efb533df6bedb038ce54e55892">_get_indexes</a> (arr, virtual_indexes, valid_values_count)</td></tr>
<tr class="separator:a73b582efb533df6bedb038ce54e55892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786f8aa690fe7768451c43830db49011" id="r_a786f8aa690fe7768451c43830db49011"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a786f8aa690fe7768451c43830db49011">_quantile</a> (np.array arr, np.array quantiles, int axis=-1, method=&quot;linear&quot;, out=None)</td></tr>
<tr class="separator:a786f8aa690fe7768451c43830db49011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf350a26e5dc3b49c88020b5d05885f7" id="r_aaf350a26e5dc3b49c88020b5d05885f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#aaf350a26e5dc3b49c88020b5d05885f7">_trapz_dispatcher</a> (y, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>=None, <a class="el" href="__blas__subroutines_8h.html#a6b1e36c081feb196285c9fc4062b28ed">dx</a>=None, axis=None)</td></tr>
<tr class="separator:aaf350a26e5dc3b49c88020b5d05885f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a1f30ec367d053bf4eee0cf62e3007" id="r_a78a1f30ec367d053bf4eee0cf62e3007"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a78a1f30ec367d053bf4eee0cf62e3007">trapz</a> (y, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>=None, <a class="el" href="__blas__subroutines_8h.html#a6b1e36c081feb196285c9fc4062b28ed">dx</a>=1.0, axis=-1)</td></tr>
<tr class="separator:a78a1f30ec367d053bf4eee0cf62e3007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fdae5868cf1a1d0605583ce647ebac" id="r_a03fdae5868cf1a1d0605583ce647ebac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a03fdae5868cf1a1d0605583ce647ebac">_meshgrid_dispatcher</a> (*xi, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afb1a45e10c0c1606be5642979696590c">copy</a>=None, sparse=None, indexing=None)</td></tr>
<tr class="separator:a03fdae5868cf1a1d0605583ce647ebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d88bc97622504e8818d631de5e3e3b9" id="r_a6d88bc97622504e8818d631de5e3e3b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a6d88bc97622504e8818d631de5e3e3b9">meshgrid</a> (*xi, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#afb1a45e10c0c1606be5642979696590c">copy</a>=True, sparse=False, indexing='xy')</td></tr>
<tr class="separator:a6d88bc97622504e8818d631de5e3e3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e424db95791f2e98e0c8f8a202b55e6" id="r_a1e424db95791f2e98e0c8f8a202b55e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a1e424db95791f2e98e0c8f8a202b55e6">_delete_dispatcher</a> (arr, obj, axis=None)</td></tr>
<tr class="separator:a1e424db95791f2e98e0c8f8a202b55e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4663e1646f5d9ce74aa757c3c9b4a463" id="r_a4663e1646f5d9ce74aa757c3c9b4a463"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a4663e1646f5d9ce74aa757c3c9b4a463">delete</a> (arr, obj, axis=None)</td></tr>
<tr class="separator:a4663e1646f5d9ce74aa757c3c9b4a463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa999aff78932c3fd4272e93e2f485c60" id="r_aa999aff78932c3fd4272e93e2f485c60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#aa999aff78932c3fd4272e93e2f485c60">_insert_dispatcher</a> (arr, obj, values, axis=None)</td></tr>
<tr class="separator:aa999aff78932c3fd4272e93e2f485c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b6af9b1d56f8f1d7d88ffcc050bed3" id="r_ae0b6af9b1d56f8f1d7d88ffcc050bed3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ae0b6af9b1d56f8f1d7d88ffcc050bed3">insert</a> (arr, obj, values, axis=None)</td></tr>
<tr class="separator:ae0b6af9b1d56f8f1d7d88ffcc050bed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18950a0bfec4d88a8d2fbdade58647ac" id="r_a18950a0bfec4d88a8d2fbdade58647ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a18950a0bfec4d88a8d2fbdade58647ac">_append_dispatcher</a> (arr, values, axis=None)</td></tr>
<tr class="separator:a18950a0bfec4d88a8d2fbdade58647ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13549a07e8b31d8a0658c402bd920251" id="r_a13549a07e8b31d8a0658c402bd920251"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a13549a07e8b31d8a0658c402bd920251">append</a> (arr, values, axis=None)</td></tr>
<tr class="separator:a13549a07e8b31d8a0658c402bd920251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae65b20eed1e549338d2939691f061c" id="r_a9ae65b20eed1e549338d2939691f061c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a9ae65b20eed1e549338d2939691f061c">_digitize_dispatcher</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, bins, right=None)</td></tr>
<tr class="separator:a9ae65b20eed1e549338d2939691f061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa259b287cb75f0a18e0ef9a53296e62d" id="r_aa259b287cb75f0a18e0ef9a53296e62d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#aa259b287cb75f0a18e0ef9a53296e62d">digitize</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#af7a40df6735224194004fe9d7a2b80d4">x</a>, bins, right=False)</td></tr>
<tr class="separator:aa259b287cb75f0a18e0ef9a53296e62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad03f4b858ee9cb78b9adf3cbb4465b1d" id="r_ad03f4b858ee9cb78b9adf3cbb4465b1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ad03f4b858ee9cb78b9adf3cbb4465b1d">array_function_dispatch</a></td></tr>
<tr class="separator:ad03f4b858ee9cb78b9adf3cbb4465b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef37d5da5475303548c0d850c3ca93d" id="r_abef37d5da5475303548c0d850c3ca93d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#abef37d5da5475303548c0d850c3ca93d">_QuantileMethods</a></td></tr>
<tr class="separator:abef37d5da5475303548c0d850c3ca93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d9035d2b11bf7f5b20a6e4b4c51f45" id="r_a85d9035d2b11bf7f5b20a6e4b4c51f45"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a85d9035d2b11bf7f5b20a6e4b4c51f45">_DIMENSION_NAME</a> = <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>'\<a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>+'</td></tr>
<tr class="separator:a85d9035d2b11bf7f5b20a6e4b4c51f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58631ca9768a039f025fec3bcdbe50ed" id="r_a58631ca9768a039f025fec3bcdbe50ed"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a58631ca9768a039f025fec3bcdbe50ed">_CORE_DIMENSION_LIST</a> = '(?:{0:}(?:,{0:})*)?'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a85d9035d2b11bf7f5b20a6e4b4c51f45">_DIMENSION_NAME</a>)</td></tr>
<tr class="separator:a58631ca9768a039f025fec3bcdbe50ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf3ca9d1e59a41d35ff1fe635d91c7" id="r_a6cdf3ca9d1e59a41d35ff1fe635d91c7"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a6cdf3ca9d1e59a41d35ff1fe635d91c7">_ARGUMENT</a> = <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>'\&zwj;({}\&zwj;)'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a58631ca9768a039f025fec3bcdbe50ed">_CORE_DIMENSION_LIST</a>)</td></tr>
<tr class="separator:a6cdf3ca9d1e59a41d35ff1fe635d91c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504fea436affc23ee55663f83ad378ea" id="r_a504fea436affc23ee55663f83ad378ea"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a504fea436affc23ee55663f83ad378ea">_ARGUMENT_LIST</a> = '{0:}(?:,{0:})*'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a6cdf3ca9d1e59a41d35ff1fe635d91c7">_ARGUMENT</a>)</td></tr>
<tr class="separator:a504fea436affc23ee55663f83ad378ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2960f69f383be4a34e3432599f93d8d7" id="r_a2960f69f383be4a34e3432599f93d8d7"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a2960f69f383be4a34e3432599f93d8d7">_SIGNATURE</a> = '^{0:}-&gt;{0:}$'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a504fea436affc23ee55663f83ad378ea">_ARGUMENT_LIST</a>)</td></tr>
<tr class="separator:a2960f69f383be4a34e3432599f93d8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1d6d9089e5008cba16f91bac09e8d7" id="r_ada1d6d9089e5008cba16f91bac09e8d7"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#ada1d6d9089e5008cba16f91bac09e8d7">_i0A</a></td></tr>
<tr class="memdesc:ada1d6d9089e5008cba16f91bac09e8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code from cephes for i0.  <br /></td></tr>
<tr class="separator:ada1d6d9089e5008cba16f91bac09e8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc2115172d1dffd8ffb230438df384" id="r_a25cc2115172d1dffd8ffb230438df384"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a25cc2115172d1dffd8ffb230438df384">_i0B</a></td></tr>
<tr class="separator:a25cc2115172d1dffd8ffb230438df384"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0165bfb4f4fcf0d1ad84866ab52eeb28" name="a0165bfb4f4fcf0d1ad84866ab52eeb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0165bfb4f4fcf0d1ad84866ab52eeb28">&#9670;&#160;</a></span>_angle_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._angle_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1598</span><span class="keyword">def </span>_angle_dispatcher(z, deg=None):</div>
<div class="line"><span class="lineno"> 1599</span>    <span class="keywordflow">return</span> (z,)</div>
<div class="line"><span class="lineno"> 1600</span> </div>
<div class="line"><span class="lineno"> 1601</span> </div>
<div class="line"><span class="lineno"> 1602</span><span class="preprocessor">@array_function_dispatch(_angle_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a18950a0bfec4d88a8d2fbdade58647ac" name="a18950a0bfec4d88a8d2fbdade58647ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18950a0bfec4d88a8d2fbdade58647ac">&#9670;&#160;</a></span>_append_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._append_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5440</span><span class="keyword">def </span>_append_dispatcher(arr, values, axis=None):</div>
<div class="line"><span class="lineno"> 5441</span>    <span class="keywordflow">return</span> (arr, values)</div>
<div class="line"><span class="lineno"> 5442</span> </div>
<div class="line"><span class="lineno"> 5443</span> </div>
<div class="line"><span class="lineno"> 5444</span><span class="preprocessor">@array_function_dispatch(_append_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4e6b286d5158dd2bba66e5af0519ff6" name="aa4e6b286d5158dd2bba66e5af0519ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e6b286d5158dd2bba66e5af0519ff6">&#9670;&#160;</a></span>_average_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._average_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>returned</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  392</span>                        keepdims=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">return</span> (a, weights)</div>
<div class="line"><span class="lineno">  394</span> </div>
<div class="line"><span class="lineno">  395</span> </div>
<div class="line"><span class="lineno">  396</span><span class="preprocessor">@array_function_dispatch(_average_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="accd84e4110f0ef89eace0688b4ec6d9e" name="accd84e4110f0ef89eace0688b4ec6d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd84e4110f0ef89eace0688b4ec6d9e">&#9670;&#160;</a></span>_calculate_shapes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._calculate_shapes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>broadcast_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>list_of_core_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper for calculating broadcast shapes with core dimensions.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2095</span><span class="keyword">def </span>_calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims):</div>
<div class="line"><span class="lineno"> 2096</span>    <span class="stringliteral">&quot;&quot;&quot;Helper for calculating broadcast shapes with core dimensions.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2097</span>    <span class="keywordflow">return</span> [broadcast_shape + tuple(dim_sizes[dim] <span class="keywordflow">for</span> dim <span class="keywordflow">in</span> core_dims)</div>
<div class="line"><span class="lineno"> 2098</span>            <span class="keywordflow">for</span> core_dims <span class="keywordflow">in</span> list_of_core_dims]</div>
<div class="line"><span class="lineno"> 2099</span> </div>
<div class="line"><span class="lineno"> 2100</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5223ef0995959b8e90373a8c0535b541" name="a5223ef0995959b8e90373a8c0535b541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5223ef0995959b8e90373a8c0535b541">&#9670;&#160;</a></span>_chbevl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._chbevl </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3343</span><span class="keyword">def </span>_chbevl(x, vals):</div>
<div class="line"><span class="lineno"> 3344</span>    b0 = vals[0]</div>
<div class="line"><span class="lineno"> 3345</span>    b1 = 0.0</div>
<div class="line"><span class="lineno"> 3346</span> </div>
<div class="line"><span class="lineno"> 3347</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, len(vals)):</div>
<div class="line"><span class="lineno"> 3348</span>        b2 = b1</div>
<div class="line"><span class="lineno"> 3349</span>        b1 = b0</div>
<div class="line"><span class="lineno"> 3350</span>        b0 = x*b1 - b2 + vals[i]</div>
<div class="line"><span class="lineno"> 3351</span> </div>
<div class="line"><span class="lineno"> 3352</span>    <span class="keywordflow">return</span> 0.5*(b0 - b2)</div>
<div class="line"><span class="lineno"> 3353</span> </div>
<div class="line"><span class="lineno"> 3354</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a078381834838b66c27a96ec6d798cbaf" name="a078381834838b66c27a96ec6d798cbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078381834838b66c27a96ec6d798cbaf">&#9670;&#160;</a></span>_check_interpolation_as_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._check_interpolation_as_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4495</span><span class="keyword">def </span>_check_interpolation_as_method(method, interpolation, fname):</div>
<div class="line"><span class="lineno"> 4496</span>    <span class="comment"># Deprecated NumPy 1.22, 2021-11-08</span></div>
<div class="line"><span class="lineno"> 4497</span>    warnings.warn(</div>
<div class="line"><span class="lineno"> 4498</span>        f<span class="stringliteral">&quot;the `interpolation=` argument to {fname} was renamed to &quot;</span></div>
<div class="line"><span class="lineno"> 4499</span>        <span class="stringliteral">&quot;`method=`, which has additional options.\n&quot;</span></div>
<div class="line"><span class="lineno"> 4500</span>        <span class="stringliteral">&quot;Users of the modes &#39;nearest&#39;, &#39;lower&#39;, &#39;higher&#39;, or &quot;</span></div>
<div class="line"><span class="lineno"> 4501</span>        <span class="stringliteral">&quot;&#39;midpoint&#39; are encouraged to review the method they used. &quot;</span></div>
<div class="line"><span class="lineno"> 4502</span>        <span class="stringliteral">&quot;(Deprecated NumPy 1.22)&quot;</span>,</div>
<div class="line"><span class="lineno"> 4503</span>        DeprecationWarning, stacklevel=4)</div>
<div class="line"><span class="lineno"> 4504</span>    <span class="keywordflow">if</span> method != <span class="stringliteral">&quot;linear&quot;</span>:</div>
<div class="line"><span class="lineno"> 4505</span>        <span class="comment"># sanity check, we assume this basically never happens</span></div>
<div class="line"><span class="lineno"> 4506</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 4507</span>            <span class="stringliteral">&quot;You shall not pass both `method` and `interpolation`!\n&quot;</span></div>
<div class="line"><span class="lineno"> 4508</span>            <span class="stringliteral">&quot;(`interpolation` is Deprecated in favor of `method`)&quot;</span>)</div>
<div class="line"><span class="lineno"> 4509</span>    <span class="keywordflow">return</span> interpolation</div>
<div class="line"><span class="lineno"> 4510</span> </div>
<div class="line"><span class="lineno"> 4511</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a30f111ae2e860dff2f018169b638fdd6" name="a30f111ae2e860dff2f018169b638fdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f111ae2e860dff2f018169b638fdd6">&#9670;&#160;</a></span>_closest_observation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._closest_observation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>quantiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4602</span><span class="keyword">def </span>_closest_observation(n, quantiles):</div>
<div class="line"><span class="lineno"> 4603</span>    gamma_fun = <span class="keyword">lambda</span> gamma, index: (gamma == 0) &amp; (np.floor(index) % 2 == 0)</div>
<div class="line"><span class="lineno"> 4604</span>    <span class="keywordflow">return</span> _discret_interpolation_to_boundaries((n * quantiles) - 1 - 0.5,</div>
<div class="line"><span class="lineno"> 4605</span>                                                gamma_fun)</div>
<div class="line"><span class="lineno"> 4606</span> </div>
<div class="line"><span class="lineno"> 4607</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4872dd9e8f7cad54bca94832b667b68" name="ab4872dd9e8f7cad54bca94832b667b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4872dd9e8f7cad54bca94832b667b68">&#9670;&#160;</a></span>_compute_virtual_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._compute_virtual_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>quantiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the floating point indexes of an array for the linear
interpolation of quantiles.
n : array_like
    The sample sizes.
quantiles : array_like
    The quantiles values.
alpha : float
    A constant used to correct the index computed.
beta : float
    A constant used to correct the index computed.

alpha and beta values depend on the chosen method
(see quantile documentation)

Reference:
Hyndman&amp;Fan paper "Sample Quantiles in Statistical Packages",
DOI: 10.1080/00031305.1996.10473566
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4512</span><span class="keyword">def </span>_compute_virtual_index(n, quantiles, alpha: float, beta: float):</div>
<div class="line"><span class="lineno"> 4513</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4514</span><span class="stringliteral">    Compute the floating point indexes of an array for the linear</span></div>
<div class="line"><span class="lineno"> 4515</span><span class="stringliteral">    interpolation of quantiles.</span></div>
<div class="line"><span class="lineno"> 4516</span><span class="stringliteral">    n : array_like</span></div>
<div class="line"><span class="lineno"> 4517</span><span class="stringliteral">        The sample sizes.</span></div>
<div class="line"><span class="lineno"> 4518</span><span class="stringliteral">    quantiles : array_like</span></div>
<div class="line"><span class="lineno"> 4519</span><span class="stringliteral">        The quantiles values.</span></div>
<div class="line"><span class="lineno"> 4520</span><span class="stringliteral">    alpha : float</span></div>
<div class="line"><span class="lineno"> 4521</span><span class="stringliteral">        A constant used to correct the index computed.</span></div>
<div class="line"><span class="lineno"> 4522</span><span class="stringliteral">    beta : float</span></div>
<div class="line"><span class="lineno"> 4523</span><span class="stringliteral">        A constant used to correct the index computed.</span></div>
<div class="line"><span class="lineno"> 4524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4525</span><span class="stringliteral">    alpha and beta values depend on the chosen method</span></div>
<div class="line"><span class="lineno"> 4526</span><span class="stringliteral">    (see quantile documentation)</span></div>
<div class="line"><span class="lineno"> 4527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4528</span><span class="stringliteral">    Reference:</span></div>
<div class="line"><span class="lineno"> 4529</span><span class="stringliteral">    Hyndman&amp;Fan paper &quot;Sample Quantiles in Statistical Packages&quot;,</span></div>
<div class="line"><span class="lineno"> 4530</span><span class="stringliteral">    DOI: 10.1080/00031305.1996.10473566</span></div>
<div class="line"><span class="lineno"> 4531</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4532</span>    <span class="keywordflow">return</span> n * quantiles + (</div>
<div class="line"><span class="lineno"> 4533</span>            alpha + quantiles * (1 - alpha - beta)</div>
<div class="line"><span class="lineno"> 4534</span>    ) - 1</div>
<div class="line"><span class="lineno"> 4535</span> </div>
<div class="line"><span class="lineno"> 4536</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e9ac66acdcd7af7d6526bc5e3def29e" name="a5e9ac66acdcd7af7d6526bc5e3def29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9ac66acdcd7af7d6526bc5e3def29e">&#9670;&#160;</a></span>_copy_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._copy_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  867</span><span class="keyword">def </span>_copy_dispatcher(a, order=None, subok=None):</div>
<div class="line"><span class="lineno">  868</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno">  869</span> </div>
<div class="line"><span class="lineno">  870</span> </div>
<div class="line"><span class="lineno">  871</span><span class="preprocessor">@array_function_dispatch(_copy_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ce71332a846dc341e3e16c575142e97" name="a3ce71332a846dc341e3e16c575142e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce71332a846dc341e3e16c575142e97">&#9670;&#160;</a></span>_corrcoef_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._corrcoef_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rowvar</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2710</span>                         dtype=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2711</span>    <span class="keywordflow">return</span> (x, y)</div>
<div class="line"><span class="lineno"> 2712</span> </div>
<div class="line"><span class="lineno"> 2713</span> </div>
<div class="line"><span class="lineno"> 2714</span><span class="preprocessor">@array_function_dispatch(_corrcoef_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af05da1ab168dad81bf5128b5e965973c" name="af05da1ab168dad81bf5128b5e965973c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05da1ab168dad81bf5128b5e965973c">&#9670;&#160;</a></span>_cov_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._cov_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rowvar</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bias</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fweights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aweights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2483</span>                    fweights=<span class="keywordtype">None</span>, aweights=<span class="keywordtype">None</span>, *, dtype=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2484</span>    <span class="keywordflow">return</span> (m, y, fweights, aweights)</div>
<div class="line"><span class="lineno"> 2485</span> </div>
<div class="line"><span class="lineno"> 2486</span> </div>
<div class="line"><span class="lineno"> 2487</span><span class="preprocessor">@array_function_dispatch(_cov_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a817fda32f3fd4bb659c8798d0b764339" name="a817fda32f3fd4bb659c8798d0b764339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817fda32f3fd4bb659c8798d0b764339">&#9670;&#160;</a></span>_create_arrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._create_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>broadcast_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>list_of_core_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>results</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper for creating output arrays in vectorize.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2102</span>                   results=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2103</span>    <span class="stringliteral">&quot;&quot;&quot;Helper for creating output arrays in vectorize.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2104</span>    shapes = _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims)</div>
<div class="line"><span class="lineno"> 2105</span>    <span class="keywordflow">if</span> dtypes <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2106</span>        dtypes = [<span class="keywordtype">None</span>] * len(shapes)</div>
<div class="line"><span class="lineno"> 2107</span>    <span class="keywordflow">if</span> results <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2108</span>        arrays = tuple(np.empty(shape=shape, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2109</span>                       <span class="keywordflow">for</span> shape, dtype <span class="keywordflow">in</span> zip(shapes, dtypes))</div>
<div class="line"><span class="lineno"> 2110</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2111</span>        arrays = tuple(np.empty_like(result, shape=shape, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2112</span>                       <span class="keywordflow">for</span> result, shape, dtype</div>
<div class="line"><span class="lineno"> 2113</span>                       <span class="keywordflow">in</span> zip(results, shapes, dtypes))</div>
<div class="line"><span class="lineno"> 2114</span>    <span class="keywordflow">return</span> arrays</div>
<div class="line"><span class="lineno"> 2115</span> </div>
<div class="line"><span class="lineno"> 2116</span> </div>
<div class="line"><span class="lineno"> 2117</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e424db95791f2e98e0c8f8a202b55e6" name="a1e424db95791f2e98e0c8f8a202b55e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e424db95791f2e98e0c8f8a202b55e6">&#9670;&#160;</a></span>_delete_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._delete_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5050</span><span class="keyword">def </span>_delete_dispatcher(arr, obj, axis=None):</div>
<div class="line"><span class="lineno"> 5051</span>    <span class="keywordflow">return</span> (arr, obj)</div>
<div class="line"><span class="lineno"> 5052</span> </div>
<div class="line"><span class="lineno"> 5053</span> </div>
<div class="line"><span class="lineno"> 5054</span><span class="preprocessor">@array_function_dispatch(_delete_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7dd7ee8cd55e5286490297bd24a56e70" name="a7dd7ee8cd55e5286490297bd24a56e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd7ee8cd55e5286490297bd24a56e70">&#9670;&#160;</a></span>_diff_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._diff_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prepend</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>append</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1316</span><span class="keyword">def </span>_diff_dispatcher(a, n=None, axis=None, prepend=None, append=None):</div>
<div class="line"><span class="lineno"> 1317</span>    <span class="keywordflow">return</span> (a, prepend, append)</div>
<div class="line"><span class="lineno"> 1318</span> </div>
<div class="line"><span class="lineno"> 1319</span> </div>
<div class="line"><span class="lineno"> 1320</span><span class="preprocessor">@array_function_dispatch(_diff_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ae65b20eed1e549338d2939691f061c" name="a9ae65b20eed1e549338d2939691f061c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae65b20eed1e549338d2939691f061c">&#9670;&#160;</a></span>_digitize_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._digitize_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5502</span><span class="keyword">def </span>_digitize_dispatcher(x, bins, right=None):</div>
<div class="line"><span class="lineno"> 5503</span>    <span class="keywordflow">return</span> (x, bins)</div>
<div class="line"><span class="lineno"> 5504</span> </div>
<div class="line"><span class="lineno"> 5505</span> </div>
<div class="line"><span class="lineno"> 5506</span><span class="preprocessor">@array_function_dispatch(_digitize_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a837273439cfedef9a15b4dd17c759dbd" name="a837273439cfedef9a15b4dd17c759dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837273439cfedef9a15b4dd17c759dbd">&#9670;&#160;</a></span>_discret_interpolation_to_boundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._discret_interpolation_to_boundaries </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gamma_condition_fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4588</span><span class="keyword">def </span>_discret_interpolation_to_boundaries(index, gamma_condition_fun):</div>
<div class="line"><span class="lineno"> 4589</span>    previous = np.floor(index)</div>
<div class="line"><span class="lineno"> 4590</span>    next = previous + 1</div>
<div class="line"><span class="lineno"> 4591</span>    gamma = index - previous</div>
<div class="line"><span class="lineno"> 4592</span>    res = _get_gamma_mask(shape=index.shape,</div>
<div class="line"><span class="lineno"> 4593</span>                          default_value=next,</div>
<div class="line"><span class="lineno"> 4594</span>                          conditioned_value=previous,</div>
<div class="line"><span class="lineno"> 4595</span>                          where=gamma_condition_fun(gamma, index)</div>
<div class="line"><span class="lineno"> 4596</span>                          ).astype(np.intp)</div>
<div class="line"><span class="lineno"> 4597</span>    <span class="comment"># Some methods can lead to out-of-bound integers, clip them:</span></div>
<div class="line"><span class="lineno"> 4598</span>    res[res &lt; 0] = 0</div>
<div class="line"><span class="lineno"> 4599</span>    <span class="keywordflow">return</span> res</div>
<div class="line"><span class="lineno"> 4600</span> </div>
<div class="line"><span class="lineno"> 4601</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abfcce310d04442337ab72600d2376054" name="abfcce310d04442337ab72600d2376054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcce310d04442337ab72600d2376054">&#9670;&#160;</a></span>_extract_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._extract_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1853</span><span class="keyword">def </span>_extract_dispatcher(condition, arr):</div>
<div class="line"><span class="lineno"> 1854</span>    <span class="keywordflow">return</span> (condition, arr)</div>
<div class="line"><span class="lineno"> 1855</span> </div>
<div class="line"><span class="lineno"> 1856</span> </div>
<div class="line"><span class="lineno"> 1857</span><span class="preprocessor">@array_function_dispatch(_extract_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab07a4474ef9b3aed3b94c9991f0f55f7" name="ab07a4474ef9b3aed3b94c9991f0f55f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07a4474ef9b3aed3b94c9991f0f55f7">&#9670;&#160;</a></span>_flip_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._flip_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  248</span><span class="keyword">def </span>_flip_dispatcher(m, axis=None):</div>
<div class="line"><span class="lineno">  249</span>    <span class="keywordflow">return</span> (m,)</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span><span class="preprocessor">@array_function_dispatch(_flip_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a38535df22bea17a5450c1cbe06705650" name="a38535df22bea17a5450c1cbe06705650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38535df22bea17a5450c1cbe06705650">&#9670;&#160;</a></span>_get_gamma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._get_gamma </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>virtual_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>previous_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute gamma (a.k.a 'm' or 'weight') for the linear interpolation
of quantiles.

virtual_indexes : array_like
    The indexes where the percentile is supposed to be found in the sorted
    sample.
previous_indexes : array_like
    The floor values of virtual_indexes.
interpolation : dict
    The interpolation method chosen, which may have a specific rule
    modifying gamma.

gamma is usually the fractional part of virtual_indexes but can be modified
by the interpolation method.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4537</span><span class="keyword">def </span>_get_gamma(virtual_indexes, previous_indexes, method):</div>
<div class="line"><span class="lineno"> 4538</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4539</span><span class="stringliteral">    Compute gamma (a.k.a &#39;m&#39; or &#39;weight&#39;) for the linear interpolation</span></div>
<div class="line"><span class="lineno"> 4540</span><span class="stringliteral">    of quantiles.</span></div>
<div class="line"><span class="lineno"> 4541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4542</span><span class="stringliteral">    virtual_indexes : array_like</span></div>
<div class="line"><span class="lineno"> 4543</span><span class="stringliteral">        The indexes where the percentile is supposed to be found in the sorted</span></div>
<div class="line"><span class="lineno"> 4544</span><span class="stringliteral">        sample.</span></div>
<div class="line"><span class="lineno"> 4545</span><span class="stringliteral">    previous_indexes : array_like</span></div>
<div class="line"><span class="lineno"> 4546</span><span class="stringliteral">        The floor values of virtual_indexes.</span></div>
<div class="line"><span class="lineno"> 4547</span><span class="stringliteral">    interpolation : dict</span></div>
<div class="line"><span class="lineno"> 4548</span><span class="stringliteral">        The interpolation method chosen, which may have a specific rule</span></div>
<div class="line"><span class="lineno"> 4549</span><span class="stringliteral">        modifying gamma.</span></div>
<div class="line"><span class="lineno"> 4550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4551</span><span class="stringliteral">    gamma is usually the fractional part of virtual_indexes but can be modified</span></div>
<div class="line"><span class="lineno"> 4552</span><span class="stringliteral">    by the interpolation method.</span></div>
<div class="line"><span class="lineno"> 4553</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4554</span>    gamma = np.asanyarray(virtual_indexes - previous_indexes)</div>
<div class="line"><span class="lineno"> 4555</span>    gamma = method[<span class="stringliteral">&quot;fix_gamma&quot;</span>](gamma, virtual_indexes)</div>
<div class="line"><span class="lineno"> 4556</span>    <span class="keywordflow">return</span> np.asanyarray(gamma)</div>
<div class="line"><span class="lineno"> 4557</span> </div>
<div class="line"><span class="lineno"> 4558</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acccb5a05da78ca94a57a1c46c71b2893" name="acccb5a05da78ca94a57a1c46c71b2893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccb5a05da78ca94a57a1c46c71b2893">&#9670;&#160;</a></span>_get_gamma_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._get_gamma_mask </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>conditioned_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4582</span><span class="keyword">def </span>_get_gamma_mask(shape, default_value, conditioned_value, where):</div>
<div class="line"><span class="lineno"> 4583</span>    out = np.full(shape, default_value)</div>
<div class="line"><span class="lineno"> 4584</span>    np.copyto(out, conditioned_value, where=where, casting=<span class="stringliteral">&quot;unsafe&quot;</span>)</div>
<div class="line"><span class="lineno"> 4585</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 4586</span> </div>
<div class="line"><span class="lineno"> 4587</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a73b582efb533df6bedb038ce54e55892" name="a73b582efb533df6bedb038ce54e55892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b582efb533df6bedb038ce54e55892">&#9670;&#160;</a></span>_get_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._get_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>virtual_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_values_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get the valid indexes of arr neighbouring virtual_indexes.
Note
This is a companion function to linear interpolation of
Quantiles

Returns
-------
(previous_indexes, next_indexes): Tuple
    A Tuple of virtual_indexes neighbouring indexes
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4647</span><span class="keyword">def </span>_get_indexes(arr, virtual_indexes, valid_values_count):</div>
<div class="line"><span class="lineno"> 4648</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4649</span><span class="stringliteral">    Get the valid indexes of arr neighbouring virtual_indexes.</span></div>
<div class="line"><span class="lineno"> 4650</span><span class="stringliteral">    Note</span></div>
<div class="line"><span class="lineno"> 4651</span><span class="stringliteral">    This is a companion function to linear interpolation of</span></div>
<div class="line"><span class="lineno"> 4652</span><span class="stringliteral">    Quantiles</span></div>
<div class="line"><span class="lineno"> 4653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4654</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4655</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4656</span><span class="stringliteral">    (previous_indexes, next_indexes): Tuple</span></div>
<div class="line"><span class="lineno"> 4657</span><span class="stringliteral">        A Tuple of virtual_indexes neighbouring indexes</span></div>
<div class="line"><span class="lineno"> 4658</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4659</span>    previous_indexes = np.asanyarray(np.floor(virtual_indexes))</div>
<div class="line"><span class="lineno"> 4660</span>    next_indexes = np.asanyarray(previous_indexes + 1)</div>
<div class="line"><span class="lineno"> 4661</span>    indexes_above_bounds = virtual_indexes &gt;= valid_values_count - 1</div>
<div class="line"><span class="lineno"> 4662</span>    <span class="comment"># When indexes is above max index, take the max value of the array</span></div>
<div class="line"><span class="lineno"> 4663</span>    <span class="keywordflow">if</span> indexes_above_bounds.any():</div>
<div class="line"><span class="lineno"> 4664</span>        previous_indexes[indexes_above_bounds] = -1</div>
<div class="line"><span class="lineno"> 4665</span>        next_indexes[indexes_above_bounds] = -1</div>
<div class="line"><span class="lineno"> 4666</span>    <span class="comment"># When indexes is below min index, take the min value of the array</span></div>
<div class="line"><span class="lineno"> 4667</span>    indexes_below_bounds = virtual_indexes &lt; 0</div>
<div class="line"><span class="lineno"> 4668</span>    <span class="keywordflow">if</span> indexes_below_bounds.any():</div>
<div class="line"><span class="lineno"> 4669</span>        previous_indexes[indexes_below_bounds] = 0</div>
<div class="line"><span class="lineno"> 4670</span>        next_indexes[indexes_below_bounds] = 0</div>
<div class="line"><span class="lineno"> 4671</span>    <span class="keywordflow">if</span> np.issubdtype(arr.dtype, np.inexact):</div>
<div class="line"><span class="lineno"> 4672</span>        <span class="comment"># After the sort, slices having NaNs will have for last element a NaN</span></div>
<div class="line"><span class="lineno"> 4673</span>        virtual_indexes_nans = np.isnan(virtual_indexes)</div>
<div class="line"><span class="lineno"> 4674</span>        <span class="keywordflow">if</span> virtual_indexes_nans.any():</div>
<div class="line"><span class="lineno"> 4675</span>            previous_indexes[virtual_indexes_nans] = -1</div>
<div class="line"><span class="lineno"> 4676</span>            next_indexes[virtual_indexes_nans] = -1</div>
<div class="line"><span class="lineno"> 4677</span>    previous_indexes = previous_indexes.astype(np.intp)</div>
<div class="line"><span class="lineno"> 4678</span>    next_indexes = next_indexes.astype(np.intp)</div>
<div class="line"><span class="lineno"> 4679</span>    <span class="keywordflow">return</span> previous_indexes, next_indexes</div>
<div class="line"><span class="lineno"> 4680</span> </div>
<div class="line"><span class="lineno"> 4681</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af14a18842fd055aa06165c99aeb4811c" name="af14a18842fd055aa06165c99aeb4811c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14a18842fd055aa06165c99aeb4811c">&#9670;&#160;</a></span>_gradient_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._gradient_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>varargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  965</span><span class="keyword">def </span>_gradient_dispatcher(f, *varargs, axis=None, edge_order=None):</div>
<div class="line"><span class="lineno">  966</span>    <span class="keywordflow">yield</span> f</div>
<div class="line"><span class="lineno">  967</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> varargs</div>
<div class="line"><span class="lineno">  968</span> </div>
<div class="line"><span class="lineno">  969</span> </div>
<div class="line"><span class="lineno">  970</span><span class="preprocessor">@array_function_dispatch(_gradient_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a415e4dc396dc474b62ec8f37a101ed98" name="a415e4dc396dc474b62ec8f37a101ed98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415e4dc396dc474b62ec8f37a101ed98">&#9670;&#160;</a></span>_i0_1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._i0_1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3355</span><span class="keyword">def </span>_i0_1(x):</div>
<div class="line"><span class="lineno"> 3356</span>    <span class="keywordflow">return</span> exp(x) * _chbevl(x/2.0-2, _i0A)</div>
<div class="line"><span class="lineno"> 3357</span> </div>
<div class="line"><span class="lineno"> 3358</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a80035258d3cf2d7837975b6760b7caae" name="a80035258d3cf2d7837975b6760b7caae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80035258d3cf2d7837975b6760b7caae">&#9670;&#160;</a></span>_i0_2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._i0_2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3359</span><span class="keyword">def </span>_i0_2(x):</div>
<div class="line"><span class="lineno"> 3360</span>    <span class="keywordflow">return</span> exp(x) * _chbevl(32.0/x - 2.0, _i0B) / sqrt(x)</div>
<div class="line"><span class="lineno"> 3361</span> </div>
<div class="line"><span class="lineno"> 3362</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a680690bfaf9f6a7acc8ac34ca0d0dc5f" name="a680690bfaf9f6a7acc8ac34ca0d0dc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680690bfaf9f6a7acc8ac34ca0d0dc5f">&#9670;&#160;</a></span>_i0_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._i0_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3363</span><span class="keyword">def </span>_i0_dispatcher(x):</div>
<div class="line"><span class="lineno"> 3364</span>    <span class="keywordflow">return</span> (x,)</div>
<div class="line"><span class="lineno"> 3365</span> </div>
<div class="line"><span class="lineno"> 3366</span> </div>
<div class="line"><span class="lineno"> 3367</span><span class="preprocessor">@array_function_dispatch(_i0_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa999aff78932c3fd4272e93e2f485c60" name="aa999aff78932c3fd4272e93e2f485c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa999aff78932c3fd4272e93e2f485c60">&#9670;&#160;</a></span>_insert_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._insert_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5246</span><span class="keyword">def </span>_insert_dispatcher(arr, obj, values, axis=None):</div>
<div class="line"><span class="lineno"> 5247</span>    <span class="keywordflow">return</span> (arr, obj, values)</div>
<div class="line"><span class="lineno"> 5248</span> </div>
<div class="line"><span class="lineno"> 5249</span> </div>
<div class="line"><span class="lineno"> 5250</span><span class="preprocessor">@array_function_dispatch(_insert_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af7e4ecc4b33b992085fab6942d41d08f" name="af7e4ecc4b33b992085fab6942d41d08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e4ecc4b33b992085fab6942d41d08f">&#9670;&#160;</a></span>_interp_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._interp_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>period</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1453</span><span class="keyword">def </span>_interp_dispatcher(x, xp, fp, left=None, right=None, period=None):</div>
<div class="line"><span class="lineno"> 1454</span>    <span class="keywordflow">return</span> (x, xp, fp)</div>
<div class="line"><span class="lineno"> 1455</span> </div>
<div class="line"><span class="lineno"> 1456</span> </div>
<div class="line"><span class="lineno"> 1457</span><span class="preprocessor">@array_function_dispatch(_interp_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af570374bc269eec1dec2cb524aaee2a0" name="af570374bc269eec1dec2cb524aaee2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af570374bc269eec1dec2cb524aaee2a0">&#9670;&#160;</a></span>_inverted_cdf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._inverted_cdf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>quantiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4608</span><span class="keyword">def </span>_inverted_cdf(n, quantiles):</div>
<div class="line"><span class="lineno"> 4609</span>    gamma_fun = <span class="keyword">lambda</span> gamma, _: (gamma == 0)</div>
<div class="line"><span class="lineno"> 4610</span>    <span class="keywordflow">return</span> _discret_interpolation_to_boundaries((n * quantiles) - 1,</div>
<div class="line"><span class="lineno"> 4611</span>                                                gamma_fun)</div>
<div class="line"><span class="lineno"> 4612</span> </div>
<div class="line"><span class="lineno"> 4613</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a86f6bbc21ee745dd0bacb3c0d4cc8d99" name="a86f6bbc21ee745dd0bacb3c0d4cc8d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f6bbc21ee745dd0bacb3c0d4cc8d99">&#9670;&#160;</a></span>_lerp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._lerp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the linear interpolation weighted by gamma on each point of
two same shape array.

a : array_like
    Left bound.
b : array_like
    Right bound.
t : array_like
    The interpolation weight.
out : array_like
    Output array.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4559</span><span class="keyword">def </span>_lerp(a, b, t, out=None):</div>
<div class="line"><span class="lineno"> 4560</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4561</span><span class="stringliteral">    Compute the linear interpolation weighted by gamma on each point of</span></div>
<div class="line"><span class="lineno"> 4562</span><span class="stringliteral">    two same shape array.</span></div>
<div class="line"><span class="lineno"> 4563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4564</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 4565</span><span class="stringliteral">        Left bound.</span></div>
<div class="line"><span class="lineno"> 4566</span><span class="stringliteral">    b : array_like</span></div>
<div class="line"><span class="lineno"> 4567</span><span class="stringliteral">        Right bound.</span></div>
<div class="line"><span class="lineno"> 4568</span><span class="stringliteral">    t : array_like</span></div>
<div class="line"><span class="lineno"> 4569</span><span class="stringliteral">        The interpolation weight.</span></div>
<div class="line"><span class="lineno"> 4570</span><span class="stringliteral">    out : array_like</span></div>
<div class="line"><span class="lineno"> 4571</span><span class="stringliteral">        Output array.</span></div>
<div class="line"><span class="lineno"> 4572</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4573</span>    diff_b_a = subtract(b, a)</div>
<div class="line"><span class="lineno"> 4574</span>    <span class="comment"># asanyarray is a stop-gap until gh-13105</span></div>
<div class="line"><span class="lineno"> 4575</span>    lerp_interpolation = asanyarray(add(a, diff_b_a * t, out=out))</div>
<div class="line"><span class="lineno"> 4576</span>    subtract(b, diff_b_a * (1 - t), out=lerp_interpolation, where=t &gt;= 0.5)</div>
<div class="line"><span class="lineno"> 4577</span>    <span class="keywordflow">if</span> lerp_interpolation.ndim == 0 <span class="keywordflow">and</span> out <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4578</span>        lerp_interpolation = lerp_interpolation[()]  <span class="comment"># unpack 0d arrays</span></div>
<div class="line"><span class="lineno"> 4579</span>    <span class="keywordflow">return</span> lerp_interpolation</div>
<div class="line"><span class="lineno"> 4580</span> </div>
<div class="line"><span class="lineno"> 4581</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac13a3070ca6d89e5a7b77afbc6b93b5b" name="ac13a3070ca6d89e5a7b77afbc6b93b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13a3070ca6d89e5a7b77afbc6b93b5b">&#9670;&#160;</a></span>_median()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._median </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3860</span><span class="keyword">def </span>_median(a, axis=None, out=None, overwrite_input=False):</div>
<div class="line"><span class="lineno"> 3861</span>    <span class="comment"># can&#39;t be reasonably be implemented in terms of percentile as we have to</span></div>
<div class="line"><span class="lineno"> 3862</span>    <span class="comment"># call mean to not break astropy</span></div>
<div class="line"><span class="lineno"> 3863</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 3864</span> </div>
<div class="line"><span class="lineno"> 3865</span>    <span class="comment"># Set the partition indexes</span></div>
<div class="line"><span class="lineno"> 3866</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3867</span>        sz = a.size</div>
<div class="line"><span class="lineno"> 3868</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3869</span>        sz = a.shape[axis]</div>
<div class="line"><span class="lineno"> 3870</span>    <span class="keywordflow">if</span> sz % 2 == 0:</div>
<div class="line"><span class="lineno"> 3871</span>        szh = sz // 2</div>
<div class="line"><span class="lineno"> 3872</span>        kth = [szh - 1, szh]</div>
<div class="line"><span class="lineno"> 3873</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3874</span>        kth = [(sz - 1) // 2]</div>
<div class="line"><span class="lineno"> 3875</span>    <span class="comment"># Check if the array contains any nan&#39;s</span></div>
<div class="line"><span class="lineno"> 3876</span>    <span class="keywordflow">if</span> np.issubdtype(a.dtype, np.inexact):</div>
<div class="line"><span class="lineno"> 3877</span>        kth.append(-1)</div>
<div class="line"><span class="lineno"> 3878</span> </div>
<div class="line"><span class="lineno"> 3879</span>    <span class="keywordflow">if</span> overwrite_input:</div>
<div class="line"><span class="lineno"> 3880</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3881</span>            part = a.ravel()</div>
<div class="line"><span class="lineno"> 3882</span>            part.partition(kth)</div>
<div class="line"><span class="lineno"> 3883</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3884</span>            a.partition(kth, axis=axis)</div>
<div class="line"><span class="lineno"> 3885</span>            part = a</div>
<div class="line"><span class="lineno"> 3886</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3887</span>        part = partition(a, kth, axis=axis)</div>
<div class="line"><span class="lineno"> 3888</span> </div>
<div class="line"><span class="lineno"> 3889</span>    <span class="keywordflow">if</span> part.shape == ():</div>
<div class="line"><span class="lineno"> 3890</span>        <span class="comment"># make 0-D arrays work</span></div>
<div class="line"><span class="lineno"> 3891</span>        <span class="keywordflow">return</span> part.item()</div>
<div class="line"><span class="lineno"> 3892</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3893</span>        axis = 0</div>
<div class="line"><span class="lineno"> 3894</span> </div>
<div class="line"><span class="lineno"> 3895</span>    indexer = [slice(<span class="keywordtype">None</span>)] * part.ndim</div>
<div class="line"><span class="lineno"> 3896</span>    index = part.shape[axis] // 2</div>
<div class="line"><span class="lineno"> 3897</span>    <span class="keywordflow">if</span> part.shape[axis] % 2 == 1:</div>
<div class="line"><span class="lineno"> 3898</span>        <span class="comment"># index with slice to allow mean (below) to work</span></div>
<div class="line"><span class="lineno"> 3899</span>        indexer[axis] = slice(index, index+1)</div>
<div class="line"><span class="lineno"> 3900</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3901</span>        indexer[axis] = slice(index-1, index+1)</div>
<div class="line"><span class="lineno"> 3902</span>    indexer = tuple(indexer)</div>
<div class="line"><span class="lineno"> 3903</span> </div>
<div class="line"><span class="lineno"> 3904</span>    <span class="comment"># Use mean in both odd and even case to coerce data type,</span></div>
<div class="line"><span class="lineno"> 3905</span>    <span class="comment"># using out array if needed.</span></div>
<div class="line"><span class="lineno"> 3906</span>    rout = mean(part[indexer], axis=axis, out=out)</div>
<div class="line"><span class="lineno"> 3907</span>    <span class="comment"># Check if the array contains any nan&#39;s</span></div>
<div class="line"><span class="lineno"> 3908</span>    <span class="keywordflow">if</span> np.issubdtype(a.dtype, np.inexact) <span class="keywordflow">and</span> sz &gt; 0:</div>
<div class="line"><span class="lineno"> 3909</span>        <span class="comment"># If nans are possible, warn and replace by nans like mean would.</span></div>
<div class="line"><span class="lineno"> 3910</span>        rout = np.lib.utils._median_nancheck(part, rout, axis)</div>
<div class="line"><span class="lineno"> 3911</span> </div>
<div class="line"><span class="lineno"> 3912</span>    <span class="keywordflow">return</span> rout</div>
<div class="line"><span class="lineno"> 3913</span> </div>
<div class="line"><span class="lineno"> 3914</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac35a05205b994efe996d7488299c6a71" name="ac35a05205b994efe996d7488299c6a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35a05205b994efe996d7488299c6a71">&#9670;&#160;</a></span>_median_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._median_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3770</span>        a, axis=<span class="keywordtype">None</span>, out=<span class="keywordtype">None</span>, overwrite_input=<span class="keywordtype">None</span>, keepdims=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3771</span>    <span class="keywordflow">return</span> (a, out)</div>
<div class="line"><span class="lineno"> 3772</span> </div>
<div class="line"><span class="lineno"> 3773</span> </div>
<div class="line"><span class="lineno"> 3774</span><span class="preprocessor">@array_function_dispatch(_median_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a03fdae5868cf1a1d0605583ce647ebac" name="a03fdae5868cf1a1d0605583ce647ebac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fdae5868cf1a1d0605583ce647ebac">&#9670;&#160;</a></span>_meshgrid_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._meshgrid_dispatcher </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexing</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4887</span><span class="keyword">def </span>_meshgrid_dispatcher(*xi, copy=None, sparse=None, indexing=None):</div>
<div class="line"><span class="lineno"> 4888</span>    <span class="keywordflow">return</span> xi</div>
<div class="line"><span class="lineno"> 4889</span> </div>
<div class="line"><span class="lineno"> 4890</span> </div>
<div class="line"><span class="lineno"> 4891</span><span class="comment"># Based on scitools meshgrid</span></div>
<div class="line"><span class="lineno"> 4892</span><span class="preprocessor">@array_function_dispatch(_meshgrid_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a697831795d3e31b4fec41f491f42d566" name="a697831795d3e31b4fec41f491f42d566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697831795d3e31b4fec41f491f42d566">&#9670;&#160;</a></span>_msort_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._msort_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3642</span><span class="keyword">def </span>_msort_dispatcher(a):</div>
<div class="line"><span class="lineno"> 3643</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 3644</span> </div>
<div class="line"><span class="lineno"> 3645</span> </div>
<div class="line"><span class="lineno"> 3646</span><span class="preprocessor">@array_function_dispatch(_msort_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8fd4d999d6b5a10b0393280c42c6af87" name="a8fd4d999d6b5a10b0393280c42c6af87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd4d999d6b5a10b0393280c42c6af87">&#9670;&#160;</a></span>_parse_gufunc_signature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._parse_gufunc_signature </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>signature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parse string signatures for a generalized universal function.

Arguments
---------
signature : string
    Generalized universal function signature, e.g., ``(m,n),(n,p)-&gt;(m,p)``
    for ``np.matmul``.

Returns
-------
Tuple of input and output core dimensions parsed from the signature, each
of the form List[Tuple[str, ...]].
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2007</span><span class="keyword">def </span>_parse_gufunc_signature(signature):</div>
<div class="line"><span class="lineno"> 2008</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">    Parse string signatures for a generalized universal function.</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral">    Arguments</span></div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral">    ---------</span></div>
<div class="line"><span class="lineno"> 2013</span><span class="stringliteral">    signature : string</span></div>
<div class="line"><span class="lineno"> 2014</span><span class="stringliteral">        Generalized universal function signature, e.g., ``(m,n),(n,p)-&gt;(m,p)``</span></div>
<div class="line"><span class="lineno"> 2015</span><span class="stringliteral">        for ``np.matmul``.</span></div>
<div class="line"><span class="lineno"> 2016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2017</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2018</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2019</span><span class="stringliteral">    Tuple of input and output core dimensions parsed from the signature, each</span></div>
<div class="line"><span class="lineno"> 2020</span><span class="stringliteral">    of the form List[Tuple[str, ...]].</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2022</span>    signature = re.sub(<span class="stringliteral">r&#39;\s+&#39;</span>, <span class="stringliteral">&#39;&#39;</span>, signature)</div>
<div class="line"><span class="lineno"> 2023</span> </div>
<div class="line"><span class="lineno"> 2024</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> re.match(_SIGNATURE, signature):</div>
<div class="line"><span class="lineno"> 2025</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2026</span>            <span class="stringliteral">&#39;not a valid gufunc signature: {}&#39;</span>.format(signature))</div>
<div class="line"><span class="lineno"> 2027</span>    <span class="keywordflow">return</span> tuple([tuple(re.findall(_DIMENSION_NAME, arg))</div>
<div class="line"><span class="lineno"> 2028</span>                  <span class="keywordflow">for</span> arg <span class="keywordflow">in</span> re.findall(_ARGUMENT, arg_list)]</div>
<div class="line"><span class="lineno"> 2029</span>                 <span class="keywordflow">for</span> arg_list <span class="keywordflow">in</span> signature.split(<span class="stringliteral">&#39;-&gt;&#39;</span>))</div>
<div class="line"><span class="lineno"> 2030</span> </div>
<div class="line"><span class="lineno"> 2031</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2dcca8942511a26a4466c9792dac08e3" name="a2dcca8942511a26a4466c9792dac08e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcca8942511a26a4466c9792dac08e3">&#9670;&#160;</a></span>_parse_input_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._parse_input_dimensions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_core_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parse broadcast and core dimensions for vectorize with a signature.

Arguments
---------
args : Tuple[ndarray, ...]
    Tuple of input arguments to examine.
input_core_dims : List[Tuple[str, ...]]
    List of core dimensions corresponding to each input.

Returns
-------
broadcast_shape : Tuple[int, ...]
    Common shape to broadcast all non-core dimensions to.
dim_sizes : Dict[str, int]
    Common sizes for named core dimensions.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2066</span><span class="keyword">def </span>_parse_input_dimensions(args, input_core_dims):</div>
<div class="line"><span class="lineno"> 2067</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2068</span><span class="stringliteral">    Parse broadcast and core dimensions for vectorize with a signature.</span></div>
<div class="line"><span class="lineno"> 2069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2070</span><span class="stringliteral">    Arguments</span></div>
<div class="line"><span class="lineno"> 2071</span><span class="stringliteral">    ---------</span></div>
<div class="line"><span class="lineno"> 2072</span><span class="stringliteral">    args : Tuple[ndarray, ...]</span></div>
<div class="line"><span class="lineno"> 2073</span><span class="stringliteral">        Tuple of input arguments to examine.</span></div>
<div class="line"><span class="lineno"> 2074</span><span class="stringliteral">    input_core_dims : List[Tuple[str, ...]]</span></div>
<div class="line"><span class="lineno"> 2075</span><span class="stringliteral">        List of core dimensions corresponding to each input.</span></div>
<div class="line"><span class="lineno"> 2076</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2077</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2078</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2079</span><span class="stringliteral">    broadcast_shape : Tuple[int, ...]</span></div>
<div class="line"><span class="lineno"> 2080</span><span class="stringliteral">        Common shape to broadcast all non-core dimensions to.</span></div>
<div class="line"><span class="lineno"> 2081</span><span class="stringliteral">    dim_sizes : Dict[str, int]</span></div>
<div class="line"><span class="lineno"> 2082</span><span class="stringliteral">        Common sizes for named core dimensions.</span></div>
<div class="line"><span class="lineno"> 2083</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2084</span>    broadcast_args = []</div>
<div class="line"><span class="lineno"> 2085</span>    dim_sizes = {}</div>
<div class="line"><span class="lineno"> 2086</span>    <span class="keywordflow">for</span> arg, core_dims <span class="keywordflow">in</span> zip(args, input_core_dims):</div>
<div class="line"><span class="lineno"> 2087</span>        _update_dim_sizes(dim_sizes, arg, core_dims)</div>
<div class="line"><span class="lineno"> 2088</span>        ndim = arg.ndim - len(core_dims)</div>
<div class="line"><span class="lineno"> 2089</span>        dummy_array = np.lib.stride_tricks.as_strided(0, arg.shape[:ndim])</div>
<div class="line"><span class="lineno"> 2090</span>        broadcast_args.append(dummy_array)</div>
<div class="line"><span class="lineno"> 2091</span>    broadcast_shape = np.lib.stride_tricks._broadcast_shape(*broadcast_args)</div>
<div class="line"><span class="lineno"> 2092</span>    <span class="keywordflow">return</span> broadcast_shape, dim_sizes</div>
<div class="line"><span class="lineno"> 2093</span> </div>
<div class="line"><span class="lineno"> 2094</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ade9f45ed23cdbeb84447214b29b4f200" name="ade9f45ed23cdbeb84447214b29b4f200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9f45ed23cdbeb84447214b29b4f200">&#9670;&#160;</a></span>_percentile_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._percentile_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3916</span>                           method=<span class="keywordtype">None</span>, keepdims=<span class="keywordtype">None</span>, *, interpolation=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3917</span>    <span class="keywordflow">return</span> (a, q, out)</div>
<div class="line"><span class="lineno"> 3918</span> </div>
<div class="line"><span class="lineno"> 3919</span> </div>
<div class="line"><span class="lineno"> 3920</span><span class="preprocessor">@array_function_dispatch(_percentile_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aceacb7828da5503ff904677f933fbb6b" name="aceacb7828da5503ff904677f933fbb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceacb7828da5503ff904677f933fbb6b">&#9670;&#160;</a></span>_piecewise_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._piecewise_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>funclist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  633</span><span class="keyword">def </span>_piecewise_dispatcher(x, condlist, funclist, *args, **kw):</div>
<div class="line"><span class="lineno">  634</span>    <span class="keywordflow">yield</span> x</div>
<div class="line"><span class="lineno">  635</span>    <span class="comment"># support the undocumented behavior of allowing scalars</span></div>
<div class="line"><span class="lineno">  636</span>    <span class="keywordflow">if</span> np.iterable(condlist):</div>
<div class="line"><span class="lineno">  637</span>        <span class="keywordflow">yield</span> <span class="keyword">from</span> condlist</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span> </div>
<div class="line"><span class="lineno">  640</span><span class="preprocessor">@array_function_dispatch(_piecewise_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af7b9453c54c6da5ab749ecfeda5aefdb" name="af7b9453c54c6da5ab749ecfeda5aefdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b9453c54c6da5ab749ecfeda5aefdb">&#9670;&#160;</a></span>_place_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._place_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1909</span><span class="keyword">def </span>_place_dispatcher(arr, mask, vals):</div>
<div class="line"><span class="lineno"> 1910</span>    <span class="keywordflow">return</span> (arr, mask, vals)</div>
<div class="line"><span class="lineno"> 1911</span> </div>
<div class="line"><span class="lineno"> 1912</span> </div>
<div class="line"><span class="lineno"> 1913</span><span class="preprocessor">@array_function_dispatch(_place_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a786f8aa690fe7768451c43830db49011" name="a786f8aa690fe7768451c43830db49011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786f8aa690fe7768451c43830db49011">&#9670;&#160;</a></span>_quantile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._quantile </td>
          <td>(</td>
          <td class="paramtype">np.array&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.array&#160;</td>
          <td class="paramname"><em>quantiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function that doesn't support extended axis or keepdims.
These methods are extended to this function using _ureduce
See nanpercentile for parameter usage
It computes the quantiles of the array for the given axis.
A linear interpolation is performed based on the `interpolation`.

By default, the method is "linear" where alpha == beta == 1 which
performs the 7th method of Hyndman&amp;Fan.
With "median_unbiased" we get alpha == beta == 1/3
thus the 8th method of Hyndman&amp;Fan.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4688</span>):</div>
<div class="line"><span class="lineno"> 4689</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4690</span><span class="stringliteral">    Private function that doesn&#39;t support extended axis or keepdims.</span></div>
<div class="line"><span class="lineno"> 4691</span><span class="stringliteral">    These methods are extended to this function using _ureduce</span></div>
<div class="line"><span class="lineno"> 4692</span><span class="stringliteral">    See nanpercentile for parameter usage</span></div>
<div class="line"><span class="lineno"> 4693</span><span class="stringliteral">    It computes the quantiles of the array for the given axis.</span></div>
<div class="line"><span class="lineno"> 4694</span><span class="stringliteral">    A linear interpolation is performed based on the `interpolation`.</span></div>
<div class="line"><span class="lineno"> 4695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4696</span><span class="stringliteral">    By default, the method is &quot;linear&quot; where alpha == beta == 1 which</span></div>
<div class="line"><span class="lineno"> 4697</span><span class="stringliteral">    performs the 7th method of Hyndman&amp;Fan.</span></div>
<div class="line"><span class="lineno"> 4698</span><span class="stringliteral">    With &quot;median_unbiased&quot; we get alpha == beta == 1/3</span></div>
<div class="line"><span class="lineno"> 4699</span><span class="stringliteral">    thus the 8th method of Hyndman&amp;Fan.</span></div>
<div class="line"><span class="lineno"> 4700</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4701</span>    <span class="comment"># --- Setup</span></div>
<div class="line"><span class="lineno"> 4702</span>    arr = np.asanyarray(arr)</div>
<div class="line"><span class="lineno"> 4703</span>    values_count = arr.shape[axis]</div>
<div class="line"><span class="lineno"> 4704</span>    <span class="comment"># The dimensions of `q` are prepended to the output shape, so we need the</span></div>
<div class="line"><span class="lineno"> 4705</span>    <span class="comment"># axis being sampled from `arr` to be last.</span></div>
<div class="line"><span class="lineno"> 4706</span>    DATA_AXIS = 0</div>
<div class="line"><span class="lineno"> 4707</span>    <span class="keywordflow">if</span> axis != DATA_AXIS:  <span class="comment"># But moveaxis is slow, so only call it if axis!=0.</span></div>
<div class="line"><span class="lineno"> 4708</span>        arr = np.moveaxis(arr, axis, destination=DATA_AXIS)</div>
<div class="line"><span class="lineno"> 4709</span>    <span class="comment"># --- Computation of indexes</span></div>
<div class="line"><span class="lineno"> 4710</span>    <span class="comment"># Index where to find the value in the sorted array.</span></div>
<div class="line"><span class="lineno"> 4711</span>    <span class="comment"># Virtual because it is a floating point value, not an valid index.</span></div>
<div class="line"><span class="lineno"> 4712</span>    <span class="comment"># The nearest neighbours are used for interpolation</span></div>
<div class="line"><span class="lineno"> 4713</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 4714</span>        method = _QuantileMethods[method]</div>
<div class="line"><span class="lineno"> 4715</span>    <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno"> 4716</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 4717</span>            f<span class="stringliteral">&quot;{method!r} is not a valid method. Use one of: &quot;</span></div>
<div class="line"><span class="lineno"> 4718</span>            f<span class="stringliteral">&quot;{_QuantileMethods.keys()}&quot;</span>) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4719</span>    virtual_indexes = method[<span class="stringliteral">&quot;get_virtual_index&quot;</span>](values_count, quantiles)</div>
<div class="line"><span class="lineno"> 4720</span>    virtual_indexes = np.asanyarray(virtual_indexes)</div>
<div class="line"><span class="lineno"> 4721</span>    <span class="keywordflow">if</span> np.issubdtype(virtual_indexes.dtype, np.integer):</div>
<div class="line"><span class="lineno"> 4722</span>        <span class="comment"># No interpolation needed, take the points along axis</span></div>
<div class="line"><span class="lineno"> 4723</span>        <span class="keywordflow">if</span> np.issubdtype(arr.dtype, np.inexact):</div>
<div class="line"><span class="lineno"> 4724</span>            <span class="comment"># may contain nan, which would sort to the end</span></div>
<div class="line"><span class="lineno"> 4725</span>            arr.partition(concatenate((virtual_indexes.ravel(), [-1])), axis=0)</div>
<div class="line"><span class="lineno"> 4726</span>            slices_having_nans = np.isnan(arr[-1])</div>
<div class="line"><span class="lineno"> 4727</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4728</span>            <span class="comment"># cannot contain nan</span></div>
<div class="line"><span class="lineno"> 4729</span>            arr.partition(virtual_indexes.ravel(), axis=0)</div>
<div class="line"><span class="lineno"> 4730</span>            slices_having_nans = np.array(<span class="keyword">False</span>, dtype=bool)</div>
<div class="line"><span class="lineno"> 4731</span>        result = take(arr, virtual_indexes, axis=0, out=out)</div>
<div class="line"><span class="lineno"> 4732</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4733</span>        previous_indexes, next_indexes = _get_indexes(arr,</div>
<div class="line"><span class="lineno"> 4734</span>                                                      virtual_indexes,</div>
<div class="line"><span class="lineno"> 4735</span>                                                      values_count)</div>
<div class="line"><span class="lineno"> 4736</span>        <span class="comment"># --- Sorting</span></div>
<div class="line"><span class="lineno"> 4737</span>        arr.partition(</div>
<div class="line"><span class="lineno"> 4738</span>            np.unique(np.concatenate(([0, -1],</div>
<div class="line"><span class="lineno"> 4739</span>                                      previous_indexes.ravel(),</div>
<div class="line"><span class="lineno"> 4740</span>                                      next_indexes.ravel(),</div>
<div class="line"><span class="lineno"> 4741</span>                                      ))),</div>
<div class="line"><span class="lineno"> 4742</span>            axis=DATA_AXIS)</div>
<div class="line"><span class="lineno"> 4743</span>        <span class="keywordflow">if</span> np.issubdtype(arr.dtype, np.inexact):</div>
<div class="line"><span class="lineno"> 4744</span>            slices_having_nans = np.isnan(</div>
<div class="line"><span class="lineno"> 4745</span>                take(arr, indices=-1, axis=DATA_AXIS)</div>
<div class="line"><span class="lineno"> 4746</span>            )</div>
<div class="line"><span class="lineno"> 4747</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4748</span>            slices_having_nans = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4749</span>        <span class="comment"># --- Get values from indexes</span></div>
<div class="line"><span class="lineno"> 4750</span>        previous = np.take(arr, previous_indexes, axis=DATA_AXIS)</div>
<div class="line"><span class="lineno"> 4751</span>        next = np.take(arr, next_indexes, axis=DATA_AXIS)</div>
<div class="line"><span class="lineno"> 4752</span>        <span class="comment"># --- Linear interpolation</span></div>
<div class="line"><span class="lineno"> 4753</span>        gamma = _get_gamma(virtual_indexes, previous_indexes, method)</div>
<div class="line"><span class="lineno"> 4754</span>        result_shape = virtual_indexes.shape + (1,) * (arr.ndim - 1)</div>
<div class="line"><span class="lineno"> 4755</span>        gamma = gamma.reshape(result_shape)</div>
<div class="line"><span class="lineno"> 4756</span>        result = _lerp(previous,</div>
<div class="line"><span class="lineno"> 4757</span>                       next,</div>
<div class="line"><span class="lineno"> 4758</span>                       gamma,</div>
<div class="line"><span class="lineno"> 4759</span>                       out=out)</div>
<div class="line"><span class="lineno"> 4760</span>    <span class="keywordflow">if</span> np.any(slices_having_nans):</div>
<div class="line"><span class="lineno"> 4761</span>        <span class="keywordflow">if</span> result.ndim == 0 <span class="keywordflow">and</span> out <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4762</span>            <span class="comment"># can&#39;t write to a scalar</span></div>
<div class="line"><span class="lineno"> 4763</span>            result = arr.dtype.type(np.nan)</div>
<div class="line"><span class="lineno"> 4764</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4765</span>            result[..., slices_having_nans] = np.nan</div>
<div class="line"><span class="lineno"> 4766</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 4767</span> </div>
<div class="line"><span class="lineno"> 4768</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a736fb6304d6e0742af293b62420de80a" name="a736fb6304d6e0742af293b62420de80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736fb6304d6e0742af293b62420de80a">&#9670;&#160;</a></span>_quantile_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._quantile_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4210</span>                         method=<span class="keywordtype">None</span>, keepdims=<span class="keywordtype">None</span>, *, interpolation=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 4211</span>    <span class="keywordflow">return</span> (a, q, out)</div>
<div class="line"><span class="lineno"> 4212</span> </div>
<div class="line"><span class="lineno"> 4213</span> </div>
<div class="line"><span class="lineno"> 4214</span><span class="preprocessor">@array_function_dispatch(_quantile_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aafd779e8ab92d87504d8fa98658602b0" name="aafd779e8ab92d87504d8fa98658602b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd779e8ab92d87504d8fa98658602b0">&#9670;&#160;</a></span>_quantile_is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._quantile_is_valid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4483</span><span class="keyword">def </span>_quantile_is_valid(q):</div>
<div class="line"><span class="lineno"> 4484</span>    <span class="comment"># avoid expensive reductions, relevant for arrays with &lt; O(1000) elements</span></div>
<div class="line"><span class="lineno"> 4485</span>    <span class="keywordflow">if</span> q.ndim == 1 <span class="keywordflow">and</span> q.size &lt; 10:</div>
<div class="line"><span class="lineno"> 4486</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(q.size):</div>
<div class="line"><span class="lineno"> 4487</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> (0.0 &lt;= q[i] &lt;= 1.0):</div>
<div class="line"><span class="lineno"> 4488</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4489</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4490</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (np.all(0 &lt;= q) <span class="keywordflow">and</span> np.all(q &lt;= 1)):</div>
<div class="line"><span class="lineno"> 4491</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4492</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4493</span> </div>
<div class="line"><span class="lineno"> 4494</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7ee7858a5049c52b0a7591c97e9d2a2" name="ac7ee7858a5049c52b0a7591c97e9d2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ee7858a5049c52b0a7591c97e9d2a2">&#9670;&#160;</a></span>_quantile_unchecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._quantile_unchecked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Assumes that q is in [0, 1], and is an ndarray</pre> <div class="fragment"><div class="line"><span class="lineno"> 4471</span>                        keepdims=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 4472</span>    <span class="stringliteral">&quot;&quot;&quot;Assumes that q is in [0, 1], and is an ndarray&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4473</span>    <span class="keywordflow">return</span> _ureduce(a,</div>
<div class="line"><span class="lineno"> 4474</span>                    func=_quantile_ureduce_func,</div>
<div class="line"><span class="lineno"> 4475</span>                    q=q,</div>
<div class="line"><span class="lineno"> 4476</span>                    keepdims=keepdims,</div>
<div class="line"><span class="lineno"> 4477</span>                    axis=axis,</div>
<div class="line"><span class="lineno"> 4478</span>                    out=out,</div>
<div class="line"><span class="lineno"> 4479</span>                    overwrite_input=overwrite_input,</div>
<div class="line"><span class="lineno"> 4480</span>                    method=method)</div>
<div class="line"><span class="lineno"> 4481</span> </div>
<div class="line"><span class="lineno"> 4482</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afae9d682b7d8f24138adc42f0bb8a2dd" name="afae9d682b7d8f24138adc42f0bb8a2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae9d682b7d8f24138adc42f0bb8a2dd">&#9670;&#160;</a></span>_quantile_ureduce_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.array numpy.lib.function_base._quantile_ureduce_func </td>
          <td>(</td>
          <td class="paramtype">np.array&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.array&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4621</span>) -&gt; np.array:</div>
<div class="line"><span class="lineno"> 4622</span>    <span class="keywordflow">if</span> q.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 4623</span>        <span class="comment"># The code below works fine for nd, but it might not have useful</span></div>
<div class="line"><span class="lineno"> 4624</span>        <span class="comment"># semantics. For now, keep the supported dimensions the same as it was</span></div>
<div class="line"><span class="lineno"> 4625</span>        <span class="comment"># before.</span></div>
<div class="line"><span class="lineno"> 4626</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;q must be a scalar or 1d&quot;</span>)</div>
<div class="line"><span class="lineno"> 4627</span>    <span class="keywordflow">if</span> overwrite_input:</div>
<div class="line"><span class="lineno"> 4628</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4629</span>            axis = 0</div>
<div class="line"><span class="lineno"> 4630</span>            arr = a.ravel()</div>
<div class="line"><span class="lineno"> 4631</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4632</span>            arr = a</div>
<div class="line"><span class="lineno"> 4633</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4634</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4635</span>            axis = 0</div>
<div class="line"><span class="lineno"> 4636</span>            arr = a.flatten()</div>
<div class="line"><span class="lineno"> 4637</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4638</span>            arr = a.copy()</div>
<div class="line"><span class="lineno"> 4639</span>    result = _quantile(arr,</div>
<div class="line"><span class="lineno"> 4640</span>                       quantiles=q,</div>
<div class="line"><span class="lineno"> 4641</span>                       axis=axis,</div>
<div class="line"><span class="lineno"> 4642</span>                       method=method,</div>
<div class="line"><span class="lineno"> 4643</span>                       out=out)</div>
<div class="line"><span class="lineno"> 4644</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 4645</span> </div>
<div class="line"><span class="lineno"> 4646</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6663e9e17400c1da951e9bd9b33dc36b" name="a6663e9e17400c1da951e9bd9b33dc36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6663e9e17400c1da951e9bd9b33dc36b">&#9670;&#160;</a></span>_rot90_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._rot90_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  154</span><span class="keyword">def </span>_rot90_dispatcher(m, k=None, axes=None):</div>
<div class="line"><span class="lineno">  155</span>    <span class="keywordflow">return</span> (m,)</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span> </div>
<div class="line"><span class="lineno">  158</span><span class="preprocessor">@array_function_dispatch(_rot90_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaca57a36f8bb8337a548b07cdeb235ef" name="aaca57a36f8bb8337a548b07cdeb235ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca57a36f8bb8337a548b07cdeb235ef">&#9670;&#160;</a></span>_select_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._select_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>choicelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  761</span><span class="keyword">def </span>_select_dispatcher(condlist, choicelist, default=None):</div>
<div class="line"><span class="lineno">  762</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> condlist</div>
<div class="line"><span class="lineno">  763</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> choicelist</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span> </div>
<div class="line"><span class="lineno">  766</span><span class="preprocessor">@array_function_dispatch(_select_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a187839059f6c15a7083b0cfd2c8370b8" name="a187839059f6c15a7083b0cfd2c8370b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187839059f6c15a7083b0cfd2c8370b8">&#9670;&#160;</a></span>_sinc_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._sinc_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3557</span><span class="keyword">def </span>_sinc_dispatcher(x):</div>
<div class="line"><span class="lineno"> 3558</span>    <span class="keywordflow">return</span> (x,)</div>
<div class="line"><span class="lineno"> 3559</span> </div>
<div class="line"><span class="lineno"> 3560</span> </div>
<div class="line"><span class="lineno"> 3561</span><span class="preprocessor">@array_function_dispatch(_sinc_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ece2e212e3125f1026cf6c4d86e40b9" name="a4ece2e212e3125f1026cf6c4d86e40b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ece2e212e3125f1026cf6c4d86e40b9">&#9670;&#160;</a></span>_sort_complex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._sort_complex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1755</span><span class="keyword">def </span>_sort_complex(a):</div>
<div class="line"><span class="lineno"> 1756</span>    <span class="keywordflow">return</span> (a,)</div>
<div class="line"><span class="lineno"> 1757</span> </div>
<div class="line"><span class="lineno"> 1758</span> </div>
<div class="line"><span class="lineno"> 1759</span><span class="preprocessor">@array_function_dispatch(_sort_complex)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf350a26e5dc3b49c88020b5d05885f7" name="aaf350a26e5dc3b49c88020b5d05885f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf350a26e5dc3b49c88020b5d05885f7">&#9670;&#160;</a></span>_trapz_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._trapz_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4769</span><span class="keyword">def </span>_trapz_dispatcher(y, x=None, dx=None, axis=None):</div>
<div class="line"><span class="lineno"> 4770</span>    <span class="keywordflow">return</span> (y, x)</div>
<div class="line"><span class="lineno"> 4771</span> </div>
<div class="line"><span class="lineno"> 4772</span> </div>
<div class="line"><span class="lineno"> 4773</span><span class="preprocessor">@array_function_dispatch(_trapz_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0c81f1007b64a18be5fb25e2c1d0b2f" name="ae0c81f1007b64a18be5fb25e2c1d0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c81f1007b64a18be5fb25e2c1d0b2f">&#9670;&#160;</a></span>_trim_zeros()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._trim_zeros </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trim</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1796</span><span class="keyword">def </span>_trim_zeros(filt, trim=None):</div>
<div class="line"><span class="lineno"> 1797</span>    <span class="keywordflow">return</span> (filt,)</div>
<div class="line"><span class="lineno"> 1798</span> </div>
<div class="line"><span class="lineno"> 1799</span> </div>
<div class="line"><span class="lineno"> 1800</span><span class="preprocessor">@array_function_dispatch(_trim_zeros)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3fc61f633b580e8b652be7769c69c866" name="a3fc61f633b580e8b652be7769c69c866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc61f633b580e8b652be7769c69c866">&#9670;&#160;</a></span>_unwrap_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._unwrap_dispatcher </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>discont</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>period</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1655</span><span class="keyword">def </span>_unwrap_dispatcher(p, discont=None, axis=None, *, period=None):</div>
<div class="line"><span class="lineno"> 1656</span>    <span class="keywordflow">return</span> (p,)</div>
<div class="line"><span class="lineno"> 1657</span> </div>
<div class="line"><span class="lineno"> 1658</span> </div>
<div class="line"><span class="lineno"> 1659</span><span class="preprocessor">@array_function_dispatch(_unwrap_dispatcher)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a432b28466a45d69935947e5c43eac939" name="a432b28466a45d69935947e5c43eac939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432b28466a45d69935947e5c43eac939">&#9670;&#160;</a></span>_update_dim_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._update_dim_sizes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>core_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Incrementally check and update core dimension sizes for a single argument.

Arguments
---------
dim_sizes : Dict[str, int]
    Sizes of existing core dimensions. Will be updated in-place.
arg : ndarray
    Argument to examine.
core_dims : Tuple[str, ...]
    Core dimensions for this argument.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2032</span><span class="keyword">def </span>_update_dim_sizes(dim_sizes, arg, core_dims):</div>
<div class="line"><span class="lineno"> 2033</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2034</span><span class="stringliteral">    Incrementally check and update core dimension sizes for a single argument.</span></div>
<div class="line"><span class="lineno"> 2035</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2036</span><span class="stringliteral">    Arguments</span></div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral">    ---------</span></div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral">    dim_sizes : Dict[str, int]</span></div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">        Sizes of existing core dimensions. Will be updated in-place.</span></div>
<div class="line"><span class="lineno"> 2040</span><span class="stringliteral">    arg : ndarray</span></div>
<div class="line"><span class="lineno"> 2041</span><span class="stringliteral">        Argument to examine.</span></div>
<div class="line"><span class="lineno"> 2042</span><span class="stringliteral">    core_dims : Tuple[str, ...]</span></div>
<div class="line"><span class="lineno"> 2043</span><span class="stringliteral">        Core dimensions for this argument.</span></div>
<div class="line"><span class="lineno"> 2044</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2045</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> core_dims:</div>
<div class="line"><span class="lineno"> 2046</span>        <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 2047</span> </div>
<div class="line"><span class="lineno"> 2048</span>    num_core_dims = len(core_dims)</div>
<div class="line"><span class="lineno"> 2049</span>    <span class="keywordflow">if</span> arg.ndim &lt; num_core_dims:</div>
<div class="line"><span class="lineno"> 2050</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2051</span>            <span class="stringliteral">&#39;%d-dimensional argument does not have enough &#39;</span></div>
<div class="line"><span class="lineno"> 2052</span>            <span class="stringliteral">&#39;dimensions for all core dimensions %r&#39;</span></div>
<div class="line"><span class="lineno"> 2053</span>            % (arg.ndim, core_dims))</div>
<div class="line"><span class="lineno"> 2054</span> </div>
<div class="line"><span class="lineno"> 2055</span>    core_shape = arg.shape[-num_core_dims:]</div>
<div class="line"><span class="lineno"> 2056</span>    <span class="keywordflow">for</span> dim, size <span class="keywordflow">in</span> zip(core_dims, core_shape):</div>
<div class="line"><span class="lineno"> 2057</span>        <span class="keywordflow">if</span> dim <span class="keywordflow">in</span> dim_sizes:</div>
<div class="line"><span class="lineno"> 2058</span>            <span class="keywordflow">if</span> size != dim_sizes[dim]:</div>
<div class="line"><span class="lineno"> 2059</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2060</span>                    <span class="stringliteral">&#39;inconsistent size for core dimension %r: %r vs %r&#39;</span></div>
<div class="line"><span class="lineno"> 2061</span>                    % (dim, size, dim_sizes[dim]))</div>
<div class="line"><span class="lineno"> 2062</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2063</span>            dim_sizes[dim] = size</div>
<div class="line"><span class="lineno"> 2064</span> </div>
<div class="line"><span class="lineno"> 2065</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9416be2583f39d18e7d839905d4da827" name="a9416be2583f39d18e7d839905d4da827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9416be2583f39d18e7d839905d4da827">&#9670;&#160;</a></span>_ureduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._ureduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Internal Function.
Call `func` with `a` as first argument swapping the axes to use extended
axis on functions that don't support it natively.

Returns result and a.shape with axis dims set to 1.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
func : callable
    Reduction function capable of receiving a single axis argument.
    It is called with `a` as first argument followed by `kwargs`.
kwargs : keyword arguments
    additional keyword arguments to pass to `func`.

Returns
-------
result : tuple
    Result of func(a, **kwargs) and a.shape with axis dims set to 1
    which can be used to reshape the result to the same shape a ufunc with
    keepdims=True would produce.</pre> <div class="fragment"><div class="line"><span class="lineno"> 3692</span><span class="keyword">def </span>_ureduce(a, func, keepdims=False, **kwargs):</div>
<div class="line"><span class="lineno"> 3693</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3694</span><span class="stringliteral">    Internal Function.</span></div>
<div class="line"><span class="lineno"> 3695</span><span class="stringliteral">    Call `func` with `a` as first argument swapping the axes to use extended</span></div>
<div class="line"><span class="lineno"> 3696</span><span class="stringliteral">    axis on functions that don&#39;t support it natively.</span></div>
<div class="line"><span class="lineno"> 3697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3698</span><span class="stringliteral">    Returns result and a.shape with axis dims set to 1.</span></div>
<div class="line"><span class="lineno"> 3699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3700</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3701</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3702</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3703</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 3704</span><span class="stringliteral">    func : callable</span></div>
<div class="line"><span class="lineno"> 3705</span><span class="stringliteral">        Reduction function capable of receiving a single axis argument.</span></div>
<div class="line"><span class="lineno"> 3706</span><span class="stringliteral">        It is called with `a` as first argument followed by `kwargs`.</span></div>
<div class="line"><span class="lineno"> 3707</span><span class="stringliteral">    kwargs : keyword arguments</span></div>
<div class="line"><span class="lineno"> 3708</span><span class="stringliteral">        additional keyword arguments to pass to `func`.</span></div>
<div class="line"><span class="lineno"> 3709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3710</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3711</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3712</span><span class="stringliteral">    result : tuple</span></div>
<div class="line"><span class="lineno"> 3713</span><span class="stringliteral">        Result of func(a, **kwargs) and a.shape with axis dims set to 1</span></div>
<div class="line"><span class="lineno"> 3714</span><span class="stringliteral">        which can be used to reshape the result to the same shape a ufunc with</span></div>
<div class="line"><span class="lineno"> 3715</span><span class="stringliteral">        keepdims=True would produce.</span></div>
<div class="line"><span class="lineno"> 3716</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3717</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3718</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno"> 3719</span>    axis = kwargs.get(<span class="stringliteral">&#39;axis&#39;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 3720</span>    out = kwargs.get(<span class="stringliteral">&#39;out&#39;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 3721</span> </div>
<div class="line"><span class="lineno"> 3722</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 3723</span>        keepdims = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 3724</span> </div>
<div class="line"><span class="lineno"> 3725</span>    nd = a.ndim</div>
<div class="line"><span class="lineno"> 3726</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3727</span>        axis = _nx.normalize_axis_tuple(axis, nd)</div>
<div class="line"><span class="lineno"> 3728</span> </div>
<div class="line"><span class="lineno"> 3729</span>        <span class="keywordflow">if</span> keepdims:</div>
<div class="line"><span class="lineno"> 3730</span>            <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3731</span>                index_out = tuple(</div>
<div class="line"><span class="lineno"> 3732</span>                    0 <span class="keywordflow">if</span> i <span class="keywordflow">in</span> axis <span class="keywordflow">else</span> slice(<span class="keywordtype">None</span>) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(nd))</div>
<div class="line"><span class="lineno"> 3733</span>                kwargs[<span class="stringliteral">&#39;out&#39;</span>] = out[(Ellipsis, ) + index_out]</div>
<div class="line"><span class="lineno"> 3734</span> </div>
<div class="line"><span class="lineno"> 3735</span>        <span class="keywordflow">if</span> len(axis) == 1:</div>
<div class="line"><span class="lineno"> 3736</span>            kwargs[<span class="stringliteral">&#39;axis&#39;</span>] = axis[0]</div>
<div class="line"><span class="lineno"> 3737</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3738</span>            keep = set(range(nd)) - set(axis)</div>
<div class="line"><span class="lineno"> 3739</span>            nkeep = len(keep)</div>
<div class="line"><span class="lineno"> 3740</span>            <span class="comment"># swap axis that should not be reduced to front</span></div>
<div class="line"><span class="lineno"> 3741</span>            <span class="keywordflow">for</span> i, s <span class="keywordflow">in</span> enumerate(sorted(keep)):</div>
<div class="line"><span class="lineno"> 3742</span>                a = a.swapaxes(i, s)</div>
<div class="line"><span class="lineno"> 3743</span>            <span class="comment"># merge reduced axis</span></div>
<div class="line"><span class="lineno"> 3744</span>            a = a.reshape(a.shape[:nkeep] + (-1,))</div>
<div class="line"><span class="lineno"> 3745</span>            kwargs[<span class="stringliteral">&#39;axis&#39;</span>] = -1</div>
<div class="line"><span class="lineno"> 3746</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3747</span>        <span class="keywordflow">if</span> keepdims:</div>
<div class="line"><span class="lineno"> 3748</span>            <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3749</span>                index_out = (0, ) * nd</div>
<div class="line"><span class="lineno"> 3750</span>                kwargs[<span class="stringliteral">&#39;out&#39;</span>] = out[(Ellipsis, ) + index_out]</div>
<div class="line"><span class="lineno"> 3751</span> </div>
<div class="line"><span class="lineno"> 3752</span>    r = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(a, **kwargs)</div>
<div class="line"><span class="lineno"> 3753</span> </div>
<div class="line"><span class="lineno"> 3754</span>    <span class="keywordflow">if</span> out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3755</span>        <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 3756</span> </div>
<div class="line"><span class="lineno"> 3757</span>    <span class="keywordflow">if</span> keepdims:</div>
<div class="line"><span class="lineno"> 3758</span>        <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3759</span>            index_r = (np.newaxis, ) * nd</div>
<div class="line"><span class="lineno"> 3760</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3761</span>            index_r = tuple(</div>
<div class="line"><span class="lineno"> 3762</span>                np.newaxis <span class="keywordflow">if</span> i <span class="keywordflow">in</span> axis <span class="keywordflow">else</span> slice(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 3763</span>                <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(nd))</div>
<div class="line"><span class="lineno"> 3764</span>        r = r[(Ellipsis, ) + index_r]</div>
<div class="line"><span class="lineno"> 3765</span> </div>
<div class="line"><span class="lineno"> 3766</span>    <span class="keywordflow">return</span> r</div>
<div class="line"><span class="lineno"> 3767</span> </div>
<div class="line"><span class="lineno"> 3768</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0cf6fbcc0e56edf854c6c4cb60c10568" name="a0cf6fbcc0e56edf854c6c4cb60c10568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf6fbcc0e56edf854c6c4cb60c10568">&#9670;&#160;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.angle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deg</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the angle of the complex argument.

Parameters
----------
z : array_like
    A complex number or sequence of complex numbers.
deg : bool, optional
    Return angle in degrees if True, radians if False (default).

Returns
-------
angle : ndarray or scalar
    The counterclockwise angle from the positive real axis on the complex
    plane in the range ``(-pi, pi]``, with dtype as numpy.float64.

    .. versionchanged:: 1.16.0
        This function works on subclasses of ndarray like `ma.array`.

See Also
--------
arctan2
absolute

Notes
-----
Although the angle of the complex number 0 is undefined, ``numpy.angle(0)``
returns the value 0.

Examples
--------
&gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians
array([ 0.        ,  1.57079633,  0.78539816]) # may vary
&gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees
45.0</pre> <div class="fragment"><div class="line"><span class="lineno"> 1603</span><span class="keyword">def </span>angle(z, deg=False):</div>
<div class="line"><span class="lineno"> 1604</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">    Return the angle of the complex argument.</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">    z : array_like</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral">        A complex number or sequence of complex numbers.</span></div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">    deg : bool, optional</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">        Return angle in degrees if True, radians if False (default).</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">    angle : ndarray or scalar</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">        The counterclockwise angle from the positive real axis on the complex</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">        plane in the range ``(-pi, pi]``, with dtype as numpy.float64.</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral">        .. versionchanged:: 1.16.0</span></div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">            This function works on subclasses of ndarray like `ma.array`.</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    arctan2</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">    absolute</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">    Although the angle of the complex number 0 is undefined, ``numpy.angle(0)``</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    returns the value 0.</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">    &gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    array([ 0.        ,  1.57079633,  0.78539816]) # may vary</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">    &gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">    45.0</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1641</span>    z = asanyarray(z)</div>
<div class="line"><span class="lineno"> 1642</span>    <span class="keywordflow">if</span> issubclass(z.dtype.type, _nx.complexfloating):</div>
<div class="line"><span class="lineno"> 1643</span>        zimag = z.imag</div>
<div class="line"><span class="lineno"> 1644</span>        zreal = z.real</div>
<div class="line"><span class="lineno"> 1645</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1646</span>        zimag = 0</div>
<div class="line"><span class="lineno"> 1647</span>        zreal = z</div>
<div class="line"><span class="lineno"> 1648</span> </div>
<div class="line"><span class="lineno"> 1649</span>    a = arctan2(zimag, zreal)</div>
<div class="line"><span class="lineno"> 1650</span>    <span class="keywordflow">if</span> deg:</div>
<div class="line"><span class="lineno"> 1651</span>        a *= 180/pi</div>
<div class="line"><span class="lineno"> 1652</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno"> 1653</span> </div>
<div class="line"><span class="lineno"> 1654</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a13549a07e8b31d8a0658c402bd920251" name="a13549a07e8b31d8a0658c402bd920251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13549a07e8b31d8a0658c402bd920251">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.append </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Append values to the end of an array.

Parameters
----------
arr : array_like
    Values are appended to a copy of this array.
values : array_like
    These values are appended to a copy of `arr`.  It must be of the
    correct shape (the same shape as `arr`, excluding `axis`).  If
    `axis` is not specified, `values` can be any shape and will be
    flattened before use.
axis : int, optional
    The axis along which `values` are appended.  If `axis` is not
    given, both `arr` and `values` are flattened before use.

Returns
-------
append : ndarray
    A copy of `arr` with `values` appended to `axis`.  Note that
    `append` does not occur in-place: a new array is allocated and
    filled.  If `axis` is None, `out` is a flattened array.

See Also
--------
insert : Insert elements into an array.
delete : Delete elements from an array.

Examples
--------
&gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
array([1, 2, 3, ..., 7, 8, 9])

When `axis` is specified, `values` must have the correct shape.

&gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
Traceback (most recent call last):
    ...
ValueError: all the input arrays must have same number of dimensions, but
the array at index 0 has 2 dimension(s) and the array at index 1 has 1
dimension(s)</pre> <div class="fragment"><div class="line"><span class="lineno"> 5445</span><span class="keyword">def </span>append(arr, values, axis=None):</div>
<div class="line"><span class="lineno"> 5446</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5447</span><span class="stringliteral">    Append values to the end of an array.</span></div>
<div class="line"><span class="lineno"> 5448</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5449</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5450</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5451</span><span class="stringliteral">    arr : array_like</span></div>
<div class="line"><span class="lineno"> 5452</span><span class="stringliteral">        Values are appended to a copy of this array.</span></div>
<div class="line"><span class="lineno"> 5453</span><span class="stringliteral">    values : array_like</span></div>
<div class="line"><span class="lineno"> 5454</span><span class="stringliteral">        These values are appended to a copy of `arr`.  It must be of the</span></div>
<div class="line"><span class="lineno"> 5455</span><span class="stringliteral">        correct shape (the same shape as `arr`, excluding `axis`).  If</span></div>
<div class="line"><span class="lineno"> 5456</span><span class="stringliteral">        `axis` is not specified, `values` can be any shape and will be</span></div>
<div class="line"><span class="lineno"> 5457</span><span class="stringliteral">        flattened before use.</span></div>
<div class="line"><span class="lineno"> 5458</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 5459</span><span class="stringliteral">        The axis along which `values` are appended.  If `axis` is not</span></div>
<div class="line"><span class="lineno"> 5460</span><span class="stringliteral">        given, both `arr` and `values` are flattened before use.</span></div>
<div class="line"><span class="lineno"> 5461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5462</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5463</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5464</span><span class="stringliteral">    append : ndarray</span></div>
<div class="line"><span class="lineno"> 5465</span><span class="stringliteral">        A copy of `arr` with `values` appended to `axis`.  Note that</span></div>
<div class="line"><span class="lineno"> 5466</span><span class="stringliteral">        `append` does not occur in-place: a new array is allocated and</span></div>
<div class="line"><span class="lineno"> 5467</span><span class="stringliteral">        filled.  If `axis` is None, `out` is a flattened array.</span></div>
<div class="line"><span class="lineno"> 5468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5469</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 5470</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5471</span><span class="stringliteral">    insert : Insert elements into an array.</span></div>
<div class="line"><span class="lineno"> 5472</span><span class="stringliteral">    delete : Delete elements from an array.</span></div>
<div class="line"><span class="lineno"> 5473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5474</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 5475</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5476</span><span class="stringliteral">    &gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])</span></div>
<div class="line"><span class="lineno"> 5477</span><span class="stringliteral">    array([1, 2, 3, ..., 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 5478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5479</span><span class="stringliteral">    When `axis` is specified, `values` must have the correct shape.</span></div>
<div class="line"><span class="lineno"> 5480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5481</span><span class="stringliteral">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)</span></div>
<div class="line"><span class="lineno"> 5482</span><span class="stringliteral">    array([[1, 2, 3],</span></div>
<div class="line"><span class="lineno"> 5483</span><span class="stringliteral">           [4, 5, 6],</span></div>
<div class="line"><span class="lineno"> 5484</span><span class="stringliteral">           [7, 8, 9]])</span></div>
<div class="line"><span class="lineno"> 5485</span><span class="stringliteral">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)</span></div>
<div class="line"><span class="lineno"> 5486</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 5487</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno"> 5488</span><span class="stringliteral">    ValueError: all the input arrays must have same number of dimensions, but</span></div>
<div class="line"><span class="lineno"> 5489</span><span class="stringliteral">    the array at index 0 has 2 dimension(s) and the array at index 1 has 1</span></div>
<div class="line"><span class="lineno"> 5490</span><span class="stringliteral">    dimension(s)</span></div>
<div class="line"><span class="lineno"> 5491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5492</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5493</span>    arr = asanyarray(arr)</div>
<div class="line"><span class="lineno"> 5494</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5495</span>        <span class="keywordflow">if</span> arr.ndim != 1:</div>
<div class="line"><span class="lineno"> 5496</span>            arr = arr.ravel()</div>
<div class="line"><span class="lineno"> 5497</span>        values = ravel(values)</div>
<div class="line"><span class="lineno"> 5498</span>        axis = arr.ndim-1</div>
<div class="line"><span class="lineno"> 5499</span>    <span class="keywordflow">return</span> concatenate((arr, values), axis=axis)</div>
<div class="line"><span class="lineno"> 5500</span> </div>
<div class="line"><span class="lineno"> 5501</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abc6385b3c574b743167157dae3e84545" name="abc6385b3c574b743167157dae3e84545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6385b3c574b743167157dae3e84545">&#9670;&#160;</a></span>asarray_chkfinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.asarray_chkfinite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the input to an array, checking for NaNs or Infs.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.  Success requires no NaNs or Infs.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F', 'A', 'K'}, optional
    Memory layout.  'A' and 'K' depend on the order of input array a.
    'C' row-major (C-style),
    'F' column-major (Fortran-style) memory representation.
    'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise
    'K' (keep) preserve input order
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray.  If `a` is a subclass of ndarray, a base
    class ndarray is returned.

Raises
------
ValueError
    Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).

See Also
--------
asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array.  If all elements are finite
``asarray_chkfinite`` is identical to ``asarray``.

&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; np.asarray_chkfinite(a, dtype=float)
array([1., 2.])

Raises ValueError if array_like contains Nans or Infs.

&gt;&gt;&gt; a = [1, 2, np.inf]
&gt;&gt;&gt; try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print('ValueError')
...
ValueError</pre> <div class="fragment"><div class="line"><span class="lineno">  563</span><span class="keyword">def </span>asarray_chkfinite(a, dtype=None, order=None):</div>
<div class="line"><span class="lineno">  564</span>    <span class="stringliteral">&quot;&quot;&quot;Convert the input to an array, checking for NaNs or Infs.</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">        Input data, in any form that can be converted to an array.  This</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        of lists and ndarrays.  Success requires no NaNs or Infs.</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">        By default, the data-type is inferred from the input data.</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">        Memory layout.  &#39;A&#39; and &#39;K&#39; depend on the order of input array a.</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">        &#39;C&#39; row-major (C-style),</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">        &#39;F&#39; column-major (Fortran-style) memory representation.</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        &#39;A&#39; (any) means &#39;F&#39; if `a` is Fortran contiguous, &#39;C&#39; otherwise</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        &#39;K&#39; (keep) preserve input order</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">        Defaults to &#39;C&#39;.</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        Array interpretation of `a`.  No copy is performed if the input</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        is already an ndarray.  If `a` is a subclass of ndarray, a base</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        class ndarray is returned.</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    asarray : Create and array.</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">    asanyarray : Similar function which passes through subclasses.</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">    ascontiguousarray : Convert input to a contiguous array.</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">    asfarray : Convert input to a floating point ndarray.</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    asfortranarray : Convert input to an ndarray with column-major</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">                     memory order.</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    fromiter : Create an array from an iterator.</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    fromfunction : Construct an array by executing a function on grid</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">                   positions.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    Convert a list into an array.  If all elements are finite</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    ``asarray_chkfinite`` is identical to ``asarray``.</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    &gt;&gt;&gt; a = [1, 2]</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    &gt;&gt;&gt; np.asarray_chkfinite(a, dtype=float)</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    array([1., 2.])</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">    Raises ValueError if array_like contains Nans or Infs.</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    &gt;&gt;&gt; a = [1, 2, np.inf]</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    &gt;&gt;&gt; try:</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    ...     np.asarray_chkfinite(a)</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    ... except ValueError:</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    ...     print(&#39;ValueError&#39;)</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  623</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  625</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  626</span>    a = asarray(a, dtype=dtype, order=order)</div>
<div class="line"><span class="lineno">  627</span>    <span class="keywordflow">if</span> a.dtype.char <span class="keywordflow">in</span> typecodes[<span class="stringliteral">&#39;AllFloat&#39;</span>] <span class="keywordflow">and</span> <span class="keywordflow">not</span> np.isfinite(a).all():</div>
<div class="line"><span class="lineno">  628</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  629</span>            <span class="stringliteral">&quot;array must not contain infs or NaNs&quot;</span>)</div>
<div class="line"><span class="lineno">  630</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  631</span> </div>
<div class="line"><span class="lineno">  632</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8798b608f6ee8d7a72139dfc4d0af52f" name="a8798b608f6ee8d7a72139dfc4d0af52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8798b608f6ee8d7a72139dfc4d0af52f">&#9670;&#160;</a></span>average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.average </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>returned</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the weighted average along the specified axis.

Parameters
----------
a : array_like
    Array containing data to be averaged. If `a` is not an array, a
    conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which to average `a`.  The default,
    axis=None, will average over all of the elements of the input array.
    If axis is negative it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, averaging is performed on all of the axes
    specified in the tuple instead of a single axis or all the axes as
    before.
weights : array_like, optional
    An array of weights associated with the values in `a`. Each value in
    `a` contributes to the average according to its associated weight.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If `weights=None`, then all data in `a` are assumed to have a
    weight equal to one.  The 1-D calculation is::

        avg = sum(a * weights) / sum(weights)

    The only constraint on `weights` is that `sum(weights)` must not be 0.
returned : bool, optional
    Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
    is returned, otherwise only the average is returned.
    If `weights=None`, `sum_of_weights` is equivalent to the number of
    elements over which the average is taken.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.
    *Note:* `keepdims` will not work with instances of `numpy.matrix`
    or other classes whose methods do not support `keepdims`.

    .. versionadded:: 1.23.0

Returns
-------
retval, [sum_of_weights] : array_type or double
    Return the average along the specified axis. When `returned` is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. `sum_of_weights` is of the
    same type as `retval`. The result dtype follows a genereal pattern.
    If `weights` is None, the result dtype will be that of `a` , or ``float64``
    if `a` is integral. Otherwise, if `weights` is not None and `a` is non-
    integral, the result type will be the type of lowest precision capable of
    representing values of both `a` and `weights`. If `a` happens to be
    integral, the previous rules still applies but the result dtype will
    at least be ``float64``.

Raises
------
ZeroDivisionError
    When all weights along axis are zero. See `numpy.ma.average` for a
    version robust to this type of error.
TypeError
    When the length of 1D `weights` is not the same as the shape of `a`
    along axis.

See Also
--------
mean

ma.average : average for masked arrays -- useful if your data contains
             "missing" values
numpy.result_type : Returns the type that results from applying the
                    numpy type promotion rules to the arguments.

Examples
--------
&gt;&gt;&gt; data = np.arange(1, 5)
&gt;&gt;&gt; data
array([1, 2, 3, 4])
&gt;&gt;&gt; np.average(data)
2.5
&gt;&gt;&gt; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))
4.0

&gt;&gt;&gt; data = np.arange(6).reshape((3, 2))
&gt;&gt;&gt; data
array([[0, 1],
       [2, 3],
       [4, 5]])
&gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])
array([0.75, 2.75, 4.75])
&gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])
Traceback (most recent call last):
    ...
TypeError: Axis must be specified when shapes of a and weights differ.

&gt;&gt;&gt; a = np.ones(5, dtype=np.float128)
&gt;&gt;&gt; w = np.ones(5, dtype=np.complex64)
&gt;&gt;&gt; avg = np.average(a, weights=w)
&gt;&gt;&gt; print(avg.dtype)
complex256

With ``keepdims=True``, the following result has shape (3, 1).

&gt;&gt;&gt; np.average(data, axis=1, keepdims=True)
array([[0.5],
       [2.5],
       [4.5]])
</pre> <div class="fragment"><div class="line"><span class="lineno">  398</span>            keepdims=np._NoValue):</div>
<div class="line"><span class="lineno">  399</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    Compute the weighted average along the specified axis.</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">        Array containing data to be averaged. If `a` is not an array, a</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">        conversion is attempted.</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">        Axis or axes along which to average `a`.  The default,</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral">        axis=None, will average over all of the elements of the input array.</span></div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">        If axis is negative it counts from the last to the first axis.</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral">        If axis is a tuple of ints, averaging is performed on all of the axes</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">        specified in the tuple instead of a single axis or all the axes as</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">        before.</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    weights : array_like, optional</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">        An array of weights associated with the values in `a`. Each value in</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        `a` contributes to the average according to its associated weight.</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">        The weights array can either be 1-D (in which case its length must be</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">        the size of `a` along the given axis) or of the same shape as `a`.</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        If `weights=None`, then all data in `a` are assumed to have a</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">        weight equal to one.  The 1-D calculation is::</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">            avg = sum(a * weights) / sum(weights)</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">        The only constraint on `weights` is that `sum(weights)` must not be 0.</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    returned : bool, optional</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        is returned, otherwise only the average is returned.</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">        If `weights=None`, `sum_of_weights` is equivalent to the number of</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">        elements over which the average is taken.</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">        the result will broadcast correctly against the original `a`.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">        *Note:* `keepdims` will not work with instances of `numpy.matrix`</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">        or other classes whose methods do not support `keepdims`.</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        .. versionadded:: 1.23.0</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    retval, [sum_of_weights] : array_type or double</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">        Return the average along the specified axis. When `returned` is `True`,</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        return a tuple with the average as the first element and the sum</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">        of the weights as the second element. `sum_of_weights` is of the</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        same type as `retval`. The result dtype follows a genereal pattern.</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        If `weights` is None, the result dtype will be that of `a` , or ``float64``</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        integral, the result type will be the type of lowest precision capable of</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        representing values of both `a` and `weights`. If `a` happens to be</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        integral, the previous rules still applies but the result dtype will</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">        at least be ``float64``.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">    ZeroDivisionError</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">        When all weights along axis are zero. See `numpy.ma.average` for a</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        version robust to this type of error.</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        When the length of 1D `weights` is not the same as the shape of `a`</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        along axis.</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    mean</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    ma.average : average for masked arrays -- useful if your data contains</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">                 &quot;missing&quot; values</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    numpy.result_type : Returns the type that results from applying the</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">                        numpy type promotion rules to the arguments.</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">    &gt;&gt;&gt; data = np.arange(1, 5)</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    &gt;&gt;&gt; data</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    array([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    &gt;&gt;&gt; np.average(data)</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    2.5</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    &gt;&gt;&gt; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    &gt;&gt;&gt; data = np.arange(6).reshape((3, 2))</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    &gt;&gt;&gt; data</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    array([[0, 1],</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">           [2, 3],</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">           [4, 5]])</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    &gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    array([0.75, 2.75, 4.75])</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    &gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        ...</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    TypeError: Axis must be specified when shapes of a and weights differ.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    &gt;&gt;&gt; a = np.ones(5, dtype=np.float128)</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    &gt;&gt;&gt; w = np.ones(5, dtype=np.complex64)</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    &gt;&gt;&gt; avg = np.average(a, weights=w)</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    &gt;&gt;&gt; print(avg.dtype)</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    complex256</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    With ``keepdims=True``, the following result has shape (3, 1).</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    &gt;&gt;&gt; np.average(data, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    array([[0.5],</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">           [2.5],</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">           [4.5]])</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  509</span>    a = np.asanyarray(a)</div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span>    <span class="keywordflow">if</span> keepdims <span class="keywordflow">is</span> np._NoValue:</div>
<div class="line"><span class="lineno">  512</span>        <span class="comment"># Don&#39;t pass on the keepdims argument if one wasn&#39;t given.</span></div>
<div class="line"><span class="lineno">  513</span>        keepdims_kw = {}</div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  515</span>        keepdims_kw = {<span class="stringliteral">&#39;keepdims&#39;</span>: keepdims}</div>
<div class="line"><span class="lineno">  516</span> </div>
<div class="line"><span class="lineno">  517</span>    <span class="keywordflow">if</span> weights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  518</span>        avg = a.mean(axis, **keepdims_kw)</div>
<div class="line"><span class="lineno">  519</span>        avg_as_array = np.asanyarray(avg)</div>
<div class="line"><span class="lineno">  520</span>        scl = avg_as_array.dtype.type(a.size/avg_as_array.size)</div>
<div class="line"><span class="lineno">  521</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  522</span>        wgt = np.asanyarray(weights)</div>
<div class="line"><span class="lineno">  523</span> </div>
<div class="line"><span class="lineno">  524</span>        <span class="keywordflow">if</span> issubclass(a.dtype.type, (np.integer, np.bool_)):</div>
<div class="line"><span class="lineno">  525</span>            result_dtype = np.result_type(a.dtype, wgt.dtype, <span class="stringliteral">&#39;f8&#39;</span>)</div>
<div class="line"><span class="lineno">  526</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  527</span>            result_dtype = np.result_type(a.dtype, wgt.dtype)</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>        <span class="comment"># Sanity checks</span></div>
<div class="line"><span class="lineno">  530</span>        <span class="keywordflow">if</span> a.shape != wgt.shape:</div>
<div class="line"><span class="lineno">  531</span>            <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  532</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  533</span>                    <span class="stringliteral">&quot;Axis must be specified when shapes of a and weights &quot;</span></div>
<div class="line"><span class="lineno">  534</span>                    <span class="stringliteral">&quot;differ.&quot;</span>)</div>
<div class="line"><span class="lineno">  535</span>            <span class="keywordflow">if</span> wgt.ndim != 1:</div>
<div class="line"><span class="lineno">  536</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  537</span>                    <span class="stringliteral">&quot;1D weights expected when shapes of a and weights differ.&quot;</span>)</div>
<div class="line"><span class="lineno">  538</span>            <span class="keywordflow">if</span> wgt.shape[0] != a.shape[axis]:</div>
<div class="line"><span class="lineno">  539</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  540</span>                    <span class="stringliteral">&quot;Length of weights not compatible with specified axis.&quot;</span>)</div>
<div class="line"><span class="lineno">  541</span> </div>
<div class="line"><span class="lineno">  542</span>            <span class="comment"># setup wgt to broadcast along axis</span></div>
<div class="line"><span class="lineno">  543</span>            wgt = np.broadcast_to(wgt, (a.ndim-1)*(1,) + wgt.shape)</div>
<div class="line"><span class="lineno">  544</span>            wgt = wgt.swapaxes(-1, axis)</div>
<div class="line"><span class="lineno">  545</span> </div>
<div class="line"><span class="lineno">  546</span>        scl = wgt.sum(axis=axis, dtype=result_dtype, **keepdims_kw)</div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">if</span> np.any(scl == 0.0):</div>
<div class="line"><span class="lineno">  548</span>            <span class="keywordflow">raise</span> ZeroDivisionError(</div>
<div class="line"><span class="lineno">  549</span>                <span class="stringliteral">&quot;Weights sum to zero, can&#39;t be normalized&quot;</span>)</div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>        avg = avg_as_array = np.multiply(a, wgt,</div>
<div class="line"><span class="lineno">  552</span>                          dtype=result_dtype).sum(axis, **keepdims_kw) / scl</div>
<div class="line"><span class="lineno">  553</span> </div>
<div class="line"><span class="lineno">  554</span>    <span class="keywordflow">if</span> returned:</div>
<div class="line"><span class="lineno">  555</span>        <span class="keywordflow">if</span> scl.shape != avg_as_array.shape:</div>
<div class="line"><span class="lineno">  556</span>            scl = np.broadcast_to(scl, avg_as_array.shape).copy()</div>
<div class="line"><span class="lineno">  557</span>        <span class="keywordflow">return</span> avg, scl</div>
<div class="line"><span class="lineno">  558</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  559</span>        <span class="keywordflow">return</span> avg</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span> </div>
<div class="line"><span class="lineno">  562</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a04f32cf5c260956aeada9d703c74620e" name="a04f32cf5c260956aeada9d703c74620e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f32cf5c260956aeada9d703c74620e">&#9670;&#160;</a></span>bartlett()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.bartlett </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Bartlett window.

The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : array
    The triangular window, with the maximum value normalized to one
    (the value one appears only if the number of samples is odd), with
    the first and last samples equal to zero.

See Also
--------
blackman, hamming, hanning, kaiser

Notes
-----
The Bartlett window is defined as

.. math:: w(n) = \\frac{2}{M-1} \\left(
          \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|
          \\right)

Most references to the Bartlett window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  Note that convolution with this window produces linear
interpolation.  It is also known as an apodization (which means "removing
the foot", i.e. smoothing discontinuities at the beginning and end of the
sampled signal) or tapering function. The Fourier transform of the
Bartlett window is the product of two sinc functions. Note the excellent
discussion in Kanasewich [2]_.

References
----------
.. [1] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
       Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
       The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, "Discrete-Time Signal
       Processing", Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 429.

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; np.bartlett(12)
array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary
        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
        0.18181818,  0.        ])

Plot the window and its frequency response (requires SciPy and matplotlib):

&gt;&gt;&gt; from numpy.fft import fft, fftshift
&gt;&gt;&gt; window = np.bartlett(51)
&gt;&gt;&gt; plt.plot(window)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Bartlett window")
Text(0.5, 1.0, 'Bartlett window')
&gt;&gt;&gt; plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
&gt;&gt;&gt; plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; plt.figure()
&lt;Figure size 640x480 with 0 Axes&gt;
&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = np.abs(fftshift(A))
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
&gt;&gt;&gt; response = np.clip(response, -100, 100)
&gt;&gt;&gt; plt.plot(freq, response)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Frequency response of Bartlett window")
Text(0.5, 1.0, 'Frequency response of Bartlett window')
&gt;&gt;&gt; plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
&gt;&gt;&gt; _ = plt.axis('tight')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2968</span><span class="keyword">def </span>bartlett(M):</div>
<div class="line"><span class="lineno"> 2969</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2970</span><span class="stringliteral">    Return the Bartlett window.</span></div>
<div class="line"><span class="lineno"> 2971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2972</span><span class="stringliteral">    The Bartlett window is very similar to a triangular window, except</span></div>
<div class="line"><span class="lineno"> 2973</span><span class="stringliteral">    that the end points are at zero.  It is often used in signal</span></div>
<div class="line"><span class="lineno"> 2974</span><span class="stringliteral">    processing for tapering a signal, without generating too much</span></div>
<div class="line"><span class="lineno"> 2975</span><span class="stringliteral">    ripple in the frequency domain.</span></div>
<div class="line"><span class="lineno"> 2976</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2977</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2978</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2979</span><span class="stringliteral">    M : int</span></div>
<div class="line"><span class="lineno"> 2980</span><span class="stringliteral">        Number of points in the output window. If zero or less, an</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral">        empty array is returned.</span></div>
<div class="line"><span class="lineno"> 2982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2983</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2984</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2985</span><span class="stringliteral">    out : array</span></div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">        The triangular window, with the maximum value normalized to one</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral">        (the value one appears only if the number of samples is odd), with</span></div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral">        the first and last samples equal to zero.</span></div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">    blackman, hamming, hanning, kaiser</span></div>
<div class="line"><span class="lineno"> 2993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2994</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2995</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2996</span><span class="stringliteral">    The Bartlett window is defined as</span></div>
<div class="line"><span class="lineno"> 2997</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2998</span><span class="stringliteral">    .. math:: w(n) = \\frac{2}{M-1} \\left(</span></div>
<div class="line"><span class="lineno"> 2999</span><span class="stringliteral">              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|</span></div>
<div class="line"><span class="lineno"> 3000</span><span class="stringliteral">              \\right)</span></div>
<div class="line"><span class="lineno"> 3001</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3002</span><span class="stringliteral">    Most references to the Bartlett window come from the signal processing</span></div>
<div class="line"><span class="lineno"> 3003</span><span class="stringliteral">    literature, where it is used as one of many windowing functions for</span></div>
<div class="line"><span class="lineno"> 3004</span><span class="stringliteral">    smoothing values.  Note that convolution with this window produces linear</span></div>
<div class="line"><span class="lineno"> 3005</span><span class="stringliteral">    interpolation.  It is also known as an apodization (which means &quot;removing</span></div>
<div class="line"><span class="lineno"> 3006</span><span class="stringliteral">    the foot&quot;, i.e. smoothing discontinuities at the beginning and end of the</span></div>
<div class="line"><span class="lineno"> 3007</span><span class="stringliteral">    sampled signal) or tapering function. The Fourier transform of the</span></div>
<div class="line"><span class="lineno"> 3008</span><span class="stringliteral">    Bartlett window is the product of two sinc functions. Note the excellent</span></div>
<div class="line"><span class="lineno"> 3009</span><span class="stringliteral">    discussion in Kanasewich [2]_.</span></div>
<div class="line"><span class="lineno"> 3010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3011</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3012</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3013</span><span class="stringliteral">    .. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;,</span></div>
<div class="line"><span class="lineno"> 3014</span><span class="stringliteral">           Biometrika 37, 1-16, 1950.</span></div>
<div class="line"><span class="lineno"> 3015</span><span class="stringliteral">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span></div>
<div class="line"><span class="lineno"> 3016</span><span class="stringliteral">           The University of Alberta Press, 1975, pp. 109-110.</span></div>
<div class="line"><span class="lineno"> 3017</span><span class="stringliteral">    .. [3] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal</span></div>
<div class="line"><span class="lineno"> 3018</span><span class="stringliteral">           Processing&quot;, Prentice-Hall, 1999, pp. 468-471.</span></div>
<div class="line"><span class="lineno"> 3019</span><span class="stringliteral">    .. [4] Wikipedia, &quot;Window function&quot;,</span></div>
<div class="line"><span class="lineno"> 3020</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Window_function</span></div>
<div class="line"><span class="lineno"> 3021</span><span class="stringliteral">    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span></div>
<div class="line"><span class="lineno"> 3022</span><span class="stringliteral">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429.</span></div>
<div class="line"><span class="lineno"> 3023</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3024</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3025</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3026</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3027</span><span class="stringliteral">    &gt;&gt;&gt; np.bartlett(12)</span></div>
<div class="line"><span class="lineno"> 3028</span><span class="stringliteral">    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary</span></div>
<div class="line"><span class="lineno"> 3029</span><span class="stringliteral">            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,</span></div>
<div class="line"><span class="lineno"> 3030</span><span class="stringliteral">            0.18181818,  0.        ])</span></div>
<div class="line"><span class="lineno"> 3031</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3032</span><span class="stringliteral">    Plot the window and its frequency response (requires SciPy and matplotlib):</span></div>
<div class="line"><span class="lineno"> 3033</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3034</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span></div>
<div class="line"><span class="lineno"> 3035</span><span class="stringliteral">    &gt;&gt;&gt; window = np.bartlett(51)</span></div>
<div class="line"><span class="lineno"> 3036</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(window)</span></div>
<div class="line"><span class="lineno"> 3037</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3038</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Bartlett window&quot;)</span></div>
<div class="line"><span class="lineno"> 3039</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Bartlett window&#39;)</span></div>
<div class="line"><span class="lineno"> 3040</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span></div>
<div class="line"><span class="lineno"> 3041</span><span class="stringliteral">    Text(0, 0.5, &#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 3042</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span></div>
<div class="line"><span class="lineno"> 3043</span><span class="stringliteral">    Text(0.5, 0, &#39;Sample&#39;)</span></div>
<div class="line"><span class="lineno"> 3044</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3046</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3047</span><span class="stringliteral">    &lt;Figure size 640x480 with 0 Axes&gt;</span></div>
<div class="line"><span class="lineno"> 3048</span><span class="stringliteral">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span></div>
<div class="line"><span class="lineno"> 3049</span><span class="stringliteral">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span></div>
<div class="line"><span class="lineno"> 3050</span><span class="stringliteral">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span></div>
<div class="line"><span class="lineno"> 3051</span><span class="stringliteral">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span></div>
<div class="line"><span class="lineno"> 3052</span><span class="stringliteral">    ...     response = 20 * np.log10(mag)</span></div>
<div class="line"><span class="lineno"> 3053</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 3054</span><span class="stringliteral">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span></div>
<div class="line"><span class="lineno"> 3055</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(freq, response)</span></div>
<div class="line"><span class="lineno"> 3056</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3057</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Bartlett window&quot;)</span></div>
<div class="line"><span class="lineno"> 3058</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Frequency response of Bartlett window&#39;)</span></div>
<div class="line"><span class="lineno"> 3059</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span></div>
<div class="line"><span class="lineno"> 3060</span><span class="stringliteral">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span></div>
<div class="line"><span class="lineno"> 3061</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span></div>
<div class="line"><span class="lineno"> 3062</span><span class="stringliteral">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span></div>
<div class="line"><span class="lineno"> 3063</span><span class="stringliteral">    &gt;&gt;&gt; _ = plt.axis(&#39;tight&#39;)</span></div>
<div class="line"><span class="lineno"> 3064</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3065</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3066</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3067</span>    <span class="keywordflow">if</span> M &lt; 1:</div>
<div class="line"><span class="lineno"> 3068</span>        <span class="keywordflow">return</span> array([], dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 3069</span>    <span class="keywordflow">if</span> M == 1:</div>
<div class="line"><span class="lineno"> 3070</span>        <span class="keywordflow">return</span> ones(1, dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 3071</span>    n = arange(1-M, M, 2)</div>
<div class="line"><span class="lineno"> 3072</span>    <span class="keywordflow">return</span> where(less_equal(n, 0), 1 + n/(M-1), 1 - n/(M-1))</div>
<div class="line"><span class="lineno"> 3073</span> </div>
<div class="line"><span class="lineno"> 3074</span> </div>
<div class="line"><span class="lineno"> 3075</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="af25ec614bed6130cd2a0d4610369203f" name="af25ec614bed6130cd2a0d4610369203f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25ec614bed6130cd2a0d4610369203f">&#9670;&#160;</a></span>blackman()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.blackman </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Blackman window.

The Blackman window is a taper formed by using the first three
terms of a summation of cosines. It was designed to have close to the
minimal leakage possible.  It is close to optimal, only slightly worse
than a Kaiser window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.

Returns
-------
out : ndarray
    The window, with the maximum value normalized to one (the value one
    appears only if the number of samples is odd).

See Also
--------
bartlett, hamming, hanning, kaiser

Notes
-----
The Blackman window is defined as

.. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)

Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
"near optimal" tapering function, almost as good (by some measures)
as the kaiser window.

References
----------
Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
Dover Publications, New York.

Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; np.blackman(12)
array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary
        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])

Plot the window and the frequency response:

&gt;&gt;&gt; from numpy.fft import fft, fftshift
&gt;&gt;&gt; window = np.blackman(51)
&gt;&gt;&gt; plt.plot(window)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Blackman window")
Text(0.5, 1.0, 'Blackman window')
&gt;&gt;&gt; plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
&gt;&gt;&gt; plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; plt.figure()
&lt;Figure size 640x480 with 0 Axes&gt;
&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = np.abs(fftshift(A))
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
&gt;&gt;&gt; response = np.clip(response, -100, 100)
&gt;&gt;&gt; plt.plot(freq, response)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Frequency response of Blackman window")
Text(0.5, 1.0, 'Frequency response of Blackman window')
&gt;&gt;&gt; plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
&gt;&gt;&gt; _ = plt.axis('tight')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 2868</span><span class="keyword">def </span>blackman(M):</div>
<div class="line"><span class="lineno"> 2869</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2870</span><span class="stringliteral">    Return the Blackman window.</span></div>
<div class="line"><span class="lineno"> 2871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2872</span><span class="stringliteral">    The Blackman window is a taper formed by using the first three</span></div>
<div class="line"><span class="lineno"> 2873</span><span class="stringliteral">    terms of a summation of cosines. It was designed to have close to the</span></div>
<div class="line"><span class="lineno"> 2874</span><span class="stringliteral">    minimal leakage possible.  It is close to optimal, only slightly worse</span></div>
<div class="line"><span class="lineno"> 2875</span><span class="stringliteral">    than a Kaiser window.</span></div>
<div class="line"><span class="lineno"> 2876</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2877</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2878</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2879</span><span class="stringliteral">    M : int</span></div>
<div class="line"><span class="lineno"> 2880</span><span class="stringliteral">        Number of points in the output window. If zero or less, an empty</span></div>
<div class="line"><span class="lineno"> 2881</span><span class="stringliteral">        array is returned.</span></div>
<div class="line"><span class="lineno"> 2882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2883</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2884</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2885</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 2886</span><span class="stringliteral">        The window, with the maximum value normalized to one (the value one</span></div>
<div class="line"><span class="lineno"> 2887</span><span class="stringliteral">        appears only if the number of samples is odd).</span></div>
<div class="line"><span class="lineno"> 2888</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2889</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2890</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2891</span><span class="stringliteral">    bartlett, hamming, hanning, kaiser</span></div>
<div class="line"><span class="lineno"> 2892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2893</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2894</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2895</span><span class="stringliteral">    The Blackman window is defined as</span></div>
<div class="line"><span class="lineno"> 2896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2897</span><span class="stringliteral">    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)</span></div>
<div class="line"><span class="lineno"> 2898</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2899</span><span class="stringliteral">    Most references to the Blackman window come from the signal processing</span></div>
<div class="line"><span class="lineno"> 2900</span><span class="stringliteral">    literature, where it is used as one of many windowing functions for</span></div>
<div class="line"><span class="lineno"> 2901</span><span class="stringliteral">    smoothing values.  It is also known as an apodization (which means</span></div>
<div class="line"><span class="lineno"> 2902</span><span class="stringliteral">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span></div>
<div class="line"><span class="lineno"> 2903</span><span class="stringliteral">    and end of the sampled signal) or tapering function. It is known as a</span></div>
<div class="line"><span class="lineno"> 2904</span><span class="stringliteral">    &quot;near optimal&quot; tapering function, almost as good (by some measures)</span></div>
<div class="line"><span class="lineno"> 2905</span><span class="stringliteral">    as the kaiser window.</span></div>
<div class="line"><span class="lineno"> 2906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2907</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral">    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,</span></div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral">    Dover Publications, New York.</span></div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2912</span><span class="stringliteral">    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral">    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</span></div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2916</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2917</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 2918</span><span class="stringliteral">    &gt;&gt;&gt; np.blackman(12)</span></div>
<div class="line"><span class="lineno"> 2919</span><span class="stringliteral">    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary</span></div>
<div class="line"><span class="lineno"> 2920</span><span class="stringliteral">            4.14397981e-01,   7.36045180e-01,   9.67046769e-01,</span></div>
<div class="line"><span class="lineno"> 2921</span><span class="stringliteral">            9.67046769e-01,   7.36045180e-01,   4.14397981e-01,</span></div>
<div class="line"><span class="lineno"> 2922</span><span class="stringliteral">            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])</span></div>
<div class="line"><span class="lineno"> 2923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2924</span><span class="stringliteral">    Plot the window and the frequency response:</span></div>
<div class="line"><span class="lineno"> 2925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2926</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span></div>
<div class="line"><span class="lineno"> 2927</span><span class="stringliteral">    &gt;&gt;&gt; window = np.blackman(51)</span></div>
<div class="line"><span class="lineno"> 2928</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(window)</span></div>
<div class="line"><span class="lineno"> 2929</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 2930</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Blackman window&quot;)</span></div>
<div class="line"><span class="lineno"> 2931</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Blackman window&#39;)</span></div>
<div class="line"><span class="lineno"> 2932</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span></div>
<div class="line"><span class="lineno"> 2933</span><span class="stringliteral">    Text(0, 0.5, &#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 2934</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span></div>
<div class="line"><span class="lineno"> 2935</span><span class="stringliteral">    Text(0.5, 0, &#39;Sample&#39;)</span></div>
<div class="line"><span class="lineno"> 2936</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2937</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2938</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 2939</span><span class="stringliteral">    &lt;Figure size 640x480 with 0 Axes&gt;</span></div>
<div class="line"><span class="lineno"> 2940</span><span class="stringliteral">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span></div>
<div class="line"><span class="lineno"> 2941</span><span class="stringliteral">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span></div>
<div class="line"><span class="lineno"> 2942</span><span class="stringliteral">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span></div>
<div class="line"><span class="lineno"> 2943</span><span class="stringliteral">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span></div>
<div class="line"><span class="lineno"> 2944</span><span class="stringliteral">    ...     response = 20 * np.log10(mag)</span></div>
<div class="line"><span class="lineno"> 2945</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 2946</span><span class="stringliteral">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span></div>
<div class="line"><span class="lineno"> 2947</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(freq, response)</span></div>
<div class="line"><span class="lineno"> 2948</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 2949</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Blackman window&quot;)</span></div>
<div class="line"><span class="lineno"> 2950</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Frequency response of Blackman window&#39;)</span></div>
<div class="line"><span class="lineno"> 2951</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span></div>
<div class="line"><span class="lineno"> 2952</span><span class="stringliteral">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span></div>
<div class="line"><span class="lineno"> 2953</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span></div>
<div class="line"><span class="lineno"> 2954</span><span class="stringliteral">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span></div>
<div class="line"><span class="lineno"> 2955</span><span class="stringliteral">    &gt;&gt;&gt; _ = plt.axis(&#39;tight&#39;)</span></div>
<div class="line"><span class="lineno"> 2956</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 2957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2958</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2959</span>    <span class="keywordflow">if</span> M &lt; 1:</div>
<div class="line"><span class="lineno"> 2960</span>        <span class="keywordflow">return</span> array([], dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 2961</span>    <span class="keywordflow">if</span> M == 1:</div>
<div class="line"><span class="lineno"> 2962</span>        <span class="keywordflow">return</span> ones(1, dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 2963</span>    n = arange(1-M, M, 2)</div>
<div class="line"><span class="lineno"> 2964</span>    <span class="keywordflow">return</span> 0.42 + 0.5*cos(pi*n/(M-1)) + 0.08*cos(2.0*pi*n/(M-1))</div>
<div class="line"><span class="lineno"> 2965</span> </div>
<div class="line"><span class="lineno"> 2966</span> </div>
<div class="line"><span class="lineno"> 2967</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="afb1a45e10c0c1606be5642979696590c" name="afb1a45e10c0c1606be5642979696590c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1a45e10c0c1606be5642979696590c">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'K'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array copy of the given object.

Parameters
----------
a : array_like
    Input data.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :meth:`ndarray.copy` are very
    similar, but have different default values for their order=
    arguments.)
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise the
    returned array will be forced to be a base-class array (defaults to False).

    .. versionadded:: 1.19.0

Returns
-------
arr : ndarray
    Array interpretation of `a`.

See Also
--------
ndarray.copy : Preferred method for creating an array copy

Notes
-----
This is equivalent to:

&gt;&gt;&gt; np.array(a, copy=True)  #doctest: +SKIP

Examples
--------
Create an array x, with a reference y and a copy z:

&gt;&gt;&gt; x = np.array([1, 2, 3])
&gt;&gt;&gt; y = x
&gt;&gt;&gt; z = np.copy(x)

Note that, when we modify x, y changes, but not z:

&gt;&gt;&gt; x[0] = 10
&gt;&gt;&gt; x[0] == y[0]
True
&gt;&gt;&gt; x[0] == z[0]
False

Note that, np.copy clears previously set WRITEABLE=False flag.

&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; a.flags["WRITEABLE"] = False
&gt;&gt;&gt; b = np.copy(a)
&gt;&gt;&gt; b.flags["WRITEABLE"]
True
&gt;&gt;&gt; b[0] = 3
&gt;&gt;&gt; b
array([3, 2, 3])

Note that np.copy is a shallow copy and will not copy object
elements within arrays. This is mainly important for arrays
containing Python objects. The new array will contain the
same object which may lead to surprises if that object can
be modified (is mutable):

&gt;&gt;&gt; a = np.array([1, 'm', [2, 3, 4]], dtype=object)
&gt;&gt;&gt; b = np.copy(a)
&gt;&gt;&gt; b[2][0] = 10
&gt;&gt;&gt; a
array([1, 'm', list([10, 3, 4])], dtype=object)

To ensure all elements within an ``object`` array are copied,
use `copy.deepcopy`:

&gt;&gt;&gt; import copy
&gt;&gt;&gt; a = np.array([1, 'm', [2, 3, 4]], dtype=object)
&gt;&gt;&gt; c = copy.deepcopy(a)
&gt;&gt;&gt; c[2][0] = 10
&gt;&gt;&gt; c
array([1, 'm', list([10, 3, 4])], dtype=object)
&gt;&gt;&gt; a
array([1, 'm', list([2, 3, 4])], dtype=object)</pre> <div class="fragment"><div class="line"><span class="lineno">  872</span><span class="keyword">def </span>copy(a, order=&#39;K&#39;, subok=False):</div>
<div class="line"><span class="lineno">  873</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    Return an array copy of the given object.</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">        Input data.</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">        Controls the memory layout of the copy. &#39;C&#39; means C-order,</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `a` is Fortran contiguous,</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">        &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `a` as closely</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">        as possible. (Note that this function and :meth:`ndarray.copy` are very</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">        similar, but have different default values for their order=</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">        arguments.)</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    subok : bool, optional</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        If True, then sub-classes will be passed-through, otherwise the</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        returned array will be forced to be a base-class array (defaults to False).</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">        .. versionadded:: 1.19.0</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">    arr : ndarray</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">        Array interpretation of `a`.</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    ndarray.copy : Preferred method for creating an array copy</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    This is equivalent to:</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    &gt;&gt;&gt; np.array(a, copy=True)  #doctest: +SKIP</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    Create an array x, with a reference y and a copy z:</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">    &gt;&gt;&gt; y = x</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    &gt;&gt;&gt; z = np.copy(x)</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    Note that, when we modify x, y changes, but not z:</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral">    &gt;&gt;&gt; x[0] = 10</span></div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    &gt;&gt;&gt; x[0] == y[0]</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    &gt;&gt;&gt; x[0] == z[0]</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    Note that, np.copy clears previously set WRITEABLE=False flag.</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    &gt;&gt;&gt; a.flags[&quot;WRITEABLE&quot;] = False</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    &gt;&gt;&gt; b = np.copy(a)</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    &gt;&gt;&gt; b.flags[&quot;WRITEABLE&quot;]</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    &gt;&gt;&gt; b[0] = 3</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    array([3, 2, 3])</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    Note that np.copy is a shallow copy and will not copy object</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">    elements within arrays. This is mainly important for arrays</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    containing Python objects. The new array will contain the</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    same object which may lead to surprises if that object can</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    be modified (is mutable):</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, &#39;m&#39;, [2, 3, 4]], dtype=object)</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    &gt;&gt;&gt; b = np.copy(a)</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    &gt;&gt;&gt; b[2][0] = 10</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    To ensure all elements within an ``object`` array are copied,</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    use `copy.deepcopy`:</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    &gt;&gt;&gt; import copy</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([1, &#39;m&#39;, [2, 3, 4]], dtype=object)</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    &gt;&gt;&gt; c = copy.deepcopy(a)</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    &gt;&gt;&gt; c[2][0] = 10</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">    &gt;&gt;&gt; c</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">    array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    array([1, &#39;m&#39;, list([2, 3, 4])], dtype=object)</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  960</span>    <span class="keywordflow">return</span> array(a, order=order, subok=subok, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  961</span> </div>
<div class="line"><span class="lineno">  962</span><span class="comment"># Basic operations</span></div>
<div class="line"><span class="lineno">  963</span> </div>
<div class="line"><span class="lineno">  964</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2472954dd7ece8908ce5d16934b838ab" name="a2472954dd7ece8908ce5d16934b838ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2472954dd7ece8908ce5d16934b838ab">&#9670;&#160;</a></span>corrcoef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.corrcoef </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rowvar</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bias</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return Pearson product-moment correlation coefficients.

Please refer to the documentation for `cov` for more detail.  The
relationship between the correlation coefficient matrix, `R`, and the
covariance matrix, `C`, is

.. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } }

The values of `R` are between -1 and 1, inclusive.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
ddof : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
dtype : data-type, optional
    Data-type of the result. By default, the return data-type will have
    at least `numpy.float64` precision.

    .. versionadded:: 1.20

Returns
-------
R : ndarray
    The correlation coefficient matrix of the variables.

See Also
--------
cov : Covariance matrix

Notes
-----
Due to floating point rounding the resulting array may not be Hermitian,
the diagonal elements may not be 1, and the elements may not satisfy the
inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
interval [-1,  1] in an attempt to improve on that situation but is not
much help in the complex case.

This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.

Examples
--------
In this example we generate two random arrays, ``xarr`` and ``yarr``, and
compute the row-wise and column-wise Pearson correlation coefficients,
``R``. Since ``rowvar`` is  true by  default, we first find the row-wise
Pearson correlation coefficients between the variables of ``xarr``.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng(seed=42)
&gt;&gt;&gt; xarr = rng.random((3, 3))
&gt;&gt;&gt; xarr
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
&gt;&gt;&gt; R1 = np.corrcoef(xarr)
&gt;&gt;&gt; R1
array([[ 1.        ,  0.99256089, -0.68080986],
       [ 0.99256089,  1.        , -0.76492172],
       [-0.68080986, -0.76492172,  1.        ]])

If we add another set of variables and observations ``yarr``, we can
compute the row-wise Pearson correlation coefficients between the
variables in ``xarr`` and ``yarr``.

&gt;&gt;&gt; yarr = rng.random((3, 3))
&gt;&gt;&gt; yarr
array([[0.45038594, 0.37079802, 0.92676499],
       [0.64386512, 0.82276161, 0.4434142 ],
       [0.22723872, 0.55458479, 0.06381726]])
&gt;&gt;&gt; R2 = np.corrcoef(xarr, yarr)
&gt;&gt;&gt; R2
array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,
        -0.99004057],
       [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,
        -0.99981569],
       [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,
         0.77714685],
       [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,
        -0.83571711],
       [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,
         0.97517215],
       [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,
         1.        ]])

Finally if we use the option ``rowvar=False``, the columns are now
being treated as the variables and we will find the column-wise Pearson
correlation coefficients between variables in ``xarr`` and ``yarr``.

&gt;&gt;&gt; R3 = np.corrcoef(xarr, yarr, rowvar=False)
&gt;&gt;&gt; R3
array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,
         0.22423734],
       [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,
        -0.44069024],
       [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,
         0.75137473],
       [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,
         0.47536961],
       [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,
        -0.46666491],
       [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,
         1.        ]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 2716</span>             dtype=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2717</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2718</span><span class="stringliteral">    Return Pearson product-moment correlation coefficients.</span></div>
<div class="line"><span class="lineno"> 2719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2720</span><span class="stringliteral">    Please refer to the documentation for `cov` for more detail.  The</span></div>
<div class="line"><span class="lineno"> 2721</span><span class="stringliteral">    relationship between the correlation coefficient matrix, `R`, and the</span></div>
<div class="line"><span class="lineno"> 2722</span><span class="stringliteral">    covariance matrix, `C`, is</span></div>
<div class="line"><span class="lineno"> 2723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2724</span><span class="stringliteral">    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } }</span></div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral">    The values of `R` are between -1 and 1, inclusive.</span></div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2728</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2729</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2730</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 2731</span><span class="stringliteral">        A 1-D or 2-D array containing multiple variables and observations.</span></div>
<div class="line"><span class="lineno"> 2732</span><span class="stringliteral">        Each row of `x` represents a variable, and each column a single</span></div>
<div class="line"><span class="lineno"> 2733</span><span class="stringliteral">        observation of all those variables. Also see `rowvar` below.</span></div>
<div class="line"><span class="lineno"> 2734</span><span class="stringliteral">    y : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2735</span><span class="stringliteral">        An additional set of variables and observations. `y` has the same</span></div>
<div class="line"><span class="lineno"> 2736</span><span class="stringliteral">        shape as `x`.</span></div>
<div class="line"><span class="lineno"> 2737</span><span class="stringliteral">    rowvar : bool, optional</span></div>
<div class="line"><span class="lineno"> 2738</span><span class="stringliteral">        If `rowvar` is True (default), then each row represents a</span></div>
<div class="line"><span class="lineno"> 2739</span><span class="stringliteral">        variable, with observations in the columns. Otherwise, the relationship</span></div>
<div class="line"><span class="lineno"> 2740</span><span class="stringliteral">        is transposed: each column represents a variable, while the rows</span></div>
<div class="line"><span class="lineno"> 2741</span><span class="stringliteral">        contain observations.</span></div>
<div class="line"><span class="lineno"> 2742</span><span class="stringliteral">    bias : _NoValue, optional</span></div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral">        Has no effect, do not use.</span></div>
<div class="line"><span class="lineno"> 2744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2745</span><span class="stringliteral">        .. deprecated:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 2746</span><span class="stringliteral">    ddof : _NoValue, optional</span></div>
<div class="line"><span class="lineno"> 2747</span><span class="stringliteral">        Has no effect, do not use.</span></div>
<div class="line"><span class="lineno"> 2748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">        .. deprecated:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno"> 2751</span><span class="stringliteral">        Data-type of the result. By default, the return data-type will have</span></div>
<div class="line"><span class="lineno"> 2752</span><span class="stringliteral">        at least `numpy.float64` precision.</span></div>
<div class="line"><span class="lineno"> 2753</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2754</span><span class="stringliteral">        .. versionadded:: 1.20</span></div>
<div class="line"><span class="lineno"> 2755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2756</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral">    R : ndarray</span></div>
<div class="line"><span class="lineno"> 2759</span><span class="stringliteral">        The correlation coefficient matrix of the variables.</span></div>
<div class="line"><span class="lineno"> 2760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2761</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2762</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2763</span><span class="stringliteral">    cov : Covariance matrix</span></div>
<div class="line"><span class="lineno"> 2764</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2765</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2766</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2767</span><span class="stringliteral">    Due to floating point rounding the resulting array may not be Hermitian,</span></div>
<div class="line"><span class="lineno"> 2768</span><span class="stringliteral">    the diagonal elements may not be 1, and the elements may not satisfy the</span></div>
<div class="line"><span class="lineno"> 2769</span><span class="stringliteral">    inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the</span></div>
<div class="line"><span class="lineno"> 2770</span><span class="stringliteral">    interval [-1,  1] in an attempt to improve on that situation but is not</span></div>
<div class="line"><span class="lineno"> 2771</span><span class="stringliteral">    much help in the complex case.</span></div>
<div class="line"><span class="lineno"> 2772</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2773</span><span class="stringliteral">    This function accepts but discards arguments `bias` and `ddof`.  This is</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="stringliteral">    for backwards compatibility with previous versions of this function.  These</span></div>
<div class="line"><span class="lineno"> 2775</span><span class="stringliteral">    arguments had no effect on the return values of the function and can be</span></div>
<div class="line"><span class="lineno"> 2776</span><span class="stringliteral">    safely ignored in this and previous versions of numpy.</span></div>
<div class="line"><span class="lineno"> 2777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2778</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2779</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2780</span><span class="stringliteral">    In this example we generate two random arrays, ``xarr`` and ``yarr``, and</span></div>
<div class="line"><span class="lineno"> 2781</span><span class="stringliteral">    compute the row-wise and column-wise Pearson correlation coefficients,</span></div>
<div class="line"><span class="lineno"> 2782</span><span class="stringliteral">    ``R``. Since ``rowvar`` is  true by  default, we first find the row-wise</span></div>
<div class="line"><span class="lineno"> 2783</span><span class="stringliteral">    Pearson correlation coefficients between the variables of ``xarr``.</span></div>
<div class="line"><span class="lineno"> 2784</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2785</span><span class="stringliteral">    &gt;&gt;&gt; import numpy as np</span></div>
<div class="line"><span class="lineno"> 2786</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng(seed=42)</span></div>
<div class="line"><span class="lineno"> 2787</span><span class="stringliteral">    &gt;&gt;&gt; xarr = rng.random((3, 3))</span></div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">    &gt;&gt;&gt; xarr</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral">    array([[0.77395605, 0.43887844, 0.85859792],</span></div>
<div class="line"><span class="lineno"> 2790</span><span class="stringliteral">           [0.69736803, 0.09417735, 0.97562235],</span></div>
<div class="line"><span class="lineno"> 2791</span><span class="stringliteral">           [0.7611397 , 0.78606431, 0.12811363]])</span></div>
<div class="line"><span class="lineno"> 2792</span><span class="stringliteral">    &gt;&gt;&gt; R1 = np.corrcoef(xarr)</span></div>
<div class="line"><span class="lineno"> 2793</span><span class="stringliteral">    &gt;&gt;&gt; R1</span></div>
<div class="line"><span class="lineno"> 2794</span><span class="stringliteral">    array([[ 1.        ,  0.99256089, -0.68080986],</span></div>
<div class="line"><span class="lineno"> 2795</span><span class="stringliteral">           [ 0.99256089,  1.        , -0.76492172],</span></div>
<div class="line"><span class="lineno"> 2796</span><span class="stringliteral">           [-0.68080986, -0.76492172,  1.        ]])</span></div>
<div class="line"><span class="lineno"> 2797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2798</span><span class="stringliteral">    If we add another set of variables and observations ``yarr``, we can</span></div>
<div class="line"><span class="lineno"> 2799</span><span class="stringliteral">    compute the row-wise Pearson correlation coefficients between the</span></div>
<div class="line"><span class="lineno"> 2800</span><span class="stringliteral">    variables in ``xarr`` and ``yarr``.</span></div>
<div class="line"><span class="lineno"> 2801</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2802</span><span class="stringliteral">    &gt;&gt;&gt; yarr = rng.random((3, 3))</span></div>
<div class="line"><span class="lineno"> 2803</span><span class="stringliteral">    &gt;&gt;&gt; yarr</span></div>
<div class="line"><span class="lineno"> 2804</span><span class="stringliteral">    array([[0.45038594, 0.37079802, 0.92676499],</span></div>
<div class="line"><span class="lineno"> 2805</span><span class="stringliteral">           [0.64386512, 0.82276161, 0.4434142 ],</span></div>
<div class="line"><span class="lineno"> 2806</span><span class="stringliteral">           [0.22723872, 0.55458479, 0.06381726]])</span></div>
<div class="line"><span class="lineno"> 2807</span><span class="stringliteral">    &gt;&gt;&gt; R2 = np.corrcoef(xarr, yarr)</span></div>
<div class="line"><span class="lineno"> 2808</span><span class="stringliteral">    &gt;&gt;&gt; R2</span></div>
<div class="line"><span class="lineno"> 2809</span><span class="stringliteral">    array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,</span></div>
<div class="line"><span class="lineno"> 2810</span><span class="stringliteral">            -0.99004057],</span></div>
<div class="line"><span class="lineno"> 2811</span><span class="stringliteral">           [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,</span></div>
<div class="line"><span class="lineno"> 2812</span><span class="stringliteral">            -0.99981569],</span></div>
<div class="line"><span class="lineno"> 2813</span><span class="stringliteral">           [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,</span></div>
<div class="line"><span class="lineno"> 2814</span><span class="stringliteral">             0.77714685],</span></div>
<div class="line"><span class="lineno"> 2815</span><span class="stringliteral">           [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,</span></div>
<div class="line"><span class="lineno"> 2816</span><span class="stringliteral">            -0.83571711],</span></div>
<div class="line"><span class="lineno"> 2817</span><span class="stringliteral">           [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,</span></div>
<div class="line"><span class="lineno"> 2818</span><span class="stringliteral">             0.97517215],</span></div>
<div class="line"><span class="lineno"> 2819</span><span class="stringliteral">           [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,</span></div>
<div class="line"><span class="lineno"> 2820</span><span class="stringliteral">             1.        ]])</span></div>
<div class="line"><span class="lineno"> 2821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2822</span><span class="stringliteral">    Finally if we use the option ``rowvar=False``, the columns are now</span></div>
<div class="line"><span class="lineno"> 2823</span><span class="stringliteral">    being treated as the variables and we will find the column-wise Pearson</span></div>
<div class="line"><span class="lineno"> 2824</span><span class="stringliteral">    correlation coefficients between variables in ``xarr`` and ``yarr``.</span></div>
<div class="line"><span class="lineno"> 2825</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2826</span><span class="stringliteral">    &gt;&gt;&gt; R3 = np.corrcoef(xarr, yarr, rowvar=False)</span></div>
<div class="line"><span class="lineno"> 2827</span><span class="stringliteral">    &gt;&gt;&gt; R3</span></div>
<div class="line"><span class="lineno"> 2828</span><span class="stringliteral">    array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,</span></div>
<div class="line"><span class="lineno"> 2829</span><span class="stringliteral">             0.22423734],</span></div>
<div class="line"><span class="lineno"> 2830</span><span class="stringliteral">           [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,</span></div>
<div class="line"><span class="lineno"> 2831</span><span class="stringliteral">            -0.44069024],</span></div>
<div class="line"><span class="lineno"> 2832</span><span class="stringliteral">           [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,</span></div>
<div class="line"><span class="lineno"> 2833</span><span class="stringliteral">             0.75137473],</span></div>
<div class="line"><span class="lineno"> 2834</span><span class="stringliteral">           [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,</span></div>
<div class="line"><span class="lineno"> 2835</span><span class="stringliteral">             0.47536961],</span></div>
<div class="line"><span class="lineno"> 2836</span><span class="stringliteral">           [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,</span></div>
<div class="line"><span class="lineno"> 2837</span><span class="stringliteral">            -0.46666491],</span></div>
<div class="line"><span class="lineno"> 2838</span><span class="stringliteral">           [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,</span></div>
<div class="line"><span class="lineno"> 2839</span><span class="stringliteral">             1.        ]])</span></div>
<div class="line"><span class="lineno"> 2840</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2841</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2842</span>    <span class="keywordflow">if</span> bias <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue <span class="keywordflow">or</span> ddof <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 2843</span>        <span class="comment"># 2015-03-15, 1.10</span></div>
<div class="line"><span class="lineno"> 2844</span>        warnings.warn(<span class="stringliteral">&#39;bias and ddof have no effect and are deprecated&#39;</span>,</div>
<div class="line"><span class="lineno"> 2845</span>                      DeprecationWarning, stacklevel=3)</div>
<div class="line"><span class="lineno"> 2846</span>    c = cov(x, y, rowvar, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2847</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 2848</span>        d = diag(c)</div>
<div class="line"><span class="lineno"> 2849</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 2850</span>        <span class="comment"># scalar covariance</span></div>
<div class="line"><span class="lineno"> 2851</span>        <span class="comment"># nan if incorrect value (nan, inf, 0), 1 otherwise</span></div>
<div class="line"><span class="lineno"> 2852</span>        <span class="keywordflow">return</span> c / c</div>
<div class="line"><span class="lineno"> 2853</span>    stddev = sqrt(d.real)</div>
<div class="line"><span class="lineno"> 2854</span>    c /= stddev[:, <span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno"> 2855</span>    c /= stddev[<span class="keywordtype">None</span>, :]</div>
<div class="line"><span class="lineno"> 2856</span> </div>
<div class="line"><span class="lineno"> 2857</span>    <span class="comment"># Clip real and imaginary parts to [-1, 1].  This does not guarantee</span></div>
<div class="line"><span class="lineno"> 2858</span>    <span class="comment"># abs(a[i,j]) &lt;= 1 for complex arrays, but is the best we can do without</span></div>
<div class="line"><span class="lineno"> 2859</span>    <span class="comment"># excessive work.</span></div>
<div class="line"><span class="lineno"> 2860</span>    np.clip(c.real, -1, 1, out=c.real)</div>
<div class="line"><span class="lineno"> 2861</span>    <span class="keywordflow">if</span> np.iscomplexobj(c):</div>
<div class="line"><span class="lineno"> 2862</span>        np.clip(c.imag, -1, 1, out=c.imag)</div>
<div class="line"><span class="lineno"> 2863</span> </div>
<div class="line"><span class="lineno"> 2864</span>    <span class="keywordflow">return</span> c</div>
<div class="line"><span class="lineno"> 2865</span> </div>
<div class="line"><span class="lineno"> 2866</span> </div>
<div class="line"><span class="lineno"> 2867</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6ff4e828f8cc2c7e326a1b09ffce808" name="ac6ff4e828f8cc2c7e326a1b09ffce808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ff4e828f8cc2c7e326a1b09ffce808">&#9670;&#160;</a></span>cov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.cov </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rowvar</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bias</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fweights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aweights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate a covariance matrix, given data and weights.

Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
then the covariance matrix element :math:`C_{ij}` is the covariance of
:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
of :math:`x_i`.

See the notes for an outline of the algorithm.

Parameters
----------
m : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `m` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same form
    as that of `m`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : bool, optional
    Default normalization (False) is by ``(N - 1)``, where ``N`` is the
    number of observations given (unbiased estimate). If `bias` is True,
    then normalization is by ``N``. These values can be overridden by using
    the keyword ``ddof`` in numpy versions &gt;= 1.5.
ddof : int, optional
    If not ``None`` the default value implied by `bias` is overridden.
    Note that ``ddof=1`` will return the unbiased estimate, even if both
    `fweights` and `aweights` are specified, and ``ddof=0`` will return
    the simple average. See the notes for the details. The default value
    is ``None``.

    .. versionadded:: 1.5
fweights : array_like, int, optional
    1-D array of integer frequency weights; the number of times each
    observation vector should be repeated.

    .. versionadded:: 1.10
aweights : array_like, optional
    1-D array of observation vector weights. These relative weights are
    typically large for observations considered "important" and smaller for
    observations considered less "important". If ``ddof=0`` the array of
    weights can be used to assign probabilities to observation vectors.

    .. versionadded:: 1.10
dtype : data-type, optional
    Data-type of the result. By default, the return data-type will have
    at least `numpy.float64` precision.

    .. versionadded:: 1.20

Returns
-------
out : ndarray
    The covariance matrix of the variables.

See Also
--------
corrcoef : Normalized covariance matrix

Notes
-----
Assume that the observations are in the columns of the observation
array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
steps to compute the weighted covariance are as follows::

    &gt;&gt;&gt; m = np.arange(10, dtype=np.float64)
    &gt;&gt;&gt; f = np.arange(10) * 2
    &gt;&gt;&gt; a = np.arange(10) ** 2.
    &gt;&gt;&gt; ddof = 1
    &gt;&gt;&gt; w = f * a
    &gt;&gt;&gt; v1 = np.sum(w)
    &gt;&gt;&gt; v2 = np.sum(w * a)
    &gt;&gt;&gt; m -= np.sum(m * w, axis=None, keepdims=True) / v1
    &gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)

Note that when ``a == 1``, the normalization factor
``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``
as it should.

Examples
--------
Consider two variables, :math:`x_0` and :math:`x_1`, which
correlate perfectly, but in opposite directions:

&gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T
&gt;&gt;&gt; x
array([[0, 1, 2],
       [2, 1, 0]])

Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
matrix shows this clearly:

&gt;&gt;&gt; np.cov(x)
array([[ 1., -1.],
       [-1.,  1.]])

Note that element :math:`C_{0,1}`, which shows the correlation between
:math:`x_0` and :math:`x_1`, is negative.

Further, note how `x` and `y` are combined:

&gt;&gt;&gt; x = [-2.1, -1,  4.3]
&gt;&gt;&gt; y = [3,  1.1,  0.12]
&gt;&gt;&gt; X = np.stack((x, y), axis=0)
&gt;&gt;&gt; np.cov(X)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
&gt;&gt;&gt; np.cov(x, y)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
&gt;&gt;&gt; np.cov(x)
array(11.71)</pre> <div class="fragment"><div class="line"><span class="lineno"> 2489</span>        aweights=<span class="keywordtype">None</span>, *, dtype=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 2490</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">    Estimate a covariance matrix, given data and weights.</span></div>
<div class="line"><span class="lineno"> 2492</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2493</span><span class="stringliteral">    Covariance indicates the level to which two variables vary together.</span></div>
<div class="line"><span class="lineno"> 2494</span><span class="stringliteral">    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,</span></div>
<div class="line"><span class="lineno"> 2495</span><span class="stringliteral">    then the covariance matrix element :math:`C_{ij}` is the covariance of</span></div>
<div class="line"><span class="lineno"> 2496</span><span class="stringliteral">    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance</span></div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral">    of :math:`x_i`.</span></div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral">    See the notes for an outline of the algorithm.</span></div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">    m : array_like</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral">        A 1-D or 2-D array containing multiple variables and observations.</span></div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral">        Each row of `m` represents a variable, and each column a single</span></div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">        observation of all those variables. Also see `rowvar` below.</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral">    y : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral">        An additional set of variables and observations. `y` has the same form</span></div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral">        as that of `m`.</span></div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral">    rowvar : bool, optional</span></div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">        If `rowvar` is True (default), then each row represents a</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">        variable, with observations in the columns. Otherwise, the relationship</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">        is transposed: each column represents a variable, while the rows</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral">        contain observations.</span></div>
<div class="line"><span class="lineno"> 2515</span><span class="stringliteral">    bias : bool, optional</span></div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">        Default normalization (False) is by ``(N - 1)``, where ``N`` is the</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral">        number of observations given (unbiased estimate). If `bias` is True,</span></div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral">        then normalization is by ``N``. These values can be overridden by using</span></div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">        the keyword ``ddof`` in numpy versions &gt;= 1.5.</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral">    ddof : int, optional</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral">        If not ``None`` the default value implied by `bias` is overridden.</span></div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">        Note that ``ddof=1`` will return the unbiased estimate, even if both</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral">        `fweights` and `aweights` are specified, and ``ddof=0`` will return</span></div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">        the simple average. See the notes for the details. The default value</span></div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral">        is ``None``.</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral">        .. versionadded:: 1.5</span></div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">    fweights : array_like, int, optional</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">        1-D array of integer frequency weights; the number of times each</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">        observation vector should be repeated.</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">        .. versionadded:: 1.10</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">    aweights : array_like, optional</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">        1-D array of observation vector weights. These relative weights are</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">        typically large for observations considered &quot;important&quot; and smaller for</span></div>
<div class="line"><span class="lineno"> 2536</span><span class="stringliteral">        observations considered less &quot;important&quot;. If ``ddof=0`` the array of</span></div>
<div class="line"><span class="lineno"> 2537</span><span class="stringliteral">        weights can be used to assign probabilities to observation vectors.</span></div>
<div class="line"><span class="lineno"> 2538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2539</span><span class="stringliteral">        .. versionadded:: 1.10</span></div>
<div class="line"><span class="lineno"> 2540</span><span class="stringliteral">    dtype : data-type, optional</span></div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">        Data-type of the result. By default, the return data-type will have</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral">        at least `numpy.float64` precision.</span></div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">        .. versionadded:: 1.20</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral">        The covariance matrix of the variables.</span></div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral">    corrcoef : Normalized covariance matrix</span></div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2555</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 2556</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 2557</span><span class="stringliteral">    Assume that the observations are in the columns of the observation</span></div>
<div class="line"><span class="lineno"> 2558</span><span class="stringliteral">    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The</span></div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral">    steps to compute the weighted covariance are as follows::</span></div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral">        &gt;&gt;&gt; m = np.arange(10, dtype=np.float64)</span></div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral">        &gt;&gt;&gt; f = np.arange(10) * 2</span></div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral">        &gt;&gt;&gt; a = np.arange(10) ** 2.</span></div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">        &gt;&gt;&gt; ddof = 1</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral">        &gt;&gt;&gt; w = f * a</span></div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">        &gt;&gt;&gt; v1 = np.sum(w)</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral">        &gt;&gt;&gt; v2 = np.sum(w * a)</span></div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral">        &gt;&gt;&gt; m -= np.sum(m * w, axis=None, keepdims=True) / v1</span></div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral">        &gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)</span></div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral">    Note that when ``a == 1``, the normalization factor</span></div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral">    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``</span></div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">    as it should.</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2577</span><span class="stringliteral">    Consider two variables, :math:`x_0` and :math:`x_1`, which</span></div>
<div class="line"><span class="lineno"> 2578</span><span class="stringliteral">    correlate perfectly, but in opposite directions:</span></div>
<div class="line"><span class="lineno"> 2579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2580</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T</span></div>
<div class="line"><span class="lineno"> 2581</span><span class="stringliteral">    &gt;&gt;&gt; x</span></div>
<div class="line"><span class="lineno"> 2582</span><span class="stringliteral">    array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno"> 2583</span><span class="stringliteral">           [2, 1, 0]])</span></div>
<div class="line"><span class="lineno"> 2584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral">    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance</span></div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral">    matrix shows this clearly:</span></div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral">    &gt;&gt;&gt; np.cov(x)</span></div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral">    array([[ 1., -1.],</span></div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">           [-1.,  1.]])</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral">    Note that element :math:`C_{0,1}`, which shows the correlation between</span></div>
<div class="line"><span class="lineno"> 2593</span><span class="stringliteral">    :math:`x_0` and :math:`x_1`, is negative.</span></div>
<div class="line"><span class="lineno"> 2594</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2595</span><span class="stringliteral">    Further, note how `x` and `y` are combined:</span></div>
<div class="line"><span class="lineno"> 2596</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2597</span><span class="stringliteral">    &gt;&gt;&gt; x = [-2.1, -1,  4.3]</span></div>
<div class="line"><span class="lineno"> 2598</span><span class="stringliteral">    &gt;&gt;&gt; y = [3,  1.1,  0.12]</span></div>
<div class="line"><span class="lineno"> 2599</span><span class="stringliteral">    &gt;&gt;&gt; X = np.stack((x, y), axis=0)</span></div>
<div class="line"><span class="lineno"> 2600</span><span class="stringliteral">    &gt;&gt;&gt; np.cov(X)</span></div>
<div class="line"><span class="lineno"> 2601</span><span class="stringliteral">    array([[11.71      , -4.286     ], # may vary</span></div>
<div class="line"><span class="lineno"> 2602</span><span class="stringliteral">           [-4.286     ,  2.144133]])</span></div>
<div class="line"><span class="lineno"> 2603</span><span class="stringliteral">    &gt;&gt;&gt; np.cov(x, y)</span></div>
<div class="line"><span class="lineno"> 2604</span><span class="stringliteral">    array([[11.71      , -4.286     ], # may vary</span></div>
<div class="line"><span class="lineno"> 2605</span><span class="stringliteral">           [-4.286     ,  2.144133]])</span></div>
<div class="line"><span class="lineno"> 2606</span><span class="stringliteral">    &gt;&gt;&gt; np.cov(x)</span></div>
<div class="line"><span class="lineno"> 2607</span><span class="stringliteral">    array(11.71)</span></div>
<div class="line"><span class="lineno"> 2608</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2609</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2610</span>    <span class="comment"># Check inputs</span></div>
<div class="line"><span class="lineno"> 2611</span>    <span class="keywordflow">if</span> ddof <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> ddof != int(ddof):</div>
<div class="line"><span class="lineno"> 2612</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2613</span>            <span class="stringliteral">&quot;ddof must be integer&quot;</span>)</div>
<div class="line"><span class="lineno"> 2614</span> </div>
<div class="line"><span class="lineno"> 2615</span>    <span class="comment"># Handles complex arrays too</span></div>
<div class="line"><span class="lineno"> 2616</span>    m = np.asarray(m)</div>
<div class="line"><span class="lineno"> 2617</span>    <span class="keywordflow">if</span> m.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 2618</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;m has more than 2 dimensions&quot;</span>)</div>
<div class="line"><span class="lineno"> 2619</span> </div>
<div class="line"><span class="lineno"> 2620</span>    <span class="keywordflow">if</span> y <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2621</span>        y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 2622</span>        <span class="keywordflow">if</span> y.ndim &gt; 2:</div>
<div class="line"><span class="lineno"> 2623</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;y has more than 2 dimensions&quot;</span>)</div>
<div class="line"><span class="lineno"> 2624</span> </div>
<div class="line"><span class="lineno"> 2625</span>    <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2626</span>        <span class="keywordflow">if</span> y <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2627</span>            dtype = np.result_type(m, np.float64)</div>
<div class="line"><span class="lineno"> 2628</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2629</span>            dtype = np.result_type(m, y, np.float64)</div>
<div class="line"><span class="lineno"> 2630</span> </div>
<div class="line"><span class="lineno"> 2631</span>    X = array(m, ndmin=2, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2632</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> rowvar <span class="keywordflow">and</span> X.shape[0] != 1:</div>
<div class="line"><span class="lineno"> 2633</span>        X = X.T</div>
<div class="line"><span class="lineno"> 2634</span>    <span class="keywordflow">if</span> X.shape[0] == 0:</div>
<div class="line"><span class="lineno"> 2635</span>        <span class="keywordflow">return</span> np.array([]).reshape(0, 0)</div>
<div class="line"><span class="lineno"> 2636</span>    <span class="keywordflow">if</span> y <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2637</span>        y = array(y, copy=<span class="keyword">False</span>, ndmin=2, dtype=dtype)</div>
<div class="line"><span class="lineno"> 2638</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> rowvar <span class="keywordflow">and</span> y.shape[0] != 1:</div>
<div class="line"><span class="lineno"> 2639</span>            y = y.T</div>
<div class="line"><span class="lineno"> 2640</span>        X = np.concatenate((X, y), axis=0)</div>
<div class="line"><span class="lineno"> 2641</span> </div>
<div class="line"><span class="lineno"> 2642</span>    <span class="keywordflow">if</span> ddof <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2643</span>        <span class="keywordflow">if</span> bias == 0:</div>
<div class="line"><span class="lineno"> 2644</span>            ddof = 1</div>
<div class="line"><span class="lineno"> 2645</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2646</span>            ddof = 0</div>
<div class="line"><span class="lineno"> 2647</span> </div>
<div class="line"><span class="lineno"> 2648</span>    <span class="comment"># Get the product of frequencies and weights</span></div>
<div class="line"><span class="lineno"> 2649</span>    w = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2650</span>    <span class="keywordflow">if</span> fweights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2651</span>        fweights = np.asarray(fweights, dtype=float)</div>
<div class="line"><span class="lineno"> 2652</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.all(fweights == np.around(fweights)):</div>
<div class="line"><span class="lineno"> 2653</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 2654</span>                <span class="stringliteral">&quot;fweights must be integer&quot;</span>)</div>
<div class="line"><span class="lineno"> 2655</span>        <span class="keywordflow">if</span> fweights.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2656</span>            <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno"> 2657</span>                <span class="stringliteral">&quot;cannot handle multidimensional fweights&quot;</span>)</div>
<div class="line"><span class="lineno"> 2658</span>        <span class="keywordflow">if</span> fweights.shape[0] != X.shape[1]:</div>
<div class="line"><span class="lineno"> 2659</span>            <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno"> 2660</span>                <span class="stringliteral">&quot;incompatible numbers of samples and fweights&quot;</span>)</div>
<div class="line"><span class="lineno"> 2661</span>        <span class="keywordflow">if</span> any(fweights &lt; 0):</div>
<div class="line"><span class="lineno"> 2662</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2663</span>                <span class="stringliteral">&quot;fweights cannot be negative&quot;</span>)</div>
<div class="line"><span class="lineno"> 2664</span>        w = fweights</div>
<div class="line"><span class="lineno"> 2665</span>    <span class="keywordflow">if</span> aweights <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2666</span>        aweights = np.asarray(aweights, dtype=float)</div>
<div class="line"><span class="lineno"> 2667</span>        <span class="keywordflow">if</span> aweights.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 2668</span>            <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno"> 2669</span>                <span class="stringliteral">&quot;cannot handle multidimensional aweights&quot;</span>)</div>
<div class="line"><span class="lineno"> 2670</span>        <span class="keywordflow">if</span> aweights.shape[0] != X.shape[1]:</div>
<div class="line"><span class="lineno"> 2671</span>            <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno"> 2672</span>                <span class="stringliteral">&quot;incompatible numbers of samples and aweights&quot;</span>)</div>
<div class="line"><span class="lineno"> 2673</span>        <span class="keywordflow">if</span> any(aweights &lt; 0):</div>
<div class="line"><span class="lineno"> 2674</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2675</span>                <span class="stringliteral">&quot;aweights cannot be negative&quot;</span>)</div>
<div class="line"><span class="lineno"> 2676</span>        <span class="keywordflow">if</span> w <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2677</span>            w = aweights</div>
<div class="line"><span class="lineno"> 2678</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2679</span>            w *= aweights</div>
<div class="line"><span class="lineno"> 2680</span> </div>
<div class="line"><span class="lineno"> 2681</span>    avg, w_sum = average(X, axis=1, weights=w, returned=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2682</span>    w_sum = w_sum[0]</div>
<div class="line"><span class="lineno"> 2683</span> </div>
<div class="line"><span class="lineno"> 2684</span>    <span class="comment"># Determine the normalization</span></div>
<div class="line"><span class="lineno"> 2685</span>    <span class="keywordflow">if</span> w <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2686</span>        fact = X.shape[1] - ddof</div>
<div class="line"><span class="lineno"> 2687</span>    <span class="keywordflow">elif</span> ddof == 0:</div>
<div class="line"><span class="lineno"> 2688</span>        fact = w_sum</div>
<div class="line"><span class="lineno"> 2689</span>    <span class="keywordflow">elif</span> aweights <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2690</span>        fact = w_sum - ddof</div>
<div class="line"><span class="lineno"> 2691</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2692</span>        fact = w_sum - ddof*sum(w*aweights)/w_sum</div>
<div class="line"><span class="lineno"> 2693</span> </div>
<div class="line"><span class="lineno"> 2694</span>    <span class="keywordflow">if</span> fact &lt;= 0:</div>
<div class="line"><span class="lineno"> 2695</span>        warnings.warn(<span class="stringliteral">&quot;Degrees of freedom &lt;= 0 for slice&quot;</span>,</div>
<div class="line"><span class="lineno"> 2696</span>                      RuntimeWarning, stacklevel=3)</div>
<div class="line"><span class="lineno"> 2697</span>        fact = 0.0</div>
<div class="line"><span class="lineno"> 2698</span> </div>
<div class="line"><span class="lineno"> 2699</span>    X -= avg[:, <span class="keywordtype">None</span>]</div>
<div class="line"><span class="lineno"> 2700</span>    <span class="keywordflow">if</span> w <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2701</span>        X_T = X.T</div>
<div class="line"><span class="lineno"> 2702</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2703</span>        X_T = (X*w).T</div>
<div class="line"><span class="lineno"> 2704</span>    c = dot(X, X_T.conj())</div>
<div class="line"><span class="lineno"> 2705</span>    c *= np.true_divide(1, fact)</div>
<div class="line"><span class="lineno"> 2706</span>    <span class="keywordflow">return</span> c.squeeze()</div>
<div class="line"><span class="lineno"> 2707</span> </div>
<div class="line"><span class="lineno"> 2708</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4663e1646f5d9ce74aa757c3c9b4a463" name="a4663e1646f5d9ce74aa757c3c9b4a463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4663e1646f5d9ce74aa757c3c9b4a463">&#9670;&#160;</a></span>delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.delete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new array with sub-arrays along an axis deleted. For a one
dimensional array, this returns those entries not returned by
`arr[obj]`.

Parameters
----------
arr : array_like
    Input array.
obj : slice, int or array of ints
    Indicate indices of sub-arrays to remove along the specified axis.

    .. versionchanged:: 1.19.0
        Boolean indices are now treated as a mask of elements to remove,
        rather than being cast to the integers 0 and 1.

axis : int, optional
    The axis along which to delete the subarray defined by `obj`.
    If `axis` is None, `obj` is applied to the flattened array.

Returns
-------
out : ndarray
    A copy of `arr` with the elements specified by `obj` removed. Note
    that `delete` does not occur in-place. If `axis` is None, `out` is
    a flattened array.

See Also
--------
insert : Insert elements into an array.
append : Append elements at the end of an array.

Notes
-----
Often it is preferable to use a boolean mask. For example:

&gt;&gt;&gt; arr = np.arange(12) + 1
&gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool)
&gt;&gt;&gt; mask[[0,2,4]] = False
&gt;&gt;&gt; result = arr[mask,...]

Is equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further
use of `mask`.

Examples
--------
&gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
&gt;&gt;&gt; arr
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; np.delete(arr, 1, 0)
array([[ 1,  2,  3,  4],
       [ 9, 10, 11, 12]])

&gt;&gt;&gt; np.delete(arr, np.s_[::2], 1)
array([[ 2,  4],
       [ 6,  8],
       [10, 12]])
&gt;&gt;&gt; np.delete(arr, [1,3,5], None)
array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</pre> <div class="fragment"><div class="line"><span class="lineno"> 5055</span><span class="keyword">def </span>delete(arr, obj, axis=None):</div>
<div class="line"><span class="lineno"> 5056</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5057</span><span class="stringliteral">    Return a new array with sub-arrays along an axis deleted. For a one</span></div>
<div class="line"><span class="lineno"> 5058</span><span class="stringliteral">    dimensional array, this returns those entries not returned by</span></div>
<div class="line"><span class="lineno"> 5059</span><span class="stringliteral">    `arr[obj]`.</span></div>
<div class="line"><span class="lineno"> 5060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5061</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5062</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5063</span><span class="stringliteral">    arr : array_like</span></div>
<div class="line"><span class="lineno"> 5064</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 5065</span><span class="stringliteral">    obj : slice, int or array of ints</span></div>
<div class="line"><span class="lineno"> 5066</span><span class="stringliteral">        Indicate indices of sub-arrays to remove along the specified axis.</span></div>
<div class="line"><span class="lineno"> 5067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5068</span><span class="stringliteral">        .. versionchanged:: 1.19.0</span></div>
<div class="line"><span class="lineno"> 5069</span><span class="stringliteral">            Boolean indices are now treated as a mask of elements to remove,</span></div>
<div class="line"><span class="lineno"> 5070</span><span class="stringliteral">            rather than being cast to the integers 0 and 1.</span></div>
<div class="line"><span class="lineno"> 5071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5072</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 5073</span><span class="stringliteral">        The axis along which to delete the subarray defined by `obj`.</span></div>
<div class="line"><span class="lineno"> 5074</span><span class="stringliteral">        If `axis` is None, `obj` is applied to the flattened array.</span></div>
<div class="line"><span class="lineno"> 5075</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5076</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5077</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5078</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 5079</span><span class="stringliteral">        A copy of `arr` with the elements specified by `obj` removed. Note</span></div>
<div class="line"><span class="lineno"> 5080</span><span class="stringliteral">        that `delete` does not occur in-place. If `axis` is None, `out` is</span></div>
<div class="line"><span class="lineno"> 5081</span><span class="stringliteral">        a flattened array.</span></div>
<div class="line"><span class="lineno"> 5082</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5083</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 5084</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5085</span><span class="stringliteral">    insert : Insert elements into an array.</span></div>
<div class="line"><span class="lineno"> 5086</span><span class="stringliteral">    append : Append elements at the end of an array.</span></div>
<div class="line"><span class="lineno"> 5087</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5088</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 5089</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 5090</span><span class="stringliteral">    Often it is preferable to use a boolean mask. For example:</span></div>
<div class="line"><span class="lineno"> 5091</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5092</span><span class="stringliteral">    &gt;&gt;&gt; arr = np.arange(12) + 1</span></div>
<div class="line"><span class="lineno"> 5093</span><span class="stringliteral">    &gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool)</span></div>
<div class="line"><span class="lineno"> 5094</span><span class="stringliteral">    &gt;&gt;&gt; mask[[0,2,4]] = False</span></div>
<div class="line"><span class="lineno"> 5095</span><span class="stringliteral">    &gt;&gt;&gt; result = arr[mask,...]</span></div>
<div class="line"><span class="lineno"> 5096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5097</span><span class="stringliteral">    Is equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further</span></div>
<div class="line"><span class="lineno"> 5098</span><span class="stringliteral">    use of `mask`.</span></div>
<div class="line"><span class="lineno"> 5099</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5100</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 5101</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5102</span><span class="stringliteral">    &gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span></div>
<div class="line"><span class="lineno"> 5103</span><span class="stringliteral">    &gt;&gt;&gt; arr</span></div>
<div class="line"><span class="lineno"> 5104</span><span class="stringliteral">    array([[ 1,  2,  3,  4],</span></div>
<div class="line"><span class="lineno"> 5105</span><span class="stringliteral">           [ 5,  6,  7,  8],</span></div>
<div class="line"><span class="lineno"> 5106</span><span class="stringliteral">           [ 9, 10, 11, 12]])</span></div>
<div class="line"><span class="lineno"> 5107</span><span class="stringliteral">    &gt;&gt;&gt; np.delete(arr, 1, 0)</span></div>
<div class="line"><span class="lineno"> 5108</span><span class="stringliteral">    array([[ 1,  2,  3,  4],</span></div>
<div class="line"><span class="lineno"> 5109</span><span class="stringliteral">           [ 9, 10, 11, 12]])</span></div>
<div class="line"><span class="lineno"> 5110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5111</span><span class="stringliteral">    &gt;&gt;&gt; np.delete(arr, np.s_[::2], 1)</span></div>
<div class="line"><span class="lineno"> 5112</span><span class="stringliteral">    array([[ 2,  4],</span></div>
<div class="line"><span class="lineno"> 5113</span><span class="stringliteral">           [ 6,  8],</span></div>
<div class="line"><span class="lineno"> 5114</span><span class="stringliteral">           [10, 12]])</span></div>
<div class="line"><span class="lineno"> 5115</span><span class="stringliteral">    &gt;&gt;&gt; np.delete(arr, [1,3,5], None)</span></div>
<div class="line"><span class="lineno"> 5116</span><span class="stringliteral">    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span></div>
<div class="line"><span class="lineno"> 5117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5118</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5119</span>    wrap = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5120</span>    <span class="keywordflow">if</span> type(arr) <span class="keywordflow">is</span> <span class="keywordflow">not</span> ndarray:</div>
<div class="line"><span class="lineno"> 5121</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 5122</span>            wrap = arr.__array_wrap__</div>
<div class="line"><span class="lineno"> 5123</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 5124</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 5125</span> </div>
<div class="line"><span class="lineno"> 5126</span>    arr = asarray(arr)</div>
<div class="line"><span class="lineno"> 5127</span>    ndim = arr.ndim</div>
<div class="line"><span class="lineno"> 5128</span>    arrorder = <span class="stringliteral">&#39;F&#39;</span> <span class="keywordflow">if</span> arr.flags.fnc <span class="keywordflow">else</span> <span class="stringliteral">&#39;C&#39;</span></div>
<div class="line"><span class="lineno"> 5129</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5130</span>        <span class="keywordflow">if</span> ndim != 1:</div>
<div class="line"><span class="lineno"> 5131</span>            arr = arr.ravel()</div>
<div class="line"><span class="lineno"> 5132</span>        <span class="comment"># needed for np.matrix, which is still not 1d after being ravelled</span></div>
<div class="line"><span class="lineno"> 5133</span>        ndim = arr.ndim</div>
<div class="line"><span class="lineno"> 5134</span>        axis = ndim - 1</div>
<div class="line"><span class="lineno"> 5135</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5136</span>        axis = normalize_axis_index(axis, ndim)</div>
<div class="line"><span class="lineno"> 5137</span> </div>
<div class="line"><span class="lineno"> 5138</span>    slobj = [slice(<span class="keywordtype">None</span>)]*ndim</div>
<div class="line"><span class="lineno"> 5139</span>    N = arr.shape[axis]</div>
<div class="line"><span class="lineno"> 5140</span>    newshape = list(arr.shape)</div>
<div class="line"><span class="lineno"> 5141</span> </div>
<div class="line"><span class="lineno"> 5142</span>    <span class="keywordflow">if</span> isinstance(obj, slice):</div>
<div class="line"><span class="lineno"> 5143</span>        start, stop, step = obj.indices(N)</div>
<div class="line"><span class="lineno"> 5144</span>        xr = range(start, stop, step)</div>
<div class="line"><span class="lineno"> 5145</span>        numtodel = len(xr)</div>
<div class="line"><span class="lineno"> 5146</span> </div>
<div class="line"><span class="lineno"> 5147</span>        <span class="keywordflow">if</span> numtodel &lt;= 0:</div>
<div class="line"><span class="lineno"> 5148</span>            <span class="keywordflow">if</span> wrap:</div>
<div class="line"><span class="lineno"> 5149</span>                <span class="keywordflow">return</span> wrap(arr.copy(order=arrorder))</div>
<div class="line"><span class="lineno"> 5150</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5151</span>                <span class="keywordflow">return</span> arr.copy(order=arrorder)</div>
<div class="line"><span class="lineno"> 5152</span> </div>
<div class="line"><span class="lineno"> 5153</span>        <span class="comment"># Invert if step is negative:</span></div>
<div class="line"><span class="lineno"> 5154</span>        <span class="keywordflow">if</span> step &lt; 0:</div>
<div class="line"><span class="lineno"> 5155</span>            step = -step</div>
<div class="line"><span class="lineno"> 5156</span>            start = xr[-1]</div>
<div class="line"><span class="lineno"> 5157</span>            stop = xr[0] + 1</div>
<div class="line"><span class="lineno"> 5158</span> </div>
<div class="line"><span class="lineno"> 5159</span>        newshape[axis] -= numtodel</div>
<div class="line"><span class="lineno"> 5160</span>        new = empty(newshape, arr.dtype, arrorder)</div>
<div class="line"><span class="lineno"> 5161</span>        <span class="comment"># copy initial chunk</span></div>
<div class="line"><span class="lineno"> 5162</span>        <span class="keywordflow">if</span> start == 0:</div>
<div class="line"><span class="lineno"> 5163</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 5164</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5165</span>            slobj[axis] = slice(<span class="keywordtype">None</span>, start)</div>
<div class="line"><span class="lineno"> 5166</span>            new[tuple(slobj)] = arr[tuple(slobj)]</div>
<div class="line"><span class="lineno"> 5167</span>        <span class="comment"># copy end chunk</span></div>
<div class="line"><span class="lineno"> 5168</span>        <span class="keywordflow">if</span> stop == N:</div>
<div class="line"><span class="lineno"> 5169</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 5170</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5171</span>            slobj[axis] = slice(stop-numtodel, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 5172</span>            slobj2 = [slice(<span class="keywordtype">None</span>)]*ndim</div>
<div class="line"><span class="lineno"> 5173</span>            slobj2[axis] = slice(stop, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 5174</span>            new[tuple(slobj)] = arr[tuple(slobj2)]</div>
<div class="line"><span class="lineno"> 5175</span>        <span class="comment"># copy middle pieces</span></div>
<div class="line"><span class="lineno"> 5176</span>        <span class="keywordflow">if</span> step == 1:</div>
<div class="line"><span class="lineno"> 5177</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 5178</span>        <span class="keywordflow">else</span>:  <span class="comment"># use array indexing.</span></div>
<div class="line"><span class="lineno"> 5179</span>            keep = ones(stop-start, dtype=bool)</div>
<div class="line"><span class="lineno"> 5180</span>            keep[:stop-start:step] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5181</span>            slobj[axis] = slice(start, stop-numtodel)</div>
<div class="line"><span class="lineno"> 5182</span>            slobj2 = [slice(<span class="keywordtype">None</span>)]*ndim</div>
<div class="line"><span class="lineno"> 5183</span>            slobj2[axis] = slice(start, stop)</div>
<div class="line"><span class="lineno"> 5184</span>            arr = arr[tuple(slobj2)]</div>
<div class="line"><span class="lineno"> 5185</span>            slobj2[axis] = keep</div>
<div class="line"><span class="lineno"> 5186</span>            new[tuple(slobj)] = arr[tuple(slobj2)]</div>
<div class="line"><span class="lineno"> 5187</span>        <span class="keywordflow">if</span> wrap:</div>
<div class="line"><span class="lineno"> 5188</span>            <span class="keywordflow">return</span> wrap(new)</div>
<div class="line"><span class="lineno"> 5189</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5190</span>            <span class="keywordflow">return</span> new</div>
<div class="line"><span class="lineno"> 5191</span> </div>
<div class="line"><span class="lineno"> 5192</span>    <span class="keywordflow">if</span> isinstance(obj, (int, integer)) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(obj, bool):</div>
<div class="line"><span class="lineno"> 5193</span>        single_value = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 5194</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5195</span>        single_value = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5196</span>        _obj = obj</div>
<div class="line"><span class="lineno"> 5197</span>        obj = np.asarray(obj)</div>
<div class="line"><span class="lineno"> 5198</span>        <span class="comment"># `size == 0` to allow empty lists similar to indexing, but (as there)</span></div>
<div class="line"><span class="lineno"> 5199</span>        <span class="comment"># is really too generic:</span></div>
<div class="line"><span class="lineno"> 5200</span>        <span class="keywordflow">if</span> obj.size == 0 <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(_obj, np.ndarray):</div>
<div class="line"><span class="lineno"> 5201</span>            obj = obj.astype(intp)</div>
<div class="line"><span class="lineno"> 5202</span>        <span class="keywordflow">elif</span> obj.size == 1 <span class="keywordflow">and</span> obj.dtype.kind <span class="keywordflow">in</span> <span class="stringliteral">&quot;ui&quot;</span>:</div>
<div class="line"><span class="lineno"> 5203</span>            <span class="comment"># For a size 1 integer array we can use the single-value path</span></div>
<div class="line"><span class="lineno"> 5204</span>            <span class="comment"># (most dtypes, except boolean, should just fail later).</span></div>
<div class="line"><span class="lineno"> 5205</span>            obj = obj.item()</div>
<div class="line"><span class="lineno"> 5206</span>            single_value = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 5207</span> </div>
<div class="line"><span class="lineno"> 5208</span>    <span class="keywordflow">if</span> single_value:</div>
<div class="line"><span class="lineno"> 5209</span>        <span class="comment"># optimization for a single value</span></div>
<div class="line"><span class="lineno"> 5210</span>        <span class="keywordflow">if</span> (obj &lt; -N <span class="keywordflow">or</span> obj &gt;= N):</div>
<div class="line"><span class="lineno"> 5211</span>            <span class="keywordflow">raise</span> IndexError(</div>
<div class="line"><span class="lineno"> 5212</span>                <span class="stringliteral">&quot;index %i is out of bounds for axis %i with &quot;</span></div>
<div class="line"><span class="lineno"> 5213</span>                <span class="stringliteral">&quot;size %i&quot;</span> % (obj, axis, N))</div>
<div class="line"><span class="lineno"> 5214</span>        <span class="keywordflow">if</span> (obj &lt; 0):</div>
<div class="line"><span class="lineno"> 5215</span>            obj += N</div>
<div class="line"><span class="lineno"> 5216</span>        newshape[axis] -= 1</div>
<div class="line"><span class="lineno"> 5217</span>        new = empty(newshape, arr.dtype, arrorder)</div>
<div class="line"><span class="lineno"> 5218</span>        slobj[axis] = slice(<span class="keywordtype">None</span>, obj)</div>
<div class="line"><span class="lineno"> 5219</span>        new[tuple(slobj)] = arr[tuple(slobj)]</div>
<div class="line"><span class="lineno"> 5220</span>        slobj[axis] = slice(obj, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 5221</span>        slobj2 = [slice(<span class="keywordtype">None</span>)]*ndim</div>
<div class="line"><span class="lineno"> 5222</span>        slobj2[axis] = slice(obj+1, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 5223</span>        new[tuple(slobj)] = arr[tuple(slobj2)]</div>
<div class="line"><span class="lineno"> 5224</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5225</span>        <span class="keywordflow">if</span> obj.dtype == bool:</div>
<div class="line"><span class="lineno"> 5226</span>            <span class="keywordflow">if</span> obj.shape != (N,):</div>
<div class="line"><span class="lineno"> 5227</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;boolean array argument obj to delete &#39;</span></div>
<div class="line"><span class="lineno"> 5228</span>                                 <span class="stringliteral">&#39;must be one dimensional and match the axis &#39;</span></div>
<div class="line"><span class="lineno"> 5229</span>                                 <span class="stringliteral">&#39;length of {}&#39;</span>.format(N))</div>
<div class="line"><span class="lineno"> 5230</span> </div>
<div class="line"><span class="lineno"> 5231</span>            <span class="comment"># optimization, the other branch is slower</span></div>
<div class="line"><span class="lineno"> 5232</span>            keep = ~obj</div>
<div class="line"><span class="lineno"> 5233</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5234</span>            keep = ones(N, dtype=bool)</div>
<div class="line"><span class="lineno"> 5235</span>            keep[obj,] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5236</span> </div>
<div class="line"><span class="lineno"> 5237</span>        slobj[axis] = keep</div>
<div class="line"><span class="lineno"> 5238</span>        new = arr[tuple(slobj)]</div>
<div class="line"><span class="lineno"> 5239</span> </div>
<div class="line"><span class="lineno"> 5240</span>    <span class="keywordflow">if</span> wrap:</div>
<div class="line"><span class="lineno"> 5241</span>        <span class="keywordflow">return</span> wrap(new)</div>
<div class="line"><span class="lineno"> 5242</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5243</span>        <span class="keywordflow">return</span> new</div>
<div class="line"><span class="lineno"> 5244</span> </div>
<div class="line"><span class="lineno"> 5245</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5eb0a6129e9afd0c17390fcf39834c97" name="a5eb0a6129e9afd0c17390fcf39834c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb0a6129e9afd0c17390fcf39834c97">&#9670;&#160;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prepend</em> = <code>np._NoValue</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>append</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the n-th discrete difference along the given axis.

The first difference is given by ``out[i] = a[i+1] - a[i]`` along
the given axis, higher differences are calculated by using `diff`
recursively.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced. If zero, the input
    is returned as-is.
axis : int, optional
    The axis along which the difference is taken, default is the
    last axis.
prepend, append : array_like, optional
    Values to prepend or append to `a` along axis prior to
    performing the difference.  Scalar values are expanded to
    arrays with length 1 in the direction of axis and the shape
    of the input array in along all other axes.  Otherwise the
    dimension and shape must match `a` except along axis.

    .. versionadded:: 1.16.0

Returns
-------
diff : ndarray
    The n-th differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`. The
    type of the output is the same as the type of the difference
    between any two elements of `a`. This is the same as the type of
    `a` in most cases. A notable exception is `datetime64`, which
    results in a `timedelta64` output array.

See Also
--------
gradient, ediff1d, cumsum

Notes
-----
Type is preserved for boolean arrays, so the result will contain
`False` when consecutive elements are the same and `True` when they
differ.

For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:

&gt;&gt;&gt; u8_arr = np.array([1, 0], dtype=np.uint8)
&gt;&gt;&gt; np.diff(u8_arr)
array([255], dtype=uint8)
&gt;&gt;&gt; u8_arr[1,...] - u8_arr[0,...]
255

If this is not desirable, then the array should be cast to a larger
integer type first:

&gt;&gt;&gt; i16_arr = u8_arr.astype(np.int16)
&gt;&gt;&gt; np.diff(i16_arr)
array([-1], dtype=int16)

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])
&gt;&gt;&gt; np.diff(x)
array([ 1,  2,  3, -7])
&gt;&gt;&gt; np.diff(x, n=2)
array([  1,   1, -10])

&gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
&gt;&gt;&gt; np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
&gt;&gt;&gt; np.diff(x, axis=0)
array([[-1,  2,  0, -2]])

&gt;&gt;&gt; x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
&gt;&gt;&gt; np.diff(x)
array([1, 1], dtype='timedelta64[D]')</pre> <div class="fragment"><div class="line"><span class="lineno"> 1321</span><span class="keyword">def </span>diff(a, n=1, axis=-1, prepend=np._NoValue, append=np._NoValue):</div>
<div class="line"><span class="lineno"> 1322</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    Calculate the n-th discrete difference along the given axis.</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    The first difference is given by ``out[i] = a[i+1] - a[i]`` along</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">    the given axis, higher differences are calculated by using `diff`</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    recursively.</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral">    n : int, optional</span></div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">        The number of times values are differenced. If zero, the input</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">        is returned as-is.</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">        The axis along which the difference is taken, default is the</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">        last axis.</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">    prepend, append : array_like, optional</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">        Values to prepend or append to `a` along axis prior to</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        performing the difference.  Scalar values are expanded to</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">        arrays with length 1 in the direction of axis and the shape</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">        of the input array in along all other axes.  Otherwise the</span></div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">        dimension and shape must match `a` except along axis.</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral">        .. versionadded:: 1.16.0</span></div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    diff : ndarray</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral">        The n-th differences. The shape of the output is the same as `a`</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">        except along `axis` where the dimension is smaller by `n`. The</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">        type of the output is the same as the type of the difference</span></div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">        between any two elements of `a`. This is the same as the type of</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">        `a` in most cases. A notable exception is `datetime64`, which</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral">        results in a `timedelta64` output array.</span></div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    gradient, ediff1d, cumsum</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1364</span><span class="stringliteral">    Type is preserved for boolean arrays, so the result will contain</span></div>
<div class="line"><span class="lineno"> 1365</span><span class="stringliteral">    `False` when consecutive elements are the same and `True` when they</span></div>
<div class="line"><span class="lineno"> 1366</span><span class="stringliteral">    differ.</span></div>
<div class="line"><span class="lineno"> 1367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1368</span><span class="stringliteral">    For unsigned integer arrays, the results will also be unsigned. This</span></div>
<div class="line"><span class="lineno"> 1369</span><span class="stringliteral">    should not be surprising, as the result is consistent with</span></div>
<div class="line"><span class="lineno"> 1370</span><span class="stringliteral">    calculating the difference directly:</span></div>
<div class="line"><span class="lineno"> 1371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1372</span><span class="stringliteral">    &gt;&gt;&gt; u8_arr = np.array([1, 0], dtype=np.uint8)</span></div>
<div class="line"><span class="lineno"> 1373</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(u8_arr)</span></div>
<div class="line"><span class="lineno"> 1374</span><span class="stringliteral">    array([255], dtype=uint8)</span></div>
<div class="line"><span class="lineno"> 1375</span><span class="stringliteral">    &gt;&gt;&gt; u8_arr[1,...] - u8_arr[0,...]</span></div>
<div class="line"><span class="lineno"> 1376</span><span class="stringliteral">    255</span></div>
<div class="line"><span class="lineno"> 1377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1378</span><span class="stringliteral">    If this is not desirable, then the array should be cast to a larger</span></div>
<div class="line"><span class="lineno"> 1379</span><span class="stringliteral">    integer type first:</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">    &gt;&gt;&gt; i16_arr = u8_arr.astype(np.int16)</span></div>
<div class="line"><span class="lineno"> 1382</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(i16_arr)</span></div>
<div class="line"><span class="lineno"> 1383</span><span class="stringliteral">    array([-1], dtype=int16)</span></div>
<div class="line"><span class="lineno"> 1384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1385</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])</span></div>
<div class="line"><span class="lineno"> 1388</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(x)</span></div>
<div class="line"><span class="lineno"> 1389</span><span class="stringliteral">    array([ 1,  2,  3, -7])</span></div>
<div class="line"><span class="lineno"> 1390</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(x, n=2)</span></div>
<div class="line"><span class="lineno"> 1391</span><span class="stringliteral">    array([  1,   1, -10])</span></div>
<div class="line"><span class="lineno"> 1392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1393</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])</span></div>
<div class="line"><span class="lineno"> 1394</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(x)</span></div>
<div class="line"><span class="lineno"> 1395</span><span class="stringliteral">    array([[2, 3, 4],</span></div>
<div class="line"><span class="lineno"> 1396</span><span class="stringliteral">           [5, 1, 2]])</span></div>
<div class="line"><span class="lineno"> 1397</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(x, axis=0)</span></div>
<div class="line"><span class="lineno"> 1398</span><span class="stringliteral">    array([[-1,  2,  0, -2]])</span></div>
<div class="line"><span class="lineno"> 1399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1400</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(&#39;1066-10-13&#39;, &#39;1066-10-16&#39;, dtype=np.datetime64)</span></div>
<div class="line"><span class="lineno"> 1401</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(x)</span></div>
<div class="line"><span class="lineno"> 1402</span><span class="stringliteral">    array([1, 1], dtype=&#39;timedelta64[D]&#39;)</span></div>
<div class="line"><span class="lineno"> 1403</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1404</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1405</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno"> 1406</span>        <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno"> 1407</span>    <span class="keywordflow">if</span> n &lt; 0:</div>
<div class="line"><span class="lineno"> 1408</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1409</span>            <span class="stringliteral">&quot;order must be non-negative but got &quot;</span> + repr(n))</div>
<div class="line"><span class="lineno"> 1410</span> </div>
<div class="line"><span class="lineno"> 1411</span>    a = asanyarray(a)</div>
<div class="line"><span class="lineno"> 1412</span>    nd = a.ndim</div>
<div class="line"><span class="lineno"> 1413</span>    <span class="keywordflow">if</span> nd == 0:</div>
<div class="line"><span class="lineno"> 1414</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;diff requires input that is at least one dimensional&quot;</span>)</div>
<div class="line"><span class="lineno"> 1415</span>    axis = normalize_axis_index(axis, nd)</div>
<div class="line"><span class="lineno"> 1416</span> </div>
<div class="line"><span class="lineno"> 1417</span>    combined = []</div>
<div class="line"><span class="lineno"> 1418</span>    <span class="keywordflow">if</span> prepend <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 1419</span>        prepend = np.asanyarray(prepend)</div>
<div class="line"><span class="lineno"> 1420</span>        <span class="keywordflow">if</span> prepend.ndim == 0:</div>
<div class="line"><span class="lineno"> 1421</span>            shape = list(a.shape)</div>
<div class="line"><span class="lineno"> 1422</span>            shape[axis] = 1</div>
<div class="line"><span class="lineno"> 1423</span>            prepend = np.broadcast_to(prepend, tuple(shape))</div>
<div class="line"><span class="lineno"> 1424</span>        combined.append(prepend)</div>
<div class="line"><span class="lineno"> 1425</span> </div>
<div class="line"><span class="lineno"> 1426</span>    combined.append(a)</div>
<div class="line"><span class="lineno"> 1427</span> </div>
<div class="line"><span class="lineno"> 1428</span>    <span class="keywordflow">if</span> append <span class="keywordflow">is</span> <span class="keywordflow">not</span> np._NoValue:</div>
<div class="line"><span class="lineno"> 1429</span>        append = np.asanyarray(append)</div>
<div class="line"><span class="lineno"> 1430</span>        <span class="keywordflow">if</span> append.ndim == 0:</div>
<div class="line"><span class="lineno"> 1431</span>            shape = list(a.shape)</div>
<div class="line"><span class="lineno"> 1432</span>            shape[axis] = 1</div>
<div class="line"><span class="lineno"> 1433</span>            append = np.broadcast_to(append, tuple(shape))</div>
<div class="line"><span class="lineno"> 1434</span>        combined.append(append)</div>
<div class="line"><span class="lineno"> 1435</span> </div>
<div class="line"><span class="lineno"> 1436</span>    <span class="keywordflow">if</span> len(combined) &gt; 1:</div>
<div class="line"><span class="lineno"> 1437</span>        a = np.concatenate(combined, axis)</div>
<div class="line"><span class="lineno"> 1438</span> </div>
<div class="line"><span class="lineno"> 1439</span>    slice1 = [slice(<span class="keywordtype">None</span>)] * nd</div>
<div class="line"><span class="lineno"> 1440</span>    slice2 = [slice(<span class="keywordtype">None</span>)] * nd</div>
<div class="line"><span class="lineno"> 1441</span>    slice1[axis] = slice(1, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1442</span>    slice2[axis] = slice(<span class="keywordtype">None</span>, -1)</div>
<div class="line"><span class="lineno"> 1443</span>    slice1 = tuple(slice1)</div>
<div class="line"><span class="lineno"> 1444</span>    slice2 = tuple(slice2)</div>
<div class="line"><span class="lineno"> 1445</span> </div>
<div class="line"><span class="lineno"> 1446</span>    op = not_equal <span class="keywordflow">if</span> a.dtype == np.bool_ <span class="keywordflow">else</span> subtract</div>
<div class="line"><span class="lineno"> 1447</span>    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(n):</div>
<div class="line"><span class="lineno"> 1448</span>        a = op(a[slice1], a[slice2])</div>
<div class="line"><span class="lineno"> 1449</span> </div>
<div class="line"><span class="lineno"> 1450</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno"> 1451</span> </div>
<div class="line"><span class="lineno"> 1452</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa259b287cb75f0a18e0ef9a53296e62d" name="aa259b287cb75f0a18e0ef9a53296e62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa259b287cb75f0a18e0ef9a53296e62d">&#9670;&#160;</a></span>digitize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.digitize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices of the bins to which each value in input array belongs.

=========  =============  ============================
`right`    order of bins  returned index `i` satisfies
=========  =============  ============================
``False``  increasing     ``bins[i-1] &lt;= x &lt; bins[i]``
``True``   increasing     ``bins[i-1] &lt; x &lt;= bins[i]``
``False``  decreasing     ``bins[i-1] &gt; x &gt;= bins[i]``
``True``   decreasing     ``bins[i-1] &gt;= x &gt; bins[i]``
=========  =============  ============================

If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is
returned as appropriate.

Parameters
----------
x : array_like
    Input array to be binned. Prior to NumPy 1.10.0, this array had to
    be 1-dimensional, but can now have any shape.
bins : array_like
    Array of bins. It has to be 1-dimensional and monotonic.
right : bool, optional
    Indicating whether the intervals include the right or the left bin
    edge. Default behavior is (right==False) indicating that the interval
    does not include the right edge. The left bin end is open in this
    case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
    monotonically increasing bins.

Returns
-------
indices : ndarray of ints
    Output array of indices, of same shape as `x`.

Raises
------
ValueError
    If `bins` is not monotonic.
TypeError
    If the type of the input is complex.

See Also
--------
bincount, histogram, unique, searchsorted

Notes
-----
If values in `x` are such that they fall outside the bin range,
attempting to index `bins` with the indices that `digitize` returns
will result in an IndexError.

.. versionadded:: 1.10.0

`np.digitize` is  implemented in terms of `np.searchsorted`. This means
that a binary search is used to bin the values, which scales much better
for larger number of bins than the previous linear search. It also removes
the requirement for the input array to be 1-dimensional.

For monotonically _increasing_ `bins`, the following are equivalent::

    np.digitize(x, bins, right=True)
    np.searchsorted(bins, x, side='left')

Note that as the order of the arguments are reversed, the side must be too.
The `searchsorted` call is marginally faster, as it does not do any
monotonicity checks. Perhaps more importantly, it supports all dtypes.

Examples
--------
&gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6])
&gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
&gt;&gt;&gt; inds = np.digitize(x, bins)
&gt;&gt;&gt; inds
array([1, 4, 3, 2])
&gt;&gt;&gt; for n in range(x.size):
...   print(bins[inds[n]-1], "&lt;=", x[n], "&lt;", bins[inds[n]])
...
0.0 &lt;= 0.2 &lt; 1.0
4.0 &lt;= 6.4 &lt; 10.0
2.5 &lt;= 3.0 &lt; 4.0
1.0 &lt;= 1.6 &lt; 2.5

&gt;&gt;&gt; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
&gt;&gt;&gt; bins = np.array([0, 5, 10, 15, 20])
&gt;&gt;&gt; np.digitize(x,bins,right=True)
array([1, 2, 3, 4, 4])
&gt;&gt;&gt; np.digitize(x,bins,right=False)
array([1, 3, 3, 4, 5])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5507</span><span class="keyword">def </span>digitize(x, bins, right=False):</div>
<div class="line"><span class="lineno"> 5508</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5509</span><span class="stringliteral">    Return the indices of the bins to which each value in input array belongs.</span></div>
<div class="line"><span class="lineno"> 5510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5511</span><span class="stringliteral">    =========  =============  ============================</span></div>
<div class="line"><span class="lineno"> 5512</span><span class="stringliteral">    `right`    order of bins  returned index `i` satisfies</span></div>
<div class="line"><span class="lineno"> 5513</span><span class="stringliteral">    =========  =============  ============================</span></div>
<div class="line"><span class="lineno"> 5514</span><span class="stringliteral">    ``False``  increasing     ``bins[i-1] &lt;= x &lt; bins[i]``</span></div>
<div class="line"><span class="lineno"> 5515</span><span class="stringliteral">    ``True``   increasing     ``bins[i-1] &lt; x &lt;= bins[i]``</span></div>
<div class="line"><span class="lineno"> 5516</span><span class="stringliteral">    ``False``  decreasing     ``bins[i-1] &gt; x &gt;= bins[i]``</span></div>
<div class="line"><span class="lineno"> 5517</span><span class="stringliteral">    ``True``   decreasing     ``bins[i-1] &gt;= x &gt; bins[i]``</span></div>
<div class="line"><span class="lineno"> 5518</span><span class="stringliteral">    =========  =============  ============================</span></div>
<div class="line"><span class="lineno"> 5519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5520</span><span class="stringliteral">    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is</span></div>
<div class="line"><span class="lineno"> 5521</span><span class="stringliteral">    returned as appropriate.</span></div>
<div class="line"><span class="lineno"> 5522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5523</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5524</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5525</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 5526</span><span class="stringliteral">        Input array to be binned. Prior to NumPy 1.10.0, this array had to</span></div>
<div class="line"><span class="lineno"> 5527</span><span class="stringliteral">        be 1-dimensional, but can now have any shape.</span></div>
<div class="line"><span class="lineno"> 5528</span><span class="stringliteral">    bins : array_like</span></div>
<div class="line"><span class="lineno"> 5529</span><span class="stringliteral">        Array of bins. It has to be 1-dimensional and monotonic.</span></div>
<div class="line"><span class="lineno"> 5530</span><span class="stringliteral">    right : bool, optional</span></div>
<div class="line"><span class="lineno"> 5531</span><span class="stringliteral">        Indicating whether the intervals include the right or the left bin</span></div>
<div class="line"><span class="lineno"> 5532</span><span class="stringliteral">        edge. Default behavior is (right==False) indicating that the interval</span></div>
<div class="line"><span class="lineno"> 5533</span><span class="stringliteral">        does not include the right edge. The left bin end is open in this</span></div>
<div class="line"><span class="lineno"> 5534</span><span class="stringliteral">        case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for</span></div>
<div class="line"><span class="lineno"> 5535</span><span class="stringliteral">        monotonically increasing bins.</span></div>
<div class="line"><span class="lineno"> 5536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5537</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5538</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5539</span><span class="stringliteral">    indices : ndarray of ints</span></div>
<div class="line"><span class="lineno"> 5540</span><span class="stringliteral">        Output array of indices, of same shape as `x`.</span></div>
<div class="line"><span class="lineno"> 5541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5542</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 5543</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 5544</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 5545</span><span class="stringliteral">        If `bins` is not monotonic.</span></div>
<div class="line"><span class="lineno"> 5546</span><span class="stringliteral">    TypeError</span></div>
<div class="line"><span class="lineno"> 5547</span><span class="stringliteral">        If the type of the input is complex.</span></div>
<div class="line"><span class="lineno"> 5548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5549</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 5550</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5551</span><span class="stringliteral">    bincount, histogram, unique, searchsorted</span></div>
<div class="line"><span class="lineno"> 5552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5553</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 5554</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 5555</span><span class="stringliteral">    If values in `x` are such that they fall outside the bin range,</span></div>
<div class="line"><span class="lineno"> 5556</span><span class="stringliteral">    attempting to index `bins` with the indices that `digitize` returns</span></div>
<div class="line"><span class="lineno"> 5557</span><span class="stringliteral">    will result in an IndexError.</span></div>
<div class="line"><span class="lineno"> 5558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5559</span><span class="stringliteral">    .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 5560</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5561</span><span class="stringliteral">    `np.digitize` is  implemented in terms of `np.searchsorted`. This means</span></div>
<div class="line"><span class="lineno"> 5562</span><span class="stringliteral">    that a binary search is used to bin the values, which scales much better</span></div>
<div class="line"><span class="lineno"> 5563</span><span class="stringliteral">    for larger number of bins than the previous linear search. It also removes</span></div>
<div class="line"><span class="lineno"> 5564</span><span class="stringliteral">    the requirement for the input array to be 1-dimensional.</span></div>
<div class="line"><span class="lineno"> 5565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5566</span><span class="stringliteral">    For monotonically _increasing_ `bins`, the following are equivalent::</span></div>
<div class="line"><span class="lineno"> 5567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5568</span><span class="stringliteral">        np.digitize(x, bins, right=True)</span></div>
<div class="line"><span class="lineno"> 5569</span><span class="stringliteral">        np.searchsorted(bins, x, side=&#39;left&#39;)</span></div>
<div class="line"><span class="lineno"> 5570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5571</span><span class="stringliteral">    Note that as the order of the arguments are reversed, the side must be too.</span></div>
<div class="line"><span class="lineno"> 5572</span><span class="stringliteral">    The `searchsorted` call is marginally faster, as it does not do any</span></div>
<div class="line"><span class="lineno"> 5573</span><span class="stringliteral">    monotonicity checks. Perhaps more importantly, it supports all dtypes.</span></div>
<div class="line"><span class="lineno"> 5574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5575</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 5576</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5577</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6])</span></div>
<div class="line"><span class="lineno"> 5578</span><span class="stringliteral">    &gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])</span></div>
<div class="line"><span class="lineno"> 5579</span><span class="stringliteral">    &gt;&gt;&gt; inds = np.digitize(x, bins)</span></div>
<div class="line"><span class="lineno"> 5580</span><span class="stringliteral">    &gt;&gt;&gt; inds</span></div>
<div class="line"><span class="lineno"> 5581</span><span class="stringliteral">    array([1, 4, 3, 2])</span></div>
<div class="line"><span class="lineno"> 5582</span><span class="stringliteral">    &gt;&gt;&gt; for n in range(x.size):</span></div>
<div class="line"><span class="lineno"> 5583</span><span class="stringliteral">    ...   print(bins[inds[n]-1], &quot;&lt;=&quot;, x[n], &quot;&lt;&quot;, bins[inds[n]])</span></div>
<div class="line"><span class="lineno"> 5584</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 5585</span><span class="stringliteral">    0.0 &lt;= 0.2 &lt; 1.0</span></div>
<div class="line"><span class="lineno"> 5586</span><span class="stringliteral">    4.0 &lt;= 6.4 &lt; 10.0</span></div>
<div class="line"><span class="lineno"> 5587</span><span class="stringliteral">    2.5 &lt;= 3.0 &lt; 4.0</span></div>
<div class="line"><span class="lineno"> 5588</span><span class="stringliteral">    1.0 &lt;= 1.6 &lt; 2.5</span></div>
<div class="line"><span class="lineno"> 5589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5590</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])</span></div>
<div class="line"><span class="lineno"> 5591</span><span class="stringliteral">    &gt;&gt;&gt; bins = np.array([0, 5, 10, 15, 20])</span></div>
<div class="line"><span class="lineno"> 5592</span><span class="stringliteral">    &gt;&gt;&gt; np.digitize(x,bins,right=True)</span></div>
<div class="line"><span class="lineno"> 5593</span><span class="stringliteral">    array([1, 2, 3, 4, 4])</span></div>
<div class="line"><span class="lineno"> 5594</span><span class="stringliteral">    &gt;&gt;&gt; np.digitize(x,bins,right=False)</span></div>
<div class="line"><span class="lineno"> 5595</span><span class="stringliteral">    array([1, 3, 3, 4, 5])</span></div>
<div class="line"><span class="lineno"> 5596</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5597</span>    x = _nx.asarray(x)</div>
<div class="line"><span class="lineno"> 5598</span>    bins = _nx.asarray(bins)</div>
<div class="line"><span class="lineno"> 5599</span> </div>
<div class="line"><span class="lineno"> 5600</span>    <span class="comment"># here for compatibility, searchsorted below is happy to take this</span></div>
<div class="line"><span class="lineno"> 5601</span>    <span class="keywordflow">if</span> np.issubdtype(x.dtype, _nx.complexfloating):</div>
<div class="line"><span class="lineno"> 5602</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;x may not be complex&quot;</span>)</div>
<div class="line"><span class="lineno"> 5603</span> </div>
<div class="line"><span class="lineno"> 5604</span>    mono = _monotonicity(bins)</div>
<div class="line"><span class="lineno"> 5605</span>    <span class="keywordflow">if</span> mono == 0:</div>
<div class="line"><span class="lineno"> 5606</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;bins must be monotonically increasing or decreasing&quot;</span>)</div>
<div class="line"><span class="lineno"> 5607</span> </div>
<div class="line"><span class="lineno"> 5608</span>    <span class="comment"># this is backwards because the arguments below are swapped</span></div>
<div class="line"><span class="lineno"> 5609</span>    side = <span class="stringliteral">&#39;left&#39;</span> <span class="keywordflow">if</span> right <span class="keywordflow">else</span> <span class="stringliteral">&#39;right&#39;</span></div>
<div class="line"><span class="lineno"> 5610</span>    <span class="keywordflow">if</span> mono == -1:</div>
<div class="line"><span class="lineno"> 5611</span>        <span class="comment"># reverse the bins, and invert the results</span></div>
<div class="line"><span class="lineno"> 5612</span>        <span class="keywordflow">return</span> len(bins) - _nx.searchsorted(bins[::-1], x, side=side)</div>
<div class="line"><span class="lineno"> 5613</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5614</span>        <span class="keywordflow">return</span> _nx.searchsorted(bins, x, side=side)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a09dbeec0a20ef95416268f8965120fba" name="a09dbeec0a20ef95416268f8965120fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dbeec0a20ef95416268f8965120fba">&#9670;&#160;</a></span>disp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.disp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mesg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>device</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linefeed</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Display a message on a device.

Parameters
----------
mesg : str
    Message to display.
device : object
    Device to write message. If None, defaults to ``sys.stdout`` which is
    very similar to ``print``. `device` needs to have ``write()`` and
    ``flush()`` methods.
linefeed : bool, optional
    Option whether to print a line feed or not. Defaults to True.

Raises
------
AttributeError
    If `device` does not have a ``write()`` or ``flush()`` method.

Examples
--------
Besides ``sys.stdout``, a file-like object can also be used as it has
both required methods:

&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; buf = StringIO()
&gt;&gt;&gt; np.disp(u'"Display" in a file', device=buf)
&gt;&gt;&gt; buf.getvalue()
'"Display" in a file\\n'</pre> <div class="fragment"><div class="line"><span class="lineno"> 1957</span><span class="keyword">def </span>disp(mesg, device=None, linefeed=True):</div>
<div class="line"><span class="lineno"> 1958</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1959</span><span class="stringliteral">    Display a message on a device.</span></div>
<div class="line"><span class="lineno"> 1960</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1961</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1962</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1963</span><span class="stringliteral">    mesg : str</span></div>
<div class="line"><span class="lineno"> 1964</span><span class="stringliteral">        Message to display.</span></div>
<div class="line"><span class="lineno"> 1965</span><span class="stringliteral">    device : object</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">        Device to write message. If None, defaults to ``sys.stdout`` which is</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral">        very similar to ``print``. `device` needs to have ``write()`` and</span></div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">        ``flush()`` methods.</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">    linefeed : bool, optional</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral">        Option whether to print a line feed or not. Defaults to True.</span></div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">    AttributeError</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">        If `device` does not have a ``write()`` or ``flush()`` method.</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral">    Besides ``sys.stdout``, a file-like object can also be used as it has</span></div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">    both required methods:</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral">    &gt;&gt;&gt; from io import StringIO</span></div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral">    &gt;&gt;&gt; buf = StringIO()</span></div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">    &gt;&gt;&gt; np.disp(u&#39;&quot;Display&quot; in a file&#39;, device=buf)</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">    &gt;&gt;&gt; buf.getvalue()</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">    &#39;&quot;Display&quot; in a file\\n&#39;</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1989</span>    <span class="keywordflow">if</span> device <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1990</span>        device = sys.stdout</div>
<div class="line"><span class="lineno"> 1991</span>    <span class="keywordflow">if</span> linefeed:</div>
<div class="line"><span class="lineno"> 1992</span>        device.write(<span class="stringliteral">&#39;%s\n&#39;</span> % mesg)</div>
<div class="line"><span class="lineno"> 1993</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1994</span>        device.write(<span class="stringliteral">&#39;%s&#39;</span> % mesg)</div>
<div class="line"><span class="lineno"> 1995</span>    device.flush()</div>
<div class="line"><span class="lineno"> 1996</span>    <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1997</span> </div>
<div class="line"><span class="lineno"> 1998</span> </div>
<div class="line"><span class="lineno"> 1999</span><span class="comment"># See https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae2b248407fcb2f95fee57aa96e087bb0" name="ae2b248407fcb2f95fee57aa96e087bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b248407fcb2f95fee57aa96e087bb0">&#9670;&#160;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.extract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the elements of an array that satisfy some condition.

This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
`condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.

Note that `place` does the exact opposite of `extract`.

Parameters
----------
condition : array_like
    An array whose nonzero or True entries indicate the elements of `arr`
    to extract.
arr : array_like
    Input array of the same size as `condition`.

Returns
-------
extract : ndarray
    Rank 1 array of values from `arr` where `condition` is True.

See Also
--------
take, put, copyto, compress, place

Examples
--------
&gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))
&gt;&gt;&gt; arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
&gt;&gt;&gt; condition = np.mod(arr, 3)==0
&gt;&gt;&gt; condition
array([[ True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False]])
&gt;&gt;&gt; np.extract(condition, arr)
array([0, 3, 6, 9])


If `condition` is boolean:

&gt;&gt;&gt; arr[condition]
array([0, 3, 6, 9])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1858</span><span class="keyword">def </span>extract(condition, arr):</div>
<div class="line"><span class="lineno"> 1859</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral">    Return the elements of an array that satisfy some condition.</span></div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral">    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If</span></div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral">    Note that `place` does the exact opposite of `extract`.</span></div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">    condition : array_like</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">        An array whose nonzero or True entries indicate the elements of `arr`</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral">        to extract.</span></div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">    arr : array_like</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral">        Input array of the same size as `condition`.</span></div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral">    extract : ndarray</span></div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">        Rank 1 array of values from `arr` where `condition` is True.</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral">    take, put, copyto, compress, place</span></div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral">    &gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))</span></div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral">    &gt;&gt;&gt; arr</span></div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">    array([[ 0,  1,  2,  3],</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral">           [ 4,  5,  6,  7],</span></div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">           [ 8,  9, 10, 11]])</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">    &gt;&gt;&gt; condition = np.mod(arr, 3)==0</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral">    &gt;&gt;&gt; condition</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">    array([[ True, False, False,  True],</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral">           [False, False,  True, False],</span></div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">           [False,  True, False, False]])</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">    &gt;&gt;&gt; np.extract(condition, arr)</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">    array([0, 3, 6, 9])</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">    If `condition` is boolean:</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">    &gt;&gt;&gt; arr[condition]</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">    array([0, 3, 6, 9])</span></div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1906</span>    <span class="keywordflow">return</span> _nx.take(ravel(arr), nonzero(ravel(condition))[0])</div>
<div class="line"><span class="lineno"> 1907</span> </div>
<div class="line"><span class="lineno"> 1908</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad88c114152e04ed3734835f74c231a74" name="ad88c114152e04ed3734835f74c231a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88c114152e04ed3734835f74c231a74">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.flip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reverse the order of elements in an array along the given axis.

The shape of the array is preserved, but the elements are reordered.

.. versionadded:: 1.12.0

Parameters
----------
m : array_like
    Input array.
axis : None or int or tuple of ints, optional
     Axis or axes along which to flip over. The default,
     axis=None, will flip over all of the axes of the input array.
     If axis is negative it counts from the last to the first axis.

     If axis is a tuple of ints, flipping is performed on all of the axes
     specified in the tuple.

     .. versionchanged:: 1.15.0
        None and tuples of axes are supported

Returns
-------
out : array_like
    A view of `m` with the entries of axis reversed.  Since a view is
    returned, this operation is done in constant time.

See Also
--------
flipud : Flip an array vertically (axis=0).
fliplr : Flip an array horizontally (axis=1).

Notes
-----
flip(m, 0) is equivalent to flipud(m).

flip(m, 1) is equivalent to fliplr(m).

flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.

flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all
positions.

flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at
position 0 and position 1.

Examples
--------
&gt;&gt;&gt; A = np.arange(8).reshape((2,2,2))
&gt;&gt;&gt; A
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
&gt;&gt;&gt; np.flip(A, 0)
array([[[4, 5],
        [6, 7]],
       [[0, 1],
        [2, 3]]])
&gt;&gt;&gt; np.flip(A, 1)
array([[[2, 3],
        [0, 1]],
       [[6, 7],
        [4, 5]]])
&gt;&gt;&gt; np.flip(A)
array([[[7, 6],
        [5, 4]],
       [[3, 2],
        [1, 0]]])
&gt;&gt;&gt; np.flip(A, (0, 2))
array([[[5, 4],
        [7, 6]],
       [[1, 0],
        [3, 2]]])
&gt;&gt;&gt; A = np.random.randn(3,4,5)
&gt;&gt;&gt; np.all(np.flip(A,2) == A[:,:,::-1,...])
True
</pre> <div class="fragment"><div class="line"><span class="lineno">  253</span><span class="keyword">def </span>flip(m, axis=None):</div>
<div class="line"><span class="lineno">  254</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    Reverse the order of elements in an array along the given axis.</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    The shape of the array is preserved, but the elements are reordered.</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    .. versionadded:: 1.12.0</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    m : array_like</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">         Axis or axes along which to flip over. The default,</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">         axis=None, will flip over all of the axes of the input array.</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">         If axis is negative it counts from the last to the first axis.</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">         If axis is a tuple of ints, flipping is performed on all of the axes</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">         specified in the tuple.</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">         .. versionchanged:: 1.15.0</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">            None and tuples of axes are supported</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    out : array_like</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        A view of `m` with the entries of axis reversed.  Since a view is</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        returned, this operation is done in constant time.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    flipud : Flip an array vertically (axis=0).</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    fliplr : Flip an array horizontally (axis=1).</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    flip(m, 0) is equivalent to flipud(m).</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    flip(m, 1) is equivalent to fliplr(m).</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    positions.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    position 0 and position 1.</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    &gt;&gt;&gt; A = np.arange(8).reshape((2,2,2))</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">    &gt;&gt;&gt; A</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">    array([[[0, 1],</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">            [2, 3]],</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">           [[4, 5],</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">            [6, 7]]])</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">    &gt;&gt;&gt; np.flip(A, 0)</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">    array([[[4, 5],</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">            [6, 7]],</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">           [[0, 1],</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">            [2, 3]]])</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    &gt;&gt;&gt; np.flip(A, 1)</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    array([[[2, 3],</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">            [0, 1]],</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">           [[6, 7],</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">            [4, 5]]])</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    &gt;&gt;&gt; np.flip(A)</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    array([[[7, 6],</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">            [5, 4]],</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">           [[3, 2],</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">            [1, 0]]])</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    &gt;&gt;&gt; np.flip(A, (0, 2))</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    array([[[5, 4],</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">            [7, 6]],</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">           [[1, 0],</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">            [3, 2]]])</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    &gt;&gt;&gt; A = np.random.randn(3,4,5)</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    &gt;&gt;&gt; np.all(np.flip(A,2) == A[:,:,::-1,...])</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  333</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(m, <span class="stringliteral">&#39;ndim&#39;</span>):</div>
<div class="line"><span class="lineno">  334</span>        m = asarray(m)</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  336</span>        indexer = (np.s_[::-1],) * m.ndim</div>
<div class="line"><span class="lineno">  337</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  338</span>        axis = _nx.normalize_axis_tuple(axis, m.ndim)</div>
<div class="line"><span class="lineno">  339</span>        indexer = [np.s_[:]] * m.ndim</div>
<div class="line"><span class="lineno">  340</span>        <span class="keywordflow">for</span> ax <span class="keywordflow">in</span> axis:</div>
<div class="line"><span class="lineno">  341</span>            indexer[ax] = np.s_[::-1]</div>
<div class="line"><span class="lineno">  342</span>        indexer = tuple(indexer)</div>
<div class="line"><span class="lineno">  343</span>    <span class="keywordflow">return</span> m[indexer]</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad34816c3b1cf5a22aa4e2ec2d74013a7" name="ad34816c3b1cf5a22aa4e2ec2d74013a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34816c3b1cf5a22aa4e2ec2d74013a7">&#9670;&#160;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.gradient </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>varargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_order</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the gradient of an N-dimensional array.

The gradient is computed using second order accurate central differences
in the interior points and either first or second order accurate one-sides
(forward or backwards) differences at the boundaries.
The returned gradient hence has the same shape as the input array.

Parameters
----------
f : array_like
    An N-dimensional array containing samples of a scalar function.
varargs : list of scalar or array, optional
    Spacing between f values. Default unitary spacing for all dimensions.
    Spacing can be specified using:

    1. single scalar to specify a sample distance for all dimensions.
    2. N scalars to specify a constant sample distance for each dimension.
       i.e. `dx`, `dy`, `dz`, ...
    3. N arrays to specify the coordinates of the values along each
       dimension of F. The length of the array must match the size of
       the corresponding dimension
    4. Any combination of N scalars/arrays with the meaning of 2. and 3.

    If `axis` is given, the number of varargs must equal the number of axes.
    Default: 1.

edge_order : {1, 2}, optional
    Gradient is calculated using N-th order accurate differences
    at the boundaries. Default: 1.

    .. versionadded:: 1.9.1

axis : None or int or tuple of ints, optional
    Gradient is calculated only along the given axis or axes
    The default (axis = None) is to calculate the gradient for all the axes
    of the input array. axis may be negative, in which case it counts from
    the last to the first axis.

    .. versionadded:: 1.11.0

Returns
-------
gradient : ndarray or list of ndarray
    A list of ndarrays (or a single ndarray if there is only one dimension)
    corresponding to the derivatives of f with respect to each dimension.
    Each derivative has the same shape as f.

Examples
--------
&gt;&gt;&gt; f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
&gt;&gt;&gt; np.gradient(f)
array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])
&gt;&gt;&gt; np.gradient(f, 2)
array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])

Spacing can be also specified with an array that represents the coordinates
of the values F along the dimensions.
For instance a uniform spacing:

&gt;&gt;&gt; x = np.arange(f.size)
&gt;&gt;&gt; np.gradient(f, x)
array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])

Or a non uniform one:

&gt;&gt;&gt; x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
&gt;&gt;&gt; np.gradient(f, x)
array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])

For two dimensional arrays, the return will be two arrays ordered by
axis. In this example the first array stands for the gradient in
rows and the second one in columns direction:

&gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
[array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],
       [1. , 1. , 1. ]])]

In this example the spacing is also specified:
uniform for axis=0 and non uniform for axis=1

&gt;&gt;&gt; dx = 2.
&gt;&gt;&gt; y = [1., 1.5, 3.5]
&gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
[array([[ 1. ,  1. , -0.5],
       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],
       [2. , 1.7, 0.5]])]

It is possible to specify how boundaries are treated using `edge_order`

&gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4])
&gt;&gt;&gt; f = x**2
&gt;&gt;&gt; np.gradient(f, edge_order=1)
array([1.,  2.,  4.,  6.,  7.])
&gt;&gt;&gt; np.gradient(f, edge_order=2)
array([0., 2., 4., 6., 8.])

The `axis` keyword can be used to specify a subset of axes of which the
gradient is calculated

&gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]])

Notes
-----
Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous
derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we
minimize the "consistency error" :math:`\\eta_{i}` between the true gradient
and its estimate from a linear combination of the neighboring grid-points:

.. math::

    \\eta_{i} = f_{i}^{\\left(1\\right)} -
                \\left[ \\alpha f\\left(x_{i}\\right) +
                        \\beta f\\left(x_{i} + h_{d}\\right) +
                        \\gamma f\\left(x_{i}-h_{s}\\right)
                \\right]

By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`
with their Taylor series expansion, this translates into solving
the following the linear system:

.. math::

    \\left\\{
        \\begin{array}{r}
            \\alpha+\\beta+\\gamma=0 \\\\
            \\beta h_{d}-\\gamma h_{s}=1 \\\\
            \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0
        \\end{array}
    \\right.

The resulting approximation of :math:`f_{i}^{(1)}` is the following:

.. math::

    \\hat f_{i}^{(1)} =
        \\frac{
            h_{s}^{2}f\\left(x_{i} + h_{d}\\right)
            + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)
            - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}
            { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}
        + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}
                            + h_{s}h_{d}^{2}}{h_{d}
                            + h_{s}}\\right)

It is worth noting that if :math:`h_{s}=h_{d}`
(i.e., data are evenly spaced)
we find the standard second order approximation:

.. math::

    \\hat f_{i}^{(1)}=
        \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}
        + \\mathcal{O}\\left(h^{2}\\right)

With a similar procedure the forward/backward approximations used for
boundaries can be derived.

References
----------
.. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
        (Texts in Applied Mathematics). New York: Springer.
.. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations
        in Geophysical Fluid Dynamics. New York: Springer.
.. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on
        Arbitrarily Spaced Grids,
        Mathematics of Computation 51, no. 184 : 699-706.
        `PDF &lt;http://www.ams.org/journals/mcom/1988-51-184/
        S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&gt;`_.
</pre> <div class="fragment"><div class="line"><span class="lineno">  971</span><span class="keyword">def </span>gradient(f, *varargs, axis=None, edge_order=1):</div>
<div class="line"><span class="lineno">  972</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  973</span><span class="stringliteral">    Return the gradient of an N-dimensional array.</span></div>
<div class="line"><span class="lineno">  974</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  975</span><span class="stringliteral">    The gradient is computed using second order accurate central differences</span></div>
<div class="line"><span class="lineno">  976</span><span class="stringliteral">    in the interior points and either first or second order accurate one-sides</span></div>
<div class="line"><span class="lineno">  977</span><span class="stringliteral">    (forward or backwards) differences at the boundaries.</span></div>
<div class="line"><span class="lineno">  978</span><span class="stringliteral">    The returned gradient hence has the same shape as the input array.</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  981</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  982</span><span class="stringliteral">    f : array_like</span></div>
<div class="line"><span class="lineno">  983</span><span class="stringliteral">        An N-dimensional array containing samples of a scalar function.</span></div>
<div class="line"><span class="lineno">  984</span><span class="stringliteral">    varargs : list of scalar or array, optional</span></div>
<div class="line"><span class="lineno">  985</span><span class="stringliteral">        Spacing between f values. Default unitary spacing for all dimensions.</span></div>
<div class="line"><span class="lineno">  986</span><span class="stringliteral">        Spacing can be specified using:</span></div>
<div class="line"><span class="lineno">  987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  988</span><span class="stringliteral">        1. single scalar to specify a sample distance for all dimensions.</span></div>
<div class="line"><span class="lineno">  989</span><span class="stringliteral">        2. N scalars to specify a constant sample distance for each dimension.</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">           i.e. `dx`, `dy`, `dz`, ...</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">        3. N arrays to specify the coordinates of the values along each</span></div>
<div class="line"><span class="lineno">  992</span><span class="stringliteral">           dimension of F. The length of the array must match the size of</span></div>
<div class="line"><span class="lineno">  993</span><span class="stringliteral">           the corresponding dimension</span></div>
<div class="line"><span class="lineno">  994</span><span class="stringliteral">        4. Any combination of N scalars/arrays with the meaning of 2. and 3.</span></div>
<div class="line"><span class="lineno">  995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  996</span><span class="stringliteral">        If `axis` is given, the number of varargs must equal the number of axes.</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">        Default: 1.</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">    edge_order : {1, 2}, optional</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        Gradient is calculated using N-th order accurate differences</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">        at the boundaries. Default: 1.</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral">        .. versionadded:: 1.9.1</span></div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">    axis : None or int or tuple of ints, optional</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">        Gradient is calculated only along the given axis or axes</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">        The default (axis = None) is to calculate the gradient for all the axes</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">        of the input array. axis may be negative, in which case it counts from</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral">        the last to the first axis.</span></div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">        .. versionadded:: 1.11.0</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    gradient : ndarray or list of ndarray</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">        A list of ndarrays (or a single ndarray if there is only one dimension)</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">        corresponding to the derivatives of f with respect to each dimension.</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">        Each derivative has the same shape as f.</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    &gt;&gt;&gt; f = np.array([1, 2, 4, 7, 11, 16], dtype=float)</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(f)</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(f, 2)</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    Spacing can be also specified with an array that represents the coordinates</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    of the values F along the dimensions.</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    For instance a uniform spacing:</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(f.size)</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(f, x)</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    Or a non uniform one:</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(f, x)</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">    For two dimensional arrays, the return will be two arrays ordered by</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    axis. In this example the first array stands for the gradient in</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">    rows and the second one in columns direction:</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    [array([[ 2.,  2., -1.],</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">           [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">           [1. , 1. , 1. ]])]</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">    In this example the spacing is also specified:</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">    uniform for axis=0 and non uniform for axis=1</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">    &gt;&gt;&gt; dx = 2.</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">    &gt;&gt;&gt; y = [1., 1.5, 3.5]</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">    [array([[ 1. ,  1. , -0.5],</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">           [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">           [2. , 1.7, 0.5]])]</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">    It is possible to specify how boundaries are treated using `edge_order`</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">    &gt;&gt;&gt; f = x**2</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(f, edge_order=1)</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">    array([1.,  2.,  4.,  6.,  7.])</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(f, edge_order=2)</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    array([0., 2., 4., 6., 8.])</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    The `axis` keyword can be used to specify a subset of axes of which the</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">    gradient is calculated</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    array([[ 2.,  2., -1.],</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">           [ 2.,  2., -1.]])</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">    Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    minimize the &quot;consistency error&quot; :math:`\\eta_{i}` between the true gradient</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">    and its estimate from a linear combination of the neighboring grid-points:</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">        \\eta_{i} = f_{i}^{\\left(1\\right)} -</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">                    \\left[ \\alpha f\\left(x_{i}\\right) +</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">                            \\beta f\\left(x_{i} + h_{d}\\right) +</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral">                            \\gamma f\\left(x_{i}-h_{s}\\right)</span></div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">                    \\right]</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral">    with their Taylor series expansion, this translates into solving</span></div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    the following the linear system:</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">        \\left\\{</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">            \\begin{array}{r}</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">                \\alpha+\\beta+\\gamma=0 \\\\</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">                \\beta h_{d}-\\gamma h_{s}=1 \\\\</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">                \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">            \\end{array}</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">        \\right.</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">    The resulting approximation of :math:`f_{i}^{(1)}` is the following:</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">        \\hat f_{i}^{(1)} =</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">            \\frac{</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">                h_{s}^{2}f\\left(x_{i} + h_{d}\\right)</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">                + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">                - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">                { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">            + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">                                + h_{s}h_{d}^{2}}{h_{d}</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">                                + h_{s}}\\right)</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    It is worth noting that if :math:`h_{s}=h_{d}`</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    (i.e., data are evenly spaced)</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    we find the standard second order approximation:</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">        \\hat f_{i}^{(1)}=</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">            \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">            + \\mathcal{O}\\left(h^{2}\\right)</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    With a similar procedure the forward/backward approximations used for</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    boundaries can be derived.</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">            (Texts in Applied Mathematics). New York: Springer.</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">            in Geophysical Fluid Dynamics. New York: Springer.</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">            Arbitrarily Spaced Grids,</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">            Mathematics of Computation 51, no. 184 : 699-706.</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">            `PDF &lt;http://www.ams.org/journals/mcom/1988-51-184/</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&gt;`_.</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1145</span>    f = np.asanyarray(f)</div>
<div class="line"><span class="lineno"> 1146</span>    N = f.ndim  <span class="comment"># number of dimensions</span></div>
<div class="line"><span class="lineno"> 1147</span> </div>
<div class="line"><span class="lineno"> 1148</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1149</span>        axes = tuple(range(N))</div>
<div class="line"><span class="lineno"> 1150</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1151</span>        axes = _nx.normalize_axis_tuple(axis, N)</div>
<div class="line"><span class="lineno"> 1152</span> </div>
<div class="line"><span class="lineno"> 1153</span>    len_axes = len(axes)</div>
<div class="line"><span class="lineno"> 1154</span>    n = len(varargs)</div>
<div class="line"><span class="lineno"> 1155</span>    <span class="keywordflow">if</span> n == 0:</div>
<div class="line"><span class="lineno"> 1156</span>        <span class="comment"># no spacing argument - use 1 in all axes</span></div>
<div class="line"><span class="lineno"> 1157</span>        dx = [1.0] * len_axes</div>
<div class="line"><span class="lineno"> 1158</span>    <span class="keywordflow">elif</span> n == 1 <span class="keywordflow">and</span> np.ndim(varargs[0]) == 0:</div>
<div class="line"><span class="lineno"> 1159</span>        <span class="comment"># single scalar for all axes</span></div>
<div class="line"><span class="lineno"> 1160</span>        dx = varargs * len_axes</div>
<div class="line"><span class="lineno"> 1161</span>    <span class="keywordflow">elif</span> n == len_axes:</div>
<div class="line"><span class="lineno"> 1162</span>        <span class="comment"># scalar or 1d array for each axis</span></div>
<div class="line"><span class="lineno"> 1163</span>        dx = list(varargs)</div>
<div class="line"><span class="lineno"> 1164</span>        <span class="keywordflow">for</span> i, distances <span class="keywordflow">in</span> enumerate(dx):</div>
<div class="line"><span class="lineno"> 1165</span>            distances = np.asanyarray(distances)</div>
<div class="line"><span class="lineno"> 1166</span>            <span class="keywordflow">if</span> distances.ndim == 0:</div>
<div class="line"><span class="lineno"> 1167</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1168</span>            <span class="keywordflow">elif</span> distances.ndim != 1:</div>
<div class="line"><span class="lineno"> 1169</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;distances must be either scalars or 1d&quot;</span>)</div>
<div class="line"><span class="lineno"> 1170</span>            <span class="keywordflow">if</span> len(distances) != f.shape[axes[i]]:</div>
<div class="line"><span class="lineno"> 1171</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;when 1d, distances must match &quot;</span></div>
<div class="line"><span class="lineno"> 1172</span>                                 <span class="stringliteral">&quot;the length of the corresponding dimension&quot;</span>)</div>
<div class="line"><span class="lineno"> 1173</span>            <span class="keywordflow">if</span> np.issubdtype(distances.dtype, np.integer):</div>
<div class="line"><span class="lineno"> 1174</span>                <span class="comment"># Convert numpy integer types to float64 to avoid modular</span></div>
<div class="line"><span class="lineno"> 1175</span>                <span class="comment"># arithmetic in np.diff(distances).</span></div>
<div class="line"><span class="lineno"> 1176</span>                distances = distances.astype(np.float64)</div>
<div class="line"><span class="lineno"> 1177</span>            diffx = np.diff(distances)</div>
<div class="line"><span class="lineno"> 1178</span>            <span class="comment"># if distances are constant reduce to the scalar case</span></div>
<div class="line"><span class="lineno"> 1179</span>            <span class="comment"># since it brings a consistent speedup</span></div>
<div class="line"><span class="lineno"> 1180</span>            <span class="keywordflow">if</span> (diffx == diffx[0]).all():</div>
<div class="line"><span class="lineno"> 1181</span>                diffx = diffx[0]</div>
<div class="line"><span class="lineno"> 1182</span>            dx[i] = diffx</div>
<div class="line"><span class="lineno"> 1183</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1184</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;invalid number of arguments&quot;</span>)</div>
<div class="line"><span class="lineno"> 1185</span> </div>
<div class="line"><span class="lineno"> 1186</span>    <span class="keywordflow">if</span> edge_order &gt; 2:</div>
<div class="line"><span class="lineno"> 1187</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;&#39;edge_order&#39; greater than 2 not supported&quot;</span>)</div>
<div class="line"><span class="lineno"> 1188</span> </div>
<div class="line"><span class="lineno"> 1189</span>    <span class="comment"># use central differences on interior and one-sided differences on the</span></div>
<div class="line"><span class="lineno"> 1190</span>    <span class="comment"># endpoints. This preserves second order-accuracy over the full domain.</span></div>
<div class="line"><span class="lineno"> 1191</span> </div>
<div class="line"><span class="lineno"> 1192</span>    outvals = []</div>
<div class="line"><span class="lineno"> 1193</span> </div>
<div class="line"><span class="lineno"> 1194</span>    <span class="comment"># create slice objects --- initially all are [:, :, ..., :]</span></div>
<div class="line"><span class="lineno"> 1195</span>    slice1 = [slice(<span class="keywordtype">None</span>)]*N</div>
<div class="line"><span class="lineno"> 1196</span>    slice2 = [slice(<span class="keywordtype">None</span>)]*N</div>
<div class="line"><span class="lineno"> 1197</span>    slice3 = [slice(<span class="keywordtype">None</span>)]*N</div>
<div class="line"><span class="lineno"> 1198</span>    slice4 = [slice(<span class="keywordtype">None</span>)]*N</div>
<div class="line"><span class="lineno"> 1199</span> </div>
<div class="line"><span class="lineno"> 1200</span>    otype = f.dtype</div>
<div class="line"><span class="lineno"> 1201</span>    <span class="keywordflow">if</span> otype.type <span class="keywordflow">is</span> np.datetime64:</div>
<div class="line"><span class="lineno"> 1202</span>        <span class="comment"># the timedelta dtype with the same unit information</span></div>
<div class="line"><span class="lineno"> 1203</span>        otype = np.dtype(otype.name.replace(<span class="stringliteral">&#39;datetime&#39;</span>, <span class="stringliteral">&#39;timedelta&#39;</span>))</div>
<div class="line"><span class="lineno"> 1204</span>        <span class="comment"># view as timedelta to allow addition</span></div>
<div class="line"><span class="lineno"> 1205</span>        f = f.view(otype)</div>
<div class="line"><span class="lineno"> 1206</span>    <span class="keywordflow">elif</span> otype.type <span class="keywordflow">is</span> np.timedelta64:</div>
<div class="line"><span class="lineno"> 1207</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1208</span>    <span class="keywordflow">elif</span> np.issubdtype(otype, np.inexact):</div>
<div class="line"><span class="lineno"> 1209</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 1210</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1211</span>        <span class="comment"># All other types convert to floating point.</span></div>
<div class="line"><span class="lineno"> 1212</span>        <span class="comment"># First check if f is a numpy integer type; if so, convert f to float64</span></div>
<div class="line"><span class="lineno"> 1213</span>        <span class="comment"># to avoid modular arithmetic when computing the changes in f.</span></div>
<div class="line"><span class="lineno"> 1214</span>        <span class="keywordflow">if</span> np.issubdtype(otype, np.integer):</div>
<div class="line"><span class="lineno"> 1215</span>            f = f.astype(np.float64)</div>
<div class="line"><span class="lineno"> 1216</span>        otype = np.float64</div>
<div class="line"><span class="lineno"> 1217</span> </div>
<div class="line"><span class="lineno"> 1218</span>    <span class="keywordflow">for</span> axis, ax_dx <span class="keywordflow">in</span> zip(axes, dx):</div>
<div class="line"><span class="lineno"> 1219</span>        <span class="keywordflow">if</span> f.shape[axis] &lt; edge_order + 1:</div>
<div class="line"><span class="lineno"> 1220</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1221</span>                <span class="stringliteral">&quot;Shape of array too small to calculate a numerical gradient, &quot;</span></div>
<div class="line"><span class="lineno"> 1222</span>                <span class="stringliteral">&quot;at least (edge_order + 1) elements are required.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1223</span>        <span class="comment"># result allocation</span></div>
<div class="line"><span class="lineno"> 1224</span>        out = np.empty_like(f, dtype=otype)</div>
<div class="line"><span class="lineno"> 1225</span> </div>
<div class="line"><span class="lineno"> 1226</span>        <span class="comment"># spacing for the current axis</span></div>
<div class="line"><span class="lineno"> 1227</span>        uniform_spacing = np.ndim(ax_dx) == 0</div>
<div class="line"><span class="lineno"> 1228</span> </div>
<div class="line"><span class="lineno"> 1229</span>        <span class="comment"># Numerical differentiation: 2nd order interior</span></div>
<div class="line"><span class="lineno"> 1230</span>        slice1[axis] = slice(1, -1)</div>
<div class="line"><span class="lineno"> 1231</span>        slice2[axis] = slice(<span class="keywordtype">None</span>, -2)</div>
<div class="line"><span class="lineno"> 1232</span>        slice3[axis] = slice(1, -1)</div>
<div class="line"><span class="lineno"> 1233</span>        slice4[axis] = slice(2, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1234</span> </div>
<div class="line"><span class="lineno"> 1235</span>        <span class="keywordflow">if</span> uniform_spacing:</div>
<div class="line"><span class="lineno"> 1236</span>            out[tuple(slice1)] = (f[tuple(slice4)] - f[tuple(slice2)]) / (2. * ax_dx)</div>
<div class="line"><span class="lineno"> 1237</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1238</span>            dx1 = ax_dx[0:-1]</div>
<div class="line"><span class="lineno"> 1239</span>            dx2 = ax_dx[1:]</div>
<div class="line"><span class="lineno"> 1240</span>            a = -(dx2)/(dx1 * (dx1 + dx2))</div>
<div class="line"><span class="lineno"> 1241</span>            b = (dx2 - dx1) / (dx1 * dx2)</div>
<div class="line"><span class="lineno"> 1242</span>            c = dx1 / (dx2 * (dx1 + dx2))</div>
<div class="line"><span class="lineno"> 1243</span>            <span class="comment"># fix the shape for broadcasting</span></div>
<div class="line"><span class="lineno"> 1244</span>            shape = np.ones(N, dtype=int)</div>
<div class="line"><span class="lineno"> 1245</span>            shape[axis] = -1</div>
<div class="line"><span class="lineno"> 1246</span>            a.shape = b.shape = c.shape = shape</div>
<div class="line"><span class="lineno"> 1247</span>            <span class="comment"># 1D equivalent -- out[1:-1] = a * f[:-2] + b * f[1:-1] + c * f[2:]</span></div>
<div class="line"><span class="lineno"> 1248</span>            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]</div>
<div class="line"><span class="lineno"> 1249</span> </div>
<div class="line"><span class="lineno"> 1250</span>        <span class="comment"># Numerical differentiation: 1st order edges</span></div>
<div class="line"><span class="lineno"> 1251</span>        <span class="keywordflow">if</span> edge_order == 1:</div>
<div class="line"><span class="lineno"> 1252</span>            slice1[axis] = 0</div>
<div class="line"><span class="lineno"> 1253</span>            slice2[axis] = 1</div>
<div class="line"><span class="lineno"> 1254</span>            slice3[axis] = 0</div>
<div class="line"><span class="lineno"> 1255</span>            dx_0 = ax_dx <span class="keywordflow">if</span> uniform_spacing <span class="keywordflow">else</span> ax_dx[0]</div>
<div class="line"><span class="lineno"> 1256</span>            <span class="comment"># 1D equivalent -- out[0] = (f[1] - f[0]) / (x[1] - x[0])</span></div>
<div class="line"><span class="lineno"> 1257</span>            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_0</div>
<div class="line"><span class="lineno"> 1258</span> </div>
<div class="line"><span class="lineno"> 1259</span>            slice1[axis] = -1</div>
<div class="line"><span class="lineno"> 1260</span>            slice2[axis] = -1</div>
<div class="line"><span class="lineno"> 1261</span>            slice3[axis] = -2</div>
<div class="line"><span class="lineno"> 1262</span>            dx_n = ax_dx <span class="keywordflow">if</span> uniform_spacing <span class="keywordflow">else</span> ax_dx[-1]</div>
<div class="line"><span class="lineno"> 1263</span>            <span class="comment"># 1D equivalent -- out[-1] = (f[-1] - f[-2]) / (x[-1] - x[-2])</span></div>
<div class="line"><span class="lineno"> 1264</span>            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_n</div>
<div class="line"><span class="lineno"> 1265</span> </div>
<div class="line"><span class="lineno"> 1266</span>        <span class="comment"># Numerical differentiation: 2nd order edges</span></div>
<div class="line"><span class="lineno"> 1267</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1268</span>            slice1[axis] = 0</div>
<div class="line"><span class="lineno"> 1269</span>            slice2[axis] = 0</div>
<div class="line"><span class="lineno"> 1270</span>            slice3[axis] = 1</div>
<div class="line"><span class="lineno"> 1271</span>            slice4[axis] = 2</div>
<div class="line"><span class="lineno"> 1272</span>            <span class="keywordflow">if</span> uniform_spacing:</div>
<div class="line"><span class="lineno"> 1273</span>                a = -1.5 / ax_dx</div>
<div class="line"><span class="lineno"> 1274</span>                b = 2. / ax_dx</div>
<div class="line"><span class="lineno"> 1275</span>                c = -0.5 / ax_dx</div>
<div class="line"><span class="lineno"> 1276</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1277</span>                dx1 = ax_dx[0]</div>
<div class="line"><span class="lineno"> 1278</span>                dx2 = ax_dx[1]</div>
<div class="line"><span class="lineno"> 1279</span>                a = -(2. * dx1 + dx2)/(dx1 * (dx1 + dx2))</div>
<div class="line"><span class="lineno"> 1280</span>                b = (dx1 + dx2) / (dx1 * dx2)</div>
<div class="line"><span class="lineno"> 1281</span>                c = - dx1 / (dx2 * (dx1 + dx2))</div>
<div class="line"><span class="lineno"> 1282</span>            <span class="comment"># 1D equivalent -- out[0] = a * f[0] + b * f[1] + c * f[2]</span></div>
<div class="line"><span class="lineno"> 1283</span>            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]</div>
<div class="line"><span class="lineno"> 1284</span> </div>
<div class="line"><span class="lineno"> 1285</span>            slice1[axis] = -1</div>
<div class="line"><span class="lineno"> 1286</span>            slice2[axis] = -3</div>
<div class="line"><span class="lineno"> 1287</span>            slice3[axis] = -2</div>
<div class="line"><span class="lineno"> 1288</span>            slice4[axis] = -1</div>
<div class="line"><span class="lineno"> 1289</span>            <span class="keywordflow">if</span> uniform_spacing:</div>
<div class="line"><span class="lineno"> 1290</span>                a = 0.5 / ax_dx</div>
<div class="line"><span class="lineno"> 1291</span>                b = -2. / ax_dx</div>
<div class="line"><span class="lineno"> 1292</span>                c = 1.5 / ax_dx</div>
<div class="line"><span class="lineno"> 1293</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1294</span>                dx1 = ax_dx[-2]</div>
<div class="line"><span class="lineno"> 1295</span>                dx2 = ax_dx[-1]</div>
<div class="line"><span class="lineno"> 1296</span>                a = (dx2) / (dx1 * (dx1 + dx2))</div>
<div class="line"><span class="lineno"> 1297</span>                b = - (dx2 + dx1) / (dx1 * dx2)</div>
<div class="line"><span class="lineno"> 1298</span>                c = (2. * dx2 + dx1) / (dx2 * (dx1 + dx2))</div>
<div class="line"><span class="lineno"> 1299</span>            <span class="comment"># 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]</span></div>
<div class="line"><span class="lineno"> 1300</span>            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]</div>
<div class="line"><span class="lineno"> 1301</span> </div>
<div class="line"><span class="lineno"> 1302</span>        outvals.append(out)</div>
<div class="line"><span class="lineno"> 1303</span> </div>
<div class="line"><span class="lineno"> 1304</span>        <span class="comment"># reset the slice object in this dimension to &quot;:&quot;</span></div>
<div class="line"><span class="lineno"> 1305</span>        slice1[axis] = slice(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1306</span>        slice2[axis] = slice(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1307</span>        slice3[axis] = slice(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1308</span>        slice4[axis] = slice(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1309</span> </div>
<div class="line"><span class="lineno"> 1310</span>    <span class="keywordflow">if</span> len_axes == 1:</div>
<div class="line"><span class="lineno"> 1311</span>        <span class="keywordflow">return</span> outvals[0]</div>
<div class="line"><span class="lineno"> 1312</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1313</span>        <span class="keywordflow">return</span> outvals</div>
<div class="line"><span class="lineno"> 1314</span> </div>
<div class="line"><span class="lineno"> 1315</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad6daf481775305b9274f38dbf7f28075" name="ad6daf481775305b9274f38dbf7f28075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6daf481775305b9274f38dbf7f28075">&#9670;&#160;</a></span>hamming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.hamming </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Hamming window.

The Hamming window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray
    The window, with the maximum value normalized to one (the value
    one appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hanning, kaiser

Notes
-----
The Hamming window is defined as

.. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
           \\qquad 0 \\leq n \\leq M-1

The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
and is described in Blackman and Tukey. It was recommended for
smoothing the truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
       University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 425.

Examples
--------
&gt;&gt;&gt; np.hamming(12)
array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary
        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
        0.15302337,  0.08      ])

Plot the window and the frequency response:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from numpy.fft import fft, fftshift
&gt;&gt;&gt; window = np.hamming(51)
&gt;&gt;&gt; plt.plot(window)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Hamming window")
Text(0.5, 1.0, 'Hamming window')
&gt;&gt;&gt; plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
&gt;&gt;&gt; plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; plt.figure()
&lt;Figure size 640x480 with 0 Axes&gt;
&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = np.abs(fftshift(A))
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(mag)
&gt;&gt;&gt; response = np.clip(response, -100, 100)
&gt;&gt;&gt; plt.plot(freq, response)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Frequency response of Hamming window")
Text(0.5, 1.0, 'Frequency response of Hamming window')
&gt;&gt;&gt; plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
&gt;&gt;&gt; plt.axis('tight')
...
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3180</span><span class="keyword">def </span>hamming(M):</div>
<div class="line"><span class="lineno"> 3181</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3182</span><span class="stringliteral">    Return the Hamming window.</span></div>
<div class="line"><span class="lineno"> 3183</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3184</span><span class="stringliteral">    The Hamming window is a taper formed by using a weighted cosine.</span></div>
<div class="line"><span class="lineno"> 3185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3186</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3187</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3188</span><span class="stringliteral">    M : int</span></div>
<div class="line"><span class="lineno"> 3189</span><span class="stringliteral">        Number of points in the output window. If zero or less, an</span></div>
<div class="line"><span class="lineno"> 3190</span><span class="stringliteral">        empty array is returned.</span></div>
<div class="line"><span class="lineno"> 3191</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3192</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3193</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3194</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 3195</span><span class="stringliteral">        The window, with the maximum value normalized to one (the value</span></div>
<div class="line"><span class="lineno"> 3196</span><span class="stringliteral">        one appears only if the number of samples is odd).</span></div>
<div class="line"><span class="lineno"> 3197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3198</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3199</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3200</span><span class="stringliteral">    bartlett, blackman, hanning, kaiser</span></div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral">    The Hamming window is defined as</span></div>
<div class="line"><span class="lineno"> 3205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3206</span><span class="stringliteral">    .. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span></div>
<div class="line"><span class="lineno"> 3207</span><span class="stringliteral">               \\qquad 0 \\leq n \\leq M-1</span></div>
<div class="line"><span class="lineno"> 3208</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3209</span><span class="stringliteral">    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey</span></div>
<div class="line"><span class="lineno"> 3210</span><span class="stringliteral">    and is described in Blackman and Tukey. It was recommended for</span></div>
<div class="line"><span class="lineno"> 3211</span><span class="stringliteral">    smoothing the truncated autocovariance function in the time domain.</span></div>
<div class="line"><span class="lineno"> 3212</span><span class="stringliteral">    Most references to the Hamming window come from the signal processing</span></div>
<div class="line"><span class="lineno"> 3213</span><span class="stringliteral">    literature, where it is used as one of many windowing functions for</span></div>
<div class="line"><span class="lineno"> 3214</span><span class="stringliteral">    smoothing values.  It is also known as an apodization (which means</span></div>
<div class="line"><span class="lineno"> 3215</span><span class="stringliteral">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span></div>
<div class="line"><span class="lineno"> 3216</span><span class="stringliteral">    and end of the sampled signal) or tapering function.</span></div>
<div class="line"><span class="lineno"> 3217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3218</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3219</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3220</span><span class="stringliteral">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral">           spectra, Dover Publications, New York.</span></div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span></div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral">           University of Alberta Press, 1975, pp. 109-110.</span></div>
<div class="line"><span class="lineno"> 3224</span><span class="stringliteral">    .. [3] Wikipedia, &quot;Window function&quot;,</span></div>
<div class="line"><span class="lineno"> 3225</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Window_function</span></div>
<div class="line"><span class="lineno"> 3226</span><span class="stringliteral">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span></div>
<div class="line"><span class="lineno"> 3227</span><span class="stringliteral">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span></div>
<div class="line"><span class="lineno"> 3228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3229</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3230</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3231</span><span class="stringliteral">    &gt;&gt;&gt; np.hamming(12)</span></div>
<div class="line"><span class="lineno"> 3232</span><span class="stringliteral">    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary</span></div>
<div class="line"><span class="lineno"> 3233</span><span class="stringliteral">            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,</span></div>
<div class="line"><span class="lineno"> 3234</span><span class="stringliteral">            0.15302337,  0.08      ])</span></div>
<div class="line"><span class="lineno"> 3235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3236</span><span class="stringliteral">    Plot the window and the frequency response:</span></div>
<div class="line"><span class="lineno"> 3237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3238</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3239</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span></div>
<div class="line"><span class="lineno"> 3240</span><span class="stringliteral">    &gt;&gt;&gt; window = np.hamming(51)</span></div>
<div class="line"><span class="lineno"> 3241</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(window)</span></div>
<div class="line"><span class="lineno"> 3242</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3243</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Hamming window&quot;)</span></div>
<div class="line"><span class="lineno"> 3244</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Hamming window&#39;)</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral">    Text(0, 0.5, &#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">    Text(0.5, 0, &#39;Sample&#39;)</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral">    &lt;Figure size 640x480 with 0 Axes&gt;</span></div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span></div>
<div class="line"><span class="lineno"> 3256</span><span class="stringliteral">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span></div>
<div class="line"><span class="lineno"> 3257</span><span class="stringliteral">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span></div>
<div class="line"><span class="lineno"> 3258</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(freq, response)</span></div>
<div class="line"><span class="lineno"> 3259</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3260</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Hamming window&quot;)</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Frequency response of Hamming window&#39;)</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span></div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span></div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span></div>
<div class="line"><span class="lineno"> 3265</span><span class="stringliteral">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span></div>
<div class="line"><span class="lineno"> 3266</span><span class="stringliteral">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span></div>
<div class="line"><span class="lineno"> 3267</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 3268</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3271</span>    <span class="keywordflow">if</span> M &lt; 1:</div>
<div class="line"><span class="lineno"> 3272</span>        <span class="keywordflow">return</span> array([], dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 3273</span>    <span class="keywordflow">if</span> M == 1:</div>
<div class="line"><span class="lineno"> 3274</span>        <span class="keywordflow">return</span> ones(1, dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 3275</span>    n = arange(1-M, M, 2)</div>
<div class="line"><span class="lineno"> 3276</span>    <span class="keywordflow">return</span> 0.54 + 0.46*cos(pi*n/(M-1))</div>
<div class="line"><span class="lineno"> 3277</span> </div>
<div class="line"><span class="lineno"> 3278</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5485a32d8c4e900a028bf62da520be04" name="a5485a32d8c4e900a028bf62da520be04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5485a32d8c4e900a028bf62da520be04">&#9670;&#160;</a></span>hanning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.hanning </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Hanning window.

The Hanning window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray, shape(M,)
    The window, with the maximum value normalized to one (the value
    one appears only if `M` is odd).

See Also
--------
bartlett, blackman, hamming, kaiser

Notes
-----
The Hanning window is defined as

.. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
           \\qquad 0 \\leq n \\leq M-1

The Hanning was named for Julius von Hann, an Austrian meteorologist.
It is also known as the Cosine Bell. Some authors prefer that it be
called a Hann window, to help avoid confusion with the very similar
Hamming window.

Most references to the Hanning window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
       The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 425.

Examples
--------
&gt;&gt;&gt; np.hanning(12)
array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,
       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,
       0.07937323, 0.        ])

Plot the window and its frequency response:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from numpy.fft import fft, fftshift
&gt;&gt;&gt; window = np.hanning(51)
&gt;&gt;&gt; plt.plot(window)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Hann window")
Text(0.5, 1.0, 'Hann window')
&gt;&gt;&gt; plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
&gt;&gt;&gt; plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; plt.figure()
&lt;Figure size 640x480 with 0 Axes&gt;
&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = np.abs(fftshift(A))
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
&gt;&gt;&gt; response = np.clip(response, -100, 100)
&gt;&gt;&gt; plt.plot(freq, response)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Frequency response of the Hann window")
Text(0.5, 1.0, 'Frequency response of the Hann window')
&gt;&gt;&gt; plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
&gt;&gt;&gt; plt.axis('tight')
...
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3076</span><span class="keyword">def </span>hanning(M):</div>
<div class="line"><span class="lineno"> 3077</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3078</span><span class="stringliteral">    Return the Hanning window.</span></div>
<div class="line"><span class="lineno"> 3079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3080</span><span class="stringliteral">    The Hanning window is a taper formed by using a weighted cosine.</span></div>
<div class="line"><span class="lineno"> 3081</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3082</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3083</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3084</span><span class="stringliteral">    M : int</span></div>
<div class="line"><span class="lineno"> 3085</span><span class="stringliteral">        Number of points in the output window. If zero or less, an</span></div>
<div class="line"><span class="lineno"> 3086</span><span class="stringliteral">        empty array is returned.</span></div>
<div class="line"><span class="lineno"> 3087</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3088</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3089</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3090</span><span class="stringliteral">    out : ndarray, shape(M,)</span></div>
<div class="line"><span class="lineno"> 3091</span><span class="stringliteral">        The window, with the maximum value normalized to one (the value</span></div>
<div class="line"><span class="lineno"> 3092</span><span class="stringliteral">        one appears only if `M` is odd).</span></div>
<div class="line"><span class="lineno"> 3093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3094</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3095</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3096</span><span class="stringliteral">    bartlett, blackman, hamming, kaiser</span></div>
<div class="line"><span class="lineno"> 3097</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3098</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3099</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3100</span><span class="stringliteral">    The Hanning window is defined as</span></div>
<div class="line"><span class="lineno"> 3101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3102</span><span class="stringliteral">    .. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span></div>
<div class="line"><span class="lineno"> 3103</span><span class="stringliteral">               \\qquad 0 \\leq n \\leq M-1</span></div>
<div class="line"><span class="lineno"> 3104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3105</span><span class="stringliteral">    The Hanning was named for Julius von Hann, an Austrian meteorologist.</span></div>
<div class="line"><span class="lineno"> 3106</span><span class="stringliteral">    It is also known as the Cosine Bell. Some authors prefer that it be</span></div>
<div class="line"><span class="lineno"> 3107</span><span class="stringliteral">    called a Hann window, to help avoid confusion with the very similar</span></div>
<div class="line"><span class="lineno"> 3108</span><span class="stringliteral">    Hamming window.</span></div>
<div class="line"><span class="lineno"> 3109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3110</span><span class="stringliteral">    Most references to the Hanning window come from the signal processing</span></div>
<div class="line"><span class="lineno"> 3111</span><span class="stringliteral">    literature, where it is used as one of many windowing functions for</span></div>
<div class="line"><span class="lineno"> 3112</span><span class="stringliteral">    smoothing values.  It is also known as an apodization (which means</span></div>
<div class="line"><span class="lineno"> 3113</span><span class="stringliteral">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span></div>
<div class="line"><span class="lineno"> 3114</span><span class="stringliteral">    and end of the sampled signal) or tapering function.</span></div>
<div class="line"><span class="lineno"> 3115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3116</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3117</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3118</span><span class="stringliteral">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span></div>
<div class="line"><span class="lineno"> 3119</span><span class="stringliteral">           spectra, Dover Publications, New York.</span></div>
<div class="line"><span class="lineno"> 3120</span><span class="stringliteral">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span></div>
<div class="line"><span class="lineno"> 3121</span><span class="stringliteral">           The University of Alberta Press, 1975, pp. 106-108.</span></div>
<div class="line"><span class="lineno"> 3122</span><span class="stringliteral">    .. [3] Wikipedia, &quot;Window function&quot;,</span></div>
<div class="line"><span class="lineno"> 3123</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Window_function</span></div>
<div class="line"><span class="lineno"> 3124</span><span class="stringliteral">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span></div>
<div class="line"><span class="lineno"> 3125</span><span class="stringliteral">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span></div>
<div class="line"><span class="lineno"> 3126</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3127</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3128</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3129</span><span class="stringliteral">    &gt;&gt;&gt; np.hanning(12)</span></div>
<div class="line"><span class="lineno"> 3130</span><span class="stringliteral">    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,</span></div>
<div class="line"><span class="lineno"> 3131</span><span class="stringliteral">           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,</span></div>
<div class="line"><span class="lineno"> 3132</span><span class="stringliteral">           0.07937323, 0.        ])</span></div>
<div class="line"><span class="lineno"> 3133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3134</span><span class="stringliteral">    Plot the window and its frequency response:</span></div>
<div class="line"><span class="lineno"> 3135</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3136</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3137</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span></div>
<div class="line"><span class="lineno"> 3138</span><span class="stringliteral">    &gt;&gt;&gt; window = np.hanning(51)</span></div>
<div class="line"><span class="lineno"> 3139</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(window)</span></div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Hann window&quot;)</span></div>
<div class="line"><span class="lineno"> 3142</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Hann window&#39;)</span></div>
<div class="line"><span class="lineno"> 3143</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span></div>
<div class="line"><span class="lineno"> 3144</span><span class="stringliteral">    Text(0, 0.5, &#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 3145</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span></div>
<div class="line"><span class="lineno"> 3146</span><span class="stringliteral">    Text(0.5, 0, &#39;Sample&#39;)</span></div>
<div class="line"><span class="lineno"> 3147</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3149</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3150</span><span class="stringliteral">    &lt;Figure size 640x480 with 0 Axes&gt;</span></div>
<div class="line"><span class="lineno"> 3151</span><span class="stringliteral">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span></div>
<div class="line"><span class="lineno"> 3152</span><span class="stringliteral">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span></div>
<div class="line"><span class="lineno"> 3153</span><span class="stringliteral">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span></div>
<div class="line"><span class="lineno"> 3154</span><span class="stringliteral">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span></div>
<div class="line"><span class="lineno"> 3155</span><span class="stringliteral">    ...     response = 20 * np.log10(mag)</span></div>
<div class="line"><span class="lineno"> 3156</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 3157</span><span class="stringliteral">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span></div>
<div class="line"><span class="lineno"> 3158</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(freq, response)</span></div>
<div class="line"><span class="lineno"> 3159</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3160</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Hann window&quot;)</span></div>
<div class="line"><span class="lineno"> 3161</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Frequency response of the Hann window&#39;)</span></div>
<div class="line"><span class="lineno"> 3162</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span></div>
<div class="line"><span class="lineno"> 3163</span><span class="stringliteral">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span></div>
<div class="line"><span class="lineno"> 3164</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span></div>
<div class="line"><span class="lineno"> 3165</span><span class="stringliteral">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span></div>
<div class="line"><span class="lineno"> 3166</span><span class="stringliteral">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span></div>
<div class="line"><span class="lineno"> 3167</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno"> 3168</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3170</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3171</span>    <span class="keywordflow">if</span> M &lt; 1:</div>
<div class="line"><span class="lineno"> 3172</span>        <span class="keywordflow">return</span> array([], dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 3173</span>    <span class="keywordflow">if</span> M == 1:</div>
<div class="line"><span class="lineno"> 3174</span>        <span class="keywordflow">return</span> ones(1, dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 3175</span>    n = arange(1-M, M, 2)</div>
<div class="line"><span class="lineno"> 3176</span>    <span class="keywordflow">return</span> 0.5 + 0.5*cos(pi*n/(M-1))</div>
<div class="line"><span class="lineno"> 3177</span> </div>
<div class="line"><span class="lineno"> 3178</span> </div>
<div class="line"><span class="lineno"> 3179</span><span class="preprocessor">@set_module(&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a56c6f434b7fb3ba18363854522256b98" name="a56c6f434b7fb3ba18363854522256b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c6f434b7fb3ba18363854522256b98">&#9670;&#160;</a></span>i0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.i0 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Modified Bessel function of the first kind, order 0.

Usually denoted :math:`I_0`.

Parameters
----------
x : array_like of float
    Argument of the Bessel function.

Returns
-------
out : ndarray, shape = x.shape, dtype = float
    The modified Bessel function evaluated at each of the elements of `x`.

See Also
--------
scipy.special.i0, scipy.special.iv, scipy.special.ive

Notes
-----
The scipy implementation is recommended over this function: it is a
proper ufunc written in C, and more than an order of magnitude faster.

We use the algorithm published by Clenshaw [1]_ and referenced by
Abramowitz and Stegun [2]_, for which the function domain is
partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
polynomial expansions are employed in each interval. Relative error on
the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).

References
----------
.. [1] C. W. Clenshaw, "Chebyshev series for mathematical functions", in
       *National Physical Laboratory Mathematical Tables*, vol. 5, London:
       Her Majesty's Stationery Office, 1962.
.. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
       Functions*, 10th printing, New York: Dover, 1964, pp. 379.
       https://personal.math.ubc.ca/~cbm/aands/page_379.htm
.. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero

Examples
--------
&gt;&gt;&gt; np.i0(0.)
array(1.0)
&gt;&gt;&gt; np.i0([0, 1, 2, 3])
array([1.        , 1.26606588, 2.2795853 , 4.88079259])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3368</span><span class="keyword">def </span>i0(x):</div>
<div class="line"><span class="lineno"> 3369</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3370</span><span class="stringliteral">    Modified Bessel function of the first kind, order 0.</span></div>
<div class="line"><span class="lineno"> 3371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3372</span><span class="stringliteral">    Usually denoted :math:`I_0`.</span></div>
<div class="line"><span class="lineno"> 3373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3374</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3375</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3376</span><span class="stringliteral">    x : array_like of float</span></div>
<div class="line"><span class="lineno"> 3377</span><span class="stringliteral">        Argument of the Bessel function.</span></div>
<div class="line"><span class="lineno"> 3378</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3379</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3380</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3381</span><span class="stringliteral">    out : ndarray, shape = x.shape, dtype = float</span></div>
<div class="line"><span class="lineno"> 3382</span><span class="stringliteral">        The modified Bessel function evaluated at each of the elements of `x`.</span></div>
<div class="line"><span class="lineno"> 3383</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3384</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3385</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3386</span><span class="stringliteral">    scipy.special.i0, scipy.special.iv, scipy.special.ive</span></div>
<div class="line"><span class="lineno"> 3387</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3388</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3389</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3390</span><span class="stringliteral">    The scipy implementation is recommended over this function: it is a</span></div>
<div class="line"><span class="lineno"> 3391</span><span class="stringliteral">    proper ufunc written in C, and more than an order of magnitude faster.</span></div>
<div class="line"><span class="lineno"> 3392</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3393</span><span class="stringliteral">    We use the algorithm published by Clenshaw [1]_ and referenced by</span></div>
<div class="line"><span class="lineno"> 3394</span><span class="stringliteral">    Abramowitz and Stegun [2]_, for which the function domain is</span></div>
<div class="line"><span class="lineno"> 3395</span><span class="stringliteral">    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev</span></div>
<div class="line"><span class="lineno"> 3396</span><span class="stringliteral">    polynomial expansions are employed in each interval. Relative error on</span></div>
<div class="line"><span class="lineno"> 3397</span><span class="stringliteral">    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a</span></div>
<div class="line"><span class="lineno"> 3398</span><span class="stringliteral">    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</span></div>
<div class="line"><span class="lineno"> 3399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3400</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3401</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3402</span><span class="stringliteral">    .. [1] C. W. Clenshaw, &quot;Chebyshev series for mathematical functions&quot;, in</span></div>
<div class="line"><span class="lineno"> 3403</span><span class="stringliteral">           *National Physical Laboratory Mathematical Tables*, vol. 5, London:</span></div>
<div class="line"><span class="lineno"> 3404</span><span class="stringliteral">           Her Majesty&#39;s Stationery Office, 1962.</span></div>
<div class="line"><span class="lineno"> 3405</span><span class="stringliteral">    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical</span></div>
<div class="line"><span class="lineno"> 3406</span><span class="stringliteral">           Functions*, 10th printing, New York: Dover, 1964, pp. 379.</span></div>
<div class="line"><span class="lineno"> 3407</span><span class="stringliteral">           https://personal.math.ubc.ca/~cbm/aands/page_379.htm</span></div>
<div class="line"><span class="lineno"> 3408</span><span class="stringliteral">    .. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero</span></div>
<div class="line"><span class="lineno"> 3409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3410</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3411</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3412</span><span class="stringliteral">    &gt;&gt;&gt; np.i0(0.)</span></div>
<div class="line"><span class="lineno"> 3413</span><span class="stringliteral">    array(1.0)</span></div>
<div class="line"><span class="lineno"> 3414</span><span class="stringliteral">    &gt;&gt;&gt; np.i0([0, 1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 3415</span><span class="stringliteral">    array([1.        , 1.26606588, 2.2795853 , 4.88079259])</span></div>
<div class="line"><span class="lineno"> 3416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3417</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3418</span>    x = np.asanyarray(x)</div>
<div class="line"><span class="lineno"> 3419</span>    <span class="keywordflow">if</span> x.dtype.kind == <span class="stringliteral">&#39;c&#39;</span>:</div>
<div class="line"><span class="lineno"> 3420</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;i0 not supported for complex values&quot;</span>)</div>
<div class="line"><span class="lineno"> 3421</span>    <span class="keywordflow">if</span> x.dtype.kind != <span class="stringliteral">&#39;f&#39;</span>:</div>
<div class="line"><span class="lineno"> 3422</span>        x = x.astype(float)</div>
<div class="line"><span class="lineno"> 3423</span>    x = np.abs(x)</div>
<div class="line"><span class="lineno"> 3424</span>    <span class="keywordflow">return</span> piecewise(x, [x &lt;= 8.0], [_i0_1, _i0_2])</div>
<div class="line"><span class="lineno"> 3425</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0b6af9b1d56f8f1d7d88ffcc050bed3" name="ae0b6af9b1d56f8f1d7d88ffcc050bed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b6af9b1d56f8f1d7d88ffcc050bed3">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.insert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Insert values along the given axis before the given indices.

Parameters
----------
arr : array_like
    Input array.
obj : int, slice or sequence of ints
    Object that defines the index or indices before which `values` is
    inserted.

    .. versionadded:: 1.8.0

    Support for multiple insertions when `obj` is a single scalar or a
    sequence with one element (similar to calling insert multiple
    times).
values : array_like
    Values to insert into `arr`. If the type of `values` is different
    from that of `arr`, `values` is converted to the type of `arr`.
    `values` should be shaped so that ``arr[...,obj,...] = values``
    is legal.
axis : int, optional
    Axis along which to insert `values`.  If `axis` is None then `arr`
    is flattened first.

Returns
-------
out : ndarray
    A copy of `arr` with `values` inserted.  Note that `insert`
    does not occur in-place: a new array is returned. If
    `axis` is None, `out` is a flattened array.

See Also
--------
append : Append elements at the end of an array.
concatenate : Join a sequence of arrays along an existing axis.
delete : Delete elements from an array.

Notes
-----
Note that for higher dimensional inserts ``obj=0`` behaves very different
from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from
``arr[:,[0],:] = values``.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])
&gt;&gt;&gt; a
array([[1, 1],
       [2, 2],
       [3, 3]])
&gt;&gt;&gt; np.insert(a, 1, 5)
array([1, 5, 1, ..., 2, 3, 3])
&gt;&gt;&gt; np.insert(a, 1, 5, axis=1)
array([[1, 5, 1],
       [2, 5, 2],
       [3, 5, 3]])

Difference between sequence and scalars:

&gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])
&gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
...                np.insert(a, [1], [[1],[2],[3]], axis=1))
True

&gt;&gt;&gt; b = a.flatten()
&gt;&gt;&gt; b
array([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

&gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

&gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting
array([1, 1, 7, ..., 2, 3, 3])

&gt;&gt;&gt; x = np.arange(8).reshape(2, 4)
&gt;&gt;&gt; idx = (1, 3)
&gt;&gt;&gt; np.insert(x, idx, 999, axis=1)
array([[  0, 999,   1,   2, 999,   3],
       [  4, 999,   5,   6, 999,   7]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 5251</span><span class="keyword">def </span>insert(arr, obj, values, axis=None):</div>
<div class="line"><span class="lineno"> 5252</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5253</span><span class="stringliteral">    Insert values along the given axis before the given indices.</span></div>
<div class="line"><span class="lineno"> 5254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5255</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 5256</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 5257</span><span class="stringliteral">    arr : array_like</span></div>
<div class="line"><span class="lineno"> 5258</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 5259</span><span class="stringliteral">    obj : int, slice or sequence of ints</span></div>
<div class="line"><span class="lineno"> 5260</span><span class="stringliteral">        Object that defines the index or indices before which `values` is</span></div>
<div class="line"><span class="lineno"> 5261</span><span class="stringliteral">        inserted.</span></div>
<div class="line"><span class="lineno"> 5262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5263</span><span class="stringliteral">        .. versionadded:: 1.8.0</span></div>
<div class="line"><span class="lineno"> 5264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5265</span><span class="stringliteral">        Support for multiple insertions when `obj` is a single scalar or a</span></div>
<div class="line"><span class="lineno"> 5266</span><span class="stringliteral">        sequence with one element (similar to calling insert multiple</span></div>
<div class="line"><span class="lineno"> 5267</span><span class="stringliteral">        times).</span></div>
<div class="line"><span class="lineno"> 5268</span><span class="stringliteral">    values : array_like</span></div>
<div class="line"><span class="lineno"> 5269</span><span class="stringliteral">        Values to insert into `arr`. If the type of `values` is different</span></div>
<div class="line"><span class="lineno"> 5270</span><span class="stringliteral">        from that of `arr`, `values` is converted to the type of `arr`.</span></div>
<div class="line"><span class="lineno"> 5271</span><span class="stringliteral">        `values` should be shaped so that ``arr[...,obj,...] = values``</span></div>
<div class="line"><span class="lineno"> 5272</span><span class="stringliteral">        is legal.</span></div>
<div class="line"><span class="lineno"> 5273</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 5274</span><span class="stringliteral">        Axis along which to insert `values`.  If `axis` is None then `arr`</span></div>
<div class="line"><span class="lineno"> 5275</span><span class="stringliteral">        is flattened first.</span></div>
<div class="line"><span class="lineno"> 5276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5277</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 5278</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 5279</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 5280</span><span class="stringliteral">        A copy of `arr` with `values` inserted.  Note that `insert`</span></div>
<div class="line"><span class="lineno"> 5281</span><span class="stringliteral">        does not occur in-place: a new array is returned. If</span></div>
<div class="line"><span class="lineno"> 5282</span><span class="stringliteral">        `axis` is None, `out` is a flattened array.</span></div>
<div class="line"><span class="lineno"> 5283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5284</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 5285</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5286</span><span class="stringliteral">    append : Append elements at the end of an array.</span></div>
<div class="line"><span class="lineno"> 5287</span><span class="stringliteral">    concatenate : Join a sequence of arrays along an existing axis.</span></div>
<div class="line"><span class="lineno"> 5288</span><span class="stringliteral">    delete : Delete elements from an array.</span></div>
<div class="line"><span class="lineno"> 5289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5290</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 5291</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 5292</span><span class="stringliteral">    Note that for higher dimensional inserts ``obj=0`` behaves very different</span></div>
<div class="line"><span class="lineno"> 5293</span><span class="stringliteral">    from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from</span></div>
<div class="line"><span class="lineno"> 5294</span><span class="stringliteral">    ``arr[:,[0],:] = values``.</span></div>
<div class="line"><span class="lineno"> 5295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5296</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 5297</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 5298</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])</span></div>
<div class="line"><span class="lineno"> 5299</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 5300</span><span class="stringliteral">    array([[1, 1],</span></div>
<div class="line"><span class="lineno"> 5301</span><span class="stringliteral">           [2, 2],</span></div>
<div class="line"><span class="lineno"> 5302</span><span class="stringliteral">           [3, 3]])</span></div>
<div class="line"><span class="lineno"> 5303</span><span class="stringliteral">    &gt;&gt;&gt; np.insert(a, 1, 5)</span></div>
<div class="line"><span class="lineno"> 5304</span><span class="stringliteral">    array([1, 5, 1, ..., 2, 3, 3])</span></div>
<div class="line"><span class="lineno"> 5305</span><span class="stringliteral">    &gt;&gt;&gt; np.insert(a, 1, 5, axis=1)</span></div>
<div class="line"><span class="lineno"> 5306</span><span class="stringliteral">    array([[1, 5, 1],</span></div>
<div class="line"><span class="lineno"> 5307</span><span class="stringliteral">           [2, 5, 2],</span></div>
<div class="line"><span class="lineno"> 5308</span><span class="stringliteral">           [3, 5, 3]])</span></div>
<div class="line"><span class="lineno"> 5309</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5310</span><span class="stringliteral">    Difference between sequence and scalars:</span></div>
<div class="line"><span class="lineno"> 5311</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5312</span><span class="stringliteral">    &gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)</span></div>
<div class="line"><span class="lineno"> 5313</span><span class="stringliteral">    array([[1, 1, 1],</span></div>
<div class="line"><span class="lineno"> 5314</span><span class="stringliteral">           [2, 2, 2],</span></div>
<div class="line"><span class="lineno"> 5315</span><span class="stringliteral">           [3, 3, 3]])</span></div>
<div class="line"><span class="lineno"> 5316</span><span class="stringliteral">    &gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),</span></div>
<div class="line"><span class="lineno"> 5317</span><span class="stringliteral">    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))</span></div>
<div class="line"><span class="lineno"> 5318</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 5319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5320</span><span class="stringliteral">    &gt;&gt;&gt; b = a.flatten()</span></div>
<div class="line"><span class="lineno"> 5321</span><span class="stringliteral">    &gt;&gt;&gt; b</span></div>
<div class="line"><span class="lineno"> 5322</span><span class="stringliteral">    array([1, 1, 2, 2, 3, 3])</span></div>
<div class="line"><span class="lineno"> 5323</span><span class="stringliteral">    &gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])</span></div>
<div class="line"><span class="lineno"> 5324</span><span class="stringliteral">    array([1, 1, 5, ..., 2, 3, 3])</span></div>
<div class="line"><span class="lineno"> 5325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5326</span><span class="stringliteral">    &gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])</span></div>
<div class="line"><span class="lineno"> 5327</span><span class="stringliteral">    array([1, 1, 5, ..., 2, 3, 3])</span></div>
<div class="line"><span class="lineno"> 5328</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5329</span><span class="stringliteral">    &gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting</span></div>
<div class="line"><span class="lineno"> 5330</span><span class="stringliteral">    array([1, 1, 7, ..., 2, 3, 3])</span></div>
<div class="line"><span class="lineno"> 5331</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5332</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(8).reshape(2, 4)</span></div>
<div class="line"><span class="lineno"> 5333</span><span class="stringliteral">    &gt;&gt;&gt; idx = (1, 3)</span></div>
<div class="line"><span class="lineno"> 5334</span><span class="stringliteral">    &gt;&gt;&gt; np.insert(x, idx, 999, axis=1)</span></div>
<div class="line"><span class="lineno"> 5335</span><span class="stringliteral">    array([[  0, 999,   1,   2, 999,   3],</span></div>
<div class="line"><span class="lineno"> 5336</span><span class="stringliteral">           [  4, 999,   5,   6, 999,   7]])</span></div>
<div class="line"><span class="lineno"> 5337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5338</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5339</span>    wrap = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5340</span>    <span class="keywordflow">if</span> type(arr) <span class="keywordflow">is</span> <span class="keywordflow">not</span> ndarray:</div>
<div class="line"><span class="lineno"> 5341</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 5342</span>            wrap = arr.__array_wrap__</div>
<div class="line"><span class="lineno"> 5343</span>        <span class="keywordflow">except</span> AttributeError:</div>
<div class="line"><span class="lineno"> 5344</span>            <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 5345</span> </div>
<div class="line"><span class="lineno"> 5346</span>    arr = asarray(arr)</div>
<div class="line"><span class="lineno"> 5347</span>    ndim = arr.ndim</div>
<div class="line"><span class="lineno"> 5348</span>    arrorder = <span class="stringliteral">&#39;F&#39;</span> <span class="keywordflow">if</span> arr.flags.fnc <span class="keywordflow">else</span> <span class="stringliteral">&#39;C&#39;</span></div>
<div class="line"><span class="lineno"> 5349</span>    <span class="keywordflow">if</span> axis <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5350</span>        <span class="keywordflow">if</span> ndim != 1:</div>
<div class="line"><span class="lineno"> 5351</span>            arr = arr.ravel()</div>
<div class="line"><span class="lineno"> 5352</span>        <span class="comment"># needed for np.matrix, which is still not 1d after being ravelled</span></div>
<div class="line"><span class="lineno"> 5353</span>        ndim = arr.ndim</div>
<div class="line"><span class="lineno"> 5354</span>        axis = ndim - 1</div>
<div class="line"><span class="lineno"> 5355</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5356</span>        axis = normalize_axis_index(axis, ndim)</div>
<div class="line"><span class="lineno"> 5357</span>    slobj = [slice(<span class="keywordtype">None</span>)]*ndim</div>
<div class="line"><span class="lineno"> 5358</span>    N = arr.shape[axis]</div>
<div class="line"><span class="lineno"> 5359</span>    newshape = list(arr.shape)</div>
<div class="line"><span class="lineno"> 5360</span> </div>
<div class="line"><span class="lineno"> 5361</span>    <span class="keywordflow">if</span> isinstance(obj, slice):</div>
<div class="line"><span class="lineno"> 5362</span>        <span class="comment"># turn it into a range object</span></div>
<div class="line"><span class="lineno"> 5363</span>        indices = arange(*obj.indices(N), dtype=intp)</div>
<div class="line"><span class="lineno"> 5364</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5365</span>        <span class="comment"># need to copy obj, because indices will be changed in-place</span></div>
<div class="line"><span class="lineno"> 5366</span>        indices = np.array(obj)</div>
<div class="line"><span class="lineno"> 5367</span>        <span class="keywordflow">if</span> indices.dtype == bool:</div>
<div class="line"><span class="lineno"> 5368</span>            <span class="comment"># See also delete</span></div>
<div class="line"><span class="lineno"> 5369</span>            <span class="comment"># 2012-10-11, NumPy 1.8</span></div>
<div class="line"><span class="lineno"> 5370</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 5371</span>                <span class="stringliteral">&quot;in the future insert will treat boolean arrays and &quot;</span></div>
<div class="line"><span class="lineno"> 5372</span>                <span class="stringliteral">&quot;array-likes as a boolean index instead of casting it to &quot;</span></div>
<div class="line"><span class="lineno"> 5373</span>                <span class="stringliteral">&quot;integer&quot;</span>, FutureWarning, stacklevel=3)</div>
<div class="line"><span class="lineno"> 5374</span>            indices = indices.astype(intp)</div>
<div class="line"><span class="lineno"> 5375</span>            <span class="comment"># Code after warning period:</span></div>
<div class="line"><span class="lineno"> 5376</span>            <span class="comment">#if obj.ndim != 1:</span></div>
<div class="line"><span class="lineno"> 5377</span>            <span class="comment">#    raise ValueError(&#39;boolean array argument obj to insert &#39;</span></div>
<div class="line"><span class="lineno"> 5378</span>            <span class="comment">#                     &#39;must be one dimensional&#39;)</span></div>
<div class="line"><span class="lineno"> 5379</span>            <span class="comment">#indices = np.flatnonzero(obj)</span></div>
<div class="line"><span class="lineno"> 5380</span>        <span class="keywordflow">elif</span> indices.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 5381</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 5382</span>                <span class="stringliteral">&quot;index array argument obj to insert must be one dimensional &quot;</span></div>
<div class="line"><span class="lineno"> 5383</span>                <span class="stringliteral">&quot;or scalar&quot;</span>)</div>
<div class="line"><span class="lineno"> 5384</span>    <span class="keywordflow">if</span> indices.size == 1:</div>
<div class="line"><span class="lineno"> 5385</span>        index = indices.item()</div>
<div class="line"><span class="lineno"> 5386</span>        <span class="keywordflow">if</span> index &lt; -N <span class="keywordflow">or</span> index &gt; N:</div>
<div class="line"><span class="lineno"> 5387</span>            <span class="keywordflow">raise</span> IndexError(f<span class="stringliteral">&quot;index {obj} is out of bounds for axis {axis} &quot;</span></div>
<div class="line"><span class="lineno"> 5388</span>                             f<span class="stringliteral">&quot;with size {N}&quot;</span>)</div>
<div class="line"><span class="lineno"> 5389</span>        <span class="keywordflow">if</span> (index &lt; 0):</div>
<div class="line"><span class="lineno"> 5390</span>            index += N</div>
<div class="line"><span class="lineno"> 5391</span> </div>
<div class="line"><span class="lineno"> 5392</span>        <span class="comment"># There are some object array corner cases here, but we cannot avoid</span></div>
<div class="line"><span class="lineno"> 5393</span>        <span class="comment"># that:</span></div>
<div class="line"><span class="lineno"> 5394</span>        values = array(values, copy=<span class="keyword">False</span>, ndmin=arr.ndim, dtype=arr.dtype)</div>
<div class="line"><span class="lineno"> 5395</span>        <span class="keywordflow">if</span> indices.ndim == 0:</div>
<div class="line"><span class="lineno"> 5396</span>            <span class="comment"># broadcasting is very different here, since a[:,0,:] = ... behaves</span></div>
<div class="line"><span class="lineno"> 5397</span>            <span class="comment"># very different from a[:,[0],:] = ...! This changes values so that</span></div>
<div class="line"><span class="lineno"> 5398</span>            <span class="comment"># it works likes the second case. (here a[:,0:1,:])</span></div>
<div class="line"><span class="lineno"> 5399</span>            values = np.moveaxis(values, 0, axis)</div>
<div class="line"><span class="lineno"> 5400</span>        numnew = values.shape[axis]</div>
<div class="line"><span class="lineno"> 5401</span>        newshape[axis] += numnew</div>
<div class="line"><span class="lineno"> 5402</span>        new = empty(newshape, arr.dtype, arrorder)</div>
<div class="line"><span class="lineno"> 5403</span>        slobj[axis] = slice(<span class="keywordtype">None</span>, index)</div>
<div class="line"><span class="lineno"> 5404</span>        new[tuple(slobj)] = arr[tuple(slobj)]</div>
<div class="line"><span class="lineno"> 5405</span>        slobj[axis] = slice(index, index+numnew)</div>
<div class="line"><span class="lineno"> 5406</span>        new[tuple(slobj)] = values</div>
<div class="line"><span class="lineno"> 5407</span>        slobj[axis] = slice(index+numnew, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 5408</span>        slobj2 = [slice(<span class="keywordtype">None</span>)] * ndim</div>
<div class="line"><span class="lineno"> 5409</span>        slobj2[axis] = slice(index, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 5410</span>        new[tuple(slobj)] = arr[tuple(slobj2)]</div>
<div class="line"><span class="lineno"> 5411</span>        <span class="keywordflow">if</span> wrap:</div>
<div class="line"><span class="lineno"> 5412</span>            <span class="keywordflow">return</span> wrap(new)</div>
<div class="line"><span class="lineno"> 5413</span>        <span class="keywordflow">return</span> new</div>
<div class="line"><span class="lineno"> 5414</span>    <span class="keywordflow">elif</span> indices.size == 0 <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(obj, np.ndarray):</div>
<div class="line"><span class="lineno"> 5415</span>        <span class="comment"># Can safely cast the empty list to intp</span></div>
<div class="line"><span class="lineno"> 5416</span>        indices = indices.astype(intp)</div>
<div class="line"><span class="lineno"> 5417</span> </div>
<div class="line"><span class="lineno"> 5418</span>    indices[indices &lt; 0] += N</div>
<div class="line"><span class="lineno"> 5419</span> </div>
<div class="line"><span class="lineno"> 5420</span>    numnew = len(indices)</div>
<div class="line"><span class="lineno"> 5421</span>    order = indices.argsort(kind=<span class="stringliteral">&#39;mergesort&#39;</span>)   <span class="comment"># stable sort</span></div>
<div class="line"><span class="lineno"> 5422</span>    indices[order] += np.arange(numnew)</div>
<div class="line"><span class="lineno"> 5423</span> </div>
<div class="line"><span class="lineno"> 5424</span>    newshape[axis] += numnew</div>
<div class="line"><span class="lineno"> 5425</span>    old_mask = ones(newshape[axis], dtype=bool)</div>
<div class="line"><span class="lineno"> 5426</span>    old_mask[indices] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5427</span> </div>
<div class="line"><span class="lineno"> 5428</span>    new = empty(newshape, arr.dtype, arrorder)</div>
<div class="line"><span class="lineno"> 5429</span>    slobj2 = [slice(<span class="keywordtype">None</span>)]*ndim</div>
<div class="line"><span class="lineno"> 5430</span>    slobj[axis] = indices</div>
<div class="line"><span class="lineno"> 5431</span>    slobj2[axis] = old_mask</div>
<div class="line"><span class="lineno"> 5432</span>    new[tuple(slobj)] = values</div>
<div class="line"><span class="lineno"> 5433</span>    new[tuple(slobj2)] = arr</div>
<div class="line"><span class="lineno"> 5434</span> </div>
<div class="line"><span class="lineno"> 5435</span>    <span class="keywordflow">if</span> wrap:</div>
<div class="line"><span class="lineno"> 5436</span>        <span class="keywordflow">return</span> wrap(new)</div>
<div class="line"><span class="lineno"> 5437</span>    <span class="keywordflow">return</span> new</div>
<div class="line"><span class="lineno"> 5438</span> </div>
<div class="line"><span class="lineno"> 5439</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5b0bfb8023fc47d9991cb3429af814f" name="ab5b0bfb8023fc47d9991cb3429af814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b0bfb8023fc47d9991cb3429af814f">&#9670;&#160;</a></span>interp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.interp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>period</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">One-dimensional linear interpolation for monotonically increasing sample points.

Returns the one-dimensional piecewise linear interpolant to a function
with given discrete data points (`xp`, `fp`), evaluated at `x`.

Parameters
----------
x : array_like
    The x-coordinates at which to evaluate the interpolated values.

xp : 1-D sequence of floats
    The x-coordinates of the data points, must be increasing if argument
    `period` is not specified. Otherwise, `xp` is internally sorted after
    normalizing the periodic boundaries with ``xp = xp % period``.

fp : 1-D sequence of float or complex
    The y-coordinates of the data points, same length as `xp`.

left : optional float or complex corresponding to fp
    Value to return for `x &lt; xp[0]`, default is `fp[0]`.

right : optional float or complex corresponding to fp
    Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.

period : None or float, optional
    A period for the x-coordinates. This parameter allows the proper
    interpolation of angular x-coordinates. Parameters `left` and `right`
    are ignored if `period` is specified.

    .. versionadded:: 1.10.0

Returns
-------
y : float or complex (corresponding to fp) or ndarray
    The interpolated values, same shape as `x`.

Raises
------
ValueError
    If `xp` and `fp` have different length
    If `xp` or `fp` are not 1-D sequences
    If `period == 0`

See Also
--------
scipy.interpolate

Warnings
--------
The x-coordinate sequence is expected to be increasing, but this is not
explicitly enforced.  However, if the sequence `xp` is non-increasing,
interpolation results are meaningless.

Note that, since NaN is unsortable, `xp` also cannot contain NaNs.

A simple check for `xp` being strictly increasing is::

    np.all(np.diff(xp) &gt; 0)

Examples
--------
&gt;&gt;&gt; xp = [1, 2, 3]
&gt;&gt;&gt; fp = [3, 2, 0]
&gt;&gt;&gt; np.interp(2.5, xp, fp)
1.0
&gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
array([3.  , 3.  , 2.5 , 0.56, 0.  ])
&gt;&gt;&gt; UNDEF = -99.0
&gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF)
-99.0

Plot an interpolant to the sine function:

&gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)
&gt;&gt;&gt; y = np.sin(x)
&gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50)
&gt;&gt;&gt; yinterp = np.interp(xvals, x, y)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x, y, 'o')
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.plot(xvals, yinterp, '-x')
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.show()

Interpolation with periodic x-coordinates:

&gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365]
&gt;&gt;&gt; xp = [190, -190, 350, -350]
&gt;&gt;&gt; fp = [5, 10, 3, 4]
&gt;&gt;&gt; np.interp(x, xp, fp, period=360)
array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])

Complex interpolation:

&gt;&gt;&gt; x = [1.5, 4.0]
&gt;&gt;&gt; xp = [2,3,5]
&gt;&gt;&gt; fp = [1.0j, 0, 2+3j]
&gt;&gt;&gt; np.interp(x, xp, fp)
array([0.+1.j , 1.+1.5j])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1458</span><span class="keyword">def </span>interp(x, xp, fp, left=None, right=None, period=None):</div>
<div class="line"><span class="lineno"> 1459</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1460</span><span class="stringliteral">    One-dimensional linear interpolation for monotonically increasing sample points.</span></div>
<div class="line"><span class="lineno"> 1461</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1462</span><span class="stringliteral">    Returns the one-dimensional piecewise linear interpolant to a function</span></div>
<div class="line"><span class="lineno"> 1463</span><span class="stringliteral">    with given discrete data points (`xp`, `fp`), evaluated at `x`.</span></div>
<div class="line"><span class="lineno"> 1464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1465</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1466</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1467</span><span class="stringliteral">    x : array_like</span></div>
<div class="line"><span class="lineno"> 1468</span><span class="stringliteral">        The x-coordinates at which to evaluate the interpolated values.</span></div>
<div class="line"><span class="lineno"> 1469</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1470</span><span class="stringliteral">    xp : 1-D sequence of floats</span></div>
<div class="line"><span class="lineno"> 1471</span><span class="stringliteral">        The x-coordinates of the data points, must be increasing if argument</span></div>
<div class="line"><span class="lineno"> 1472</span><span class="stringliteral">        `period` is not specified. Otherwise, `xp` is internally sorted after</span></div>
<div class="line"><span class="lineno"> 1473</span><span class="stringliteral">        normalizing the periodic boundaries with ``xp = xp % period``.</span></div>
<div class="line"><span class="lineno"> 1474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1475</span><span class="stringliteral">    fp : 1-D sequence of float or complex</span></div>
<div class="line"><span class="lineno"> 1476</span><span class="stringliteral">        The y-coordinates of the data points, same length as `xp`.</span></div>
<div class="line"><span class="lineno"> 1477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1478</span><span class="stringliteral">    left : optional float or complex corresponding to fp</span></div>
<div class="line"><span class="lineno"> 1479</span><span class="stringliteral">        Value to return for `x &lt; xp[0]`, default is `fp[0]`.</span></div>
<div class="line"><span class="lineno"> 1480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1481</span><span class="stringliteral">    right : optional float or complex corresponding to fp</span></div>
<div class="line"><span class="lineno"> 1482</span><span class="stringliteral">        Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.</span></div>
<div class="line"><span class="lineno"> 1483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1484</span><span class="stringliteral">    period : None or float, optional</span></div>
<div class="line"><span class="lineno"> 1485</span><span class="stringliteral">        A period for the x-coordinates. This parameter allows the proper</span></div>
<div class="line"><span class="lineno"> 1486</span><span class="stringliteral">        interpolation of angular x-coordinates. Parameters `left` and `right`</span></div>
<div class="line"><span class="lineno"> 1487</span><span class="stringliteral">        are ignored if `period` is specified.</span></div>
<div class="line"><span class="lineno"> 1488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1489</span><span class="stringliteral">        .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral">    y : float or complex (corresponding to fp) or ndarray</span></div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">        The interpolated values, same shape as `x`.</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">        If `xp` and `fp` have different length</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">        If `xp` or `fp` are not 1-D sequences</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">        If `period == 0`</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">    scipy.interpolate</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">    Warnings</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral">    The x-coordinate sequence is expected to be increasing, but this is not</span></div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">    explicitly enforced.  However, if the sequence `xp` is non-increasing,</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">    interpolation results are meaningless.</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">    Note that, since NaN is unsortable, `xp` also cannot contain NaNs.</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1515</span><span class="stringliteral">    A simple check for `xp` being strictly increasing is::</span></div>
<div class="line"><span class="lineno"> 1516</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1517</span><span class="stringliteral">        np.all(np.diff(xp) &gt; 0)</span></div>
<div class="line"><span class="lineno"> 1518</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1519</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1520</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="stringliteral">    &gt;&gt;&gt; xp = [1, 2, 3]</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="stringliteral">    &gt;&gt;&gt; fp = [3, 2, 0]</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="stringliteral">    &gt;&gt;&gt; np.interp(2.5, xp, fp)</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="stringliteral">    1.0</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="stringliteral">    &gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="stringliteral">    array([3.  , 3.  , 2.5 , 0.56, 0.  ])</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="stringliteral">    &gt;&gt;&gt; UNDEF = -99.0</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="stringliteral">    &gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF)</span></div>
<div class="line"><span class="lineno"> 1529</span><span class="stringliteral">    -99.0</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">    Plot an interpolant to the sine function:</span></div>
<div class="line"><span class="lineno"> 1532</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1533</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)</span></div>
<div class="line"><span class="lineno"> 1534</span><span class="stringliteral">    &gt;&gt;&gt; y = np.sin(x)</span></div>
<div class="line"><span class="lineno"> 1535</span><span class="stringliteral">    &gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50)</span></div>
<div class="line"><span class="lineno"> 1536</span><span class="stringliteral">    &gt;&gt;&gt; yinterp = np.interp(xvals, x, y)</span></div>
<div class="line"><span class="lineno"> 1537</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1538</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;)</span></div>
<div class="line"><span class="lineno"> 1539</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 1540</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(xvals, yinterp, &#39;-x&#39;)</span></div>
<div class="line"><span class="lineno"> 1541</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 1542</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral">    Interpolation with periodic x-coordinates:</span></div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">    &gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365]</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">    &gt;&gt;&gt; xp = [190, -190, 350, -350]</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    &gt;&gt;&gt; fp = [5, 10, 3, 4]</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    &gt;&gt;&gt; np.interp(x, xp, fp, period=360)</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    Complex interpolation:</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral">    &gt;&gt;&gt; x = [1.5, 4.0]</span></div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    &gt;&gt;&gt; xp = [2,3,5]</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    &gt;&gt;&gt; fp = [1.0j, 0, 2+3j]</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    &gt;&gt;&gt; np.interp(x, xp, fp)</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">    array([0.+1.j , 1.+1.5j])</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1561</span> </div>
<div class="line"><span class="lineno"> 1562</span>    fp = np.asarray(fp)</div>
<div class="line"><span class="lineno"> 1563</span> </div>
<div class="line"><span class="lineno"> 1564</span>    <span class="keywordflow">if</span> np.iscomplexobj(fp):</div>
<div class="line"><span class="lineno"> 1565</span>        interp_func = compiled_interp_complex</div>
<div class="line"><span class="lineno"> 1566</span>        input_dtype = np.complex128</div>
<div class="line"><span class="lineno"> 1567</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1568</span>        interp_func = compiled_interp</div>
<div class="line"><span class="lineno"> 1569</span>        input_dtype = np.float64</div>
<div class="line"><span class="lineno"> 1570</span> </div>
<div class="line"><span class="lineno"> 1571</span>    <span class="keywordflow">if</span> period <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1572</span>        <span class="keywordflow">if</span> period == 0:</div>
<div class="line"><span class="lineno"> 1573</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;period must be a non-zero value&quot;</span>)</div>
<div class="line"><span class="lineno"> 1574</span>        period = abs(period)</div>
<div class="line"><span class="lineno"> 1575</span>        left = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1576</span>        right = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1577</span> </div>
<div class="line"><span class="lineno"> 1578</span>        x = np.asarray(x, dtype=np.float64)</div>
<div class="line"><span class="lineno"> 1579</span>        xp = np.asarray(xp, dtype=np.float64)</div>
<div class="line"><span class="lineno"> 1580</span>        fp = np.asarray(fp, dtype=input_dtype)</div>
<div class="line"><span class="lineno"> 1581</span> </div>
<div class="line"><span class="lineno"> 1582</span>        <span class="keywordflow">if</span> xp.ndim != 1 <span class="keywordflow">or</span> fp.ndim != 1:</div>
<div class="line"><span class="lineno"> 1583</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data points must be 1-D sequences&quot;</span>)</div>
<div class="line"><span class="lineno"> 1584</span>        <span class="keywordflow">if</span> xp.shape[0] != fp.shape[0]:</div>
<div class="line"><span class="lineno"> 1585</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;fp and xp are not of the same length&quot;</span>)</div>
<div class="line"><span class="lineno"> 1586</span>        <span class="comment"># normalizing periodic boundaries</span></div>
<div class="line"><span class="lineno"> 1587</span>        x = x % period</div>
<div class="line"><span class="lineno"> 1588</span>        xp = xp % period</div>
<div class="line"><span class="lineno"> 1589</span>        asort_xp = np.argsort(xp)</div>
<div class="line"><span class="lineno"> 1590</span>        xp = xp[asort_xp]</div>
<div class="line"><span class="lineno"> 1591</span>        fp = fp[asort_xp]</div>
<div class="line"><span class="lineno"> 1592</span>        xp = np.concatenate((xp[-1:]-period, xp, xp[0:1]+period))</div>
<div class="line"><span class="lineno"> 1593</span>        fp = np.concatenate((fp[-1:], fp, fp[0:1]))</div>
<div class="line"><span class="lineno"> 1594</span> </div>
<div class="line"><span class="lineno"> 1595</span>    <span class="keywordflow">return</span> interp_func(x, xp, fp, left, right)</div>
<div class="line"><span class="lineno"> 1596</span> </div>
<div class="line"><span class="lineno"> 1597</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a531c572a52ebfaba6055e1d1b7c88ba2" name="a531c572a52ebfaba6055e1d1b7c88ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531c572a52ebfaba6055e1d1b7c88ba2">&#9670;&#160;</a></span>iterable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.iterable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether or not an object can be iterated over.

Parameters
----------
y : object
  Input object.

Returns
-------
b : bool
  Return ``True`` if the object has an iterator method or is a
  sequence and ``False`` otherwise.


Examples
--------
&gt;&gt;&gt; np.iterable([1, 2, 3])
True
&gt;&gt;&gt; np.iterable(2)
False

Notes
-----
In most cases, the results of ``np.iterable(obj)`` are consistent with
``isinstance(obj, collections.abc.Iterable)``. One notable exception is
the treatment of 0-dimensional arrays::

    &gt;&gt;&gt; from collections.abc import Iterable
    &gt;&gt;&gt; a = np.array(1.0)  # 0-dimensional numpy array
    &gt;&gt;&gt; isinstance(a, Iterable)
    True
    &gt;&gt;&gt; np.iterable(a)
    False</pre> <div class="fragment"><div class="line"><span class="lineno">  347</span><span class="keyword">def </span>iterable(y):</div>
<div class="line"><span class="lineno">  348</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    Check whether or not an object can be iterated over.</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    y : object</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">      Input object.</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    b : bool</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">      Return ``True`` if the object has an iterator method or is a</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">      sequence and ``False`` otherwise.</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    &gt;&gt;&gt; np.iterable([1, 2, 3])</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    &gt;&gt;&gt; np.iterable(2)</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    In most cases, the results of ``np.iterable(obj)`` are consistent with</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    ``isinstance(obj, collections.abc.Iterable)``. One notable exception is</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    the treatment of 0-dimensional arrays::</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">        &gt;&gt;&gt; from collections.abc import Iterable</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        &gt;&gt;&gt; a = np.array(1.0)  # 0-dimensional numpy array</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        &gt;&gt;&gt; isinstance(a, Iterable)</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        &gt;&gt;&gt; np.iterable(a)</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  384</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  385</span>        <a class="code hl_variable" href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a>(y)</div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno">  387</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="ttc" id="a__lapack__subroutines_8h_html_a60590d91febfcb54d88443940cd5f23e"><div class="ttname"><a href="__lapack__subroutines_8h.html#a60590d91febfcb54d88443940cd5f23e">iter</a></div><div class="ttdeci">void int double int double double double double int int * iter</div><div class="ttdef"><b>Definition</b> _lapack_subroutines.h:623</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c484a36cce93348651a5fe19e2ac5e8" name="a3c484a36cce93348651a5fe19e2ac5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c484a36cce93348651a5fe19e2ac5e8">&#9670;&#160;</a></span>kaiser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.kaiser </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of cephes code for i0. </p>
<pre class="fragment">Return the Kaiser window.

The Kaiser window is a taper formed by using a Bessel function.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.
beta : float
    Shape parameter for window.

Returns
-------
out : array
    The window, with the maximum value normalized to one (the value
    one appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hamming, hanning

Notes
-----
The Kaiser window is defined as

.. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}
           \\right)/I_0(\\beta)

with

.. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},

where :math:`I_0` is the modified zeroth-order Bessel function.

The Kaiser was named for Jim Kaiser, who discovered a simple
approximation to the DPSS window based on Bessel functions.  The Kaiser
window is a very good approximation to the Digital Prolate Spheroidal
Sequence, or Slepian window, which is the transform which maximizes the
energy in the main lobe of the window relative to total energy.

The Kaiser can approximate many other windows by varying the beta
parameter.

====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hanning
8.6   Similar to a Blackman
====  =======================

A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
get returned.

Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] J. F. Kaiser, "Digital Filters" - Ch 7 in "Systems analysis by
       digital computer", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
       John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
       University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; np.kaiser(12, 14)
 array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary
        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,
        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,
        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])


Plot the window and the frequency response:

&gt;&gt;&gt; from numpy.fft import fft, fftshift
&gt;&gt;&gt; window = np.kaiser(51, 14)
&gt;&gt;&gt; plt.plot(window)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Kaiser window")
Text(0.5, 1.0, 'Kaiser window')
&gt;&gt;&gt; plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
&gt;&gt;&gt; plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; plt.figure()
&lt;Figure size 640x480 with 0 Axes&gt;
&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = np.abs(fftshift(A))
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(mag)
&gt;&gt;&gt; response = np.clip(response, -100, 100)
&gt;&gt;&gt; plt.plot(freq, response)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Frequency response of Kaiser window")
Text(0.5, 1.0, 'Frequency response of Kaiser window')
&gt;&gt;&gt; plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
&gt;&gt;&gt; plt.axis('tight')
(-0.5, 0.5, -100.0, ...) # may vary
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3430</span><span class="keyword">def </span>kaiser(M, beta):</div>
<div class="line"><span class="lineno"> 3431</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3432</span><span class="stringliteral">    Return the Kaiser window.</span></div>
<div class="line"><span class="lineno"> 3433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3434</span><span class="stringliteral">    The Kaiser window is a taper formed by using a Bessel function.</span></div>
<div class="line"><span class="lineno"> 3435</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3436</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3437</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3438</span><span class="stringliteral">    M : int</span></div>
<div class="line"><span class="lineno"> 3439</span><span class="stringliteral">        Number of points in the output window. If zero or less, an</span></div>
<div class="line"><span class="lineno"> 3440</span><span class="stringliteral">        empty array is returned.</span></div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral">    beta : float</span></div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral">        Shape parameter for window.</span></div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3446</span><span class="stringliteral">    out : array</span></div>
<div class="line"><span class="lineno"> 3447</span><span class="stringliteral">        The window, with the maximum value normalized to one (the value</span></div>
<div class="line"><span class="lineno"> 3448</span><span class="stringliteral">        one appears only if the number of samples is odd).</span></div>
<div class="line"><span class="lineno"> 3449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3450</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3451</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3452</span><span class="stringliteral">    bartlett, blackman, hamming, hanning</span></div>
<div class="line"><span class="lineno"> 3453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3454</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3455</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3456</span><span class="stringliteral">    The Kaiser window is defined as</span></div>
<div class="line"><span class="lineno"> 3457</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3458</span><span class="stringliteral">    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}</span></div>
<div class="line"><span class="lineno"> 3459</span><span class="stringliteral">               \\right)/I_0(\\beta)</span></div>
<div class="line"><span class="lineno"> 3460</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3461</span><span class="stringliteral">    with</span></div>
<div class="line"><span class="lineno"> 3462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3463</span><span class="stringliteral">    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},</span></div>
<div class="line"><span class="lineno"> 3464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3465</span><span class="stringliteral">    where :math:`I_0` is the modified zeroth-order Bessel function.</span></div>
<div class="line"><span class="lineno"> 3466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3467</span><span class="stringliteral">    The Kaiser was named for Jim Kaiser, who discovered a simple</span></div>
<div class="line"><span class="lineno"> 3468</span><span class="stringliteral">    approximation to the DPSS window based on Bessel functions.  The Kaiser</span></div>
<div class="line"><span class="lineno"> 3469</span><span class="stringliteral">    window is a very good approximation to the Digital Prolate Spheroidal</span></div>
<div class="line"><span class="lineno"> 3470</span><span class="stringliteral">    Sequence, or Slepian window, which is the transform which maximizes the</span></div>
<div class="line"><span class="lineno"> 3471</span><span class="stringliteral">    energy in the main lobe of the window relative to total energy.</span></div>
<div class="line"><span class="lineno"> 3472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3473</span><span class="stringliteral">    The Kaiser can approximate many other windows by varying the beta</span></div>
<div class="line"><span class="lineno"> 3474</span><span class="stringliteral">    parameter.</span></div>
<div class="line"><span class="lineno"> 3475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3476</span><span class="stringliteral">    ====  =======================</span></div>
<div class="line"><span class="lineno"> 3477</span><span class="stringliteral">    beta  Window shape</span></div>
<div class="line"><span class="lineno"> 3478</span><span class="stringliteral">    ====  =======================</span></div>
<div class="line"><span class="lineno"> 3479</span><span class="stringliteral">    0     Rectangular</span></div>
<div class="line"><span class="lineno"> 3480</span><span class="stringliteral">    5     Similar to a Hamming</span></div>
<div class="line"><span class="lineno"> 3481</span><span class="stringliteral">    6     Similar to a Hanning</span></div>
<div class="line"><span class="lineno"> 3482</span><span class="stringliteral">    8.6   Similar to a Blackman</span></div>
<div class="line"><span class="lineno"> 3483</span><span class="stringliteral">    ====  =======================</span></div>
<div class="line"><span class="lineno"> 3484</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3485</span><span class="stringliteral">    A beta value of 14 is probably a good starting point. Note that as beta</span></div>
<div class="line"><span class="lineno"> 3486</span><span class="stringliteral">    gets large, the window narrows, and so the number of samples needs to be</span></div>
<div class="line"><span class="lineno"> 3487</span><span class="stringliteral">    large enough to sample the increasingly narrow spike, otherwise NaNs will</span></div>
<div class="line"><span class="lineno"> 3488</span><span class="stringliteral">    get returned.</span></div>
<div class="line"><span class="lineno"> 3489</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3490</span><span class="stringliteral">    Most references to the Kaiser window come from the signal processing</span></div>
<div class="line"><span class="lineno"> 3491</span><span class="stringliteral">    literature, where it is used as one of many windowing functions for</span></div>
<div class="line"><span class="lineno"> 3492</span><span class="stringliteral">    smoothing values.  It is also known as an apodization (which means</span></div>
<div class="line"><span class="lineno"> 3493</span><span class="stringliteral">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span></div>
<div class="line"><span class="lineno"> 3494</span><span class="stringliteral">    and end of the sampled signal) or tapering function.</span></div>
<div class="line"><span class="lineno"> 3495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3496</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3497</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3498</span><span class="stringliteral">    .. [1] J. F. Kaiser, &quot;Digital Filters&quot; - Ch 7 in &quot;Systems analysis by</span></div>
<div class="line"><span class="lineno"> 3499</span><span class="stringliteral">           digital computer&quot;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.</span></div>
<div class="line"><span class="lineno"> 3500</span><span class="stringliteral">           John Wiley and Sons, New York, (1966).</span></div>
<div class="line"><span class="lineno"> 3501</span><span class="stringliteral">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span></div>
<div class="line"><span class="lineno"> 3502</span><span class="stringliteral">           University of Alberta Press, 1975, pp. 177-178.</span></div>
<div class="line"><span class="lineno"> 3503</span><span class="stringliteral">    .. [3] Wikipedia, &quot;Window function&quot;,</span></div>
<div class="line"><span class="lineno"> 3504</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Window_function</span></div>
<div class="line"><span class="lineno"> 3505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3506</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3507</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3508</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3509</span><span class="stringliteral">    &gt;&gt;&gt; np.kaiser(12, 14)</span></div>
<div class="line"><span class="lineno"> 3510</span><span class="stringliteral">     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary</span></div>
<div class="line"><span class="lineno"> 3511</span><span class="stringliteral">            2.29737120e-01, 5.99885316e-01, 9.45674898e-01,</span></div>
<div class="line"><span class="lineno"> 3512</span><span class="stringliteral">            9.45674898e-01, 5.99885316e-01, 2.29737120e-01,</span></div>
<div class="line"><span class="lineno"> 3513</span><span class="stringliteral">            4.65200189e-02, 3.46009194e-03, 7.72686684e-06])</span></div>
<div class="line"><span class="lineno"> 3514</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3516</span><span class="stringliteral">    Plot the window and the frequency response:</span></div>
<div class="line"><span class="lineno"> 3517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3518</span><span class="stringliteral">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span></div>
<div class="line"><span class="lineno"> 3519</span><span class="stringliteral">    &gt;&gt;&gt; window = np.kaiser(51, 14)</span></div>
<div class="line"><span class="lineno"> 3520</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(window)</span></div>
<div class="line"><span class="lineno"> 3521</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3522</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Kaiser window&quot;)</span></div>
<div class="line"><span class="lineno"> 3523</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Kaiser window&#39;)</span></div>
<div class="line"><span class="lineno"> 3524</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span></div>
<div class="line"><span class="lineno"> 3525</span><span class="stringliteral">    Text(0, 0.5, &#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 3526</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span></div>
<div class="line"><span class="lineno"> 3527</span><span class="stringliteral">    Text(0.5, 0, &#39;Sample&#39;)</span></div>
<div class="line"><span class="lineno"> 3528</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3529</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3530</span><span class="stringliteral">    &gt;&gt;&gt; plt.figure()</span></div>
<div class="line"><span class="lineno"> 3531</span><span class="stringliteral">    &lt;Figure size 640x480 with 0 Axes&gt;</span></div>
<div class="line"><span class="lineno"> 3532</span><span class="stringliteral">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span></div>
<div class="line"><span class="lineno"> 3533</span><span class="stringliteral">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span></div>
<div class="line"><span class="lineno"> 3534</span><span class="stringliteral">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span></div>
<div class="line"><span class="lineno"> 3535</span><span class="stringliteral">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span></div>
<div class="line"><span class="lineno"> 3536</span><span class="stringliteral">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span></div>
<div class="line"><span class="lineno"> 3537</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(freq, response)</span></div>
<div class="line"><span class="lineno"> 3538</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3539</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Kaiser window&quot;)</span></div>
<div class="line"><span class="lineno"> 3540</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Frequency response of Kaiser window&#39;)</span></div>
<div class="line"><span class="lineno"> 3541</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span></div>
<div class="line"><span class="lineno"> 3542</span><span class="stringliteral">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span></div>
<div class="line"><span class="lineno"> 3543</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span></div>
<div class="line"><span class="lineno"> 3544</span><span class="stringliteral">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span></div>
<div class="line"><span class="lineno"> 3545</span><span class="stringliteral">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span></div>
<div class="line"><span class="lineno"> 3546</span><span class="stringliteral">    (-0.5, 0.5, -100.0, ...) # may vary</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3550</span>    <span class="keywordflow">if</span> M == 1:</div>
<div class="line"><span class="lineno"> 3551</span>        <span class="keywordflow">return</span> np.ones(1, dtype=np.result_type(M, 0.0))</div>
<div class="line"><span class="lineno"> 3552</span>    n = arange(0, M)</div>
<div class="line"><span class="lineno"> 3553</span>    alpha = (M-1)/2.0</div>
<div class="line"><span class="lineno"> 3554</span>    <span class="keywordflow">return</span> i0(beta * sqrt(1-((n-alpha)/alpha)**2.0))/i0(float(beta))</div>
<div class="line"><span class="lineno"> 3555</span> </div>
<div class="line"><span class="lineno"> 3556</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a862b8d45a444babe7129725541b2e8bb" name="a862b8d45a444babe7129725541b2e8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862b8d45a444babe7129725541b2e8bb">&#9670;&#160;</a></span>median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.median </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : {int, sequence of int, None}, optional
    Axis or axes along which the medians are computed. The default
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array `a` for
   calculations. The input array will be modified by the call to
   `median`. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. If `overwrite_input` is ``True`` and `a` is not already an
   `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

    .. versionadded:: 1.9.0

Returns
-------
median : ndarray
    A new array holding the result. If the input contains integers
    or floats smaller than ``float64``, then the output data-type is
    ``np.float64``.  Otherwise, the data-type of the output is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean, percentile

Notes
-----
Given a vector ``V`` of length ``N``, the median of ``V`` is the
middle value of a sorted copy of ``V``, ``V_sorted`` - i
e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the
two middle values of ``V_sorted`` when ``N`` is even.

Examples
--------
&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; np.median(a)
3.5
&gt;&gt;&gt; np.median(a, axis=0)
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; np.median(a, axis=1)
array([7.,  2.])
&gt;&gt;&gt; m = np.median(a, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.median(a, axis=0, out=m)
array([6.5,  4.5,  2.5])
&gt;&gt;&gt; m
array([6.5,  4.5,  2.5])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)
array([7.,  2.])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)
3.5
&gt;&gt;&gt; assert not np.all(a==b)</pre> <div class="fragment"><div class="line"><span class="lineno"> 3775</span><span class="keyword">def </span>median(a, axis=None, out=None, overwrite_input=False, keepdims=False):</div>
<div class="line"><span class="lineno"> 3776</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3777</span><span class="stringliteral">    Compute the median along the specified axis.</span></div>
<div class="line"><span class="lineno"> 3778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3779</span><span class="stringliteral">    Returns the median of the array elements.</span></div>
<div class="line"><span class="lineno"> 3780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3781</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3782</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3783</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3784</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 3785</span><span class="stringliteral">    axis : {int, sequence of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 3786</span><span class="stringliteral">        Axis or axes along which the medians are computed. The default</span></div>
<div class="line"><span class="lineno"> 3787</span><span class="stringliteral">        is to compute the median along a flattened version of the array.</span></div>
<div class="line"><span class="lineno"> 3788</span><span class="stringliteral">        A sequence of axes is supported since version 1.9.0.</span></div>
<div class="line"><span class="lineno"> 3789</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3790</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno"> 3791</span><span class="stringliteral">        have the same shape and buffer length as the expected output,</span></div>
<div class="line"><span class="lineno"> 3792</span><span class="stringliteral">        but the type (of the output) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 3793</span><span class="stringliteral">    overwrite_input : bool, optional</span></div>
<div class="line"><span class="lineno"> 3794</span><span class="stringliteral">       If True, then allow use of memory of input array `a` for</span></div>
<div class="line"><span class="lineno"> 3795</span><span class="stringliteral">       calculations. The input array will be modified by the call to</span></div>
<div class="line"><span class="lineno"> 3796</span><span class="stringliteral">       `median`. This will save memory when you do not need to preserve</span></div>
<div class="line"><span class="lineno"> 3797</span><span class="stringliteral">       the contents of the input array. Treat the input as undefined,</span></div>
<div class="line"><span class="lineno"> 3798</span><span class="stringliteral">       but it will probably be fully or partially sorted. Default is</span></div>
<div class="line"><span class="lineno"> 3799</span><span class="stringliteral">       False. If `overwrite_input` is ``True`` and `a` is not already an</span></div>
<div class="line"><span class="lineno"> 3800</span><span class="stringliteral">       `ndarray`, an error will be raised.</span></div>
<div class="line"><span class="lineno"> 3801</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 3802</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left</span></div>
<div class="line"><span class="lineno"> 3803</span><span class="stringliteral">        in the result as dimensions with size one. With this option,</span></div>
<div class="line"><span class="lineno"> 3804</span><span class="stringliteral">        the result will broadcast correctly against the original `arr`.</span></div>
<div class="line"><span class="lineno"> 3805</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3806</span><span class="stringliteral">        .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno"> 3807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3808</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3809</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3810</span><span class="stringliteral">    median : ndarray</span></div>
<div class="line"><span class="lineno"> 3811</span><span class="stringliteral">        A new array holding the result. If the input contains integers</span></div>
<div class="line"><span class="lineno"> 3812</span><span class="stringliteral">        or floats smaller than ``float64``, then the output data-type is</span></div>
<div class="line"><span class="lineno"> 3813</span><span class="stringliteral">        ``np.float64``.  Otherwise, the data-type of the output is the</span></div>
<div class="line"><span class="lineno"> 3814</span><span class="stringliteral">        same as that of the input. If `out` is specified, that array is</span></div>
<div class="line"><span class="lineno"> 3815</span><span class="stringliteral">        returned instead.</span></div>
<div class="line"><span class="lineno"> 3816</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3817</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3818</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3819</span><span class="stringliteral">    mean, percentile</span></div>
<div class="line"><span class="lineno"> 3820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3821</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3822</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3823</span><span class="stringliteral">    Given a vector ``V`` of length ``N``, the median of ``V`` is the</span></div>
<div class="line"><span class="lineno"> 3824</span><span class="stringliteral">    middle value of a sorted copy of ``V``, ``V_sorted`` - i</span></div>
<div class="line"><span class="lineno"> 3825</span><span class="stringliteral">    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the</span></div>
<div class="line"><span class="lineno"> 3826</span><span class="stringliteral">    two middle values of ``V_sorted`` when ``N`` is even.</span></div>
<div class="line"><span class="lineno"> 3827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3828</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3829</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3830</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span></div>
<div class="line"><span class="lineno"> 3831</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 3832</span><span class="stringliteral">    array([[10,  7,  4],</span></div>
<div class="line"><span class="lineno"> 3833</span><span class="stringliteral">           [ 3,  2,  1]])</span></div>
<div class="line"><span class="lineno"> 3834</span><span class="stringliteral">    &gt;&gt;&gt; np.median(a)</span></div>
<div class="line"><span class="lineno"> 3835</span><span class="stringliteral">    3.5</span></div>
<div class="line"><span class="lineno"> 3836</span><span class="stringliteral">    &gt;&gt;&gt; np.median(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 3837</span><span class="stringliteral">    array([6.5, 4.5, 2.5])</span></div>
<div class="line"><span class="lineno"> 3838</span><span class="stringliteral">    &gt;&gt;&gt; np.median(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 3839</span><span class="stringliteral">    array([7.,  2.])</span></div>
<div class="line"><span class="lineno"> 3840</span><span class="stringliteral">    &gt;&gt;&gt; m = np.median(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 3841</span><span class="stringliteral">    &gt;&gt;&gt; out = np.zeros_like(m)</span></div>
<div class="line"><span class="lineno"> 3842</span><span class="stringliteral">    &gt;&gt;&gt; np.median(a, axis=0, out=m)</span></div>
<div class="line"><span class="lineno"> 3843</span><span class="stringliteral">    array([6.5,  4.5,  2.5])</span></div>
<div class="line"><span class="lineno"> 3844</span><span class="stringliteral">    &gt;&gt;&gt; m</span></div>
<div class="line"><span class="lineno"> 3845</span><span class="stringliteral">    array([6.5,  4.5,  2.5])</span></div>
<div class="line"><span class="lineno"> 3846</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 3847</span><span class="stringliteral">    &gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 3848</span><span class="stringliteral">    array([7.,  2.])</span></div>
<div class="line"><span class="lineno"> 3849</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a==b)</span></div>
<div class="line"><span class="lineno"> 3850</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 3851</span><span class="stringliteral">    &gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 3852</span><span class="stringliteral">    3.5</span></div>
<div class="line"><span class="lineno"> 3853</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a==b)</span></div>
<div class="line"><span class="lineno"> 3854</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3855</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3856</span>    <span class="keywordflow">return</span> _ureduce(a, func=_median, keepdims=keepdims, axis=axis, out=out,</div>
<div class="line"><span class="lineno"> 3857</span>                    overwrite_input=overwrite_input)</div>
<div class="line"><span class="lineno"> 3858</span> </div>
<div class="line"><span class="lineno"> 3859</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d88bc97622504e8818d631de5e3e3b9" name="a6d88bc97622504e8818d631de5e3e3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d88bc97622504e8818d631de5e3e3b9">&#9670;&#160;</a></span>meshgrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.meshgrid </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexing</em> = <code>'xy'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return coordinate matrices from coordinate vectors.

Make N-D coordinate arrays for vectorized evaluations of
N-D scalar/vector fields over N-D grids, given
one-dimensional coordinate arrays x1, x2,..., xn.

.. versionchanged:: 1.9
   1-D and 0-D cases are allowed.

Parameters
----------
x1, x2,..., xn : array_like
    1-D arrays representing the coordinates of a grid.
indexing : {'xy', 'ij'}, optional
    Cartesian ('xy', default) or matrix ('ij') indexing of output.
    See Notes for more details.

    .. versionadded:: 1.7.0
sparse : bool, optional
    If True the shape of the returned coordinate array for dimension *i*
    is reduced from ``(N1, ..., Ni, ... Nn)`` to
    ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are
    intended to be use with :ref:`basics.broadcasting`.  When all
    coordinates are used in an expression, broadcasting still leads to a
    fully-dimensonal result array.

    Default is False.

    .. versionadded:: 1.7.0
copy : bool, optional
    If False, a view into the original arrays are returned in order to
    conserve memory.  Default is True.  Please note that
    ``sparse=False, copy=False`` will likely return non-contiguous
    arrays.  Furthermore, more than one element of a broadcast array
    may refer to a single memory location.  If you need to write to the
    arrays, make copies first.

    .. versionadded:: 1.7.0

Returns
-------
X1, X2,..., XN : ndarray
    For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``,
    returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing='ij'
    or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing='xy'
    with the elements of `xi` repeated to fill the matrix along
    the first dimension for `x1`, the second for `x2` and so on.

Notes
-----
This function supports both indexing conventions through the indexing
keyword argument.  Giving the string 'ij' returns a meshgrid with
matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.
In the 2-D case with inputs of length M and N, the outputs are of shape
(N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case
with inputs of length M, N and P, outputs are of shape (N, M, P) for
'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is
illustrated by the following code snippet::

    xv, yv = np.meshgrid(x, y, indexing='ij')
    for i in range(nx):
        for j in range(ny):
            # treat xv[i,j], yv[i,j]

    xv, yv = np.meshgrid(x, y, indexing='xy')
    for i in range(nx):
        for j in range(ny):
            # treat xv[j,i], yv[j,i]

In the 1-D and 0-D case, the indexing and sparse keywords have no effect.

See Also
--------
mgrid : Construct a multi-dimensional "meshgrid" using indexing notation.
ogrid : Construct an open multi-dimensional "meshgrid" using indexing
        notation.
how-to-index

Examples
--------
&gt;&gt;&gt; nx, ny = (3, 2)
&gt;&gt;&gt; x = np.linspace(0, 1, nx)
&gt;&gt;&gt; y = np.linspace(0, 1, ny)
&gt;&gt;&gt; xv, yv = np.meshgrid(x, y)
&gt;&gt;&gt; xv
array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])
&gt;&gt;&gt; yv
array([[0.,  0.,  0.],
       [1.,  1.,  1.]])

The result of `meshgrid` is a coordinate grid:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(xv, yv, marker='o', color='k', linestyle='none')
&gt;&gt;&gt; plt.show()

You can create sparse output arrays to save memory and computation time.

&gt;&gt;&gt; xv, yv = np.meshgrid(x, y, sparse=True)
&gt;&gt;&gt; xv
array([[0. ,  0.5,  1. ]])
&gt;&gt;&gt; yv
array([[0.],
       [1.]])

`meshgrid` is very useful to evaluate functions on a grid. If the
function depends on all coordinates, both dense and sparse outputs can be
used.

&gt;&gt;&gt; x = np.linspace(-5, 5, 101)
&gt;&gt;&gt; y = np.linspace(-5, 5, 101)
&gt;&gt;&gt; # full coordinate arrays
&gt;&gt;&gt; xx, yy = np.meshgrid(x, y)
&gt;&gt;&gt; zz = np.sqrt(xx**2 + yy**2)
&gt;&gt;&gt; xx.shape, yy.shape, zz.shape
((101, 101), (101, 101), (101, 101))
&gt;&gt;&gt; # sparse coordinate arrays
&gt;&gt;&gt; xs, ys = np.meshgrid(x, y, sparse=True)
&gt;&gt;&gt; zs = np.sqrt(xs**2 + ys**2)
&gt;&gt;&gt; xs.shape, ys.shape, zs.shape
((1, 101), (101, 1), (101, 101))
&gt;&gt;&gt; np.array_equal(zz, zs)
True

&gt;&gt;&gt; h = plt.contourf(x, y, zs)
&gt;&gt;&gt; plt.axis('scaled')
&gt;&gt;&gt; plt.colorbar()
&gt;&gt;&gt; plt.show()
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4893</span><span class="keyword">def </span>meshgrid(*xi, copy=True, sparse=False, indexing=&#39;xy&#39;):</div>
<div class="line"><span class="lineno"> 4894</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4895</span><span class="stringliteral">    Return coordinate matrices from coordinate vectors.</span></div>
<div class="line"><span class="lineno"> 4896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4897</span><span class="stringliteral">    Make N-D coordinate arrays for vectorized evaluations of</span></div>
<div class="line"><span class="lineno"> 4898</span><span class="stringliteral">    N-D scalar/vector fields over N-D grids, given</span></div>
<div class="line"><span class="lineno"> 4899</span><span class="stringliteral">    one-dimensional coordinate arrays x1, x2,..., xn.</span></div>
<div class="line"><span class="lineno"> 4900</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4901</span><span class="stringliteral">    .. versionchanged:: 1.9</span></div>
<div class="line"><span class="lineno"> 4902</span><span class="stringliteral">       1-D and 0-D cases are allowed.</span></div>
<div class="line"><span class="lineno"> 4903</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4904</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4905</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4906</span><span class="stringliteral">    x1, x2,..., xn : array_like</span></div>
<div class="line"><span class="lineno"> 4907</span><span class="stringliteral">        1-D arrays representing the coordinates of a grid.</span></div>
<div class="line"><span class="lineno"> 4908</span><span class="stringliteral">    indexing : {&#39;xy&#39;, &#39;ij&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 4909</span><span class="stringliteral">        Cartesian (&#39;xy&#39;, default) or matrix (&#39;ij&#39;) indexing of output.</span></div>
<div class="line"><span class="lineno"> 4910</span><span class="stringliteral">        See Notes for more details.</span></div>
<div class="line"><span class="lineno"> 4911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4912</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 4913</span><span class="stringliteral">    sparse : bool, optional</span></div>
<div class="line"><span class="lineno"> 4914</span><span class="stringliteral">        If True the shape of the returned coordinate array for dimension *i*</span></div>
<div class="line"><span class="lineno"> 4915</span><span class="stringliteral">        is reduced from ``(N1, ..., Ni, ... Nn)`` to</span></div>
<div class="line"><span class="lineno"> 4916</span><span class="stringliteral">        ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are</span></div>
<div class="line"><span class="lineno"> 4917</span><span class="stringliteral">        intended to be use with :ref:`basics.broadcasting`.  When all</span></div>
<div class="line"><span class="lineno"> 4918</span><span class="stringliteral">        coordinates are used in an expression, broadcasting still leads to a</span></div>
<div class="line"><span class="lineno"> 4919</span><span class="stringliteral">        fully-dimensonal result array.</span></div>
<div class="line"><span class="lineno"> 4920</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4921</span><span class="stringliteral">        Default is False.</span></div>
<div class="line"><span class="lineno"> 4922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4923</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 4924</span><span class="stringliteral">    copy : bool, optional</span></div>
<div class="line"><span class="lineno"> 4925</span><span class="stringliteral">        If False, a view into the original arrays are returned in order to</span></div>
<div class="line"><span class="lineno"> 4926</span><span class="stringliteral">        conserve memory.  Default is True.  Please note that</span></div>
<div class="line"><span class="lineno"> 4927</span><span class="stringliteral">        ``sparse=False, copy=False`` will likely return non-contiguous</span></div>
<div class="line"><span class="lineno"> 4928</span><span class="stringliteral">        arrays.  Furthermore, more than one element of a broadcast array</span></div>
<div class="line"><span class="lineno"> 4929</span><span class="stringliteral">        may refer to a single memory location.  If you need to write to the</span></div>
<div class="line"><span class="lineno"> 4930</span><span class="stringliteral">        arrays, make copies first.</span></div>
<div class="line"><span class="lineno"> 4931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4932</span><span class="stringliteral">        .. versionadded:: 1.7.0</span></div>
<div class="line"><span class="lineno"> 4933</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4934</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4935</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4936</span><span class="stringliteral">    X1, X2,..., XN : ndarray</span></div>
<div class="line"><span class="lineno"> 4937</span><span class="stringliteral">        For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``,</span></div>
<div class="line"><span class="lineno"> 4938</span><span class="stringliteral">        returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing=&#39;ij&#39;</span></div>
<div class="line"><span class="lineno"> 4939</span><span class="stringliteral">        or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing=&#39;xy&#39;</span></div>
<div class="line"><span class="lineno"> 4940</span><span class="stringliteral">        with the elements of `xi` repeated to fill the matrix along</span></div>
<div class="line"><span class="lineno"> 4941</span><span class="stringliteral">        the first dimension for `x1`, the second for `x2` and so on.</span></div>
<div class="line"><span class="lineno"> 4942</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4943</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4944</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4945</span><span class="stringliteral">    This function supports both indexing conventions through the indexing</span></div>
<div class="line"><span class="lineno"> 4946</span><span class="stringliteral">    keyword argument.  Giving the string &#39;ij&#39; returns a meshgrid with</span></div>
<div class="line"><span class="lineno"> 4947</span><span class="stringliteral">    matrix indexing, while &#39;xy&#39; returns a meshgrid with Cartesian indexing.</span></div>
<div class="line"><span class="lineno"> 4948</span><span class="stringliteral">    In the 2-D case with inputs of length M and N, the outputs are of shape</span></div>
<div class="line"><span class="lineno"> 4949</span><span class="stringliteral">    (N, M) for &#39;xy&#39; indexing and (M, N) for &#39;ij&#39; indexing.  In the 3-D case</span></div>
<div class="line"><span class="lineno"> 4950</span><span class="stringliteral">    with inputs of length M, N and P, outputs are of shape (N, M, P) for</span></div>
<div class="line"><span class="lineno"> 4951</span><span class="stringliteral">    &#39;xy&#39; indexing and (M, N, P) for &#39;ij&#39; indexing.  The difference is</span></div>
<div class="line"><span class="lineno"> 4952</span><span class="stringliteral">    illustrated by the following code snippet::</span></div>
<div class="line"><span class="lineno"> 4953</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4954</span><span class="stringliteral">        xv, yv = np.meshgrid(x, y, indexing=&#39;ij&#39;)</span></div>
<div class="line"><span class="lineno"> 4955</span><span class="stringliteral">        for i in range(nx):</span></div>
<div class="line"><span class="lineno"> 4956</span><span class="stringliteral">            for j in range(ny):</span></div>
<div class="line"><span class="lineno"> 4957</span><span class="stringliteral">                # treat xv[i,j], yv[i,j]</span></div>
<div class="line"><span class="lineno"> 4958</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4959</span><span class="stringliteral">        xv, yv = np.meshgrid(x, y, indexing=&#39;xy&#39;)</span></div>
<div class="line"><span class="lineno"> 4960</span><span class="stringliteral">        for i in range(nx):</span></div>
<div class="line"><span class="lineno"> 4961</span><span class="stringliteral">            for j in range(ny):</span></div>
<div class="line"><span class="lineno"> 4962</span><span class="stringliteral">                # treat xv[j,i], yv[j,i]</span></div>
<div class="line"><span class="lineno"> 4963</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4964</span><span class="stringliteral">    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</span></div>
<div class="line"><span class="lineno"> 4965</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4966</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4967</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4968</span><span class="stringliteral">    mgrid : Construct a multi-dimensional &quot;meshgrid&quot; using indexing notation.</span></div>
<div class="line"><span class="lineno"> 4969</span><span class="stringliteral">    ogrid : Construct an open multi-dimensional &quot;meshgrid&quot; using indexing</span></div>
<div class="line"><span class="lineno"> 4970</span><span class="stringliteral">            notation.</span></div>
<div class="line"><span class="lineno"> 4971</span><span class="stringliteral">    how-to-index</span></div>
<div class="line"><span class="lineno"> 4972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4973</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4974</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4975</span><span class="stringliteral">    &gt;&gt;&gt; nx, ny = (3, 2)</span></div>
<div class="line"><span class="lineno"> 4976</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 1, nx)</span></div>
<div class="line"><span class="lineno"> 4977</span><span class="stringliteral">    &gt;&gt;&gt; y = np.linspace(0, 1, ny)</span></div>
<div class="line"><span class="lineno"> 4978</span><span class="stringliteral">    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y)</span></div>
<div class="line"><span class="lineno"> 4979</span><span class="stringliteral">    &gt;&gt;&gt; xv</span></div>
<div class="line"><span class="lineno"> 4980</span><span class="stringliteral">    array([[0. , 0.5, 1. ],</span></div>
<div class="line"><span class="lineno"> 4981</span><span class="stringliteral">           [0. , 0.5, 1. ]])</span></div>
<div class="line"><span class="lineno"> 4982</span><span class="stringliteral">    &gt;&gt;&gt; yv</span></div>
<div class="line"><span class="lineno"> 4983</span><span class="stringliteral">    array([[0.,  0.,  0.],</span></div>
<div class="line"><span class="lineno"> 4984</span><span class="stringliteral">           [1.,  1.,  1.]])</span></div>
<div class="line"><span class="lineno"> 4985</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4986</span><span class="stringliteral">    The result of `meshgrid` is a coordinate grid:</span></div>
<div class="line"><span class="lineno"> 4987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4988</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 4989</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(xv, yv, marker=&#39;o&#39;, color=&#39;k&#39;, linestyle=&#39;none&#39;)</span></div>
<div class="line"><span class="lineno"> 4990</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 4991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4992</span><span class="stringliteral">    You can create sparse output arrays to save memory and computation time.</span></div>
<div class="line"><span class="lineno"> 4993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4994</span><span class="stringliteral">    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y, sparse=True)</span></div>
<div class="line"><span class="lineno"> 4995</span><span class="stringliteral">    &gt;&gt;&gt; xv</span></div>
<div class="line"><span class="lineno"> 4996</span><span class="stringliteral">    array([[0. ,  0.5,  1. ]])</span></div>
<div class="line"><span class="lineno"> 4997</span><span class="stringliteral">    &gt;&gt;&gt; yv</span></div>
<div class="line"><span class="lineno"> 4998</span><span class="stringliteral">    array([[0.],</span></div>
<div class="line"><span class="lineno"> 4999</span><span class="stringliteral">           [1.]])</span></div>
<div class="line"><span class="lineno"> 5000</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5001</span><span class="stringliteral">    `meshgrid` is very useful to evaluate functions on a grid. If the</span></div>
<div class="line"><span class="lineno"> 5002</span><span class="stringliteral">    function depends on all coordinates, both dense and sparse outputs can be</span></div>
<div class="line"><span class="lineno"> 5003</span><span class="stringliteral">    used.</span></div>
<div class="line"><span class="lineno"> 5004</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5005</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(-5, 5, 101)</span></div>
<div class="line"><span class="lineno"> 5006</span><span class="stringliteral">    &gt;&gt;&gt; y = np.linspace(-5, 5, 101)</span></div>
<div class="line"><span class="lineno"> 5007</span><span class="stringliteral">    &gt;&gt;&gt; # full coordinate arrays</span></div>
<div class="line"><span class="lineno"> 5008</span><span class="stringliteral">    &gt;&gt;&gt; xx, yy = np.meshgrid(x, y)</span></div>
<div class="line"><span class="lineno"> 5009</span><span class="stringliteral">    &gt;&gt;&gt; zz = np.sqrt(xx**2 + yy**2)</span></div>
<div class="line"><span class="lineno"> 5010</span><span class="stringliteral">    &gt;&gt;&gt; xx.shape, yy.shape, zz.shape</span></div>
<div class="line"><span class="lineno"> 5011</span><span class="stringliteral">    ((101, 101), (101, 101), (101, 101))</span></div>
<div class="line"><span class="lineno"> 5012</span><span class="stringliteral">    &gt;&gt;&gt; # sparse coordinate arrays</span></div>
<div class="line"><span class="lineno"> 5013</span><span class="stringliteral">    &gt;&gt;&gt; xs, ys = np.meshgrid(x, y, sparse=True)</span></div>
<div class="line"><span class="lineno"> 5014</span><span class="stringliteral">    &gt;&gt;&gt; zs = np.sqrt(xs**2 + ys**2)</span></div>
<div class="line"><span class="lineno"> 5015</span><span class="stringliteral">    &gt;&gt;&gt; xs.shape, ys.shape, zs.shape</span></div>
<div class="line"><span class="lineno"> 5016</span><span class="stringliteral">    ((1, 101), (101, 1), (101, 101))</span></div>
<div class="line"><span class="lineno"> 5017</span><span class="stringliteral">    &gt;&gt;&gt; np.array_equal(zz, zs)</span></div>
<div class="line"><span class="lineno"> 5018</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno"> 5019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5020</span><span class="stringliteral">    &gt;&gt;&gt; h = plt.contourf(x, y, zs)</span></div>
<div class="line"><span class="lineno"> 5021</span><span class="stringliteral">    &gt;&gt;&gt; plt.axis(&#39;scaled&#39;)</span></div>
<div class="line"><span class="lineno"> 5022</span><span class="stringliteral">    &gt;&gt;&gt; plt.colorbar()</span></div>
<div class="line"><span class="lineno"> 5023</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 5024</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5025</span>    ndim = len(xi)</div>
<div class="line"><span class="lineno"> 5026</span> </div>
<div class="line"><span class="lineno"> 5027</span>    <span class="keywordflow">if</span> indexing <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;xy&#39;</span>, <span class="stringliteral">&#39;ij&#39;</span>]:</div>
<div class="line"><span class="lineno"> 5028</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 5029</span>            <span class="stringliteral">&quot;Valid values for `indexing` are &#39;xy&#39; and &#39;ij&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno"> 5030</span> </div>
<div class="line"><span class="lineno"> 5031</span>    s0 = (1,) * ndim</div>
<div class="line"><span class="lineno"> 5032</span>    output = [np.asanyarray(x).reshape(s0[:i] + (-1,) + s0[i + 1:])</div>
<div class="line"><span class="lineno"> 5033</span>              <span class="keywordflow">for</span> i, x <span class="keywordflow">in</span> enumerate(xi)]</div>
<div class="line"><span class="lineno"> 5034</span> </div>
<div class="line"><span class="lineno"> 5035</span>    <span class="keywordflow">if</span> indexing == <span class="stringliteral">&#39;xy&#39;</span> <span class="keywordflow">and</span> ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 5036</span>        <span class="comment"># switch first and second axis</span></div>
<div class="line"><span class="lineno"> 5037</span>        output[0].shape = (1, -1) + s0[2:]</div>
<div class="line"><span class="lineno"> 5038</span>        output[1].shape = (-1, 1) + s0[2:]</div>
<div class="line"><span class="lineno"> 5039</span> </div>
<div class="line"><span class="lineno"> 5040</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> sparse:</div>
<div class="line"><span class="lineno"> 5041</span>        <span class="comment"># Return the full N-D matrix (not only the 1-D vector)</span></div>
<div class="line"><span class="lineno"> 5042</span>        output = np.broadcast_arrays(*output, subok=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 5043</span> </div>
<div class="line"><span class="lineno"> 5044</span>    <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno"> 5045</span>        output = [x.copy() <span class="keywordflow">for</span> x <span class="keywordflow">in</span> output]</div>
<div class="line"><span class="lineno"> 5046</span> </div>
<div class="line"><span class="lineno"> 5047</span>    <span class="keywordflow">return</span> output</div>
<div class="line"><span class="lineno"> 5048</span> </div>
<div class="line"><span class="lineno"> 5049</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a95c594f2c56716496924f9606f7751cd" name="a95c594f2c56716496924f9606f7751cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c594f2c56716496924f9606f7751cd">&#9670;&#160;</a></span>msort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.msort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a copy of an array sorted along the first axis.

.. deprecated:: 1.24

   msort is deprecated, use ``np.sort(a, axis=0)`` instead.

Parameters
----------
a : array_like
    Array to be sorted.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
sort

Notes
-----
``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 4], [3, 1]])
&gt;&gt;&gt; np.msort(a)  # sort along the first axis
array([[1, 1],
       [3, 4]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 3647</span><span class="keyword">def </span>msort(a):</div>
<div class="line"><span class="lineno"> 3648</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3649</span><span class="stringliteral">    Return a copy of an array sorted along the first axis.</span></div>
<div class="line"><span class="lineno"> 3650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3651</span><span class="stringliteral">    .. deprecated:: 1.24</span></div>
<div class="line"><span class="lineno"> 3652</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3653</span><span class="stringliteral">       msort is deprecated, use ``np.sort(a, axis=0)`` instead.</span></div>
<div class="line"><span class="lineno"> 3654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3655</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3656</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3657</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3658</span><span class="stringliteral">        Array to be sorted.</span></div>
<div class="line"><span class="lineno"> 3659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3660</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3661</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3662</span><span class="stringliteral">    sorted_array : ndarray</span></div>
<div class="line"><span class="lineno"> 3663</span><span class="stringliteral">        Array of the same type and shape as `a`.</span></div>
<div class="line"><span class="lineno"> 3664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3665</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 3666</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3667</span><span class="stringliteral">    sort</span></div>
<div class="line"><span class="lineno"> 3668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3669</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3670</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3671</span><span class="stringliteral">    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.</span></div>
<div class="line"><span class="lineno"> 3672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3673</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3674</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3675</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[1, 4], [3, 1]])</span></div>
<div class="line"><span class="lineno"> 3676</span><span class="stringliteral">    &gt;&gt;&gt; np.msort(a)  # sort along the first axis</span></div>
<div class="line"><span class="lineno"> 3677</span><span class="stringliteral">    array([[1, 1],</span></div>
<div class="line"><span class="lineno"> 3678</span><span class="stringliteral">           [3, 4]])</span></div>
<div class="line"><span class="lineno"> 3679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3680</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3681</span>    <span class="comment"># 2022-10-20 1.24</span></div>
<div class="line"><span class="lineno"> 3682</span>    warnings.warn(</div>
<div class="line"><span class="lineno"> 3683</span>        <span class="stringliteral">&quot;msort is deprecated, use np.sort(a, axis=0) instead&quot;</span>,</div>
<div class="line"><span class="lineno"> 3684</span>        DeprecationWarning,</div>
<div class="line"><span class="lineno"> 3685</span>        stacklevel=3,</div>
<div class="line"><span class="lineno"> 3686</span>    )</div>
<div class="line"><span class="lineno"> 3687</span>    b = array(a, subok=<span class="keyword">True</span>, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3688</span>    b.sort(0)</div>
<div class="line"><span class="lineno"> 3689</span>    <span class="keywordflow">return</span> b</div>
<div class="line"><span class="lineno"> 3690</span> </div>
<div class="line"><span class="lineno"> 3691</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b4e514e3ecff25254cc286445e42622" name="a7b4e514e3ecff25254cc286445e42622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4e514e3ecff25254cc286445e42622">&#9670;&#160;</a></span>percentile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.percentile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the q-th percentile of the data along the specified axis.

Returns the q-th percentile(s) of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
q : array_like of float
    Percentile or sequence of percentiles to compute, which must be between
    0 and 100 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the percentiles are computed. The
    default is to compute the percentile(s) along a flattened
    version of the array.

    .. versionchanged:: 1.9.0
        A tuple of axes is supported
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
method : str, optional
    This parameter specifies the method to use for estimating the
    percentile.  There are many different methods, some unique to NumPy.
    See the notes for explanation.  The options sorted by their R type
    as summarized in the H&amp;F paper [1]_ are:

    1. 'inverted_cdf'
    2. 'averaged_inverted_cdf'
    3. 'closest_observation'
    4. 'interpolated_inverted_cdf'
    5. 'hazen'
    6. 'weibull'
    7. 'linear'  (default)
    8. 'median_unbiased'
    9. 'normal_unbiased'

    The first three methods are discontinuous.  NumPy further defines the
    following discontinuous variations of the default 'linear' (7.) option:

    * 'lower'
    * 'higher',
    * 'midpoint'
    * 'nearest'

    .. versionchanged:: 1.22.0
        This argument was previously called "interpolation" and only
        offered the "linear" default and last four options.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    .. versionadded:: 1.9.0

interpolation : str, optional
    Deprecated name for the method keyword argument.

    .. deprecated:: 1.22.0

Returns
-------
percentile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple percentiles are given, first axis of
    the result corresponds to the percentiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean
median : equivalent to ``percentile(..., 50)``
nanpercentile
quantile : equivalent to percentile, except q in the range [0, 1].

Notes
-----
Given a vector ``V`` of length ``n``, the q-th percentile of ``V`` is
the value ``q/100`` of the way from the minimum to the maximum in a
sorted copy of ``V``. The values and distances of the two nearest
neighbors as well as the `method` parameter will determine the
percentile if the normalized ranking does not match the location of
``q`` exactly. This function is the same as the median if ``q=50``, the
same as the minimum if ``q=0`` and the same as the maximum if
``q=100``.

The optional `method` parameter specifies the method to use when the
desired percentile lies between two indexes ``i`` and ``j = i + 1``.
In that case, we first determine ``i + g``, a virtual index that lies
between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the
fractional part of the index. The final result is, then, an interpolation
of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,
``i`` and ``j`` are modified using correction constants ``alpha`` and
``beta`` whose choices depend on the ``method`` used. Finally, note that
since Python uses 0-based indexing, the code subtracts another 1 from the
index internally.

The following formula determines the virtual index ``i + g``, the location 
of the percentile in the sorted sample:

.. math::
    i + g = (q / 100) * ( n - alpha - beta + 1 ) + alpha

The different methods then work as follows

inverted_cdf:
    method 1 of H&amp;F [1]_.
    This method gives discontinuous results:

    * if g &gt; 0 ; then take j
    * if g = 0 ; then take i

averaged_inverted_cdf:
    method 2 of H&amp;F [1]_.
    This method give discontinuous results:

    * if g &gt; 0 ; then take j
    * if g = 0 ; then average between bounds

closest_observation:
    method 3 of H&amp;F [1]_.
    This method give discontinuous results:

    * if g &gt; 0 ; then take j
    * if g = 0 and index is odd ; then take j
    * if g = 0 and index is even ; then take i

interpolated_inverted_cdf:
    method 4 of H&amp;F [1]_.
    This method give continuous results using:

    * alpha = 0
    * beta = 1

hazen:
    method 5 of H&amp;F [1]_.
    This method give continuous results using:

    * alpha = 1/2
    * beta = 1/2

weibull:
    method 6 of H&amp;F [1]_.
    This method give continuous results using:

    * alpha = 0
    * beta = 0

linear:
    method 7 of H&amp;F [1]_.
    This method give continuous results using:

    * alpha = 1
    * beta = 1

median_unbiased:
    method 8 of H&amp;F [1]_.
    This method is probably the best method if the sample
    distribution function is unknown (see reference).
    This method give continuous results using:

    * alpha = 1/3
    * beta = 1/3

normal_unbiased:
    method 9 of H&amp;F [1]_.
    This method is probably the best method if the sample
    distribution function is known to be normal.
    This method give continuous results using:

    * alpha = 3/8
    * beta = 3/8

lower:
    NumPy method kept for backwards compatibility.
    Takes ``i`` as the interpolation point.

higher:
    NumPy method kept for backwards compatibility.
    Takes ``j`` as the interpolation point.

nearest:
    NumPy method kept for backwards compatibility.
    Takes ``i`` or ``j``, whichever is nearest.

midpoint:
    NumPy method kept for backwards compatibility.
    Uses ``(i + j) / 2``.

Examples
--------
&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; np.percentile(a, 50)
3.5
&gt;&gt;&gt; np.percentile(a, 50, axis=0)
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; np.percentile(a, 50, axis=1)
array([7.,  2.])
&gt;&gt;&gt; np.percentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])

&gt;&gt;&gt; m = np.percentile(a, 50, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.percentile(a, 50, axis=0, out=out)
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; m
array([6.5, 4.5, 2.5])

&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)
array([7.,  2.])
&gt;&gt;&gt; assert not np.all(a == b)

The different methods can be visualized graphically:

.. plot::

    import matplotlib.pyplot as plt

    a = np.arange(4)
    p = np.linspace(0, 100, 6001)
    ax = plt.gca()
    lines = [
        ('linear', '-', 'C0'),
        ('inverted_cdf', ':', 'C1'),
        # Almost the same as `inverted_cdf`:
        ('averaged_inverted_cdf', '-.', 'C1'),
        ('closest_observation', ':', 'C2'),
        ('interpolated_inverted_cdf', '--', 'C1'),
        ('hazen', '--', 'C3'),
        ('weibull', '-.', 'C4'),
        ('median_unbiased', '--', 'C5'),
        ('normal_unbiased', '-.', 'C6'),
        ]
    for method, style, color in lines:
        ax.plot(
            p, np.percentile(a, p, method=method),
            label=method, linestyle=style, color=color)
    ax.set(
        title='Percentiles for different methods and data: ' + str(a),
        xlabel='Percentile',
        ylabel='Estimated percentile value',
        yticks=a)
    ax.legend()
    plt.show()

References
----------
.. [1] R. J. Hyndman and Y. Fan,
   "Sample quantiles in statistical packages,"
   The American Statistician, 50(4), pp. 361-365, 1996</pre> <div class="fragment"><div class="line"><span class="lineno"> 3929</span>               interpolation=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 3930</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3931</span><span class="stringliteral">    Compute the q-th percentile of the data along the specified axis.</span></div>
<div class="line"><span class="lineno"> 3932</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3933</span><span class="stringliteral">    Returns the q-th percentile(s) of the array elements.</span></div>
<div class="line"><span class="lineno"> 3934</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3935</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3936</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3937</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 3938</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 3939</span><span class="stringliteral">    q : array_like of float</span></div>
<div class="line"><span class="lineno"> 3940</span><span class="stringliteral">        Percentile or sequence of percentiles to compute, which must be between</span></div>
<div class="line"><span class="lineno"> 3941</span><span class="stringliteral">        0 and 100 inclusive.</span></div>
<div class="line"><span class="lineno"> 3942</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 3943</span><span class="stringliteral">        Axis or axes along which the percentiles are computed. The</span></div>
<div class="line"><span class="lineno"> 3944</span><span class="stringliteral">        default is to compute the percentile(s) along a flattened</span></div>
<div class="line"><span class="lineno"> 3945</span><span class="stringliteral">        version of the array.</span></div>
<div class="line"><span class="lineno"> 3946</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3947</span><span class="stringliteral">        .. versionchanged:: 1.9.0</span></div>
<div class="line"><span class="lineno"> 3948</span><span class="stringliteral">            A tuple of axes is supported</span></div>
<div class="line"><span class="lineno"> 3949</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 3950</span><span class="stringliteral">        Alternative output array in which to place the result. It must</span></div>
<div class="line"><span class="lineno"> 3951</span><span class="stringliteral">        have the same shape and buffer length as the expected output,</span></div>
<div class="line"><span class="lineno"> 3952</span><span class="stringliteral">        but the type (of the output) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 3953</span><span class="stringliteral">    overwrite_input : bool, optional</span></div>
<div class="line"><span class="lineno"> 3954</span><span class="stringliteral">        If True, then allow the input array `a` to be modified by intermediate</span></div>
<div class="line"><span class="lineno"> 3955</span><span class="stringliteral">        calculations, to save memory. In this case, the contents of the input</span></div>
<div class="line"><span class="lineno"> 3956</span><span class="stringliteral">        `a` after this function completes is undefined.</span></div>
<div class="line"><span class="lineno"> 3957</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno"> 3958</span><span class="stringliteral">        This parameter specifies the method to use for estimating the</span></div>
<div class="line"><span class="lineno"> 3959</span><span class="stringliteral">        percentile.  There are many different methods, some unique to NumPy.</span></div>
<div class="line"><span class="lineno"> 3960</span><span class="stringliteral">        See the notes for explanation.  The options sorted by their R type</span></div>
<div class="line"><span class="lineno"> 3961</span><span class="stringliteral">        as summarized in the H&amp;F paper [1]_ are:</span></div>
<div class="line"><span class="lineno"> 3962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3963</span><span class="stringliteral">        1. &#39;inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 3964</span><span class="stringliteral">        2. &#39;averaged_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 3965</span><span class="stringliteral">        3. &#39;closest_observation&#39;</span></div>
<div class="line"><span class="lineno"> 3966</span><span class="stringliteral">        4. &#39;interpolated_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 3967</span><span class="stringliteral">        5. &#39;hazen&#39;</span></div>
<div class="line"><span class="lineno"> 3968</span><span class="stringliteral">        6. &#39;weibull&#39;</span></div>
<div class="line"><span class="lineno"> 3969</span><span class="stringliteral">        7. &#39;linear&#39;  (default)</span></div>
<div class="line"><span class="lineno"> 3970</span><span class="stringliteral">        8. &#39;median_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 3971</span><span class="stringliteral">        9. &#39;normal_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 3972</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3973</span><span class="stringliteral">        The first three methods are discontinuous.  NumPy further defines the</span></div>
<div class="line"><span class="lineno"> 3974</span><span class="stringliteral">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span></div>
<div class="line"><span class="lineno"> 3975</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3976</span><span class="stringliteral">        * &#39;lower&#39;</span></div>
<div class="line"><span class="lineno"> 3977</span><span class="stringliteral">        * &#39;higher&#39;,</span></div>
<div class="line"><span class="lineno"> 3978</span><span class="stringliteral">        * &#39;midpoint&#39;</span></div>
<div class="line"><span class="lineno"> 3979</span><span class="stringliteral">        * &#39;nearest&#39;</span></div>
<div class="line"><span class="lineno"> 3980</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3981</span><span class="stringliteral">        .. versionchanged:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 3982</span><span class="stringliteral">            This argument was previously called &quot;interpolation&quot; and only</span></div>
<div class="line"><span class="lineno"> 3983</span><span class="stringliteral">            offered the &quot;linear&quot; default and last four options.</span></div>
<div class="line"><span class="lineno"> 3984</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3985</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 3986</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left in</span></div>
<div class="line"><span class="lineno"> 3987</span><span class="stringliteral">        the result as dimensions with size one. With this option, the</span></div>
<div class="line"><span class="lineno"> 3988</span><span class="stringliteral">        result will broadcast correctly against the original array `a`.</span></div>
<div class="line"><span class="lineno"> 3989</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3990</span><span class="stringliteral">        .. versionadded:: 1.9.0</span></div>
<div class="line"><span class="lineno"> 3991</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3992</span><span class="stringliteral">    interpolation : str, optional</span></div>
<div class="line"><span class="lineno"> 3993</span><span class="stringliteral">        Deprecated name for the method keyword argument.</span></div>
<div class="line"><span class="lineno"> 3994</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3995</span><span class="stringliteral">        .. deprecated:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 3996</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3997</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3998</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3999</span><span class="stringliteral">    percentile : scalar or ndarray</span></div>
<div class="line"><span class="lineno"> 4000</span><span class="stringliteral">        If `q` is a single percentile and `axis=None`, then the result</span></div>
<div class="line"><span class="lineno"> 4001</span><span class="stringliteral">        is a scalar. If multiple percentiles are given, first axis of</span></div>
<div class="line"><span class="lineno"> 4002</span><span class="stringliteral">        the result corresponds to the percentiles. The other axes are</span></div>
<div class="line"><span class="lineno"> 4003</span><span class="stringliteral">        the axes that remain after the reduction of `a`. If the input</span></div>
<div class="line"><span class="lineno"> 4004</span><span class="stringliteral">        contains integers or floats smaller than ``float64``, the output</span></div>
<div class="line"><span class="lineno"> 4005</span><span class="stringliteral">        data-type is ``float64``. Otherwise, the output data-type is the</span></div>
<div class="line"><span class="lineno"> 4006</span><span class="stringliteral">        same as that of the input. If `out` is specified, that array is</span></div>
<div class="line"><span class="lineno"> 4007</span><span class="stringliteral">        returned instead.</span></div>
<div class="line"><span class="lineno"> 4008</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4009</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4010</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4011</span><span class="stringliteral">    mean</span></div>
<div class="line"><span class="lineno"> 4012</span><span class="stringliteral">    median : equivalent to ``percentile(..., 50)``</span></div>
<div class="line"><span class="lineno"> 4013</span><span class="stringliteral">    nanpercentile</span></div>
<div class="line"><span class="lineno"> 4014</span><span class="stringliteral">    quantile : equivalent to percentile, except q in the range [0, 1].</span></div>
<div class="line"><span class="lineno"> 4015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4016</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4017</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4018</span><span class="stringliteral">    Given a vector ``V`` of length ``n``, the q-th percentile of ``V`` is</span></div>
<div class="line"><span class="lineno"> 4019</span><span class="stringliteral">    the value ``q/100`` of the way from the minimum to the maximum in a</span></div>
<div class="line"><span class="lineno"> 4020</span><span class="stringliteral">    sorted copy of ``V``. The values and distances of the two nearest</span></div>
<div class="line"><span class="lineno"> 4021</span><span class="stringliteral">    neighbors as well as the `method` parameter will determine the</span></div>
<div class="line"><span class="lineno"> 4022</span><span class="stringliteral">    percentile if the normalized ranking does not match the location of</span></div>
<div class="line"><span class="lineno"> 4023</span><span class="stringliteral">    ``q`` exactly. This function is the same as the median if ``q=50``, the</span></div>
<div class="line"><span class="lineno"> 4024</span><span class="stringliteral">    same as the minimum if ``q=0`` and the same as the maximum if</span></div>
<div class="line"><span class="lineno"> 4025</span><span class="stringliteral">    ``q=100``.</span></div>
<div class="line"><span class="lineno"> 4026</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4027</span><span class="stringliteral">    The optional `method` parameter specifies the method to use when the</span></div>
<div class="line"><span class="lineno"> 4028</span><span class="stringliteral">    desired percentile lies between two indexes ``i`` and ``j = i + 1``.</span></div>
<div class="line"><span class="lineno"> 4029</span><span class="stringliteral">    In that case, we first determine ``i + g``, a virtual index that lies</span></div>
<div class="line"><span class="lineno"> 4030</span><span class="stringliteral">    between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the</span></div>
<div class="line"><span class="lineno"> 4031</span><span class="stringliteral">    fractional part of the index. The final result is, then, an interpolation</span></div>
<div class="line"><span class="lineno"> 4032</span><span class="stringliteral">    of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,</span></div>
<div class="line"><span class="lineno"> 4033</span><span class="stringliteral">    ``i`` and ``j`` are modified using correction constants ``alpha`` and</span></div>
<div class="line"><span class="lineno"> 4034</span><span class="stringliteral">    ``beta`` whose choices depend on the ``method`` used. Finally, note that</span></div>
<div class="line"><span class="lineno"> 4035</span><span class="stringliteral">    since Python uses 0-based indexing, the code subtracts another 1 from the</span></div>
<div class="line"><span class="lineno"> 4036</span><span class="stringliteral">    index internally.</span></div>
<div class="line"><span class="lineno"> 4037</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4038</span><span class="stringliteral">    The following formula determines the virtual index ``i + g``, the location </span></div>
<div class="line"><span class="lineno"> 4039</span><span class="stringliteral">    of the percentile in the sorted sample:</span></div>
<div class="line"><span class="lineno"> 4040</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4041</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 4042</span><span class="stringliteral">        i + g = (q / 100) * ( n - alpha - beta + 1 ) + alpha</span></div>
<div class="line"><span class="lineno"> 4043</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4044</span><span class="stringliteral">    The different methods then work as follows</span></div>
<div class="line"><span class="lineno"> 4045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4046</span><span class="stringliteral">    inverted_cdf:</span></div>
<div class="line"><span class="lineno"> 4047</span><span class="stringliteral">        method 1 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4048</span><span class="stringliteral">        This method gives discontinuous results:</span></div>
<div class="line"><span class="lineno"> 4049</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4050</span><span class="stringliteral">        * if g &gt; 0 ; then take j</span></div>
<div class="line"><span class="lineno"> 4051</span><span class="stringliteral">        * if g = 0 ; then take i</span></div>
<div class="line"><span class="lineno"> 4052</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4053</span><span class="stringliteral">    averaged_inverted_cdf:</span></div>
<div class="line"><span class="lineno"> 4054</span><span class="stringliteral">        method 2 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4055</span><span class="stringliteral">        This method give discontinuous results:</span></div>
<div class="line"><span class="lineno"> 4056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4057</span><span class="stringliteral">        * if g &gt; 0 ; then take j</span></div>
<div class="line"><span class="lineno"> 4058</span><span class="stringliteral">        * if g = 0 ; then average between bounds</span></div>
<div class="line"><span class="lineno"> 4059</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4060</span><span class="stringliteral">    closest_observation:</span></div>
<div class="line"><span class="lineno"> 4061</span><span class="stringliteral">        method 3 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4062</span><span class="stringliteral">        This method give discontinuous results:</span></div>
<div class="line"><span class="lineno"> 4063</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4064</span><span class="stringliteral">        * if g &gt; 0 ; then take j</span></div>
<div class="line"><span class="lineno"> 4065</span><span class="stringliteral">        * if g = 0 and index is odd ; then take j</span></div>
<div class="line"><span class="lineno"> 4066</span><span class="stringliteral">        * if g = 0 and index is even ; then take i</span></div>
<div class="line"><span class="lineno"> 4067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4068</span><span class="stringliteral">    interpolated_inverted_cdf:</span></div>
<div class="line"><span class="lineno"> 4069</span><span class="stringliteral">        method 4 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4070</span><span class="stringliteral">        This method give continuous results using:</span></div>
<div class="line"><span class="lineno"> 4071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4072</span><span class="stringliteral">        * alpha = 0</span></div>
<div class="line"><span class="lineno"> 4073</span><span class="stringliteral">        * beta = 1</span></div>
<div class="line"><span class="lineno"> 4074</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4075</span><span class="stringliteral">    hazen:</span></div>
<div class="line"><span class="lineno"> 4076</span><span class="stringliteral">        method 5 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4077</span><span class="stringliteral">        This method give continuous results using:</span></div>
<div class="line"><span class="lineno"> 4078</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4079</span><span class="stringliteral">        * alpha = 1/2</span></div>
<div class="line"><span class="lineno"> 4080</span><span class="stringliteral">        * beta = 1/2</span></div>
<div class="line"><span class="lineno"> 4081</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4082</span><span class="stringliteral">    weibull:</span></div>
<div class="line"><span class="lineno"> 4083</span><span class="stringliteral">        method 6 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4084</span><span class="stringliteral">        This method give continuous results using:</span></div>
<div class="line"><span class="lineno"> 4085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4086</span><span class="stringliteral">        * alpha = 0</span></div>
<div class="line"><span class="lineno"> 4087</span><span class="stringliteral">        * beta = 0</span></div>
<div class="line"><span class="lineno"> 4088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4089</span><span class="stringliteral">    linear:</span></div>
<div class="line"><span class="lineno"> 4090</span><span class="stringliteral">        method 7 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4091</span><span class="stringliteral">        This method give continuous results using:</span></div>
<div class="line"><span class="lineno"> 4092</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4093</span><span class="stringliteral">        * alpha = 1</span></div>
<div class="line"><span class="lineno"> 4094</span><span class="stringliteral">        * beta = 1</span></div>
<div class="line"><span class="lineno"> 4095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4096</span><span class="stringliteral">    median_unbiased:</span></div>
<div class="line"><span class="lineno"> 4097</span><span class="stringliteral">        method 8 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4098</span><span class="stringliteral">        This method is probably the best method if the sample</span></div>
<div class="line"><span class="lineno"> 4099</span><span class="stringliteral">        distribution function is unknown (see reference).</span></div>
<div class="line"><span class="lineno"> 4100</span><span class="stringliteral">        This method give continuous results using:</span></div>
<div class="line"><span class="lineno"> 4101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4102</span><span class="stringliteral">        * alpha = 1/3</span></div>
<div class="line"><span class="lineno"> 4103</span><span class="stringliteral">        * beta = 1/3</span></div>
<div class="line"><span class="lineno"> 4104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4105</span><span class="stringliteral">    normal_unbiased:</span></div>
<div class="line"><span class="lineno"> 4106</span><span class="stringliteral">        method 9 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4107</span><span class="stringliteral">        This method is probably the best method if the sample</span></div>
<div class="line"><span class="lineno"> 4108</span><span class="stringliteral">        distribution function is known to be normal.</span></div>
<div class="line"><span class="lineno"> 4109</span><span class="stringliteral">        This method give continuous results using:</span></div>
<div class="line"><span class="lineno"> 4110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4111</span><span class="stringliteral">        * alpha = 3/8</span></div>
<div class="line"><span class="lineno"> 4112</span><span class="stringliteral">        * beta = 3/8</span></div>
<div class="line"><span class="lineno"> 4113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4114</span><span class="stringliteral">    lower:</span></div>
<div class="line"><span class="lineno"> 4115</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4116</span><span class="stringliteral">        Takes ``i`` as the interpolation point.</span></div>
<div class="line"><span class="lineno"> 4117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4118</span><span class="stringliteral">    higher:</span></div>
<div class="line"><span class="lineno"> 4119</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4120</span><span class="stringliteral">        Takes ``j`` as the interpolation point.</span></div>
<div class="line"><span class="lineno"> 4121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4122</span><span class="stringliteral">    nearest:</span></div>
<div class="line"><span class="lineno"> 4123</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4124</span><span class="stringliteral">        Takes ``i`` or ``j``, whichever is nearest.</span></div>
<div class="line"><span class="lineno"> 4125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4126</span><span class="stringliteral">    midpoint:</span></div>
<div class="line"><span class="lineno"> 4127</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4128</span><span class="stringliteral">        Uses ``(i + j) / 2``.</span></div>
<div class="line"><span class="lineno"> 4129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4130</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4131</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4132</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span></div>
<div class="line"><span class="lineno"> 4133</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 4134</span><span class="stringliteral">    array([[10,  7,  4],</span></div>
<div class="line"><span class="lineno"> 4135</span><span class="stringliteral">           [ 3,  2,  1]])</span></div>
<div class="line"><span class="lineno"> 4136</span><span class="stringliteral">    &gt;&gt;&gt; np.percentile(a, 50)</span></div>
<div class="line"><span class="lineno"> 4137</span><span class="stringliteral">    3.5</span></div>
<div class="line"><span class="lineno"> 4138</span><span class="stringliteral">    &gt;&gt;&gt; np.percentile(a, 50, axis=0)</span></div>
<div class="line"><span class="lineno"> 4139</span><span class="stringliteral">    array([6.5, 4.5, 2.5])</span></div>
<div class="line"><span class="lineno"> 4140</span><span class="stringliteral">    &gt;&gt;&gt; np.percentile(a, 50, axis=1)</span></div>
<div class="line"><span class="lineno"> 4141</span><span class="stringliteral">    array([7.,  2.])</span></div>
<div class="line"><span class="lineno"> 4142</span><span class="stringliteral">    &gt;&gt;&gt; np.percentile(a, 50, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 4143</span><span class="stringliteral">    array([[7.],</span></div>
<div class="line"><span class="lineno"> 4144</span><span class="stringliteral">           [2.]])</span></div>
<div class="line"><span class="lineno"> 4145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4146</span><span class="stringliteral">    &gt;&gt;&gt; m = np.percentile(a, 50, axis=0)</span></div>
<div class="line"><span class="lineno"> 4147</span><span class="stringliteral">    &gt;&gt;&gt; out = np.zeros_like(m)</span></div>
<div class="line"><span class="lineno"> 4148</span><span class="stringliteral">    &gt;&gt;&gt; np.percentile(a, 50, axis=0, out=out)</span></div>
<div class="line"><span class="lineno"> 4149</span><span class="stringliteral">    array([6.5, 4.5, 2.5])</span></div>
<div class="line"><span class="lineno"> 4150</span><span class="stringliteral">    &gt;&gt;&gt; m</span></div>
<div class="line"><span class="lineno"> 4151</span><span class="stringliteral">    array([6.5, 4.5, 2.5])</span></div>
<div class="line"><span class="lineno"> 4152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4153</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 4154</span><span class="stringliteral">    &gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 4155</span><span class="stringliteral">    array([7.,  2.])</span></div>
<div class="line"><span class="lineno"> 4156</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a == b)</span></div>
<div class="line"><span class="lineno"> 4157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4158</span><span class="stringliteral">    The different methods can be visualized graphically:</span></div>
<div class="line"><span class="lineno"> 4159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4160</span><span class="stringliteral">    .. plot::</span></div>
<div class="line"><span class="lineno"> 4161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4162</span><span class="stringliteral">        import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 4163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4164</span><span class="stringliteral">        a = np.arange(4)</span></div>
<div class="line"><span class="lineno"> 4165</span><span class="stringliteral">        p = np.linspace(0, 100, 6001)</span></div>
<div class="line"><span class="lineno"> 4166</span><span class="stringliteral">        ax = plt.gca()</span></div>
<div class="line"><span class="lineno"> 4167</span><span class="stringliteral">        lines = [</span></div>
<div class="line"><span class="lineno"> 4168</span><span class="stringliteral">            (&#39;linear&#39;, &#39;-&#39;, &#39;C0&#39;),</span></div>
<div class="line"><span class="lineno"> 4169</span><span class="stringliteral">            (&#39;inverted_cdf&#39;, &#39;:&#39;, &#39;C1&#39;),</span></div>
<div class="line"><span class="lineno"> 4170</span><span class="stringliteral">            # Almost the same as `inverted_cdf`:</span></div>
<div class="line"><span class="lineno"> 4171</span><span class="stringliteral">            (&#39;averaged_inverted_cdf&#39;, &#39;-.&#39;, &#39;C1&#39;),</span></div>
<div class="line"><span class="lineno"> 4172</span><span class="stringliteral">            (&#39;closest_observation&#39;, &#39;:&#39;, &#39;C2&#39;),</span></div>
<div class="line"><span class="lineno"> 4173</span><span class="stringliteral">            (&#39;interpolated_inverted_cdf&#39;, &#39;--&#39;, &#39;C1&#39;),</span></div>
<div class="line"><span class="lineno"> 4174</span><span class="stringliteral">            (&#39;hazen&#39;, &#39;--&#39;, &#39;C3&#39;),</span></div>
<div class="line"><span class="lineno"> 4175</span><span class="stringliteral">            (&#39;weibull&#39;, &#39;-.&#39;, &#39;C4&#39;),</span></div>
<div class="line"><span class="lineno"> 4176</span><span class="stringliteral">            (&#39;median_unbiased&#39;, &#39;--&#39;, &#39;C5&#39;),</span></div>
<div class="line"><span class="lineno"> 4177</span><span class="stringliteral">            (&#39;normal_unbiased&#39;, &#39;-.&#39;, &#39;C6&#39;),</span></div>
<div class="line"><span class="lineno"> 4178</span><span class="stringliteral">            ]</span></div>
<div class="line"><span class="lineno"> 4179</span><span class="stringliteral">        for method, style, color in lines:</span></div>
<div class="line"><span class="lineno"> 4180</span><span class="stringliteral">            ax.plot(</span></div>
<div class="line"><span class="lineno"> 4181</span><span class="stringliteral">                p, np.percentile(a, p, method=method),</span></div>
<div class="line"><span class="lineno"> 4182</span><span class="stringliteral">                label=method, linestyle=style, color=color)</span></div>
<div class="line"><span class="lineno"> 4183</span><span class="stringliteral">        ax.set(</span></div>
<div class="line"><span class="lineno"> 4184</span><span class="stringliteral">            title=&#39;Percentiles for different methods and data: &#39; + str(a),</span></div>
<div class="line"><span class="lineno"> 4185</span><span class="stringliteral">            xlabel=&#39;Percentile&#39;,</span></div>
<div class="line"><span class="lineno"> 4186</span><span class="stringliteral">            ylabel=&#39;Estimated percentile value&#39;,</span></div>
<div class="line"><span class="lineno"> 4187</span><span class="stringliteral">            yticks=a)</span></div>
<div class="line"><span class="lineno"> 4188</span><span class="stringliteral">        ax.legend()</span></div>
<div class="line"><span class="lineno"> 4189</span><span class="stringliteral">        plt.show()</span></div>
<div class="line"><span class="lineno"> 4190</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4191</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 4192</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4193</span><span class="stringliteral">    .. [1] R. J. Hyndman and Y. Fan,</span></div>
<div class="line"><span class="lineno"> 4194</span><span class="stringliteral">       &quot;Sample quantiles in statistical packages,&quot;</span></div>
<div class="line"><span class="lineno"> 4195</span><span class="stringliteral">       The American Statistician, 50(4), pp. 361-365, 1996</span></div>
<div class="line"><span class="lineno"> 4196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4197</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4198</span>    <span class="keywordflow">if</span> interpolation <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4199</span>        method = _check_interpolation_as_method(</div>
<div class="line"><span class="lineno"> 4200</span>            method, interpolation, <span class="stringliteral">&quot;percentile&quot;</span>)</div>
<div class="line"><span class="lineno"> 4201</span>    q = np.true_divide(q, 100)</div>
<div class="line"><span class="lineno"> 4202</span>    q = asanyarray(q)  <span class="comment"># undo any decay that the ufunc performed (see gh-13105)</span></div>
<div class="line"><span class="lineno"> 4203</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _quantile_is_valid(q):</div>
<div class="line"><span class="lineno"> 4204</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Percentiles must be in the range [0, 100]&quot;</span>)</div>
<div class="line"><span class="lineno"> 4205</span>    <span class="keywordflow">return</span> _quantile_unchecked(</div>
<div class="line"><span class="lineno"> 4206</span>        a, q, axis, out, overwrite_input, method, keepdims)</div>
<div class="line"><span class="lineno"> 4207</span> </div>
<div class="line"><span class="lineno"> 4208</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1cd513d50354ad3bf31cdf9a39773dbf" name="a1cd513d50354ad3bf31cdf9a39773dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd513d50354ad3bf31cdf9a39773dbf">&#9670;&#160;</a></span>piecewise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.piecewise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>funclist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate a piecewise-defined function.

Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.

Parameters
----------
x : ndarray or scalar
    The input domain.
condlist : list of bool arrays or bool scalars
    Each boolean array corresponds to a function in `funclist`.  Wherever
    `condlist[i]` is True, `funclist[i](x)` is used as the output value.

    Each boolean array in `condlist` selects a piece of `x`,
    and should therefore be of the same shape as `x`.

    The length of `condlist` must correspond to that of `funclist`.
    If one extra function is given, i.e. if
    ``len(funclist) == len(condlist) + 1``, then that extra function
    is the default value, used wherever all conditions are false.
funclist : list of callables, f(x,*args,**kw), or scalars
    Each function is evaluated over `x` wherever its corresponding
    condition is True.  It should take a 1d array as input and give an 1d
    array or a scalar value as output.  If, instead of a callable,
    a scalar is provided then a constant function (``lambda x: scalar``) is
    assumed.
args : tuple, optional
    Any further arguments given to `piecewise` are passed to the functions
    upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then
    each function is called as ``f(x, 1, 'a')``.
kw : dict, optional
    Keyword arguments used in calling `piecewise` are passed to the
    functions upon execution, i.e., if called
    ``piecewise(..., ..., alpha=1)``, then each function is called as
    ``f(x, alpha=1)``.

Returns
-------
out : ndarray
    The output is the same shape and type as x and is found by
    calling the functions in `funclist` on the appropriate portions of `x`,
    as defined by the boolean arrays in `condlist`.  Portions not covered
    by any condition have a default value of 0.


See Also
--------
choose, select, where

Notes
-----
This is similar to choose or select, except that functions are
evaluated on elements of `x` that satisfy the corresponding condition from
`condlist`.

The result is::

        |--
        |funclist[0](x[condlist[0]])
  out = |funclist[1](x[condlist[1]])
        |...
        |funclist[n2](x[condlist[n2]])
        |--

Examples
--------
Define the sigma function, which is -1 for ``x &lt; 0`` and +1 for ``x &gt;= 0``.

&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6)
&gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])
array([-1., -1., -1.,  1.,  1.,  1.])

Define the absolute value, which is ``-x`` for ``x &lt;0`` and ``x`` for
``x &gt;= 0``.

&gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])
array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])

Apply the same function to a scalar value.

&gt;&gt;&gt; y = -2
&gt;&gt;&gt; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])
array(2)</pre> <div class="fragment"><div class="line"><span class="lineno">  641</span><span class="keyword">def </span>piecewise(x, condlist, funclist, *args, **kw):</div>
<div class="line"><span class="lineno">  642</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral">    Evaluate a piecewise-defined function.</span></div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    Given a set of conditions and corresponding functions, evaluate each</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    function on the input data wherever its condition is true.</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">    x : ndarray or scalar</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">        The input domain.</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">    condlist : list of bool arrays or bool scalars</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        Each boolean array corresponds to a function in `funclist`.  Wherever</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral">        `condlist[i]` is True, `funclist[i](x)` is used as the output value.</span></div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        Each boolean array in `condlist` selects a piece of `x`,</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">        and should therefore be of the same shape as `x`.</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        The length of `condlist` must correspond to that of `funclist`.</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        If one extra function is given, i.e. if</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">        ``len(funclist) == len(condlist) + 1``, then that extra function</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">        is the default value, used wherever all conditions are false.</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    funclist : list of callables, f(x,*args,**kw), or scalars</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">        Each function is evaluated over `x` wherever its corresponding</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        condition is True.  It should take a 1d array as input and give an 1d</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">        array or a scalar value as output.  If, instead of a callable,</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">        a scalar is provided then a constant function (``lambda x: scalar``) is</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">        assumed.</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    args : tuple, optional</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        Any further arguments given to `piecewise` are passed to the functions</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        upon execution, i.e., if called ``piecewise(..., ..., 1, &#39;a&#39;)``, then</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        each function is called as ``f(x, 1, &#39;a&#39;)``.</span></div>
<div class="line"><span class="lineno">  673</span><span class="stringliteral">    kw : dict, optional</span></div>
<div class="line"><span class="lineno">  674</span><span class="stringliteral">        Keyword arguments used in calling `piecewise` are passed to the</span></div>
<div class="line"><span class="lineno">  675</span><span class="stringliteral">        functions upon execution, i.e., if called</span></div>
<div class="line"><span class="lineno">  676</span><span class="stringliteral">        ``piecewise(..., ..., alpha=1)``, then each function is called as</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        ``f(x, alpha=1)``.</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">        The output is the same shape and type as x and is found by</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">        calling the functions in `funclist` on the appropriate portions of `x`,</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">        as defined by the boolean arrays in `condlist`.  Portions not covered</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        by any condition have a default value of 0.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    choose, select, where</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    This is similar to choose or select, except that functions are</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    evaluated on elements of `x` that satisfy the corresponding condition from</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    `condlist`.</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    The result is::</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">            |--</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">            |funclist[0](x[condlist[0]])</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">      out = |funclist[1](x[condlist[1]])</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">            |...</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">            |funclist[n2](x[condlist[n2]])</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">            |--</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    Define the sigma function, which is -1 for ``x &lt; 0`` and +1 for ``x &gt;= 0``.</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6)</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    array([-1., -1., -1.,  1.,  1.,  1.])</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    Define the absolute value, which is ``-x`` for ``x &lt;0`` and ``x`` for</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    ``x &gt;= 0``.</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    Apply the same function to a scalar value.</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">    &gt;&gt;&gt; y = -2</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    &gt;&gt;&gt; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    array(2)</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  728</span>    x = asanyarray(x)</div>
<div class="line"><span class="lineno">  729</span>    n2 = len(funclist)</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span>    <span class="comment"># undocumented: single condition is promoted to a list of one condition</span></div>
<div class="line"><span class="lineno">  732</span>    <span class="keywordflow">if</span> isscalar(condlist) <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno">  733</span>            <span class="keywordflow">not</span> isinstance(condlist[0], (list, ndarray)) <span class="keywordflow">and</span> x.ndim != 0):</div>
<div class="line"><span class="lineno">  734</span>        condlist = [condlist]</div>
<div class="line"><span class="lineno">  735</span> </div>
<div class="line"><span class="lineno">  736</span>    condlist = asarray(condlist, dtype=bool)</div>
<div class="line"><span class="lineno">  737</span>    n = len(condlist)</div>
<div class="line"><span class="lineno">  738</span> </div>
<div class="line"><span class="lineno">  739</span>    <span class="keywordflow">if</span> n == n2 - 1:  <span class="comment"># compute the &quot;otherwise&quot; condition.</span></div>
<div class="line"><span class="lineno">  740</span>        condelse = ~np.any(condlist, axis=0, keepdims=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  741</span>        condlist = np.concatenate([condlist, condelse], axis=0)</div>
<div class="line"><span class="lineno">  742</span>        n += 1</div>
<div class="line"><span class="lineno">  743</span>    <span class="keywordflow">elif</span> n != n2:</div>
<div class="line"><span class="lineno">  744</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  745</span>            <span class="stringliteral">&quot;with {} condition(s), either {} or {} functions are expected&quot;</span></div>
<div class="line"><span class="lineno">  746</span>            .format(n, n, n+1)</div>
<div class="line"><span class="lineno">  747</span>        )</div>
<div class="line"><span class="lineno">  748</span> </div>
<div class="line"><span class="lineno">  749</span>    y = zeros_like(x)</div>
<div class="line"><span class="lineno">  750</span>    <span class="keywordflow">for</span> cond, func <span class="keywordflow">in</span> zip(condlist, funclist):</div>
<div class="line"><span class="lineno">  751</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(func, collections.abc.Callable):</div>
<div class="line"><span class="lineno">  752</span>            y[cond] = func</div>
<div class="line"><span class="lineno">  753</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  754</span>            vals = x[cond]</div>
<div class="line"><span class="lineno">  755</span>            <span class="keywordflow">if</span> vals.size &gt; 0:</div>
<div class="line"><span class="lineno">  756</span>                y[cond] = <a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(vals, *args, **kw)</div>
<div class="line"><span class="lineno">  757</span> </div>
<div class="line"><span class="lineno">  758</span>    <span class="keywordflow">return</span> y</div>
<div class="line"><span class="lineno">  759</span> </div>
<div class="line"><span class="lineno">  760</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4e851f1e69da703565e781dc75ba601" name="ae4e851f1e69da703565e781dc75ba601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e851f1e69da703565e781dc75ba601">&#9670;&#160;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.place </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Change elements of an array based on conditional and input values.

Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that
`place` uses the first N elements of `vals`, where N is the number of
True values in `mask`, while `copyto` uses the elements where `mask`
is True.

Note that `extract` does the exact opposite of `place`.

Parameters
----------
arr : ndarray
    Array to put data into.
mask : array_like
    Boolean mask array. Must have the same size as `a`.
vals : 1-D sequence
    Values to put into `a`. Only the first N elements are used, where
    N is the number of True values in `mask`. If `vals` is smaller
    than N, it will be repeated, and if elements of `a` are to be masked,
    this sequence must be non-empty.

See Also
--------
copyto, put, take, extract

Examples
--------
&gt;&gt;&gt; arr = np.arange(6).reshape(2, 3)
&gt;&gt;&gt; np.place(arr, arr&gt;2, [44, 55])
&gt;&gt;&gt; arr
array([[ 0,  1,  2],
       [44, 55, 44]])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1914</span><span class="keyword">def </span>place(arr, mask, vals):</div>
<div class="line"><span class="lineno"> 1915</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral">    Change elements of an array based on conditional and input values.</span></div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral">    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that</span></div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">    `place` uses the first N elements of `vals`, where N is the number of</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">    True values in `mask`, while `copyto` uses the elements where `mask`</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">    is True.</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">    Note that `extract` does the exact opposite of `place`.</span></div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1926</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1927</span><span class="stringliteral">    arr : ndarray</span></div>
<div class="line"><span class="lineno"> 1928</span><span class="stringliteral">        Array to put data into.</span></div>
<div class="line"><span class="lineno"> 1929</span><span class="stringliteral">    mask : array_like</span></div>
<div class="line"><span class="lineno"> 1930</span><span class="stringliteral">        Boolean mask array. Must have the same size as `a`.</span></div>
<div class="line"><span class="lineno"> 1931</span><span class="stringliteral">    vals : 1-D sequence</span></div>
<div class="line"><span class="lineno"> 1932</span><span class="stringliteral">        Values to put into `a`. Only the first N elements are used, where</span></div>
<div class="line"><span class="lineno"> 1933</span><span class="stringliteral">        N is the number of True values in `mask`. If `vals` is smaller</span></div>
<div class="line"><span class="lineno"> 1934</span><span class="stringliteral">        than N, it will be repeated, and if elements of `a` are to be masked,</span></div>
<div class="line"><span class="lineno"> 1935</span><span class="stringliteral">        this sequence must be non-empty.</span></div>
<div class="line"><span class="lineno"> 1936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1937</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1938</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1939</span><span class="stringliteral">    copyto, put, take, extract</span></div>
<div class="line"><span class="lineno"> 1940</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1941</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1942</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1943</span><span class="stringliteral">    &gt;&gt;&gt; arr = np.arange(6).reshape(2, 3)</span></div>
<div class="line"><span class="lineno"> 1944</span><span class="stringliteral">    &gt;&gt;&gt; np.place(arr, arr&gt;2, [44, 55])</span></div>
<div class="line"><span class="lineno"> 1945</span><span class="stringliteral">    &gt;&gt;&gt; arr</span></div>
<div class="line"><span class="lineno"> 1946</span><span class="stringliteral">    array([[ 0,  1,  2],</span></div>
<div class="line"><span class="lineno"> 1947</span><span class="stringliteral">           [44, 55, 44]])</span></div>
<div class="line"><span class="lineno"> 1948</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1949</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1950</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(arr, np.ndarray):</div>
<div class="line"><span class="lineno"> 1951</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;argument 1 must be numpy.ndarray, &quot;</span></div>
<div class="line"><span class="lineno"> 1952</span>                        <span class="stringliteral">&quot;not {name}&quot;</span>.format(name=type(arr).__name__))</div>
<div class="line"><span class="lineno"> 1953</span> </div>
<div class="line"><span class="lineno"> 1954</span>    <span class="keywordflow">return</span> _insert(arr, mask, vals)</div>
<div class="line"><span class="lineno"> 1955</span> </div>
<div class="line"><span class="lineno"> 1956</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a57179f55df5cbb088279582322eff2a0" name="a57179f55df5cbb088279582322eff2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57179f55df5cbb088279582322eff2a0">&#9670;&#160;</a></span>quantile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.quantile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;linear&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the q-th quantile of the data along the specified axis.

.. versionadded:: 1.15.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
q : array_like of float
    Quantile or sequence of quantiles to compute, which must be between
    0 and 1 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the quantiles are computed. The default is
    to compute the quantile(s) along a flattened version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape and buffer length as the expected output, but the
    type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by
    intermediate calculations, to save memory. In this case, the
    contents of the input `a` after this function completes is
    undefined.
method : str, optional
    This parameter specifies the method to use for estimating the
    quantile.  There are many different methods, some unique to NumPy.
    See the notes for explanation.  The options sorted by their R type
    as summarized in the H&amp;F paper [1]_ are:

    1. 'inverted_cdf'
    2. 'averaged_inverted_cdf'
    3. 'closest_observation'
    4. 'interpolated_inverted_cdf'
    5. 'hazen'
    6. 'weibull'
    7. 'linear'  (default)
    8. 'median_unbiased'
    9. 'normal_unbiased'

    The first three methods are discontinuous.  NumPy further defines the
    following discontinuous variations of the default 'linear' (7.) option:

    * 'lower'
    * 'higher',
    * 'midpoint'
    * 'nearest'

    .. versionchanged:: 1.22.0
        This argument was previously called "interpolation" and only
        offered the "linear" default and last four options.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

interpolation : str, optional
    Deprecated name for the method keyword argument.

    .. deprecated:: 1.22.0

Returns
-------
quantile : scalar or ndarray
    If `q` is a single quantile and `axis=None`, then the result
    is a scalar. If multiple quantiles are given, first axis of
    the result corresponds to the quantiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean
percentile : equivalent to quantile, but with q in the range [0, 100].
median : equivalent to ``quantile(..., 0.5)``
nanquantile

Notes
-----
Given a vector ``V`` of length ``n``, the q-th quantile of ``V`` is
the value ``q`` of the way from the minimum to the maximum in a
sorted copy of ``V``. The values and distances of the two nearest
neighbors as well as the `method` parameter will determine the
quantile if the normalized ranking does not match the location of
``q`` exactly. This function is the same as the median if ``q=0.5``, the
same as the minimum if ``q=0.0`` and the same as the maximum if
``q=1.0``.

The optional `method` parameter specifies the method to use when the
desired quantile lies between two indexes ``i`` and ``j = i + 1``.
In that case, we first determine ``i + g``, a virtual index that lies
between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the
fractional part of the index. The final result is, then, an interpolation
of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,
``i`` and ``j`` are modified using correction constants ``alpha`` and
``beta`` whose choices depend on the ``method`` used. Finally, note that
since Python uses 0-based indexing, the code subtracts another 1 from the
index internally.

The following formula determines the virtual index ``i + g``, the location 
of the quantile in the sorted sample:

.. math::
    i + g = q * ( n - alpha - beta + 1 ) + alpha

The different methods then work as follows

inverted_cdf:
    method 1 of H&amp;F [1]_.
    This method gives discontinuous results:

    * if g &gt; 0 ; then take j
    * if g = 0 ; then take i

averaged_inverted_cdf:
    method 2 of H&amp;F [1]_.
    This method gives discontinuous results:

    * if g &gt; 0 ; then take j
    * if g = 0 ; then average between bounds

closest_observation:
    method 3 of H&amp;F [1]_.
    This method gives discontinuous results:

    * if g &gt; 0 ; then take j
    * if g = 0 and index is odd ; then take j
    * if g = 0 and index is even ; then take i

interpolated_inverted_cdf:
    method 4 of H&amp;F [1]_.
    This method gives continuous results using:

    * alpha = 0
    * beta = 1

hazen:
    method 5 of H&amp;F [1]_.
    This method gives continuous results using:

    * alpha = 1/2
    * beta = 1/2

weibull:
    method 6 of H&amp;F [1]_.
    This method gives continuous results using:

    * alpha = 0
    * beta = 0

linear:
    method 7 of H&amp;F [1]_.
    This method gives continuous results using:

    * alpha = 1
    * beta = 1

median_unbiased:
    method 8 of H&amp;F [1]_.
    This method is probably the best method if the sample
    distribution function is unknown (see reference).
    This method gives continuous results using:

    * alpha = 1/3
    * beta = 1/3

normal_unbiased:
    method 9 of H&amp;F [1]_.
    This method is probably the best method if the sample
    distribution function is known to be normal.
    This method gives continuous results using:

    * alpha = 3/8
    * beta = 3/8

lower:
    NumPy method kept for backwards compatibility.
    Takes ``i`` as the interpolation point.

higher:
    NumPy method kept for backwards compatibility.
    Takes ``j`` as the interpolation point.

nearest:
    NumPy method kept for backwards compatibility.
    Takes ``i`` or ``j``, whichever is nearest.

midpoint:
    NumPy method kept for backwards compatibility.
    Uses ``(i + j) / 2``.

Examples
--------
&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; np.quantile(a, 0.5)
3.5
&gt;&gt;&gt; np.quantile(a, 0.5, axis=0)
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; np.quantile(a, 0.5, axis=1)
array([7.,  2.])
&gt;&gt;&gt; np.quantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
&gt;&gt;&gt; m = np.quantile(a, 0.5, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.quantile(a, 0.5, axis=0, out=out)
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; m
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.quantile(b, 0.5, axis=1, overwrite_input=True)
array([7.,  2.])
&gt;&gt;&gt; assert not np.all(a == b)

See also `numpy.percentile` for a visualization of most methods.

References
----------
.. [1] R. J. Hyndman and Y. Fan,
   "Sample quantiles in statistical packages,"
   The American Statistician, 50(4), pp. 361-365, 1996</pre> <div class="fragment"><div class="line"><span class="lineno"> 4223</span>             interpolation=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 4224</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4225</span><span class="stringliteral">    Compute the q-th quantile of the data along the specified axis.</span></div>
<div class="line"><span class="lineno"> 4226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4227</span><span class="stringliteral">    .. versionadded:: 1.15.0</span></div>
<div class="line"><span class="lineno"> 4228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4229</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4230</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4231</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 4232</span><span class="stringliteral">        Input array or object that can be converted to an array.</span></div>
<div class="line"><span class="lineno"> 4233</span><span class="stringliteral">    q : array_like of float</span></div>
<div class="line"><span class="lineno"> 4234</span><span class="stringliteral">        Quantile or sequence of quantiles to compute, which must be between</span></div>
<div class="line"><span class="lineno"> 4235</span><span class="stringliteral">        0 and 1 inclusive.</span></div>
<div class="line"><span class="lineno"> 4236</span><span class="stringliteral">    axis : {int, tuple of int, None}, optional</span></div>
<div class="line"><span class="lineno"> 4237</span><span class="stringliteral">        Axis or axes along which the quantiles are computed. The default is</span></div>
<div class="line"><span class="lineno"> 4238</span><span class="stringliteral">        to compute the quantile(s) along a flattened version of the array.</span></div>
<div class="line"><span class="lineno"> 4239</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 4240</span><span class="stringliteral">        Alternative output array in which to place the result. It must have</span></div>
<div class="line"><span class="lineno"> 4241</span><span class="stringliteral">        the same shape and buffer length as the expected output, but the</span></div>
<div class="line"><span class="lineno"> 4242</span><span class="stringliteral">        type (of the output) will be cast if necessary.</span></div>
<div class="line"><span class="lineno"> 4243</span><span class="stringliteral">    overwrite_input : bool, optional</span></div>
<div class="line"><span class="lineno"> 4244</span><span class="stringliteral">        If True, then allow the input array `a` to be modified by</span></div>
<div class="line"><span class="lineno"> 4245</span><span class="stringliteral">        intermediate calculations, to save memory. In this case, the</span></div>
<div class="line"><span class="lineno"> 4246</span><span class="stringliteral">        contents of the input `a` after this function completes is</span></div>
<div class="line"><span class="lineno"> 4247</span><span class="stringliteral">        undefined.</span></div>
<div class="line"><span class="lineno"> 4248</span><span class="stringliteral">    method : str, optional</span></div>
<div class="line"><span class="lineno"> 4249</span><span class="stringliteral">        This parameter specifies the method to use for estimating the</span></div>
<div class="line"><span class="lineno"> 4250</span><span class="stringliteral">        quantile.  There are many different methods, some unique to NumPy.</span></div>
<div class="line"><span class="lineno"> 4251</span><span class="stringliteral">        See the notes for explanation.  The options sorted by their R type</span></div>
<div class="line"><span class="lineno"> 4252</span><span class="stringliteral">        as summarized in the H&amp;F paper [1]_ are:</span></div>
<div class="line"><span class="lineno"> 4253</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4254</span><span class="stringliteral">        1. &#39;inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 4255</span><span class="stringliteral">        2. &#39;averaged_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 4256</span><span class="stringliteral">        3. &#39;closest_observation&#39;</span></div>
<div class="line"><span class="lineno"> 4257</span><span class="stringliteral">        4. &#39;interpolated_inverted_cdf&#39;</span></div>
<div class="line"><span class="lineno"> 4258</span><span class="stringliteral">        5. &#39;hazen&#39;</span></div>
<div class="line"><span class="lineno"> 4259</span><span class="stringliteral">        6. &#39;weibull&#39;</span></div>
<div class="line"><span class="lineno"> 4260</span><span class="stringliteral">        7. &#39;linear&#39;  (default)</span></div>
<div class="line"><span class="lineno"> 4261</span><span class="stringliteral">        8. &#39;median_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 4262</span><span class="stringliteral">        9. &#39;normal_unbiased&#39;</span></div>
<div class="line"><span class="lineno"> 4263</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4264</span><span class="stringliteral">        The first three methods are discontinuous.  NumPy further defines the</span></div>
<div class="line"><span class="lineno"> 4265</span><span class="stringliteral">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span></div>
<div class="line"><span class="lineno"> 4266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4267</span><span class="stringliteral">        * &#39;lower&#39;</span></div>
<div class="line"><span class="lineno"> 4268</span><span class="stringliteral">        * &#39;higher&#39;,</span></div>
<div class="line"><span class="lineno"> 4269</span><span class="stringliteral">        * &#39;midpoint&#39;</span></div>
<div class="line"><span class="lineno"> 4270</span><span class="stringliteral">        * &#39;nearest&#39;</span></div>
<div class="line"><span class="lineno"> 4271</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4272</span><span class="stringliteral">        .. versionchanged:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 4273</span><span class="stringliteral">            This argument was previously called &quot;interpolation&quot; and only</span></div>
<div class="line"><span class="lineno"> 4274</span><span class="stringliteral">            offered the &quot;linear&quot; default and last four options.</span></div>
<div class="line"><span class="lineno"> 4275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4276</span><span class="stringliteral">    keepdims : bool, optional</span></div>
<div class="line"><span class="lineno"> 4277</span><span class="stringliteral">        If this is set to True, the axes which are reduced are left in</span></div>
<div class="line"><span class="lineno"> 4278</span><span class="stringliteral">        the result as dimensions with size one. With this option, the</span></div>
<div class="line"><span class="lineno"> 4279</span><span class="stringliteral">        result will broadcast correctly against the original array `a`.</span></div>
<div class="line"><span class="lineno"> 4280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4281</span><span class="stringliteral">    interpolation : str, optional</span></div>
<div class="line"><span class="lineno"> 4282</span><span class="stringliteral">        Deprecated name for the method keyword argument.</span></div>
<div class="line"><span class="lineno"> 4283</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4284</span><span class="stringliteral">        .. deprecated:: 1.22.0</span></div>
<div class="line"><span class="lineno"> 4285</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4286</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4287</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4288</span><span class="stringliteral">    quantile : scalar or ndarray</span></div>
<div class="line"><span class="lineno"> 4289</span><span class="stringliteral">        If `q` is a single quantile and `axis=None`, then the result</span></div>
<div class="line"><span class="lineno"> 4290</span><span class="stringliteral">        is a scalar. If multiple quantiles are given, first axis of</span></div>
<div class="line"><span class="lineno"> 4291</span><span class="stringliteral">        the result corresponds to the quantiles. The other axes are</span></div>
<div class="line"><span class="lineno"> 4292</span><span class="stringliteral">        the axes that remain after the reduction of `a`. If the input</span></div>
<div class="line"><span class="lineno"> 4293</span><span class="stringliteral">        contains integers or floats smaller than ``float64``, the output</span></div>
<div class="line"><span class="lineno"> 4294</span><span class="stringliteral">        data-type is ``float64``. Otherwise, the output data-type is the</span></div>
<div class="line"><span class="lineno"> 4295</span><span class="stringliteral">        same as that of the input. If `out` is specified, that array is</span></div>
<div class="line"><span class="lineno"> 4296</span><span class="stringliteral">        returned instead.</span></div>
<div class="line"><span class="lineno"> 4297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4298</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4299</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4300</span><span class="stringliteral">    mean</span></div>
<div class="line"><span class="lineno"> 4301</span><span class="stringliteral">    percentile : equivalent to quantile, but with q in the range [0, 100].</span></div>
<div class="line"><span class="lineno"> 4302</span><span class="stringliteral">    median : equivalent to ``quantile(..., 0.5)``</span></div>
<div class="line"><span class="lineno"> 4303</span><span class="stringliteral">    nanquantile</span></div>
<div class="line"><span class="lineno"> 4304</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4305</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4306</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4307</span><span class="stringliteral">    Given a vector ``V`` of length ``n``, the q-th quantile of ``V`` is</span></div>
<div class="line"><span class="lineno"> 4308</span><span class="stringliteral">    the value ``q`` of the way from the minimum to the maximum in a</span></div>
<div class="line"><span class="lineno"> 4309</span><span class="stringliteral">    sorted copy of ``V``. The values and distances of the two nearest</span></div>
<div class="line"><span class="lineno"> 4310</span><span class="stringliteral">    neighbors as well as the `method` parameter will determine the</span></div>
<div class="line"><span class="lineno"> 4311</span><span class="stringliteral">    quantile if the normalized ranking does not match the location of</span></div>
<div class="line"><span class="lineno"> 4312</span><span class="stringliteral">    ``q`` exactly. This function is the same as the median if ``q=0.5``, the</span></div>
<div class="line"><span class="lineno"> 4313</span><span class="stringliteral">    same as the minimum if ``q=0.0`` and the same as the maximum if</span></div>
<div class="line"><span class="lineno"> 4314</span><span class="stringliteral">    ``q=1.0``.</span></div>
<div class="line"><span class="lineno"> 4315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4316</span><span class="stringliteral">    The optional `method` parameter specifies the method to use when the</span></div>
<div class="line"><span class="lineno"> 4317</span><span class="stringliteral">    desired quantile lies between two indexes ``i`` and ``j = i + 1``.</span></div>
<div class="line"><span class="lineno"> 4318</span><span class="stringliteral">    In that case, we first determine ``i + g``, a virtual index that lies</span></div>
<div class="line"><span class="lineno"> 4319</span><span class="stringliteral">    between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the</span></div>
<div class="line"><span class="lineno"> 4320</span><span class="stringliteral">    fractional part of the index. The final result is, then, an interpolation</span></div>
<div class="line"><span class="lineno"> 4321</span><span class="stringliteral">    of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,</span></div>
<div class="line"><span class="lineno"> 4322</span><span class="stringliteral">    ``i`` and ``j`` are modified using correction constants ``alpha`` and</span></div>
<div class="line"><span class="lineno"> 4323</span><span class="stringliteral">    ``beta`` whose choices depend on the ``method`` used. Finally, note that</span></div>
<div class="line"><span class="lineno"> 4324</span><span class="stringliteral">    since Python uses 0-based indexing, the code subtracts another 1 from the</span></div>
<div class="line"><span class="lineno"> 4325</span><span class="stringliteral">    index internally.</span></div>
<div class="line"><span class="lineno"> 4326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4327</span><span class="stringliteral">    The following formula determines the virtual index ``i + g``, the location </span></div>
<div class="line"><span class="lineno"> 4328</span><span class="stringliteral">    of the quantile in the sorted sample:</span></div>
<div class="line"><span class="lineno"> 4329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4330</span><span class="stringliteral">    .. math::</span></div>
<div class="line"><span class="lineno"> 4331</span><span class="stringliteral">        i + g = q * ( n - alpha - beta + 1 ) + alpha</span></div>
<div class="line"><span class="lineno"> 4332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4333</span><span class="stringliteral">    The different methods then work as follows</span></div>
<div class="line"><span class="lineno"> 4334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4335</span><span class="stringliteral">    inverted_cdf:</span></div>
<div class="line"><span class="lineno"> 4336</span><span class="stringliteral">        method 1 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4337</span><span class="stringliteral">        This method gives discontinuous results:</span></div>
<div class="line"><span class="lineno"> 4338</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4339</span><span class="stringliteral">        * if g &gt; 0 ; then take j</span></div>
<div class="line"><span class="lineno"> 4340</span><span class="stringliteral">        * if g = 0 ; then take i</span></div>
<div class="line"><span class="lineno"> 4341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4342</span><span class="stringliteral">    averaged_inverted_cdf:</span></div>
<div class="line"><span class="lineno"> 4343</span><span class="stringliteral">        method 2 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4344</span><span class="stringliteral">        This method gives discontinuous results:</span></div>
<div class="line"><span class="lineno"> 4345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4346</span><span class="stringliteral">        * if g &gt; 0 ; then take j</span></div>
<div class="line"><span class="lineno"> 4347</span><span class="stringliteral">        * if g = 0 ; then average between bounds</span></div>
<div class="line"><span class="lineno"> 4348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4349</span><span class="stringliteral">    closest_observation:</span></div>
<div class="line"><span class="lineno"> 4350</span><span class="stringliteral">        method 3 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4351</span><span class="stringliteral">        This method gives discontinuous results:</span></div>
<div class="line"><span class="lineno"> 4352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4353</span><span class="stringliteral">        * if g &gt; 0 ; then take j</span></div>
<div class="line"><span class="lineno"> 4354</span><span class="stringliteral">        * if g = 0 and index is odd ; then take j</span></div>
<div class="line"><span class="lineno"> 4355</span><span class="stringliteral">        * if g = 0 and index is even ; then take i</span></div>
<div class="line"><span class="lineno"> 4356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4357</span><span class="stringliteral">    interpolated_inverted_cdf:</span></div>
<div class="line"><span class="lineno"> 4358</span><span class="stringliteral">        method 4 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4359</span><span class="stringliteral">        This method gives continuous results using:</span></div>
<div class="line"><span class="lineno"> 4360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4361</span><span class="stringliteral">        * alpha = 0</span></div>
<div class="line"><span class="lineno"> 4362</span><span class="stringliteral">        * beta = 1</span></div>
<div class="line"><span class="lineno"> 4363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4364</span><span class="stringliteral">    hazen:</span></div>
<div class="line"><span class="lineno"> 4365</span><span class="stringliteral">        method 5 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4366</span><span class="stringliteral">        This method gives continuous results using:</span></div>
<div class="line"><span class="lineno"> 4367</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4368</span><span class="stringliteral">        * alpha = 1/2</span></div>
<div class="line"><span class="lineno"> 4369</span><span class="stringliteral">        * beta = 1/2</span></div>
<div class="line"><span class="lineno"> 4370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4371</span><span class="stringliteral">    weibull:</span></div>
<div class="line"><span class="lineno"> 4372</span><span class="stringliteral">        method 6 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4373</span><span class="stringliteral">        This method gives continuous results using:</span></div>
<div class="line"><span class="lineno"> 4374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4375</span><span class="stringliteral">        * alpha = 0</span></div>
<div class="line"><span class="lineno"> 4376</span><span class="stringliteral">        * beta = 0</span></div>
<div class="line"><span class="lineno"> 4377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4378</span><span class="stringliteral">    linear:</span></div>
<div class="line"><span class="lineno"> 4379</span><span class="stringliteral">        method 7 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4380</span><span class="stringliteral">        This method gives continuous results using:</span></div>
<div class="line"><span class="lineno"> 4381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4382</span><span class="stringliteral">        * alpha = 1</span></div>
<div class="line"><span class="lineno"> 4383</span><span class="stringliteral">        * beta = 1</span></div>
<div class="line"><span class="lineno"> 4384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4385</span><span class="stringliteral">    median_unbiased:</span></div>
<div class="line"><span class="lineno"> 4386</span><span class="stringliteral">        method 8 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4387</span><span class="stringliteral">        This method is probably the best method if the sample</span></div>
<div class="line"><span class="lineno"> 4388</span><span class="stringliteral">        distribution function is unknown (see reference).</span></div>
<div class="line"><span class="lineno"> 4389</span><span class="stringliteral">        This method gives continuous results using:</span></div>
<div class="line"><span class="lineno"> 4390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4391</span><span class="stringliteral">        * alpha = 1/3</span></div>
<div class="line"><span class="lineno"> 4392</span><span class="stringliteral">        * beta = 1/3</span></div>
<div class="line"><span class="lineno"> 4393</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4394</span><span class="stringliteral">    normal_unbiased:</span></div>
<div class="line"><span class="lineno"> 4395</span><span class="stringliteral">        method 9 of H&amp;F [1]_.</span></div>
<div class="line"><span class="lineno"> 4396</span><span class="stringliteral">        This method is probably the best method if the sample</span></div>
<div class="line"><span class="lineno"> 4397</span><span class="stringliteral">        distribution function is known to be normal.</span></div>
<div class="line"><span class="lineno"> 4398</span><span class="stringliteral">        This method gives continuous results using:</span></div>
<div class="line"><span class="lineno"> 4399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4400</span><span class="stringliteral">        * alpha = 3/8</span></div>
<div class="line"><span class="lineno"> 4401</span><span class="stringliteral">        * beta = 3/8</span></div>
<div class="line"><span class="lineno"> 4402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4403</span><span class="stringliteral">    lower:</span></div>
<div class="line"><span class="lineno"> 4404</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4405</span><span class="stringliteral">        Takes ``i`` as the interpolation point.</span></div>
<div class="line"><span class="lineno"> 4406</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4407</span><span class="stringliteral">    higher:</span></div>
<div class="line"><span class="lineno"> 4408</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4409</span><span class="stringliteral">        Takes ``j`` as the interpolation point.</span></div>
<div class="line"><span class="lineno"> 4410</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4411</span><span class="stringliteral">    nearest:</span></div>
<div class="line"><span class="lineno"> 4412</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4413</span><span class="stringliteral">        Takes ``i`` or ``j``, whichever is nearest.</span></div>
<div class="line"><span class="lineno"> 4414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4415</span><span class="stringliteral">    midpoint:</span></div>
<div class="line"><span class="lineno"> 4416</span><span class="stringliteral">        NumPy method kept for backwards compatibility.</span></div>
<div class="line"><span class="lineno"> 4417</span><span class="stringliteral">        Uses ``(i + j) / 2``.</span></div>
<div class="line"><span class="lineno"> 4418</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4419</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4420</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4421</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span></div>
<div class="line"><span class="lineno"> 4422</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 4423</span><span class="stringliteral">    array([[10,  7,  4],</span></div>
<div class="line"><span class="lineno"> 4424</span><span class="stringliteral">           [ 3,  2,  1]])</span></div>
<div class="line"><span class="lineno"> 4425</span><span class="stringliteral">    &gt;&gt;&gt; np.quantile(a, 0.5)</span></div>
<div class="line"><span class="lineno"> 4426</span><span class="stringliteral">    3.5</span></div>
<div class="line"><span class="lineno"> 4427</span><span class="stringliteral">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0)</span></div>
<div class="line"><span class="lineno"> 4428</span><span class="stringliteral">    array([6.5, 4.5, 2.5])</span></div>
<div class="line"><span class="lineno"> 4429</span><span class="stringliteral">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1)</span></div>
<div class="line"><span class="lineno"> 4430</span><span class="stringliteral">    array([7.,  2.])</span></div>
<div class="line"><span class="lineno"> 4431</span><span class="stringliteral">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1, keepdims=True)</span></div>
<div class="line"><span class="lineno"> 4432</span><span class="stringliteral">    array([[7.],</span></div>
<div class="line"><span class="lineno"> 4433</span><span class="stringliteral">           [2.]])</span></div>
<div class="line"><span class="lineno"> 4434</span><span class="stringliteral">    &gt;&gt;&gt; m = np.quantile(a, 0.5, axis=0)</span></div>
<div class="line"><span class="lineno"> 4435</span><span class="stringliteral">    &gt;&gt;&gt; out = np.zeros_like(m)</span></div>
<div class="line"><span class="lineno"> 4436</span><span class="stringliteral">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0, out=out)</span></div>
<div class="line"><span class="lineno"> 4437</span><span class="stringliteral">    array([6.5, 4.5, 2.5])</span></div>
<div class="line"><span class="lineno"> 4438</span><span class="stringliteral">    &gt;&gt;&gt; m</span></div>
<div class="line"><span class="lineno"> 4439</span><span class="stringliteral">    array([6.5, 4.5, 2.5])</span></div>
<div class="line"><span class="lineno"> 4440</span><span class="stringliteral">    &gt;&gt;&gt; b = a.copy()</span></div>
<div class="line"><span class="lineno"> 4441</span><span class="stringliteral">    &gt;&gt;&gt; np.quantile(b, 0.5, axis=1, overwrite_input=True)</span></div>
<div class="line"><span class="lineno"> 4442</span><span class="stringliteral">    array([7.,  2.])</span></div>
<div class="line"><span class="lineno"> 4443</span><span class="stringliteral">    &gt;&gt;&gt; assert not np.all(a == b)</span></div>
<div class="line"><span class="lineno"> 4444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4445</span><span class="stringliteral">    See also `numpy.percentile` for a visualization of most methods.</span></div>
<div class="line"><span class="lineno"> 4446</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4447</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 4448</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4449</span><span class="stringliteral">    .. [1] R. J. Hyndman and Y. Fan,</span></div>
<div class="line"><span class="lineno"> 4450</span><span class="stringliteral">       &quot;Sample quantiles in statistical packages,&quot;</span></div>
<div class="line"><span class="lineno"> 4451</span><span class="stringliteral">       The American Statistician, 50(4), pp. 361-365, 1996</span></div>
<div class="line"><span class="lineno"> 4452</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4453</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4454</span>    <span class="keywordflow">if</span> interpolation <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4455</span>        method = _check_interpolation_as_method(</div>
<div class="line"><span class="lineno"> 4456</span>            method, interpolation, <span class="stringliteral">&quot;quantile&quot;</span>)</div>
<div class="line"><span class="lineno"> 4457</span> </div>
<div class="line"><span class="lineno"> 4458</span>    q = np.asanyarray(q)</div>
<div class="line"><span class="lineno"> 4459</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _quantile_is_valid(q):</div>
<div class="line"><span class="lineno"> 4460</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Quantiles must be in the range [0, 1]&quot;</span>)</div>
<div class="line"><span class="lineno"> 4461</span>    <span class="keywordflow">return</span> _quantile_unchecked(</div>
<div class="line"><span class="lineno"> 4462</span>        a, q, axis, out, overwrite_input, method, keepdims)</div>
<div class="line"><span class="lineno"> 4463</span> </div>
<div class="line"><span class="lineno"> 4464</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5374f6a2d928557250c44f626ee930ba" name="a5374f6a2d928557250c44f626ee930ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5374f6a2d928557250c44f626ee930ba">&#9670;&#160;</a></span>rot90()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.rot90 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rotate an array by 90 degrees in the plane specified by axes.

Rotation direction is from the first towards the second axis.

Parameters
----------
m : array_like
    Array of two or more dimensions.
k : integer
    Number of times the array is rotated by 90 degrees.
axes : (2,) array_like
    The array is rotated in the plane defined by the axes.
    Axes must be different.

    .. versionadded:: 1.12.0

Returns
-------
y : ndarray
    A rotated view of `m`.

See Also
--------
flip : Reverse the order of elements in an array along the given axis.
fliplr : Flip an array horizontally.
flipud : Flip an array vertically.

Notes
-----
``rot90(m, k=1, axes=(1,0))``  is the reverse of
``rot90(m, k=1, axes=(0,1))``

``rot90(m, k=1, axes=(1,0))`` is equivalent to
``rot90(m, k=-1, axes=(0,1))``

Examples
--------
&gt;&gt;&gt; m = np.array([[1,2],[3,4]], int)
&gt;&gt;&gt; m
array([[1, 2],
       [3, 4]])
&gt;&gt;&gt; np.rot90(m)
array([[2, 4],
       [1, 3]])
&gt;&gt;&gt; np.rot90(m, 2)
array([[4, 3],
       [2, 1]])
&gt;&gt;&gt; m = np.arange(8).reshape((2,2,2))
&gt;&gt;&gt; np.rot90(m, 1, (1,2))
array([[[1, 3],
        [0, 2]],
       [[5, 7],
        [4, 6]]])</pre> <div class="fragment"><div class="line"><span class="lineno">  159</span><span class="keyword">def </span>rot90(m, k=1, axes=(0, 1)):</div>
<div class="line"><span class="lineno">  160</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    Rotate an array by 90 degrees in the plane specified by axes.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    Rotation direction is from the first towards the second axis.</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    m : array_like</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">        Array of two or more dimensions.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    k : integer</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">        Number of times the array is rotated by 90 degrees.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    axes : (2,) array_like</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">        The array is rotated in the plane defined by the axes.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">        Axes must be different.</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">        .. versionadded:: 1.12.0</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    y : ndarray</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        A rotated view of `m`.</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    flip : Reverse the order of elements in an array along the given axis.</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    fliplr : Flip an array horizontally.</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    flipud : Flip an array vertically.</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    ``rot90(m, k=1, axes=(1,0))``  is the reverse of</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    ``rot90(m, k=1, axes=(0,1))``</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    ``rot90(m, k=1, axes=(1,0))`` is equivalent to</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    ``rot90(m, k=-1, axes=(0,1))``</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    &gt;&gt;&gt; m = np.array([[1,2],[3,4]], int)</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    &gt;&gt;&gt; m</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    array([[1, 2],</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">           [3, 4]])</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    &gt;&gt;&gt; np.rot90(m)</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    array([[2, 4],</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">           [1, 3]])</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    &gt;&gt;&gt; np.rot90(m, 2)</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    array([[4, 3],</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">           [2, 1]])</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    &gt;&gt;&gt; m = np.arange(8).reshape((2,2,2))</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    &gt;&gt;&gt; np.rot90(m, 1, (1,2))</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    array([[[1, 3],</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">            [0, 2]],</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">           [[5, 7],</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">            [4, 6]]])</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  216</span>    axes = tuple(axes)</div>
<div class="line"><span class="lineno">  217</span>    <span class="keywordflow">if</span> len(axes) != 2:</div>
<div class="line"><span class="lineno">  218</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;len(axes) must be 2.&quot;</span>)</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>    m = asanyarray(m)</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">if</span> axes[0] == axes[1] <span class="keywordflow">or</span> absolute(axes[0] - axes[1]) == m.ndim:</div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Axes must be different.&quot;</span>)</div>
<div class="line"><span class="lineno">  224</span> </div>
<div class="line"><span class="lineno">  225</span>    <span class="keywordflow">if</span> (axes[0] &gt;= m.ndim <span class="keywordflow">or</span> axes[0] &lt; -m.ndim</div>
<div class="line"><span class="lineno">  226</span>        <span class="keywordflow">or</span> axes[1] &gt;= m.ndim <span class="keywordflow">or</span> axes[1] &lt; -m.ndim):</div>
<div class="line"><span class="lineno">  227</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Axes={} out of range for array of ndim={}.&quot;</span></div>
<div class="line"><span class="lineno">  228</span>            .format(axes, m.ndim))</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>    k %= 4</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">if</span> k == 0:</div>
<div class="line"><span class="lineno">  233</span>        <span class="keywordflow">return</span> m[:]</div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">if</span> k == 2:</div>
<div class="line"><span class="lineno">  235</span>        <span class="keywordflow">return</span> flip(flip(m, axes[0]), axes[1])</div>
<div class="line"><span class="lineno">  236</span> </div>
<div class="line"><span class="lineno">  237</span>    axes_list = arange(0, m.ndim)</div>
<div class="line"><span class="lineno">  238</span>    (axes_list[axes[0]], axes_list[axes[1]]) = (axes_list[axes[1]],</div>
<div class="line"><span class="lineno">  239</span>                                                axes_list[axes[0]])</div>
<div class="line"><span class="lineno">  240</span> </div>
<div class="line"><span class="lineno">  241</span>    <span class="keywordflow">if</span> k == 1:</div>
<div class="line"><span class="lineno">  242</span>        <span class="keywordflow">return</span> transpose(flip(m, axes[1]), axes_list)</div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  244</span>        <span class="comment"># k == 3</span></div>
<div class="line"><span class="lineno">  245</span>        <span class="keywordflow">return</span> flip(transpose(m, axes_list), axes[1])</div>
<div class="line"><span class="lineno">  246</span> </div>
<div class="line"><span class="lineno">  247</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5593cdafb52222befa97feaabb012c44" name="a5593cdafb52222befa97feaabb012c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5593cdafb52222befa97feaabb012c44">&#9670;&#160;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.select </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>choicelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array drawn from elements in choicelist, depending on conditions.

Parameters
----------
condlist : list of bool ndarrays
    The list of conditions which determine from which array in `choicelist`
    the output elements are taken. When multiple conditions are satisfied,
    the first one encountered in `condlist` is used.
choicelist : list of ndarrays
    The list of arrays from which the output elements are taken. It has
    to be of the same length as `condlist`.
default : scalar, optional
    The element inserted in `output` when all conditions evaluate to False.

Returns
-------
output : ndarray
    The output at position m is the m-th element of the array in
    `choicelist` where the m-th element of the corresponding array in
    `condlist` is True.

See Also
--------
where : Return elements from one of two arrays depending on condition.
take, choose, compress, diag, diagonal

Examples
--------
&gt;&gt;&gt; x = np.arange(6)
&gt;&gt;&gt; condlist = [x&lt;3, x&gt;3]
&gt;&gt;&gt; choicelist = [x, x**2]
&gt;&gt;&gt; np.select(condlist, choicelist, 42)
array([ 0,  1,  2, 42, 16, 25])

&gt;&gt;&gt; condlist = [x&lt;=4, x&gt;3]
&gt;&gt;&gt; choicelist = [x, x**2]
&gt;&gt;&gt; np.select(condlist, choicelist, 55)
array([ 0,  1,  2,  3,  4, 25])</pre> <div class="fragment"><div class="line"><span class="lineno">  767</span><span class="keyword">def </span>select(condlist, choicelist, default=0):</div>
<div class="line"><span class="lineno">  768</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    Return an array drawn from elements in choicelist, depending on conditions.</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    condlist : list of bool ndarrays</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">        The list of conditions which determine from which array in `choicelist`</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">        the output elements are taken. When multiple conditions are satisfied,</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        the first one encountered in `condlist` is used.</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">    choicelist : list of ndarrays</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">        The list of arrays from which the output elements are taken. It has</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">        to be of the same length as `condlist`.</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    default : scalar, optional</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">        The element inserted in `output` when all conditions evaluate to False.</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">        The output at position m is the m-th element of the array in</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        `choicelist` where the m-th element of the corresponding array in</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">        `condlist` is True.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    where : Return elements from one of two arrays depending on condition.</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    take, choose, compress, diag, diagonal</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    &gt;&gt;&gt; x = np.arange(6)</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    &gt;&gt;&gt; condlist = [x&lt;3, x&gt;3]</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    &gt;&gt;&gt; choicelist = [x, x**2]</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    &gt;&gt;&gt; np.select(condlist, choicelist, 42)</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    array([ 0,  1,  2, 42, 16, 25])</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">    &gt;&gt;&gt; condlist = [x&lt;=4, x&gt;3]</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    &gt;&gt;&gt; choicelist = [x, x**2]</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    &gt;&gt;&gt; np.select(condlist, choicelist, 55)</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    array([ 0,  1,  2,  3,  4, 25])</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  809</span>    <span class="comment"># Check the size of condlist and choicelist are the same, or abort.</span></div>
<div class="line"><span class="lineno">  810</span>    <span class="keywordflow">if</span> len(condlist) != len(choicelist):</div>
<div class="line"><span class="lineno">  811</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  812</span>            <span class="stringliteral">&#39;list of cases must be same length as list of conditions&#39;</span>)</div>
<div class="line"><span class="lineno">  813</span> </div>
<div class="line"><span class="lineno">  814</span>    <span class="comment"># Now that the dtype is known, handle the deprecated select([], []) case</span></div>
<div class="line"><span class="lineno">  815</span>    <span class="keywordflow">if</span> len(condlist) == 0:</div>
<div class="line"><span class="lineno">  816</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;select with an empty condition list is not possible&quot;</span>)</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span>    choicelist = [np.asarray(choice) <span class="keywordflow">for</span> choice <span class="keywordflow">in</span> choicelist]</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  821</span>        intermediate_dtype = np.result_type(*choicelist)</div>
<div class="line"><span class="lineno">  822</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  823</span>        msg = f<span class="stringliteral">&#39;Choicelist elements do not have a common dtype: {e}&#39;</span></div>
<div class="line"><span class="lineno">  824</span>        <span class="keywordflow">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  825</span>    default_array = np.asarray(default)</div>
<div class="line"><span class="lineno">  826</span>    choicelist.append(default_array)</div>
<div class="line"><span class="lineno">  827</span> </div>
<div class="line"><span class="lineno">  828</span>    <span class="comment"># need to get the result type before broadcasting for correct scalar</span></div>
<div class="line"><span class="lineno">  829</span>    <span class="comment"># behaviour</span></div>
<div class="line"><span class="lineno">  830</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  831</span>        dtype = np.result_type(intermediate_dtype, default_array)</div>
<div class="line"><span class="lineno">  832</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  833</span>        msg = f<span class="stringliteral">&#39;Choicelists and default value do not have a common dtype: {e}&#39;</span></div>
<div class="line"><span class="lineno">  834</span>        <span class="keywordflow">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  835</span> </div>
<div class="line"><span class="lineno">  836</span>    <span class="comment"># Convert conditions to arrays and broadcast conditions and choices</span></div>
<div class="line"><span class="lineno">  837</span>    <span class="comment"># as the shape is needed for the result. Doing it separately optimizes</span></div>
<div class="line"><span class="lineno">  838</span>    <span class="comment"># for example when all choices are scalars.</span></div>
<div class="line"><span class="lineno">  839</span>    condlist = np.broadcast_arrays(*condlist)</div>
<div class="line"><span class="lineno">  840</span>    choicelist = np.broadcast_arrays(*choicelist)</div>
<div class="line"><span class="lineno">  841</span> </div>
<div class="line"><span class="lineno">  842</span>    <span class="comment"># If cond array is not an ndarray in boolean format or scalar bool, abort.</span></div>
<div class="line"><span class="lineno">  843</span>    <span class="keywordflow">for</span> i, cond <span class="keywordflow">in</span> enumerate(condlist):</div>
<div class="line"><span class="lineno">  844</span>        <span class="keywordflow">if</span> cond.dtype.type <span class="keywordflow">is</span> <span class="keywordflow">not</span> np.bool_:</div>
<div class="line"><span class="lineno">  845</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno">  846</span>                <span class="stringliteral">&#39;invalid entry {} in condlist: should be boolean ndarray&#39;</span>.format(i))</div>
<div class="line"><span class="lineno">  847</span> </div>
<div class="line"><span class="lineno">  848</span>    <span class="keywordflow">if</span> choicelist[0].ndim == 0:</div>
<div class="line"><span class="lineno">  849</span>        <span class="comment"># This may be common, so avoid the call.</span></div>
<div class="line"><span class="lineno">  850</span>        result_shape = condlist[0].shape</div>
<div class="line"><span class="lineno">  851</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  852</span>        result_shape = np.broadcast_arrays(condlist[0], choicelist[0])[0].shape</div>
<div class="line"><span class="lineno">  853</span> </div>
<div class="line"><span class="lineno">  854</span>    result = np.full(result_shape, choicelist[-1], dtype)</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span>    <span class="comment"># Use np.copyto to burn each choicelist array onto result, using the</span></div>
<div class="line"><span class="lineno">  857</span>    <span class="comment"># corresponding condlist as a boolean mask. This is done in reverse</span></div>
<div class="line"><span class="lineno">  858</span>    <span class="comment"># order since the first choice should take precedence.</span></div>
<div class="line"><span class="lineno">  859</span>    choicelist = choicelist[-2::-1]</div>
<div class="line"><span class="lineno">  860</span>    condlist = condlist[::-1]</div>
<div class="line"><span class="lineno">  861</span>    <span class="keywordflow">for</span> choice, cond <span class="keywordflow">in</span> zip(choicelist, condlist):</div>
<div class="line"><span class="lineno">  862</span>        np.copyto(result, choice, where=cond)</div>
<div class="line"><span class="lineno">  863</span> </div>
<div class="line"><span class="lineno">  864</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  865</span> </div>
<div class="line"><span class="lineno">  866</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1037c45a8411f2e3cd9dcf9a9ed7c75c" name="a1037c45a8411f2e3cd9dcf9a9ed7c75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1037c45a8411f2e3cd9dcf9a9ed7c75c">&#9670;&#160;</a></span>sinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.sinc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the normalized sinc function.

The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument
:math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not
only everywhere continuous but also infinitely differentiable.

.. note::

    Note the normalization factor of ``pi`` used in the definition.
    This is the most commonly used definition in signal processing.
    Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function
    :math:`\sin(x)/x` that is more common in mathematics.

Parameters
----------
x : ndarray
    Array (possibly multi-dimensional) of values for which to calculate
    ``sinc(x)``.

Returns
-------
out : ndarray
    ``sinc(x)``, which has the same shape as the input.

Notes
-----
The name sinc is short for "sine cardinal" or "sinus cardinalis".

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
.. [1] Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
       Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, "Sinc function",
       https://en.wikipedia.org/wiki/Sinc_function

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.linspace(-4, 4, 41)
&gt;&gt;&gt; np.sinc(x)
 array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
        -4.92362781e-02,  -3.89804309e-17])

&gt;&gt;&gt; plt.plot(x, np.sinc(x))
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Sinc Function")
Text(0.5, 1.0, 'Sinc Function')
&gt;&gt;&gt; plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
&gt;&gt;&gt; plt.xlabel("X")
Text(0.5, 0, 'X')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno"> 3562</span><span class="keyword">def </span>sinc(x):</div>
<div class="line"><span class="lineno"> 3563</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3564</span><span class="stringliteral">    Return the normalized sinc function.</span></div>
<div class="line"><span class="lineno"> 3565</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3566</span><span class="stringliteral">    The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument</span></div>
<div class="line"><span class="lineno"> 3567</span><span class="stringliteral">    :math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not</span></div>
<div class="line"><span class="lineno"> 3568</span><span class="stringliteral">    only everywhere continuous but also infinitely differentiable.</span></div>
<div class="line"><span class="lineno"> 3569</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3570</span><span class="stringliteral">    .. note::</span></div>
<div class="line"><span class="lineno"> 3571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3572</span><span class="stringliteral">        Note the normalization factor of ``pi`` used in the definition.</span></div>
<div class="line"><span class="lineno"> 3573</span><span class="stringliteral">        This is the most commonly used definition in signal processing.</span></div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral">        Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function</span></div>
<div class="line"><span class="lineno"> 3575</span><span class="stringliteral">        :math:`\sin(x)/x` that is more common in mathematics.</span></div>
<div class="line"><span class="lineno"> 3576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3577</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 3578</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3579</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno"> 3580</span><span class="stringliteral">        Array (possibly multi-dimensional) of values for which to calculate</span></div>
<div class="line"><span class="lineno"> 3581</span><span class="stringliteral">        ``sinc(x)``.</span></div>
<div class="line"><span class="lineno"> 3582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3583</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 3584</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 3585</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 3586</span><span class="stringliteral">        ``sinc(x)``, which has the same shape as the input.</span></div>
<div class="line"><span class="lineno"> 3587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3588</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 3589</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 3590</span><span class="stringliteral">    The name sinc is short for &quot;sine cardinal&quot; or &quot;sinus cardinalis&quot;.</span></div>
<div class="line"><span class="lineno"> 3591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3592</span><span class="stringliteral">    The sinc function is used in various signal processing applications,</span></div>
<div class="line"><span class="lineno"> 3593</span><span class="stringliteral">    including in anti-aliasing, in the construction of a Lanczos resampling</span></div>
<div class="line"><span class="lineno"> 3594</span><span class="stringliteral">    filter, and in interpolation.</span></div>
<div class="line"><span class="lineno"> 3595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3596</span><span class="stringliteral">    For bandlimited interpolation of discrete-time signals, the ideal</span></div>
<div class="line"><span class="lineno"> 3597</span><span class="stringliteral">    interpolation kernel is proportional to the sinc function.</span></div>
<div class="line"><span class="lineno"> 3598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3599</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 3600</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 3601</span><span class="stringliteral">    .. [1] Weisstein, Eric W. &quot;Sinc Function.&quot; From MathWorld--A Wolfram Web</span></div>
<div class="line"><span class="lineno"> 3602</span><span class="stringliteral">           Resource. http://mathworld.wolfram.com/SincFunction.html</span></div>
<div class="line"><span class="lineno"> 3603</span><span class="stringliteral">    .. [2] Wikipedia, &quot;Sinc function&quot;,</span></div>
<div class="line"><span class="lineno"> 3604</span><span class="stringliteral">           https://en.wikipedia.org/wiki/Sinc_function</span></div>
<div class="line"><span class="lineno"> 3605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3606</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 3607</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 3608</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 3609</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(-4, 4, 41)</span></div>
<div class="line"><span class="lineno"> 3610</span><span class="stringliteral">    &gt;&gt;&gt; np.sinc(x)</span></div>
<div class="line"><span class="lineno"> 3611</span><span class="stringliteral">     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary</span></div>
<div class="line"><span class="lineno"> 3612</span><span class="stringliteral">            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,</span></div>
<div class="line"><span class="lineno"> 3613</span><span class="stringliteral">            6.68206631e-02,   1.16434881e-01,   1.26137788e-01,</span></div>
<div class="line"><span class="lineno"> 3614</span><span class="stringliteral">            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,</span></div>
<div class="line"><span class="lineno"> 3615</span><span class="stringliteral">            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,</span></div>
<div class="line"><span class="lineno"> 3616</span><span class="stringliteral">            3.89804309e-17,   2.33872321e-01,   5.04551152e-01,</span></div>
<div class="line"><span class="lineno"> 3617</span><span class="stringliteral">            7.56826729e-01,   9.35489284e-01,   1.00000000e+00,</span></div>
<div class="line"><span class="lineno"> 3618</span><span class="stringliteral">            9.35489284e-01,   7.56826729e-01,   5.04551152e-01,</span></div>
<div class="line"><span class="lineno"> 3619</span><span class="stringliteral">            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,</span></div>
<div class="line"><span class="lineno"> 3620</span><span class="stringliteral">           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,</span></div>
<div class="line"><span class="lineno"> 3621</span><span class="stringliteral">           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,</span></div>
<div class="line"><span class="lineno"> 3622</span><span class="stringliteral">            1.16434881e-01,   6.68206631e-02,   3.89804309e-17,</span></div>
<div class="line"><span class="lineno"> 3623</span><span class="stringliteral">            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,</span></div>
<div class="line"><span class="lineno"> 3624</span><span class="stringliteral">            -4.92362781e-02,  -3.89804309e-17])</span></div>
<div class="line"><span class="lineno"> 3625</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3626</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x, np.sinc(x))</span></div>
<div class="line"><span class="lineno"> 3627</span><span class="stringliteral">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span></div>
<div class="line"><span class="lineno"> 3628</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&quot;Sinc Function&quot;)</span></div>
<div class="line"><span class="lineno"> 3629</span><span class="stringliteral">    Text(0.5, 1.0, &#39;Sinc Function&#39;)</span></div>
<div class="line"><span class="lineno"> 3630</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span></div>
<div class="line"><span class="lineno"> 3631</span><span class="stringliteral">    Text(0, 0.5, &#39;Amplitude&#39;)</span></div>
<div class="line"><span class="lineno"> 3632</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&quot;X&quot;)</span></div>
<div class="line"><span class="lineno"> 3633</span><span class="stringliteral">    Text(0.5, 0, &#39;X&#39;)</span></div>
<div class="line"><span class="lineno"> 3634</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno"> 3635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3636</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3637</span>    x = np.asanyarray(x)</div>
<div class="line"><span class="lineno"> 3638</span>    y = pi * where(x == 0, 1.0e-20, x)</div>
<div class="line"><span class="lineno"> 3639</span>    <span class="keywordflow">return</span> sin(y)/y</div>
<div class="line"><span class="lineno"> 3640</span> </div>
<div class="line"><span class="lineno"> 3641</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a12184eaf5717d61a52570d93c2dfc98f" name="a12184eaf5717d61a52570d93c2dfc98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12184eaf5717d61a52570d93c2dfc98f">&#9670;&#160;</a></span>sort_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.sort_complex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sort a complex array using the real part first, then the imaginary part.

Parameters
----------
a : array_like
    Input array

Returns
-------
out : complex ndarray
    Always returns a sorted complex array.

Examples
--------
&gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])
array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])

&gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</pre> <div class="fragment"><div class="line"><span class="lineno"> 1760</span><span class="keyword">def </span>sort_complex(a):</div>
<div class="line"><span class="lineno"> 1761</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1762</span><span class="stringliteral">    Sort a complex array using the real part first, then the imaginary part.</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1764</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1765</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1766</span><span class="stringliteral">    a : array_like</span></div>
<div class="line"><span class="lineno"> 1767</span><span class="stringliteral">        Input array</span></div>
<div class="line"><span class="lineno"> 1768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1769</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1770</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1771</span><span class="stringliteral">    out : complex ndarray</span></div>
<div class="line"><span class="lineno"> 1772</span><span class="stringliteral">        Always returns a sorted complex array.</span></div>
<div class="line"><span class="lineno"> 1773</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1774</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1775</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1776</span><span class="stringliteral">    &gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])</span></div>
<div class="line"><span class="lineno"> 1777</span><span class="stringliteral">    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])</span></div>
<div class="line"><span class="lineno"> 1778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1779</span><span class="stringliteral">    &gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])</span></div>
<div class="line"><span class="lineno"> 1780</span><span class="stringliteral">    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</span></div>
<div class="line"><span class="lineno"> 1781</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1782</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1783</span>    b = array(a, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1784</span>    b.sort()</div>
<div class="line"><span class="lineno"> 1785</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> issubclass(b.dtype.type, _nx.complexfloating):</div>
<div class="line"><span class="lineno"> 1786</span>        <span class="keywordflow">if</span> b.dtype.char <span class="keywordflow">in</span> <span class="stringliteral">&#39;bhBH&#39;</span>:</div>
<div class="line"><span class="lineno"> 1787</span>            <span class="keywordflow">return</span> b.astype(<span class="stringliteral">&#39;F&#39;</span>)</div>
<div class="line"><span class="lineno"> 1788</span>        <span class="keywordflow">elif</span> b.dtype.char == <span class="stringliteral">&#39;g&#39;</span>:</div>
<div class="line"><span class="lineno"> 1789</span>            <span class="keywordflow">return</span> b.astype(<span class="stringliteral">&#39;G&#39;</span>)</div>
<div class="line"><span class="lineno"> 1790</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1791</span>            <span class="keywordflow">return</span> b.astype(<span class="stringliteral">&#39;D&#39;</span>)</div>
<div class="line"><span class="lineno"> 1792</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1793</span>        <span class="keywordflow">return</span> b</div>
<div class="line"><span class="lineno"> 1794</span> </div>
<div class="line"><span class="lineno"> 1795</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a78a1f30ec367d053bf4eee0cf62e3007" name="a78a1f30ec367d053bf4eee0cf62e3007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a1f30ec367d053bf4eee0cf62e3007">&#9670;&#160;</a></span>trapz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.trapz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integrate along the given axis using the composite trapezoidal rule.

If `x` is provided, the integration happens in sequence along its
elements - they are not sorted.

Integrate `y` (`x`) along each 1d slice on the given axis, compute
:math:`\int y(x) dx`.
When `x` is specified, this integrates along the parametric curve,
computing :math:`\int_t y(t) dt =
\int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`.

Parameters
----------
y : array_like
Input array to integrate.
x : array_like, optional
The sample points corresponding to the `y` values. If `x` is None,
the sample points are assumed to be evenly spaced `dx` apart. The
default is None.
dx : scalar, optional
The spacing between sample points when `x` is None. The default is 1.
axis : int, optional
The axis along which to integrate.

Returns
-------
trapz : float or ndarray
Definite integral of `y` = n-dimensional array as approximated along
a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,
then the result is a float. If `n` is greater than 1, then the result
is an `n`-1 dimensional array.

See Also
--------
sum, cumsum

Notes
-----
Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
will be taken from `y` array, by default x-axis distances between
points will be 1.0, alternatively they can be provided with `x` array
or with `dx` scalar.  Return value will be equal to combined area under
the red lines.


References
----------
.. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule

.. [2] Illustration image:
https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png

Examples
--------
&gt;&gt;&gt; np.trapz([1,2,3])
4.0
&gt;&gt;&gt; np.trapz([1,2,3], x=[4,6,8])
8.0
&gt;&gt;&gt; np.trapz([1,2,3], dx=2)
8.0

Using a decreasing `x` corresponds to integrating in reverse:

&gt;&gt;&gt; np.trapz([1,2,3], x=[8,6,4])
-8.0

More generally `x` is used to integrate along a parametric curve.
This finds the area of a circle, noting we repeat the sample which closes
the curve:

&gt;&gt;&gt; theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)
&gt;&gt;&gt; np.trapz(np.cos(theta), x=np.sin(theta))
3.141571941375841

&gt;&gt;&gt; a = np.arange(6).reshape(2, 3)
&gt;&gt;&gt; a
array([[0, 1, 2],
[3, 4, 5]])
&gt;&gt;&gt; np.trapz(a, axis=0)
array([1.5, 2.5, 3.5])
&gt;&gt;&gt; np.trapz(a, axis=1)
array([2.,  8.])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4774</span><span class="keyword">def </span>trapz(y, x=None, dx=1.0, axis=-1):</div>
<div class="line"><span class="lineno"> 4775</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4776</span><span class="stringliteral">    Integrate along the given axis using the composite trapezoidal rule.</span></div>
<div class="line"><span class="lineno"> 4777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4778</span><span class="stringliteral">    If `x` is provided, the integration happens in sequence along its</span></div>
<div class="line"><span class="lineno"> 4779</span><span class="stringliteral">    elements - they are not sorted.</span></div>
<div class="line"><span class="lineno"> 4780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4781</span><span class="stringliteral">    Integrate `y` (`x`) along each 1d slice on the given axis, compute</span></div>
<div class="line"><span class="lineno"> 4782</span><span class="stringliteral">    :math:`\int y(x) dx`.</span></div>
<div class="line"><span class="lineno"> 4783</span><span class="stringliteral">    When `x` is specified, this integrates along the parametric curve,</span></div>
<div class="line"><span class="lineno"> 4784</span><span class="stringliteral">    computing :math:`\int_t y(t) dt =</span></div>
<div class="line"><span class="lineno"> 4785</span><span class="stringliteral">    \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`.</span></div>
<div class="line"><span class="lineno"> 4786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4787</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 4788</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4789</span><span class="stringliteral">    y : array_like</span></div>
<div class="line"><span class="lineno"> 4790</span><span class="stringliteral">        Input array to integrate.</span></div>
<div class="line"><span class="lineno"> 4791</span><span class="stringliteral">    x : array_like, optional</span></div>
<div class="line"><span class="lineno"> 4792</span><span class="stringliteral">        The sample points corresponding to the `y` values. If `x` is None,</span></div>
<div class="line"><span class="lineno"> 4793</span><span class="stringliteral">        the sample points are assumed to be evenly spaced `dx` apart. The</span></div>
<div class="line"><span class="lineno"> 4794</span><span class="stringliteral">        default is None.</span></div>
<div class="line"><span class="lineno"> 4795</span><span class="stringliteral">    dx : scalar, optional</span></div>
<div class="line"><span class="lineno"> 4796</span><span class="stringliteral">        The spacing between sample points when `x` is None. The default is 1.</span></div>
<div class="line"><span class="lineno"> 4797</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 4798</span><span class="stringliteral">        The axis along which to integrate.</span></div>
<div class="line"><span class="lineno"> 4799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4800</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 4801</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 4802</span><span class="stringliteral">    trapz : float or ndarray</span></div>
<div class="line"><span class="lineno"> 4803</span><span class="stringliteral">        Definite integral of `y` = n-dimensional array as approximated along</span></div>
<div class="line"><span class="lineno"> 4804</span><span class="stringliteral">        a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,</span></div>
<div class="line"><span class="lineno"> 4805</span><span class="stringliteral">        then the result is a float. If `n` is greater than 1, then the result</span></div>
<div class="line"><span class="lineno"> 4806</span><span class="stringliteral">        is an `n`-1 dimensional array.</span></div>
<div class="line"><span class="lineno"> 4807</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4808</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 4809</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4810</span><span class="stringliteral">    sum, cumsum</span></div>
<div class="line"><span class="lineno"> 4811</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4812</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 4813</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 4814</span><span class="stringliteral">    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points</span></div>
<div class="line"><span class="lineno"> 4815</span><span class="stringliteral">    will be taken from `y` array, by default x-axis distances between</span></div>
<div class="line"><span class="lineno"> 4816</span><span class="stringliteral">    points will be 1.0, alternatively they can be provided with `x` array</span></div>
<div class="line"><span class="lineno"> 4817</span><span class="stringliteral">    or with `dx` scalar.  Return value will be equal to combined area under</span></div>
<div class="line"><span class="lineno"> 4818</span><span class="stringliteral">    the red lines.</span></div>
<div class="line"><span class="lineno"> 4819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4820</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4821</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 4822</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 4823</span><span class="stringliteral">    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule</span></div>
<div class="line"><span class="lineno"> 4824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4825</span><span class="stringliteral">    .. [2] Illustration image:</span></div>
<div class="line"><span class="lineno"> 4826</span><span class="stringliteral">           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png</span></div>
<div class="line"><span class="lineno"> 4827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4828</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 4829</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 4830</span><span class="stringliteral">    &gt;&gt;&gt; np.trapz([1,2,3])</span></div>
<div class="line"><span class="lineno"> 4831</span><span class="stringliteral">    4.0</span></div>
<div class="line"><span class="lineno"> 4832</span><span class="stringliteral">    &gt;&gt;&gt; np.trapz([1,2,3], x=[4,6,8])</span></div>
<div class="line"><span class="lineno"> 4833</span><span class="stringliteral">    8.0</span></div>
<div class="line"><span class="lineno"> 4834</span><span class="stringliteral">    &gt;&gt;&gt; np.trapz([1,2,3], dx=2)</span></div>
<div class="line"><span class="lineno"> 4835</span><span class="stringliteral">    8.0</span></div>
<div class="line"><span class="lineno"> 4836</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4837</span><span class="stringliteral">    Using a decreasing `x` corresponds to integrating in reverse:</span></div>
<div class="line"><span class="lineno"> 4838</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4839</span><span class="stringliteral">    &gt;&gt;&gt; np.trapz([1,2,3], x=[8,6,4])</span></div>
<div class="line"><span class="lineno"> 4840</span><span class="stringliteral">    -8.0</span></div>
<div class="line"><span class="lineno"> 4841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4842</span><span class="stringliteral">    More generally `x` is used to integrate along a parametric curve.</span></div>
<div class="line"><span class="lineno"> 4843</span><span class="stringliteral">    This finds the area of a circle, noting we repeat the sample which closes</span></div>
<div class="line"><span class="lineno"> 4844</span><span class="stringliteral">    the curve:</span></div>
<div class="line"><span class="lineno"> 4845</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4846</span><span class="stringliteral">    &gt;&gt;&gt; theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)</span></div>
<div class="line"><span class="lineno"> 4847</span><span class="stringliteral">    &gt;&gt;&gt; np.trapz(np.cos(theta), x=np.sin(theta))</span></div>
<div class="line"><span class="lineno"> 4848</span><span class="stringliteral">    3.141571941375841</span></div>
<div class="line"><span class="lineno"> 4849</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4850</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3)</span></div>
<div class="line"><span class="lineno"> 4851</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 4852</span><span class="stringliteral">    array([[0, 1, 2],</span></div>
<div class="line"><span class="lineno"> 4853</span><span class="stringliteral">           [3, 4, 5]])</span></div>
<div class="line"><span class="lineno"> 4854</span><span class="stringliteral">    &gt;&gt;&gt; np.trapz(a, axis=0)</span></div>
<div class="line"><span class="lineno"> 4855</span><span class="stringliteral">    array([1.5, 2.5, 3.5])</span></div>
<div class="line"><span class="lineno"> 4856</span><span class="stringliteral">    &gt;&gt;&gt; np.trapz(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 4857</span><span class="stringliteral">    array([2.,  8.])</span></div>
<div class="line"><span class="lineno"> 4858</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4859</span>    y = asanyarray(y)</div>
<div class="line"><span class="lineno"> 4860</span>    <span class="keywordflow">if</span> x <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4861</span>        d = dx</div>
<div class="line"><span class="lineno"> 4862</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4863</span>        x = asanyarray(x)</div>
<div class="line"><span class="lineno"> 4864</span>        <span class="keywordflow">if</span> x.ndim == 1:</div>
<div class="line"><span class="lineno"> 4865</span>            d = diff(x)</div>
<div class="line"><span class="lineno"> 4866</span>            <span class="comment"># reshape to correct shape</span></div>
<div class="line"><span class="lineno"> 4867</span>            shape = [1]*y.ndim</div>
<div class="line"><span class="lineno"> 4868</span>            shape[axis] = d.shape[0]</div>
<div class="line"><span class="lineno"> 4869</span>            d = d.reshape(shape)</div>
<div class="line"><span class="lineno"> 4870</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4871</span>            d = diff(x, axis=axis)</div>
<div class="line"><span class="lineno"> 4872</span>    nd = y.ndim</div>
<div class="line"><span class="lineno"> 4873</span>    slice1 = [slice(<span class="keywordtype">None</span>)]*nd</div>
<div class="line"><span class="lineno"> 4874</span>    slice2 = [slice(<span class="keywordtype">None</span>)]*nd</div>
<div class="line"><span class="lineno"> 4875</span>    slice1[axis] = slice(1, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 4876</span>    slice2[axis] = slice(<span class="keywordtype">None</span>, -1)</div>
<div class="line"><span class="lineno"> 4877</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 4878</span>        ret = (d * (y[tuple(slice1)] + y[tuple(slice2)]) / 2.0).sum(axis)</div>
<div class="line"><span class="lineno"> 4879</span>    <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 4880</span>        <span class="comment"># Operations didn&#39;t work, cast to ndarray</span></div>
<div class="line"><span class="lineno"> 4881</span>        d = np.asarray(d)</div>
<div class="line"><span class="lineno"> 4882</span>        y = np.asarray(y)</div>
<div class="line"><span class="lineno"> 4883</span>        ret = add.reduce(d * (y[tuple(slice1)]+y[tuple(slice2)])/2.0, axis)</div>
<div class="line"><span class="lineno"> 4884</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno"> 4885</span> </div>
<div class="line"><span class="lineno"> 4886</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adcdbca2c84c981abdf7f356dbf3c66bc" name="adcdbca2c84c981abdf7f356dbf3c66bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdbca2c84c981abdf7f356dbf3c66bc">&#9670;&#160;</a></span>trim_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.trim_zeros </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trim</em> = <code>'fb'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Trim the leading and/or trailing zeros from a 1-D array or sequence.

Parameters
----------
filt : 1-D array or sequence
    Input array.
trim : str, optional
    A string with 'f' representing trim from front and 'b' to trim from
    back. Default is 'fb', trim zeros from both front and back of the
    array.

Returns
-------
trimmed : 1-D array or sequence
    The result of trimming the input. The input data type is preserved.

Examples
--------
&gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
&gt;&gt;&gt; np.trim_zeros(a)
array([1, 2, 3, 0, 2, 1])

&gt;&gt;&gt; np.trim_zeros(a, 'b')
array([0, 0, 0, ..., 0, 2, 1])

The input data type is preserved, list/tuple in means list/tuple out.

&gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0])
[1, 2]</pre> <div class="fragment"><div class="line"><span class="lineno"> 1801</span><span class="keyword">def </span>trim_zeros(filt, trim=&#39;fb&#39;):</div>
<div class="line"><span class="lineno"> 1802</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">    Trim the leading and/or trailing zeros from a 1-D array or sequence.</span></div>
<div class="line"><span class="lineno"> 1804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1805</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1806</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1807</span><span class="stringliteral">    filt : 1-D array or sequence</span></div>
<div class="line"><span class="lineno"> 1808</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1809</span><span class="stringliteral">    trim : str, optional</span></div>
<div class="line"><span class="lineno"> 1810</span><span class="stringliteral">        A string with &#39;f&#39; representing trim from front and &#39;b&#39; to trim from</span></div>
<div class="line"><span class="lineno"> 1811</span><span class="stringliteral">        back. Default is &#39;fb&#39;, trim zeros from both front and back of the</span></div>
<div class="line"><span class="lineno"> 1812</span><span class="stringliteral">        array.</span></div>
<div class="line"><span class="lineno"> 1813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1814</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1815</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1816</span><span class="stringliteral">    trimmed : 1-D array or sequence</span></div>
<div class="line"><span class="lineno"> 1817</span><span class="stringliteral">        The result of trimming the input. The input data type is preserved.</span></div>
<div class="line"><span class="lineno"> 1818</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1819</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1820</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1821</span><span class="stringliteral">    &gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))</span></div>
<div class="line"><span class="lineno"> 1822</span><span class="stringliteral">    &gt;&gt;&gt; np.trim_zeros(a)</span></div>
<div class="line"><span class="lineno"> 1823</span><span class="stringliteral">    array([1, 2, 3, 0, 2, 1])</span></div>
<div class="line"><span class="lineno"> 1824</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1825</span><span class="stringliteral">    &gt;&gt;&gt; np.trim_zeros(a, &#39;b&#39;)</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">    array([0, 0, 0, ..., 0, 2, 1])</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">    The input data type is preserved, list/tuple in means list/tuple out.</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">    &gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0])</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">    [1, 2]</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1834</span> </div>
<div class="line"><span class="lineno"> 1835</span>    first = 0</div>
<div class="line"><span class="lineno"> 1836</span>    trim = trim.upper()</div>
<div class="line"><span class="lineno"> 1837</span>    <span class="keywordflow">if</span> <span class="stringliteral">&#39;F&#39;</span> <span class="keywordflow">in</span> trim:</div>
<div class="line"><span class="lineno"> 1838</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> filt:</div>
<div class="line"><span class="lineno"> 1839</span>            <span class="keywordflow">if</span> i != 0.:</div>
<div class="line"><span class="lineno"> 1840</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1841</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1842</span>                first = first + 1</div>
<div class="line"><span class="lineno"> 1843</span>    last = len(filt)</div>
<div class="line"><span class="lineno"> 1844</span>    <span class="keywordflow">if</span> <span class="stringliteral">&#39;B&#39;</span> <span class="keywordflow">in</span> trim:</div>
<div class="line"><span class="lineno"> 1845</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> filt[::-1]:</div>
<div class="line"><span class="lineno"> 1846</span>            <span class="keywordflow">if</span> i != 0.:</div>
<div class="line"><span class="lineno"> 1847</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno"> 1848</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1849</span>                last = last - 1</div>
<div class="line"><span class="lineno"> 1850</span>    <span class="keywordflow">return</span> filt[first:last]</div>
<div class="line"><span class="lineno"> 1851</span> </div>
<div class="line"><span class="lineno"> 1852</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac934e7fa932a746c0f58564f9d87ad26" name="ac934e7fa932a746c0f58564f9d87ad26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac934e7fa932a746c0f58564f9d87ad26">&#9670;&#160;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.unwrap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>discont</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>period</em> = <code>2*pi</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unwrap by taking the complement of large deltas with respect to the period.

This unwraps a signal `p` by changing elements which have an absolute
difference from their predecessor of more than ``max(discont, period/2)``
to their `period`-complementary values.

For the default case where `period` is :math:`2\pi` and `discont` is
:math:`\pi`, this unwraps a radian phase `p` such that adjacent differences
are never greater than :math:`\pi` by adding :math:`2k\pi` for some
integer :math:`k`.

Parameters
----------
p : array_like
    Input array.
discont : float, optional
    Maximum discontinuity between values, default is ``period/2``.
    Values below ``period/2`` are treated as if they were ``period/2``.
    To have an effect different from the default, `discont` should be
    larger than ``period/2``.
axis : int, optional
    Axis along which unwrap will operate, default is the last axis.
period : float, optional
    Size of the range over which the input wraps. By default, it is
    ``2 pi``.

    .. versionadded:: 1.21.0

Returns
-------
out : ndarray
    Output array.

See Also
--------
rad2deg, deg2rad

Notes
-----
If the discontinuity in `p` is smaller than ``period/2``,
but larger than `discont`, no unwrapping is done because taking
the complement would only make the discontinuity larger.

Examples
--------
&gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5)
&gt;&gt;&gt; phase[3:] += np.pi
&gt;&gt;&gt; phase
array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary
&gt;&gt;&gt; np.unwrap(phase)
array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary
&gt;&gt;&gt; np.unwrap([0, 1, 2, -1, 0], period=4)
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)
array([2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180
&gt;&gt;&gt; np.unwrap(phase_deg, period=360)
array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,
        180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,
        540.])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1660</span><span class="keyword">def </span>unwrap(p, discont=None, axis=-1, *, period=2*pi):</div>
<div class="line"><span class="lineno"> 1661</span>    <span class="stringliteral">r&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="stringliteral">    Unwrap by taking the complement of large deltas with respect to the period.</span></div>
<div class="line"><span class="lineno"> 1663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">    This unwraps a signal `p` by changing elements which have an absolute</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral">    difference from their predecessor of more than ``max(discont, period/2)``</span></div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">    to their `period`-complementary values.</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">    For the default case where `period` is :math:`2\pi` and `discont` is</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">    :math:`\pi`, this unwraps a radian phase `p` such that adjacent differences</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral">    are never greater than :math:`\pi` by adding :math:`2k\pi` for some</span></div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">    integer :math:`k`.</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">    p : array_like</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">        Input array.</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">    discont : float, optional</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">        Maximum discontinuity between values, default is ``period/2``.</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral">        Values below ``period/2`` are treated as if they were ``period/2``.</span></div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">        To have an effect different from the default, `discont` should be</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">        larger than ``period/2``.</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">        Axis along which unwrap will operate, default is the last axis.</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral">    period : float, optional</span></div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">        Size of the range over which the input wraps. By default, it is</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        ``2 pi``.</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">        .. versionadded:: 1.21.0</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">        Output array.</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">    rad2deg, deg2rad</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">    If the discontinuity in `p` is smaller than ``period/2``,</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral">    but larger than `discont`, no unwrapping is done because taking</span></div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">    the complement would only make the discontinuity larger.</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">    &gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5)</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">    &gt;&gt;&gt; phase[3:] += np.pi</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">    &gt;&gt;&gt; phase</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary</span></div>
<div class="line"><span class="lineno"> 1711</span><span class="stringliteral">    &gt;&gt;&gt; np.unwrap(phase)</span></div>
<div class="line"><span class="lineno"> 1712</span><span class="stringliteral">    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary</span></div>
<div class="line"><span class="lineno"> 1713</span><span class="stringliteral">    &gt;&gt;&gt; np.unwrap([0, 1, 2, -1, 0], period=4)</span></div>
<div class="line"><span class="lineno"> 1714</span><span class="stringliteral">    array([0, 1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 1715</span><span class="stringliteral">    &gt;&gt;&gt; np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)</span></div>
<div class="line"><span class="lineno"> 1716</span><span class="stringliteral">    array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 1717</span><span class="stringliteral">    &gt;&gt;&gt; np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)</span></div>
<div class="line"><span class="lineno"> 1718</span><span class="stringliteral">    array([2, 3, 4, 5, 6, 7, 8, 9])</span></div>
<div class="line"><span class="lineno"> 1719</span><span class="stringliteral">    &gt;&gt;&gt; phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180</span></div>
<div class="line"><span class="lineno"> 1720</span><span class="stringliteral">    &gt;&gt;&gt; np.unwrap(phase_deg, period=360)</span></div>
<div class="line"><span class="lineno"> 1721</span><span class="stringliteral">    array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,</span></div>
<div class="line"><span class="lineno"> 1722</span><span class="stringliteral">            180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,</span></div>
<div class="line"><span class="lineno"> 1723</span><span class="stringliteral">            540.])</span></div>
<div class="line"><span class="lineno"> 1724</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1725</span>    p = asarray(p)</div>
<div class="line"><span class="lineno"> 1726</span>    nd = p.ndim</div>
<div class="line"><span class="lineno"> 1727</span>    dd = diff(p, axis=axis)</div>
<div class="line"><span class="lineno"> 1728</span>    <span class="keywordflow">if</span> discont <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1729</span>        discont = period/2</div>
<div class="line"><span class="lineno"> 1730</span>    slice1 = [slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>)]*nd     <span class="comment"># full slices</span></div>
<div class="line"><span class="lineno"> 1731</span>    slice1[axis] = slice(1, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1732</span>    slice1 = tuple(slice1)</div>
<div class="line"><span class="lineno"> 1733</span>    dtype = np.result_type(dd, period)</div>
<div class="line"><span class="lineno"> 1734</span>    <span class="keywordflow">if</span> _nx.issubdtype(dtype, _nx.integer):</div>
<div class="line"><span class="lineno"> 1735</span>        interval_high, rem = divmod(period, 2)</div>
<div class="line"><span class="lineno"> 1736</span>        boundary_ambiguous = rem == 0</div>
<div class="line"><span class="lineno"> 1737</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1738</span>        interval_high = period / 2</div>
<div class="line"><span class="lineno"> 1739</span>        boundary_ambiguous = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1740</span>    interval_low = -interval_high</div>
<div class="line"><span class="lineno"> 1741</span>    ddmod = <a class="code hl_namespace" href="namespacemod.html">mod</a>(dd - interval_low, period) + interval_low</div>
<div class="line"><span class="lineno"> 1742</span>    <span class="keywordflow">if</span> boundary_ambiguous:</div>
<div class="line"><span class="lineno"> 1743</span>        <span class="comment"># for `mask = (abs(dd) == period/2)`, the above line made</span></div>
<div class="line"><span class="lineno"> 1744</span>        <span class="comment"># `ddmod[mask] == -period/2`. correct these such that</span></div>
<div class="line"><span class="lineno"> 1745</span>        <span class="comment"># `ddmod[mask] == sign(dd[mask])*period/2`.</span></div>
<div class="line"><span class="lineno"> 1746</span>        _nx.copyto(ddmod, interval_high,</div>
<div class="line"><span class="lineno"> 1747</span>                   where=(ddmod == interval_low) &amp; (dd &gt; 0))</div>
<div class="line"><span class="lineno"> 1748</span>    ph_correct = ddmod - dd</div>
<div class="line"><span class="lineno"> 1749</span>    _nx.copyto(ph_correct, 0, where=abs(dd) &lt; discont)</div>
<div class="line"><span class="lineno"> 1750</span>    up = array(p, copy=<span class="keyword">True</span>, dtype=dtype)</div>
<div class="line"><span class="lineno"> 1751</span>    up[slice1] = p[slice1] + ph_correct.cumsum(axis)</div>
<div class="line"><span class="lineno"> 1752</span>    <span class="keywordflow">return</span> up</div>
<div class="line"><span class="lineno"> 1753</span> </div>
<div class="line"><span class="lineno"> 1754</span> </div>
<div class="ttc" id="anamespacemod_html"><div class="ttname"><a href="namespacemod.html">mod</a></div><div class="ttdef"><b>Definition</b> foo_mod.f90:2</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6cdf3ca9d1e59a41d35ff1fe635d91c7" name="a6cdf3ca9d1e59a41d35ff1fe635d91c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdf3ca9d1e59a41d35ff1fe635d91c7">&#9670;&#160;</a></span>_ARGUMENT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str numpy.lib.function_base._ARGUMENT = <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>'\&zwj;({}\&zwj;)'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a58631ca9768a039f025fec3bcdbe50ed">_CORE_DIMENSION_LIST</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a504fea436affc23ee55663f83ad378ea" name="a504fea436affc23ee55663f83ad378ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504fea436affc23ee55663f83ad378ea">&#9670;&#160;</a></span>_ARGUMENT_LIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str numpy.lib.function_base._ARGUMENT_LIST = '{0:}(?:,{0:})*'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a6cdf3ca9d1e59a41d35ff1fe635d91c7">_ARGUMENT</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58631ca9768a039f025fec3bcdbe50ed" name="a58631ca9768a039f025fec3bcdbe50ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58631ca9768a039f025fec3bcdbe50ed">&#9670;&#160;</a></span>_CORE_DIMENSION_LIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str numpy.lib.function_base._CORE_DIMENSION_LIST = '(?:{0:}(?:,{0:})*)?'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a85d9035d2b11bf7f5b20a6e4b4c51f45">_DIMENSION_NAME</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85d9035d2b11bf7f5b20a6e4b4c51f45" name="a85d9035d2b11bf7f5b20a6e4b4c51f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d9035d2b11bf7f5b20a6e4b4c51f45">&#9670;&#160;</a></span>_DIMENSION_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str numpy.lib.function_base._DIMENSION_NAME = <a class="el" href="__lapack__subroutines_8h.html#a952912404e837594f7cbfb183beeacd4">r</a>'\<a class="el" href="__lapack__subroutines_8h.html#a817b85d82af73ef273fafbec623bb90b">w</a>+'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada1d6d9089e5008cba16f91bac09e8d7" name="ada1d6d9089e5008cba16f91bac09e8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1d6d9089e5008cba16f91bac09e8d7">&#9670;&#160;</a></span>_i0A</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list numpy.lib.function_base._i0A</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Code from cephes for i0. </p>

</div>
</div>
<a id="a25cc2115172d1dffd8ffb230438df384" name="a25cc2115172d1dffd8ffb230438df384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cc2115172d1dffd8ffb230438df384">&#9670;&#160;</a></span>_i0B</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list numpy.lib.function_base._i0B</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [</div>
<div class="line"><span class="lineno">    2</span>    -7.23318048787475395456E-18,</div>
<div class="line"><span class="lineno">    3</span>    -4.83050448594418207126E-18,</div>
<div class="line"><span class="lineno">    4</span>    4.46562142029675999901E-17,</div>
<div class="line"><span class="lineno">    5</span>    3.46122286769746109310E-17,</div>
<div class="line"><span class="lineno">    6</span>    -2.82762398051658348494E-16,</div>
<div class="line"><span class="lineno">    7</span>    -3.42548561967721913462E-16,</div>
<div class="line"><span class="lineno">    8</span>    1.77256013305652638360E-15,</div>
<div class="line"><span class="lineno">    9</span>    3.81168066935262242075E-15,</div>
<div class="line"><span class="lineno">   10</span>    -9.55484669882830764870E-15,</div>
<div class="line"><span class="lineno">   11</span>    -4.15056934728722208663E-14,</div>
<div class="line"><span class="lineno">   12</span>    1.54008621752140982691E-14,</div>
<div class="line"><span class="lineno">   13</span>    3.85277838274214270114E-13,</div>
<div class="line"><span class="lineno">   14</span>    7.18012445138366623367E-13,</div>
<div class="line"><span class="lineno">   15</span>    -1.79417853150680611778E-12,</div>
<div class="line"><span class="lineno">   16</span>    -1.32158118404477131188E-11,</div>
<div class="line"><span class="lineno">   17</span>    -3.14991652796324136454E-11,</div>
<div class="line"><span class="lineno">   18</span>    1.18891471078464383424E-11,</div>
<div class="line"><span class="lineno">   19</span>    4.94060238822496958910E-10,</div>
<div class="line"><span class="lineno">   20</span>    3.39623202570838634515E-9,</div>
<div class="line"><span class="lineno">   21</span>    2.26666899049817806459E-8,</div>
<div class="line"><span class="lineno">   22</span>    2.04891858946906374183E-7,</div>
<div class="line"><span class="lineno">   23</span>    2.89137052083475648297E-6,</div>
<div class="line"><span class="lineno">   24</span>    6.88975834691682398426E-5,</div>
<div class="line"><span class="lineno">   25</span>    3.36911647825569408990E-3,</div>
<div class="line"><span class="lineno">   26</span>    8.04490411014108831608E-1</div>
<div class="line"><span class="lineno">   27</span>    ]</div>
</div><!-- fragment -->
</div>
</div>
<a id="abef37d5da5475303548c0d850c3ca93d" name="abef37d5da5475303548c0d850c3ca93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef37d5da5475303548c0d850c3ca93d">&#9670;&#160;</a></span>_QuantileMethods</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base._QuantileMethods</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2960f69f383be4a34e3432599f93d8d7" name="a2960f69f383be4a34e3432599f93d8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2960f69f383be4a34e3432599f93d8d7">&#9670;&#160;</a></span>_SIGNATURE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str numpy.lib.function_base._SIGNATURE = '^{0:}-&gt;{0:}$'.format(<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a504fea436affc23ee55663f83ad378ea">_ARGUMENT_LIST</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad03f4b858ee9cb78b9adf3cbb4465b1d" name="ad03f4b858ee9cb78b9adf3cbb4465b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03f4b858ee9cb78b9adf3cbb4465b1d">&#9670;&#160;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.function_base.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
