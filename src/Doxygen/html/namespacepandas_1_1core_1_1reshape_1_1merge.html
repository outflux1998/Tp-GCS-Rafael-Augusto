<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.reshape.merge Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1reshape.html">reshape</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html">merge</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.reshape.merge Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1reshape_1_1merge_1_1___as_of_merge.html">_AsOfMerge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1reshape_1_1merge_1_1___merge_operation.html">_MergeOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1reshape_1_1merge_1_1___ordered_merge.html">_OrderedMerge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab0c86921177f6ade5d4e14067b85ed05" id="r_ab0c86921177f6ade5d4e14067b85ed05"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#ab0c86921177f6ade5d4e14067b85ed05">merge</a> (DataFrame|Series left, DataFrame|Series right, str how=&quot;inner&quot;, IndexLabel|None on=None, IndexLabel|None left_on=None, IndexLabel|None right_on=None, bool left_index=False, bool right_index=False, bool sort=False, Suffixes suffixes=(&quot;_x&quot;, &quot;_y&quot;), bool copy=True, bool indicator=False, str|None validate=None)</td></tr>
<tr class="separator:ab0c86921177f6ade5d4e14067b85ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1410ae559a4ca6e59413316e21985895" id="r_a1410ae559a4ca6e59413316e21985895"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a1410ae559a4ca6e59413316e21985895">_groupby_and_merge</a> (by, DataFrame left, DataFrame right, merge_pieces)</td></tr>
<tr class="separator:a1410ae559a4ca6e59413316e21985895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646e354e6c0a1700a8076da5b0d6237c" id="r_a646e354e6c0a1700a8076da5b0d6237c"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a646e354e6c0a1700a8076da5b0d6237c">merge_ordered</a> (DataFrame left, DataFrame right, IndexLabel|None on=None, IndexLabel|None left_on=None, IndexLabel|None right_on=None, left_by=None, right_by=None, str|None fill_method=None, Suffixes suffixes=(&quot;_x&quot;, &quot;_y&quot;), str how=&quot;outer&quot;)</td></tr>
<tr class="separator:a646e354e6c0a1700a8076da5b0d6237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6e711acf4e76fe342b7968bb817dfb" id="r_aca6e711acf4e76fe342b7968bb817dfb"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#aca6e711acf4e76fe342b7968bb817dfb">merge_asof</a> (DataFrame|Series left, DataFrame|Series right, IndexLabel|None on=None, IndexLabel|None left_on=None, IndexLabel|None right_on=None, bool left_index=False, bool right_index=False, by=None, left_by=None, right_by=None, Suffixes suffixes=(&quot;_x&quot;, &quot;_y&quot;), tolerance=None, bool allow_exact_matches=True, str direction=&quot;backward&quot;)</td></tr>
<tr class="separator:aca6e711acf4e76fe342b7968bb817dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4446da57fa5657e88048f3820c5249" id="r_a0d4446da57fa5657e88048f3820c5249"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a0d4446da57fa5657e88048f3820c5249">get_join_indexers</a> (left_keys, right_keys, bool sort=False, str how=&quot;inner&quot;, **kwargs)</td></tr>
<tr class="separator:a0d4446da57fa5657e88048f3820c5249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8ba232918fd1041ae30e81bd176185" id="r_afd8ba232918fd1041ae30e81bd176185"><td class="memItemLeft" align="right" valign="top">tuple[list[Index], npt.NDArray[np.intp], list[Hashable]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#afd8ba232918fd1041ae30e81bd176185">restore_dropped_levels_multijoin</a> (MultiIndex left, MultiIndex right, dropped_level_names, Index join_index, npt.NDArray[np.intp] lindexer, npt.NDArray[np.intp] rindexer)</td></tr>
<tr class="separator:afd8ba232918fd1041ae30e81bd176185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91041a29ad9433764f01f5d9115f60" id="r_aaf91041a29ad9433764f01f5d9115f60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#aaf91041a29ad9433764f01f5d9115f60">_asof_by_function</a> (str direction)</td></tr>
<tr class="separator:aaf91041a29ad9433764f01f5d9115f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecd5dde1d34c8387b67df82eca51d0d" id="r_aaecd5dde1d34c8387b67df82eca51d0d"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#aaecd5dde1d34c8387b67df82eca51d0d">_get_cython_type_upcast</a> (DtypeObj dtype)</td></tr>
<tr class="separator:aaecd5dde1d34c8387b67df82eca51d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077ec6b00444c0c0d636689123aaf62a" id="r_a077ec6b00444c0c0d636689123aaf62a"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a077ec6b00444c0c0d636689123aaf62a">_get_multiindex_indexer</a> (join_keys, MultiIndex index, bool sort)</td></tr>
<tr class="separator:a077ec6b00444c0c0d636689123aaf62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199ffefd98d87f71159177a619a6ac1d" id="r_a199ffefd98d87f71159177a619a6ac1d"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a199ffefd98d87f71159177a619a6ac1d">_get_single_indexer</a> (join_key, Index index, bool sort=False)</td></tr>
<tr class="separator:a199ffefd98d87f71159177a619a6ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab518876bd959ef97f0025ee69a5a9090" id="r_ab518876bd959ef97f0025ee69a5a9090"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#ab518876bd959ef97f0025ee69a5a9090">_get_empty_indexer</a> ()</td></tr>
<tr class="separator:ab518876bd959ef97f0025ee69a5a9090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa656edfe5cfcaade8407f5603939bb" id="r_a0fa656edfe5cfcaade8407f5603939bb"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a0fa656edfe5cfcaade8407f5603939bb">_get_no_sort_one_missing_indexer</a> (int <a class="el" href="__blas__subroutines_8h.html#a25eafceb38c8e75bc60701fea6623f71">n</a>, bool left_missing)</td></tr>
<tr class="separator:a0fa656edfe5cfcaade8407f5603939bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18abae01d419bf16ee4071e50af36cc" id="r_ad18abae01d419bf16ee4071e50af36cc"><td class="memItemLeft" align="right" valign="top">tuple[Index, npt.NDArray[np.intp]|None, npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#ad18abae01d419bf16ee4071e50af36cc">_left_join_on_index</a> (Index left_ax, Index right_ax, join_keys, bool sort=False)</td></tr>
<tr class="separator:ad18abae01d419bf16ee4071e50af36cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e7b3a53a74d89b5c1cc5a0eb7b0b8" id="r_abc1e7b3a53a74d89b5c1cc5a0eb7b0b8"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp], int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#abc1e7b3a53a74d89b5c1cc5a0eb7b0b8">_factorize_keys</a> (ArrayLike lk, ArrayLike rk, bool sort=True, str how=&quot;inner&quot;)</td></tr>
<tr class="separator:abc1e7b3a53a74d89b5c1cc5a0eb7b0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13183a5063615f83a232945134e53dd1" id="r_a13183a5063615f83a232945134e53dd1"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a13183a5063615f83a232945134e53dd1">_sort_labels</a> (np.ndarray uniques, npt.NDArray[np.intp] left, npt.NDArray[np.intp] right)</td></tr>
<tr class="separator:a13183a5063615f83a232945134e53dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583c8365397e292f9a44913e68a8b6dc" id="r_a583c8365397e292f9a44913e68a8b6dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a583c8365397e292f9a44913e68a8b6dc">_get_join_keys</a> (llab, rlab, shape, bool sort)</td></tr>
<tr class="separator:a583c8365397e292f9a44913e68a8b6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad737cfd2b8316ab193a3266242847250" id="r_ad737cfd2b8316ab193a3266242847250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#ad737cfd2b8316ab193a3266242847250">_should_fill</a> (lname, rname)</td></tr>
<tr class="separator:ad737cfd2b8316ab193a3266242847250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39e7e9167bfc4b6d32758d42b8bddf2" id="r_aa39e7e9167bfc4b6d32758d42b8bddf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#aa39e7e9167bfc4b6d32758d42b8bddf2">_any</a> (x)</td></tr>
<tr class="separator:aa39e7e9167bfc4b6d32758d42b8bddf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1417d1bc5063b99b5eaff44ee7eabdfe" id="r_a1417d1bc5063b99b5eaff44ee7eabdfe"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a1417d1bc5063b99b5eaff44ee7eabdfe">_validate_operand</a> (DataFrame|Series obj)</td></tr>
<tr class="separator:a1417d1bc5063b99b5eaff44ee7eabdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35f4f8d83a11ab8fea7a78fc2685db8" id="r_ad35f4f8d83a11ab8fea7a78fc2685db8"><td class="memItemLeft" align="right" valign="top">tuple[Index, Index]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#ad35f4f8d83a11ab8fea7a78fc2685db8">_items_overlap_with_suffix</a> (Index left, Index right, Suffixes suffixes)</td></tr>
<tr class="separator:ad35f4f8d83a11ab8fea7a78fc2685db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a413163801386bb7302b50154b8d7ca77" id="r_a413163801386bb7302b50154b8d7ca77"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1reshape_1_1merge.html#a413163801386bb7302b50154b8d7ca77">_type_casters</a></td></tr>
<tr class="separator:a413163801386bb7302b50154b8d7ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">SQL-style merge routines
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aa39e7e9167bfc4b6d32758d42b8bddf2" name="aa39e7e9167bfc4b6d32758d42b8bddf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39e7e9167bfc4b6d32758d42b8bddf2">&#9670;&#160;</a></span>_any()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.reshape.merge._any </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2413</span><span class="keyword">def </span>_any(x) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2414</span>    <span class="keywordflow">return</span> x <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> com.any_not_none(*x)</div>
<div class="line"><span class="lineno"> 2415</span> </div>
<div class="line"><span class="lineno"> 2416</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf91041a29ad9433764f01f5d9115f60" name="aaf91041a29ad9433764f01f5d9115f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf91041a29ad9433764f01f5d9115f60">&#9670;&#160;</a></span>_asof_by_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.merge._asof_by_function </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1771</span><span class="keyword">def </span>_asof_by_function(direction: str):</div>
<div class="line"><span class="lineno"> 1772</span>    name = f<span class="stringliteral">&quot;asof_join_{direction}_on_X_by_Y&quot;</span></div>
<div class="line"><span class="lineno"> 1773</span>    <span class="keywordflow">return</span> getattr(libjoin, name, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 1774</span> </div>
<div class="line"><span class="lineno"> 1775</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abc1e7b3a53a74d89b5c1cc5a0eb7b0b8" name="abc1e7b3a53a74d89b5c1cc5a0eb7b0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1e7b3a53a74d89b5c1cc5a0eb7b0b8">&#9670;&#160;</a></span>_factorize_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp], int] pandas.core.reshape.merge._factorize_keys </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>lk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;inner&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Encode left and right keys as enumerated types.

This is used to get the join indexers to be used when merging DataFrames.

Parameters
----------
lk : array-like
    Left key.
rk : array-like
    Right key.
sort : bool, defaults to True
    If True, the encoding is done such that the unique elements in the
    keys are sorted.
how : {‘left’, ‘right’, ‘outer’, ‘inner’}, default ‘inner’
    Type of merge.

Returns
-------
np.ndarray[np.intp]
    Left (resp. right if called with `key='right'`) labels, as enumerated type.
np.ndarray[np.intp]
    Right (resp. left if called with `key='right'`) labels, as enumerated type.
int
    Number of unique elements in union of left and right labels.

See Also
--------
merge : Merge DataFrame or named Series objects
    with a database-style join.
algorithms.factorize : Encode the object as an enumerated type
    or categorical variable.

Examples
--------
&gt;&gt;&gt; lk = np.array(["a", "c", "b"])
&gt;&gt;&gt; rk = np.array(["a", "c"])

Here, the unique values are `'a', 'b', 'c'`. With the default
`sort=True`, the encoding will be `{0: 'a', 1: 'b', 2: 'c'}`:

&gt;&gt;&gt; pd.core.reshape.merge._factorize_keys(lk, rk)
(array([0, 2, 1]), array([0, 2]), 3)

With the `sort=False`, the encoding will correspond to the order
in which the unique elements first appear: `{0: 'a', 1: 'c', 2: 'b'}`:

&gt;&gt;&gt; pd.core.reshape.merge._factorize_keys(lk, rk, sort=False)
(array([0, 1, 2]), array([0, 1]), 3)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2221</span>) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp], int]:</div>
<div class="line"><span class="lineno"> 2222</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2223</span><span class="stringliteral">    Encode left and right keys as enumerated types.</span></div>
<div class="line"><span class="lineno"> 2224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2225</span><span class="stringliteral">    This is used to get the join indexers to be used when merging DataFrames.</span></div>
<div class="line"><span class="lineno"> 2226</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2227</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2228</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2229</span><span class="stringliteral">    lk : array-like</span></div>
<div class="line"><span class="lineno"> 2230</span><span class="stringliteral">        Left key.</span></div>
<div class="line"><span class="lineno"> 2231</span><span class="stringliteral">    rk : array-like</span></div>
<div class="line"><span class="lineno"> 2232</span><span class="stringliteral">        Right key.</span></div>
<div class="line"><span class="lineno"> 2233</span><span class="stringliteral">    sort : bool, defaults to True</span></div>
<div class="line"><span class="lineno"> 2234</span><span class="stringliteral">        If True, the encoding is done such that the unique elements in the</span></div>
<div class="line"><span class="lineno"> 2235</span><span class="stringliteral">        keys are sorted.</span></div>
<div class="line"><span class="lineno"> 2236</span><span class="stringliteral">    how : {‘left’, ‘right’, ‘outer’, ‘inner’}, default ‘inner’</span></div>
<div class="line"><span class="lineno"> 2237</span><span class="stringliteral">        Type of merge.</span></div>
<div class="line"><span class="lineno"> 2238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2239</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2240</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2241</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 2242</span><span class="stringliteral">        Left (resp. right if called with `key=&#39;right&#39;`) labels, as enumerated type.</span></div>
<div class="line"><span class="lineno"> 2243</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 2244</span><span class="stringliteral">        Right (resp. left if called with `key=&#39;right&#39;`) labels, as enumerated type.</span></div>
<div class="line"><span class="lineno"> 2245</span><span class="stringliteral">    int</span></div>
<div class="line"><span class="lineno"> 2246</span><span class="stringliteral">        Number of unique elements in union of left and right labels.</span></div>
<div class="line"><span class="lineno"> 2247</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2248</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 2249</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2250</span><span class="stringliteral">    merge : Merge DataFrame or named Series objects</span></div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral">        with a database-style join.</span></div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral">    algorithms.factorize : Encode the object as an enumerated type</span></div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">        or categorical variable.</span></div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral">    &gt;&gt;&gt; lk = np.array([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;])</span></div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">    &gt;&gt;&gt; rk = np.array([&quot;a&quot;, &quot;c&quot;])</span></div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">    Here, the unique values are `&#39;a&#39;, &#39;b&#39;, &#39;c&#39;`. With the default</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral">    `sort=True`, the encoding will be `{0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;}`:</span></div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral">    &gt;&gt;&gt; pd.core.reshape.merge._factorize_keys(lk, rk)</span></div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral">    (array([0, 2, 1]), array([0, 2]), 3)</span></div>
<div class="line"><span class="lineno"> 2265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2266</span><span class="stringliteral">    With the `sort=False`, the encoding will correspond to the order</span></div>
<div class="line"><span class="lineno"> 2267</span><span class="stringliteral">    in which the unique elements first appear: `{0: &#39;a&#39;, 1: &#39;c&#39;, 2: &#39;b&#39;}`:</span></div>
<div class="line"><span class="lineno"> 2268</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2269</span><span class="stringliteral">    &gt;&gt;&gt; pd.core.reshape.merge._factorize_keys(lk, rk, sort=False)</span></div>
<div class="line"><span class="lineno"> 2270</span><span class="stringliteral">    (array([0, 1, 2]), array([0, 1]), 3)</span></div>
<div class="line"><span class="lineno"> 2271</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2272</span>    <span class="comment"># Some pre-processing for non-ndarray lk / rk</span></div>
<div class="line"><span class="lineno"> 2273</span>    lk = extract_array(lk, extract_numpy=<span class="keyword">True</span>, extract_range=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2274</span>    rk = extract_array(rk, extract_numpy=<span class="keyword">True</span>, extract_range=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2275</span>    <span class="comment"># TODO: if either is a RangeIndex, we can likely factorize more efficiently?</span></div>
<div class="line"><span class="lineno"> 2276</span> </div>
<div class="line"><span class="lineno"> 2277</span>    <span class="keywordflow">if</span> isinstance(lk.dtype, DatetimeTZDtype) <span class="keywordflow">and</span> isinstance(rk.dtype, DatetimeTZDtype):</div>
<div class="line"><span class="lineno"> 2278</span>        <span class="comment"># Extract the ndarray (UTC-localized) values</span></div>
<div class="line"><span class="lineno"> 2279</span>        <span class="comment"># Note: we dont need the dtypes to match, as these can still be compared</span></div>
<div class="line"><span class="lineno"> 2280</span>        <span class="comment"># TODO(non-nano): need to make sure resolutions match</span></div>
<div class="line"><span class="lineno"> 2281</span>        lk = cast(<span class="stringliteral">&quot;DatetimeArray&quot;</span>, lk)._ndarray</div>
<div class="line"><span class="lineno"> 2282</span>        rk = cast(<span class="stringliteral">&quot;DatetimeArray&quot;</span>, rk)._ndarray</div>
<div class="line"><span class="lineno"> 2283</span> </div>
<div class="line"><span class="lineno"> 2284</span>    <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno"> 2285</span>        is_categorical_dtype(lk.dtype)</div>
<div class="line"><span class="lineno"> 2286</span>        <span class="keywordflow">and</span> is_categorical_dtype(rk.dtype)</div>
<div class="line"><span class="lineno"> 2287</span>        <span class="keywordflow">and</span> is_dtype_equal(lk.dtype, rk.dtype)</div>
<div class="line"><span class="lineno"> 2288</span>    ):</div>
<div class="line"><span class="lineno"> 2289</span>        <span class="keyword">assert</span> isinstance(lk, Categorical)</div>
<div class="line"><span class="lineno"> 2290</span>        <span class="keyword">assert</span> isinstance(rk, Categorical)</div>
<div class="line"><span class="lineno"> 2291</span>        <span class="comment"># Cast rk to encoding so we can compare codes with lk</span></div>
<div class="line"><span class="lineno"> 2292</span> </div>
<div class="line"><span class="lineno"> 2293</span>        rk = lk._encode_with_my_categories(rk)</div>
<div class="line"><span class="lineno"> 2294</span> </div>
<div class="line"><span class="lineno"> 2295</span>        lk = ensure_int64(lk.codes)</div>
<div class="line"><span class="lineno"> 2296</span>        rk = ensure_int64(rk.codes)</div>
<div class="line"><span class="lineno"> 2297</span> </div>
<div class="line"><span class="lineno"> 2298</span>    <span class="keywordflow">elif</span> isinstance(lk, ExtensionArray) <span class="keywordflow">and</span> is_dtype_equal(lk.dtype, rk.dtype):</div>
<div class="line"><span class="lineno"> 2299</span>        lk, _ = lk._values_for_factorize()</div>
<div class="line"><span class="lineno"> 2300</span> </div>
<div class="line"><span class="lineno"> 2301</span>        <span class="comment"># error: Item &quot;ndarray&quot; of &quot;Union[Any, ndarray]&quot; has no attribute</span></div>
<div class="line"><span class="lineno"> 2302</span>        <span class="comment"># &quot;_values_for_factorize&quot;</span></div>
<div class="line"><span class="lineno"> 2303</span>        rk, _ = rk._values_for_factorize()  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno"> 2304</span> </div>
<div class="line"><span class="lineno"> 2305</span>    klass: type[libhashtable.Factorizer] | type[libhashtable.Int64Factorizer]</div>
<div class="line"><span class="lineno"> 2306</span>    <span class="keywordflow">if</span> is_integer_dtype(lk.dtype) <span class="keywordflow">and</span> is_integer_dtype(rk.dtype):</div>
<div class="line"><span class="lineno"> 2307</span>        <span class="comment"># GH#23917 TODO: needs tests for case where lk is integer-dtype</span></div>
<div class="line"><span class="lineno"> 2308</span>        <span class="comment">#  and rk is datetime-dtype</span></div>
<div class="line"><span class="lineno"> 2309</span>        klass = libhashtable.Int64Factorizer</div>
<div class="line"><span class="lineno"> 2310</span>        lk = ensure_int64(np.asarray(lk))</div>
<div class="line"><span class="lineno"> 2311</span>        rk = ensure_int64(np.asarray(rk))</div>
<div class="line"><span class="lineno"> 2312</span> </div>
<div class="line"><span class="lineno"> 2313</span>    <span class="keywordflow">elif</span> needs_i8_conversion(lk.dtype) <span class="keywordflow">and</span> is_dtype_equal(lk.dtype, rk.dtype):</div>
<div class="line"><span class="lineno"> 2314</span>        <span class="comment"># GH#23917 TODO: Needs tests for non-matching dtypes</span></div>
<div class="line"><span class="lineno"> 2315</span>        klass = libhashtable.Int64Factorizer</div>
<div class="line"><span class="lineno"> 2316</span>        lk = ensure_int64(np.asarray(lk, dtype=np.int64))</div>
<div class="line"><span class="lineno"> 2317</span>        rk = ensure_int64(np.asarray(rk, dtype=np.int64))</div>
<div class="line"><span class="lineno"> 2318</span> </div>
<div class="line"><span class="lineno"> 2319</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2320</span>        klass = libhashtable.ObjectFactorizer</div>
<div class="line"><span class="lineno"> 2321</span>        lk = ensure_object(lk)</div>
<div class="line"><span class="lineno"> 2322</span>        rk = ensure_object(rk)</div>
<div class="line"><span class="lineno"> 2323</span> </div>
<div class="line"><span class="lineno"> 2324</span>    rizer = klass(max(len(lk), len(rk)))</div>
<div class="line"><span class="lineno"> 2325</span> </div>
<div class="line"><span class="lineno"> 2326</span>    <span class="comment"># Argument 1 to &quot;factorize&quot; of &quot;ObjectFactorizer&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 2327</span>    <span class="comment"># &quot;Union[ndarray[Any, dtype[signedinteger[_64Bit]]],</span></div>
<div class="line"><span class="lineno"> 2328</span>    <span class="comment"># ndarray[Any, dtype[object_]]]&quot;; expected &quot;ndarray[Any, dtype[object_]]&quot;</span></div>
<div class="line"><span class="lineno"> 2329</span>    llab = rizer.factorize(lk)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 2330</span>    <span class="comment"># Argument 1 to &quot;factorize&quot; of &quot;ObjectFactorizer&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 2331</span>    <span class="comment"># &quot;Union[ndarray[Any, dtype[signedinteger[_64Bit]]],</span></div>
<div class="line"><span class="lineno"> 2332</span>    <span class="comment"># ndarray[Any, dtype[object_]]]&quot;; expected &quot;ndarray[Any, dtype[object_]]&quot;</span></div>
<div class="line"><span class="lineno"> 2333</span>    rlab = rizer.factorize(rk)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 2334</span>    <span class="keyword">assert</span> llab.dtype == np.dtype(np.intp), llab.dtype</div>
<div class="line"><span class="lineno"> 2335</span>    <span class="keyword">assert</span> rlab.dtype == np.dtype(np.intp), rlab.dtype</div>
<div class="line"><span class="lineno"> 2336</span> </div>
<div class="line"><span class="lineno"> 2337</span>    count = rizer.get_count()</div>
<div class="line"><span class="lineno"> 2338</span> </div>
<div class="line"><span class="lineno"> 2339</span>    <span class="keywordflow">if</span> sort:</div>
<div class="line"><span class="lineno"> 2340</span>        uniques = rizer.uniques.to_array()</div>
<div class="line"><span class="lineno"> 2341</span>        llab, rlab = _sort_labels(uniques, llab, rlab)</div>
<div class="line"><span class="lineno"> 2342</span> </div>
<div class="line"><span class="lineno"> 2343</span>    <span class="comment"># NA group</span></div>
<div class="line"><span class="lineno"> 2344</span>    lmask = llab == -1</div>
<div class="line"><span class="lineno"> 2345</span>    lany = lmask.any()</div>
<div class="line"><span class="lineno"> 2346</span>    rmask = rlab == -1</div>
<div class="line"><span class="lineno"> 2347</span>    rany = rmask.any()</div>
<div class="line"><span class="lineno"> 2348</span> </div>
<div class="line"><span class="lineno"> 2349</span>    <span class="keywordflow">if</span> lany <span class="keywordflow">or</span> rany:</div>
<div class="line"><span class="lineno"> 2350</span>        <span class="keywordflow">if</span> lany:</div>
<div class="line"><span class="lineno"> 2351</span>            np.putmask(llab, lmask, count)</div>
<div class="line"><span class="lineno"> 2352</span>        <span class="keywordflow">if</span> rany:</div>
<div class="line"><span class="lineno"> 2353</span>            np.putmask(rlab, rmask, count)</div>
<div class="line"><span class="lineno"> 2354</span>        count += 1</div>
<div class="line"><span class="lineno"> 2355</span> </div>
<div class="line"><span class="lineno"> 2356</span>    <span class="keywordflow">if</span> how == <span class="stringliteral">&quot;right&quot;</span>:</div>
<div class="line"><span class="lineno"> 2357</span>        <span class="keywordflow">return</span> rlab, llab, count</div>
<div class="line"><span class="lineno"> 2358</span>    <span class="keywordflow">return</span> llab, rlab, count</div>
<div class="line"><span class="lineno"> 2359</span> </div>
<div class="line"><span class="lineno"> 2360</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaecd5dde1d34c8387b67df82eca51d0d" name="aaecd5dde1d34c8387b67df82eca51d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecd5dde1d34c8387b67df82eca51d0d">&#9670;&#160;</a></span>_get_cython_type_upcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> str pandas.core.reshape.merge._get_cython_type_upcast </td>
          <td>(</td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Upcast a dtype to 'int64_t', 'double', or 'object'</pre> <div class="fragment"><div class="line"><span class="lineno"> 1783</span><span class="keyword">def </span>_get_cython_type_upcast(dtype: DtypeObj) -&gt; str:</div>
<div class="line"><span class="lineno"> 1784</span>    <span class="stringliteral">&quot;&quot;&quot;Upcast a dtype to &#39;int64_t&#39;, &#39;double&#39;, or &#39;object&#39;&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1785</span>    <span class="keywordflow">if</span> is_integer_dtype(dtype):</div>
<div class="line"><span class="lineno"> 1786</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;int64_t&quot;</span></div>
<div class="line"><span class="lineno"> 1787</span>    <span class="keywordflow">elif</span> is_float_dtype(dtype):</div>
<div class="line"><span class="lineno"> 1788</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;double&quot;</span></div>
<div class="line"><span class="lineno"> 1789</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1790</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;object&quot;</span></div>
<div class="line"><span class="lineno"> 1791</span> </div>
<div class="line"><span class="lineno"> 1792</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab518876bd959ef97f0025ee69a5a9090" name="ab518876bd959ef97f0025ee69a5a9090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab518876bd959ef97f0025ee69a5a9090">&#9670;&#160;</a></span>_get_empty_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.reshape.merge._get_empty_indexer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return empty join indexers.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2152</span><span class="keyword">def </span>_get_empty_indexer() -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 2153</span>    <span class="stringliteral">&quot;&quot;&quot;Return empty join indexers.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2154</span>    <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno"> 2155</span>        np.array([], dtype=np.intp),</div>
<div class="line"><span class="lineno"> 2156</span>        np.array([], dtype=np.intp),</div>
<div class="line"><span class="lineno"> 2157</span>    )</div>
<div class="line"><span class="lineno"> 2158</span> </div>
<div class="line"><span class="lineno"> 2159</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a583c8365397e292f9a44913e68a8b6dc" name="a583c8365397e292f9a44913e68a8b6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583c8365397e292f9a44913e68a8b6dc">&#9670;&#160;</a></span>_get_join_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.merge._get_join_keys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>llab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rlab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2374</span><span class="keyword">def </span>_get_join_keys(llab, rlab, shape, sort: bool):</div>
<div class="line"><span class="lineno"> 2375</span> </div>
<div class="line"><span class="lineno"> 2376</span>    <span class="comment"># how many levels can be done without overflow</span></div>
<div class="line"><span class="lineno"> 2377</span>    nlev = next(</div>
<div class="line"><span class="lineno"> 2378</span>        lev</div>
<div class="line"><span class="lineno"> 2379</span>        <span class="keywordflow">for</span> lev <span class="keywordflow">in</span> range(len(shape), 0, -1)</div>
<div class="line"><span class="lineno"> 2380</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_int64_overflow_possible(shape[:lev])</div>
<div class="line"><span class="lineno"> 2381</span>    )</div>
<div class="line"><span class="lineno"> 2382</span> </div>
<div class="line"><span class="lineno"> 2383</span>    <span class="comment"># get keys for the first `nlev` levels</span></div>
<div class="line"><span class="lineno"> 2384</span>    stride = np.prod(shape[1:nlev], dtype=<span class="stringliteral">&quot;i8&quot;</span>)</div>
<div class="line"><span class="lineno"> 2385</span>    lkey = stride * llab[0].astype(<span class="stringliteral">&quot;i8&quot;</span>, subok=<span class="keyword">False</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2386</span>    rkey = stride * rlab[0].astype(<span class="stringliteral">&quot;i8&quot;</span>, subok=<span class="keyword">False</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2387</span> </div>
<div class="line"><span class="lineno"> 2388</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, nlev):</div>
<div class="line"><span class="lineno"> 2389</span>        <span class="keyword">with</span> np.errstate(divide=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno"> 2390</span>            stride //= shape[i]</div>
<div class="line"><span class="lineno"> 2391</span>        lkey += llab[i] * stride</div>
<div class="line"><span class="lineno"> 2392</span>        rkey += rlab[i] * stride</div>
<div class="line"><span class="lineno"> 2393</span> </div>
<div class="line"><span class="lineno"> 2394</span>    <span class="keywordflow">if</span> nlev == len(shape):  <span class="comment"># all done!</span></div>
<div class="line"><span class="lineno"> 2395</span>        <span class="keywordflow">return</span> lkey, rkey</div>
<div class="line"><span class="lineno"> 2396</span> </div>
<div class="line"><span class="lineno"> 2397</span>    <span class="comment"># densify current keys to avoid overflow</span></div>
<div class="line"><span class="lineno"> 2398</span>    lkey, rkey, count = _factorize_keys(lkey, rkey, sort=sort)</div>
<div class="line"><span class="lineno"> 2399</span> </div>
<div class="line"><span class="lineno"> 2400</span>    llab = [lkey] + llab[nlev:]</div>
<div class="line"><span class="lineno"> 2401</span>    rlab = [rkey] + rlab[nlev:]</div>
<div class="line"><span class="lineno"> 2402</span>    shape = [count] + shape[nlev:]</div>
<div class="line"><span class="lineno"> 2403</span> </div>
<div class="line"><span class="lineno"> 2404</span>    <span class="keywordflow">return</span> _get_join_keys(llab, rlab, shape, sort)</div>
<div class="line"><span class="lineno"> 2405</span> </div>
<div class="line"><span class="lineno"> 2406</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a077ec6b00444c0c0d636689123aaf62a" name="a077ec6b00444c0c0d636689123aaf62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077ec6b00444c0c0d636689123aaf62a">&#9670;&#160;</a></span>_get_multiindex_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.reshape.merge._get_multiindex_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>join_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiIndex&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2108</span>) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 2109</span> </div>
<div class="line"><span class="lineno"> 2110</span>    <span class="comment"># left &amp; right join labels and num. of levels at each location</span></div>
<div class="line"><span class="lineno"> 2111</span>    mapped = (</div>
<div class="line"><span class="lineno"> 2112</span>        _factorize_keys(index.levels[n], join_keys[n], sort=sort)</div>
<div class="line"><span class="lineno"> 2113</span>        <span class="keywordflow">for</span> n <span class="keywordflow">in</span> range(index.nlevels)</div>
<div class="line"><span class="lineno"> 2114</span>    )</div>
<div class="line"><span class="lineno"> 2115</span>    zipped = zip(*mapped)</div>
<div class="line"><span class="lineno"> 2116</span>    rcodes, lcodes, shape = (list(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> zipped)</div>
<div class="line"><span class="lineno"> 2117</span>    <span class="keywordflow">if</span> sort:</div>
<div class="line"><span class="lineno"> 2118</span>        rcodes = list(map(np.take, rcodes, index.codes))</div>
<div class="line"><span class="lineno"> 2119</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2120</span>        i8copy = <span class="keyword">lambda</span> a: a.astype(<span class="stringliteral">&quot;i8&quot;</span>, subok=<span class="keyword">False</span>, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2121</span>        rcodes = list(map(i8copy, index.codes))</div>
<div class="line"><span class="lineno"> 2122</span> </div>
<div class="line"><span class="lineno"> 2123</span>    <span class="comment"># fix right labels if there were any nulls</span></div>
<div class="line"><span class="lineno"> 2124</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(join_keys)):</div>
<div class="line"><span class="lineno"> 2125</span>        mask = index.codes[i] == -1</div>
<div class="line"><span class="lineno"> 2126</span>        <span class="keywordflow">if</span> mask.any():</div>
<div class="line"><span class="lineno"> 2127</span>            <span class="comment"># check if there already was any nulls at this location</span></div>
<div class="line"><span class="lineno"> 2128</span>            <span class="comment"># if there was, it is factorized to `shape[i] - 1`</span></div>
<div class="line"><span class="lineno"> 2129</span>            a = join_keys[i][lcodes[i] == shape[i] - 1]</div>
<div class="line"><span class="lineno"> 2130</span>            <span class="keywordflow">if</span> a.size == 0 <span class="keywordflow">or</span> <span class="keywordflow">not</span> a[0] != a[0]:</div>
<div class="line"><span class="lineno"> 2131</span>                shape[i] += 1</div>
<div class="line"><span class="lineno"> 2132</span> </div>
<div class="line"><span class="lineno"> 2133</span>            rcodes[i][mask] = shape[i] - 1</div>
<div class="line"><span class="lineno"> 2134</span> </div>
<div class="line"><span class="lineno"> 2135</span>    <span class="comment"># get flat i8 join keys</span></div>
<div class="line"><span class="lineno"> 2136</span>    lkey, rkey = _get_join_keys(lcodes, rcodes, shape, sort)</div>
<div class="line"><span class="lineno"> 2137</span> </div>
<div class="line"><span class="lineno"> 2138</span>    <span class="comment"># factorize keys to a dense i8 space</span></div>
<div class="line"><span class="lineno"> 2139</span>    lkey, rkey, count = _factorize_keys(lkey, rkey, sort=sort)</div>
<div class="line"><span class="lineno"> 2140</span> </div>
<div class="line"><span class="lineno"> 2141</span>    <span class="keywordflow">return</span> libjoin.left_outer_join(lkey, rkey, count, sort=sort)</div>
<div class="line"><span class="lineno"> 2142</span> </div>
<div class="line"><span class="lineno"> 2143</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0fa656edfe5cfcaade8407f5603939bb" name="a0fa656edfe5cfcaade8407f5603939bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa656edfe5cfcaade8407f5603939bb">&#9670;&#160;</a></span>_get_no_sort_one_missing_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.reshape.merge._get_no_sort_one_missing_indexer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>left_missing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return join indexers where all of one side is selected without sorting
and none of the other side is selected.

Parameters
----------
n : int
    Length of indexers to create.
left_missing : bool
    If True, the left indexer will contain only -1's.
    If False, the right indexer will contain only -1's.

Returns
-------
np.ndarray[np.intp]
    Left indexer
np.ndarray[np.intp]
    Right indexer
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2162</span>) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 2163</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral">    Return join indexers where all of one side is selected without sorting</span></div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral">    and none of the other side is selected.</span></div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral">    n : int</span></div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral">        Length of indexers to create.</span></div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">    left_missing : bool</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral">        If True, the left indexer will contain only -1&#39;s.</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral">        If False, the right indexer will contain only -1&#39;s.</span></div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 2178</span><span class="stringliteral">        Left indexer</span></div>
<div class="line"><span class="lineno"> 2179</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 2180</span><span class="stringliteral">        Right indexer</span></div>
<div class="line"><span class="lineno"> 2181</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2182</span>    idx = np.arange(n, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 2183</span>    idx_missing = np.full(shape=n, fill_value=-1, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 2184</span>    <span class="keywordflow">if</span> left_missing:</div>
<div class="line"><span class="lineno"> 2185</span>        <span class="keywordflow">return</span> idx_missing, idx</div>
<div class="line"><span class="lineno"> 2186</span>    <span class="keywordflow">return</span> idx, idx_missing</div>
<div class="line"><span class="lineno"> 2187</span> </div>
<div class="line"><span class="lineno"> 2188</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a199ffefd98d87f71159177a619a6ac1d" name="a199ffefd98d87f71159177a619a6ac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199ffefd98d87f71159177a619a6ac1d">&#9670;&#160;</a></span>_get_single_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.reshape.merge._get_single_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>join_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2146</span>) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 2147</span>    left_key, right_key, count = _factorize_keys(join_key, index._values, sort=sort)</div>
<div class="line"><span class="lineno"> 2148</span> </div>
<div class="line"><span class="lineno"> 2149</span>    <span class="keywordflow">return</span> libjoin.left_outer_join(left_key, right_key, count, sort=sort)</div>
<div class="line"><span class="lineno"> 2150</span> </div>
<div class="line"><span class="lineno"> 2151</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1410ae559a4ca6e59413316e21985895" name="a1410ae559a4ca6e59413316e21985895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1410ae559a4ca6e59413316e21985895">&#9670;&#160;</a></span>_groupby_and_merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.reshape.merge._groupby_and_merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataFrame&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataFrame&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>merge_pieces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">groupby &amp; merge; we are always performing a left-by type operation

Parameters
----------
by: field to group
left: DataFrame
right: DataFrame
merge_pieces: function for merging
</pre> <div class="fragment"><div class="line"><span class="lineno">  131</span><span class="keyword">def </span>_groupby_and_merge(by, left: DataFrame, right: DataFrame, merge_pieces):</div>
<div class="line"><span class="lineno">  132</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    groupby &amp; merge; we are always performing a left-by type operation</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    by: field to group</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    left: DataFrame</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    right: DataFrame</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    merge_pieces: function for merging</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  142</span>    pieces = []</div>
<div class="line"><span class="lineno">  143</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(by, (list, tuple)):</div>
<div class="line"><span class="lineno">  144</span>        by = [by]</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>    lby = left.groupby(by, sort=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  147</span>    rby: groupby.DataFrameGroupBy | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>    <span class="comment"># if we can groupby the rhs</span></div>
<div class="line"><span class="lineno">  150</span>    <span class="comment"># then we can get vastly better perf</span></div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordflow">if</span> all(item <span class="keywordflow">in</span> right.columns <span class="keywordflow">for</span> item <span class="keywordflow">in</span> by):</div>
<div class="line"><span class="lineno">  152</span>        rby = right.groupby(by, sort=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">for</span> key, lhs <span class="keywordflow">in</span> lby.grouper.get_iterator(lby._selected_obj, axis=lby.axis):</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>        <span class="keywordflow">if</span> rby <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  157</span>            rhs = right</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  159</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  160</span>                rhs = right.take(rby.indices[key])</div>
<div class="line"><span class="lineno">  161</span>            <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno">  162</span>                <span class="comment"># key doesn&#39;t exist in left</span></div>
<div class="line"><span class="lineno">  163</span>                lcols = lhs.columns.tolist()</div>
<div class="line"><span class="lineno">  164</span>                cols = lcols + [r <span class="keywordflow">for</span> r <span class="keywordflow">in</span> right.columns <span class="keywordflow">if</span> r <span class="keywordflow">not</span> <span class="keywordflow">in</span> set(lcols)]</div>
<div class="line"><span class="lineno">  165</span>                merged = lhs.reindex(columns=cols)</div>
<div class="line"><span class="lineno">  166</span>                merged.index = range(len(merged))</div>
<div class="line"><span class="lineno">  167</span>                pieces.append(merged)</div>
<div class="line"><span class="lineno">  168</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="line"><span class="lineno">  170</span>        merged = merge_pieces(lhs, rhs)</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>        <span class="comment"># make sure join keys are in the merged</span></div>
<div class="line"><span class="lineno">  173</span>        <span class="comment"># TODO, should merge_pieces do this?</span></div>
<div class="line"><span class="lineno">  174</span>        merged[by] = key</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>        pieces.append(merged)</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span>    <span class="comment"># preserve the original order</span></div>
<div class="line"><span class="lineno">  179</span>    <span class="comment"># if we have a missing piece this can be reset</span></div>
<div class="line"><span class="lineno">  180</span>    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1reshape_1_1concat.html">pandas.core.reshape.concat</a> <span class="keyword">import</span> concat</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>    result = concat(pieces, ignore_index=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  183</span>    result = result.reindex(columns=pieces[0].columns, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">return</span> result, lby</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1reshape_1_1concat_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1reshape_1_1concat.html">pandas.core.reshape.concat</a></div><div class="ttdef"><b>Definition</b> concat.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad35f4f8d83a11ab8fea7a78fc2685db8" name="ad35f4f8d83a11ab8fea7a78fc2685db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35f4f8d83a11ab8fea7a78fc2685db8">&#9670;&#160;</a></span>_items_overlap_with_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[Index, Index] pandas.core.reshape.merge._items_overlap_with_suffix </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Suffixes
&#160;</td>
          <td class="paramname"><em>suffixes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Suffixes type validation.

If two indices overlap, add suffixes to overlapping entries.

If corresponding suffix is empty, the entry is simply converted to string.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2433</span>) -&gt; tuple[Index, Index]:</div>
<div class="line"><span class="lineno"> 2434</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">    Suffixes type validation.</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">    If two indices overlap, add suffixes to overlapping entries.</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">    If corresponding suffix is empty, the entry is simply converted to string.</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2442</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(suffixes, allow_sets=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 2443</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 2444</span>            f<span class="stringliteral">&quot;Passing &#39;suffixes&#39; as a {type(suffixes)}, is not supported and may give &quot;</span></div>
<div class="line"><span class="lineno"> 2445</span>            <span class="stringliteral">&quot;unexpected results. Provide &#39;suffixes&#39; as a tuple instead. In the &quot;</span></div>
<div class="line"><span class="lineno"> 2446</span>            <span class="stringliteral">&quot;future a &#39;TypeError&#39; will be raised.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2447</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 2448</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 2449</span>        )</div>
<div class="line"><span class="lineno"> 2450</span> </div>
<div class="line"><span class="lineno"> 2451</span>    to_rename = left.intersection(right)</div>
<div class="line"><span class="lineno"> 2452</span>    <span class="keywordflow">if</span> len(to_rename) == 0:</div>
<div class="line"><span class="lineno"> 2453</span>        <span class="keywordflow">return</span> left, right</div>
<div class="line"><span class="lineno"> 2454</span> </div>
<div class="line"><span class="lineno"> 2455</span>    lsuffix, rsuffix = suffixes</div>
<div class="line"><span class="lineno"> 2456</span> </div>
<div class="line"><span class="lineno"> 2457</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> lsuffix <span class="keywordflow">and</span> <span class="keywordflow">not</span> rsuffix:</div>
<div class="line"><span class="lineno"> 2458</span>        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;columns overlap but no suffix specified: {to_rename}&quot;</span>)</div>
<div class="line"><span class="lineno"> 2459</span> </div>
<div class="line"><span class="lineno"> 2460</span>    <span class="keyword">def </span>renamer(x, suffix):</div>
<div class="line"><span class="lineno"> 2461</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral">        Rename the left and right indices.</span></div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">        If there is overlap, and suffix is not None, add</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">        suffix, otherwise, leave it as-is.</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">        x : original column name</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral">        suffix : str or None</span></div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral">        x : renamed column name</span></div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2476</span>        <span class="keywordflow">if</span> x <span class="keywordflow">in</span> to_rename <span class="keywordflow">and</span> suffix <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2477</span>            <span class="keywordflow">return</span> f<span class="stringliteral">&quot;{x}{suffix}&quot;</span></div>
<div class="line"><span class="lineno"> 2478</span>        <span class="keywordflow">return</span> x</div>
<div class="line"><span class="lineno"> 2479</span> </div>
<div class="line"><span class="lineno"> 2480</span>    lrenamer = partial(renamer, suffix=lsuffix)</div>
<div class="line"><span class="lineno"> 2481</span>    rrenamer = partial(renamer, suffix=rsuffix)</div>
<div class="line"><span class="lineno"> 2482</span> </div>
<div class="line"><span class="lineno"> 2483</span>    llabels = left._transform_index(lrenamer)</div>
<div class="line"><span class="lineno"> 2484</span>    rlabels = right._transform_index(rrenamer)</div>
<div class="line"><span class="lineno"> 2485</span> </div>
<div class="line"><span class="lineno"> 2486</span>    dups = []</div>
<div class="line"><span class="lineno"> 2487</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> llabels.is_unique:</div>
<div class="line"><span class="lineno"> 2488</span>        <span class="comment"># Only warn when duplicates are caused because of suffixes, already duplicated</span></div>
<div class="line"><span class="lineno"> 2489</span>        <span class="comment"># columns in origin should not warn</span></div>
<div class="line"><span class="lineno"> 2490</span>        dups = llabels[(llabels.duplicated()) &amp; (~left.duplicated())].tolist()</div>
<div class="line"><span class="lineno"> 2491</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> rlabels.is_unique:</div>
<div class="line"><span class="lineno"> 2492</span>        dups.extend(rlabels[(rlabels.duplicated()) &amp; (~right.duplicated())].tolist())</div>
<div class="line"><span class="lineno"> 2493</span>    <span class="keywordflow">if</span> dups:</div>
<div class="line"><span class="lineno"> 2494</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 2495</span>            f<span class="stringliteral">&quot;Passing &#39;suffixes&#39; which cause duplicate columns {set(dups)} in the &quot;</span></div>
<div class="line"><span class="lineno"> 2496</span>            f<span class="stringliteral">&quot;result is deprecated and will raise a MergeError in a future version.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2497</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 2498</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 2499</span>        )</div>
<div class="line"><span class="lineno"> 2500</span> </div>
<div class="line"><span class="lineno"> 2501</span>    <span class="keywordflow">return</span> llabels, rlabels</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad18abae01d419bf16ee4071e50af36cc" name="ad18abae01d419bf16ee4071e50af36cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18abae01d419bf16ee4071e50af36cc">&#9670;&#160;</a></span>_left_join_on_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp]] pandas.core.reshape.merge._left_join_on_index </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>left_ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>right_ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>join_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2191</span>) -&gt; tuple[Index, npt.NDArray[np.intp] | <span class="keywordtype">None</span>, npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 2192</span>    <span class="keywordflow">if</span> len(join_keys) &gt; 1:</div>
<div class="line"><span class="lineno"> 2193</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno"> 2194</span>            isinstance(right_ax, MultiIndex) <span class="keywordflow">and</span> len(join_keys) == right_ax.nlevels</div>
<div class="line"><span class="lineno"> 2195</span>        ):</div>
<div class="line"><span class="lineno"> 2196</span>            <span class="keywordflow">raise</span> AssertionError(</div>
<div class="line"><span class="lineno"> 2197</span>                <span class="stringliteral">&quot;If more than one join key is given then &quot;</span></div>
<div class="line"><span class="lineno"> 2198</span>                <span class="stringliteral">&quot;&#39;right_ax&#39; must be a MultiIndex and the &quot;</span></div>
<div class="line"><span class="lineno"> 2199</span>                <span class="stringliteral">&quot;number of join keys must be the number of levels in right_ax&quot;</span></div>
<div class="line"><span class="lineno"> 2200</span>            )</div>
<div class="line"><span class="lineno"> 2201</span> </div>
<div class="line"><span class="lineno"> 2202</span>        left_indexer, right_indexer = _get_multiindex_indexer(</div>
<div class="line"><span class="lineno"> 2203</span>            join_keys, right_ax, sort=sort</div>
<div class="line"><span class="lineno"> 2204</span>        )</div>
<div class="line"><span class="lineno"> 2205</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2206</span>        jkey = join_keys[0]</div>
<div class="line"><span class="lineno"> 2207</span> </div>
<div class="line"><span class="lineno"> 2208</span>        left_indexer, right_indexer = _get_single_indexer(jkey, right_ax, sort=sort)</div>
<div class="line"><span class="lineno"> 2209</span> </div>
<div class="line"><span class="lineno"> 2210</span>    <span class="keywordflow">if</span> sort <span class="keywordflow">or</span> len(left_ax) != len(left_indexer):</div>
<div class="line"><span class="lineno"> 2211</span>        <span class="comment"># if asked to sort or there are 1-to-many matches</span></div>
<div class="line"><span class="lineno"> 2212</span>        join_index = left_ax.take(left_indexer)</div>
<div class="line"><span class="lineno"> 2213</span>        <span class="keywordflow">return</span> join_index, left_indexer, right_indexer</div>
<div class="line"><span class="lineno"> 2214</span> </div>
<div class="line"><span class="lineno"> 2215</span>    <span class="comment"># left frame preserves order &amp; length of its index</span></div>
<div class="line"><span class="lineno"> 2216</span>    <span class="keywordflow">return</span> left_ax, <span class="keywordtype">None</span>, right_indexer</div>
<div class="line"><span class="lineno"> 2217</span> </div>
<div class="line"><span class="lineno"> 2218</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad737cfd2b8316ab193a3266242847250" name="ad737cfd2b8316ab193a3266242847250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad737cfd2b8316ab193a3266242847250">&#9670;&#160;</a></span>_should_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.reshape.merge._should_fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2407</span><span class="keyword">def </span>_should_fill(lname, rname) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2408</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(lname, str) <span class="keywordflow">or</span> <span class="keywordflow">not</span> isinstance(rname, str):</div>
<div class="line"><span class="lineno"> 2409</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2410</span>    <span class="keywordflow">return</span> lname == rname</div>
<div class="line"><span class="lineno"> 2411</span> </div>
<div class="line"><span class="lineno"> 2412</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a13183a5063615f83a232945134e53dd1" name="a13183a5063615f83a232945134e53dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13183a5063615f83a232945134e53dd1">&#9670;&#160;</a></span>_sort_labels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.reshape.merge._sort_labels </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>uniques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]
&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2363</span>) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 2364</span> </div>
<div class="line"><span class="lineno"> 2365</span>    llength = len(left)</div>
<div class="line"><span class="lineno"> 2366</span>    labels = np.concatenate([left, right])</div>
<div class="line"><span class="lineno"> 2367</span> </div>
<div class="line"><span class="lineno"> 2368</span>    _, new_labels = algos.safe_sort(uniques, labels, na_sentinel=-1)</div>
<div class="line"><span class="lineno"> 2369</span>    new_left, new_right = new_labels[:llength], new_labels[llength:]</div>
<div class="line"><span class="lineno"> 2370</span> </div>
<div class="line"><span class="lineno"> 2371</span>    <span class="keywordflow">return</span> new_left, new_right</div>
<div class="line"><span class="lineno"> 2372</span> </div>
<div class="line"><span class="lineno"> 2373</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1417d1bc5063b99b5eaff44ee7eabdfe" name="a1417d1bc5063b99b5eaff44ee7eabdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1417d1bc5063b99b5eaff44ee7eabdfe">&#9670;&#160;</a></span>_validate_operand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.core.reshape.merge._validate_operand </td>
          <td>(</td>
          <td class="paramtype">DataFrame | Series&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2417</span><span class="keyword">def </span>_validate_operand(obj: DataFrame | Series) -&gt; DataFrame:</div>
<div class="line"><span class="lineno"> 2418</span>    <span class="keywordflow">if</span> isinstance(obj, ABCDataFrame):</div>
<div class="line"><span class="lineno"> 2419</span>        <span class="keywordflow">return</span> obj</div>
<div class="line"><span class="lineno"> 2420</span>    <span class="keywordflow">elif</span> isinstance(obj, ABCSeries):</div>
<div class="line"><span class="lineno"> 2421</span>        <span class="keywordflow">if</span> obj.name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2422</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Cannot merge a Series without a name&quot;</span>)</div>
<div class="line"><span class="lineno"> 2423</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2424</span>            <span class="keywordflow">return</span> obj.to_frame()</div>
<div class="line"><span class="lineno"> 2425</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2426</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 2427</span>            f<span class="stringliteral">&quot;Can only merge Series or DataFrame objects, a {type(obj)} was passed&quot;</span></div>
<div class="line"><span class="lineno"> 2428</span>        )</div>
<div class="line"><span class="lineno"> 2429</span> </div>
<div class="line"><span class="lineno"> 2430</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d4446da57fa5657e88048f3820c5249" name="a0d4446da57fa5657e88048f3820c5249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4446da57fa5657e88048f3820c5249">&#9670;&#160;</a></span>get_join_indexers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.reshape.merge.get_join_indexers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;inner&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
left_keys : ndarray, Index, Series
right_keys : ndarray, Index, Series
sort : bool, default False
how : {'inner', 'outer', 'left', 'right'}, default 'inner'

Returns
-------
np.ndarray[np.intp]
    Indexer into the left_keys.
np.ndarray[np.intp]
    Indexer into the right_keys.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1545</span>) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 1546</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">    left_keys : ndarray, Index, Series</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">    right_keys : ndarray, Index, Series</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">    sort : bool, default False</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">    how : {&#39;inner&#39;, &#39;outer&#39;, &#39;left&#39;, &#39;right&#39;}, default &#39;inner&#39;</span></div>
<div class="line"><span class="lineno"> 1554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1555</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1556</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1557</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 1558</span><span class="stringliteral">        Indexer into the left_keys.</span></div>
<div class="line"><span class="lineno"> 1559</span><span class="stringliteral">    np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 1560</span><span class="stringliteral">        Indexer into the right_keys.</span></div>
<div class="line"><span class="lineno"> 1561</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1562</span>    <span class="keyword">assert</span> len(left_keys) == len(</div>
<div class="line"><span class="lineno"> 1563</span>        right_keys</div>
<div class="line"><span class="lineno"> 1564</span>    ), <span class="stringliteral">&quot;left_key and right_keys must be the same length&quot;</span></div>
<div class="line"><span class="lineno"> 1565</span> </div>
<div class="line"><span class="lineno"> 1566</span>    <span class="comment"># fast-path for empty left/right</span></div>
<div class="line"><span class="lineno"> 1567</span>    left_n = len(left_keys[0])</div>
<div class="line"><span class="lineno"> 1568</span>    right_n = len(right_keys[0])</div>
<div class="line"><span class="lineno"> 1569</span>    <span class="keywordflow">if</span> left_n == 0:</div>
<div class="line"><span class="lineno"> 1570</span>        <span class="keywordflow">if</span> how <span class="keywordflow">in</span> [<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;inner&quot;</span>, <span class="stringliteral">&quot;cross&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1571</span>            <span class="keywordflow">return</span> _get_empty_indexer()</div>
<div class="line"><span class="lineno"> 1572</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> sort <span class="keywordflow">and</span> how <span class="keywordflow">in</span> [<span class="stringliteral">&quot;right&quot;</span>, <span class="stringliteral">&quot;outer&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1573</span>            <span class="keywordflow">return</span> _get_no_sort_one_missing_indexer(right_n, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1574</span>    <span class="keywordflow">elif</span> right_n == 0:</div>
<div class="line"><span class="lineno"> 1575</span>        <span class="keywordflow">if</span> how <span class="keywordflow">in</span> [<span class="stringliteral">&quot;right&quot;</span>, <span class="stringliteral">&quot;inner&quot;</span>, <span class="stringliteral">&quot;cross&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1576</span>            <span class="keywordflow">return</span> _get_empty_indexer()</div>
<div class="line"><span class="lineno"> 1577</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> sort <span class="keywordflow">and</span> how <span class="keywordflow">in</span> [<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;outer&quot;</span>]:</div>
<div class="line"><span class="lineno"> 1578</span>            <span class="keywordflow">return</span> _get_no_sort_one_missing_indexer(left_n, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1579</span> </div>
<div class="line"><span class="lineno"> 1580</span>    <span class="comment"># get left &amp; right join labels and num. of levels at each location</span></div>
<div class="line"><span class="lineno"> 1581</span>    mapped = (</div>
<div class="line"><span class="lineno"> 1582</span>        _factorize_keys(left_keys[n], right_keys[n], sort=sort, how=how)</div>
<div class="line"><span class="lineno"> 1583</span>        <span class="keywordflow">for</span> n <span class="keywordflow">in</span> range(len(left_keys))</div>
<div class="line"><span class="lineno"> 1584</span>    )</div>
<div class="line"><span class="lineno"> 1585</span>    zipped = zip(*mapped)</div>
<div class="line"><span class="lineno"> 1586</span>    llab, rlab, shape = (list(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> zipped)</div>
<div class="line"><span class="lineno"> 1587</span> </div>
<div class="line"><span class="lineno"> 1588</span>    <span class="comment"># get flat i8 keys from label lists</span></div>
<div class="line"><span class="lineno"> 1589</span>    lkey, rkey = _get_join_keys(llab, rlab, shape, sort)</div>
<div class="line"><span class="lineno"> 1590</span> </div>
<div class="line"><span class="lineno"> 1591</span>    <span class="comment"># factorize keys to a dense i8 space</span></div>
<div class="line"><span class="lineno"> 1592</span>    <span class="comment"># `count` is the num. of unique keys</span></div>
<div class="line"><span class="lineno"> 1593</span>    <span class="comment"># set(lkey) | set(rkey) == range(count)</span></div>
<div class="line"><span class="lineno"> 1594</span> </div>
<div class="line"><span class="lineno"> 1595</span>    lkey, rkey, count = _factorize_keys(lkey, rkey, sort=sort, how=how)</div>
<div class="line"><span class="lineno"> 1596</span>    <span class="comment"># preserve left frame order if how == &#39;left&#39; and sort == False</span></div>
<div class="line"><span class="lineno"> 1597</span>    kwargs = copy.copy(kwargs)</div>
<div class="line"><span class="lineno"> 1598</span>    <span class="keywordflow">if</span> how <span class="keywordflow">in</span> (<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;right&quot;</span>):</div>
<div class="line"><span class="lineno"> 1599</span>        kwargs[<span class="stringliteral">&quot;sort&quot;</span>] = sort</div>
<div class="line"><span class="lineno"> 1600</span>    join_func = {</div>
<div class="line"><span class="lineno"> 1601</span>        <span class="stringliteral">&quot;inner&quot;</span>: libjoin.inner_join,</div>
<div class="line"><span class="lineno"> 1602</span>        <span class="stringliteral">&quot;left&quot;</span>: libjoin.left_outer_join,</div>
<div class="line"><span class="lineno"> 1603</span>        <span class="stringliteral">&quot;right&quot;</span>: <span class="keyword">lambda</span> x, y, count, **kwargs: libjoin.left_outer_join(</div>
<div class="line"><span class="lineno"> 1604</span>            y, x, count, **kwargs</div>
<div class="line"><span class="lineno"> 1605</span>        )[::-1],</div>
<div class="line"><span class="lineno"> 1606</span>        <span class="stringliteral">&quot;outer&quot;</span>: libjoin.full_outer_join,</div>
<div class="line"><span class="lineno"> 1607</span>    }[how]</div>
<div class="line"><span class="lineno"> 1608</span> </div>
<div class="line"><span class="lineno"> 1609</span>    <span class="comment"># error: Cannot call function of unknown type</span></div>
<div class="line"><span class="lineno"> 1610</span>    <span class="keywordflow">return</span> join_func(lkey, rkey, count, **kwargs)  <span class="comment"># type: ignore[operator]</span></div>
<div class="line"><span class="lineno"> 1611</span> </div>
<div class="line"><span class="lineno"> 1612</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0c86921177f6ade5d4e14067b85ed05" name="ab0c86921177f6ade5d4e14067b85ed05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c86921177f6ade5d4e14067b85ed05">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.core.reshape.merge.merge </td>
          <td>(</td>
          <td class="paramtype">DataFrame | Series&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataFrame | Series&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;inner&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>left_on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>right_on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>left_index</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>right_index</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Suffixes &#160;</td>
          <td class="paramname"><em>suffixes</em> = <code>(&quot;_x&quot;,&#160;&quot;_y&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>indicator</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>validate</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  109</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  110</span>    op = _MergeOperation(</div>
<div class="line"><span class="lineno">  111</span>        left,</div>
<div class="line"><span class="lineno">  112</span>        right,</div>
<div class="line"><span class="lineno">  113</span>        how=how,</div>
<div class="line"><span class="lineno">  114</span>        on=on,</div>
<div class="line"><span class="lineno">  115</span>        left_on=left_on,</div>
<div class="line"><span class="lineno">  116</span>        right_on=right_on,</div>
<div class="line"><span class="lineno">  117</span>        left_index=left_index,</div>
<div class="line"><span class="lineno">  118</span>        right_index=right_index,</div>
<div class="line"><span class="lineno">  119</span>        sort=sort,</div>
<div class="line"><span class="lineno">  120</span>        suffixes=suffixes,</div>
<div class="line"><span class="lineno">  121</span>        indicator=indicator,</div>
<div class="line"><span class="lineno">  122</span>        validate=validate,</div>
<div class="line"><span class="lineno">  123</span>    )</div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordflow">return</span> op.get_result(copy=copy)</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aca6e711acf4e76fe342b7968bb817dfb" name="aca6e711acf4e76fe342b7968bb817dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6e711acf4e76fe342b7968bb817dfb">&#9670;&#160;</a></span>merge_asof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.core.reshape.merge.merge_asof </td>
          <td>(</td>
          <td class="paramtype">DataFrame | Series&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataFrame | Series&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>left_on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>right_on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>left_index</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>right_index</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>by</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left_by</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right_by</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Suffixes &#160;</td>
          <td class="paramname"><em>suffixes</em> = <code>(&quot;_x&quot;,&#160;&quot;_y&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>allow_exact_matches</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>direction</em> = <code>&quot;backward&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a merge by key distance.

This is similar to a left-join except that we match on nearest
key rather than equal keys. Both DataFrames must be sorted by the key.

For each row in the left DataFrame:

  - A "backward" search selects the last row in the right DataFrame whose
    'on' key is less than or equal to the left's key.

  - A "forward" search selects the first row in the right DataFrame whose
    'on' key is greater than or equal to the left's key.

  - A "nearest" search selects the row in the right DataFrame whose 'on'
    key is closest in absolute distance to the left's key.

The default is "backward" and is compatible in versions below 0.20.0.
The direction parameter was added in version 0.20.0 and introduces
"forward" and "nearest".

Optionally match on equivalent keys with 'by' before searching with 'on'.

Parameters
----------
left : DataFrame or named Series
right : DataFrame or named Series
on : label
    Field name to join on. Must be found in both DataFrames.
    The data MUST be ordered. Furthermore this must be a numeric column,
    such as datetimelike, integer, or float. On or left_on/right_on
    must be given.
left_on : label
    Field name to join on in left DataFrame.
right_on : label
    Field name to join on in right DataFrame.
left_index : bool
    Use the index of the left DataFrame as the join key.
right_index : bool
    Use the index of the right DataFrame as the join key.
by : column name or list of column names
    Match on these columns before performing merge operation.
left_by : column name
    Field names to match on in the left DataFrame.
right_by : column name
    Field names to match on in the right DataFrame.
suffixes : 2-length sequence (tuple, list, ...)
    Suffix to apply to overlapping column names in the left and right
    side, respectively.
tolerance : int or Timedelta, optional, default None
    Select asof tolerance within this range; must be compatible
    with the merge index.
allow_exact_matches : bool, default True

    - If True, allow matching with the same 'on' value
      (i.e. less-than-or-equal-to / greater-than-or-equal-to)
    - If False, don't match the same 'on' value
      (i.e., strictly less-than / strictly greater-than).

direction : 'backward' (default), 'forward', or 'nearest'
    Whether to search for prior, subsequent, or closest matches.

Returns
-------
merged : DataFrame

See Also
--------
merge : Merge with a database-style join.
merge_ordered : Merge with optional filling/interpolation.

Examples
--------
&gt;&gt;&gt; left = pd.DataFrame({"a": [1, 5, 10], "left_val": ["a", "b", "c"]})
&gt;&gt;&gt; left
    a left_val
0   1        a
1   5        b
2  10        c

&gt;&gt;&gt; right = pd.DataFrame({"a": [1, 2, 3, 6, 7], "right_val": [1, 2, 3, 6, 7]})
&gt;&gt;&gt; right
   a  right_val
0  1          1
1  2          2
2  3          3
3  6          6
4  7          7

&gt;&gt;&gt; pd.merge_asof(left, right, on="a")
    a left_val  right_val
0   1        a          1
1   5        b          3
2  10        c          7

&gt;&gt;&gt; pd.merge_asof(left, right, on="a", allow_exact_matches=False)
    a left_val  right_val
0   1        a        NaN
1   5        b        3.0
2  10        c        7.0

&gt;&gt;&gt; pd.merge_asof(left, right, on="a", direction="forward")
    a left_val  right_val
0   1        a        1.0
1   5        b        6.0
2  10        c        NaN

&gt;&gt;&gt; pd.merge_asof(left, right, on="a", direction="nearest")
    a left_val  right_val
0   1        a          1
1   5        b          6
2  10        c          7

We can use indexed DataFrames as well.

&gt;&gt;&gt; left = pd.DataFrame({"left_val": ["a", "b", "c"]}, index=[1, 5, 10])
&gt;&gt;&gt; left
   left_val
1         a
5         b
10        c

&gt;&gt;&gt; right = pd.DataFrame({"right_val": [1, 2, 3, 6, 7]}, index=[1, 2, 3, 6, 7])
&gt;&gt;&gt; right
   right_val
1          1
2          2
3          3
6          6
7          7

&gt;&gt;&gt; pd.merge_asof(left, right, left_index=True, right_index=True)
   left_val  right_val
1         a          1
5         b          3
10        c          7

Here is a real-world times-series example

&gt;&gt;&gt; quotes = pd.DataFrame(
...     {
...         "time": [
...             pd.Timestamp("2016-05-25 13:30:00.023"),
...             pd.Timestamp("2016-05-25 13:30:00.023"),
...             pd.Timestamp("2016-05-25 13:30:00.030"),
...             pd.Timestamp("2016-05-25 13:30:00.041"),
...             pd.Timestamp("2016-05-25 13:30:00.048"),
...             pd.Timestamp("2016-05-25 13:30:00.049"),
...             pd.Timestamp("2016-05-25 13:30:00.072"),
...             pd.Timestamp("2016-05-25 13:30:00.075")
...         ],
...         "ticker": [
...                "GOOG",
...                "MSFT",
...                "MSFT",
...                "MSFT",
...                "GOOG",
...                "AAPL",
...                "GOOG",
...                "MSFT"
...            ],
...            "bid": [720.50, 51.95, 51.97, 51.99, 720.50, 97.99, 720.50, 52.01],
...            "ask": [720.93, 51.96, 51.98, 52.00, 720.93, 98.01, 720.88, 52.03]
...     }
... )
&gt;&gt;&gt; quotes
                     time ticker     bid     ask
0 2016-05-25 13:30:00.023   GOOG  720.50  720.93
1 2016-05-25 13:30:00.023   MSFT   51.95   51.96
2 2016-05-25 13:30:00.030   MSFT   51.97   51.98
3 2016-05-25 13:30:00.041   MSFT   51.99   52.00
4 2016-05-25 13:30:00.048   GOOG  720.50  720.93
5 2016-05-25 13:30:00.049   AAPL   97.99   98.01
6 2016-05-25 13:30:00.072   GOOG  720.50  720.88
7 2016-05-25 13:30:00.075   MSFT   52.01   52.03

&gt;&gt;&gt; trades = pd.DataFrame(
...        {
...            "time": [
...                pd.Timestamp("2016-05-25 13:30:00.023"),
...                pd.Timestamp("2016-05-25 13:30:00.038"),
...                pd.Timestamp("2016-05-25 13:30:00.048"),
...                pd.Timestamp("2016-05-25 13:30:00.048"),
...                pd.Timestamp("2016-05-25 13:30:00.048")
...            ],
...            "ticker": ["MSFT", "MSFT", "GOOG", "GOOG", "AAPL"],
...            "price": [51.95, 51.95, 720.77, 720.92, 98.0],
...            "quantity": [75, 155, 100, 100, 100]
...        }
...    )
&gt;&gt;&gt; trades
                     time ticker   price  quantity
0 2016-05-25 13:30:00.023   MSFT   51.95        75
1 2016-05-25 13:30:00.038   MSFT   51.95       155
2 2016-05-25 13:30:00.048   GOOG  720.77       100
3 2016-05-25 13:30:00.048   GOOG  720.92       100
4 2016-05-25 13:30:00.048   AAPL   98.00       100

By default we are taking the asof of the quotes

&gt;&gt;&gt; pd.merge_asof(trades, quotes, on="time", by="ticker")
                     time ticker   price  quantity     bid     ask
0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96
1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98
2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93
3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93
4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN

We only asof within 2ms between the quote time and the trade time

&gt;&gt;&gt; pd.merge_asof(
...     trades, quotes, on="time", by="ticker", tolerance=pd.Timedelta("2ms")
... )
                     time ticker   price  quantity     bid     ask
0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96
1 2016-05-25 13:30:00.038   MSFT   51.95       155     NaN     NaN
2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93
3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93
4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN

We only asof within 10ms between the quote time and the trade time
and we exclude exact matches on time. However *prior* data will
propagate forward

&gt;&gt;&gt; pd.merge_asof(
...     trades,
...     quotes,
...     on="time",
...     by="ticker",
...     tolerance=pd.Timedelta("10ms"),
...     allow_exact_matches=False
... )
                     time ticker   price  quantity     bid     ask
0 2016-05-25 13:30:00.023   MSFT   51.95        75     NaN     NaN
1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98
2 2016-05-25 13:30:00.048   GOOG  720.77       100     NaN     NaN
3 2016-05-25 13:30:00.048   GOOG  720.92       100     NaN     NaN
4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN
</pre> <div class="fragment"><div class="line"><span class="lineno">  343</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  344</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    Perform a merge by key distance.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    This is similar to a left-join except that we match on nearest</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    key rather than equal keys. Both DataFrames must be sorted by the key.</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">    For each row in the left DataFrame:</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">      - A &quot;backward&quot; search selects the last row in the right DataFrame whose</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">        &#39;on&#39; key is less than or equal to the left&#39;s key.</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">      - A &quot;forward&quot; search selects the first row in the right DataFrame whose</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        &#39;on&#39; key is greater than or equal to the left&#39;s key.</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">      - A &quot;nearest&quot; search selects the row in the right DataFrame whose &#39;on&#39;</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">        key is closest in absolute distance to the left&#39;s key.</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    The default is &quot;backward&quot; and is compatible in versions below 0.20.0.</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    The direction parameter was added in version 0.20.0 and introduces</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    &quot;forward&quot; and &quot;nearest&quot;.</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    Optionally match on equivalent keys with &#39;by&#39; before searching with &#39;on&#39;.</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    left : DataFrame or named Series</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    right : DataFrame or named Series</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    on : label</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">        Field name to join on. Must be found in both DataFrames.</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">        The data MUST be ordered. Furthermore this must be a numeric column,</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        such as datetimelike, integer, or float. On or left_on/right_on</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        must be given.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    left_on : label</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        Field name to join on in left DataFrame.</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    right_on : label</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        Field name to join on in right DataFrame.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    left_index : bool</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">        Use the index of the left DataFrame as the join key.</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">    right_index : bool</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        Use the index of the right DataFrame as the join key.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    by : column name or list of column names</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">        Match on these columns before performing merge operation.</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    left_by : column name</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        Field names to match on in the left DataFrame.</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    right_by : column name</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">        Field names to match on in the right DataFrame.</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    suffixes : 2-length sequence (tuple, list, ...)</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        Suffix to apply to overlapping column names in the left and right</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">        side, respectively.</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    tolerance : int or Timedelta, optional, default None</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">        Select asof tolerance within this range; must be compatible</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">        with the merge index.</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    allow_exact_matches : bool, default True</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        - If True, allow matching with the same &#39;on&#39; value</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">          (i.e. less-than-or-equal-to / greater-than-or-equal-to)</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        - If False, don&#39;t match the same &#39;on&#39; value</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">          (i.e., strictly less-than / strictly greater-than).</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">    direction : &#39;backward&#39; (default), &#39;forward&#39;, or &#39;nearest&#39;</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral">        Whether to search for prior, subsequent, or closest matches.</span></div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    merged : DataFrame</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    merge : Merge with a database-style join.</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    merge_ordered : Merge with optional filling/interpolation.</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    &gt;&gt;&gt; left = pd.DataFrame({&quot;a&quot;: [1, 5, 10], &quot;left_val&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]})</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    &gt;&gt;&gt; left</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">        a left_val</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    0   1        a</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    1   5        b</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">    2  10        c</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">    &gt;&gt;&gt; right = pd.DataFrame({&quot;a&quot;: [1, 2, 3, 6, 7], &quot;right_val&quot;: [1, 2, 3, 6, 7]})</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    &gt;&gt;&gt; right</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">       a  right_val</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    0  1          1</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    1  2          2</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    2  3          3</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">    3  6          6</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    4  7          7</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;)</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">        a left_val  right_val</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    0   1        a          1</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    1   5        b          3</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    2  10        c          7</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;, allow_exact_matches=False)</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">        a left_val  right_val</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    0   1        a        NaN</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    1   5        b        3.0</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    2  10        c        7.0</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;, direction=&quot;forward&quot;)</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">        a left_val  right_val</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    0   1        a        1.0</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    1   5        b        6.0</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    2  10        c        NaN</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;, direction=&quot;nearest&quot;)</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        a left_val  right_val</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    0   1        a          1</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    1   5        b          6</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    2  10        c          7</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">    We can use indexed DataFrames as well.</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">    &gt;&gt;&gt; left = pd.DataFrame({&quot;left_val&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}, index=[1, 5, 10])</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">    &gt;&gt;&gt; left</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">       left_val</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">    1         a</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">    5         b</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    10        c</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    &gt;&gt;&gt; right = pd.DataFrame({&quot;right_val&quot;: [1, 2, 3, 6, 7]}, index=[1, 2, 3, 6, 7])</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    &gt;&gt;&gt; right</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">       right_val</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    1          1</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    2          2</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    3          3</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">    6          6</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    7          7</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(left, right, left_index=True, right_index=True)</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">       left_val  right_val</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">    1         a          1</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">    5         b          3</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">    10        c          7</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">    Here is a real-world times-series example</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">    &gt;&gt;&gt; quotes = pd.DataFrame(</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    ...     {</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">    ...         &quot;time&quot;: [</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.023&quot;),</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.023&quot;),</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.030&quot;),</span></div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.041&quot;),</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;),</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.049&quot;),</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.072&quot;),</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.075&quot;)</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    ...         ],</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    ...         &quot;ticker&quot;: [</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    ...                &quot;GOOG&quot;,</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    ...                &quot;MSFT&quot;,</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    ...                &quot;MSFT&quot;,</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    ...                &quot;MSFT&quot;,</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    ...                &quot;GOOG&quot;,</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    ...                &quot;AAPL&quot;,</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">    ...                &quot;GOOG&quot;,</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">    ...                &quot;MSFT&quot;</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">    ...            ],</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">    ...            &quot;bid&quot;: [720.50, 51.95, 51.97, 51.99, 720.50, 97.99, 720.50, 52.01],</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">    ...            &quot;ask&quot;: [720.93, 51.96, 51.98, 52.00, 720.93, 98.01, 720.88, 52.03]</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    ...     }</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    &gt;&gt;&gt; quotes</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">                         time ticker     bid     ask</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">    0 2016-05-25 13:30:00.023   GOOG  720.50  720.93</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    1 2016-05-25 13:30:00.023   MSFT   51.95   51.96</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    2 2016-05-25 13:30:00.030   MSFT   51.97   51.98</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    3 2016-05-25 13:30:00.041   MSFT   51.99   52.00</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    4 2016-05-25 13:30:00.048   GOOG  720.50  720.93</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    5 2016-05-25 13:30:00.049   AAPL   97.99   98.01</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">    6 2016-05-25 13:30:00.072   GOOG  720.50  720.88</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    7 2016-05-25 13:30:00.075   MSFT   52.01   52.03</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    &gt;&gt;&gt; trades = pd.DataFrame(</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">    ...        {</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    ...            &quot;time&quot;: [</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.023&quot;),</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.038&quot;),</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;),</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;),</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;)</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    ...            ],</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    ...            &quot;ticker&quot;: [&quot;MSFT&quot;, &quot;MSFT&quot;, &quot;GOOG&quot;, &quot;GOOG&quot;, &quot;AAPL&quot;],</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">    ...            &quot;price&quot;: [51.95, 51.95, 720.77, 720.92, 98.0],</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    ...            &quot;quantity&quot;: [75, 155, 100, 100, 100]</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    ...        }</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    ...    )</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    &gt;&gt;&gt; trades</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">                         time ticker   price  quantity</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    0 2016-05-25 13:30:00.023   MSFT   51.95        75</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    1 2016-05-25 13:30:00.038   MSFT   51.95       155</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    2 2016-05-25 13:30:00.048   GOOG  720.77       100</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    3 2016-05-25 13:30:00.048   GOOG  720.92       100</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    4 2016-05-25 13:30:00.048   AAPL   98.00       100</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    By default we are taking the asof of the quotes</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(trades, quotes, on=&quot;time&quot;, by=&quot;ticker&quot;)</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">                         time ticker   price  quantity     bid     ask</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    We only asof within 2ms between the quote time and the trade time</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    ...     trades, quotes, on=&quot;time&quot;, by=&quot;ticker&quot;, tolerance=pd.Timedelta(&quot;2ms&quot;)</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">                         time ticker   price  quantity     bid     ask</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    1 2016-05-25 13:30:00.038   MSFT   51.95       155     NaN     NaN</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    We only asof within 10ms between the quote time and the trade time</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    and we exclude exact matches on time. However *prior* data will</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    propagate forward</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    &gt;&gt;&gt; pd.merge_asof(</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    ...     trades,</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    ...     quotes,</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    ...     on=&quot;time&quot;,</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    ...     by=&quot;ticker&quot;,</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    ...     tolerance=pd.Timedelta(&quot;10ms&quot;),</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">    ...     allow_exact_matches=False</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">                         time ticker   price  quantity     bid     ask</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    0 2016-05-25 13:30:00.023   MSFT   51.95        75     NaN     NaN</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    2 2016-05-25 13:30:00.048   GOOG  720.77       100     NaN     NaN</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    3 2016-05-25 13:30:00.048   GOOG  720.92       100     NaN     NaN</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  583</span>    op = _AsOfMerge(</div>
<div class="line"><span class="lineno">  584</span>        left,</div>
<div class="line"><span class="lineno">  585</span>        right,</div>
<div class="line"><span class="lineno">  586</span>        on=on,</div>
<div class="line"><span class="lineno">  587</span>        left_on=left_on,</div>
<div class="line"><span class="lineno">  588</span>        right_on=right_on,</div>
<div class="line"><span class="lineno">  589</span>        left_index=left_index,</div>
<div class="line"><span class="lineno">  590</span>        right_index=right_index,</div>
<div class="line"><span class="lineno">  591</span>        by=by,</div>
<div class="line"><span class="lineno">  592</span>        left_by=left_by,</div>
<div class="line"><span class="lineno">  593</span>        right_by=right_by,</div>
<div class="line"><span class="lineno">  594</span>        suffixes=suffixes,</div>
<div class="line"><span class="lineno">  595</span>        how=<span class="stringliteral">&quot;asof&quot;</span>,</div>
<div class="line"><span class="lineno">  596</span>        tolerance=tolerance,</div>
<div class="line"><span class="lineno">  597</span>        allow_exact_matches=allow_exact_matches,</div>
<div class="line"><span class="lineno">  598</span>        direction=direction,</div>
<div class="line"><span class="lineno">  599</span>    )</div>
<div class="line"><span class="lineno">  600</span>    <span class="keywordflow">return</span> op.get_result()</div>
<div class="line"><span class="lineno">  601</span> </div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span><span class="comment"># TODO: transformations??</span></div>
<div class="line"><span class="lineno">  604</span><span class="comment"># TODO: only copy DataFrames when modification necessary</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a646e354e6c0a1700a8076da5b0d6237c" name="a646e354e6c0a1700a8076da5b0d6237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646e354e6c0a1700a8076da5b0d6237c">&#9670;&#160;</a></span>merge_ordered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.core.reshape.merge.merge_ordered </td>
          <td>(</td>
          <td class="paramtype">DataFrame&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataFrame&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>left_on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexLabel | None &#160;</td>
          <td class="paramname"><em>right_on</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left_by</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right_by</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>fill_method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Suffixes &#160;</td>
          <td class="paramname"><em>suffixes</em> = <code>(&quot;_x&quot;,&#160;&quot;_y&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;outer&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a merge for ordered data with optional filling/interpolation.

Designed for ordered data like time series data. Optionally
perform group-wise merge (see examples).

Parameters
----------
left : DataFrame
right : DataFrame
on : label or list
    Field names to join on. Must be found in both DataFrames.
left_on : label or list, or array-like
    Field names to join on in left DataFrame. Can be a vector or list of
    vectors of the length of the DataFrame to use a particular vector as
    the join key instead of columns.
right_on : label or list, or array-like
    Field names to join on in right DataFrame or vector/list of vectors per
    left_on docs.
left_by : column name or list of column names
    Group left DataFrame by group columns and merge piece by piece with
    right DataFrame.
right_by : column name or list of column names
    Group right DataFrame by group columns and merge piece by piece with
    left DataFrame.
fill_method : {'ffill', None}, default None
    Interpolation method for data.
suffixes : list-like, default is ("_x", "_y")
    A length-2 sequence where each element is optionally a string
    indicating the suffix to add to overlapping column names in
    `left` and `right` respectively. Pass a value of `None` instead
    of a string to indicate that the column name from `left` or
    `right` should be left as-is, with no suffix. At least one of the
    values must not be None.

    .. versionchanged:: 0.25.0
how : {'left', 'right', 'outer', 'inner'}, default 'outer'
    * left: use only keys from left frame (SQL: left outer join)
    * right: use only keys from right frame (SQL: right outer join)
    * outer: use union of keys from both frames (SQL: full outer join)
    * inner: use intersection of keys from both frames (SQL: inner join).

Returns
-------
DataFrame
    The merged DataFrame output type will the be same as
    'left', if it is a subclass of DataFrame.

See Also
--------
merge : Merge with a database-style join.
merge_asof : Merge on nearest keys.

Examples
--------
&gt;&gt;&gt; df1 = pd.DataFrame(
...     {
...         "key": ["a", "c", "e", "a", "c", "e"],
...         "lvalue": [1, 2, 3, 1, 2, 3],
...         "group": ["a", "a", "a", "b", "b", "b"]
...     }
... )
&gt;&gt;&gt; df1
      key  lvalue group
0   a       1     a
1   c       2     a
2   e       3     a
3   a       1     b
4   c       2     b
5   e       3     b

&gt;&gt;&gt; df2 = pd.DataFrame({"key": ["b", "c", "d"], "rvalue": [1, 2, 3]})
&gt;&gt;&gt; df2
      key  rvalue
0   b       1
1   c       2
2   d       3

&gt;&gt;&gt; merge_ordered(df1, df2, fill_method="ffill", left_by="group")
  key  lvalue group  rvalue
0   a       1     a     NaN
1   b       1     a     1.0
2   c       2     a     2.0
3   d       2     a     3.0
4   e       3     a     3.0
5   a       1     b     NaN
6   b       1     b     1.0
7   c       2     b     2.0
8   d       2     b     3.0
9   e       3     b     3.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  198</span>) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  199</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    Perform a merge for ordered data with optional filling/interpolation.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    Designed for ordered data like time series data. Optionally</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">    perform group-wise merge (see examples).</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    left : DataFrame</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    right : DataFrame</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    on : label or list</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        Field names to join on. Must be found in both DataFrames.</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    left_on : label or list, or array-like</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        Field names to join on in left DataFrame. Can be a vector or list of</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        vectors of the length of the DataFrame to use a particular vector as</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        the join key instead of columns.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    right_on : label or list, or array-like</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        Field names to join on in right DataFrame or vector/list of vectors per</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">        left_on docs.</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    left_by : column name or list of column names</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        Group left DataFrame by group columns and merge piece by piece with</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        right DataFrame.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    right_by : column name or list of column names</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        Group right DataFrame by group columns and merge piece by piece with</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">        left DataFrame.</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    fill_method : {&#39;ffill&#39;, None}, default None</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">        Interpolation method for data.</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    suffixes : list-like, default is (&quot;_x&quot;, &quot;_y&quot;)</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">        A length-2 sequence where each element is optionally a string</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">        indicating the suffix to add to overlapping column names in</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">        `left` and `right` respectively. Pass a value of `None` instead</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        of a string to indicate that the column name from `left` or</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        `right` should be left as-is, with no suffix. At least one of the</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        values must not be None.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        .. versionchanged:: 0.25.0</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    how : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;}, default &#39;outer&#39;</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        * left: use only keys from left frame (SQL: left outer join)</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">        * right: use only keys from right frame (SQL: right outer join)</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        * outer: use union of keys from both frames (SQL: full outer join)</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        * inner: use intersection of keys from both frames (SQL: inner join).</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    DataFrame</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        The merged DataFrame output type will the be same as</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        &#39;left&#39;, if it is a subclass of DataFrame.</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">    merge : Merge with a database-style join.</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    merge_asof : Merge on nearest keys.</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    &gt;&gt;&gt; df1 = pd.DataFrame(</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    ...     {</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    ...         &quot;key&quot;: [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;a&quot;, &quot;c&quot;, &quot;e&quot;],</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    ...         &quot;lvalue&quot;: [1, 2, 3, 1, 2, 3],</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    ...         &quot;group&quot;: [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;]</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">    ...     }</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    ... )</span></div>
<div class="line"><span class="lineno">  261</span><span class="stringliteral">    &gt;&gt;&gt; df1</span></div>
<div class="line"><span class="lineno">  262</span><span class="stringliteral">          key  lvalue group</span></div>
<div class="line"><span class="lineno">  263</span><span class="stringliteral">    0   a       1     a</span></div>
<div class="line"><span class="lineno">  264</span><span class="stringliteral">    1   c       2     a</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    2   e       3     a</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral">    3   a       1     b</span></div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    4   c       2     b</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    5   e       3     b</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    &gt;&gt;&gt; df2 = pd.DataFrame({&quot;key&quot;: [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;], &quot;rvalue&quot;: [1, 2, 3]})</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    &gt;&gt;&gt; df2</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">          key  rvalue</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    0   b       1</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    1   c       2</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    2   d       3</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    &gt;&gt;&gt; merge_ordered(df1, df2, fill_method=&quot;ffill&quot;, left_by=&quot;group&quot;)</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">      key  lvalue group  rvalue</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    0   a       1     a     NaN</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    1   b       1     a     1.0</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    2   c       2     a     2.0</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    3   d       2     a     3.0</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    4   e       3     a     3.0</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    5   a       1     b     NaN</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    6   b       1     b     1.0</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    7   c       2     b     2.0</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    8   d       2     b     3.0</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    9   e       3     b     3.0</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>    <span class="keyword">def </span>_merger(x, y) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  292</span>        <span class="comment"># perform the ordered merge operation</span></div>
<div class="line"><span class="lineno">  293</span>        op = _OrderedMerge(</div>
<div class="line"><span class="lineno">  294</span>            x,</div>
<div class="line"><span class="lineno">  295</span>            y,</div>
<div class="line"><span class="lineno">  296</span>            on=on,</div>
<div class="line"><span class="lineno">  297</span>            left_on=left_on,</div>
<div class="line"><span class="lineno">  298</span>            right_on=right_on,</div>
<div class="line"><span class="lineno">  299</span>            suffixes=suffixes,</div>
<div class="line"><span class="lineno">  300</span>            fill_method=fill_method,</div>
<div class="line"><span class="lineno">  301</span>            how=how,</div>
<div class="line"><span class="lineno">  302</span>        )</div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordflow">return</span> op.get_result()</div>
<div class="line"><span class="lineno">  304</span> </div>
<div class="line"><span class="lineno">  305</span>    <span class="keywordflow">if</span> left_by <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> right_by <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  306</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Can only group either left or right frames&quot;</span>)</div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">elif</span> left_by <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  308</span>        <span class="keywordflow">if</span> isinstance(left_by, str):</div>
<div class="line"><span class="lineno">  309</span>            left_by = [left_by]</div>
<div class="line"><span class="lineno">  310</span>        check = set(left_by).difference(left.columns)</div>
<div class="line"><span class="lineno">  311</span>        <span class="keywordflow">if</span> len(check) != 0:</div>
<div class="line"><span class="lineno">  312</span>            <span class="keywordflow">raise</span> KeyError(f<span class="stringliteral">&quot;{check} not found in left columns&quot;</span>)</div>
<div class="line"><span class="lineno">  313</span>        result, _ = _groupby_and_merge(left_by, left, right, <span class="keyword">lambda</span> x, y: _merger(x, y))</div>
<div class="line"><span class="lineno">  314</span>    <span class="keywordflow">elif</span> right_by <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  315</span>        <span class="keywordflow">if</span> isinstance(right_by, str):</div>
<div class="line"><span class="lineno">  316</span>            right_by = [right_by]</div>
<div class="line"><span class="lineno">  317</span>        check = set(right_by).difference(right.columns)</div>
<div class="line"><span class="lineno">  318</span>        <span class="keywordflow">if</span> len(check) != 0:</div>
<div class="line"><span class="lineno">  319</span>            <span class="keywordflow">raise</span> KeyError(f<span class="stringliteral">&quot;{check} not found in right columns&quot;</span>)</div>
<div class="line"><span class="lineno">  320</span>        result, _ = _groupby_and_merge(</div>
<div class="line"><span class="lineno">  321</span>            right_by, right, left, <span class="keyword">lambda</span> x, y: _merger(y, x)</div>
<div class="line"><span class="lineno">  322</span>        )</div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  324</span>        result = _merger(left, right)</div>
<div class="line"><span class="lineno">  325</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afd8ba232918fd1041ae30e81bd176185" name="afd8ba232918fd1041ae30e81bd176185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8ba232918fd1041ae30e81bd176185">&#9670;&#160;</a></span>restore_dropped_levels_multijoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[list[Index], npt.NDArray[np.intp], list[Hashable]] pandas.core.reshape.merge.restore_dropped_levels_multijoin </td>
          <td>(</td>
          <td class="paramtype">MultiIndex&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiIndex&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dropped_level_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>join_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>lindexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>rindexer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">*this is an internal non-public method*

Returns the levels, labels and names of a multi-index to multi-index join.
Depending on the type of join, this method restores the appropriate
dropped levels of the joined multi-index.
The method relies on lidx, rindexer which hold the index positions of
left and right, where a join was feasible

Parameters
----------
left : MultiIndex
    left index
right : MultiIndex
    right index
dropped_level_names : str array
    list of non-common level names
join_index : Index
    the index of the join between the
    common levels of left and right
lindexer : np.ndarray[np.intp]
    left indexer
rindexer : np.ndarray[np.intp]
    right indexer

Returns
-------
levels : list of Index
    levels of combined multiindexes
labels : np.ndarray[np.intp]
    labels of combined multiindexes
names : List[Hashable]
    names of combined multiindex levels</pre> <div class="fragment"><div class="line"><span class="lineno"> 1620</span>) -&gt; tuple[list[Index], npt.NDArray[np.intp], list[Hashable]]:</div>
<div class="line"><span class="lineno"> 1621</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">    *this is an internal non-public method*</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral">    Returns the levels, labels and names of a multi-index to multi-index join.</span></div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">    Depending on the type of join, this method restores the appropriate</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral">    dropped levels of the joined multi-index.</span></div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">    The method relies on lidx, rindexer which hold the index positions of</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">    left and right, where a join was feasible</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">    left : MultiIndex</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral">        left index</span></div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">    right : MultiIndex</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral">        right index</span></div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">    dropped_level_names : str array</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">        list of non-common level names</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">    join_index : Index</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">        the index of the join between the</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">        common levels of left and right</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral">    lindexer : np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">        left indexer</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral">    rindexer : np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">        right indexer</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">    levels : list of Index</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">        levels of combined multiindexes</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">    labels : np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 1651</span><span class="stringliteral">        labels of combined multiindexes</span></div>
<div class="line"><span class="lineno"> 1652</span><span class="stringliteral">    names : List[Hashable]</span></div>
<div class="line"><span class="lineno"> 1653</span><span class="stringliteral">        names of combined multiindex levels</span></div>
<div class="line"><span class="lineno"> 1654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1655</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1656</span> </div>
<div class="line"><span class="lineno"> 1657</span>    <span class="keyword">def </span>_convert_to_multiindex(index: Index) -&gt; MultiIndex:</div>
<div class="line"><span class="lineno"> 1658</span>        <span class="keywordflow">if</span> isinstance(index, MultiIndex):</div>
<div class="line"><span class="lineno"> 1659</span>            <span class="keywordflow">return</span> index</div>
<div class="line"><span class="lineno"> 1660</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1661</span>            <span class="keywordflow">return</span> MultiIndex.from_arrays([index._values], names=[index.name])</div>
<div class="line"><span class="lineno"> 1662</span> </div>
<div class="line"><span class="lineno"> 1663</span>    <span class="comment"># For multi-multi joins with one overlapping level,</span></div>
<div class="line"><span class="lineno"> 1664</span>    <span class="comment"># the returned index if of type Index</span></div>
<div class="line"><span class="lineno"> 1665</span>    <span class="comment"># Assure that join_index is of type MultiIndex</span></div>
<div class="line"><span class="lineno"> 1666</span>    <span class="comment"># so that dropped levels can be appended</span></div>
<div class="line"><span class="lineno"> 1667</span>    join_index = _convert_to_multiindex(join_index)</div>
<div class="line"><span class="lineno"> 1668</span> </div>
<div class="line"><span class="lineno"> 1669</span>    join_levels = join_index.levels</div>
<div class="line"><span class="lineno"> 1670</span>    join_codes = join_index.codes</div>
<div class="line"><span class="lineno"> 1671</span>    join_names = join_index.names</div>
<div class="line"><span class="lineno"> 1672</span> </div>
<div class="line"><span class="lineno"> 1673</span>    <span class="comment"># lindexer and rindexer hold the indexes where the join occurred</span></div>
<div class="line"><span class="lineno"> 1674</span>    <span class="comment"># for left and right respectively. If left/right is None then</span></div>
<div class="line"><span class="lineno"> 1675</span>    <span class="comment"># the join occurred on all indices of left/right</span></div>
<div class="line"><span class="lineno"> 1676</span>    <span class="keywordflow">if</span> lindexer <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1677</span>        lindexer = range(left.size)</div>
<div class="line"><span class="lineno"> 1678</span> </div>
<div class="line"><span class="lineno"> 1679</span>    <span class="keywordflow">if</span> rindexer <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1680</span>        rindexer = range(right.size)</div>
<div class="line"><span class="lineno"> 1681</span> </div>
<div class="line"><span class="lineno"> 1682</span>    <span class="comment"># Iterate through the levels that must be restored</span></div>
<div class="line"><span class="lineno"> 1683</span>    <span class="keywordflow">for</span> dropped_level_name <span class="keywordflow">in</span> dropped_level_names:</div>
<div class="line"><span class="lineno"> 1684</span>        <span class="keywordflow">if</span> dropped_level_name <span class="keywordflow">in</span> left.names:</div>
<div class="line"><span class="lineno"> 1685</span>            idx = left</div>
<div class="line"><span class="lineno"> 1686</span>            indexer = lindexer</div>
<div class="line"><span class="lineno"> 1687</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1688</span>            idx = right</div>
<div class="line"><span class="lineno"> 1689</span>            indexer = rindexer</div>
<div class="line"><span class="lineno"> 1690</span> </div>
<div class="line"><span class="lineno"> 1691</span>        <span class="comment"># The index of the level name to be restored</span></div>
<div class="line"><span class="lineno"> 1692</span>        name_idx = idx.names.index(dropped_level_name)</div>
<div class="line"><span class="lineno"> 1693</span> </div>
<div class="line"><span class="lineno"> 1694</span>        restore_levels = idx.levels[name_idx]</div>
<div class="line"><span class="lineno"> 1695</span>        <span class="comment"># Inject -1 in the codes list where a join was not possible</span></div>
<div class="line"><span class="lineno"> 1696</span>        <span class="comment"># IOW indexer[i]=-1</span></div>
<div class="line"><span class="lineno"> 1697</span>        codes = idx.codes[name_idx]</div>
<div class="line"><span class="lineno"> 1698</span>        restore_codes = algos.take_nd(codes, indexer, fill_value=-1)</div>
<div class="line"><span class="lineno"> 1699</span> </div>
<div class="line"><span class="lineno"> 1700</span>        join_levels = join_levels + [restore_levels]</div>
<div class="line"><span class="lineno"> 1701</span>        join_codes = join_codes + [restore_codes]</div>
<div class="line"><span class="lineno"> 1702</span>        join_names = join_names + [dropped_level_name]</div>
<div class="line"><span class="lineno"> 1703</span> </div>
<div class="line"><span class="lineno"> 1704</span>    <span class="keywordflow">return</span> join_levels, join_codes, join_names</div>
<div class="line"><span class="lineno"> 1705</span> </div>
<div class="line"><span class="lineno"> 1706</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a413163801386bb7302b50154b8d7ca77" name="a413163801386bb7302b50154b8d7ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413163801386bb7302b50154b8d7ca77">&#9670;&#160;</a></span>_type_casters</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.reshape.merge._type_casters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;int64_t&quot;</span>: ensure_int64,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;double&quot;</span>: ensure_float64,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;object&quot;</span>: ensure_object,</div>
<div class="line"><span class="lineno">    5</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
